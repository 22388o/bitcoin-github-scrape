[
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/899094330",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-899094330",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
    "id": 899094330,
    "node_id": "IC_kwDOABII5841lxc6",
    "user": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?u=5ff13e375b40ea55ecd3c108337dd6a23f68eddf&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-08-15T18:46:11Z",
    "updated_at": "2021-08-15T18:46:11Z",
    "author_association": "CONTRIBUTOR",
    "body": "Concept ACK\r\n\r\nThe numbers look very promising!\r\n\r\nSeems like this could be one of those rare optimization opportunities actually worth pursuing :)",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/899094330/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/899097140",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-899097140",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
    "id": 899097140,
    "node_id": "IC_kwDOABII5841lyI0",
    "user": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?u=8cdd8653982252593843d7369ecfebe432b89768&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-08-15T19:11:58Z",
    "updated_at": "2021-08-15T19:11:58Z",
    "author_association": "CONTRIBUTOR",
    "body": "I'm curious what the impact would be on the performance if you allocated N chunks at a time, always, to fill a page.\r\n\r\nE.g., if you want to allocate one node, always allocate something like `aligned_alloc(sysconf(_SC_PAGESIZE), size)` and divide it up into a bunch of pointers for the free list.\r\n\r\nCool properties of doing so: Better cache alignment on items added around the same time, fewer things to keep in the allocated chunks list, if you were to sort the list by pointer (perhaps lazily, when we're not doing anything else) you would get something with good cache alignment again. ",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/899097140/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/899241874",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-899241874",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
    "id": 899241874,
    "node_id": "IC_kwDOABII5841mVeS",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?u=da89313ed4793f9594c09c23513f49aa4dc1c141&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-08-16T05:52:41Z",
    "updated_at": "2021-08-16T05:52:41Z",
    "author_association": "CONTRIBUTOR",
    "body": "> I'm curious what the impact would be on the performance if you allocated N chunks at a time, always, to fill a page.\r\n\r\nI've run the benchmark with `::aligned_alloc(sysconf(_SC_PAGESIZE), ...);` and only allocating a single page, and at least in the benchmark there's no difference:\r\n\r\n|               ns/op |                op/s |    err% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------:|:----------\r\n|              140.95 |        7,094,953.03 |    0.2% |      0.08 | `NodeAllocator_StdUnorderedMap`\r\n|              115.57 |        8,652,942.75 |    0.1% |      0.06 | `NodeAllocator_StdUnorderedMapWithNodeAllocator` ::operator new\r\n|              115.33 |        8,670,873.08 |    0.2% |      0.06 | `NodeAllocator_StdUnorderedMapWithNodeAllocator`aligned_alloc",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/899241874/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/899359234",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-899359234",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
    "id": 899359234,
    "node_id": "IC_kwDOABII5841myIC",
    "user": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?u=8cdd8653982252593843d7369ecfebe432b89768&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-08-16T09:19:46Z",
    "updated_at": "2021-08-16T09:19:46Z",
    "author_association": "CONTRIBUTOR",
    "body": "Do you have specific code for that? The changes sounded a bit more complex than just aligning the allocator. Did you divide the allocation into N free list chunks? Or just over-allocate?",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/899359234/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/899385299",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-899385299",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
    "id": 899385299,
    "node_id": "IC_kwDOABII5841m4fT",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?u=da89313ed4793f9594c09c23513f49aa4dc1c141&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-08-16T10:03:36Z",
    "updated_at": "2021-08-16T10:03:36Z",
    "author_association": "CONTRIBUTOR",
    "body": "> Do you have specific code for that? The changes sounded a bit more complex than just aligning the allocator. Did you divide the allocation into N free list chunks? Or just over-allocate?\r\n\r\n`MemoryResource::AllocateNewBlock` is the only place where I actually malloc a new block that's divided into the chunks. Here I've replaced the `::operator new(num_chunks* m_chunk_size_bytes)` with `::alligned_alloc(sysconf(_SC_PAGESIZE), num_chunks* m_chunk_size_bytes)`. And use `free` in `~MemoryResource`.\r\nI also changed the default allocation size `m_block_size_bytes` from 262144 to `sysconf(_SC_PAGESIZE)`. \r\n\r\nSo for node size of 104 bytes and page size 4096, this should allocate a page-alligned block with 39*104=4056 bytes.",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/899385299/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/899545273",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-899545273",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
    "id": 899545273,
    "node_id": "IC_kwDOABII5841nfi5",
    "user": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-08-16T14:13:15Z",
    "updated_at": "2021-08-16T14:13:15Z",
    "author_association": "MEMBER",
    "body": "Some fresh benches in (high dbcache). Continuing to see fairly substantial time/memory improvements with this change.\r\n\r\n![ibd local range 500000 540000](https://user-images.githubusercontent.com/73197/129577300-d73f42aa-8598-4418-9375-2a7c4521701a.png)\r\n\r\n#### commands index\r\n|          bench name           |                                                                                                     command                                                                                                      |\r\n|-------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\r\n| ibd.local.range.500000.540000 | `bitcoind -dbcache=10000 -debug=coindb -debug=bench -listen=0 -connect=0 -addnode=127.0.0.1:8888 -prune=9999999 -printtoconsole=0 -assumevalid=000000000000000000176c192f42ad13ab159fdb20198b87e7ba3c001e47b876` |\r\n\r\n\r\n#### #22702 vs. $mergebase (absolute)\r\n|                  bench name                   |  x  |           #22702           |        $mergebase         |\r\n|-----------------------------------------------|----:|----------------------------|---------------------------|\r\n| ibd.local.range.500000.540000.total_secs      |   3 | 2888.4055 (\u00b1 24.7775)      | 3131.5871 (\u00b1 4.8045)      |\r\n| ibd.local.range.500000.540000.peak_rss_KiB    |   3 | 5886729.3333 (\u00b1 3815.6315) | 6352470.6667 (\u00b1 979.1552) |\r\n| ibd.local.range.500000.540000.cpu_kernel_secs |   3 | 263.5433 (\u00b1 1.9605)        | 269.2233 (\u00b1 2.6299)       |\r\n| ibd.local.range.500000.540000.cpu_user_secs   |   3 | 12852.1300 (\u00b1 15.0661)     | 13134.5300 (\u00b1 2.9587)     |\r\n\r\n\r\n#### #22702 vs. $mergebase (relative)\r\n|                  bench name                   |  x  | #22702 | $mergebase |\r\n|-----------------------------------------------|----:|-------:|-----------:|\r\n| ibd.local.range.500000.540000.total_secs      |   3 |      1 |      1.084 |\r\n| ibd.local.range.500000.540000.peak_rss_KiB    |   3 |      1 |      1.079 |\r\n| ibd.local.range.500000.540000.cpu_kernel_secs |   3 |      1 |      1.022 |\r\n| ibd.local.range.500000.540000.cpu_user_secs   |   3 |      1 |      1.022 |\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/899545273/reactions",
      "total_count": 4,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 4,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/899698242",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-899698242",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
    "id": 899698242,
    "node_id": "IC_kwDOABII5841oE5C",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?u=da89313ed4793f9594c09c23513f49aa4dc1c141&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-08-16T17:46:45Z",
    "updated_at": "2021-08-16T17:46:45Z",
    "author_association": "CONTRIBUTOR",
    "body": "Thanks for the benchmark! Good to see its 8.4% faster. I think the only reason the memory is lower is because the `memusage::DynamicUsage` now overestimates the memory requirements of the `std::unordered_map` that uses the node_allocator. I guess I should correct that. Then the memory usage should stay roughly the same (as it should, that's what `-dbcache` is for), but the number of transactions that can be cached will increase.",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/899698242/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/899759585",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-899759585",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
    "id": 899759585,
    "node_id": "IC_kwDOABII5841oT3h",
    "user": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?u=8cdd8653982252593843d7369ecfebe432b89768&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-08-16T19:22:09Z",
    "updated_at": "2021-08-16T19:22:09Z",
    "author_association": "CONTRIBUTOR",
    "body": "> `MemoryResource::AllocateNewBlock` is the only place where I actually malloc a new block that's divided into the chunks. Here I've replaced the `::operator new(num_chunks* m_chunk_size_bytes)` with `::alligned_alloc(sysconf(_SC_PAGESIZE), num_chunks* m_chunk_size_bytes)`. And use `free` in `~MemoryResource`.\r\n> I also changed the default allocation size `m_block_size_bytes` from 262144 to `sysconf(_SC_PAGESIZE)`.\r\n\r\nhmm yeah it's interesting to think through the alignment issues. I think I understand the code a bit better now so it makes sense that most of you allocations are already aligned. One thing that strikes me is that it seems that you have these 104 byte chunks (13 uint64_t s). You might get better properties if you pad them out to the nearest 32/64/128 bytes (memory overhead 24 bytes :( ), because then you'll never have nodes across cache lines. Memory usage is a bit worse though, but cache perfomance may be better this way? https://www.usenix.org/legacy/publications/library/proceedings/als00/2000papers/papers/full_papers/sears/sears_html/index.html for reference.\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/899759585/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/899763888",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-899763888",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
    "id": 899763888,
    "node_id": "IC_kwDOABII5841oU6w",
    "user": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?u=8cdd8653982252593843d7369ecfebe432b89768&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-08-16T19:29:56Z",
    "updated_at": "2021-08-16T19:29:56Z",
    "author_association": "CONTRIBUTOR",
    "body": "might also be interesting to bump the CScript prevector size from 28 to 35 (7 bytes). This would help with the above as well because if we're 104/128 byte aligned we have the capacity & then we'd also save a prevector allocation (which means the vector costs 25 bytes + 34-35 bytes) for a non p2sh segwit v0-v1 output, and also means even more indirection.\r\n\r\nThis might have system impacts very broadly because prevector is a leaky optimization sadly.",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/899763888/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/900662089",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-900662089",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
    "id": 900662089,
    "node_id": "IC_kwDOABII5841rwNJ",
    "user": {
      "login": "0xB10C",
      "id": 19157360,
      "node_id": "MDQ6VXNlcjE5MTU3MzYw",
      "avatar_url": "https://avatars.githubusercontent.com/u/19157360?u=a20996a145f1be613c7b0a57e75d36508572e29d&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/0xB10C",
      "html_url": "https://github.com/0xB10C",
      "followers_url": "https://api.github.com/users/0xB10C/followers",
      "following_url": "https://api.github.com/users/0xB10C/following{/other_user}",
      "gists_url": "https://api.github.com/users/0xB10C/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/0xB10C/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/0xB10C/subscriptions",
      "organizations_url": "https://api.github.com/users/0xB10C/orgs",
      "repos_url": "https://api.github.com/users/0xB10C/repos",
      "events_url": "https://api.github.com/users/0xB10C/events{/privacy}",
      "received_events_url": "https://api.github.com/users/0xB10C/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-08-17T22:04:46Z",
    "updated_at": "2021-08-20T18:32:00Z",
    "author_association": "CONTRIBUTOR",
    "body": "I've benchmarked the performance of `CChainState::ConnectBlock` between cde8a991f525b72d3a7ac76e0c83aaa611169f22 (PR) and the mergebase 803ef70fd9f65ef800567ff9456fac525bc3e3c2 (MB) using the [`validation::connect_block`](https://github.com/bitcoin/bitcoin/blob/master/doc/tracing.md#tracepoint-validationblock_connected) tracepoint. The tracepoint reports the time it took to connect each block. This means my results don't include the time it took to download and, AFAIK, not the time it took to persist the block to disk. I didn't look at memory usage. \r\n\r\nI've oriented myself on @jamesob's parameters and synced the blocks 500.000 to 540.000 from a localhost peer three times for the PR and the MB. I used the default dbcache (shouldn't matter for my measurements as cache flushes don't happen while inside `CChainState::ConnectBlock`). I've used an idle workstation with an i5 6500 and an NVME drive. Room and hardware temperature between runs changed which could have impacted performance. A `bpftrace` script to hook into the tracepoint can be found [here](https://gist.github.com/0xB10C/7f9010d44f1d97fbf1c83ec7f98155fd).\r\n\r\nTotal time spent in  `CChainState::ConnectBlock` per run for PR and MB: \r\n| run | 1         | 2     | 3     | \r\n|-----|-----------|-------|-------|\r\n| PR  | **1427s** | 1487s | 1486s | \r\n| MB  | **1577s** | 1670s | 1661s |\r\n\r\n![image](https://user-images.githubusercontent.com/19157360/129805353-5b48c0c1-1184-49c2-800c-196f1eed89c8.png)\r\n(PR run 2 and run 3 are overlapping quite a bit and indistinguishably here)\r\n\r\nMy results confirm that less time is spent in `CChainState::ConnectBlock` with PR compared to MB. A performance improvement between 6% - 10% is likely. \r\n\r\n\r\nTo rule out temperature effects on performance, these measurements could be redone with a properly cooled server/workstation.\r\n\r\n---\r\n\r\n**EDIT:** I did another three runs of PR and MB with calling `pyperf system tune` beforehand as @martinus suggested. PR is still faster.\r\n\r\n| run | 4         | 5     | 6     | \r\n|-----|-----------|-------|-------|\r\n| PR  | 1585s | **1537s** | 1546s | \r\n| MB  | 1647s | 1688s | **1644s** |\r\n\r\n![image](https://user-images.githubusercontent.com/19157360/130277740-548c4070-8dfd-4059-b8eb-acf152a8728f.png)\r\n \r\n\r\n\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/900662089/reactions",
      "total_count": 4,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 1,
      "confused": 0,
      "heart": 2,
      "rocket": 1,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/900871568",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-900871568",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
    "id": 900871568,
    "node_id": "IC_kwDOABII5841sjWQ",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?u=da89313ed4793f9594c09c23513f49aa4dc1c141&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-08-18T07:03:09Z",
    "updated_at": "2021-08-18T07:03:09Z",
    "author_association": "CONTRIBUTOR",
    "body": "@JeremyRubin I actually tried to bump it up to 128 byte to see what that does, but I didn't see any major difference. The benchmark got maybe 1% slower, but maybe the benchmark is also not very realistic. I also tried to reduce the size by 8 byte (which can be done by making use of the `Coin`'s padding in `CCoinsCacheEntry`, I might open anothe PR for that), and it got about ~1% faster. I think though that even with no performance benefit the node_allocator is worthwhile because it has lower memory overhead, so we can cache more entries with the same `-dbcache` setting.\r\n\r\n@jonatack Thanks for the review! I'm not sure though how I should best incorporate your changes? Should I copy them and add a `Co-authored-by` in the commit message? (I've never done that)\r\n\r\n@0xB10C Thanks for the benchmark! You might get a bit more stable result with [pyperf](https://pyperf.readthedocs.io/en/latest/): I always use `sudo pyperf system tune` before I run a benchmark which does a few things to make benchmarks much more stable (e.g. locks the CPU to a fixed frequency, disables turbo boost)",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/900871568/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/901426870",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-901426870",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
    "id": 901426870,
    "node_id": "IC_kwDOABII5841uq62",
    "user": {
      "login": "jonatack",
      "id": 2415484,
      "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2415484?u=3f68150a5f30acd541d1ed279376cd20b78046b1&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonatack",
      "html_url": "https://github.com/jonatack",
      "followers_url": "https://api.github.com/users/jonatack/followers",
      "following_url": "https://api.github.com/users/jonatack/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonatack/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
      "organizations_url": "https://api.github.com/users/jonatack/orgs",
      "repos_url": "https://api.github.com/users/jonatack/repos",
      "events_url": "https://api.github.com/users/jonatack/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonatack/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-08-18T21:00:09Z",
    "updated_at": "2021-08-18T21:00:09Z",
    "author_association": "MEMBER",
    "body": "> @jonatack Thanks for the review! I'm not sure though how I should best incorporate your changes? Should I copy them and add a `Co-authored-by` in the commit message? (I've never done that)\r\n\r\nThanks! I'd say squash in the changes you want to keep. You can add an empty line followed by `Co-authored-by: Jon Atack <jon@atack.com>` to the bottom of a commit message if you like, but it was just a regular average review :)\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/901426870/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/902047745",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-902047745",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
    "id": 902047745,
    "node_id": "IC_kwDOABII5841xCgB",
    "user": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-08-19T16:17:16Z",
    "updated_at": "2021-08-19T16:17:16Z",
    "author_association": "MEMBER",
    "body": "Bench results with more modest dbcache (800): 6% speedup, 6.7% less memory usage.\r\n\r\n|          bench name           |                                                                                                    command                                                                                                     |\r\n|-------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\r\n| ibd.local.range.500000.540000 | `bitcoind -dbcache=800 -debug=coindb -debug=bench -listen=0 -connect=0 -addnode=127.0.0.1:8888 -prune=9999999 -printtoconsole=0 -assumevalid=000000000000000000176c192f42ad13ab159fdb20198b87e7ba3c001e47b876` |\r\n\r\n|                  bench name                   |  x  |           #22702            |         $mergebase          |\r\n|-----------------------------------------------|----:|-----------------------------|-----------------------------|\r\n| ibd.local.range.500000.540000.total_secs      |   3 | 3519.2667 (\u00b1 58.0440)       | 3752.9732 (\u00b1 54.8626)       |\r\n| ibd.local.range.500000.540000.peak_rss_KiB    |   3 | 2282000.0000 (\u00b1 45539.0428) | 2443188.0000 (\u00b1 22211.2803) |\r\n| ibd.local.range.500000.540000.cpu_kernel_secs |   3 | 491.2067 (\u00b1 4.5352)         | 493.7567 (\u00b1 13.1047)        |\r\n| ibd.local.range.500000.540000.cpu_user_secs   |   3 | 13717.5467 (\u00b1 15.0752)      | 13957.7867 (\u00b1 18.7773)      |\r\n\r\n|                  bench name                   |  x  | #22702 | $mergebase |\r\n|-----------------------------------------------|----:|-------:|-----------:|\r\n| ibd.local.range.500000.540000.total_secs      |   3 |      1 |      1.066 |\r\n| ibd.local.range.500000.540000.peak_rss_KiB    |   3 |      1 |      1.071 |\r\n| ibd.local.range.500000.540000.cpu_kernel_secs |   3 |      1 |      1.005 |\r\n| ibd.local.range.500000.540000.cpu_user_secs   |   3 |      1 |      1.018 |",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/902047745/reactions",
      "total_count": 3,
      "+1": 3,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/902831715",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-902831715",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
    "id": 902831715,
    "node_id": "IC_kwDOABII58410B5j",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?u=da89313ed4793f9594c09c23513f49aa4dc1c141&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-08-20T17:03:40Z",
    "updated_at": "2021-08-20T17:08:56Z",
    "author_association": "CONTRIBUTOR",
    "body": "I've now updated the code with correct memory estimation, and benchmarked it. I had a fully synchronized node, and ran `-reindex-chainstate` from block 0 to 690000. All done on a Intel i7 8700, locked to 3200 MHz. I used this command:\r\n\r\n```sh\r\n/usr/bin/time -v bitcoind -datadir=/run/media/martinus/big/bitcoin/db -dbcache=5000 -assumevalid=00000000000000000002a23d6df20eecec15b21d32c75833cce28f113de888b7 -reindex-chainstate -printtoconsole=0 -stopatheight=690000\r\n```\r\nThe PR ran quite a bit faster than master, 20.8%, with practically the same memory usage. Here some interesting data from `/usr/bin/time`:\r\n\r\n| what | mergebase | #22702 | Change \r\n---|---:|---:|---:\r\nElapsed (wall clock) time (h:mm:ss or m:ss) | 4:06:05 | 3:14:49 | 20.8% lower\r\nMaximum resident set size (kbytes) | 6837496 | 6856104 | 0.27% more\r\nMinor (reclaiming a frame) page faults | 101689566 | 70194069 | 31% fewer\r\nFile system inputs | 693891464 | 687479120 | 0.9% fewer\r\nFile system outputs | 239830024 | 188574064 | 21.4% fewer\r\n\r\nHere are some graphs that I created from parsing the `debug.log` file:\r\n\r\n![Progress in Million Transactions over Time(1)](https://user-images.githubusercontent.com/14386/130218881-c724daa3-f1ab-46e4-848f-a467fe875e4f.png)\r\n\r\n![Size of Cache in MiB over Time](https://user-images.githubusercontent.com/14386/130218975-c04af0ce-d36b-4fd6-9a4d-64b43040650c.png)\r\n\r\n`CCoinsMap` requires currently 104 byte for one node, and `node_allocator` basically uses exactly that (a bit more for house keeping of the allocated blocks but that's practically negigable), and the `std::unordered_map`'s default requires 128 byte (16 byte house keeping, and 8 more byte for 16 byte alignment). So we can cache quite a bit more transactions in the same amount of memory:\r\n\r\n![Size of Cache in Million tx over Time](https://user-images.githubusercontent.com/14386/130219000-5f9674cd-fffb-41c8-aa48-85ce51daca77.png)\r\n\r\nDue to the different allocation behavior (it allocates one big chunk of memory right as the first Coin is added), I also had to update the checks in `validation_flush_tests.cpp`",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/902831715/reactions",
      "total_count": 4,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 3,
      "eyes": 1
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/903302726",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-903302726",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
    "id": 903302726,
    "node_id": "IC_kwDOABII5841105G",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?u=da89313ed4793f9594c09c23513f49aa4dc1c141&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-08-22T17:28:11Z",
    "updated_at": "2021-08-22T17:28:11Z",
    "author_association": "CONTRIBUTOR",
    "body": "Unfortunately Microsofts implementation of unordered_map behaves quite a bit different from libc++ and libstdc++, so the heuristic that I'm using to detect the node size doesn't work. I've added a WIP to the header until I've fixed this. Most likely I'll ditch the heuristic completely, and properly calculate the correct size. I'm already doing that in the tests anyways (except for windows)",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/903302726/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/906958642",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-906958642",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
    "id": 906958642,
    "node_id": "IC_kwDOABII5842Dxcy",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?u=da89313ed4793f9594c09c23513f49aa4dc1c141&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-08-27T06:27:22Z",
    "updated_at": "2021-08-27T06:27:22Z",
    "author_association": "CONTRIBUTOR",
    "body": "I've run the same benchmark as https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-902831715 again, but this time with `-dbcache=10000`, and on my brand new much faster SSD (NVMe Corsair MP400). The results are very similar as before, just both runs are relatively faster. Interestingly, with such a large dbsize the branch never needs to flush the cache, only when finished, while master has to flush once because it got full around the 190 minute mark. That's also why memory usage of the branch is a bit lower here.\r\n\r\n| what | mergebase | #22702 | Change \r\n---|---:|---:|---:\r\nElapsed (wall clock) time (h:mm:ss or m:ss) | 3:29:56 | 2:43:43 | 22.0% faster\r\nMaximum resident set size (kbytes) | 10303716 | 9637256 | 6.4% lower\r\nMinor (reclaiming a frame) page faults | 24088467 | 3836829 | 84% fewer\r\nFile system inputs | 693485000 | 696413568 | 0.4% more\r\nFile system outputs | 109392776 | 81335536 | 25.6% fewer\r\n\r\nAgain, graphs are generated from parsing the `debug.log` files, on an Intel i7 8700 locked to 3.2 GHz:\r\n![Progress in Million Transactions over Time](https://user-images.githubusercontent.com/14386/131080470-18a5a79a-0849-4897-8dee-5eec709d6ab4.png)\r\n![Size of Cache in MiB over Time](https://user-images.githubusercontent.com/14386/131080505-23278cc5-8977-4a73-beec-4f2ece769fae.png)\r\n![Size of Cache in Million tx over Time](https://user-images.githubusercontent.com/14386/131080519-b01abbdb-1300-4acb-aa82-17d83278fdc1.png)\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/906958642/reactions",
      "total_count": 3,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 1,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/907000522",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-907000522",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
    "id": 907000522,
    "node_id": "IC_kwDOABII5842D7rK",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?u=da89313ed4793f9594c09c23513f49aa4dc1c141&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-08-27T07:46:48Z",
    "updated_at": "2021-08-27T07:46:48Z",
    "author_association": "CONTRIBUTOR",
    "body": "I've removed `[WIP]` in the title after the code cleanup & fixes, everything should work now as expected on all platforms",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/907000522/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/912411850",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-912411850",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
    "id": 912411850,
    "node_id": "IC_kwDOABII5842YkzK",
    "user": {
      "login": "0xB10C",
      "id": 19157360,
      "node_id": "MDQ6VXNlcjE5MTU3MzYw",
      "avatar_url": "https://avatars.githubusercontent.com/u/19157360?u=a20996a145f1be613c7b0a57e75d36508572e29d&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/0xB10C",
      "html_url": "https://github.com/0xB10C",
      "followers_url": "https://api.github.com/users/0xB10C/followers",
      "following_url": "https://api.github.com/users/0xB10C/following{/other_user}",
      "gists_url": "https://api.github.com/users/0xB10C/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/0xB10C/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/0xB10C/subscriptions",
      "organizations_url": "https://api.github.com/users/0xB10C/orgs",
      "repos_url": "https://api.github.com/users/0xB10C/repos",
      "events_url": "https://api.github.com/users/0xB10C/events{/privacy}",
      "received_events_url": "https://api.github.com/users/0xB10C/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-09-03T09:50:33Z",
    "updated_at": "2021-09-03T09:50:33Z",
    "author_association": "CONTRIBUTOR",
    "body": "I think it would be better to not @ @jonatack in the commit message. IIRC he'll get a notification each time this commit is included in some bitcoin-fork.",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/912411850/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/912511422",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-912511422",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
    "id": 912511422,
    "node_id": "IC_kwDOABII5842Y9G-",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?u=da89313ed4793f9594c09c23513f49aa4dc1c141&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-09-03T12:47:17Z",
    "updated_at": "2021-09-03T12:47:17Z",
    "author_association": "CONTRIBUTOR",
    "body": "> I think it would be better to not @ @jonatack in the commit message. IIRC he'll get a notification each time this commit is included in some bitcoin-fork.\r\n\r\nAh right, it even says so in `CONTRIBUTING.md`. I'll change the commit message.",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/912511422/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/912519251",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-912519251",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
    "id": 912519251,
    "node_id": "IC_kwDOABII5842Y_BT",
    "user": {
      "login": "jonatack",
      "id": 2415484,
      "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2415484?u=3f68150a5f30acd541d1ed279376cd20b78046b1&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonatack",
      "html_url": "https://github.com/jonatack",
      "followers_url": "https://api.github.com/users/jonatack/followers",
      "following_url": "https://api.github.com/users/jonatack/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonatack/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
      "organizations_url": "https://api.github.com/users/jonatack/orgs",
      "repos_url": "https://api.github.com/users/jonatack/repos",
      "events_url": "https://api.github.com/users/jonatack/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonatack/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-09-03T12:58:16Z",
    "updated_at": "2021-09-03T12:58:16Z",
    "author_association": "MEMBER",
    "body": "The @ is not bothersome until merge, so it can wait until need to retouch.",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/912519251/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/912873136",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-912873136",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
    "id": 912873136,
    "node_id": "IC_kwDOABII5842aVaw",
    "user": {
      "login": "benthecarman",
      "id": 15256660,
      "node_id": "MDQ6VXNlcjE1MjU2NjYw",
      "avatar_url": "https://avatars.githubusercontent.com/u/15256660?u=eab48576b7831944b8ce7f04fcdff4154a853d50&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/benthecarman",
      "html_url": "https://github.com/benthecarman",
      "followers_url": "https://api.github.com/users/benthecarman/followers",
      "following_url": "https://api.github.com/users/benthecarman/following{/other_user}",
      "gists_url": "https://api.github.com/users/benthecarman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/benthecarman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/benthecarman/subscriptions",
      "organizations_url": "https://api.github.com/users/benthecarman/orgs",
      "repos_url": "https://api.github.com/users/benthecarman/repos",
      "events_url": "https://api.github.com/users/benthecarman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/benthecarman/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-09-04T00:17:55Z",
    "updated_at": "2021-09-04T00:17:55Z",
    "author_association": "CONTRIBUTOR",
    "body": "tACK 952c37a31c39b7acdb5ab2634a354a1c548708a2\r\n\r\nDid IDB on a testnet node, ubuntu 20.04",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/912873136/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/916295394",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-916295394",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
    "id": 916295394,
    "node_id": "IC_kwDOABII5842nY7i",
    "user": {
      "login": "DrahtBot",
      "id": 39886733,
      "node_id": "MDQ6VXNlcjM5ODg2NzMz",
      "avatar_url": "https://avatars.githubusercontent.com/u/39886733?u=3c1e73d828cf5a5850dfc25c8397c1cf751db5ac&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/DrahtBot",
      "html_url": "https://github.com/DrahtBot",
      "followers_url": "https://api.github.com/users/DrahtBot/followers",
      "following_url": "https://api.github.com/users/DrahtBot/following{/other_user}",
      "gists_url": "https://api.github.com/users/DrahtBot/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
      "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
      "repos_url": "https://api.github.com/users/DrahtBot/repos",
      "events_url": "https://api.github.com/users/DrahtBot/events{/privacy}",
      "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-09-09T17:28:40Z",
    "updated_at": "2021-11-22T22:38:49Z",
    "author_association": "CONTRIBUTOR",
    "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#23546](https://github.com/bitcoin/bitcoin/pull/23546) (scripted-diff: Use clang-tidy syntax for C++ named arguments (tests only) by MarcoFalke)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/916295394/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/941055887",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-941055887",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
    "id": 941055887,
    "node_id": "IC_kwDOABII5844F1-P",
    "user": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-10-12T14:17:02Z",
    "updated_at": "2021-10-12T14:17:02Z",
    "author_association": "MEMBER",
    "body": "Given the high potential performance benefit of this PR, it'd be great to see it move forward somehow.\r\n\r\n@martinus: are there any limitations or concerns you have about this? Are there any risks in particular we should be testing for?\r\n\r\n@sipa @ryanofsky @TheBlueMatt: given you're some resident C++/systems experts, are there any concerns you have? Tests you'd like to see?\r\n\r\nI just want to best understand what kind of work we should be doing to assess the suitability of this change. ",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/941055887/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/941067769",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-941067769",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
    "id": 941067769,
    "node_id": "IC_kwDOABII5844F435",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?u=7999a16349f0df0fb273fffa18e5a955c9d3f11c&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-10-12T14:30:24Z",
    "updated_at": "2021-10-12T14:30:24Z",
    "author_association": "MEMBER",
    "body": "It's been on my list to go through the code in detail.\n\nSo far, my biggest concern is that the object size gets computed incorrectly by a future libstdc++ (or equivalent) change, and we'll silently fall back to old performance.\n\n@martinus What do you think the impact would be from having a list of memory blobs per allocation size? That would alleviate any such concerns, but I'm not sure whether its performance impact might be non-negligible, of if there are other issues with that approach. A pointer to the last-used allocation size's blobs could be cached, perhaps.",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/941067769/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/941097068",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-941097068",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
    "id": 941097068,
    "node_id": "IC_kwDOABII5844GABs",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-10-12T15:03:05Z",
    "updated_at": "2021-10-12T15:03:05Z",
    "author_association": "CONTRIBUTOR",
    "body": "> @sipa @ryanofsky @TheBlueMatt: given you're some resident C++/systems experts, are there any concerns you have? Tests you'd like to see?\r\n\r\nNo specific concerns from me. It's just a PR adding a lot of dense code that will take time to read over. This seems like a very worthwhile change if it is speeding up IBD, and it seems less risky than other more invasive performance improvements.\r\n\r\nDumb question, just because the title of this PR is makes me immediately feel stupid: What is  a \"node-based\" container? Just any map container? Maybe a more motivating PR title would be \"Implement node allocator for UTXO cache for faster IBD\". Also it would be good if PR description described the new PR instead of just comparing it to previous PR, since probably some potential reviewers like me are not familiar with the previous PR.",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/941097068/reactions",
      "total_count": 2,
      "+1": 2,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/941108553",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-941108553",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
    "id": 941108553,
    "node_id": "IC_kwDOABII5844GC1J",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?u=7999a16349f0df0fb273fffa18e5a955c9d3f11c&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-10-12T15:14:58Z",
    "updated_at": "2021-10-12T15:19:32Z",
    "author_association": "MEMBER",
    "body": "@ryanofsky I'm not exactly sure where the name \"node based\" comes from, but my interpretation is this: it's an allocator that optimizes the allocation of lots of objects of one specific preset size, without the ability to return individual memory back to the system. Such an allocator is specifically useful for standard library collection types which involve a separately-allocated object (which I guess are called nodes?) for each item (this would apply to things like `std::{,forward_}list`, `std::{,unordered_}{,multi}{set,map}`; I'm unsure about `std::deque`).",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/941108553/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/941117614",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-941117614",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
    "id": 941117614,
    "node_id": "IC_kwDOABII5844GFCu",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-10-12T15:24:30Z",
    "updated_at": "2021-10-12T15:24:30Z",
    "author_association": "CONTRIBUTOR",
    "body": "Yeah I don't mean to quibble over the name. I'm sure it's appropriate. Just suggesting to make not make the term seem like assumed knowledge for reviewing the PR. Naively I would think \"separately-allocated object\" would apply to trees and lists but not hash tables so `{,unordered_}` part of this is specifically what's confusing me here. But I should just sit down and read `node_allocator.h`, since the code itself is nicely documented.",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/941117614/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/941121006",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-941121006",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
    "id": 941121006,
    "node_id": "IC_kwDOABII5844GF3u",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?u=7999a16349f0df0fb273fffa18e5a955c9d3f11c&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-10-12T15:27:56Z",
    "updated_at": "2021-10-12T15:28:47Z",
    "author_association": "MEMBER",
    "body": "@ryanofsky Yeah I'm just trying to explain my understanding, not nit about the name. `std::unordered_{multi,}{set}{map}` use a single hashtable with pointers that start singly-linked lists of objects in that bucket, each of which points to the next one. Those objects are potential candidates for optimization by the allocator (the hashtable itself isn't).",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/941121006/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/941122228",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-941122228",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
    "id": 941122228,
    "node_id": "IC_kwDOABII5844GGK0",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?u=da89313ed4793f9594c09c23513f49aa4dc1c141&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-10-12T15:29:16Z",
    "updated_at": "2021-10-12T15:29:16Z",
    "author_association": "CONTRIBUTOR",
    "body": "@jamesob concerning limitations, I can't really think of much... I think the biggest change is that the `MemoryResource` doesn't free memory any more. So once the map reaches a size, memory usage won't decrease even when the map gets smaller. You can see that nicely in this graph: https://user-images.githubusercontent.com/14386/131080505-23278cc5-8977-4a73-beec-4f2ece769fae.png The blue line is mergebase and when map size decreases memory goes down. For this PR the memory stays constant (at a lower level because it needs less memory).\r\n\r\nAnother concern is that on some systems malloc could be exceptionally fast, or implemented differently, so that this `node_allocator` is not actually a performance / memory benefit. \r\n\r\n@sipa concerning incorrectly calculating object sizes, I think this can be covered in unit tests. In the new test `test_chunks_are_used` I'm trying to create `std::unordered_map` with all kind of alignments with and without a `noexcept` hash, and assert if the MemoryResource is actually used. I could also add another test that actually uses `CCoinsMap` to see if the allocator is used.\r\n\r\nAbout having a list of memory blobs per allocation size: I've thought about that, but I've tried to keep the allocator as simple as possible and didn't want to make it more complex. By the way the logic is quite a bit similar to python's pymalloc (which I've discovered after I wrote most of it...): https://www.evanjones.ca/memoryallocator/ Newer versions have multiple pools of different byte sizes, and also the ability to actually free chunks. Of course then the allocator would become much more complex.\r\n\r\n@ryanofsky Node based containers are all containers where for each element they need to allocate data (the actual content + some control structure). For `std::unordered_map` that node usually consists of key+value pair and a pointer. Sometimes hash value is also stored in the node. Only `std::vector`, `std::deque`, `std::array` are not node based. The nodes are a big performance issue because it's always a layer of indirection and requires allocation, but it is necessary so pointers/references to data stays valid even when the container is modified.",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/941122228/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/941122988",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-941122988",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
    "id": 941122988,
    "node_id": "IC_kwDOABII5844GGWs",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-10-12T15:30:06Z",
    "updated_at": "2021-10-12T15:30:06Z",
    "author_association": "CONTRIBUTOR",
    "body": "Makes sense! I didn't know that about those containers.",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/941122988/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/941123677",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-941123677",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
    "id": 941123677,
    "node_id": "IC_kwDOABII5844GGhd",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?u=7999a16349f0df0fb273fffa18e5a955c9d3f11c&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-10-12T15:30:54Z",
    "updated_at": "2021-10-12T15:31:07Z",
    "author_association": "MEMBER",
    "body": "@martinus Ah good, the unit tests covering this that way mostly alleviates my concern. I'll review the code.",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/941123677/reactions",
      "total_count": 1,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 1,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/950158246",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-950158246",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
    "id": 950158246,
    "node_id": "IC_kwDOABII5844okOm",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?u=da89313ed4793f9594c09c23513f49aa4dc1c141&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-10-23T14:07:12Z",
    "updated_at": "2021-10-23T14:07:12Z",
    "author_association": "CONTRIBUTOR",
    "body": "Thanks a lot for the detailed review @ryanofsky! I'll go through all that and see what I can do",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/950158246/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/952007669",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-952007669",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
    "id": 952007669,
    "node_id": "IC_kwDOABII5844vnv1",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?u=da89313ed4793f9594c09c23513f49aa4dc1c141&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-10-26T14:38:09Z",
    "updated_at": "2021-10-26T14:38:09Z",
    "author_association": "CONTRIBUTOR",
    "body": "@ryanofsky I have done quite a bit of refactoring based on your suggestion, thanks again! It's a big change unfortunately, but I think it addresses almost everything you mentioned.",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/952007669/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/957655782",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-957655782",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
    "id": 957655782,
    "node_id": "IC_kwDOABII5845FKrm",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?u=da89313ed4793f9594c09c23513f49aa4dc1c141&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-11-02T14:08:25Z",
    "updated_at": "2021-11-02T14:08:25Z",
    "author_association": "CONTRIBUTOR",
    "body": "Thanks again @ryanofsky, I'll of course look through your review closely again but I don't have much time right now, so it can take a while.",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/957655782/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/962655193",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-962655193",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
    "id": 962655193,
    "node_id": "IC_kwDOABII5845YPPZ",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?u=7999a16349f0df0fb273fffa18e5a955c9d3f11c&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-11-07T18:02:44Z",
    "updated_at": "2021-11-07T18:05:00Z",
    "author_association": "MEMBER",
    "body": "A few high-level comments:\r\n* I think it would be nice to split up the first commit more (e.g. separating the introduction of the allocator from the changes to make the UTXO set use it)\r\n* Don't @ mention people in the PR description; they'll get random spam anytime j-random-altcoin cherry-picks it.\r\n* I find the \"semantic\" cyclic dependency between node_allocator and memusage (as in: neither can be used without the other, effectively) somewhat ugly. Would it make sense to have the logic for determining node size for containers live in node_allocator itself?",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/962655193/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/962655357",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-962655357",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
    "id": 962655357,
    "node_id": "IC_kwDOABII5845YPR9",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?u=da89313ed4793f9594c09c23513f49aa4dc1c141&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-11-07T18:03:47Z",
    "updated_at": "2021-11-07T18:03:47Z",
    "author_association": "CONTRIBUTOR",
    "body": "I have rebased & squashed to e2a5547f12e5da2718ba17ebac5d5aeb5a2e24d5 and integrated most suggestions from @ryanofsky. This update is mostly style improvements, deduplicating code, but also two correctness improvements:\r\n\r\n* `MemoryResource::Deallocate` previously just `static_cast` void* to FreeList. This was technically undefined behavior. Instead, I'm now using placement new.\r\n* `MemoryResource::Allocate` now has a `static_assert` to make sure the pool's data is correctly aligned for node alignments.",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/962655357/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/962905590",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-962905590",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
    "id": 962905590,
    "node_id": "IC_kwDOABII5845ZMX2",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?u=da89313ed4793f9594c09c23513f49aa4dc1c141&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-11-08T08:10:15Z",
    "updated_at": "2021-11-08T08:10:15Z",
    "author_association": "CONTRIBUTOR",
    "body": "@sipa I'll split up the node_allocator into multiple files, and also into multiple commits. It's a bit tricky though to get rid of the cyclic dependency, because MemoryResource needs some functionality of memusage to calculate its dynamic usage, and memusage needs to know the Allocator.",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/962905590/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/964493772",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-964493772",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
    "id": 964493772,
    "node_id": "IC_kwDOABII5845fQHM",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-11-09T20:05:00Z",
    "updated_at": "2021-11-09T20:05:00Z",
    "author_association": "CONTRIBUTOR",
    "body": "> It's a bit tricky though to get rid of the cyclic dependency, because MemoryResource needs some functionality of memusage to calculate its dynamic usage, and memusage needs to know the Allocator.\r\n\r\nFWIW, I gave a suggestion to remove the circular dependency in https://github.com/bitcoin/bitcoin/pull/22702#discussion_r737676396. Instead of not including the size of allocated nodes in the container size when an allocator is used, the container can report its size the same way whether or not an allocator is used, and the allocator can only report the size of unallocated space instead of the total allocated + unallocated space. I think this would make the accounting more intuitive, in addition to making the container size calculation independent of the allocator size calculation.",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/964493772/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/968245254",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-968245254",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
    "id": 968245254,
    "node_id": "IC_kwDOABII5845tkAG",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?u=da89313ed4793f9594c09c23513f49aa4dc1c141&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-11-14T08:18:26Z",
    "updated_at": "2021-11-14T08:18:26Z",
    "author_association": "CONTRIBUTOR",
    "body": "Rebased e2a5547f12e5da2718ba17ebac5d5aeb5a2e24d5 ->  290649c with plenty of refactoring. No functional changes.\r\n\r\n* Split code into multiple files, each with its own concern.\r\n* Split up commits into logical chunks\r\n* Added another test for `NodeSize` calculation\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/968245254/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/969292463",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-969292463",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
    "id": 969292463,
    "node_id": "IC_kwDOABII5845xjqv",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?u=da89313ed4793f9594c09c23513f49aa4dc1c141&v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-11-15T20:27:55Z",
    "updated_at": "2021-11-15T20:27:55Z",
    "author_association": "CONTRIBUTOR",
    "body": "Rebased to 8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74 to resolve conflicts",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/969292463/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/972049312",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-972049312",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
    "id": 972049312,
    "node_id": "IC_kwDOABII58458Eug",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2021-11-17T21:21:07Z",
    "updated_at": "2021-11-17T21:21:07Z",
    "author_association": "CONTRIBUTOR",
    "body": "I'm starting to catch up on this, but so far the new changes look great, and it's nice the way this is now split up into smaller commits and files. I think being able to look at different parts in isolation now makes this PR more approachable and easier to review.",
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/972049312/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "performed_via_github_app": null
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/689129302",
    "pull_request_review_id": 730212106,
    "id": 689129302,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4OTEyOTMwMg==",
    "diff_hunk": "@@ -0,0 +1,356 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <cstddef>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a freelist for further use.This behavior has two main advantages:\n+ *\n+ * - Memory: no control structure is required for each node memory, the freelist is stored inplace. This typically safes\n+ *   about 8 bytes per node.\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - Memory that's been used for nodes is always put back into a freelist and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The freelist is a simple first-in-last-out linked list, it doesn't reorder elements. So freeing and malloc'ing again",
    "path": "src/support/allocators/node_allocator.h",
    "position": null,
    "original_position": 34,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "3574aeebcbb54df26b7ef27573230c125e96b209",
    "user": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "last in first out?",
    "created_at": "2021-08-15T18:56:43Z",
    "updated_at": "2021-08-15T18:56:43Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r689129302",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/689129302"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r689129302"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/689129302/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 34,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/689129360",
    "pull_request_review_id": 730212152,
    "id": 689129360,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4OTEyOTM2MA==",
    "diff_hunk": "@@ -0,0 +1,356 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <cstddef>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a freelist for further use.This behavior has two main advantages:\n+ *\n+ * - Memory: no control structure is required for each node memory, the freelist is stored inplace. This typically safes\n+ *   about 8 bytes per node.\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - Memory that's been used for nodes is always put back into a freelist and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The freelist is a simple first-in-last-out linked list, it doesn't reorder elements. So freeing and malloc'ing again\n+ *   can have an advantageous access pattern which leads to less cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator` compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Since there is\n+ * unfortunately no way to determine the size of nodes that we want to optimize for in advance, MemoryResource uses\n+ * a simple heuristic: We assume the first call to Allocate with 1 element is for the node, and upon that first call the\n+ * MemoryResource is configured to use that as it's chunk size. Note that due to this heuristic we cannot implement an\n+ * `std::pmr::memory_resource` because it does not gie the information about the number of elements.",
    "path": "src/support/allocators/node_allocator.h",
    "position": null,
    "original_position": 46,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "3574aeebcbb54df26b7ef27573230c125e96b209",
    "user": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "gie -> give",
    "created_at": "2021-08-15T18:57:28Z",
    "updated_at": "2021-08-15T18:57:29Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r689129360",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/689129360"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r689129360"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/689129360/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 46,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/690258262",
    "pull_request_review_id": 731616678,
    "id": 690258262,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5MDI1ODI2Mg==",
    "diff_hunk": "@@ -0,0 +1,313 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <support/allocators/node_allocator.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <list>\n+#include <map>\n+#include <string>\n+#include <unordered_map>\n+\n+BOOST_FIXTURE_TEST_SUITE(node_allocator_tests, BasicTestingSetup)\n+\n+#define CHECK_MEMORY_RESOURCE(mr, chunk_size, num_free_chunks, num_blocks) \\\n+    BOOST_CHECK_EQUAL(chunk_size, mr.ChunkSize());                         \\\n+    BOOST_CHECK_EQUAL(num_free_chunks, mr.NumFreeChunks());                \\\n+    BOOST_CHECK_EQUAL(num_blocks, mr.NumBlocks());\n+\n+#define CHECK_IN_RANGE(what, lowerInclusive, upperInclusive) \\\n+    BOOST_TEST(what >= lowerInclusive);                      \\\n+    BOOST_TEST(what <= upperInclusive);\n+\n+BOOST_AUTO_TEST_CASE(too_small)\n+{\n+    node_allocator::MemoryResource mr;\n+    void* ptr = mr.Allocate<char>(1);\n+    BOOST_CHECK(ptr != nullptr);\n+\n+    // mr is used\n+    CHECK_MEMORY_RESOURCE(mr, sizeof(void*), 0, 1);\n+    mr.Deallocate<char>(ptr, 1);\n+    CHECK_MEMORY_RESOURCE(mr, sizeof(void*), 1, 1);\n+\n+    // void* works too, use freelist\n+    ptr = mr.Allocate<void*>(1);\n+    BOOST_CHECK(ptr != nullptr);\n+    CHECK_MEMORY_RESOURCE(mr, sizeof(void*), 0, 1);\n+    mr.Deallocate<char>(ptr, 1);\n+    CHECK_MEMORY_RESOURCE(mr, sizeof(void*), 1, 1);\n+}\n+\n+BOOST_AUTO_TEST_CASE(std_unordered_map)\n+{\n+    using Map = std::unordered_map<uint64_t, uint64_t, std::hash<uint64_t>, std::equal_to<uint64_t>, node_allocator::Allocator<std::pair<const uint64_t, uint64_t>>>;\n+\n+    node_allocator::MemoryResource mr;\n+    Map m(0, Map::hasher{}, Map::key_equal{}, Map::allocator_type{&mr});\n+    size_t num_free_chunks = 0;\n+    {\n+        Map a(0, Map::hasher{}, Map::key_equal{}, Map::allocator_type{&mr});\n+\n+        // Allocator compares equal because the same memory resource is used\n+        BOOST_CHECK(a.get_allocator() == m.get_allocator());\n+        for (uint64_t i = 0; i < 1000; ++i) {\n+            a[i] = i;\n+        }\n+\n+        num_free_chunks = mr.NumFreeChunks();\n+\n+        // create a copy of the map, destroy the map => now a lot more free chunks should be available\n+        {\n+            Map b = a;\n+        }\n+\n+        BOOST_CHECK(mr.NumFreeChunks() > num_free_chunks);\n+        num_free_chunks = mr.NumFreeChunks();\n+\n+        // creating another copy, and then destroying everything should reuse all the chunks\n+        {\n+            Map b = a;\n+        }\n+        BOOST_CHECK_EQUAL(mr.NumFreeChunks(), num_free_chunks);\n+\n+        // moving the map should not create new nodes\n+        m = std::move(a);\n+        BOOST_CHECK_EQUAL(mr.NumFreeChunks(), num_free_chunks);\n+    }\n+    // a is destroyed, still all chunks should stay roughly the same.\n+    BOOST_CHECK(mr.NumFreeChunks() <= num_free_chunks + 5);\n+\n+    m = Map(0, Map::hasher{}, Map::key_equal{}, Map::allocator_type{&mr});\n+\n+    // now we got everything free\n+    BOOST_CHECK(mr.NumFreeChunks() > num_free_chunks + 50);\n+}\n+\n+BOOST_AUTO_TEST_CASE(different_memoryresource_assignment)\n+{\n+    using Map = std::unordered_map<uint64_t, uint64_t, std::hash<uint64_t>, std::equal_to<uint64_t>, node_allocator::Allocator<std::pair<const uint64_t, uint64_t>>>;\n+\n+    node_allocator::MemoryResource mr_a;\n+    node_allocator::MemoryResource mr_b;\n+\n+    {\n+        Map map_a(0, Map::hasher{}, Map::key_equal{}, Map::allocator_type{&mr_a});\n+        for (int i = 0; i < 100; ++i) {\n+            map_a[i] = i;\n+        }\n+\n+        {\n+            Map map_b(0, Map::hasher{}, Map::key_equal{}, Map::allocator_type{&mr_b});\n+            map_b[123] = 321;\n+            BOOST_CHECK(map_a.get_allocator() != map_b.get_allocator());\n+            BOOST_CHECK_EQUAL(mr_b.NumFreeChunks(), 0);\n+            BOOST_CHECK_EQUAL(mr_b.NumBlocks(), 1);\n+\n+            map_b = map_a;\n+\n+            // map_a now uses mr_b, since propagate_on_container_copy_assignment is std::true_type\n+            BOOST_CHECK(map_a.get_allocator() == map_b.get_allocator());\n+            CHECK_IN_RANGE(mr_b.NumFreeChunks(), 1U, 2U);\n+            BOOST_CHECK_EQUAL(mr_b.NumBlocks(), 1);\n+\n+            // map_b was now recreated with data from map_a, using mr_a as the memory resource.\n+        }\n+\n+        // map_b destroyed, should not have any effect on mr_b\n+        CHECK_IN_RANGE(mr_b.NumFreeChunks(), 1U, 2U);\n+        BOOST_CHECK_EQUAL(mr_b.NumBlocks(), 1);\n+        // but we'll get more free chunks in mr_a\n+        CHECK_IN_RANGE(mr_a.NumFreeChunks(), 100U, 101U);\n+    }\n+\n+    // finally map_a is destroyed, getting more free chunks.\n+    CHECK_IN_RANGE(mr_a.NumFreeChunks(), 200U, 202U);\n+}\n+\n+\n+BOOST_AUTO_TEST_CASE(different_memoryresource_move)\n+{\n+    using Map = std::unordered_map<uint64_t, uint64_t, std::hash<uint64_t>, std::equal_to<uint64_t>, node_allocator::Allocator<std::pair<const uint64_t, uint64_t>>>;\n+\n+    node_allocator::MemoryResource mr_a;\n+    node_allocator::MemoryResource mr_b;\n+\n+    {\n+        Map map_a(0, Map::hasher{}, Map::key_equal{}, Map::allocator_type{&mr_a});\n+        for (int i = 0; i < 100; ++i) {\n+            map_a[i] = i;\n+        }\n+\n+        {\n+            Map map_b(0, Map::hasher{}, Map::key_equal{}, Map::allocator_type{&mr_b});\n+            map_b[123] = 321;\n+\n+            map_b = std::move(map_a);\n+\n+            // map_a now uses mr_b, since propagate_on_container_copy_assignment is std::true_type\n+            BOOST_CHECK(map_a.get_allocator() == map_b.get_allocator());\n+            CHECK_IN_RANGE(mr_b.NumFreeChunks(), 1U, 2U);\n+            BOOST_CHECK_EQUAL(mr_b.NumBlocks(), 1);\n+\n+            // map_b was now recreated with data from map_a, using mr_a as the memory resource.\n+        }\n+\n+        // map_b destroyed, should not have any effect on mr_b.\n+        CHECK_IN_RANGE(mr_b.NumFreeChunks(), 1U, 2U);\n+        BOOST_CHECK_EQUAL(mr_b.NumBlocks(), 1);\n+        // but we'll get more free chunks in mr_a\n+        CHECK_IN_RANGE(mr_a.NumFreeChunks(), 100U, 101U);\n+    }\n+\n+    // finally map_a is destroyed, but since it was moved, no more free chunks.\n+    CHECK_IN_RANGE(mr_a.NumFreeChunks(), 100U, 102U);\n+}\n+\n+\n+BOOST_AUTO_TEST_CASE(different_memoryresource_swap)\n+{\n+    using Map = std::unordered_map<uint64_t, uint64_t, std::hash<uint64_t>, std::equal_to<uint64_t>, node_allocator::Allocator<std::pair<const uint64_t, uint64_t>>>;\n+\n+    node_allocator::MemoryResource mr_a;\n+    node_allocator::MemoryResource mr_b;\n+\n+    {\n+        Map map_a(0, Map::hasher{}, Map::key_equal{}, Map::allocator_type{&mr_a});\n+        for (int i = 0; i < 100; ++i) {\n+            map_a[i] = i;\n+        }\n+\n+        {\n+            Map map_b(0, Map::hasher{}, Map::key_equal{}, Map::allocator_type{&mr_b});\n+            map_b[123] = 321;\n+\n+            auto alloc_a = map_a.get_allocator();\n+            auto alloc_b = map_b.get_allocator();\n+\n+            std::swap(map_a, map_b);\n+\n+            // maps have swapped, so their allocator have swapped too. No additional allocations have occored!\n+            BOOST_CHECK(map_a.get_allocator() != map_b.get_allocator());\n+            BOOST_CHECK(alloc_a == map_b.get_allocator());\n+            BOOST_CHECK(alloc_b == map_a.get_allocator());\n+        }\n+\n+        // map_b destroyed, so mr_a must have plenty of free chunks now\n+        CHECK_IN_RANGE(mr_a.NumFreeChunks(), 100U, 101U);\n+\n+        // nothing happened to map_a, so mr_b still has no free chunks\n+        BOOST_CHECK_EQUAL(mr_b.NumFreeChunks(), 0);\n+    }\n+\n+    // finally map_a is destroyed, so we got an entry back for mr_b.\n+    CHECK_IN_RANGE(mr_a.NumFreeChunks(), 100U, 101U);\n+    CHECK_IN_RANGE(mr_b.NumFreeChunks(), 1U, 2U);\n+}\n+\n+// some structs that with defined alignment and customizeable size\n+\n+namespace {\n+\n+template <size_t S>\n+struct alignas(1) A1 {\n+    char data[S];\n+};\n+\n+template <size_t S>\n+struct alignas(2) A2 {\n+    char data[S];\n+};\n+\n+template <size_t S>\n+struct alignas(4) A4 {\n+    char data[S];\n+};\n+\n+template <size_t S>\n+struct alignas(8) A8 {\n+    char data[S];\n+};\n+\n+template <size_t S>\n+struct alignas(16) A16 {\n+    char data[S];\n+};\n+\n+template <size_t S>\n+struct alignas(32) A32 {\n+    char data[S];\n+};\n+\n+constexpr bool isMultiple(size_t a, size_t b)\n+{\n+    return (a / b) * b == a;\n+}",
    "path": "src/test/node_allocator_tests.cpp",
    "position": null,
    "original_position": 248,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "3574aeebcbb54df26b7ef27573230c125e96b209",
    "user": {
      "login": "jonatack",
      "id": 2415484,
      "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonatack",
      "html_url": "https://github.com/jonatack",
      "followers_url": "https://api.github.com/users/jonatack/followers",
      "following_url": "https://api.github.com/users/jonatack/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonatack/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
      "organizations_url": "https://api.github.com/users/jonatack/orgs",
      "repos_url": "https://api.github.com/users/jonatack/repos",
      "events_url": "https://api.github.com/users/jonatack/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonatack/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Tested that `IsMultiple()` can be removed (Debian Clang 13)\r\n\r\n```\r\ntest/node_allocator_tests.cpp:245:16: warning: unused function 'isMultiple' [-Wunused-function]\r\nconstexpr bool isMultiple(size_t a, size_t b)\r\n               ^\r\n1 warning generated.\r\n```\r\n",
    "created_at": "2021-08-17T10:55:25Z",
    "updated_at": "2021-08-17T11:27:01Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r690258262",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/690258262"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r690258262"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/690258262/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 248,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/690263859",
    "pull_request_review_id": 731616678,
    "id": 690263859,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5MDI2Mzg1OQ==",
    "diff_hunk": "@@ -0,0 +1,356 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <cstddef>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a freelist for further use.This behavior has two main advantages:\n+ *\n+ * - Memory: no control structure is required for each node memory, the freelist is stored inplace. This typically safes\n+ *   about 8 bytes per node.\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - Memory that's been used for nodes is always put back into a freelist and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The freelist is a simple first-in-last-out linked list, it doesn't reorder elements. So freeing and malloc'ing again\n+ *   can have an advantageous access pattern which leads to less cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator` compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Since there is\n+ * unfortunately no way to determine the size of nodes that we want to optimize for in advance, MemoryResource uses\n+ * a simple heuristic: We assume the first call to Allocate with 1 element is for the node, and upon that first call the\n+ * MemoryResource is configured to use that as it's chunk size. Note that due to this heuristic we cannot implement an\n+ * `std::pmr::memory_resource` because it does not gie the information about the number of elements.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall \u201cHow to Write a Custom Allocator\u201d https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer \u201cAn Allocator is a Handle to a Heap\u201d https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *     https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block. Whenever a node is given back\n+ *   with Deallocate(), it is put into a freelist.\n+ */\n+class MemoryResource\n+{\n+public:\n+    /**\n+     * Inplace linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object and uses the specified block size for allocations.\n+     * Actually the real block size can be a bit smaller, it will be the largest multiple of chunk size\n+     * that fits into the block.\n+     */\n+    explicit MemoryResource(size_t block_size_byte) : m_block_size_bytes(block_size_byte) {}\n+\n+    MemoryResource() = default;\n+\n+    /**\n+     * Copying a memory resource is not allowed, it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;",
    "path": "src/support/allocators/node_allocator.h",
    "position": null,
    "original_position": 91,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "3574aeebcbb54df26b7ef27573230c125e96b209",
    "user": {
      "login": "jonatack",
      "id": 2415484,
      "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonatack",
      "html_url": "https://github.com/jonatack",
      "followers_url": "https://api.github.com/users/jonatack/followers",
      "following_url": "https://api.github.com/users/jonatack/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonatack/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
      "organizations_url": "https://api.github.com/users/jonatack/orgs",
      "repos_url": "https://api.github.com/users/jonatack/repos",
      "events_url": "https://api.github.com/users/jonatack/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonatack/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Perhaps rule of 5 (https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-five, https://www.stroustrup.com/C++11FAQ.html#default)\r\n```diff \r\n     /**\r\n-     * Copying a memory resource is not allowed, it is an immobile object.\r\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\r\n      */\r\n     MemoryResource(const MemoryResource&) = delete;\r\n     MemoryResource& operator=(const MemoryResource&) = delete;\r\n+    MemoryResource(MemoryResource&&) = delete;\r\n+    MemoryResource& operator=(MemoryResource&&) = delete;\r\n```",
    "created_at": "2021-08-17T11:04:06Z",
    "updated_at": "2021-08-17T11:27:01Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r690263859",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/690263859"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r690263859"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/690263859/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 132,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/693212773",
    "pull_request_review_id": 735378772,
    "id": 693212773,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5MzIxMjc3Mw==",
    "diff_hunk": "@@ -0,0 +1,399 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <cstddef>\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no control structure is required for each node memory; the free list is stored in-place. This typically saves\n+ *   about 8 bytes per node.\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements. So freeing and malloc'ing again",
    "path": "src/support/allocators/node_allocator.h",
    "position": null,
    "original_position": 37,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "6fa1a72e7dd9ff1e99c6e2ad0531619d119045f9",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "This does not sound like a disadvantage when formulated this way?",
    "created_at": "2021-08-20T20:51:51Z",
    "updated_at": "2021-08-20T21:27:28Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r693212773",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/693212773"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r693212773"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/693212773/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 38,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/693215356",
    "pull_request_review_id": 735378772,
    "id": 693215356,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5MzIxNTM1Ng==",
    "diff_hunk": "@@ -0,0 +1,399 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <cstddef>\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no control structure is required for each node memory; the free list is stored in-place. This typically saves\n+ *   about 8 bytes per node.\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements. So freeing and malloc'ing again\n+ *   can have an advantageous access pattern which leads to less cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator` compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Since there is\n+ * unfortunately no way to determine the size of nodes that we want to optimize for in advance, MemoryResource uses\n+ * a simple heuristic: We assume the first call to Allocate with 1 element is for the node, and upon that first call the\n+ * MemoryResource is configured to use that as its chunk size. Note that due to this heuristic we cannot implement a\n+ * `std::pmr::memory_resource` because it does not give the information about the number of elements.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall \u201cHow to Write a Custom Allocator\u201d https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer \u201cAn Allocator is a Handle to a Heap\u201d https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *     https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block. Whenever a node is given back\n+ *   with Deallocate(), it is put into a free list.\n+ */\n+class MemoryResource\n+{\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object that uses the specified block size for allocations.\n+     * Actually the real block size can be a bit smaller, it will be the largest multiple of chunk size\n+     * that fits into the block.\n+     */\n+    explicit MemoryResource(size_t block_size_byte) : m_block_size_bytes(block_size_byte) {}\n+\n+    MemoryResource() = default;\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated blocks.\n+     */\n+    ~MemoryResource() noexcept\n+    {\n+        Clear();\n+    }\n+\n+    /**\n+     * Clears all allocated blocks.\n+     *\n+     * Memory is freed regardless if its still in use, so use with care! E.g. only after a call to clear() to the underlying container.\n+     */\n+    void Clear()\n+    {\n+        for (auto* block : m_allocated_blocks) {\n+            ::operator delete(block);\n+        }\n+        m_free_chunks = nullptr;\n+        m_allocated_blocks.clear();\n+        m_chunk_size_bytes = 0U;\n+        m_untouched_memory_iterator = nullptr;\n+        m_untouched_memory_end = nullptr;\n+    }\n+\n+    /**\n+     * Allocates memory for n times T. Only when n==1 the memory blocks are used to give out memory. The first call with n==1\n+     * decides the chunk size.\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size = CalcRequiredChunkSizeBytes<T>();\n+\n+        // only use pool when a single element is allocated\n+        if (m_chunk_size_bytes == 0 && n == 1) {\n+            // first call to Allocate with n==1 determines chunk size\n+            m_chunk_size_bytes = required_chunk_size;\n+        }\n+\n+        if (m_chunk_size_bytes != required_chunk_size || n != 1) {\n+            // pool is not used so forward to operator new.\n+            return static_cast<T*>(::operator new(n * sizeof(T)));\n+        }\n+\n+        // chunk size is correct, so we can actually use the pool's block data\n+\n+        if (m_free_chunks) {\n+            // we've already got data in the free list, unlink one element\n+            auto old_head = m_free_chunks;\n+            m_free_chunks = static_cast<ChunkNode*>(m_free_chunks)->next;\n+            return static_cast<T*>(old_head);\n+        }\n+\n+        // free list is empty: get one chunk from allocated block memory.\n+        // It makes sense to not create the fully linked list of an allocated block up front, for several reasons\n+        // On the one hand, the latency is higher when we need to iterate and update pointers for the whole block at once.\n+        // More importantly, most systems lazily allocate data. So when we allocate a big block of memory the memory for a page\n+        // is only actually made available to the program when it is first touched. So when we allocate a big block and only use\n+        // very little memory from it, the total memory usage is lower than what has been malloc'ed.\n+        if (m_untouched_memory_iterator == m_untouched_memory_end) {\n+            // slow path, only happens when a new block needs to be allocated\n+            AllocateNewBlock();\n+        }\n+\n+        // peel off one chunk from the untouched memory\n+        auto tmp = m_untouched_memory_iterator;\n+        m_untouched_memory_iterator = static_cast<char*>(tmp) + m_chunk_size_bytes;\n+        return static_cast<T*>(tmp);\n+    }\n+\n+    /**\n+     * Puts p back into the free list f it was actually allocated from the memory block.\n+     */\n+    template <typename T>\n+    void Deallocate(void* p, std::size_t n) noexcept\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size_bytes = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes == required_chunk_size_bytes && n == 1) {\n+            // put it into the linked list\n+            auto node = static_cast<ChunkNode*>(p);\n+            node->next = m_free_chunks;\n+            m_free_chunks = node;\n+        } else {\n+            // allocation didn't happen with the pool\n+            ::operator delete(p);\n+        }\n+    }\n+\n+    /**\n+     * Actual size in bytes that is used for one chunk (node allocation)\n+     */\n+    [[nodiscard]] size_t ChunkSize() const noexcept\n+    {\n+        return m_chunk_size_bytes;\n+    }\n+\n+    /**\n+     * Calculates bytes allocated by the memory resource.\n+     */\n+    [[nodiscard]] size_t DynamicMemoryUsage() const noexcept\n+    {\n+        if (m_chunk_size_bytes == 0) {\n+            return 0;\n+        }\n+        size_t alloc_size = (m_block_size_bytes / m_chunk_size_bytes) * m_chunk_size_bytes;\n+        return memusage::MallocUsage(alloc_size) * m_allocated_blocks.size() + memusage::DynamicUsage(m_allocated_blocks);\n+    }\n+\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation. Mostly for debugging / logging / testing.\n+     */\n+    [[nodiscard]] size_t NumFreeChunks() const noexcept\n+    {\n+        size_t length = 0;\n+        auto node = m_free_chunks;\n+        while (node) {\n+            node = static_cast<ChunkNode const*>(node)->next;\n+            ++length;\n+        }\n+        return length;\n+    }\n+\n+    /**\n+     * Number of memory blocks that have been allocated\n+     */\n+    [[nodiscard]] size_t NumBlocks() const noexcept\n+    {\n+        return m_allocated_blocks.size();\n+    }\n+\n+    /**\n+     * Calculates the required chunk size for the given type.\n+     * The memory block needs to be correctly aligned and large enough to hold both T and ChunkNode.\n+     */\n+    template <typename T>\n+    [[nodiscard]] static constexpr size_t CalcRequiredChunkSizeBytes() noexcept\n+    {\n+        auto alignment_max = std::max(std::alignment_of_v<T>, std::alignment_of_v<ChunkNode>);\n+        auto size_max = std::max(sizeof(T), sizeof(ChunkNode));\n+\n+        // find closest multiple of alignment_max that holds size_max\n+        return ((size_max + alignment_max - 1U) / alignment_max) * alignment_max;\n+    }\n+\n+private:\n+    /**\n+     * Allocate one full memory block which is used to carve out chunks.\n+     * The block size is the multiple of m_chunk_size_bytes that comes closest to m_block_size_bytes.\n+     */\n+    void AllocateNewBlock()\n+    {\n+        static_assert(sizeof(char) == 1U);\n+\n+        auto const num_chunks = m_block_size_bytes / m_chunk_size_bytes;\n+        m_untouched_memory_iterator = ::operator new(num_chunks* m_chunk_size_bytes);\n+        m_untouched_memory_end = static_cast<char*>(m_untouched_memory_iterator) + num_chunks * m_chunk_size_bytes;\n+        m_allocated_blocks.push_back(m_untouched_memory_iterator);\n+    }\n+\n+    //! A single linked list of all data available in the pool. This list is used for allocations of single elements.\n+    void* m_free_chunks = nullptr;\n+\n+    //! A contains all allocated blocks of memory, used to free the data in the destructor.",
    "path": "src/support/allocators/node_allocator.h",
    "position": null,
    "original_position": 267,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "6fa1a72e7dd9ff1e99c6e2ad0531619d119045f9",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "\"A contains\" ... what is A?",
    "created_at": "2021-08-20T20:58:04Z",
    "updated_at": "2021-08-20T21:27:28Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r693215356",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/693215356"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r693215356"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/693215356/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 257,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/693219259",
    "pull_request_review_id": 735378772,
    "id": 693219259,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5MzIxOTI1OQ==",
    "diff_hunk": "@@ -0,0 +1,399 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <cstddef>\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no control structure is required for each node memory; the free list is stored in-place. This typically saves\n+ *   about 8 bytes per node.\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements. So freeing and malloc'ing again\n+ *   can have an advantageous access pattern which leads to less cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator` compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Since there is\n+ * unfortunately no way to determine the size of nodes that we want to optimize for in advance, MemoryResource uses\n+ * a simple heuristic: We assume the first call to Allocate with 1 element is for the node, and upon that first call the\n+ * MemoryResource is configured to use that as its chunk size. Note that due to this heuristic we cannot implement a\n+ * `std::pmr::memory_resource` because it does not give the information about the number of elements.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall \u201cHow to Write a Custom Allocator\u201d https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer \u201cAn Allocator is a Handle to a Heap\u201d https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *     https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block. Whenever a node is given back\n+ *   with Deallocate(), it is put into a free list.\n+ */\n+class MemoryResource\n+{\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object that uses the specified block size for allocations.\n+     * Actually the real block size can be a bit smaller, it will be the largest multiple of chunk size\n+     * that fits into the block.\n+     */\n+    explicit MemoryResource(size_t block_size_byte) : m_block_size_bytes(block_size_byte) {}\n+\n+    MemoryResource() = default;\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated blocks.\n+     */\n+    ~MemoryResource() noexcept\n+    {\n+        Clear();\n+    }\n+\n+    /**\n+     * Clears all allocated blocks.\n+     *\n+     * Memory is freed regardless if its still in use, so use with care! E.g. only after a call to clear() to the underlying container.\n+     */\n+    void Clear()\n+    {\n+        for (auto* block : m_allocated_blocks) {\n+            ::operator delete(block);\n+        }\n+        m_free_chunks = nullptr;\n+        m_allocated_blocks.clear();\n+        m_chunk_size_bytes = 0U;\n+        m_untouched_memory_iterator = nullptr;\n+        m_untouched_memory_end = nullptr;\n+    }\n+\n+    /**\n+     * Allocates memory for n times T. Only when n==1 the memory blocks are used to give out memory. The first call with n==1\n+     * decides the chunk size.\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size = CalcRequiredChunkSizeBytes<T>();\n+\n+        // only use pool when a single element is allocated\n+        if (m_chunk_size_bytes == 0 && n == 1) {\n+            // first call to Allocate with n==1 determines chunk size\n+            m_chunk_size_bytes = required_chunk_size;\n+        }\n+\n+        if (m_chunk_size_bytes != required_chunk_size || n != 1) {\n+            // pool is not used so forward to operator new.\n+            return static_cast<T*>(::operator new(n * sizeof(T)));\n+        }\n+\n+        // chunk size is correct, so we can actually use the pool's block data\n+\n+        if (m_free_chunks) {\n+            // we've already got data in the free list, unlink one element\n+            auto old_head = m_free_chunks;\n+            m_free_chunks = static_cast<ChunkNode*>(m_free_chunks)->next;\n+            return static_cast<T*>(old_head);\n+        }\n+\n+        // free list is empty: get one chunk from allocated block memory.\n+        // It makes sense to not create the fully linked list of an allocated block up front, for several reasons\n+        // On the one hand, the latency is higher when we need to iterate and update pointers for the whole block at once.\n+        // More importantly, most systems lazily allocate data. So when we allocate a big block of memory the memory for a page\n+        // is only actually made available to the program when it is first touched. So when we allocate a big block and only use\n+        // very little memory from it, the total memory usage is lower than what has been malloc'ed.\n+        if (m_untouched_memory_iterator == m_untouched_memory_end) {\n+            // slow path, only happens when a new block needs to be allocated\n+            AllocateNewBlock();\n+        }\n+\n+        // peel off one chunk from the untouched memory\n+        auto tmp = m_untouched_memory_iterator;\n+        m_untouched_memory_iterator = static_cast<char*>(tmp) + m_chunk_size_bytes;\n+        return static_cast<T*>(tmp);\n+    }\n+\n+    /**\n+     * Puts p back into the free list f it was actually allocated from the memory block.\n+     */\n+    template <typename T>\n+    void Deallocate(void* p, std::size_t n) noexcept\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size_bytes = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes == required_chunk_size_bytes && n == 1) {\n+            // put it into the linked list\n+            auto node = static_cast<ChunkNode*>(p);\n+            node->next = m_free_chunks;\n+            m_free_chunks = node;\n+        } else {\n+            // allocation didn't happen with the pool\n+            ::operator delete(p);\n+        }\n+    }\n+\n+    /**\n+     * Actual size in bytes that is used for one chunk (node allocation)\n+     */\n+    [[nodiscard]] size_t ChunkSize() const noexcept\n+    {\n+        return m_chunk_size_bytes;\n+    }\n+\n+    /**\n+     * Calculates bytes allocated by the memory resource.\n+     */\n+    [[nodiscard]] size_t DynamicMemoryUsage() const noexcept\n+    {\n+        if (m_chunk_size_bytes == 0) {\n+            return 0;\n+        }\n+        size_t alloc_size = (m_block_size_bytes / m_chunk_size_bytes) * m_chunk_size_bytes;\n+        return memusage::MallocUsage(alloc_size) * m_allocated_blocks.size() + memusage::DynamicUsage(m_allocated_blocks);\n+    }\n+\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation. Mostly for debugging / logging / testing.\n+     */\n+    [[nodiscard]] size_t NumFreeChunks() const noexcept\n+    {\n+        size_t length = 0;\n+        auto node = m_free_chunks;\n+        while (node) {\n+            node = static_cast<ChunkNode const*>(node)->next;\n+            ++length;\n+        }\n+        return length;\n+    }\n+\n+    /**\n+     * Number of memory blocks that have been allocated\n+     */\n+    [[nodiscard]] size_t NumBlocks() const noexcept\n+    {\n+        return m_allocated_blocks.size();\n+    }\n+\n+    /**\n+     * Calculates the required chunk size for the given type.\n+     * The memory block needs to be correctly aligned and large enough to hold both T and ChunkNode.\n+     */\n+    template <typename T>\n+    [[nodiscard]] static constexpr size_t CalcRequiredChunkSizeBytes() noexcept\n+    {\n+        auto alignment_max = std::max(std::alignment_of_v<T>, std::alignment_of_v<ChunkNode>);\n+        auto size_max = std::max(sizeof(T), sizeof(ChunkNode));\n+\n+        // find closest multiple of alignment_max that holds size_max\n+        return ((size_max + alignment_max - 1U) / alignment_max) * alignment_max;\n+    }\n+\n+private:\n+    /**\n+     * Allocate one full memory block which is used to carve out chunks.\n+     * The block size is the multiple of m_chunk_size_bytes that comes closest to m_block_size_bytes.\n+     */\n+    void AllocateNewBlock()\n+    {\n+        static_assert(sizeof(char) == 1U);\n+\n+        auto const num_chunks = m_block_size_bytes / m_chunk_size_bytes;\n+        m_untouched_memory_iterator = ::operator new(num_chunks* m_chunk_size_bytes);\n+        m_untouched_memory_end = static_cast<char*>(m_untouched_memory_iterator) + num_chunks * m_chunk_size_bytes;\n+        m_allocated_blocks.push_back(m_untouched_memory_iterator);\n+    }\n+\n+    //! A single linked list of all data available in the pool. This list is used for allocations of single elements.\n+    void* m_free_chunks = nullptr;\n+\n+    //! A contains all allocated blocks of memory, used to free the data in the destructor.\n+    std::vector<void*> m_allocated_blocks{};\n+\n+    //! The pool's size for the memory blocks. First call to Allocate() determines the used size.",
    "path": "src/support/allocators/node_allocator.h",
    "position": null,
    "original_position": 270,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "6fa1a72e7dd9ff1e99c6e2ad0531619d119045f9",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "I think this comment is incorrect (this is the size of one chunk; blocks are a multiple of that).",
    "created_at": "2021-08-20T21:07:09Z",
    "updated_at": "2021-08-20T21:27:28Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r693219259",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/693219259"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r693219259"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/693219259/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 270,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/693225214",
    "pull_request_review_id": 735378772,
    "id": 693225214,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5MzIyNTIxNA==",
    "diff_hunk": "@@ -0,0 +1,399 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <cstddef>\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no control structure is required for each node memory; the free list is stored in-place. This typically saves\n+ *   about 8 bytes per node.\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements. So freeing and malloc'ing again\n+ *   can have an advantageous access pattern which leads to less cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator` compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Since there is\n+ * unfortunately no way to determine the size of nodes that we want to optimize for in advance, MemoryResource uses\n+ * a simple heuristic: We assume the first call to Allocate with 1 element is for the node, and upon that first call the\n+ * MemoryResource is configured to use that as its chunk size. Note that due to this heuristic we cannot implement a\n+ * `std::pmr::memory_resource` because it does not give the information about the number of elements.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall \u201cHow to Write a Custom Allocator\u201d https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer \u201cAn Allocator is a Handle to a Heap\u201d https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *     https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block. Whenever a node is given back\n+ *   with Deallocate(), it is put into a free list.\n+ */\n+class MemoryResource\n+{\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object that uses the specified block size for allocations.\n+     * Actually the real block size can be a bit smaller, it will be the largest multiple of chunk size\n+     * that fits into the block.\n+     */\n+    explicit MemoryResource(size_t block_size_byte) : m_block_size_bytes(block_size_byte) {}\n+\n+    MemoryResource() = default;\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated blocks.\n+     */\n+    ~MemoryResource() noexcept\n+    {\n+        Clear();\n+    }\n+\n+    /**\n+     * Clears all allocated blocks.\n+     *\n+     * Memory is freed regardless if its still in use, so use with care! E.g. only after a call to clear() to the underlying container.\n+     */\n+    void Clear()\n+    {\n+        for (auto* block : m_allocated_blocks) {\n+            ::operator delete(block);\n+        }\n+        m_free_chunks = nullptr;\n+        m_allocated_blocks.clear();\n+        m_chunk_size_bytes = 0U;\n+        m_untouched_memory_iterator = nullptr;\n+        m_untouched_memory_end = nullptr;\n+    }\n+\n+    /**\n+     * Allocates memory for n times T. Only when n==1 the memory blocks are used to give out memory. The first call with n==1\n+     * decides the chunk size.\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size = CalcRequiredChunkSizeBytes<T>();\n+\n+        // only use pool when a single element is allocated\n+        if (m_chunk_size_bytes == 0 && n == 1) {\n+            // first call to Allocate with n==1 determines chunk size\n+            m_chunk_size_bytes = required_chunk_size;\n+        }\n+\n+        if (m_chunk_size_bytes != required_chunk_size || n != 1) {\n+            // pool is not used so forward to operator new.\n+            return static_cast<T*>(::operator new(n * sizeof(T)));\n+        }\n+\n+        // chunk size is correct, so we can actually use the pool's block data\n+\n+        if (m_free_chunks) {\n+            // we've already got data in the free list, unlink one element\n+            auto old_head = m_free_chunks;\n+            m_free_chunks = static_cast<ChunkNode*>(m_free_chunks)->next;\n+            return static_cast<T*>(old_head);\n+        }\n+\n+        // free list is empty: get one chunk from allocated block memory.\n+        // It makes sense to not create the fully linked list of an allocated block up front, for several reasons\n+        // On the one hand, the latency is higher when we need to iterate and update pointers for the whole block at once.\n+        // More importantly, most systems lazily allocate data. So when we allocate a big block of memory the memory for a page\n+        // is only actually made available to the program when it is first touched. So when we allocate a big block and only use\n+        // very little memory from it, the total memory usage is lower than what has been malloc'ed.\n+        if (m_untouched_memory_iterator == m_untouched_memory_end) {\n+            // slow path, only happens when a new block needs to be allocated\n+            AllocateNewBlock();\n+        }\n+\n+        // peel off one chunk from the untouched memory\n+        auto tmp = m_untouched_memory_iterator;",
    "path": "src/support/allocators/node_allocator.h",
    "position": null,
    "original_position": 168,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "6fa1a72e7dd9ff1e99c6e2ad0531619d119045f9",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Perhaps add a comment here explaining that the `next` pointer of in-use elements actually doesn't matter until it's deallocated, so it doesn't need initialization here.",
    "created_at": "2021-08-20T21:21:34Z",
    "updated_at": "2021-08-20T21:27:28Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r693225214",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/693225214"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r693225214"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/693225214/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 158,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/693308019",
    "pull_request_review_id": 735469428,
    "id": 693308019,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5MzMwODAxOQ==",
    "diff_hunk": "@@ -0,0 +1,399 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <cstddef>\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no control structure is required for each node memory; the free list is stored in-place. This typically saves\n+ *   about 8 bytes per node.\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements. So freeing and malloc'ing again",
    "path": "src/support/allocators/node_allocator.h",
    "position": null,
    "original_position": 37,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "6fa1a72e7dd9ff1e99c6e2ad0531619d119045f9",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "yes I wanted to clarify that the linked list's can become relatively random access pattern into the memory, which can be slower due to lots of cache misses. I'll fix the comment",
    "created_at": "2021-08-21T05:35:40Z",
    "updated_at": "2021-08-21T05:35:40Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r693308019",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/693308019"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r693308019"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/693308019/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 38,
    "side": "RIGHT",
    "in_reply_to_id": 693212773
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/693308135",
    "pull_request_review_id": 735469503,
    "id": 693308135,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5MzMwODEzNQ==",
    "diff_hunk": "@@ -0,0 +1,399 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <cstddef>\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no control structure is required for each node memory; the free list is stored in-place. This typically saves\n+ *   about 8 bytes per node.\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements. So freeing and malloc'ing again\n+ *   can have an advantageous access pattern which leads to less cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator` compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Since there is\n+ * unfortunately no way to determine the size of nodes that we want to optimize for in advance, MemoryResource uses\n+ * a simple heuristic: We assume the first call to Allocate with 1 element is for the node, and upon that first call the\n+ * MemoryResource is configured to use that as its chunk size. Note that due to this heuristic we cannot implement a\n+ * `std::pmr::memory_resource` because it does not give the information about the number of elements.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall \u201cHow to Write a Custom Allocator\u201d https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer \u201cAn Allocator is a Handle to a Heap\u201d https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *     https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block. Whenever a node is given back\n+ *   with Deallocate(), it is put into a free list.\n+ */\n+class MemoryResource\n+{\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object that uses the specified block size for allocations.\n+     * Actually the real block size can be a bit smaller, it will be the largest multiple of chunk size\n+     * that fits into the block.\n+     */\n+    explicit MemoryResource(size_t block_size_byte) : m_block_size_bytes(block_size_byte) {}\n+\n+    MemoryResource() = default;\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated blocks.\n+     */\n+    ~MemoryResource() noexcept\n+    {\n+        Clear();\n+    }\n+\n+    /**\n+     * Clears all allocated blocks.\n+     *\n+     * Memory is freed regardless if its still in use, so use with care! E.g. only after a call to clear() to the underlying container.\n+     */\n+    void Clear()\n+    {\n+        for (auto* block : m_allocated_blocks) {\n+            ::operator delete(block);\n+        }\n+        m_free_chunks = nullptr;\n+        m_allocated_blocks.clear();\n+        m_chunk_size_bytes = 0U;\n+        m_untouched_memory_iterator = nullptr;\n+        m_untouched_memory_end = nullptr;\n+    }\n+\n+    /**\n+     * Allocates memory for n times T. Only when n==1 the memory blocks are used to give out memory. The first call with n==1\n+     * decides the chunk size.\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size = CalcRequiredChunkSizeBytes<T>();\n+\n+        // only use pool when a single element is allocated\n+        if (m_chunk_size_bytes == 0 && n == 1) {\n+            // first call to Allocate with n==1 determines chunk size\n+            m_chunk_size_bytes = required_chunk_size;\n+        }\n+\n+        if (m_chunk_size_bytes != required_chunk_size || n != 1) {\n+            // pool is not used so forward to operator new.\n+            return static_cast<T*>(::operator new(n * sizeof(T)));\n+        }\n+\n+        // chunk size is correct, so we can actually use the pool's block data\n+\n+        if (m_free_chunks) {\n+            // we've already got data in the free list, unlink one element\n+            auto old_head = m_free_chunks;\n+            m_free_chunks = static_cast<ChunkNode*>(m_free_chunks)->next;\n+            return static_cast<T*>(old_head);\n+        }\n+\n+        // free list is empty: get one chunk from allocated block memory.\n+        // It makes sense to not create the fully linked list of an allocated block up front, for several reasons\n+        // On the one hand, the latency is higher when we need to iterate and update pointers for the whole block at once.\n+        // More importantly, most systems lazily allocate data. So when we allocate a big block of memory the memory for a page\n+        // is only actually made available to the program when it is first touched. So when we allocate a big block and only use\n+        // very little memory from it, the total memory usage is lower than what has been malloc'ed.\n+        if (m_untouched_memory_iterator == m_untouched_memory_end) {\n+            // slow path, only happens when a new block needs to be allocated\n+            AllocateNewBlock();\n+        }\n+\n+        // peel off one chunk from the untouched memory\n+        auto tmp = m_untouched_memory_iterator;\n+        m_untouched_memory_iterator = static_cast<char*>(tmp) + m_chunk_size_bytes;\n+        return static_cast<T*>(tmp);\n+    }\n+\n+    /**\n+     * Puts p back into the free list f it was actually allocated from the memory block.\n+     */\n+    template <typename T>\n+    void Deallocate(void* p, std::size_t n) noexcept\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size_bytes = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes == required_chunk_size_bytes && n == 1) {\n+            // put it into the linked list\n+            auto node = static_cast<ChunkNode*>(p);\n+            node->next = m_free_chunks;\n+            m_free_chunks = node;\n+        } else {\n+            // allocation didn't happen with the pool\n+            ::operator delete(p);\n+        }\n+    }\n+\n+    /**\n+     * Actual size in bytes that is used for one chunk (node allocation)\n+     */\n+    [[nodiscard]] size_t ChunkSize() const noexcept\n+    {\n+        return m_chunk_size_bytes;\n+    }\n+\n+    /**\n+     * Calculates bytes allocated by the memory resource.\n+     */\n+    [[nodiscard]] size_t DynamicMemoryUsage() const noexcept\n+    {\n+        if (m_chunk_size_bytes == 0) {\n+            return 0;\n+        }\n+        size_t alloc_size = (m_block_size_bytes / m_chunk_size_bytes) * m_chunk_size_bytes;\n+        return memusage::MallocUsage(alloc_size) * m_allocated_blocks.size() + memusage::DynamicUsage(m_allocated_blocks);\n+    }\n+\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation. Mostly for debugging / logging / testing.\n+     */\n+    [[nodiscard]] size_t NumFreeChunks() const noexcept\n+    {\n+        size_t length = 0;\n+        auto node = m_free_chunks;\n+        while (node) {\n+            node = static_cast<ChunkNode const*>(node)->next;\n+            ++length;\n+        }\n+        return length;\n+    }\n+\n+    /**\n+     * Number of memory blocks that have been allocated\n+     */\n+    [[nodiscard]] size_t NumBlocks() const noexcept\n+    {\n+        return m_allocated_blocks.size();\n+    }\n+\n+    /**\n+     * Calculates the required chunk size for the given type.\n+     * The memory block needs to be correctly aligned and large enough to hold both T and ChunkNode.\n+     */\n+    template <typename T>\n+    [[nodiscard]] static constexpr size_t CalcRequiredChunkSizeBytes() noexcept\n+    {\n+        auto alignment_max = std::max(std::alignment_of_v<T>, std::alignment_of_v<ChunkNode>);\n+        auto size_max = std::max(sizeof(T), sizeof(ChunkNode));\n+\n+        // find closest multiple of alignment_max that holds size_max\n+        return ((size_max + alignment_max - 1U) / alignment_max) * alignment_max;\n+    }\n+\n+private:\n+    /**\n+     * Allocate one full memory block which is used to carve out chunks.\n+     * The block size is the multiple of m_chunk_size_bytes that comes closest to m_block_size_bytes.\n+     */\n+    void AllocateNewBlock()\n+    {\n+        static_assert(sizeof(char) == 1U);\n+\n+        auto const num_chunks = m_block_size_bytes / m_chunk_size_bytes;\n+        m_untouched_memory_iterator = ::operator new(num_chunks* m_chunk_size_bytes);\n+        m_untouched_memory_end = static_cast<char*>(m_untouched_memory_iterator) + num_chunks * m_chunk_size_bytes;\n+        m_allocated_blocks.push_back(m_untouched_memory_iterator);\n+    }\n+\n+    //! A single linked list of all data available in the pool. This list is used for allocations of single elements.\n+    void* m_free_chunks = nullptr;\n+\n+    //! A contains all allocated blocks of memory, used to free the data in the destructor.",
    "path": "src/support/allocators/node_allocator.h",
    "position": null,
    "original_position": 267,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "6fa1a72e7dd9ff1e99c6e2ad0531619d119045f9",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Should be just \"Contains all allocated blocks of memory\"",
    "created_at": "2021-08-21T05:36:28Z",
    "updated_at": "2021-08-21T05:36:28Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r693308135",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/693308135"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r693308135"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/693308135/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 257,
    "side": "RIGHT",
    "in_reply_to_id": 693215356
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/696103452",
    "pull_request_review_id": 738531236,
    "id": 696103452,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NjEwMzQ1Mg==",
    "diff_hunk": "@@ -135,7 +143,7 @@ BOOST_AUTO_TEST_CASE(getcoinscachesizestate)\n         BOOST_CHECK(usage_percentage >= 0.9);\n         BOOST_CHECK(usage_percentage < 1);\n         BOOST_CHECK_EQUAL(\n-            chainstate.GetCoinsCacheSizeState(MAX_COINS_CACHE_BYTES, 1 << 10),\n+            chainstate.GetCoinsCacheSizeState(MAX_COINS_CACHE_BYTES, 512),",
    "path": "src/test/validation_flush_tests.cpp",
    "position": null,
    "original_position": 67,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "c6561fd394aab850ac2d8bc6889eaaa274c4abda",
    "user": {
      "login": "jonatack",
      "id": 2415484,
      "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonatack",
      "html_url": "https://github.com/jonatack",
      "followers_url": "https://api.github.com/users/jonatack/followers",
      "following_url": "https://api.github.com/users/jonatack/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonatack/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
      "organizations_url": "https://api.github.com/users/jonatack/orgs",
      "repos_url": "https://api.github.com/users/jonatack/repos",
      "events_url": "https://api.github.com/users/jonatack/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonatack/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "As far as I can tell, this can remain `1 << 10` (1024).\r\n\r\nIn both cases, invoking the test with `src/test/test_bitcoin -t validation_flush_tests -l test_suite` prints `CoinsTip usage percentage: 0.997634`\r\n```suggestion\r\n            chainstate.GetCoinsCacheSizeState(MAX_COINS_CACHE_BYTES, /*max_mempool_size_bytes*/ 1 << 10), // 1024\r\n```",
    "created_at": "2021-08-25T20:50:36Z",
    "updated_at": "2021-08-25T21:31:24Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r696103452",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/696103452"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r696103452"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/696103452/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 146,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/696124457",
    "pull_request_review_id": 738531236,
    "id": 696124457,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NjEyNDQ1Nw==",
    "diff_hunk": "@@ -0,0 +1,371 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <support/allocators/node_allocator.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <list>\n+#include <map>\n+#include <string>\n+#include <unordered_map>\n+\n+BOOST_FIXTURE_TEST_SUITE(node_allocator_tests, BasicTestingSetup)\n+\n+#define CHECK_MEMORY_RESOURCE(mr, chunk_size, num_free_chunks, num_blocks) \\\n+    BOOST_CHECK_EQUAL(chunk_size, mr.ChunkSizeBytes());                    \\\n+    BOOST_CHECK_EQUAL(num_free_chunks, mr.NumFreeChunks());                \\\n+    BOOST_CHECK_EQUAL(num_blocks, mr.NumBlocks());\n+\n+#define CHECK_IN_RANGE(what, lowerInclusive, upperInclusive) \\\n+    BOOST_TEST(what >= lowerInclusive);                      \\\n+    BOOST_TEST(what <= upperInclusive);\n+\n+BOOST_AUTO_TEST_CASE(too_small)\n+{\n+    node_allocator::MemoryResource mr(sizeof(void*));\n+    void* ptr = mr.Allocate<char>(1);\n+    BOOST_CHECK(ptr != nullptr);\n+\n+    // mr is used\n+    CHECK_MEMORY_RESOURCE(mr, sizeof(void*), 0, 1);\n+    mr.Deallocate<char>(ptr, 1);\n+    CHECK_MEMORY_RESOURCE(mr, sizeof(void*), 1, 1);\n+\n+    // void* works too, use freelist\n+    ptr = mr.Allocate<void*>(1);\n+    BOOST_CHECK(ptr != nullptr);\n+    CHECK_MEMORY_RESOURCE(mr, sizeof(void*), 0, 1);\n+    mr.Deallocate<char>(ptr, 1);\n+    CHECK_MEMORY_RESOURCE(mr, sizeof(void*), 1, 1);\n+}\n+\n+BOOST_AUTO_TEST_CASE(std_unordered_map)\n+{\n+    using Factory = node_allocator::UnorderedMapFactory<uint64_t, uint64_t>;\n+\n+    auto mr = Factory::CreateMemoryResource();\n+    auto m = Factory::CreateContainer(&mr);\n+    size_t num_free_chunks = 0;\n+    {\n+        auto a = Factory::CreateContainer(&mr);\n+\n+        // Allocator compares equal because the same memory resource is used\n+        BOOST_CHECK(a.get_allocator() == m.get_allocator());\n+        for (uint64_t i = 0; i < 1000; ++i) {\n+            a[i] = i;\n+        }\n+\n+        num_free_chunks = mr.NumFreeChunks();\n+\n+        // create a copy of the map, destroy the map => now a lot more free chunks should be available\n+        {\n+            auto b = a;\n+        }\n+\n+        BOOST_CHECK(mr.NumFreeChunks() > num_free_chunks);\n+        num_free_chunks = mr.NumFreeChunks();\n+\n+        // creating another copy, and then destroying everything should reuse all the chunks\n+        {\n+            auto b = a;\n+        }\n+        BOOST_CHECK_EQUAL(mr.NumFreeChunks(), num_free_chunks);\n+\n+        // moving the map should not create new nodes\n+        m = std::move(a);\n+        BOOST_CHECK_EQUAL(mr.NumFreeChunks(), num_free_chunks);\n+    }\n+    // a is destroyed, still all chunks should stay roughly the same.\n+    BOOST_CHECK(mr.NumFreeChunks() <= num_free_chunks + 5);\n+\n+    m = Factory::CreateContainer(&mr);\n+\n+    // now we got everything free\n+    BOOST_CHECK(mr.NumFreeChunks() > num_free_chunks + 50);\n+}\n+\n+BOOST_AUTO_TEST_CASE(different_memoryresource_assignment)\n+{\n+    using Factory = node_allocator::UnorderedMapFactory<uint64_t, uint64_t>;\n+\n+    auto mr_a = Factory::CreateMemoryResource();\n+    auto mr_b = Factory::CreateMemoryResource();\n+\n+    {\n+        auto map_a = Factory::CreateContainer(&mr_a);\n+        for (int i = 0; i < 100; ++i) {\n+            map_a[i] = i;\n+        }\n+\n+        {\n+            auto map_b = Factory::CreateContainer(&mr_b);\n+            map_b[123] = 321;\n+            BOOST_CHECK(map_a.get_allocator() != map_b.get_allocator());\n+            BOOST_CHECK_EQUAL(mr_b.NumFreeChunks(), 0);\n+            BOOST_CHECK_EQUAL(mr_b.NumBlocks(), 1);\n+\n+            map_b = map_a;\n+\n+            // map_a now uses mr_b, since propagate_on_container_copy_assignment is std::true_type\n+            BOOST_CHECK(map_a.get_allocator() == map_b.get_allocator());\n+            CHECK_IN_RANGE(mr_b.NumFreeChunks(), 1U, 2U);\n+            BOOST_CHECK_EQUAL(mr_b.NumBlocks(), 1);\n+\n+            // map_b was now recreated with data from map_a, using mr_a as the memory resource.\n+        }\n+\n+        // map_b destroyed, should not have any effect on mr_b\n+        CHECK_IN_RANGE(mr_b.NumFreeChunks(), 1U, 2U);\n+        BOOST_CHECK_EQUAL(mr_b.NumBlocks(), 1);\n+        // but we'll get more free chunks in mr_a\n+        CHECK_IN_RANGE(mr_a.NumFreeChunks(), 100U, 101U);\n+    }\n+\n+    // finally map_a is destroyed, getting more free chunks.\n+    CHECK_IN_RANGE(mr_a.NumFreeChunks(), 200U, 202U);\n+}\n+\n+\n+BOOST_AUTO_TEST_CASE(different_memoryresource_move)\n+{\n+    using Factory = node_allocator::UnorderedMapFactory<uint64_t, uint64_t>;\n+\n+    auto mr_a = Factory::CreateMemoryResource();\n+    auto mr_b = Factory::CreateMemoryResource();\n+\n+    {\n+        auto map_a = Factory::CreateContainer(&mr_a);\n+        for (int i = 0; i < 100; ++i) {\n+            map_a[i] = i;\n+        }\n+\n+        {\n+            auto map_b = Factory::CreateContainer(&mr_b);\n+            map_b[123] = 321;\n+\n+            map_b = std::move(map_a);\n+\n+            // map_a now uses mr_b, since propagate_on_container_copy_assignment is std::true_type",
    "path": "src/test/node_allocator_tests.cpp",
    "position": null,
    "original_position": 152,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "c6561fd394aab850ac2d8bc6889eaaa274c4abda",
    "user": {
      "login": "jonatack",
      "id": 2415484,
      "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonatack",
      "html_url": "https://github.com/jonatack",
      "followers_url": "https://api.github.com/users/jonatack/followers",
      "following_url": "https://api.github.com/users/jonatack/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonatack/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
      "organizations_url": "https://api.github.com/users/jonatack/orgs",
      "repos_url": "https://api.github.com/users/jonatack/repos",
      "events_url": "https://api.github.com/users/jonatack/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonatack/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "```suggestion\r\n            // map_a now uses mr_b, since propagate_on_container_move_assignment is std::true_type\r\n```",
    "created_at": "2021-08-25T21:25:28Z",
    "updated_at": "2021-08-25T21:31:24Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r696124457",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/696124457"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r696124457"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/696124457/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 152,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/697171063",
    "pull_request_review_id": 740162998,
    "id": 697171063,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NzE3MTA2Mw==",
    "diff_hunk": "@@ -0,0 +1,399 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <cstddef>\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no control structure is required for each node memory; the free list is stored in-place. This typically saves\n+ *   about 8 bytes per node.\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements. So freeing and malloc'ing again\n+ *   can have an advantageous access pattern which leads to less cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator` compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Since there is\n+ * unfortunately no way to determine the size of nodes that we want to optimize for in advance, MemoryResource uses\n+ * a simple heuristic: We assume the first call to Allocate with 1 element is for the node, and upon that first call the\n+ * MemoryResource is configured to use that as its chunk size. Note that due to this heuristic we cannot implement a\n+ * `std::pmr::memory_resource` because it does not give the information about the number of elements.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall \u201cHow to Write a Custom Allocator\u201d https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer \u201cAn Allocator is a Handle to a Heap\u201d https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *     https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block. Whenever a node is given back\n+ *   with Deallocate(), it is put into a free list.\n+ */\n+class MemoryResource\n+{\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object that uses the specified block size for allocations.\n+     * Actually the real block size can be a bit smaller, it will be the largest multiple of chunk size\n+     * that fits into the block.\n+     */\n+    explicit MemoryResource(size_t block_size_byte) : m_block_size_bytes(block_size_byte) {}\n+\n+    MemoryResource() = default;\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated blocks.\n+     */\n+    ~MemoryResource() noexcept\n+    {\n+        Clear();\n+    }\n+\n+    /**\n+     * Clears all allocated blocks.\n+     *\n+     * Memory is freed regardless if its still in use, so use with care! E.g. only after a call to clear() to the underlying container.\n+     */\n+    void Clear()\n+    {\n+        for (auto* block : m_allocated_blocks) {\n+            ::operator delete(block);\n+        }\n+        m_free_chunks = nullptr;\n+        m_allocated_blocks.clear();\n+        m_chunk_size_bytes = 0U;\n+        m_untouched_memory_iterator = nullptr;\n+        m_untouched_memory_end = nullptr;\n+    }\n+\n+    /**\n+     * Allocates memory for n times T. Only when n==1 the memory blocks are used to give out memory. The first call with n==1\n+     * decides the chunk size.\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size = CalcRequiredChunkSizeBytes<T>();\n+\n+        // only use pool when a single element is allocated\n+        if (m_chunk_size_bytes == 0 && n == 1) {\n+            // first call to Allocate with n==1 determines chunk size\n+            m_chunk_size_bytes = required_chunk_size;\n+        }\n+\n+        if (m_chunk_size_bytes != required_chunk_size || n != 1) {\n+            // pool is not used so forward to operator new.\n+            return static_cast<T*>(::operator new(n * sizeof(T)));\n+        }\n+\n+        // chunk size is correct, so we can actually use the pool's block data\n+\n+        if (m_free_chunks) {\n+            // we've already got data in the free list, unlink one element\n+            auto old_head = m_free_chunks;\n+            m_free_chunks = static_cast<ChunkNode*>(m_free_chunks)->next;\n+            return static_cast<T*>(old_head);\n+        }\n+\n+        // free list is empty: get one chunk from allocated block memory.\n+        // It makes sense to not create the fully linked list of an allocated block up front, for several reasons\n+        // On the one hand, the latency is higher when we need to iterate and update pointers for the whole block at once.\n+        // More importantly, most systems lazily allocate data. So when we allocate a big block of memory the memory for a page\n+        // is only actually made available to the program when it is first touched. So when we allocate a big block and only use\n+        // very little memory from it, the total memory usage is lower than what has been malloc'ed.\n+        if (m_untouched_memory_iterator == m_untouched_memory_end) {\n+            // slow path, only happens when a new block needs to be allocated\n+            AllocateNewBlock();\n+        }\n+\n+        // peel off one chunk from the untouched memory\n+        auto tmp = m_untouched_memory_iterator;\n+        m_untouched_memory_iterator = static_cast<char*>(tmp) + m_chunk_size_bytes;\n+        return static_cast<T*>(tmp);\n+    }\n+\n+    /**\n+     * Puts p back into the free list f it was actually allocated from the memory block.\n+     */\n+    template <typename T>\n+    void Deallocate(void* p, std::size_t n) noexcept\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size_bytes = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes == required_chunk_size_bytes && n == 1) {\n+            // put it into the linked list\n+            auto node = static_cast<ChunkNode*>(p);\n+            node->next = m_free_chunks;\n+            m_free_chunks = node;\n+        } else {\n+            // allocation didn't happen with the pool\n+            ::operator delete(p);\n+        }\n+    }\n+\n+    /**\n+     * Actual size in bytes that is used for one chunk (node allocation)\n+     */\n+    [[nodiscard]] size_t ChunkSize() const noexcept\n+    {\n+        return m_chunk_size_bytes;\n+    }\n+\n+    /**\n+     * Calculates bytes allocated by the memory resource.\n+     */\n+    [[nodiscard]] size_t DynamicMemoryUsage() const noexcept\n+    {\n+        if (m_chunk_size_bytes == 0) {\n+            return 0;\n+        }\n+        size_t alloc_size = (m_block_size_bytes / m_chunk_size_bytes) * m_chunk_size_bytes;\n+        return memusage::MallocUsage(alloc_size) * m_allocated_blocks.size() + memusage::DynamicUsage(m_allocated_blocks);\n+    }\n+\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation. Mostly for debugging / logging / testing.\n+     */\n+    [[nodiscard]] size_t NumFreeChunks() const noexcept\n+    {\n+        size_t length = 0;\n+        auto node = m_free_chunks;\n+        while (node) {\n+            node = static_cast<ChunkNode const*>(node)->next;\n+            ++length;\n+        }\n+        return length;\n+    }\n+\n+    /**\n+     * Number of memory blocks that have been allocated\n+     */\n+    [[nodiscard]] size_t NumBlocks() const noexcept\n+    {\n+        return m_allocated_blocks.size();\n+    }\n+\n+    /**\n+     * Calculates the required chunk size for the given type.\n+     * The memory block needs to be correctly aligned and large enough to hold both T and ChunkNode.\n+     */\n+    template <typename T>\n+    [[nodiscard]] static constexpr size_t CalcRequiredChunkSizeBytes() noexcept\n+    {\n+        auto alignment_max = std::max(std::alignment_of_v<T>, std::alignment_of_v<ChunkNode>);\n+        auto size_max = std::max(sizeof(T), sizeof(ChunkNode));\n+\n+        // find closest multiple of alignment_max that holds size_max\n+        return ((size_max + alignment_max - 1U) / alignment_max) * alignment_max;\n+    }\n+\n+private:\n+    /**\n+     * Allocate one full memory block which is used to carve out chunks.\n+     * The block size is the multiple of m_chunk_size_bytes that comes closest to m_block_size_bytes.\n+     */\n+    void AllocateNewBlock()\n+    {\n+        static_assert(sizeof(char) == 1U);\n+\n+        auto const num_chunks = m_block_size_bytes / m_chunk_size_bytes;\n+        m_untouched_memory_iterator = ::operator new(num_chunks* m_chunk_size_bytes);\n+        m_untouched_memory_end = static_cast<char*>(m_untouched_memory_iterator) + num_chunks * m_chunk_size_bytes;\n+        m_allocated_blocks.push_back(m_untouched_memory_iterator);\n+    }\n+\n+    //! A single linked list of all data available in the pool. This list is used for allocations of single elements.\n+    void* m_free_chunks = nullptr;\n+\n+    //! A contains all allocated blocks of memory, used to free the data in the destructor.\n+    std::vector<void*> m_allocated_blocks{};\n+\n+    //! The pool's size for the memory blocks. First call to Allocate() determines the used size.",
    "path": "src/support/allocators/node_allocator.h",
    "position": null,
    "original_position": 270,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "6fa1a72e7dd9ff1e99c6e2ad0531619d119045f9",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "thanks, I've updated the comment",
    "created_at": "2021-08-27T05:53:58Z",
    "updated_at": "2021-08-27T05:53:58Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r697171063",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/697171063"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r697171063"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/697171063/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 270,
    "side": "RIGHT",
    "in_reply_to_id": 693219259
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/697171107",
    "pull_request_review_id": 740163071,
    "id": 697171107,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NzE3MTEwNw==",
    "diff_hunk": "@@ -0,0 +1,399 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <cstddef>\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no control structure is required for each node memory; the free list is stored in-place. This typically saves\n+ *   about 8 bytes per node.\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements. So freeing and malloc'ing again\n+ *   can have an advantageous access pattern which leads to less cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator` compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Since there is\n+ * unfortunately no way to determine the size of nodes that we want to optimize for in advance, MemoryResource uses\n+ * a simple heuristic: We assume the first call to Allocate with 1 element is for the node, and upon that first call the\n+ * MemoryResource is configured to use that as its chunk size. Note that due to this heuristic we cannot implement a\n+ * `std::pmr::memory_resource` because it does not give the information about the number of elements.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall \u201cHow to Write a Custom Allocator\u201d https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer \u201cAn Allocator is a Handle to a Heap\u201d https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *     https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block. Whenever a node is given back\n+ *   with Deallocate(), it is put into a free list.\n+ */\n+class MemoryResource\n+{\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object that uses the specified block size for allocations.\n+     * Actually the real block size can be a bit smaller, it will be the largest multiple of chunk size\n+     * that fits into the block.\n+     */\n+    explicit MemoryResource(size_t block_size_byte) : m_block_size_bytes(block_size_byte) {}\n+\n+    MemoryResource() = default;\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated blocks.\n+     */\n+    ~MemoryResource() noexcept\n+    {\n+        Clear();\n+    }\n+\n+    /**\n+     * Clears all allocated blocks.\n+     *\n+     * Memory is freed regardless if its still in use, so use with care! E.g. only after a call to clear() to the underlying container.\n+     */\n+    void Clear()\n+    {\n+        for (auto* block : m_allocated_blocks) {\n+            ::operator delete(block);\n+        }\n+        m_free_chunks = nullptr;\n+        m_allocated_blocks.clear();\n+        m_chunk_size_bytes = 0U;\n+        m_untouched_memory_iterator = nullptr;\n+        m_untouched_memory_end = nullptr;\n+    }\n+\n+    /**\n+     * Allocates memory for n times T. Only when n==1 the memory blocks are used to give out memory. The first call with n==1\n+     * decides the chunk size.\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size = CalcRequiredChunkSizeBytes<T>();\n+\n+        // only use pool when a single element is allocated\n+        if (m_chunk_size_bytes == 0 && n == 1) {\n+            // first call to Allocate with n==1 determines chunk size\n+            m_chunk_size_bytes = required_chunk_size;\n+        }\n+\n+        if (m_chunk_size_bytes != required_chunk_size || n != 1) {\n+            // pool is not used so forward to operator new.\n+            return static_cast<T*>(::operator new(n * sizeof(T)));\n+        }\n+\n+        // chunk size is correct, so we can actually use the pool's block data\n+\n+        if (m_free_chunks) {\n+            // we've already got data in the free list, unlink one element\n+            auto old_head = m_free_chunks;\n+            m_free_chunks = static_cast<ChunkNode*>(m_free_chunks)->next;\n+            return static_cast<T*>(old_head);\n+        }\n+\n+        // free list is empty: get one chunk from allocated block memory.\n+        // It makes sense to not create the fully linked list of an allocated block up front, for several reasons\n+        // On the one hand, the latency is higher when we need to iterate and update pointers for the whole block at once.\n+        // More importantly, most systems lazily allocate data. So when we allocate a big block of memory the memory for a page\n+        // is only actually made available to the program when it is first touched. So when we allocate a big block and only use\n+        // very little memory from it, the total memory usage is lower than what has been malloc'ed.\n+        if (m_untouched_memory_iterator == m_untouched_memory_end) {\n+            // slow path, only happens when a new block needs to be allocated\n+            AllocateNewBlock();\n+        }\n+\n+        // peel off one chunk from the untouched memory\n+        auto tmp = m_untouched_memory_iterator;",
    "path": "src/support/allocators/node_allocator.h",
    "position": null,
    "original_position": 168,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "6fa1a72e7dd9ff1e99c6e2ad0531619d119045f9",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "I've updated the comment",
    "created_at": "2021-08-27T05:54:08Z",
    "updated_at": "2021-08-27T05:54:08Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r697171107",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/697171107"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r697171107"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/697171107/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 158,
    "side": "RIGHT",
    "in_reply_to_id": 693225214
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/697171287",
    "pull_request_review_id": 740163322,
    "id": 697171287,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NzE3MTI4Nw==",
    "diff_hunk": "@@ -135,7 +143,7 @@ BOOST_AUTO_TEST_CASE(getcoinscachesizestate)\n         BOOST_CHECK(usage_percentage >= 0.9);\n         BOOST_CHECK(usage_percentage < 1);\n         BOOST_CHECK_EQUAL(\n-            chainstate.GetCoinsCacheSizeState(MAX_COINS_CACHE_BYTES, 1 << 10),\n+            chainstate.GetCoinsCacheSizeState(MAX_COINS_CACHE_BYTES, 512),",
    "path": "src/test/validation_flush_tests.cpp",
    "position": null,
    "original_position": 67,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "c6561fd394aab850ac2d8bc6889eaaa274c4abda",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Thanks again, I've squashed your review and rebased",
    "created_at": "2021-08-27T05:54:40Z",
    "updated_at": "2021-08-27T05:54:40Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r697171287",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/697171287"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r697171287"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/697171287/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 146,
    "side": "RIGHT",
    "in_reply_to_id": 696103452
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/701533891",
    "pull_request_review_id": 745649234,
    "id": 701533891,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwMTUzMzg5MQ==",
    "diff_hunk": "@@ -0,0 +1,52 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <bench/bench.h>\n+#include <coins.h>\n+#include <memusage.h>\n+#include <support/allocators/node_allocator.h>\n+\n+#include <cstring>\n+#include <iostream>\n+#include <unordered_map>\n+\n+template <typename Map>\n+void BenchFillClearMap(benchmark::Bench& bench, Map& map)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(1);\n+    tx.vin[0].scriptSig = CScript() << OP_2;\n+    tx.vin[0].scriptWitness.stack.push_back({2});\n+    tx.vout.resize(1);\n+    tx.vout[0].scriptPubKey = CScript() << OP_2 << OP_EQUAL;\n+    tx.vout[0].nValue = 10 * COIN;\n+\n+    COutPoint p{tx.GetHash(), 0};\n+\n+    bench.epochIterations(5000 * 10).run([&] {\n+        // modify hash a bit so we get a new entry in the map\n+        ++p.n;",
    "path": "src/bench/node_allocator.cpp",
    "position": null,
    "original_position": 29,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "952c37a31c39b7acdb5ab2634a354a1c548708a2",
    "user": {
      "login": "benthecarman",
      "id": 15256660,
      "node_id": "MDQ6VXNlcjE1MjU2NjYw",
      "avatar_url": "https://avatars.githubusercontent.com/u/15256660?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/benthecarman",
      "html_url": "https://github.com/benthecarman",
      "followers_url": "https://api.github.com/users/benthecarman/followers",
      "following_url": "https://api.github.com/users/benthecarman/following{/other_user}",
      "gists_url": "https://api.github.com/users/benthecarman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/benthecarman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/benthecarman/subscriptions",
      "organizations_url": "https://api.github.com/users/benthecarman/orgs",
      "repos_url": "https://api.github.com/users/benthecarman/repos",
      "events_url": "https://api.github.com/users/benthecarman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/benthecarman/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "will this be handled correctly in the case of overflow?",
    "created_at": "2021-09-03T02:00:35Z",
    "updated_at": "2021-09-03T04:30:22Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r701533891",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/701533891"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r701533891"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/701533891/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 29,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/701594319",
    "pull_request_review_id": 745717791,
    "id": 701594319,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwMTU5NDMxOQ==",
    "diff_hunk": "@@ -0,0 +1,52 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <bench/bench.h>\n+#include <coins.h>\n+#include <memusage.h>\n+#include <support/allocators/node_allocator.h>\n+\n+#include <cstring>\n+#include <iostream>\n+#include <unordered_map>\n+\n+template <typename Map>\n+void BenchFillClearMap(benchmark::Bench& bench, Map& map)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(1);\n+    tx.vin[0].scriptSig = CScript() << OP_2;\n+    tx.vin[0].scriptWitness.stack.push_back({2});\n+    tx.vout.resize(1);\n+    tx.vout[0].scriptPubKey = CScript() << OP_2 << OP_EQUAL;\n+    tx.vout[0].nValue = 10 * COIN;\n+\n+    COutPoint p{tx.GetHash(), 0};\n+\n+    bench.epochIterations(5000 * 10).run([&] {\n+        // modify hash a bit so we get a new entry in the map\n+        ++p.n;",
    "path": "src/bench/node_allocator.cpp",
    "position": null,
    "original_position": 29,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "952c37a31c39b7acdb5ab2634a354a1c548708a2",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "I think `p.n` cannot overflow here. It is initialized to 0, and since I've specified the number of iterations each measurement will have exactly 50000 iterations. I do this so I can be sure each measurement has exactly the same number of calls to `map.clear();`, which gives more stable benchmark results. Nanobench defaults to 11 measurements, so in total n will reach 550000.",
    "created_at": "2021-09-03T05:29:14Z",
    "updated_at": "2021-09-03T05:29:14Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r701594319",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/701594319"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r701594319"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/701594319/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 29,
    "side": "RIGHT",
    "in_reply_to_id": 701533891
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/728671072",
    "pull_request_review_id": 779353334,
    "id": 728671072,
    "node_id": "PRRC_kwDOABII584rbqNg",
    "diff_hunk": "@@ -0,0 +1,425 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored in-place. This typically\n+ *   saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but there is no\n+ *   standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on proximity. So freeing\n+ *   and malloc'ing again can become a random access pattern which can lead to more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Currently it is only\n+ * able provide optimized alloc/free for a single fixed node size which is given in the constructor. Only allocations that match this\n+ * size will be provided from the preallocated blocks of memory; all other requests simply use ::operator new().\n+ * To get the correct node size in all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios in\n+ * `node_allocator_tests/test_chunks_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall \u201cHow to Write a Custom Allocator\u201d https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer \u201cAn Allocator is a Handle to a Heap\u201d https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *      https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block, or from a free list if it contains entries.\n+ *   Whenever a node is given back with Deallocate(), it is put into that free list.\n+ */\n+class MemoryResource\n+{\n+    //! Size in bytes to allocate per block, currently hardcoded to 256 KiB.\n+    static constexpr size_t BlockSizeBytes = 262144;\n+\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object that uses the specified chunk size to optimize for.\n+     */\n+    explicit MemoryResource(size_t chunk_size_bytes) : m_chunk_size_bytes(chunk_size_bytes) {}\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated blocks.\n+     *\n+     * There's no Clear() method on purpose, because it would be dangerous. E.g. when calling clear() on\n+     * an unordered_map, it is not certain that all allocated chunks are given back to the MemoryResource.\n+     * Microsoft's STL still uses a control structure that might have the same size as the nodes, and therefore\n+     * needs to be kept around until the map is actually destroyed.\n+     */\n+    ~MemoryResource() noexcept\n+    {\n+        for (auto* block : m_allocated_blocks) {\n+            ::operator delete(block);\n+        }\n+    }\n+\n+    /**\n+     * Allocates memory for n times T. Only when n==1 and T's size matches m_chunk_size_bytes\n+     * the chunking mechanism is used. Otherwise, the allocation is forwarded to ::operator new().\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes != required_chunk_size || n != 1) {\n+            // pool is not used so forward to operator new.\n+            return static_cast<T*>(::operator new(n * sizeof(T)));\n+        }\n+\n+        // chunk size is correct, so we can actually use the pool's block data\n+\n+        if (m_free_chunks) {\n+            // we've already got data in the free list, unlink one element\n+            auto old_head = m_free_chunks;\n+            m_free_chunks = static_cast<ChunkNode*>(m_free_chunks)->next;\n+            return static_cast<T*>(old_head);\n+        }\n+\n+        // free list is empty: get one chunk from allocated block memory.\n+        // It makes sense to not create the fully linked list of an allocated block up-front, for several reasons.\n+        // On the one hand, the latency is higher when we need to iterate and update pointers for the whole block at once.\n+        // More importantly, most systems lazily allocate data. So when we allocate a big block of memory the memory for a page\n+        // is only actually made available to the program when it is first touched. So when we allocate a big block and only use\n+        // very little memory from it, the total memory usage is lower than what has been malloc'ed.\n+        if (m_untouched_memory_iterator == m_untouched_memory_end) {\n+            // slow path, only happens when a new block needs to be allocated\n+            AllocateNewBlock();\n+        }\n+\n+        // peel off one chunk from the untouched memory. The next pointer of in-use elements doesn't matter until it is\n+        // deallocated, only then it is used to form the free list.\n+        const auto tmp = m_untouched_memory_iterator;\n+        m_untouched_memory_iterator = static_cast<char*>(tmp) + m_chunk_size_bytes;\n+        return static_cast<T*>(tmp);\n+    }\n+\n+    /**\n+     * Puts p back into the free list f it was actually allocated from the memory block.",
    "path": "src/support/allocators/node_allocator.h",
    "position": null,
    "original_position": 164,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "952c37a31c39b7acdb5ab2634a354a1c548708a2",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "typo: \"puts p back into the free list **if** it was...\"",
    "created_at": "2021-10-14T06:27:38Z",
    "updated_at": "2021-10-26T08:33:51Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r728671072",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/728671072"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r728671072"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/728671072/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 164,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734648036",
    "pull_request_review_id": 787000548,
    "id": 734648036,
    "node_id": "PRRC_kwDOABII584rydbk",
    "diff_hunk": "@@ -0,0 +1,425 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored in-place. This typically\n+ *   saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but there is no\n+ *   standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on proximity. So freeing\n+ *   and malloc'ing again can become a random access pattern which can lead to more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Currently it is only\n+ * able provide optimized alloc/free for a single fixed node size which is given in the constructor. Only allocations that match this\n+ * size will be provided from the preallocated blocks of memory; all other requests simply use ::operator new().\n+ * To get the correct node size in all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios in\n+ * `node_allocator_tests/test_chunks_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall \u201cHow to Write a Custom Allocator\u201d https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer \u201cAn Allocator is a Handle to a Heap\u201d https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *      https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block, or from a free list if it contains entries.\n+ *   Whenever a node is given back with Deallocate(), it is put into that free list.\n+ */\n+class MemoryResource\n+{\n+    //! Size in bytes to allocate per block, currently hardcoded to 256 KiB.\n+    static constexpr size_t BlockSizeBytes = 262144;\n+\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object that uses the specified chunk size to optimize for.\n+     */\n+    explicit MemoryResource(size_t chunk_size_bytes) : m_chunk_size_bytes(chunk_size_bytes) {}\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated blocks.\n+     *\n+     * There's no Clear() method on purpose, because it would be dangerous. E.g. when calling clear() on\n+     * an unordered_map, it is not certain that all allocated chunks are given back to the MemoryResource.\n+     * Microsoft's STL still uses a control structure that might have the same size as the nodes, and therefore\n+     * needs to be kept around until the map is actually destroyed.\n+     */\n+    ~MemoryResource() noexcept\n+    {\n+        for (auto* block : m_allocated_blocks) {\n+            ::operator delete(block);\n+        }\n+    }\n+\n+    /**\n+     * Allocates memory for n times T. Only when n==1 and T's size matches m_chunk_size_bytes\n+     * the chunking mechanism is used. Otherwise, the allocation is forwarded to ::operator new().\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes != required_chunk_size || n != 1) {\n+            // pool is not used so forward to operator new.\n+            return static_cast<T*>(::operator new(n * sizeof(T)));\n+        }\n+\n+        // chunk size is correct, so we can actually use the pool's block data\n+\n+        if (m_free_chunks) {\n+            // we've already got data in the free list, unlink one element\n+            auto old_head = m_free_chunks;\n+            m_free_chunks = static_cast<ChunkNode*>(m_free_chunks)->next;\n+            return static_cast<T*>(old_head);\n+        }\n+\n+        // free list is empty: get one chunk from allocated block memory.\n+        // It makes sense to not create the fully linked list of an allocated block up-front, for several reasons.\n+        // On the one hand, the latency is higher when we need to iterate and update pointers for the whole block at once.\n+        // More importantly, most systems lazily allocate data. So when we allocate a big block of memory the memory for a page\n+        // is only actually made available to the program when it is first touched. So when we allocate a big block and only use\n+        // very little memory from it, the total memory usage is lower than what has been malloc'ed.\n+        if (m_untouched_memory_iterator == m_untouched_memory_end) {\n+            // slow path, only happens when a new block needs to be allocated\n+            AllocateNewBlock();\n+        }\n+\n+        // peel off one chunk from the untouched memory. The next pointer of in-use elements doesn't matter until it is\n+        // deallocated, only then it is used to form the free list.\n+        const auto tmp = m_untouched_memory_iterator;\n+        m_untouched_memory_iterator = static_cast<char*>(tmp) + m_chunk_size_bytes;\n+        return static_cast<T*>(tmp);\n+    }\n+\n+    /**\n+     * Puts p back into the free list f it was actually allocated from the memory block.\n+     * Otherwise, simply call ::operator delete(p).\n+     */\n+    template <typename T>\n+    void Deallocate(void* p, size_t n) noexcept\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size_bytes = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes == required_chunk_size_bytes && n == 1) {\n+            // put it into the linked list\n+            const auto node = static_cast<ChunkNode*>(p);\n+            node->next = m_free_chunks;\n+            m_free_chunks = node;\n+        } else {\n+            // allocation didn't happen with the pool\n+            ::operator delete(p);\n+        }\n+    }\n+\n+    /**\n+     * Actual size in bytes that is used for one chunk (node allocation)\n+     */\n+    [[nodiscard]] size_t ChunkSizeBytes() const noexcept\n+    {\n+        return m_chunk_size_bytes;\n+    }\n+\n+    /**\n+     * Calculates bytes allocated by the memory resource.\n+     */\n+    [[nodiscard]] size_t DynamicMemoryUsage() const noexcept\n+    {\n+        const size_t alloc_size{(BlockSizeBytes / m_chunk_size_bytes) * m_chunk_size_bytes};\n+        return memusage::MallocUsage(alloc_size) * m_allocated_blocks.size() + memusage::DynamicUsage(m_allocated_blocks);\n+    }\n+\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation. Mostly for debugging / logging / testing.\n+     */\n+    [[nodiscard]] size_t NumFreeChunks() const noexcept\n+    {\n+        size_t length = 0;\n+        auto node = m_free_chunks;\n+        while (node) {\n+            node = static_cast<ChunkNode const*>(node)->next;\n+            ++length;\n+        }\n+        return length;\n+    }\n+\n+    /**\n+     * Number of memory blocks that have been allocated\n+     */\n+    [[nodiscard]] size_t NumBlocks() const noexcept\n+    {\n+        return m_allocated_blocks.size();\n+    }\n+\n+    /**\n+     * Calculates the required chunk size for the given type.\n+     * The memory block needs to be correctly aligned and large enough to hold both T and ChunkNode.\n+     */\n+    template <typename T>\n+    [[nodiscard]] static constexpr size_t CalcRequiredChunkSizeBytes() noexcept\n+    {\n+        const auto alignment_max = std::max(std::alignment_of_v<T>, std::alignment_of_v<ChunkNode>);\n+        const auto size_max = std::max(sizeof(T), sizeof(ChunkNode));\n+\n+        // find closest multiple of alignment_max that holds size_max\n+        return ((size_max + alignment_max - 1U) / alignment_max) * alignment_max;\n+    }\n+\n+private:\n+    /**\n+     * Allocate one full memory block which is used to carve out chunks.\n+     * The block size is the multiple of m_chunk_size_bytes that comes closest to BlockSizeBytes.\n+     */\n+    void AllocateNewBlock()\n+    {\n+        static_assert(sizeof(char) == 1U);\n+\n+        const auto num_chunks = BlockSizeBytes / m_chunk_size_bytes;\n+        m_untouched_memory_iterator = ::operator new(num_chunks* m_chunk_size_bytes);\n+        m_untouched_memory_end = static_cast<char*>(m_untouched_memory_iterator) + num_chunks * m_chunk_size_bytes;\n+        m_allocated_blocks.push_back(m_untouched_memory_iterator);\n+    }\n+\n+    /**\n+     * The MemoryResource's size for the memory chunks that it can give out.\n+     */\n+    size_t const m_chunk_size_bytes;\n+\n+    //! A contains all allocated blocks of memory, used to free the data in the destructor.\n+    std::vector<void*> m_allocated_blocks{};\n+\n+    //! A single linked list of all data available in the MemoryResource. This list is used for allocations of single elements.\n+    void* m_free_chunks = nullptr;\n+\n+    //! Points to the beginning of available memory for carving out chunks.\n+    void* m_untouched_memory_iterator = nullptr;\n+\n+    //! Points to the end of available memory for carving out chunks.\n+    void* m_untouched_memory_end = nullptr;",
    "path": "src/support/allocators/node_allocator.h",
    "position": null,
    "original_position": 267,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "952c37a31c39b7acdb5ab2634a354a1c548708a2",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "In commit \"Add allocator for node based containers\" (952c37a31c39b7acdb5ab2634a354a1c548708a2)\r\n\r\n`m_untouched_memory_end` is always `m_allocated_blocks.back() + alloc_size`. Seems like it would be safer and less confusing to drop this unnecessary variable. Safer to avoid possibility of bugs where object gets into an inconsistent state. Less confusing to need one less variable to understand this.",
    "created_at": "2021-10-22T15:34:03Z",
    "updated_at": "2021-10-22T22:02:11Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r734648036",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734648036"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r734648036"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734648036/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 267,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734663213",
    "pull_request_review_id": 787000548,
    "id": 734663213,
    "node_id": "PRRC_kwDOABII584ryhIt",
    "diff_hunk": "@@ -0,0 +1,425 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored in-place. This typically\n+ *   saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but there is no\n+ *   standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on proximity. So freeing\n+ *   and malloc'ing again can become a random access pattern which can lead to more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Currently it is only\n+ * able provide optimized alloc/free for a single fixed node size which is given in the constructor. Only allocations that match this\n+ * size will be provided from the preallocated blocks of memory; all other requests simply use ::operator new().\n+ * To get the correct node size in all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios in\n+ * `node_allocator_tests/test_chunks_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall \u201cHow to Write a Custom Allocator\u201d https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer \u201cAn Allocator is a Handle to a Heap\u201d https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *      https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block, or from a free list if it contains entries.\n+ *   Whenever a node is given back with Deallocate(), it is put into that free list.\n+ */\n+class MemoryResource\n+{\n+    //! Size in bytes to allocate per block, currently hardcoded to 256 KiB.\n+    static constexpr size_t BlockSizeBytes = 262144;\n+\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {",
    "path": "src/support/allocators/node_allocator.h",
    "position": null,
    "original_position": 86,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "952c37a31c39b7acdb5ab2634a354a1c548708a2",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "In commit \"Add allocator for node based containers\" (952c37a31c39b7acdb5ab2634a354a1c548708a2)\r\n\r\nWhy are individual allocations sometimes called \"chunks\" and sometimes called \"nodes\"? Can we drop \"chunk\" terminology and just refer to individual allocations consistently as nodes? \r\n\r\nPersonally I would love to drop the custom chunk/node/block terms entirely, just call the allocator a fixed size allocator,  call the allocations allocations, and call the blocks pools. Just IMO, though.",
    "created_at": "2021-10-22T15:54:37Z",
    "updated_at": "2021-10-22T22:02:11Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r734663213",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734663213"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r734663213"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734663213/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 86,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734678036",
    "pull_request_review_id": 787000548,
    "id": 734678036,
    "node_id": "PRRC_kwDOABII584rykwU",
    "diff_hunk": "@@ -0,0 +1,425 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored in-place. This typically\n+ *   saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but there is no\n+ *   standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on proximity. So freeing\n+ *   and malloc'ing again can become a random access pattern which can lead to more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Currently it is only\n+ * able provide optimized alloc/free for a single fixed node size which is given in the constructor. Only allocations that match this\n+ * size will be provided from the preallocated blocks of memory; all other requests simply use ::operator new().\n+ * To get the correct node size in all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios in\n+ * `node_allocator_tests/test_chunks_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall \u201cHow to Write a Custom Allocator\u201d https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer \u201cAn Allocator is a Handle to a Heap\u201d https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *      https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block, or from a free list if it contains entries.\n+ *   Whenever a node is given back with Deallocate(), it is put into that free list.\n+ */\n+class MemoryResource\n+{\n+    //! Size in bytes to allocate per block, currently hardcoded to 256 KiB.\n+    static constexpr size_t BlockSizeBytes = 262144;\n+\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object that uses the specified chunk size to optimize for.\n+     */\n+    explicit MemoryResource(size_t chunk_size_bytes) : m_chunk_size_bytes(chunk_size_bytes) {}\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated blocks.\n+     *\n+     * There's no Clear() method on purpose, because it would be dangerous. E.g. when calling clear() on\n+     * an unordered_map, it is not certain that all allocated chunks are given back to the MemoryResource.\n+     * Microsoft's STL still uses a control structure that might have the same size as the nodes, and therefore\n+     * needs to be kept around until the map is actually destroyed.\n+     */\n+    ~MemoryResource() noexcept\n+    {\n+        for (auto* block : m_allocated_blocks) {\n+            ::operator delete(block);\n+        }\n+    }\n+\n+    /**\n+     * Allocates memory for n times T. Only when n==1 and T's size matches m_chunk_size_bytes\n+     * the chunking mechanism is used. Otherwise, the allocation is forwarded to ::operator new().\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes != required_chunk_size || n != 1) {\n+            // pool is not used so forward to operator new.\n+            return static_cast<T*>(::operator new(n * sizeof(T)));\n+        }\n+\n+        // chunk size is correct, so we can actually use the pool's block data\n+\n+        if (m_free_chunks) {\n+            // we've already got data in the free list, unlink one element\n+            auto old_head = m_free_chunks;\n+            m_free_chunks = static_cast<ChunkNode*>(m_free_chunks)->next;\n+            return static_cast<T*>(old_head);\n+        }\n+\n+        // free list is empty: get one chunk from allocated block memory.\n+        // It makes sense to not create the fully linked list of an allocated block up-front, for several reasons.\n+        // On the one hand, the latency is higher when we need to iterate and update pointers for the whole block at once.\n+        // More importantly, most systems lazily allocate data. So when we allocate a big block of memory the memory for a page\n+        // is only actually made available to the program when it is first touched. So when we allocate a big block and only use\n+        // very little memory from it, the total memory usage is lower than what has been malloc'ed.\n+        if (m_untouched_memory_iterator == m_untouched_memory_end) {\n+            // slow path, only happens when a new block needs to be allocated\n+            AllocateNewBlock();\n+        }\n+\n+        // peel off one chunk from the untouched memory. The next pointer of in-use elements doesn't matter until it is\n+        // deallocated, only then it is used to form the free list.\n+        const auto tmp = m_untouched_memory_iterator;\n+        m_untouched_memory_iterator = static_cast<char*>(tmp) + m_chunk_size_bytes;\n+        return static_cast<T*>(tmp);\n+    }\n+\n+    /**\n+     * Puts p back into the free list f it was actually allocated from the memory block.\n+     * Otherwise, simply call ::operator delete(p).\n+     */\n+    template <typename T>\n+    void Deallocate(void* p, size_t n) noexcept\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size_bytes = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes == required_chunk_size_bytes && n == 1) {\n+            // put it into the linked list\n+            const auto node = static_cast<ChunkNode*>(p);\n+            node->next = m_free_chunks;\n+            m_free_chunks = node;\n+        } else {\n+            // allocation didn't happen with the pool\n+            ::operator delete(p);\n+        }\n+    }\n+\n+    /**\n+     * Actual size in bytes that is used for one chunk (node allocation)\n+     */\n+    [[nodiscard]] size_t ChunkSizeBytes() const noexcept\n+    {\n+        return m_chunk_size_bytes;\n+    }\n+\n+    /**\n+     * Calculates bytes allocated by the memory resource.\n+     */\n+    [[nodiscard]] size_t DynamicMemoryUsage() const noexcept\n+    {\n+        const size_t alloc_size{(BlockSizeBytes / m_chunk_size_bytes) * m_chunk_size_bytes};\n+        return memusage::MallocUsage(alloc_size) * m_allocated_blocks.size() + memusage::DynamicUsage(m_allocated_blocks);\n+    }\n+\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation. Mostly for debugging / logging / testing.\n+     */\n+    [[nodiscard]] size_t NumFreeChunks() const noexcept\n+    {\n+        size_t length = 0;\n+        auto node = m_free_chunks;\n+        while (node) {\n+            node = static_cast<ChunkNode const*>(node)->next;\n+            ++length;\n+        }\n+        return length;\n+    }\n+\n+    /**\n+     * Number of memory blocks that have been allocated\n+     */\n+    [[nodiscard]] size_t NumBlocks() const noexcept\n+    {\n+        return m_allocated_blocks.size();\n+    }\n+\n+    /**\n+     * Calculates the required chunk size for the given type.\n+     * The memory block needs to be correctly aligned and large enough to hold both T and ChunkNode.\n+     */\n+    template <typename T>\n+    [[nodiscard]] static constexpr size_t CalcRequiredChunkSizeBytes() noexcept\n+    {\n+        const auto alignment_max = std::max(std::alignment_of_v<T>, std::alignment_of_v<ChunkNode>);",
    "path": "src/support/allocators/node_allocator.h",
    "position": null,
    "original_position": 230,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "952c37a31c39b7acdb5ab2634a354a1c548708a2",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "In commit \"Add allocator for node based containers\" (952c37a31c39b7acdb5ab2634a354a1c548708a2)\r\n\r\nStrictly speaking, keeping ChunkNode structs aligned shouldn't be required, because we could `memcpy` them to and from the empty spaces instead of `static_cast`ing them. But I guess not taking the max alignment is unlikely to save any space, if we already need to use the max size anyway? \r\n\r\nIn any case, it would be good to have sentence here to say why this is using ChunkNode alignment, since it seems like ChunkNode alignment shouldn't need to matter in principle.",
    "created_at": "2021-10-22T16:15:44Z",
    "updated_at": "2021-10-22T22:02:11Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r734678036",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734678036"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r734678036"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734678036/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 230,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734785167",
    "pull_request_review_id": 787000548,
    "id": 734785167,
    "node_id": "PRRC_kwDOABII584ry-6P",
    "diff_hunk": "@@ -0,0 +1,425 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored in-place. This typically\n+ *   saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but there is no\n+ *   standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on proximity. So freeing\n+ *   and malloc'ing again can become a random access pattern which can lead to more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Currently it is only\n+ * able provide optimized alloc/free for a single fixed node size which is given in the constructor. Only allocations that match this\n+ * size will be provided from the preallocated blocks of memory; all other requests simply use ::operator new().\n+ * To get the correct node size in all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios in\n+ * `node_allocator_tests/test_chunks_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall \u201cHow to Write a Custom Allocator\u201d https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer \u201cAn Allocator is a Handle to a Heap\u201d https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *      https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block, or from a free list if it contains entries.\n+ *   Whenever a node is given back with Deallocate(), it is put into that free list.\n+ */\n+class MemoryResource\n+{\n+    //! Size in bytes to allocate per block, currently hardcoded to 256 KiB.\n+    static constexpr size_t BlockSizeBytes = 262144;\n+\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object that uses the specified chunk size to optimize for.\n+     */\n+    explicit MemoryResource(size_t chunk_size_bytes) : m_chunk_size_bytes(chunk_size_bytes) {}",
    "path": "src/support/allocators/node_allocator.h",
    "position": null,
    "original_position": 93,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "952c37a31c39b7acdb5ab2634a354a1c548708a2",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "In commit \"Add allocator for node based containers\" (952c37a31c39b7acdb5ab2634a354a1c548708a2)\r\n\r\nIt seems like it would be more ideal for chunk_size_bytes to be a compile time constant (template parameter) instead of a runtime constant (class member), since in all cases can be known at compile time, and the fact that it isn't mean that other things like size of a block can't be constant either. Not being able to easily compute size of the block (it requires runtime multiplication and division) I think indirectly led to `m_untouched_memory_end` being added unnecessarily. Not having a compile-time block size also appears to be a reason `m_allocated_blocks` is using `void*` and raw new/deletes instead of safer types like `std::unique_ptr` and `std::array`\r\n\r\nMaking this const would also have more minor benefit of improving clarity by being able to declare useful constants up front and not have things like  `/ m_chunk_size_bytes * m_chunk_size_bytes` various places in the code.",
    "created_at": "2021-10-22T19:11:34Z",
    "updated_at": "2021-10-22T22:02:11Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r734785167",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734785167"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r734785167"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734785167/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 93,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734826521",
    "pull_request_review_id": 787000548,
    "id": 734826521,
    "node_id": "PRRC_kwDOABII584rzJAZ",
    "diff_hunk": "@@ -0,0 +1,425 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored in-place. This typically\n+ *   saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but there is no\n+ *   standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on proximity. So freeing\n+ *   and malloc'ing again can become a random access pattern which can lead to more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Currently it is only\n+ * able provide optimized alloc/free for a single fixed node size which is given in the constructor. Only allocations that match this\n+ * size will be provided from the preallocated blocks of memory; all other requests simply use ::operator new().\n+ * To get the correct node size in all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios in\n+ * `node_allocator_tests/test_chunks_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall \u201cHow to Write a Custom Allocator\u201d https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer \u201cAn Allocator is a Handle to a Heap\u201d https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *      https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block, or from a free list if it contains entries.\n+ *   Whenever a node is given back with Deallocate(), it is put into that free list.\n+ */\n+class MemoryResource\n+{\n+    //! Size in bytes to allocate per block, currently hardcoded to 256 KiB.\n+    static constexpr size_t BlockSizeBytes = 262144;\n+\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object that uses the specified chunk size to optimize for.\n+     */\n+    explicit MemoryResource(size_t chunk_size_bytes) : m_chunk_size_bytes(chunk_size_bytes) {}\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated blocks.\n+     *\n+     * There's no Clear() method on purpose, because it would be dangerous. E.g. when calling clear() on\n+     * an unordered_map, it is not certain that all allocated chunks are given back to the MemoryResource.\n+     * Microsoft's STL still uses a control structure that might have the same size as the nodes, and therefore\n+     * needs to be kept around until the map is actually destroyed.\n+     */\n+    ~MemoryResource() noexcept\n+    {\n+        for (auto* block : m_allocated_blocks) {\n+            ::operator delete(block);\n+        }\n+    }",
    "path": "src/support/allocators/node_allocator.h",
    "position": null,
    "original_position": 116,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "952c37a31c39b7acdb5ab2634a354a1c548708a2",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "In commit \"Add allocator for node based containers\" (952c37a31c39b7acdb5ab2634a354a1c548708a2)\r\n\r\nThis could go away using std::unique_ptr",
    "created_at": "2021-10-22T20:30:21Z",
    "updated_at": "2021-10-22T22:02:11Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r734826521",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734826521"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r734826521"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734826521/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": 103,
    "start_side": "RIGHT",
    "line": null,
    "original_line": 116,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734831606",
    "pull_request_review_id": 787000548,
    "id": 734831606,
    "node_id": "PRRC_kwDOABII584rzKP2",
    "diff_hunk": "@@ -0,0 +1,425 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored in-place. This typically\n+ *   saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but there is no\n+ *   standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on proximity. So freeing\n+ *   and malloc'ing again can become a random access pattern which can lead to more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Currently it is only\n+ * able provide optimized alloc/free for a single fixed node size which is given in the constructor. Only allocations that match this\n+ * size will be provided from the preallocated blocks of memory; all other requests simply use ::operator new().\n+ * To get the correct node size in all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios in\n+ * `node_allocator_tests/test_chunks_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall \u201cHow to Write a Custom Allocator\u201d https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer \u201cAn Allocator is a Handle to a Heap\u201d https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *      https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block, or from a free list if it contains entries.\n+ *   Whenever a node is given back with Deallocate(), it is put into that free list.\n+ */\n+class MemoryResource\n+{\n+    //! Size in bytes to allocate per block, currently hardcoded to 256 KiB.\n+    static constexpr size_t BlockSizeBytes = 262144;\n+\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object that uses the specified chunk size to optimize for.\n+     */\n+    explicit MemoryResource(size_t chunk_size_bytes) : m_chunk_size_bytes(chunk_size_bytes) {}\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated blocks.\n+     *\n+     * There's no Clear() method on purpose, because it would be dangerous. E.g. when calling clear() on\n+     * an unordered_map, it is not certain that all allocated chunks are given back to the MemoryResource.\n+     * Microsoft's STL still uses a control structure that might have the same size as the nodes, and therefore\n+     * needs to be kept around until the map is actually destroyed.\n+     */\n+    ~MemoryResource() noexcept\n+    {\n+        for (auto* block : m_allocated_blocks) {\n+            ::operator delete(block);\n+        }\n+    }\n+\n+    /**\n+     * Allocates memory for n times T. Only when n==1 and T's size matches m_chunk_size_bytes\n+     * the chunking mechanism is used. Otherwise, the allocation is forwarded to ::operator new().\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes != required_chunk_size || n != 1) {\n+            // pool is not used so forward to operator new.\n+            return static_cast<T*>(::operator new(n * sizeof(T)));\n+        }\n+\n+        // chunk size is correct, so we can actually use the pool's block data\n+\n+        if (m_free_chunks) {\n+            // we've already got data in the free list, unlink one element\n+            auto old_head = m_free_chunks;\n+            m_free_chunks = static_cast<ChunkNode*>(m_free_chunks)->next;\n+            return static_cast<T*>(old_head);\n+        }\n+\n+        // free list is empty: get one chunk from allocated block memory.\n+        // It makes sense to not create the fully linked list of an allocated block up-front, for several reasons.\n+        // On the one hand, the latency is higher when we need to iterate and update pointers for the whole block at once.\n+        // More importantly, most systems lazily allocate data. So when we allocate a big block of memory the memory for a page\n+        // is only actually made available to the program when it is first touched. So when we allocate a big block and only use\n+        // very little memory from it, the total memory usage is lower than what has been malloc'ed.\n+        if (m_untouched_memory_iterator == m_untouched_memory_end) {\n+            // slow path, only happens when a new block needs to be allocated\n+            AllocateNewBlock();\n+        }\n+\n+        // peel off one chunk from the untouched memory. The next pointer of in-use elements doesn't matter until it is\n+        // deallocated, only then it is used to form the free list.\n+        const auto tmp = m_untouched_memory_iterator;\n+        m_untouched_memory_iterator = static_cast<char*>(tmp) + m_chunk_size_bytes;\n+        return static_cast<T*>(tmp);\n+    }\n+\n+    /**\n+     * Puts p back into the free list f it was actually allocated from the memory block.\n+     * Otherwise, simply call ::operator delete(p).\n+     */\n+    template <typename T>\n+    void Deallocate(void* p, size_t n) noexcept\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size_bytes = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes == required_chunk_size_bytes && n == 1) {\n+            // put it into the linked list\n+            const auto node = static_cast<ChunkNode*>(p);\n+            node->next = m_free_chunks;\n+            m_free_chunks = node;\n+        } else {\n+            // allocation didn't happen with the pool\n+            ::operator delete(p);\n+        }\n+    }\n+\n+    /**\n+     * Actual size in bytes that is used for one chunk (node allocation)\n+     */\n+    [[nodiscard]] size_t ChunkSizeBytes() const noexcept\n+    {\n+        return m_chunk_size_bytes;\n+    }\n+\n+    /**\n+     * Calculates bytes allocated by the memory resource.\n+     */\n+    [[nodiscard]] size_t DynamicMemoryUsage() const noexcept\n+    {\n+        const size_t alloc_size{(BlockSizeBytes / m_chunk_size_bytes) * m_chunk_size_bytes};\n+        return memusage::MallocUsage(alloc_size) * m_allocated_blocks.size() + memusage::DynamicUsage(m_allocated_blocks);\n+    }\n+\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation. Mostly for debugging / logging / testing.\n+     */\n+    [[nodiscard]] size_t NumFreeChunks() const noexcept",
    "path": "src/support/allocators/node_allocator.h",
    "position": null,
    "original_position": 204,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "952c37a31c39b7acdb5ab2634a354a1c548708a2",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "In commit \"Add allocator for node based containers\" (952c37a31c39b7acdb5ab2634a354a1c548708a2)\r\n\r\nExposing this method seems pretty dubious. Maybe do `friend class MemoryResourceTester;` instead and move it to test code. My concerns here are verbosity of this header, and temptation for someone to call this inappropriately in some performance counter or log statement. If this should be exposed publicly, maybe it should have a name like `CountFreeChunks` so it doesn't look like an innocuous accessor method.",
    "created_at": "2021-10-22T20:41:04Z",
    "updated_at": "2021-10-22T22:02:11Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r734831606",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734831606"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r734831606"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734831606/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 204,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734835564",
    "pull_request_review_id": 787000548,
    "id": 734835564,
    "node_id": "PRRC_kwDOABII584rzLNs",
    "diff_hunk": "@@ -0,0 +1,425 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored in-place. This typically\n+ *   saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but there is no\n+ *   standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on proximity. So freeing\n+ *   and malloc'ing again can become a random access pattern which can lead to more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Currently it is only\n+ * able provide optimized alloc/free for a single fixed node size which is given in the constructor. Only allocations that match this\n+ * size will be provided from the preallocated blocks of memory; all other requests simply use ::operator new().\n+ * To get the correct node size in all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios in\n+ * `node_allocator_tests/test_chunks_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall \u201cHow to Write a Custom Allocator\u201d https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer \u201cAn Allocator is a Handle to a Heap\u201d https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *      https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block, or from a free list if it contains entries.\n+ *   Whenever a node is given back with Deallocate(), it is put into that free list.\n+ */\n+class MemoryResource\n+{\n+    //! Size in bytes to allocate per block, currently hardcoded to 256 KiB.\n+    static constexpr size_t BlockSizeBytes = 262144;\n+\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object that uses the specified chunk size to optimize for.\n+     */\n+    explicit MemoryResource(size_t chunk_size_bytes) : m_chunk_size_bytes(chunk_size_bytes) {}\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated blocks.\n+     *\n+     * There's no Clear() method on purpose, because it would be dangerous. E.g. when calling clear() on\n+     * an unordered_map, it is not certain that all allocated chunks are given back to the MemoryResource.\n+     * Microsoft's STL still uses a control structure that might have the same size as the nodes, and therefore\n+     * needs to be kept around until the map is actually destroyed.\n+     */\n+    ~MemoryResource() noexcept\n+    {\n+        for (auto* block : m_allocated_blocks) {\n+            ::operator delete(block);\n+        }\n+    }\n+\n+    /**\n+     * Allocates memory for n times T. Only when n==1 and T's size matches m_chunk_size_bytes\n+     * the chunking mechanism is used. Otherwise, the allocation is forwarded to ::operator new().\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes != required_chunk_size || n != 1) {\n+            // pool is not used so forward to operator new.\n+            return static_cast<T*>(::operator new(n * sizeof(T)));\n+        }\n+\n+        // chunk size is correct, so we can actually use the pool's block data\n+\n+        if (m_free_chunks) {\n+            // we've already got data in the free list, unlink one element\n+            auto old_head = m_free_chunks;\n+            m_free_chunks = static_cast<ChunkNode*>(m_free_chunks)->next;\n+            return static_cast<T*>(old_head);\n+        }\n+\n+        // free list is empty: get one chunk from allocated block memory.\n+        // It makes sense to not create the fully linked list of an allocated block up-front, for several reasons.\n+        // On the one hand, the latency is higher when we need to iterate and update pointers for the whole block at once.\n+        // More importantly, most systems lazily allocate data. So when we allocate a big block of memory the memory for a page\n+        // is only actually made available to the program when it is first touched. So when we allocate a big block and only use\n+        // very little memory from it, the total memory usage is lower than what has been malloc'ed.\n+        if (m_untouched_memory_iterator == m_untouched_memory_end) {\n+            // slow path, only happens when a new block needs to be allocated\n+            AllocateNewBlock();\n+        }\n+\n+        // peel off one chunk from the untouched memory. The next pointer of in-use elements doesn't matter until it is\n+        // deallocated, only then it is used to form the free list.\n+        const auto tmp = m_untouched_memory_iterator;\n+        m_untouched_memory_iterator = static_cast<char*>(tmp) + m_chunk_size_bytes;\n+        return static_cast<T*>(tmp);\n+    }\n+\n+    /**\n+     * Puts p back into the free list f it was actually allocated from the memory block.\n+     * Otherwise, simply call ::operator delete(p).\n+     */\n+    template <typename T>\n+    void Deallocate(void* p, size_t n) noexcept\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size_bytes = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes == required_chunk_size_bytes && n == 1) {\n+            // put it into the linked list\n+            const auto node = static_cast<ChunkNode*>(p);\n+            node->next = m_free_chunks;\n+            m_free_chunks = node;\n+        } else {\n+            // allocation didn't happen with the pool\n+            ::operator delete(p);\n+        }\n+    }\n+\n+    /**\n+     * Actual size in bytes that is used for one chunk (node allocation)\n+     */\n+    [[nodiscard]] size_t ChunkSizeBytes() const noexcept\n+    {\n+        return m_chunk_size_bytes;\n+    }\n+\n+    /**\n+     * Calculates bytes allocated by the memory resource.\n+     */\n+    [[nodiscard]] size_t DynamicMemoryUsage() const noexcept\n+    {\n+        const size_t alloc_size{(BlockSizeBytes / m_chunk_size_bytes) * m_chunk_size_bytes};\n+        return memusage::MallocUsage(alloc_size) * m_allocated_blocks.size() + memusage::DynamicUsage(m_allocated_blocks);\n+    }\n+\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation. Mostly for debugging / logging / testing.\n+     */\n+    [[nodiscard]] size_t NumFreeChunks() const noexcept\n+    {\n+        size_t length = 0;\n+        auto node = m_free_chunks;\n+        while (node) {\n+            node = static_cast<ChunkNode const*>(node)->next;\n+            ++length;\n+        }\n+        return length;\n+    }\n+\n+    /**\n+     * Number of memory blocks that have been allocated\n+     */\n+    [[nodiscard]] size_t NumBlocks() const noexcept\n+    {\n+        return m_allocated_blocks.size();\n+    }\n+\n+    /**\n+     * Calculates the required chunk size for the given type.\n+     * The memory block needs to be correctly aligned and large enough to hold both T and ChunkNode.\n+     */\n+    template <typename T>\n+    [[nodiscard]] static constexpr size_t CalcRequiredChunkSizeBytes() noexcept\n+    {\n+        const auto alignment_max = std::max(std::alignment_of_v<T>, std::alignment_of_v<ChunkNode>);\n+        const auto size_max = std::max(sizeof(T), sizeof(ChunkNode));\n+\n+        // find closest multiple of alignment_max that holds size_max\n+        return ((size_max + alignment_max - 1U) / alignment_max) * alignment_max;",
    "path": "src/support/allocators/node_allocator.h",
    "position": null,
    "original_position": 234,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "952c37a31c39b7acdb5ab2634a354a1c548708a2",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "In commit \"Add allocator for node based containers\" (952c37a31c39b7acdb5ab2634a354a1c548708a2)\r\n\r\nSuggestion not for here, but I wouldn't mind some other PR adding simple `CEIL_DIV`, `ROUND_UP` util macros and using them places like this.",
    "created_at": "2021-10-22T20:49:24Z",
    "updated_at": "2021-10-22T22:02:11Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r734835564",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734835564"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r734835564"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734835564/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 234,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734838852",
    "pull_request_review_id": 787000548,
    "id": 734838852,
    "node_id": "PRRC_kwDOABII584rzMBE",
    "diff_hunk": "@@ -0,0 +1,425 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored in-place. This typically\n+ *   saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but there is no\n+ *   standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on proximity. So freeing\n+ *   and malloc'ing again can become a random access pattern which can lead to more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Currently it is only\n+ * able provide optimized alloc/free for a single fixed node size which is given in the constructor. Only allocations that match this\n+ * size will be provided from the preallocated blocks of memory; all other requests simply use ::operator new().\n+ * To get the correct node size in all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios in\n+ * `node_allocator_tests/test_chunks_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall \u201cHow to Write a Custom Allocator\u201d https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer \u201cAn Allocator is a Handle to a Heap\u201d https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *      https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block, or from a free list if it contains entries.\n+ *   Whenever a node is given back with Deallocate(), it is put into that free list.\n+ */\n+class MemoryResource\n+{\n+    //! Size in bytes to allocate per block, currently hardcoded to 256 KiB.\n+    static constexpr size_t BlockSizeBytes = 262144;\n+\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object that uses the specified chunk size to optimize for.\n+     */\n+    explicit MemoryResource(size_t chunk_size_bytes) : m_chunk_size_bytes(chunk_size_bytes) {}\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated blocks.\n+     *\n+     * There's no Clear() method on purpose, because it would be dangerous. E.g. when calling clear() on\n+     * an unordered_map, it is not certain that all allocated chunks are given back to the MemoryResource.\n+     * Microsoft's STL still uses a control structure that might have the same size as the nodes, and therefore\n+     * needs to be kept around until the map is actually destroyed.\n+     */\n+    ~MemoryResource() noexcept\n+    {\n+        for (auto* block : m_allocated_blocks) {\n+            ::operator delete(block);\n+        }\n+    }\n+\n+    /**\n+     * Allocates memory for n times T. Only when n==1 and T's size matches m_chunk_size_bytes\n+     * the chunking mechanism is used. Otherwise, the allocation is forwarded to ::operator new().\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes != required_chunk_size || n != 1) {\n+            // pool is not used so forward to operator new.\n+            return static_cast<T*>(::operator new(n * sizeof(T)));\n+        }\n+\n+        // chunk size is correct, so we can actually use the pool's block data\n+\n+        if (m_free_chunks) {\n+            // we've already got data in the free list, unlink one element\n+            auto old_head = m_free_chunks;\n+            m_free_chunks = static_cast<ChunkNode*>(m_free_chunks)->next;\n+            return static_cast<T*>(old_head);\n+        }\n+\n+        // free list is empty: get one chunk from allocated block memory.\n+        // It makes sense to not create the fully linked list of an allocated block up-front, for several reasons.\n+        // On the one hand, the latency is higher when we need to iterate and update pointers for the whole block at once.\n+        // More importantly, most systems lazily allocate data. So when we allocate a big block of memory the memory for a page\n+        // is only actually made available to the program when it is first touched. So when we allocate a big block and only use\n+        // very little memory from it, the total memory usage is lower than what has been malloc'ed.\n+        if (m_untouched_memory_iterator == m_untouched_memory_end) {\n+            // slow path, only happens when a new block needs to be allocated\n+            AllocateNewBlock();\n+        }\n+\n+        // peel off one chunk from the untouched memory. The next pointer of in-use elements doesn't matter until it is\n+        // deallocated, only then it is used to form the free list.\n+        const auto tmp = m_untouched_memory_iterator;\n+        m_untouched_memory_iterator = static_cast<char*>(tmp) + m_chunk_size_bytes;\n+        return static_cast<T*>(tmp);\n+    }\n+\n+    /**\n+     * Puts p back into the free list f it was actually allocated from the memory block.\n+     * Otherwise, simply call ::operator delete(p).\n+     */\n+    template <typename T>\n+    void Deallocate(void* p, size_t n) noexcept\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size_bytes = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes == required_chunk_size_bytes && n == 1) {\n+            // put it into the linked list\n+            const auto node = static_cast<ChunkNode*>(p);\n+            node->next = m_free_chunks;\n+            m_free_chunks = node;\n+        } else {\n+            // allocation didn't happen with the pool\n+            ::operator delete(p);\n+        }\n+    }\n+\n+    /**\n+     * Actual size in bytes that is used for one chunk (node allocation)\n+     */\n+    [[nodiscard]] size_t ChunkSizeBytes() const noexcept\n+    {\n+        return m_chunk_size_bytes;\n+    }\n+\n+    /**\n+     * Calculates bytes allocated by the memory resource.\n+     */\n+    [[nodiscard]] size_t DynamicMemoryUsage() const noexcept\n+    {\n+        const size_t alloc_size{(BlockSizeBytes / m_chunk_size_bytes) * m_chunk_size_bytes};\n+        return memusage::MallocUsage(alloc_size) * m_allocated_blocks.size() + memusage::DynamicUsage(m_allocated_blocks);\n+    }\n+\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation. Mostly for debugging / logging / testing.\n+     */\n+    [[nodiscard]] size_t NumFreeChunks() const noexcept\n+    {\n+        size_t length = 0;\n+        auto node = m_free_chunks;\n+        while (node) {\n+            node = static_cast<ChunkNode const*>(node)->next;\n+            ++length;\n+        }\n+        return length;\n+    }\n+\n+    /**\n+     * Number of memory blocks that have been allocated\n+     */\n+    [[nodiscard]] size_t NumBlocks() const noexcept\n+    {\n+        return m_allocated_blocks.size();\n+    }\n+\n+    /**\n+     * Calculates the required chunk size for the given type.\n+     * The memory block needs to be correctly aligned and large enough to hold both T and ChunkNode.\n+     */\n+    template <typename T>\n+    [[nodiscard]] static constexpr size_t CalcRequiredChunkSizeBytes() noexcept\n+    {\n+        const auto alignment_max = std::max(std::alignment_of_v<T>, std::alignment_of_v<ChunkNode>);\n+        const auto size_max = std::max(sizeof(T), sizeof(ChunkNode));\n+\n+        // find closest multiple of alignment_max that holds size_max\n+        return ((size_max + alignment_max - 1U) / alignment_max) * alignment_max;\n+    }\n+\n+private:\n+    /**\n+     * Allocate one full memory block which is used to carve out chunks.\n+     * The block size is the multiple of m_chunk_size_bytes that comes closest to BlockSizeBytes.\n+     */\n+    void AllocateNewBlock()\n+    {\n+        static_assert(sizeof(char) == 1U);",
    "path": "src/support/allocators/node_allocator.h",
    "position": null,
    "original_position": 244,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "952c37a31c39b7acdb5ab2634a354a1c548708a2",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "In commit \"Add allocator for node based containers\" (952c37a31c39b7acdb5ab2634a354a1c548708a2)\r\n\r\nThis should be removed since it's true by definition that `sizeof` returns `char` sized units and `sizeof(char)` is `1`. Size of a char can vary (it is `CHAR_BIT` bits which is usually `8`), but I don't think any code here depends on a particular char size. ",
    "created_at": "2021-10-22T20:56:20Z",
    "updated_at": "2021-10-22T22:02:11Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r734838852",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734838852"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r734838852"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734838852/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 244,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734842535",
    "pull_request_review_id": 787000548,
    "id": 734842535,
    "node_id": "PRRC_kwDOABII584rzM6n",
    "diff_hunk": "@@ -0,0 +1,425 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored in-place. This typically\n+ *   saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but there is no\n+ *   standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on proximity. So freeing\n+ *   and malloc'ing again can become a random access pattern which can lead to more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Currently it is only\n+ * able provide optimized alloc/free for a single fixed node size which is given in the constructor. Only allocations that match this\n+ * size will be provided from the preallocated blocks of memory; all other requests simply use ::operator new().\n+ * To get the correct node size in all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios in\n+ * `node_allocator_tests/test_chunks_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall \u201cHow to Write a Custom Allocator\u201d https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer \u201cAn Allocator is a Handle to a Heap\u201d https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *      https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block, or from a free list if it contains entries.\n+ *   Whenever a node is given back with Deallocate(), it is put into that free list.\n+ */\n+class MemoryResource\n+{\n+    //! Size in bytes to allocate per block, currently hardcoded to 256 KiB.\n+    static constexpr size_t BlockSizeBytes = 262144;",
    "path": "src/support/allocators/node_allocator.h",
    "position": null,
    "original_position": 80,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "952c37a31c39b7acdb5ab2634a354a1c548708a2",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "In commit \"Add allocator for node based containers\" (952c37a31c39b7acdb5ab2634a354a1c548708a2)\r\n\r\nI think this should be named `MaxBlockSizeBytes` instead of `BlockSizeBytes` since actual block size may be slightly less depending on alignment. Also convention is to use snake case for variable/constant names and camel case for type/function names, so maybe would be good `MAX_BLOCK_SIZE_BYTES` to also make it more obvious this is a compile-time constant.",
    "created_at": "2021-10-22T21:04:23Z",
    "updated_at": "2021-10-22T22:02:11Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r734842535",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734842535"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r734842535"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734842535/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 80,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734846594",
    "pull_request_review_id": 787000548,
    "id": 734846594,
    "node_id": "PRRC_kwDOABII584rzN6C",
    "diff_hunk": "@@ -0,0 +1,425 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored in-place. This typically\n+ *   saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but there is no\n+ *   standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on proximity. So freeing\n+ *   and malloc'ing again can become a random access pattern which can lead to more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Currently it is only\n+ * able provide optimized alloc/free for a single fixed node size which is given in the constructor. Only allocations that match this\n+ * size will be provided from the preallocated blocks of memory; all other requests simply use ::operator new().\n+ * To get the correct node size in all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.",
    "path": "src/support/allocators/node_allocator.h",
    "position": null,
    "original_position": 52,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "952c37a31c39b7acdb5ab2634a354a1c548708a2",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "In commit \"Add allocator for node based containers\" (952c37a31c39b7acdb5ab2634a354a1c548708a2)\r\n\r\nThis doesn't doesn't really have anything to do with `MemoryResource`, and I'd think it should be part of the `Allocator` paragraph not the `MemoryResource` one. I'd reshuffle this design section a little bit and put `MemoryResource` paragraph first, `Allocator` paragraph second, and information about determining the node sizes third.",
    "created_at": "2021-10-22T21:13:50Z",
    "updated_at": "2021-10-22T22:02:11Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r734846594",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734846594"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r734846594"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734846594/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": 51,
    "start_side": "RIGHT",
    "line": null,
    "original_line": 52,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734849669",
    "pull_request_review_id": 787000548,
    "id": 734849669,
    "node_id": "PRRC_kwDOABII584rzOqF",
    "diff_hunk": "@@ -0,0 +1,425 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored in-place. This typically\n+ *   saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but there is no\n+ *   standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on proximity. So freeing\n+ *   and malloc'ing again can become a random access pattern which can lead to more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Currently it is only\n+ * able provide optimized alloc/free for a single fixed node size which is given in the constructor. Only allocations that match this\n+ * size will be provided from the preallocated blocks of memory; all other requests simply use ::operator new().\n+ * To get the correct node size in all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios in\n+ * `node_allocator_tests/test_chunks_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall \u201cHow to Write a Custom Allocator\u201d https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer \u201cAn Allocator is a Handle to a Heap\u201d https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *      https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block, or from a free list if it contains entries.\n+ *   Whenever a node is given back with Deallocate(), it is put into that free list.\n+ */\n+class MemoryResource\n+{\n+    //! Size in bytes to allocate per block, currently hardcoded to 256 KiB.\n+    static constexpr size_t BlockSizeBytes = 262144;\n+\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object that uses the specified chunk size to optimize for.\n+     */\n+    explicit MemoryResource(size_t chunk_size_bytes) : m_chunk_size_bytes(chunk_size_bytes) {}\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated blocks.\n+     *\n+     * There's no Clear() method on purpose, because it would be dangerous. E.g. when calling clear() on\n+     * an unordered_map, it is not certain that all allocated chunks are given back to the MemoryResource.\n+     * Microsoft's STL still uses a control structure that might have the same size as the nodes, and therefore\n+     * needs to be kept around until the map is actually destroyed.\n+     */\n+    ~MemoryResource() noexcept\n+    {\n+        for (auto* block : m_allocated_blocks) {\n+            ::operator delete(block);\n+        }\n+    }\n+\n+    /**\n+     * Allocates memory for n times T. Only when n==1 and T's size matches m_chunk_size_bytes\n+     * the chunking mechanism is used. Otherwise, the allocation is forwarded to ::operator new().\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes != required_chunk_size || n != 1) {\n+            // pool is not used so forward to operator new.\n+            return static_cast<T*>(::operator new(n * sizeof(T)));\n+        }\n+\n+        // chunk size is correct, so we can actually use the pool's block data\n+\n+        if (m_free_chunks) {\n+            // we've already got data in the free list, unlink one element\n+            auto old_head = m_free_chunks;\n+            m_free_chunks = static_cast<ChunkNode*>(m_free_chunks)->next;\n+            return static_cast<T*>(old_head);\n+        }\n+\n+        // free list is empty: get one chunk from allocated block memory.\n+        // It makes sense to not create the fully linked list of an allocated block up-front, for several reasons.\n+        // On the one hand, the latency is higher when we need to iterate and update pointers for the whole block at once.\n+        // More importantly, most systems lazily allocate data. So when we allocate a big block of memory the memory for a page\n+        // is only actually made available to the program when it is first touched. So when we allocate a big block and only use\n+        // very little memory from it, the total memory usage is lower than what has been malloc'ed.\n+        if (m_untouched_memory_iterator == m_untouched_memory_end) {\n+            // slow path, only happens when a new block needs to be allocated\n+            AllocateNewBlock();\n+        }\n+\n+        // peel off one chunk from the untouched memory. The next pointer of in-use elements doesn't matter until it is\n+        // deallocated, only then it is used to form the free list.\n+        const auto tmp = m_untouched_memory_iterator;\n+        m_untouched_memory_iterator = static_cast<char*>(tmp) + m_chunk_size_bytes;\n+        return static_cast<T*>(tmp);\n+    }\n+\n+    /**\n+     * Puts p back into the free list f it was actually allocated from the memory block.\n+     * Otherwise, simply call ::operator delete(p).\n+     */\n+    template <typename T>\n+    void Deallocate(void* p, size_t n) noexcept\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size_bytes = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes == required_chunk_size_bytes && n == 1) {\n+            // put it into the linked list\n+            const auto node = static_cast<ChunkNode*>(p);\n+            node->next = m_free_chunks;\n+            m_free_chunks = node;\n+        } else {\n+            // allocation didn't happen with the pool\n+            ::operator delete(p);\n+        }\n+    }\n+\n+    /**\n+     * Actual size in bytes that is used for one chunk (node allocation)\n+     */\n+    [[nodiscard]] size_t ChunkSizeBytes() const noexcept\n+    {\n+        return m_chunk_size_bytes;\n+    }\n+\n+    /**\n+     * Calculates bytes allocated by the memory resource.\n+     */\n+    [[nodiscard]] size_t DynamicMemoryUsage() const noexcept\n+    {\n+        const size_t alloc_size{(BlockSizeBytes / m_chunk_size_bytes) * m_chunk_size_bytes};\n+        return memusage::MallocUsage(alloc_size) * m_allocated_blocks.size() + memusage::DynamicUsage(m_allocated_blocks);\n+    }\n+\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation. Mostly for debugging / logging / testing.\n+     */\n+    [[nodiscard]] size_t NumFreeChunks() const noexcept\n+    {\n+        size_t length = 0;\n+        auto node = m_free_chunks;\n+        while (node) {\n+            node = static_cast<ChunkNode const*>(node)->next;\n+            ++length;\n+        }\n+        return length;\n+    }\n+\n+    /**\n+     * Number of memory blocks that have been allocated\n+     */\n+    [[nodiscard]] size_t NumBlocks() const noexcept\n+    {\n+        return m_allocated_blocks.size();\n+    }\n+\n+    /**\n+     * Calculates the required chunk size for the given type.\n+     * The memory block needs to be correctly aligned and large enough to hold both T and ChunkNode.\n+     */\n+    template <typename T>\n+    [[nodiscard]] static constexpr size_t CalcRequiredChunkSizeBytes() noexcept\n+    {\n+        const auto alignment_max = std::max(std::alignment_of_v<T>, std::alignment_of_v<ChunkNode>);\n+        const auto size_max = std::max(sizeof(T), sizeof(ChunkNode));\n+\n+        // find closest multiple of alignment_max that holds size_max\n+        return ((size_max + alignment_max - 1U) / alignment_max) * alignment_max;\n+    }\n+\n+private:\n+    /**\n+     * Allocate one full memory block which is used to carve out chunks.\n+     * The block size is the multiple of m_chunk_size_bytes that comes closest to BlockSizeBytes.\n+     */\n+    void AllocateNewBlock()\n+    {\n+        static_assert(sizeof(char) == 1U);\n+\n+        const auto num_chunks = BlockSizeBytes / m_chunk_size_bytes;\n+        m_untouched_memory_iterator = ::operator new(num_chunks* m_chunk_size_bytes);\n+        m_untouched_memory_end = static_cast<char*>(m_untouched_memory_iterator) + num_chunks * m_chunk_size_bytes;\n+        m_allocated_blocks.push_back(m_untouched_memory_iterator);\n+    }\n+\n+    /**\n+     * The MemoryResource's size for the memory chunks that it can give out.\n+     */\n+    size_t const m_chunk_size_bytes;\n+\n+    //! A contains all allocated blocks of memory, used to free the data in the destructor.\n+    std::vector<void*> m_allocated_blocks{};\n+\n+    //! A single linked list of all data available in the MemoryResource. This list is used for allocations of single elements.\n+    void* m_free_chunks = nullptr;\n+\n+    //! Points to the beginning of available memory for carving out chunks.\n+    void* m_untouched_memory_iterator = nullptr;\n+\n+    //! Points to the end of available memory for carving out chunks.\n+    void* m_untouched_memory_end = nullptr;\n+};\n+\n+\n+/**\n+ * Allocator that's usable for node-based containers like std::unordered_map or std::list.\n+ *\n+ * The allocator is stateful, and can be cheaply copied. Its state is an immobile MemoryResource, which\n+ * actually does all the allocation/deallocations. So this class is just a simple wrapper that conforms to the\n+ * required STL interface to be usable for the node-based containers.\n+ */\n+template <typename T>\n+class Allocator\n+{\n+    template <typename U>\n+    friend class Allocator;\n+\n+    template <typename X, typename Y>\n+    friend bool operator==(const Allocator<X>& a, const Allocator<Y>& b) noexcept;\n+\n+public:\n+    using value_type = T;\n+\n+    /**\n+     * The allocator is stateful so we can't use the compile time `is_always_equal` optimization and have to use the runtime operator==.\n+     */\n+    using is_always_equal = std::false_type;\n+\n+    /**\n+     * Move assignment should be a fast operation. In the case of a = std::move(b), we want\n+     * a to be able to use b's allocator, otherwise all elements would have to be recreated with a's old allocator.\n+     */\n+    using propagate_on_container_move_assignment = std::true_type;\n+\n+    /**\n+     * Swapping two containers with unequal allocators who are *not* propagated is undefined\n+     * behavior. Unfortunately this is the default! Obviously, we don't want that.\n+     */\n+    using propagate_on_container_swap = std::true_type; // to avoid the undefined behavior\n+\n+    /**\n+     * Move and swap have to propagate the allocator, so for consistency we do the same for copy assignment.\n+     */\n+    using propagate_on_container_copy_assignment = std::true_type;\n+\n+    /**\n+     * Construct a new Allocator object which will delegate all allocations/deallocations to the memory resource.\n+     */\n+    explicit Allocator(MemoryResource* memory_resource) noexcept\n+        : m_memory_resource(memory_resource)\n+    {\n+    }\n+\n+    /**\n+     * Conversion constructor for rebinding. All Allocators use the same memory_resource.",
    "path": "src/support/allocators/node_allocator.h",
    "position": null,
    "original_position": 321,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "952c37a31c39b7acdb5ab2634a354a1c548708a2",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "In commit \"Add allocator for node based containers\" (952c37a31c39b7acdb5ab2634a354a1c548708a2)\r\n\r\nCurious, when does rebinding happen? Maybe say something about when/if this would happen in a sentence here.",
    "created_at": "2021-10-22T21:21:34Z",
    "updated_at": "2021-10-22T22:02:11Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r734849669",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734849669"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r734849669"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734849669/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 303,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734854608",
    "pull_request_review_id": 787000548,
    "id": 734854608,
    "node_id": "PRRC_kwDOABII584rzP3Q",
    "diff_hunk": "@@ -0,0 +1,425 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored in-place. This typically\n+ *   saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but there is no\n+ *   standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on proximity. So freeing\n+ *   and malloc'ing again can become a random access pattern which can lead to more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Currently it is only\n+ * able provide optimized alloc/free for a single fixed node size which is given in the constructor. Only allocations that match this\n+ * size will be provided from the preallocated blocks of memory; all other requests simply use ::operator new().\n+ * To get the correct node size in all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios in\n+ * `node_allocator_tests/test_chunks_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall \u201cHow to Write a Custom Allocator\u201d https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer \u201cAn Allocator is a Handle to a Heap\u201d https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *      https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block, or from a free list if it contains entries.\n+ *   Whenever a node is given back with Deallocate(), it is put into that free list.\n+ */\n+class MemoryResource\n+{\n+    //! Size in bytes to allocate per block, currently hardcoded to 256 KiB.\n+    static constexpr size_t BlockSizeBytes = 262144;\n+\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object that uses the specified chunk size to optimize for.\n+     */\n+    explicit MemoryResource(size_t chunk_size_bytes) : m_chunk_size_bytes(chunk_size_bytes) {}\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated blocks.\n+     *\n+     * There's no Clear() method on purpose, because it would be dangerous. E.g. when calling clear() on\n+     * an unordered_map, it is not certain that all allocated chunks are given back to the MemoryResource.\n+     * Microsoft's STL still uses a control structure that might have the same size as the nodes, and therefore\n+     * needs to be kept around until the map is actually destroyed.\n+     */\n+    ~MemoryResource() noexcept\n+    {\n+        for (auto* block : m_allocated_blocks) {\n+            ::operator delete(block);\n+        }\n+    }\n+\n+    /**\n+     * Allocates memory for n times T. Only when n==1 and T's size matches m_chunk_size_bytes\n+     * the chunking mechanism is used. Otherwise, the allocation is forwarded to ::operator new().\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes != required_chunk_size || n != 1) {\n+            // pool is not used so forward to operator new.\n+            return static_cast<T*>(::operator new(n * sizeof(T)));\n+        }\n+\n+        // chunk size is correct, so we can actually use the pool's block data\n+\n+        if (m_free_chunks) {\n+            // we've already got data in the free list, unlink one element\n+            auto old_head = m_free_chunks;\n+            m_free_chunks = static_cast<ChunkNode*>(m_free_chunks)->next;\n+            return static_cast<T*>(old_head);\n+        }\n+\n+        // free list is empty: get one chunk from allocated block memory.\n+        // It makes sense to not create the fully linked list of an allocated block up-front, for several reasons.\n+        // On the one hand, the latency is higher when we need to iterate and update pointers for the whole block at once.\n+        // More importantly, most systems lazily allocate data. So when we allocate a big block of memory the memory for a page\n+        // is only actually made available to the program when it is first touched. So when we allocate a big block and only use\n+        // very little memory from it, the total memory usage is lower than what has been malloc'ed.\n+        if (m_untouched_memory_iterator == m_untouched_memory_end) {\n+            // slow path, only happens when a new block needs to be allocated\n+            AllocateNewBlock();\n+        }\n+\n+        // peel off one chunk from the untouched memory. The next pointer of in-use elements doesn't matter until it is\n+        // deallocated, only then it is used to form the free list.\n+        const auto tmp = m_untouched_memory_iterator;\n+        m_untouched_memory_iterator = static_cast<char*>(tmp) + m_chunk_size_bytes;\n+        return static_cast<T*>(tmp);\n+    }\n+\n+    /**\n+     * Puts p back into the free list f it was actually allocated from the memory block.\n+     * Otherwise, simply call ::operator delete(p).\n+     */\n+    template <typename T>\n+    void Deallocate(void* p, size_t n) noexcept\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size_bytes = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes == required_chunk_size_bytes && n == 1) {\n+            // put it into the linked list\n+            const auto node = static_cast<ChunkNode*>(p);\n+            node->next = m_free_chunks;\n+            m_free_chunks = node;\n+        } else {\n+            // allocation didn't happen with the pool\n+            ::operator delete(p);\n+        }\n+    }\n+\n+    /**\n+     * Actual size in bytes that is used for one chunk (node allocation)\n+     */\n+    [[nodiscard]] size_t ChunkSizeBytes() const noexcept\n+    {\n+        return m_chunk_size_bytes;\n+    }\n+\n+    /**\n+     * Calculates bytes allocated by the memory resource.\n+     */\n+    [[nodiscard]] size_t DynamicMemoryUsage() const noexcept\n+    {\n+        const size_t alloc_size{(BlockSizeBytes / m_chunk_size_bytes) * m_chunk_size_bytes};\n+        return memusage::MallocUsage(alloc_size) * m_allocated_blocks.size() + memusage::DynamicUsage(m_allocated_blocks);\n+    }\n+\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation. Mostly for debugging / logging / testing.\n+     */\n+    [[nodiscard]] size_t NumFreeChunks() const noexcept\n+    {\n+        size_t length = 0;\n+        auto node = m_free_chunks;\n+        while (node) {\n+            node = static_cast<ChunkNode const*>(node)->next;\n+            ++length;\n+        }\n+        return length;\n+    }\n+\n+    /**\n+     * Number of memory blocks that have been allocated\n+     */\n+    [[nodiscard]] size_t NumBlocks() const noexcept\n+    {\n+        return m_allocated_blocks.size();\n+    }\n+\n+    /**\n+     * Calculates the required chunk size for the given type.\n+     * The memory block needs to be correctly aligned and large enough to hold both T and ChunkNode.\n+     */\n+    template <typename T>\n+    [[nodiscard]] static constexpr size_t CalcRequiredChunkSizeBytes() noexcept\n+    {\n+        const auto alignment_max = std::max(std::alignment_of_v<T>, std::alignment_of_v<ChunkNode>);\n+        const auto size_max = std::max(sizeof(T), sizeof(ChunkNode));\n+\n+        // find closest multiple of alignment_max that holds size_max\n+        return ((size_max + alignment_max - 1U) / alignment_max) * alignment_max;\n+    }\n+\n+private:\n+    /**\n+     * Allocate one full memory block which is used to carve out chunks.\n+     * The block size is the multiple of m_chunk_size_bytes that comes closest to BlockSizeBytes.\n+     */\n+    void AllocateNewBlock()\n+    {\n+        static_assert(sizeof(char) == 1U);\n+\n+        const auto num_chunks = BlockSizeBytes / m_chunk_size_bytes;\n+        m_untouched_memory_iterator = ::operator new(num_chunks* m_chunk_size_bytes);\n+        m_untouched_memory_end = static_cast<char*>(m_untouched_memory_iterator) + num_chunks * m_chunk_size_bytes;\n+        m_allocated_blocks.push_back(m_untouched_memory_iterator);\n+    }\n+\n+    /**\n+     * The MemoryResource's size for the memory chunks that it can give out.\n+     */\n+    size_t const m_chunk_size_bytes;\n+\n+    //! A contains all allocated blocks of memory, used to free the data in the destructor.\n+    std::vector<void*> m_allocated_blocks{};\n+\n+    //! A single linked list of all data available in the MemoryResource. This list is used for allocations of single elements.\n+    void* m_free_chunks = nullptr;\n+\n+    //! Points to the beginning of available memory for carving out chunks.\n+    void* m_untouched_memory_iterator = nullptr;\n+\n+    //! Points to the end of available memory for carving out chunks.\n+    void* m_untouched_memory_end = nullptr;\n+};\n+\n+\n+/**\n+ * Allocator that's usable for node-based containers like std::unordered_map or std::list.\n+ *\n+ * The allocator is stateful, and can be cheaply copied. Its state is an immobile MemoryResource, which\n+ * actually does all the allocation/deallocations. So this class is just a simple wrapper that conforms to the\n+ * required STL interface to be usable for the node-based containers.\n+ */\n+template <typename T>\n+class Allocator\n+{\n+    template <typename U>\n+    friend class Allocator;\n+\n+    template <typename X, typename Y>\n+    friend bool operator==(const Allocator<X>& a, const Allocator<Y>& b) noexcept;\n+\n+public:\n+    using value_type = T;\n+\n+    /**\n+     * The allocator is stateful so we can't use the compile time `is_always_equal` optimization and have to use the runtime operator==.\n+     */\n+    using is_always_equal = std::false_type;\n+\n+    /**\n+     * Move assignment should be a fast operation. In the case of a = std::move(b), we want\n+     * a to be able to use b's allocator, otherwise all elements would have to be recreated with a's old allocator.\n+     */\n+    using propagate_on_container_move_assignment = std::true_type;\n+\n+    /**\n+     * Swapping two containers with unequal allocators who are *not* propagated is undefined\n+     * behavior. Unfortunately this is the default! Obviously, we don't want that.\n+     */\n+    using propagate_on_container_swap = std::true_type; // to avoid the undefined behavior\n+\n+    /**\n+     * Move and swap have to propagate the allocator, so for consistency we do the same for copy assignment.\n+     */\n+    using propagate_on_container_copy_assignment = std::true_type;\n+\n+    /**\n+     * Construct a new Allocator object which will delegate all allocations/deallocations to the memory resource.\n+     */\n+    explicit Allocator(MemoryResource* memory_resource) noexcept\n+        : m_memory_resource(memory_resource)\n+    {\n+    }\n+\n+    /**\n+     * Conversion constructor for rebinding. All Allocators use the same memory_resource.\n+     */\n+    template <typename U>\n+    Allocator(const Allocator<U>& other) noexcept\n+        : m_memory_resource(other.m_memory_resource)\n+    {\n+    }\n+\n+    /**\n+     * Allocates n entries of the given type.\n+     */\n+    T* allocate(size_t n)\n+    {\n+        // Forward all allocations to the memory_resource\n+        return m_memory_resource->Allocate<T>(n);\n+    }\n+\n+\n+    /**\n+     * Deallocates n entries of the given type.\n+     */\n+    void deallocate(T* p, size_t n)\n+    {\n+        m_memory_resource->Deallocate<T>(p, n);\n+    }\n+\n+private:\n+    //! Stateful allocator, where the state is a simple pointer that can be cheaply copied.\n+    MemoryResource* m_memory_resource;\n+};\n+\n+\n+/**\n+ * Since Allocator is stateful, comparison with another one only returns true if it uses the same memory_resource.\n+ */\n+template <typename T, typename U>\n+bool operator==(const Allocator<T>& a, const Allocator<U>& b) noexcept\n+{\n+    // \"Equality of an allocator is determined through the ability of allocating memory with one\n+    // allocator and deallocating it with another.\" - Jonathan M\u00fcller\n+    // See https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+    //\n+    // For us that is the case when both allocators use the same memory resource.\n+    return a.m_memory_resource == b.m_memory_resource;\n+}\n+\n+template <typename T, typename U>\n+bool operator!=(const Allocator<T>& a, const Allocator<U>& b) noexcept\n+{\n+    return !(a == b);\n+}\n+\n+/**\n+ * Helper to create std::unordered_map which uses the node_allocator.\n+ *\n+ * This calculates the size of the container's internally used node correctly for all supported platforms,\n+ * which is also asserted by the unit tests.\n+ */\n+template <typename Key, typename Value, typename Hash = std::hash<Key>, typename Equals = std::equal_to<Key>>\n+class UnorderedMapFactory\n+{\n+public:\n+    using AllocatorType = Allocator<std::pair<const Key, Value>>;\n+    using ContainerType = std::unordered_map<Key, Value, Hash, Equals, AllocatorType>;\n+    static constexpr size_t NodeSizeBytes = memusage::NodeSize<ContainerType>::Value();\n+\n+    /**\n+     * Create the MemoryResource with correctly calculated ChunkSize.\n+     */\n+    [[nodiscard]] static MemoryResource CreateMemoryResource()\n+    {\n+        return MemoryResource{NodeSizeBytes};\n+    }\n+\n+    /**\n+     * Creates the std::unordered_map container, and asserts that the specified memory_resource is correct.\n+     */\n+    [[nodiscard]] static ContainerType CreateContainer(MemoryResource* memory_resource)\n+    {\n+        assert(memory_resource != nullptr && memory_resource->ChunkSizeBytes() == NodeSizeBytes);\n+        return ContainerType{0, Hash{}, Equals{}, AllocatorType{memory_resource}};\n+    }\n+\n+    /**\n+     * Constructs MemoryResource in the uninitialized storage pointed to by ptr.\n+     */\n+    static void Construct(MemoryResource* ptr)\n+    {\n+        assert(ptr != nullptr);\n+        ::new ((void*)ptr) MemoryResource{NodeSizeBytes};\n+    }\n+\n+    /**\n+     * Constructs the container in the uninitialized storage pointed to by ptr, using the given memory_resource as parameter.\n+     */\n+    static void Construct(ContainerType* ptr, MemoryResource* memory_resource)\n+    {\n+        assert(ptr != nullptr && memory_resource != nullptr && memory_resource->ChunkSizeBytes() == NodeSizeBytes);\n+        ::new ((void*)ptr) ContainerType{0, Hash{}, Equals{}, AllocatorType{memory_resource}};\n+    }\n+};",
    "path": "src/support/allocators/node_allocator.h",
    "position": null,
    "original_position": 421,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "952c37a31c39b7acdb5ab2634a354a1c548708a2",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "In commit \"Add allocator for node based containers\" (952c37a31c39b7acdb5ab2634a354a1c548708a2)\r\n\r\nThese construct methods seem sketchy and prone to misuse. Can we drop these? The one place these are called is in `ReallocateCache` and it should be possible to eliminate them there by keeping the existing placement new:\r\n\r\n```c++\r\n::new (&cacheCoinsMemoryResource) MemoryResource{CCoinsMapFactory::CreateMemoryResource()};\r\n::new (&cacheCoins) CCoinsMap{CCoinsMapFactory::CreateContainer(&cacheCoinsMemoryResource)};\r\n```",
    "created_at": "2021-10-22T21:34:11Z",
    "updated_at": "2021-10-22T22:02:11Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r734854608",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734854608"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r734854608"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734854608/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": 404,
    "start_side": "RIGHT",
    "line": null,
    "original_line": 422,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734858608",
    "pull_request_review_id": 787000548,
    "id": 734858608,
    "node_id": "PRRC_kwDOABII584rzQ1w",
    "diff_hunk": "@@ -222,6 +222,7 @@ bool CCoinsViewCache::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlockIn\n bool CCoinsViewCache::Flush() {\n     bool fOk = base->BatchWrite(cacheCoins, hashBlock);\n     cacheCoins.clear();\n+    ReallocateCache();",
    "path": "src/coins.cpp",
    "position": 17,
    "original_position": 17,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "952c37a31c39b7acdb5ab2634a354a1c548708a2",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "In commit \"Add allocator for node based containers\" (952c37a31c39b7acdb5ab2634a354a1c548708a2)\r\n\r\nI think it makes sense to add ReallocateCache cache (though I would be curious if someone knows a reason it wasn't added here initially).\r\n\r\nBut if we are going to add this here I think we should remove the other `ReallocateCache()` call in `validation.h` which is now redundant, and make the `ReallocateCache` method private so it is not uselessly confusing.",
    "created_at": "2021-10-22T21:44:28Z",
    "updated_at": "2021-10-22T22:02:11Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r734858608",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734858608"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r734858608"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734858608/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 225,
    "original_line": 225,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734861053",
    "pull_request_review_id": 787000548,
    "id": 734861053,
    "node_id": "PRRC_kwDOABII584rzRb9",
    "diff_hunk": "@@ -148,23 +154,61 @@ static inline size_t DynamicUsage(const std::shared_ptr<X>& p)\n     return p ? MallocUsage(sizeof(X)) + MallocUsage(sizeof(stl_shared_counter)) : 0;\n }\n \n-template<typename X>\n-struct unordered_node : private X\n-{\n-private:\n-    void* ptr;\n+template <typename T>\n+struct NodeSize {\n+};\n+\n+template <typename Key, typename V, typename Hash, typename Equals, typename Allocator>\n+struct NodeSize<std::unordered_map<Key, V, Hash, Equals, Allocator>> {",
    "path": "src/memusage.h",
    "position": null,
    "original_position": 27,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "952c37a31c39b7acdb5ab2634a354a1c548708a2",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "In commit \"Add allocator for node based containers\" (952c37a31c39b7acdb5ab2634a354a1c548708a2)\r\n\r\nJust so this information is easily accessible, can you add a comment about how this is tested for accuracy or where the tests can be found?",
    "created_at": "2021-10-22T21:51:16Z",
    "updated_at": "2021-10-22T22:02:11Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r734861053",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734861053"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r734861053"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734861053/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 165,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734941728",
    "pull_request_review_id": 779353334,
    "id": 734941728,
    "node_id": "PRRC_kwDOABII584rzlIg",
    "diff_hunk": "@@ -222,6 +222,7 @@ bool CCoinsViewCache::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlockIn\n bool CCoinsViewCache::Flush() {\n     bool fOk = base->BatchWrite(cacheCoins, hashBlock);\n     cacheCoins.clear();\n+    ReallocateCache();",
    "path": "src/coins.cpp",
    "position": 17,
    "original_position": 17,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "952c37a31c39b7acdb5ab2634a354a1c548708a2",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "`ReallocateCache` is now necessary here, because Flush is triggered when memory is full, and with the node_allocator clear() does not free any memory the memory usage would stay constant. It was not necessary before because clear() already deallocated all of the nodes and only kept the memory for the unordered_map's internal indexing array.\r\n\r\nRight! `CoinsTip().ReallocateCache();` in validation.cpp is now unnecessary. Good catch.",
    "created_at": "2021-10-23T08:20:03Z",
    "updated_at": "2021-10-26T08:33:52Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r734941728",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734941728"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r734941728"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734941728/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 225,
    "original_line": 225,
    "side": "RIGHT",
    "in_reply_to_id": 734858608
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/735096984",
    "pull_request_review_id": 779353334,
    "id": 735096984,
    "node_id": "PRRC_kwDOABII584r0LCY",
    "diff_hunk": "@@ -0,0 +1,425 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored in-place. This typically\n+ *   saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but there is no\n+ *   standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on proximity. So freeing\n+ *   and malloc'ing again can become a random access pattern which can lead to more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Currently it is only\n+ * able provide optimized alloc/free for a single fixed node size which is given in the constructor. Only allocations that match this\n+ * size will be provided from the preallocated blocks of memory; all other requests simply use ::operator new().\n+ * To get the correct node size in all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios in\n+ * `node_allocator_tests/test_chunks_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall \u201cHow to Write a Custom Allocator\u201d https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer \u201cAn Allocator is a Handle to a Heap\u201d https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *      https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block, or from a free list if it contains entries.\n+ *   Whenever a node is given back with Deallocate(), it is put into that free list.\n+ */\n+class MemoryResource\n+{\n+    //! Size in bytes to allocate per block, currently hardcoded to 256 KiB.\n+    static constexpr size_t BlockSizeBytes = 262144;\n+\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object that uses the specified chunk size to optimize for.\n+     */\n+    explicit MemoryResource(size_t chunk_size_bytes) : m_chunk_size_bytes(chunk_size_bytes) {}\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated blocks.\n+     *\n+     * There's no Clear() method on purpose, because it would be dangerous. E.g. when calling clear() on\n+     * an unordered_map, it is not certain that all allocated chunks are given back to the MemoryResource.\n+     * Microsoft's STL still uses a control structure that might have the same size as the nodes, and therefore\n+     * needs to be kept around until the map is actually destroyed.\n+     */\n+    ~MemoryResource() noexcept\n+    {\n+        for (auto* block : m_allocated_blocks) {\n+            ::operator delete(block);\n+        }\n+    }\n+\n+    /**\n+     * Allocates memory for n times T. Only when n==1 and T's size matches m_chunk_size_bytes\n+     * the chunking mechanism is used. Otherwise, the allocation is forwarded to ::operator new().\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes != required_chunk_size || n != 1) {\n+            // pool is not used so forward to operator new.\n+            return static_cast<T*>(::operator new(n * sizeof(T)));\n+        }\n+\n+        // chunk size is correct, so we can actually use the pool's block data\n+\n+        if (m_free_chunks) {\n+            // we've already got data in the free list, unlink one element\n+            auto old_head = m_free_chunks;\n+            m_free_chunks = static_cast<ChunkNode*>(m_free_chunks)->next;\n+            return static_cast<T*>(old_head);\n+        }\n+\n+        // free list is empty: get one chunk from allocated block memory.\n+        // It makes sense to not create the fully linked list of an allocated block up-front, for several reasons.\n+        // On the one hand, the latency is higher when we need to iterate and update pointers for the whole block at once.\n+        // More importantly, most systems lazily allocate data. So when we allocate a big block of memory the memory for a page\n+        // is only actually made available to the program when it is first touched. So when we allocate a big block and only use\n+        // very little memory from it, the total memory usage is lower than what has been malloc'ed.\n+        if (m_untouched_memory_iterator == m_untouched_memory_end) {\n+            // slow path, only happens when a new block needs to be allocated\n+            AllocateNewBlock();\n+        }\n+\n+        // peel off one chunk from the untouched memory. The next pointer of in-use elements doesn't matter until it is\n+        // deallocated, only then it is used to form the free list.\n+        const auto tmp = m_untouched_memory_iterator;\n+        m_untouched_memory_iterator = static_cast<char*>(tmp) + m_chunk_size_bytes;\n+        return static_cast<T*>(tmp);\n+    }\n+\n+    /**\n+     * Puts p back into the free list f it was actually allocated from the memory block.\n+     * Otherwise, simply call ::operator delete(p).\n+     */\n+    template <typename T>\n+    void Deallocate(void* p, size_t n) noexcept\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size_bytes = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes == required_chunk_size_bytes && n == 1) {\n+            // put it into the linked list\n+            const auto node = static_cast<ChunkNode*>(p);\n+            node->next = m_free_chunks;\n+            m_free_chunks = node;\n+        } else {\n+            // allocation didn't happen with the pool\n+            ::operator delete(p);\n+        }\n+    }\n+\n+    /**\n+     * Actual size in bytes that is used for one chunk (node allocation)\n+     */\n+    [[nodiscard]] size_t ChunkSizeBytes() const noexcept\n+    {\n+        return m_chunk_size_bytes;\n+    }\n+\n+    /**\n+     * Calculates bytes allocated by the memory resource.\n+     */\n+    [[nodiscard]] size_t DynamicMemoryUsage() const noexcept\n+    {\n+        const size_t alloc_size{(BlockSizeBytes / m_chunk_size_bytes) * m_chunk_size_bytes};\n+        return memusage::MallocUsage(alloc_size) * m_allocated_blocks.size() + memusage::DynamicUsage(m_allocated_blocks);\n+    }\n+\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation. Mostly for debugging / logging / testing.\n+     */\n+    [[nodiscard]] size_t NumFreeChunks() const noexcept\n+    {\n+        size_t length = 0;\n+        auto node = m_free_chunks;\n+        while (node) {\n+            node = static_cast<ChunkNode const*>(node)->next;\n+            ++length;\n+        }\n+        return length;\n+    }\n+\n+    /**\n+     * Number of memory blocks that have been allocated\n+     */\n+    [[nodiscard]] size_t NumBlocks() const noexcept\n+    {\n+        return m_allocated_blocks.size();\n+    }\n+\n+    /**\n+     * Calculates the required chunk size for the given type.\n+     * The memory block needs to be correctly aligned and large enough to hold both T and ChunkNode.\n+     */\n+    template <typename T>\n+    [[nodiscard]] static constexpr size_t CalcRequiredChunkSizeBytes() noexcept\n+    {\n+        const auto alignment_max = std::max(std::alignment_of_v<T>, std::alignment_of_v<ChunkNode>);\n+        const auto size_max = std::max(sizeof(T), sizeof(ChunkNode));\n+\n+        // find closest multiple of alignment_max that holds size_max\n+        return ((size_max + alignment_max - 1U) / alignment_max) * alignment_max;\n+    }\n+\n+private:\n+    /**\n+     * Allocate one full memory block which is used to carve out chunks.\n+     * The block size is the multiple of m_chunk_size_bytes that comes closest to BlockSizeBytes.\n+     */\n+    void AllocateNewBlock()\n+    {\n+        static_assert(sizeof(char) == 1U);\n+\n+        const auto num_chunks = BlockSizeBytes / m_chunk_size_bytes;\n+        m_untouched_memory_iterator = ::operator new(num_chunks* m_chunk_size_bytes);\n+        m_untouched_memory_end = static_cast<char*>(m_untouched_memory_iterator) + num_chunks * m_chunk_size_bytes;\n+        m_allocated_blocks.push_back(m_untouched_memory_iterator);\n+    }\n+\n+    /**\n+     * The MemoryResource's size for the memory chunks that it can give out.\n+     */\n+    size_t const m_chunk_size_bytes;\n+\n+    //! A contains all allocated blocks of memory, used to free the data in the destructor.\n+    std::vector<void*> m_allocated_blocks{};\n+\n+    //! A single linked list of all data available in the MemoryResource. This list is used for allocations of single elements.\n+    void* m_free_chunks = nullptr;\n+\n+    //! Points to the beginning of available memory for carving out chunks.\n+    void* m_untouched_memory_iterator = nullptr;\n+\n+    //! Points to the end of available memory for carving out chunks.\n+    void* m_untouched_memory_end = nullptr;",
    "path": "src/support/allocators/node_allocator.h",
    "position": null,
    "original_position": 267,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "952c37a31c39b7acdb5ab2634a354a1c548708a2",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "I'd prefer to keep that member variable because it is used in `Allocate(size_t n)` which should be really fast. I think it would be a bit slower with additional indirections. Also I currently don't need special handling for when nothing is allocated yet because both pointers are initialized to nullptr",
    "created_at": "2021-10-24T10:27:17Z",
    "updated_at": "2021-10-26T08:33:51Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r735096984",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/735096984"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r735096984"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/735096984/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 267,
    "side": "RIGHT",
    "in_reply_to_id": 734648036
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/735146196",
    "pull_request_review_id": 779353334,
    "id": 735146196,
    "node_id": "PRRC_kwDOABII584r0XDU",
    "diff_hunk": "@@ -0,0 +1,425 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored in-place. This typically\n+ *   saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but there is no\n+ *   standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on proximity. So freeing\n+ *   and malloc'ing again can become a random access pattern which can lead to more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Currently it is only\n+ * able provide optimized alloc/free for a single fixed node size which is given in the constructor. Only allocations that match this\n+ * size will be provided from the preallocated blocks of memory; all other requests simply use ::operator new().\n+ * To get the correct node size in all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios in\n+ * `node_allocator_tests/test_chunks_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall \u201cHow to Write a Custom Allocator\u201d https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer \u201cAn Allocator is a Handle to a Heap\u201d https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *      https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block, or from a free list if it contains entries.\n+ *   Whenever a node is given back with Deallocate(), it is put into that free list.\n+ */\n+class MemoryResource\n+{\n+    //! Size in bytes to allocate per block, currently hardcoded to 256 KiB.\n+    static constexpr size_t BlockSizeBytes = 262144;\n+\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object that uses the specified chunk size to optimize for.\n+     */\n+    explicit MemoryResource(size_t chunk_size_bytes) : m_chunk_size_bytes(chunk_size_bytes) {}\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated blocks.\n+     *\n+     * There's no Clear() method on purpose, because it would be dangerous. E.g. when calling clear() on\n+     * an unordered_map, it is not certain that all allocated chunks are given back to the MemoryResource.\n+     * Microsoft's STL still uses a control structure that might have the same size as the nodes, and therefore\n+     * needs to be kept around until the map is actually destroyed.\n+     */\n+    ~MemoryResource() noexcept\n+    {\n+        for (auto* block : m_allocated_blocks) {\n+            ::operator delete(block);\n+        }\n+    }\n+\n+    /**\n+     * Allocates memory for n times T. Only when n==1 and T's size matches m_chunk_size_bytes\n+     * the chunking mechanism is used. Otherwise, the allocation is forwarded to ::operator new().\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes != required_chunk_size || n != 1) {\n+            // pool is not used so forward to operator new.\n+            return static_cast<T*>(::operator new(n * sizeof(T)));\n+        }\n+\n+        // chunk size is correct, so we can actually use the pool's block data\n+\n+        if (m_free_chunks) {\n+            // we've already got data in the free list, unlink one element\n+            auto old_head = m_free_chunks;\n+            m_free_chunks = static_cast<ChunkNode*>(m_free_chunks)->next;\n+            return static_cast<T*>(old_head);\n+        }\n+\n+        // free list is empty: get one chunk from allocated block memory.\n+        // It makes sense to not create the fully linked list of an allocated block up-front, for several reasons.\n+        // On the one hand, the latency is higher when we need to iterate and update pointers for the whole block at once.\n+        // More importantly, most systems lazily allocate data. So when we allocate a big block of memory the memory for a page\n+        // is only actually made available to the program when it is first touched. So when we allocate a big block and only use\n+        // very little memory from it, the total memory usage is lower than what has been malloc'ed.\n+        if (m_untouched_memory_iterator == m_untouched_memory_end) {\n+            // slow path, only happens when a new block needs to be allocated\n+            AllocateNewBlock();\n+        }\n+\n+        // peel off one chunk from the untouched memory. The next pointer of in-use elements doesn't matter until it is\n+        // deallocated, only then it is used to form the free list.\n+        const auto tmp = m_untouched_memory_iterator;\n+        m_untouched_memory_iterator = static_cast<char*>(tmp) + m_chunk_size_bytes;\n+        return static_cast<T*>(tmp);\n+    }\n+\n+    /**\n+     * Puts p back into the free list f it was actually allocated from the memory block.\n+     * Otherwise, simply call ::operator delete(p).\n+     */\n+    template <typename T>\n+    void Deallocate(void* p, size_t n) noexcept\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size_bytes = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes == required_chunk_size_bytes && n == 1) {\n+            // put it into the linked list\n+            const auto node = static_cast<ChunkNode*>(p);\n+            node->next = m_free_chunks;\n+            m_free_chunks = node;\n+        } else {\n+            // allocation didn't happen with the pool\n+            ::operator delete(p);\n+        }\n+    }\n+\n+    /**\n+     * Actual size in bytes that is used for one chunk (node allocation)\n+     */\n+    [[nodiscard]] size_t ChunkSizeBytes() const noexcept\n+    {\n+        return m_chunk_size_bytes;\n+    }\n+\n+    /**\n+     * Calculates bytes allocated by the memory resource.\n+     */\n+    [[nodiscard]] size_t DynamicMemoryUsage() const noexcept\n+    {\n+        const size_t alloc_size{(BlockSizeBytes / m_chunk_size_bytes) * m_chunk_size_bytes};\n+        return memusage::MallocUsage(alloc_size) * m_allocated_blocks.size() + memusage::DynamicUsage(m_allocated_blocks);\n+    }\n+\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation. Mostly for debugging / logging / testing.\n+     */\n+    [[nodiscard]] size_t NumFreeChunks() const noexcept\n+    {\n+        size_t length = 0;\n+        auto node = m_free_chunks;\n+        while (node) {\n+            node = static_cast<ChunkNode const*>(node)->next;\n+            ++length;\n+        }\n+        return length;\n+    }\n+\n+    /**\n+     * Number of memory blocks that have been allocated\n+     */\n+    [[nodiscard]] size_t NumBlocks() const noexcept\n+    {\n+        return m_allocated_blocks.size();\n+    }\n+\n+    /**\n+     * Calculates the required chunk size for the given type.\n+     * The memory block needs to be correctly aligned and large enough to hold both T and ChunkNode.\n+     */\n+    template <typename T>\n+    [[nodiscard]] static constexpr size_t CalcRequiredChunkSizeBytes() noexcept\n+    {\n+        const auto alignment_max = std::max(std::alignment_of_v<T>, std::alignment_of_v<ChunkNode>);\n+        const auto size_max = std::max(sizeof(T), sizeof(ChunkNode));\n+\n+        // find closest multiple of alignment_max that holds size_max\n+        return ((size_max + alignment_max - 1U) / alignment_max) * alignment_max;\n+    }\n+\n+private:\n+    /**\n+     * Allocate one full memory block which is used to carve out chunks.\n+     * The block size is the multiple of m_chunk_size_bytes that comes closest to BlockSizeBytes.\n+     */\n+    void AllocateNewBlock()\n+    {\n+        static_assert(sizeof(char) == 1U);\n+\n+        const auto num_chunks = BlockSizeBytes / m_chunk_size_bytes;\n+        m_untouched_memory_iterator = ::operator new(num_chunks* m_chunk_size_bytes);\n+        m_untouched_memory_end = static_cast<char*>(m_untouched_memory_iterator) + num_chunks * m_chunk_size_bytes;\n+        m_allocated_blocks.push_back(m_untouched_memory_iterator);\n+    }\n+\n+    /**\n+     * The MemoryResource's size for the memory chunks that it can give out.\n+     */\n+    size_t const m_chunk_size_bytes;\n+\n+    //! A contains all allocated blocks of memory, used to free the data in the destructor.\n+    std::vector<void*> m_allocated_blocks{};\n+\n+    //! A single linked list of all data available in the MemoryResource. This list is used for allocations of single elements.\n+    void* m_free_chunks = nullptr;\n+\n+    //! Points to the beginning of available memory for carving out chunks.\n+    void* m_untouched_memory_iterator = nullptr;\n+\n+    //! Points to the end of available memory for carving out chunks.\n+    void* m_untouched_memory_end = nullptr;\n+};\n+\n+\n+/**\n+ * Allocator that's usable for node-based containers like std::unordered_map or std::list.\n+ *\n+ * The allocator is stateful, and can be cheaply copied. Its state is an immobile MemoryResource, which\n+ * actually does all the allocation/deallocations. So this class is just a simple wrapper that conforms to the\n+ * required STL interface to be usable for the node-based containers.\n+ */\n+template <typename T>\n+class Allocator\n+{\n+    template <typename U>\n+    friend class Allocator;\n+\n+    template <typename X, typename Y>\n+    friend bool operator==(const Allocator<X>& a, const Allocator<Y>& b) noexcept;\n+\n+public:\n+    using value_type = T;\n+\n+    /**\n+     * The allocator is stateful so we can't use the compile time `is_always_equal` optimization and have to use the runtime operator==.\n+     */\n+    using is_always_equal = std::false_type;\n+\n+    /**\n+     * Move assignment should be a fast operation. In the case of a = std::move(b), we want\n+     * a to be able to use b's allocator, otherwise all elements would have to be recreated with a's old allocator.\n+     */\n+    using propagate_on_container_move_assignment = std::true_type;\n+\n+    /**\n+     * Swapping two containers with unequal allocators who are *not* propagated is undefined\n+     * behavior. Unfortunately this is the default! Obviously, we don't want that.\n+     */\n+    using propagate_on_container_swap = std::true_type; // to avoid the undefined behavior\n+\n+    /**\n+     * Move and swap have to propagate the allocator, so for consistency we do the same for copy assignment.\n+     */\n+    using propagate_on_container_copy_assignment = std::true_type;\n+\n+    /**\n+     * Construct a new Allocator object which will delegate all allocations/deallocations to the memory resource.\n+     */\n+    explicit Allocator(MemoryResource* memory_resource) noexcept\n+        : m_memory_resource(memory_resource)\n+    {\n+    }\n+\n+    /**\n+     * Conversion constructor for rebinding. All Allocators use the same memory_resource.",
    "path": "src/support/allocators/node_allocator.h",
    "position": null,
    "original_position": 321,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "952c37a31c39b7acdb5ab2634a354a1c548708a2",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "The C++ API for allocators is a bit stupid, it actually happens all the time. No allocation actually ever happens with the `std::pair<const Key, Value>` type, the container's rebind to the internal node type, possibly to some control structure, and for unordered_map to the underlying array type. I'll add a comment",
    "created_at": "2021-10-24T17:15:03Z",
    "updated_at": "2021-10-26T08:33:51Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r735146196",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/735146196"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r735146196"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/735146196/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 303,
    "side": "RIGHT",
    "in_reply_to_id": 734849669
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/735147340",
    "pull_request_review_id": 779353334,
    "id": 735147340,
    "node_id": "PRRC_kwDOABII584r0XVM",
    "diff_hunk": "@@ -0,0 +1,425 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored in-place. This typically\n+ *   saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but there is no\n+ *   standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on proximity. So freeing\n+ *   and malloc'ing again can become a random access pattern which can lead to more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Currently it is only\n+ * able provide optimized alloc/free for a single fixed node size which is given in the constructor. Only allocations that match this\n+ * size will be provided from the preallocated blocks of memory; all other requests simply use ::operator new().\n+ * To get the correct node size in all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios in\n+ * `node_allocator_tests/test_chunks_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall \u201cHow to Write a Custom Allocator\u201d https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer \u201cAn Allocator is a Handle to a Heap\u201d https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *      https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block, or from a free list if it contains entries.\n+ *   Whenever a node is given back with Deallocate(), it is put into that free list.\n+ */\n+class MemoryResource\n+{\n+    //! Size in bytes to allocate per block, currently hardcoded to 256 KiB.\n+    static constexpr size_t BlockSizeBytes = 262144;\n+\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object that uses the specified chunk size to optimize for.\n+     */\n+    explicit MemoryResource(size_t chunk_size_bytes) : m_chunk_size_bytes(chunk_size_bytes) {}\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated blocks.\n+     *\n+     * There's no Clear() method on purpose, because it would be dangerous. E.g. when calling clear() on\n+     * an unordered_map, it is not certain that all allocated chunks are given back to the MemoryResource.\n+     * Microsoft's STL still uses a control structure that might have the same size as the nodes, and therefore\n+     * needs to be kept around until the map is actually destroyed.\n+     */\n+    ~MemoryResource() noexcept\n+    {\n+        for (auto* block : m_allocated_blocks) {\n+            ::operator delete(block);\n+        }\n+    }",
    "path": "src/support/allocators/node_allocator.h",
    "position": null,
    "original_position": 116,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "952c37a31c39b7acdb5ab2634a354a1c548708a2",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Right! I'll switch to using `std::unique_ptr<char[]>`.",
    "created_at": "2021-10-24T17:25:15Z",
    "updated_at": "2021-10-26T08:33:51Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r735147340",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/735147340"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r735147340"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/735147340/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": 103,
    "start_side": "RIGHT",
    "line": null,
    "original_line": 116,
    "side": "RIGHT",
    "in_reply_to_id": 734826521
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/735147664",
    "pull_request_review_id": 779353334,
    "id": 735147664,
    "node_id": "PRRC_kwDOABII584r0XaQ",
    "diff_hunk": "@@ -0,0 +1,425 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored in-place. This typically\n+ *   saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but there is no\n+ *   standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on proximity. So freeing\n+ *   and malloc'ing again can become a random access pattern which can lead to more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Currently it is only\n+ * able provide optimized alloc/free for a single fixed node size which is given in the constructor. Only allocations that match this\n+ * size will be provided from the preallocated blocks of memory; all other requests simply use ::operator new().\n+ * To get the correct node size in all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios in\n+ * `node_allocator_tests/test_chunks_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall \u201cHow to Write a Custom Allocator\u201d https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer \u201cAn Allocator is a Handle to a Heap\u201d https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *      https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block, or from a free list if it contains entries.\n+ *   Whenever a node is given back with Deallocate(), it is put into that free list.\n+ */\n+class MemoryResource\n+{\n+    //! Size in bytes to allocate per block, currently hardcoded to 256 KiB.\n+    static constexpr size_t BlockSizeBytes = 262144;\n+\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object that uses the specified chunk size to optimize for.\n+     */\n+    explicit MemoryResource(size_t chunk_size_bytes) : m_chunk_size_bytes(chunk_size_bytes) {}",
    "path": "src/support/allocators/node_allocator.h",
    "position": null,
    "original_position": 93,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "952c37a31c39b7acdb5ab2634a354a1c548708a2",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "I've tried to make it a template argument before, but couldn't get it to compile. But I've tried it again and figured it out now, the main issue that I missed is that the `Allocator` then needs to have a `struct rebind` for this to work. (this is described in a little footnote here: https://en.cppreference.com/w/cpp/named_req/Allocator#cite_note-2 The rebind is *not* optional because the second template argument will be a `size_t`, and not a template type)",
    "created_at": "2021-10-24T17:28:34Z",
    "updated_at": "2021-10-26T08:33:51Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r735147664",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/735147664"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r735147664"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/735147664/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 93,
    "side": "RIGHT",
    "in_reply_to_id": 734785167
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/735279551",
    "pull_request_review_id": 779353334,
    "id": 735279551,
    "node_id": "PRRC_kwDOABII584r03m_",
    "diff_hunk": "@@ -0,0 +1,425 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored in-place. This typically\n+ *   saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but there is no\n+ *   standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on proximity. So freeing\n+ *   and malloc'ing again can become a random access pattern which can lead to more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Currently it is only\n+ * able provide optimized alloc/free for a single fixed node size which is given in the constructor. Only allocations that match this\n+ * size will be provided from the preallocated blocks of memory; all other requests simply use ::operator new().\n+ * To get the correct node size in all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios in\n+ * `node_allocator_tests/test_chunks_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall \u201cHow to Write a Custom Allocator\u201d https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer \u201cAn Allocator is a Handle to a Heap\u201d https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *      https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block, or from a free list if it contains entries.\n+ *   Whenever a node is given back with Deallocate(), it is put into that free list.\n+ */\n+class MemoryResource\n+{\n+    //! Size in bytes to allocate per block, currently hardcoded to 256 KiB.\n+    static constexpr size_t BlockSizeBytes = 262144;\n+\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object that uses the specified chunk size to optimize for.\n+     */\n+    explicit MemoryResource(size_t chunk_size_bytes) : m_chunk_size_bytes(chunk_size_bytes) {}\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated blocks.\n+     *\n+     * There's no Clear() method on purpose, because it would be dangerous. E.g. when calling clear() on\n+     * an unordered_map, it is not certain that all allocated chunks are given back to the MemoryResource.\n+     * Microsoft's STL still uses a control structure that might have the same size as the nodes, and therefore\n+     * needs to be kept around until the map is actually destroyed.\n+     */\n+    ~MemoryResource() noexcept\n+    {\n+        for (auto* block : m_allocated_blocks) {\n+            ::operator delete(block);\n+        }\n+    }\n+\n+    /**\n+     * Allocates memory for n times T. Only when n==1 and T's size matches m_chunk_size_bytes\n+     * the chunking mechanism is used. Otherwise, the allocation is forwarded to ::operator new().\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes != required_chunk_size || n != 1) {\n+            // pool is not used so forward to operator new.\n+            return static_cast<T*>(::operator new(n * sizeof(T)));\n+        }\n+\n+        // chunk size is correct, so we can actually use the pool's block data\n+\n+        if (m_free_chunks) {\n+            // we've already got data in the free list, unlink one element\n+            auto old_head = m_free_chunks;\n+            m_free_chunks = static_cast<ChunkNode*>(m_free_chunks)->next;\n+            return static_cast<T*>(old_head);\n+        }\n+\n+        // free list is empty: get one chunk from allocated block memory.\n+        // It makes sense to not create the fully linked list of an allocated block up-front, for several reasons.\n+        // On the one hand, the latency is higher when we need to iterate and update pointers for the whole block at once.\n+        // More importantly, most systems lazily allocate data. So when we allocate a big block of memory the memory for a page\n+        // is only actually made available to the program when it is first touched. So when we allocate a big block and only use\n+        // very little memory from it, the total memory usage is lower than what has been malloc'ed.\n+        if (m_untouched_memory_iterator == m_untouched_memory_end) {\n+            // slow path, only happens when a new block needs to be allocated\n+            AllocateNewBlock();\n+        }\n+\n+        // peel off one chunk from the untouched memory. The next pointer of in-use elements doesn't matter until it is\n+        // deallocated, only then it is used to form the free list.\n+        const auto tmp = m_untouched_memory_iterator;\n+        m_untouched_memory_iterator = static_cast<char*>(tmp) + m_chunk_size_bytes;\n+        return static_cast<T*>(tmp);\n+    }\n+\n+    /**\n+     * Puts p back into the free list f it was actually allocated from the memory block.\n+     * Otherwise, simply call ::operator delete(p).\n+     */\n+    template <typename T>\n+    void Deallocate(void* p, size_t n) noexcept\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size_bytes = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes == required_chunk_size_bytes && n == 1) {\n+            // put it into the linked list\n+            const auto node = static_cast<ChunkNode*>(p);\n+            node->next = m_free_chunks;\n+            m_free_chunks = node;\n+        } else {\n+            // allocation didn't happen with the pool\n+            ::operator delete(p);\n+        }\n+    }\n+\n+    /**\n+     * Actual size in bytes that is used for one chunk (node allocation)\n+     */\n+    [[nodiscard]] size_t ChunkSizeBytes() const noexcept\n+    {\n+        return m_chunk_size_bytes;\n+    }\n+\n+    /**\n+     * Calculates bytes allocated by the memory resource.\n+     */\n+    [[nodiscard]] size_t DynamicMemoryUsage() const noexcept\n+    {\n+        const size_t alloc_size{(BlockSizeBytes / m_chunk_size_bytes) * m_chunk_size_bytes};\n+        return memusage::MallocUsage(alloc_size) * m_allocated_blocks.size() + memusage::DynamicUsage(m_allocated_blocks);\n+    }\n+\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation. Mostly for debugging / logging / testing.\n+     */\n+    [[nodiscard]] size_t NumFreeChunks() const noexcept\n+    {\n+        size_t length = 0;\n+        auto node = m_free_chunks;\n+        while (node) {\n+            node = static_cast<ChunkNode const*>(node)->next;\n+            ++length;\n+        }\n+        return length;\n+    }\n+\n+    /**\n+     * Number of memory blocks that have been allocated\n+     */\n+    [[nodiscard]] size_t NumBlocks() const noexcept\n+    {\n+        return m_allocated_blocks.size();\n+    }\n+\n+    /**\n+     * Calculates the required chunk size for the given type.\n+     * The memory block needs to be correctly aligned and large enough to hold both T and ChunkNode.\n+     */\n+    template <typename T>\n+    [[nodiscard]] static constexpr size_t CalcRequiredChunkSizeBytes() noexcept\n+    {\n+        const auto alignment_max = std::max(std::alignment_of_v<T>, std::alignment_of_v<ChunkNode>);\n+        const auto size_max = std::max(sizeof(T), sizeof(ChunkNode));\n+\n+        // find closest multiple of alignment_max that holds size_max\n+        return ((size_max + alignment_max - 1U) / alignment_max) * alignment_max;\n+    }\n+\n+private:\n+    /**\n+     * Allocate one full memory block which is used to carve out chunks.\n+     * The block size is the multiple of m_chunk_size_bytes that comes closest to BlockSizeBytes.\n+     */\n+    void AllocateNewBlock()\n+    {\n+        static_assert(sizeof(char) == 1U);\n+\n+        const auto num_chunks = BlockSizeBytes / m_chunk_size_bytes;\n+        m_untouched_memory_iterator = ::operator new(num_chunks* m_chunk_size_bytes);\n+        m_untouched_memory_end = static_cast<char*>(m_untouched_memory_iterator) + num_chunks * m_chunk_size_bytes;\n+        m_allocated_blocks.push_back(m_untouched_memory_iterator);\n+    }\n+\n+    /**\n+     * The MemoryResource's size for the memory chunks that it can give out.\n+     */\n+    size_t const m_chunk_size_bytes;\n+\n+    //! A contains all allocated blocks of memory, used to free the data in the destructor.\n+    std::vector<void*> m_allocated_blocks{};\n+\n+    //! A single linked list of all data available in the MemoryResource. This list is used for allocations of single elements.\n+    void* m_free_chunks = nullptr;\n+\n+    //! Points to the beginning of available memory for carving out chunks.\n+    void* m_untouched_memory_iterator = nullptr;\n+\n+    //! Points to the end of available memory for carving out chunks.\n+    void* m_untouched_memory_end = nullptr;\n+};\n+\n+\n+/**\n+ * Allocator that's usable for node-based containers like std::unordered_map or std::list.\n+ *\n+ * The allocator is stateful, and can be cheaply copied. Its state is an immobile MemoryResource, which\n+ * actually does all the allocation/deallocations. So this class is just a simple wrapper that conforms to the\n+ * required STL interface to be usable for the node-based containers.\n+ */\n+template <typename T>\n+class Allocator\n+{\n+    template <typename U>\n+    friend class Allocator;\n+\n+    template <typename X, typename Y>\n+    friend bool operator==(const Allocator<X>& a, const Allocator<Y>& b) noexcept;\n+\n+public:\n+    using value_type = T;\n+\n+    /**\n+     * The allocator is stateful so we can't use the compile time `is_always_equal` optimization and have to use the runtime operator==.\n+     */\n+    using is_always_equal = std::false_type;\n+\n+    /**\n+     * Move assignment should be a fast operation. In the case of a = std::move(b), we want\n+     * a to be able to use b's allocator, otherwise all elements would have to be recreated with a's old allocator.\n+     */\n+    using propagate_on_container_move_assignment = std::true_type;\n+\n+    /**\n+     * Swapping two containers with unequal allocators who are *not* propagated is undefined\n+     * behavior. Unfortunately this is the default! Obviously, we don't want that.\n+     */\n+    using propagate_on_container_swap = std::true_type; // to avoid the undefined behavior\n+\n+    /**\n+     * Move and swap have to propagate the allocator, so for consistency we do the same for copy assignment.\n+     */\n+    using propagate_on_container_copy_assignment = std::true_type;\n+\n+    /**\n+     * Construct a new Allocator object which will delegate all allocations/deallocations to the memory resource.\n+     */\n+    explicit Allocator(MemoryResource* memory_resource) noexcept\n+        : m_memory_resource(memory_resource)\n+    {\n+    }\n+\n+    /**\n+     * Conversion constructor for rebinding. All Allocators use the same memory_resource.\n+     */\n+    template <typename U>\n+    Allocator(const Allocator<U>& other) noexcept\n+        : m_memory_resource(other.m_memory_resource)\n+    {\n+    }\n+\n+    /**\n+     * Allocates n entries of the given type.\n+     */\n+    T* allocate(size_t n)\n+    {\n+        // Forward all allocations to the memory_resource\n+        return m_memory_resource->Allocate<T>(n);\n+    }\n+\n+\n+    /**\n+     * Deallocates n entries of the given type.\n+     */\n+    void deallocate(T* p, size_t n)\n+    {\n+        m_memory_resource->Deallocate<T>(p, n);\n+    }\n+\n+private:\n+    //! Stateful allocator, where the state is a simple pointer that can be cheaply copied.\n+    MemoryResource* m_memory_resource;\n+};\n+\n+\n+/**\n+ * Since Allocator is stateful, comparison with another one only returns true if it uses the same memory_resource.\n+ */\n+template <typename T, typename U>\n+bool operator==(const Allocator<T>& a, const Allocator<U>& b) noexcept\n+{\n+    // \"Equality of an allocator is determined through the ability of allocating memory with one\n+    // allocator and deallocating it with another.\" - Jonathan M\u00fcller\n+    // See https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+    //\n+    // For us that is the case when both allocators use the same memory resource.\n+    return a.m_memory_resource == b.m_memory_resource;\n+}\n+\n+template <typename T, typename U>\n+bool operator!=(const Allocator<T>& a, const Allocator<U>& b) noexcept\n+{\n+    return !(a == b);\n+}\n+\n+/**\n+ * Helper to create std::unordered_map which uses the node_allocator.\n+ *\n+ * This calculates the size of the container's internally used node correctly for all supported platforms,\n+ * which is also asserted by the unit tests.\n+ */\n+template <typename Key, typename Value, typename Hash = std::hash<Key>, typename Equals = std::equal_to<Key>>\n+class UnorderedMapFactory\n+{\n+public:\n+    using AllocatorType = Allocator<std::pair<const Key, Value>>;\n+    using ContainerType = std::unordered_map<Key, Value, Hash, Equals, AllocatorType>;\n+    static constexpr size_t NodeSizeBytes = memusage::NodeSize<ContainerType>::Value();\n+\n+    /**\n+     * Create the MemoryResource with correctly calculated ChunkSize.\n+     */\n+    [[nodiscard]] static MemoryResource CreateMemoryResource()\n+    {\n+        return MemoryResource{NodeSizeBytes};\n+    }\n+\n+    /**\n+     * Creates the std::unordered_map container, and asserts that the specified memory_resource is correct.\n+     */\n+    [[nodiscard]] static ContainerType CreateContainer(MemoryResource* memory_resource)\n+    {\n+        assert(memory_resource != nullptr && memory_resource->ChunkSizeBytes() == NodeSizeBytes);\n+        return ContainerType{0, Hash{}, Equals{}, AllocatorType{memory_resource}};\n+    }\n+\n+    /**\n+     * Constructs MemoryResource in the uninitialized storage pointed to by ptr.\n+     */\n+    static void Construct(MemoryResource* ptr)\n+    {\n+        assert(ptr != nullptr);\n+        ::new ((void*)ptr) MemoryResource{NodeSizeBytes};\n+    }\n+\n+    /**\n+     * Constructs the container in the uninitialized storage pointed to by ptr, using the given memory_resource as parameter.\n+     */\n+    static void Construct(ContainerType* ptr, MemoryResource* memory_resource)\n+    {\n+        assert(ptr != nullptr && memory_resource != nullptr && memory_resource->ChunkSizeBytes() == NodeSizeBytes);\n+        ::new ((void*)ptr) ContainerType{0, Hash{}, Equals{}, AllocatorType{memory_resource}};\n+    }\n+};",
    "path": "src/support/allocators/node_allocator.h",
    "position": null,
    "original_position": 421,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "952c37a31c39b7acdb5ab2634a354a1c548708a2",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Good idea, I didn't think about writing it that way",
    "created_at": "2021-10-25T06:04:47Z",
    "updated_at": "2021-10-26T08:33:52Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r735279551",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/735279551"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r735279551"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/735279551/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": 404,
    "start_side": "RIGHT",
    "line": null,
    "original_line": 422,
    "side": "RIGHT",
    "in_reply_to_id": 734854608
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/735298577",
    "pull_request_review_id": 779353334,
    "id": 735298577,
    "node_id": "PRRC_kwDOABII584r08QR",
    "diff_hunk": "@@ -0,0 +1,425 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored in-place. This typically\n+ *   saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but there is no\n+ *   standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on proximity. So freeing\n+ *   and malloc'ing again can become a random access pattern which can lead to more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Currently it is only\n+ * able provide optimized alloc/free for a single fixed node size which is given in the constructor. Only allocations that match this\n+ * size will be provided from the preallocated blocks of memory; all other requests simply use ::operator new().\n+ * To get the correct node size in all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios in\n+ * `node_allocator_tests/test_chunks_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall \u201cHow to Write a Custom Allocator\u201d https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer \u201cAn Allocator is a Handle to a Heap\u201d https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *      https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block, or from a free list if it contains entries.\n+ *   Whenever a node is given back with Deallocate(), it is put into that free list.\n+ */\n+class MemoryResource\n+{\n+    //! Size in bytes to allocate per block, currently hardcoded to 256 KiB.\n+    static constexpr size_t BlockSizeBytes = 262144;\n+\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object that uses the specified chunk size to optimize for.\n+     */\n+    explicit MemoryResource(size_t chunk_size_bytes) : m_chunk_size_bytes(chunk_size_bytes) {}\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated blocks.\n+     *\n+     * There's no Clear() method on purpose, because it would be dangerous. E.g. when calling clear() on\n+     * an unordered_map, it is not certain that all allocated chunks are given back to the MemoryResource.\n+     * Microsoft's STL still uses a control structure that might have the same size as the nodes, and therefore\n+     * needs to be kept around until the map is actually destroyed.\n+     */\n+    ~MemoryResource() noexcept\n+    {\n+        for (auto* block : m_allocated_blocks) {\n+            ::operator delete(block);\n+        }\n+    }\n+\n+    /**\n+     * Allocates memory for n times T. Only when n==1 and T's size matches m_chunk_size_bytes\n+     * the chunking mechanism is used. Otherwise, the allocation is forwarded to ::operator new().\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes != required_chunk_size || n != 1) {\n+            // pool is not used so forward to operator new.\n+            return static_cast<T*>(::operator new(n * sizeof(T)));\n+        }\n+\n+        // chunk size is correct, so we can actually use the pool's block data\n+\n+        if (m_free_chunks) {\n+            // we've already got data in the free list, unlink one element\n+            auto old_head = m_free_chunks;\n+            m_free_chunks = static_cast<ChunkNode*>(m_free_chunks)->next;\n+            return static_cast<T*>(old_head);\n+        }\n+\n+        // free list is empty: get one chunk from allocated block memory.\n+        // It makes sense to not create the fully linked list of an allocated block up-front, for several reasons.\n+        // On the one hand, the latency is higher when we need to iterate and update pointers for the whole block at once.\n+        // More importantly, most systems lazily allocate data. So when we allocate a big block of memory the memory for a page\n+        // is only actually made available to the program when it is first touched. So when we allocate a big block and only use\n+        // very little memory from it, the total memory usage is lower than what has been malloc'ed.\n+        if (m_untouched_memory_iterator == m_untouched_memory_end) {\n+            // slow path, only happens when a new block needs to be allocated\n+            AllocateNewBlock();\n+        }\n+\n+        // peel off one chunk from the untouched memory. The next pointer of in-use elements doesn't matter until it is\n+        // deallocated, only then it is used to form the free list.\n+        const auto tmp = m_untouched_memory_iterator;\n+        m_untouched_memory_iterator = static_cast<char*>(tmp) + m_chunk_size_bytes;\n+        return static_cast<T*>(tmp);\n+    }\n+\n+    /**\n+     * Puts p back into the free list f it was actually allocated from the memory block.\n+     * Otherwise, simply call ::operator delete(p).\n+     */\n+    template <typename T>\n+    void Deallocate(void* p, size_t n) noexcept\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size_bytes = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes == required_chunk_size_bytes && n == 1) {\n+            // put it into the linked list\n+            const auto node = static_cast<ChunkNode*>(p);\n+            node->next = m_free_chunks;\n+            m_free_chunks = node;\n+        } else {\n+            // allocation didn't happen with the pool\n+            ::operator delete(p);\n+        }\n+    }\n+\n+    /**\n+     * Actual size in bytes that is used for one chunk (node allocation)\n+     */\n+    [[nodiscard]] size_t ChunkSizeBytes() const noexcept\n+    {\n+        return m_chunk_size_bytes;\n+    }\n+\n+    /**\n+     * Calculates bytes allocated by the memory resource.\n+     */\n+    [[nodiscard]] size_t DynamicMemoryUsage() const noexcept\n+    {\n+        const size_t alloc_size{(BlockSizeBytes / m_chunk_size_bytes) * m_chunk_size_bytes};\n+        return memusage::MallocUsage(alloc_size) * m_allocated_blocks.size() + memusage::DynamicUsage(m_allocated_blocks);\n+    }\n+\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation. Mostly for debugging / logging / testing.\n+     */\n+    [[nodiscard]] size_t NumFreeChunks() const noexcept\n+    {\n+        size_t length = 0;\n+        auto node = m_free_chunks;\n+        while (node) {\n+            node = static_cast<ChunkNode const*>(node)->next;\n+            ++length;\n+        }\n+        return length;\n+    }\n+\n+    /**\n+     * Number of memory blocks that have been allocated\n+     */\n+    [[nodiscard]] size_t NumBlocks() const noexcept\n+    {\n+        return m_allocated_blocks.size();\n+    }\n+\n+    /**\n+     * Calculates the required chunk size for the given type.\n+     * The memory block needs to be correctly aligned and large enough to hold both T and ChunkNode.\n+     */\n+    template <typename T>\n+    [[nodiscard]] static constexpr size_t CalcRequiredChunkSizeBytes() noexcept\n+    {\n+        const auto alignment_max = std::max(std::alignment_of_v<T>, std::alignment_of_v<ChunkNode>);",
    "path": "src/support/allocators/node_allocator.h",
    "position": null,
    "original_position": 230,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "952c37a31c39b7acdb5ab2634a354a1c548708a2",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "I prefer to keep the alignment here, as far as I remember some systems can produce very slow code when using memcpy without the alignment requirement. It shouldn't matter for x86 though. I'll add a comment",
    "created_at": "2021-10-25T06:45:04Z",
    "updated_at": "2021-10-26T08:33:51Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r735298577",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/735298577"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r735298577"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/735298577/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 230,
    "side": "RIGHT",
    "in_reply_to_id": 734678036
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736176745",
    "pull_request_review_id": 779353334,
    "id": 736176745,
    "node_id": "PRRC_kwDOABII584r4Spp",
    "diff_hunk": "@@ -0,0 +1,425 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored in-place. This typically\n+ *   saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but there is no\n+ *   standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on proximity. So freeing\n+ *   and malloc'ing again can become a random access pattern which can lead to more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Currently it is only\n+ * able provide optimized alloc/free for a single fixed node size which is given in the constructor. Only allocations that match this\n+ * size will be provided from the preallocated blocks of memory; all other requests simply use ::operator new().\n+ * To get the correct node size in all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios in\n+ * `node_allocator_tests/test_chunks_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall \u201cHow to Write a Custom Allocator\u201d https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer \u201cAn Allocator is a Handle to a Heap\u201d https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *      https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block, or from a free list if it contains entries.\n+ *   Whenever a node is given back with Deallocate(), it is put into that free list.\n+ */\n+class MemoryResource\n+{\n+    //! Size in bytes to allocate per block, currently hardcoded to 256 KiB.\n+    static constexpr size_t BlockSizeBytes = 262144;",
    "path": "src/support/allocators/node_allocator.h",
    "position": null,
    "original_position": 80,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "952c37a31c39b7acdb5ab2634a354a1c548708a2",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "When refactoring to use compile time `NODE_SIZE_BYTES` (renamed to `ALLOCATION_SIZE_BYTES`) I can now calculate the correct blocksize right here.",
    "created_at": "2021-10-26T06:00:08Z",
    "updated_at": "2021-10-26T08:33:51Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r736176745",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736176745"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r736176745"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736176745/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 80,
    "side": "RIGHT",
    "in_reply_to_id": 734842535
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736177958",
    "pull_request_review_id": 779353334,
    "id": 736177958,
    "node_id": "PRRC_kwDOABII584r4S8m",
    "diff_hunk": "@@ -0,0 +1,425 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored in-place. This typically\n+ *   saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but there is no\n+ *   standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on proximity. So freeing\n+ *   and malloc'ing again can become a random access pattern which can lead to more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Currently it is only\n+ * able provide optimized alloc/free for a single fixed node size which is given in the constructor. Only allocations that match this\n+ * size will be provided from the preallocated blocks of memory; all other requests simply use ::operator new().\n+ * To get the correct node size in all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios in\n+ * `node_allocator_tests/test_chunks_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall \u201cHow to Write a Custom Allocator\u201d https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer \u201cAn Allocator is a Handle to a Heap\u201d https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *      https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block, or from a free list if it contains entries.\n+ *   Whenever a node is given back with Deallocate(), it is put into that free list.\n+ */\n+class MemoryResource\n+{\n+    //! Size in bytes to allocate per block, currently hardcoded to 256 KiB.\n+    static constexpr size_t BlockSizeBytes = 262144;\n+\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {",
    "path": "src/support/allocators/node_allocator.h",
    "position": null,
    "original_position": 86,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "952c37a31c39b7acdb5ab2634a354a1c548708a2",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "I also wasn't really sure what terms to use. I'll try to clean that up.",
    "created_at": "2021-10-26T06:02:44Z",
    "updated_at": "2021-10-26T08:33:51Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r736177958",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736177958"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r736177958"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736177958/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 86,
    "side": "RIGHT",
    "in_reply_to_id": 734663213
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736178494",
    "pull_request_review_id": 779353334,
    "id": 736178494,
    "node_id": "PRRC_kwDOABII584r4TE-",
    "diff_hunk": "@@ -0,0 +1,425 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored in-place. This typically\n+ *   saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but there is no\n+ *   standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on proximity. So freeing\n+ *   and malloc'ing again can become a random access pattern which can lead to more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Currently it is only\n+ * able provide optimized alloc/free for a single fixed node size which is given in the constructor. Only allocations that match this\n+ * size will be provided from the preallocated blocks of memory; all other requests simply use ::operator new().\n+ * To get the correct node size in all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios in\n+ * `node_allocator_tests/test_chunks_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall \u201cHow to Write a Custom Allocator\u201d https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer \u201cAn Allocator is a Handle to a Heap\u201d https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *      https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block, or from a free list if it contains entries.\n+ *   Whenever a node is given back with Deallocate(), it is put into that free list.\n+ */\n+class MemoryResource\n+{\n+    //! Size in bytes to allocate per block, currently hardcoded to 256 KiB.\n+    static constexpr size_t BlockSizeBytes = 262144;\n+\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object that uses the specified chunk size to optimize for.\n+     */\n+    explicit MemoryResource(size_t chunk_size_bytes) : m_chunk_size_bytes(chunk_size_bytes) {}\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated blocks.\n+     *\n+     * There's no Clear() method on purpose, because it would be dangerous. E.g. when calling clear() on\n+     * an unordered_map, it is not certain that all allocated chunks are given back to the MemoryResource.\n+     * Microsoft's STL still uses a control structure that might have the same size as the nodes, and therefore\n+     * needs to be kept around until the map is actually destroyed.\n+     */\n+    ~MemoryResource() noexcept\n+    {\n+        for (auto* block : m_allocated_blocks) {\n+            ::operator delete(block);\n+        }\n+    }\n+\n+    /**\n+     * Allocates memory for n times T. Only when n==1 and T's size matches m_chunk_size_bytes\n+     * the chunking mechanism is used. Otherwise, the allocation is forwarded to ::operator new().\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes != required_chunk_size || n != 1) {\n+            // pool is not used so forward to operator new.\n+            return static_cast<T*>(::operator new(n * sizeof(T)));\n+        }\n+\n+        // chunk size is correct, so we can actually use the pool's block data\n+\n+        if (m_free_chunks) {\n+            // we've already got data in the free list, unlink one element\n+            auto old_head = m_free_chunks;\n+            m_free_chunks = static_cast<ChunkNode*>(m_free_chunks)->next;\n+            return static_cast<T*>(old_head);\n+        }\n+\n+        // free list is empty: get one chunk from allocated block memory.\n+        // It makes sense to not create the fully linked list of an allocated block up-front, for several reasons.\n+        // On the one hand, the latency is higher when we need to iterate and update pointers for the whole block at once.\n+        // More importantly, most systems lazily allocate data. So when we allocate a big block of memory the memory for a page\n+        // is only actually made available to the program when it is first touched. So when we allocate a big block and only use\n+        // very little memory from it, the total memory usage is lower than what has been malloc'ed.\n+        if (m_untouched_memory_iterator == m_untouched_memory_end) {\n+            // slow path, only happens when a new block needs to be allocated\n+            AllocateNewBlock();\n+        }\n+\n+        // peel off one chunk from the untouched memory. The next pointer of in-use elements doesn't matter until it is\n+        // deallocated, only then it is used to form the free list.\n+        const auto tmp = m_untouched_memory_iterator;\n+        m_untouched_memory_iterator = static_cast<char*>(tmp) + m_chunk_size_bytes;\n+        return static_cast<T*>(tmp);\n+    }\n+\n+    /**\n+     * Puts p back into the free list f it was actually allocated from the memory block.\n+     * Otherwise, simply call ::operator delete(p).\n+     */\n+    template <typename T>\n+    void Deallocate(void* p, size_t n) noexcept\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size_bytes = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes == required_chunk_size_bytes && n == 1) {\n+            // put it into the linked list\n+            const auto node = static_cast<ChunkNode*>(p);\n+            node->next = m_free_chunks;\n+            m_free_chunks = node;\n+        } else {\n+            // allocation didn't happen with the pool\n+            ::operator delete(p);\n+        }\n+    }\n+\n+    /**\n+     * Actual size in bytes that is used for one chunk (node allocation)\n+     */\n+    [[nodiscard]] size_t ChunkSizeBytes() const noexcept\n+    {\n+        return m_chunk_size_bytes;\n+    }\n+\n+    /**\n+     * Calculates bytes allocated by the memory resource.\n+     */\n+    [[nodiscard]] size_t DynamicMemoryUsage() const noexcept\n+    {\n+        const size_t alloc_size{(BlockSizeBytes / m_chunk_size_bytes) * m_chunk_size_bytes};\n+        return memusage::MallocUsage(alloc_size) * m_allocated_blocks.size() + memusage::DynamicUsage(m_allocated_blocks);\n+    }\n+\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation. Mostly for debugging / logging / testing.\n+     */\n+    [[nodiscard]] size_t NumFreeChunks() const noexcept",
    "path": "src/support/allocators/node_allocator.h",
    "position": null,
    "original_position": 204,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "952c37a31c39b7acdb5ab2634a354a1c548708a2",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "That's a good idea, then I can move `NumFreeChunks` and `NumBlocks` to the test class because it shouldn't be needed anywhere else",
    "created_at": "2021-10-26T06:03:57Z",
    "updated_at": "2021-10-26T08:33:51Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r736178494",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736178494"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r736178494"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736178494/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 204,
    "side": "RIGHT",
    "in_reply_to_id": 734831606
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736298809",
    "pull_request_review_id": 789052548,
    "id": 736298809,
    "node_id": "PRRC_kwDOABII584r4wc5",
    "diff_hunk": "@@ -0,0 +1,399 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <cstddef>\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no control structure is required for each node memory; the free list is stored in-place. This typically saves\n+ *   about 8 bytes per node.\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements. So freeing and malloc'ing again\n+ *   can have an advantageous access pattern which leads to less cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator` compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Since there is\n+ * unfortunately no way to determine the size of nodes that we want to optimize for in advance, MemoryResource uses\n+ * a simple heuristic: We assume the first call to Allocate with 1 element is for the node, and upon that first call the\n+ * MemoryResource is configured to use that as its chunk size. Note that due to this heuristic we cannot implement a\n+ * `std::pmr::memory_resource` because it does not give the information about the number of elements.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall \u201cHow to Write a Custom Allocator\u201d https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer \u201cAn Allocator is a Handle to a Heap\u201d https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *     https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block. Whenever a node is given back\n+ *   with Deallocate(), it is put into a free list.\n+ */\n+class MemoryResource\n+{\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object that uses the specified block size for allocations.\n+     * Actually the real block size can be a bit smaller, it will be the largest multiple of chunk size\n+     * that fits into the block.\n+     */\n+    explicit MemoryResource(size_t block_size_byte) : m_block_size_bytes(block_size_byte) {}\n+\n+    MemoryResource() = default;\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated blocks.\n+     */\n+    ~MemoryResource() noexcept\n+    {\n+        Clear();\n+    }\n+\n+    /**\n+     * Clears all allocated blocks.\n+     *\n+     * Memory is freed regardless if its still in use, so use with care! E.g. only after a call to clear() to the underlying container.\n+     */\n+    void Clear()\n+    {\n+        for (auto* block : m_allocated_blocks) {\n+            ::operator delete(block);\n+        }\n+        m_free_chunks = nullptr;\n+        m_allocated_blocks.clear();\n+        m_chunk_size_bytes = 0U;\n+        m_untouched_memory_iterator = nullptr;\n+        m_untouched_memory_end = nullptr;\n+    }\n+\n+    /**\n+     * Allocates memory for n times T. Only when n==1 the memory blocks are used to give out memory. The first call with n==1\n+     * decides the chunk size.\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size = CalcRequiredChunkSizeBytes<T>();\n+\n+        // only use pool when a single element is allocated\n+        if (m_chunk_size_bytes == 0 && n == 1) {\n+            // first call to Allocate with n==1 determines chunk size\n+            m_chunk_size_bytes = required_chunk_size;\n+        }\n+\n+        if (m_chunk_size_bytes != required_chunk_size || n != 1) {\n+            // pool is not used so forward to operator new.\n+            return static_cast<T*>(::operator new(n * sizeof(T)));\n+        }\n+\n+        // chunk size is correct, so we can actually use the pool's block data\n+\n+        if (m_free_chunks) {\n+            // we've already got data in the free list, unlink one element\n+            auto old_head = m_free_chunks;\n+            m_free_chunks = static_cast<ChunkNode*>(m_free_chunks)->next;\n+            return static_cast<T*>(old_head);\n+        }\n+\n+        // free list is empty: get one chunk from allocated block memory.\n+        // It makes sense to not create the fully linked list of an allocated block up front, for several reasons\n+        // On the one hand, the latency is higher when we need to iterate and update pointers for the whole block at once.\n+        // More importantly, most systems lazily allocate data. So when we allocate a big block of memory the memory for a page\n+        // is only actually made available to the program when it is first touched. So when we allocate a big block and only use\n+        // very little memory from it, the total memory usage is lower than what has been malloc'ed.\n+        if (m_untouched_memory_iterator == m_untouched_memory_end) {\n+            // slow path, only happens when a new block needs to be allocated\n+            AllocateNewBlock();\n+        }\n+\n+        // peel off one chunk from the untouched memory\n+        auto tmp = m_untouched_memory_iterator;\n+        m_untouched_memory_iterator = static_cast<char*>(tmp) + m_chunk_size_bytes;\n+        return static_cast<T*>(tmp);\n+    }\n+\n+    /**\n+     * Puts p back into the free list f it was actually allocated from the memory block.\n+     */\n+    template <typename T>\n+    void Deallocate(void* p, std::size_t n) noexcept\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size_bytes = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes == required_chunk_size_bytes && n == 1) {\n+            // put it into the linked list\n+            auto node = static_cast<ChunkNode*>(p);\n+            node->next = m_free_chunks;\n+            m_free_chunks = node;\n+        } else {\n+            // allocation didn't happen with the pool\n+            ::operator delete(p);\n+        }\n+    }\n+\n+    /**\n+     * Actual size in bytes that is used for one chunk (node allocation)\n+     */\n+    [[nodiscard]] size_t ChunkSize() const noexcept\n+    {\n+        return m_chunk_size_bytes;\n+    }\n+\n+    /**\n+     * Calculates bytes allocated by the memory resource.\n+     */\n+    [[nodiscard]] size_t DynamicMemoryUsage() const noexcept\n+    {\n+        if (m_chunk_size_bytes == 0) {\n+            return 0;\n+        }\n+        size_t alloc_size = (m_block_size_bytes / m_chunk_size_bytes) * m_chunk_size_bytes;\n+        return memusage::MallocUsage(alloc_size) * m_allocated_blocks.size() + memusage::DynamicUsage(m_allocated_blocks);\n+    }\n+\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation. Mostly for debugging / logging / testing.\n+     */\n+    [[nodiscard]] size_t NumFreeChunks() const noexcept\n+    {\n+        size_t length = 0;\n+        auto node = m_free_chunks;\n+        while (node) {\n+            node = static_cast<ChunkNode const*>(node)->next;\n+            ++length;\n+        }\n+        return length;\n+    }\n+\n+    /**\n+     * Number of memory blocks that have been allocated\n+     */\n+    [[nodiscard]] size_t NumBlocks() const noexcept\n+    {\n+        return m_allocated_blocks.size();\n+    }\n+\n+    /**\n+     * Calculates the required chunk size for the given type.\n+     * The memory block needs to be correctly aligned and large enough to hold both T and ChunkNode.\n+     */\n+    template <typename T>\n+    [[nodiscard]] static constexpr size_t CalcRequiredChunkSizeBytes() noexcept\n+    {\n+        auto alignment_max = std::max(std::alignment_of_v<T>, std::alignment_of_v<ChunkNode>);\n+        auto size_max = std::max(sizeof(T), sizeof(ChunkNode));\n+\n+        // find closest multiple of alignment_max that holds size_max\n+        return ((size_max + alignment_max - 1U) / alignment_max) * alignment_max;\n+    }\n+\n+private:\n+    /**\n+     * Allocate one full memory block which is used to carve out chunks.\n+     * The block size is the multiple of m_chunk_size_bytes that comes closest to m_block_size_bytes.\n+     */\n+    void AllocateNewBlock()\n+    {\n+        static_assert(sizeof(char) == 1U);\n+\n+        auto const num_chunks = m_block_size_bytes / m_chunk_size_bytes;\n+        m_untouched_memory_iterator = ::operator new(num_chunks* m_chunk_size_bytes);\n+        m_untouched_memory_end = static_cast<char*>(m_untouched_memory_iterator) + num_chunks * m_chunk_size_bytes;\n+        m_allocated_blocks.push_back(m_untouched_memory_iterator);\n+    }\n+\n+    //! A single linked list of all data available in the pool. This list is used for allocations of single elements.\n+    void* m_free_chunks = nullptr;\n+\n+    //! A contains all allocated blocks of memory, used to free the data in the destructor.",
    "path": "src/support/allocators/node_allocator.h",
    "position": null,
    "original_position": 267,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "6fa1a72e7dd9ff1e99c6e2ad0531619d119045f9",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "fixed in 89c62017f2a099de5353579b08f79037805ca70f",
    "created_at": "2021-10-26T08:46:35Z",
    "updated_at": "2021-10-26T08:46:36Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r736298809",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736298809"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r736298809"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736298809/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 257,
    "side": "RIGHT",
    "in_reply_to_id": 693215356
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736299928",
    "pull_request_review_id": 789054076,
    "id": 736299928,
    "node_id": "PRRC_kwDOABII584r4wuY",
    "diff_hunk": "@@ -0,0 +1,425 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored in-place. This typically\n+ *   saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but there is no\n+ *   standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on proximity. So freeing\n+ *   and malloc'ing again can become a random access pattern which can lead to more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Currently it is only\n+ * able provide optimized alloc/free for a single fixed node size which is given in the constructor. Only allocations that match this\n+ * size will be provided from the preallocated blocks of memory; all other requests simply use ::operator new().\n+ * To get the correct node size in all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios in\n+ * `node_allocator_tests/test_chunks_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall \u201cHow to Write a Custom Allocator\u201d https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer \u201cAn Allocator is a Handle to a Heap\u201d https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *      https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block, or from a free list if it contains entries.\n+ *   Whenever a node is given back with Deallocate(), it is put into that free list.\n+ */\n+class MemoryResource\n+{\n+    //! Size in bytes to allocate per block, currently hardcoded to 256 KiB.\n+    static constexpr size_t BlockSizeBytes = 262144;\n+\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object that uses the specified chunk size to optimize for.\n+     */\n+    explicit MemoryResource(size_t chunk_size_bytes) : m_chunk_size_bytes(chunk_size_bytes) {}\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated blocks.\n+     *\n+     * There's no Clear() method on purpose, because it would be dangerous. E.g. when calling clear() on\n+     * an unordered_map, it is not certain that all allocated chunks are given back to the MemoryResource.\n+     * Microsoft's STL still uses a control structure that might have the same size as the nodes, and therefore\n+     * needs to be kept around until the map is actually destroyed.\n+     */\n+    ~MemoryResource() noexcept\n+    {\n+        for (auto* block : m_allocated_blocks) {\n+            ::operator delete(block);\n+        }\n+    }",
    "path": "src/support/allocators/node_allocator.h",
    "position": null,
    "original_position": 116,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "952c37a31c39b7acdb5ab2634a354a1c548708a2",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done in 89c62017f2a099de5353579b08f79037805ca70f",
    "created_at": "2021-10-26T08:47:48Z",
    "updated_at": "2021-10-26T08:47:48Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r736299928",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736299928"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r736299928"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736299928/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": 103,
    "start_side": "RIGHT",
    "line": null,
    "original_line": 116,
    "side": "RIGHT",
    "in_reply_to_id": 734826521
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736300228",
    "pull_request_review_id": 789054455,
    "id": 736300228,
    "node_id": "PRRC_kwDOABII584r4wzE",
    "diff_hunk": "@@ -0,0 +1,425 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored in-place. This typically\n+ *   saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but there is no\n+ *   standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on proximity. So freeing\n+ *   and malloc'ing again can become a random access pattern which can lead to more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Currently it is only\n+ * able provide optimized alloc/free for a single fixed node size which is given in the constructor. Only allocations that match this\n+ * size will be provided from the preallocated blocks of memory; all other requests simply use ::operator new().\n+ * To get the correct node size in all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios in\n+ * `node_allocator_tests/test_chunks_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall \u201cHow to Write a Custom Allocator\u201d https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer \u201cAn Allocator is a Handle to a Heap\u201d https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *      https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block, or from a free list if it contains entries.\n+ *   Whenever a node is given back with Deallocate(), it is put into that free list.\n+ */\n+class MemoryResource\n+{\n+    //! Size in bytes to allocate per block, currently hardcoded to 256 KiB.\n+    static constexpr size_t BlockSizeBytes = 262144;\n+\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object that uses the specified chunk size to optimize for.\n+     */\n+    explicit MemoryResource(size_t chunk_size_bytes) : m_chunk_size_bytes(chunk_size_bytes) {}",
    "path": "src/support/allocators/node_allocator.h",
    "position": null,
    "original_position": 93,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "952c37a31c39b7acdb5ab2634a354a1c548708a2",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "done in 89c62017f2a099de5353579b08f79037805ca70f",
    "created_at": "2021-10-26T08:48:06Z",
    "updated_at": "2021-10-26T08:48:06Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r736300228",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736300228"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r736300228"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736300228/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 93,
    "side": "RIGHT",
    "in_reply_to_id": 734785167
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736300410",
    "pull_request_review_id": 789054714,
    "id": 736300410,
    "node_id": "PRRC_kwDOABII584r4w16",
    "diff_hunk": "@@ -0,0 +1,425 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored in-place. This typically\n+ *   saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but there is no\n+ *   standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on proximity. So freeing\n+ *   and malloc'ing again can become a random access pattern which can lead to more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Currently it is only\n+ * able provide optimized alloc/free for a single fixed node size which is given in the constructor. Only allocations that match this\n+ * size will be provided from the preallocated blocks of memory; all other requests simply use ::operator new().\n+ * To get the correct node size in all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios in\n+ * `node_allocator_tests/test_chunks_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall \u201cHow to Write a Custom Allocator\u201d https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer \u201cAn Allocator is a Handle to a Heap\u201d https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *      https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block, or from a free list if it contains entries.\n+ *   Whenever a node is given back with Deallocate(), it is put into that free list.\n+ */\n+class MemoryResource\n+{\n+    //! Size in bytes to allocate per block, currently hardcoded to 256 KiB.\n+    static constexpr size_t BlockSizeBytes = 262144;\n+\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object that uses the specified chunk size to optimize for.\n+     */\n+    explicit MemoryResource(size_t chunk_size_bytes) : m_chunk_size_bytes(chunk_size_bytes) {}\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated blocks.\n+     *\n+     * There's no Clear() method on purpose, because it would be dangerous. E.g. when calling clear() on\n+     * an unordered_map, it is not certain that all allocated chunks are given back to the MemoryResource.\n+     * Microsoft's STL still uses a control structure that might have the same size as the nodes, and therefore\n+     * needs to be kept around until the map is actually destroyed.\n+     */\n+    ~MemoryResource() noexcept\n+    {\n+        for (auto* block : m_allocated_blocks) {\n+            ::operator delete(block);\n+        }\n+    }\n+\n+    /**\n+     * Allocates memory for n times T. Only when n==1 and T's size matches m_chunk_size_bytes\n+     * the chunking mechanism is used. Otherwise, the allocation is forwarded to ::operator new().\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes != required_chunk_size || n != 1) {\n+            // pool is not used so forward to operator new.\n+            return static_cast<T*>(::operator new(n * sizeof(T)));\n+        }\n+\n+        // chunk size is correct, so we can actually use the pool's block data\n+\n+        if (m_free_chunks) {\n+            // we've already got data in the free list, unlink one element\n+            auto old_head = m_free_chunks;\n+            m_free_chunks = static_cast<ChunkNode*>(m_free_chunks)->next;\n+            return static_cast<T*>(old_head);\n+        }\n+\n+        // free list is empty: get one chunk from allocated block memory.\n+        // It makes sense to not create the fully linked list of an allocated block up-front, for several reasons.\n+        // On the one hand, the latency is higher when we need to iterate and update pointers for the whole block at once.\n+        // More importantly, most systems lazily allocate data. So when we allocate a big block of memory the memory for a page\n+        // is only actually made available to the program when it is first touched. So when we allocate a big block and only use\n+        // very little memory from it, the total memory usage is lower than what has been malloc'ed.\n+        if (m_untouched_memory_iterator == m_untouched_memory_end) {\n+            // slow path, only happens when a new block needs to be allocated\n+            AllocateNewBlock();\n+        }\n+\n+        // peel off one chunk from the untouched memory. The next pointer of in-use elements doesn't matter until it is\n+        // deallocated, only then it is used to form the free list.\n+        const auto tmp = m_untouched_memory_iterator;\n+        m_untouched_memory_iterator = static_cast<char*>(tmp) + m_chunk_size_bytes;\n+        return static_cast<T*>(tmp);\n+    }\n+\n+    /**\n+     * Puts p back into the free list f it was actually allocated from the memory block.\n+     * Otherwise, simply call ::operator delete(p).\n+     */\n+    template <typename T>\n+    void Deallocate(void* p, size_t n) noexcept\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size_bytes = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes == required_chunk_size_bytes && n == 1) {\n+            // put it into the linked list\n+            const auto node = static_cast<ChunkNode*>(p);\n+            node->next = m_free_chunks;\n+            m_free_chunks = node;\n+        } else {\n+            // allocation didn't happen with the pool\n+            ::operator delete(p);\n+        }\n+    }\n+\n+    /**\n+     * Actual size in bytes that is used for one chunk (node allocation)\n+     */\n+    [[nodiscard]] size_t ChunkSizeBytes() const noexcept\n+    {\n+        return m_chunk_size_bytes;\n+    }\n+\n+    /**\n+     * Calculates bytes allocated by the memory resource.\n+     */\n+    [[nodiscard]] size_t DynamicMemoryUsage() const noexcept\n+    {\n+        const size_t alloc_size{(BlockSizeBytes / m_chunk_size_bytes) * m_chunk_size_bytes};\n+        return memusage::MallocUsage(alloc_size) * m_allocated_blocks.size() + memusage::DynamicUsage(m_allocated_blocks);\n+    }\n+\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation. Mostly for debugging / logging / testing.\n+     */\n+    [[nodiscard]] size_t NumFreeChunks() const noexcept",
    "path": "src/support/allocators/node_allocator.h",
    "position": null,
    "original_position": 204,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "952c37a31c39b7acdb5ab2634a354a1c548708a2",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "done in 89c62017f2a099de5353579b08f79037805ca70f",
    "created_at": "2021-10-26T08:48:18Z",
    "updated_at": "2021-10-26T08:48:18Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r736300410",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736300410"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r736300410"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736300410/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 204,
    "side": "RIGHT",
    "in_reply_to_id": 734831606
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736300724",
    "pull_request_review_id": 789055038,
    "id": 736300724,
    "node_id": "PRRC_kwDOABII584r4w60",
    "diff_hunk": "@@ -0,0 +1,425 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored in-place. This typically\n+ *   saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but there is no\n+ *   standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on proximity. So freeing\n+ *   and malloc'ing again can become a random access pattern which can lead to more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Currently it is only\n+ * able provide optimized alloc/free for a single fixed node size which is given in the constructor. Only allocations that match this\n+ * size will be provided from the preallocated blocks of memory; all other requests simply use ::operator new().\n+ * To get the correct node size in all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios in\n+ * `node_allocator_tests/test_chunks_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall \u201cHow to Write a Custom Allocator\u201d https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer \u201cAn Allocator is a Handle to a Heap\u201d https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *      https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block, or from a free list if it contains entries.\n+ *   Whenever a node is given back with Deallocate(), it is put into that free list.\n+ */\n+class MemoryResource\n+{\n+    //! Size in bytes to allocate per block, currently hardcoded to 256 KiB.\n+    static constexpr size_t BlockSizeBytes = 262144;\n+\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object that uses the specified chunk size to optimize for.\n+     */\n+    explicit MemoryResource(size_t chunk_size_bytes) : m_chunk_size_bytes(chunk_size_bytes) {}\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated blocks.\n+     *\n+     * There's no Clear() method on purpose, because it would be dangerous. E.g. when calling clear() on\n+     * an unordered_map, it is not certain that all allocated chunks are given back to the MemoryResource.\n+     * Microsoft's STL still uses a control structure that might have the same size as the nodes, and therefore\n+     * needs to be kept around until the map is actually destroyed.\n+     */\n+    ~MemoryResource() noexcept\n+    {\n+        for (auto* block : m_allocated_blocks) {\n+            ::operator delete(block);\n+        }\n+    }\n+\n+    /**\n+     * Allocates memory for n times T. Only when n==1 and T's size matches m_chunk_size_bytes\n+     * the chunking mechanism is used. Otherwise, the allocation is forwarded to ::operator new().\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes != required_chunk_size || n != 1) {\n+            // pool is not used so forward to operator new.\n+            return static_cast<T*>(::operator new(n * sizeof(T)));\n+        }\n+\n+        // chunk size is correct, so we can actually use the pool's block data\n+\n+        if (m_free_chunks) {\n+            // we've already got data in the free list, unlink one element\n+            auto old_head = m_free_chunks;\n+            m_free_chunks = static_cast<ChunkNode*>(m_free_chunks)->next;\n+            return static_cast<T*>(old_head);\n+        }\n+\n+        // free list is empty: get one chunk from allocated block memory.\n+        // It makes sense to not create the fully linked list of an allocated block up-front, for several reasons.\n+        // On the one hand, the latency is higher when we need to iterate and update pointers for the whole block at once.\n+        // More importantly, most systems lazily allocate data. So when we allocate a big block of memory the memory for a page\n+        // is only actually made available to the program when it is first touched. So when we allocate a big block and only use\n+        // very little memory from it, the total memory usage is lower than what has been malloc'ed.\n+        if (m_untouched_memory_iterator == m_untouched_memory_end) {\n+            // slow path, only happens when a new block needs to be allocated\n+            AllocateNewBlock();\n+        }\n+\n+        // peel off one chunk from the untouched memory. The next pointer of in-use elements doesn't matter until it is\n+        // deallocated, only then it is used to form the free list.\n+        const auto tmp = m_untouched_memory_iterator;\n+        m_untouched_memory_iterator = static_cast<char*>(tmp) + m_chunk_size_bytes;\n+        return static_cast<T*>(tmp);\n+    }\n+\n+    /**\n+     * Puts p back into the free list f it was actually allocated from the memory block.\n+     * Otherwise, simply call ::operator delete(p).\n+     */\n+    template <typename T>\n+    void Deallocate(void* p, size_t n) noexcept\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size_bytes = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes == required_chunk_size_bytes && n == 1) {\n+            // put it into the linked list\n+            const auto node = static_cast<ChunkNode*>(p);\n+            node->next = m_free_chunks;\n+            m_free_chunks = node;\n+        } else {\n+            // allocation didn't happen with the pool\n+            ::operator delete(p);\n+        }\n+    }\n+\n+    /**\n+     * Actual size in bytes that is used for one chunk (node allocation)\n+     */\n+    [[nodiscard]] size_t ChunkSizeBytes() const noexcept\n+    {\n+        return m_chunk_size_bytes;\n+    }\n+\n+    /**\n+     * Calculates bytes allocated by the memory resource.\n+     */\n+    [[nodiscard]] size_t DynamicMemoryUsage() const noexcept\n+    {\n+        const size_t alloc_size{(BlockSizeBytes / m_chunk_size_bytes) * m_chunk_size_bytes};\n+        return memusage::MallocUsage(alloc_size) * m_allocated_blocks.size() + memusage::DynamicUsage(m_allocated_blocks);\n+    }\n+\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation. Mostly for debugging / logging / testing.\n+     */\n+    [[nodiscard]] size_t NumFreeChunks() const noexcept\n+    {\n+        size_t length = 0;\n+        auto node = m_free_chunks;\n+        while (node) {\n+            node = static_cast<ChunkNode const*>(node)->next;\n+            ++length;\n+        }\n+        return length;\n+    }\n+\n+    /**\n+     * Number of memory blocks that have been allocated\n+     */\n+    [[nodiscard]] size_t NumBlocks() const noexcept\n+    {\n+        return m_allocated_blocks.size();\n+    }\n+\n+    /**\n+     * Calculates the required chunk size for the given type.\n+     * The memory block needs to be correctly aligned and large enough to hold both T and ChunkNode.\n+     */\n+    template <typename T>\n+    [[nodiscard]] static constexpr size_t CalcRequiredChunkSizeBytes() noexcept\n+    {\n+        const auto alignment_max = std::max(std::alignment_of_v<T>, std::alignment_of_v<ChunkNode>);\n+        const auto size_max = std::max(sizeof(T), sizeof(ChunkNode));\n+\n+        // find closest multiple of alignment_max that holds size_max\n+        return ((size_max + alignment_max - 1U) / alignment_max) * alignment_max;\n+    }\n+\n+private:\n+    /**\n+     * Allocate one full memory block which is used to carve out chunks.\n+     * The block size is the multiple of m_chunk_size_bytes that comes closest to BlockSizeBytes.\n+     */\n+    void AllocateNewBlock()\n+    {\n+        static_assert(sizeof(char) == 1U);",
    "path": "src/support/allocators/node_allocator.h",
    "position": null,
    "original_position": 244,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "952c37a31c39b7acdb5ab2634a354a1c548708a2",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "done in 89c62017f2a099de5353579b08f79037805ca70f",
    "created_at": "2021-10-26T08:48:35Z",
    "updated_at": "2021-10-26T08:48:36Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r736300724",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736300724"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r736300724"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736300724/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 244,
    "side": "RIGHT",
    "in_reply_to_id": 734838852
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736300998",
    "pull_request_review_id": 789055353,
    "id": 736300998,
    "node_id": "PRRC_kwDOABII584r4w_G",
    "diff_hunk": "@@ -0,0 +1,425 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored in-place. This typically\n+ *   saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but there is no\n+ *   standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on proximity. So freeing\n+ *   and malloc'ing again can become a random access pattern which can lead to more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Currently it is only\n+ * able provide optimized alloc/free for a single fixed node size which is given in the constructor. Only allocations that match this\n+ * size will be provided from the preallocated blocks of memory; all other requests simply use ::operator new().\n+ * To get the correct node size in all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios in\n+ * `node_allocator_tests/test_chunks_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall \u201cHow to Write a Custom Allocator\u201d https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer \u201cAn Allocator is a Handle to a Heap\u201d https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *      https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block, or from a free list if it contains entries.\n+ *   Whenever a node is given back with Deallocate(), it is put into that free list.\n+ */\n+class MemoryResource\n+{\n+    //! Size in bytes to allocate per block, currently hardcoded to 256 KiB.\n+    static constexpr size_t BlockSizeBytes = 262144;",
    "path": "src/support/allocators/node_allocator.h",
    "position": null,
    "original_position": 80,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "952c37a31c39b7acdb5ab2634a354a1c548708a2",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "done in 89c62017f2a099de5353579b08f79037805ca70f",
    "created_at": "2021-10-26T08:48:51Z",
    "updated_at": "2021-10-26T08:48:51Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r736300998",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736300998"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r736300998"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736300998/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 80,
    "side": "RIGHT",
    "in_reply_to_id": 734842535
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736301223",
    "pull_request_review_id": 789055687,
    "id": 736301223,
    "node_id": "PRRC_kwDOABII584r4xCn",
    "diff_hunk": "@@ -0,0 +1,425 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored in-place. This typically\n+ *   saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but there is no\n+ *   standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on proximity. So freeing\n+ *   and malloc'ing again can become a random access pattern which can lead to more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Currently it is only\n+ * able provide optimized alloc/free for a single fixed node size which is given in the constructor. Only allocations that match this\n+ * size will be provided from the preallocated blocks of memory; all other requests simply use ::operator new().\n+ * To get the correct node size in all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.",
    "path": "src/support/allocators/node_allocator.h",
    "position": null,
    "original_position": 52,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "952c37a31c39b7acdb5ab2634a354a1c548708a2",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "reshuffled in 89c62017f2a099de5353579b08f79037805ca70f",
    "created_at": "2021-10-26T08:49:07Z",
    "updated_at": "2021-10-26T08:49:08Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r736301223",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736301223"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r736301223"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736301223/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": 51,
    "start_side": "RIGHT",
    "line": null,
    "original_line": 52,
    "side": "RIGHT",
    "in_reply_to_id": 734846594
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736301409",
    "pull_request_review_id": 789055899,
    "id": 736301409,
    "node_id": "PRRC_kwDOABII584r4xFh",
    "diff_hunk": "@@ -0,0 +1,425 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored in-place. This typically\n+ *   saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but there is no\n+ *   standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on proximity. So freeing\n+ *   and malloc'ing again can become a random access pattern which can lead to more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Currently it is only\n+ * able provide optimized alloc/free for a single fixed node size which is given in the constructor. Only allocations that match this\n+ * size will be provided from the preallocated blocks of memory; all other requests simply use ::operator new().\n+ * To get the correct node size in all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios in\n+ * `node_allocator_tests/test_chunks_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall \u201cHow to Write a Custom Allocator\u201d https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer \u201cAn Allocator is a Handle to a Heap\u201d https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *      https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block, or from a free list if it contains entries.\n+ *   Whenever a node is given back with Deallocate(), it is put into that free list.\n+ */\n+class MemoryResource\n+{\n+    //! Size in bytes to allocate per block, currently hardcoded to 256 KiB.\n+    static constexpr size_t BlockSizeBytes = 262144;\n+\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object that uses the specified chunk size to optimize for.\n+     */\n+    explicit MemoryResource(size_t chunk_size_bytes) : m_chunk_size_bytes(chunk_size_bytes) {}\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated blocks.\n+     *\n+     * There's no Clear() method on purpose, because it would be dangerous. E.g. when calling clear() on\n+     * an unordered_map, it is not certain that all allocated chunks are given back to the MemoryResource.\n+     * Microsoft's STL still uses a control structure that might have the same size as the nodes, and therefore\n+     * needs to be kept around until the map is actually destroyed.\n+     */\n+    ~MemoryResource() noexcept\n+    {\n+        for (auto* block : m_allocated_blocks) {\n+            ::operator delete(block);\n+        }\n+    }\n+\n+    /**\n+     * Allocates memory for n times T. Only when n==1 and T's size matches m_chunk_size_bytes\n+     * the chunking mechanism is used. Otherwise, the allocation is forwarded to ::operator new().\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes != required_chunk_size || n != 1) {\n+            // pool is not used so forward to operator new.\n+            return static_cast<T*>(::operator new(n * sizeof(T)));\n+        }\n+\n+        // chunk size is correct, so we can actually use the pool's block data\n+\n+        if (m_free_chunks) {\n+            // we've already got data in the free list, unlink one element\n+            auto old_head = m_free_chunks;\n+            m_free_chunks = static_cast<ChunkNode*>(m_free_chunks)->next;\n+            return static_cast<T*>(old_head);\n+        }\n+\n+        // free list is empty: get one chunk from allocated block memory.\n+        // It makes sense to not create the fully linked list of an allocated block up-front, for several reasons.\n+        // On the one hand, the latency is higher when we need to iterate and update pointers for the whole block at once.\n+        // More importantly, most systems lazily allocate data. So when we allocate a big block of memory the memory for a page\n+        // is only actually made available to the program when it is first touched. So when we allocate a big block and only use\n+        // very little memory from it, the total memory usage is lower than what has been malloc'ed.\n+        if (m_untouched_memory_iterator == m_untouched_memory_end) {\n+            // slow path, only happens when a new block needs to be allocated\n+            AllocateNewBlock();\n+        }\n+\n+        // peel off one chunk from the untouched memory. The next pointer of in-use elements doesn't matter until it is\n+        // deallocated, only then it is used to form the free list.\n+        const auto tmp = m_untouched_memory_iterator;\n+        m_untouched_memory_iterator = static_cast<char*>(tmp) + m_chunk_size_bytes;\n+        return static_cast<T*>(tmp);\n+    }\n+\n+    /**\n+     * Puts p back into the free list f it was actually allocated from the memory block.\n+     * Otherwise, simply call ::operator delete(p).\n+     */\n+    template <typename T>\n+    void Deallocate(void* p, size_t n) noexcept\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size_bytes = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes == required_chunk_size_bytes && n == 1) {\n+            // put it into the linked list\n+            const auto node = static_cast<ChunkNode*>(p);\n+            node->next = m_free_chunks;\n+            m_free_chunks = node;\n+        } else {\n+            // allocation didn't happen with the pool\n+            ::operator delete(p);\n+        }\n+    }\n+\n+    /**\n+     * Actual size in bytes that is used for one chunk (node allocation)\n+     */\n+    [[nodiscard]] size_t ChunkSizeBytes() const noexcept\n+    {\n+        return m_chunk_size_bytes;\n+    }\n+\n+    /**\n+     * Calculates bytes allocated by the memory resource.\n+     */\n+    [[nodiscard]] size_t DynamicMemoryUsage() const noexcept\n+    {\n+        const size_t alloc_size{(BlockSizeBytes / m_chunk_size_bytes) * m_chunk_size_bytes};\n+        return memusage::MallocUsage(alloc_size) * m_allocated_blocks.size() + memusage::DynamicUsage(m_allocated_blocks);\n+    }\n+\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation. Mostly for debugging / logging / testing.\n+     */\n+    [[nodiscard]] size_t NumFreeChunks() const noexcept\n+    {\n+        size_t length = 0;\n+        auto node = m_free_chunks;\n+        while (node) {\n+            node = static_cast<ChunkNode const*>(node)->next;\n+            ++length;\n+        }\n+        return length;\n+    }\n+\n+    /**\n+     * Number of memory blocks that have been allocated\n+     */\n+    [[nodiscard]] size_t NumBlocks() const noexcept\n+    {\n+        return m_allocated_blocks.size();\n+    }\n+\n+    /**\n+     * Calculates the required chunk size for the given type.\n+     * The memory block needs to be correctly aligned and large enough to hold both T and ChunkNode.\n+     */\n+    template <typename T>\n+    [[nodiscard]] static constexpr size_t CalcRequiredChunkSizeBytes() noexcept\n+    {\n+        const auto alignment_max = std::max(std::alignment_of_v<T>, std::alignment_of_v<ChunkNode>);\n+        const auto size_max = std::max(sizeof(T), sizeof(ChunkNode));\n+\n+        // find closest multiple of alignment_max that holds size_max\n+        return ((size_max + alignment_max - 1U) / alignment_max) * alignment_max;\n+    }\n+\n+private:\n+    /**\n+     * Allocate one full memory block which is used to carve out chunks.\n+     * The block size is the multiple of m_chunk_size_bytes that comes closest to BlockSizeBytes.\n+     */\n+    void AllocateNewBlock()\n+    {\n+        static_assert(sizeof(char) == 1U);\n+\n+        const auto num_chunks = BlockSizeBytes / m_chunk_size_bytes;\n+        m_untouched_memory_iterator = ::operator new(num_chunks* m_chunk_size_bytes);\n+        m_untouched_memory_end = static_cast<char*>(m_untouched_memory_iterator) + num_chunks * m_chunk_size_bytes;\n+        m_allocated_blocks.push_back(m_untouched_memory_iterator);\n+    }\n+\n+    /**\n+     * The MemoryResource's size for the memory chunks that it can give out.\n+     */\n+    size_t const m_chunk_size_bytes;\n+\n+    //! A contains all allocated blocks of memory, used to free the data in the destructor.\n+    std::vector<void*> m_allocated_blocks{};\n+\n+    //! A single linked list of all data available in the MemoryResource. This list is used for allocations of single elements.\n+    void* m_free_chunks = nullptr;\n+\n+    //! Points to the beginning of available memory for carving out chunks.\n+    void* m_untouched_memory_iterator = nullptr;\n+\n+    //! Points to the end of available memory for carving out chunks.\n+    void* m_untouched_memory_end = nullptr;\n+};\n+\n+\n+/**\n+ * Allocator that's usable for node-based containers like std::unordered_map or std::list.\n+ *\n+ * The allocator is stateful, and can be cheaply copied. Its state is an immobile MemoryResource, which\n+ * actually does all the allocation/deallocations. So this class is just a simple wrapper that conforms to the\n+ * required STL interface to be usable for the node-based containers.\n+ */\n+template <typename T>\n+class Allocator\n+{\n+    template <typename U>\n+    friend class Allocator;\n+\n+    template <typename X, typename Y>\n+    friend bool operator==(const Allocator<X>& a, const Allocator<Y>& b) noexcept;\n+\n+public:\n+    using value_type = T;\n+\n+    /**\n+     * The allocator is stateful so we can't use the compile time `is_always_equal` optimization and have to use the runtime operator==.\n+     */\n+    using is_always_equal = std::false_type;\n+\n+    /**\n+     * Move assignment should be a fast operation. In the case of a = std::move(b), we want\n+     * a to be able to use b's allocator, otherwise all elements would have to be recreated with a's old allocator.\n+     */\n+    using propagate_on_container_move_assignment = std::true_type;\n+\n+    /**\n+     * Swapping two containers with unequal allocators who are *not* propagated is undefined\n+     * behavior. Unfortunately this is the default! Obviously, we don't want that.\n+     */\n+    using propagate_on_container_swap = std::true_type; // to avoid the undefined behavior\n+\n+    /**\n+     * Move and swap have to propagate the allocator, so for consistency we do the same for copy assignment.\n+     */\n+    using propagate_on_container_copy_assignment = std::true_type;\n+\n+    /**\n+     * Construct a new Allocator object which will delegate all allocations/deallocations to the memory resource.\n+     */\n+    explicit Allocator(MemoryResource* memory_resource) noexcept\n+        : m_memory_resource(memory_resource)\n+    {\n+    }\n+\n+    /**\n+     * Conversion constructor for rebinding. All Allocators use the same memory_resource.",
    "path": "src/support/allocators/node_allocator.h",
    "position": null,
    "original_position": 321,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "952c37a31c39b7acdb5ab2634a354a1c548708a2",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "comment added in 89c62017f2a099de5353579b08f79037805ca70f",
    "created_at": "2021-10-26T08:49:18Z",
    "updated_at": "2021-10-26T08:49:18Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r736301409",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736301409"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r736301409"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736301409/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 303,
    "side": "RIGHT",
    "in_reply_to_id": 734849669
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736301727",
    "pull_request_review_id": 789056337,
    "id": 736301727,
    "node_id": "PRRC_kwDOABII584r4xKf",
    "diff_hunk": "@@ -0,0 +1,425 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored in-place. This typically\n+ *   saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but there is no\n+ *   standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on proximity. So freeing\n+ *   and malloc'ing again can become a random access pattern which can lead to more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Currently it is only\n+ * able provide optimized alloc/free for a single fixed node size which is given in the constructor. Only allocations that match this\n+ * size will be provided from the preallocated blocks of memory; all other requests simply use ::operator new().\n+ * To get the correct node size in all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios in\n+ * `node_allocator_tests/test_chunks_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall \u201cHow to Write a Custom Allocator\u201d https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer \u201cAn Allocator is a Handle to a Heap\u201d https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *      https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block, or from a free list if it contains entries.\n+ *   Whenever a node is given back with Deallocate(), it is put into that free list.\n+ */\n+class MemoryResource\n+{\n+    //! Size in bytes to allocate per block, currently hardcoded to 256 KiB.\n+    static constexpr size_t BlockSizeBytes = 262144;\n+\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object that uses the specified chunk size to optimize for.\n+     */\n+    explicit MemoryResource(size_t chunk_size_bytes) : m_chunk_size_bytes(chunk_size_bytes) {}\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated blocks.\n+     *\n+     * There's no Clear() method on purpose, because it would be dangerous. E.g. when calling clear() on\n+     * an unordered_map, it is not certain that all allocated chunks are given back to the MemoryResource.\n+     * Microsoft's STL still uses a control structure that might have the same size as the nodes, and therefore\n+     * needs to be kept around until the map is actually destroyed.\n+     */\n+    ~MemoryResource() noexcept\n+    {\n+        for (auto* block : m_allocated_blocks) {\n+            ::operator delete(block);\n+        }\n+    }\n+\n+    /**\n+     * Allocates memory for n times T. Only when n==1 and T's size matches m_chunk_size_bytes\n+     * the chunking mechanism is used. Otherwise, the allocation is forwarded to ::operator new().\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes != required_chunk_size || n != 1) {\n+            // pool is not used so forward to operator new.\n+            return static_cast<T*>(::operator new(n * sizeof(T)));\n+        }\n+\n+        // chunk size is correct, so we can actually use the pool's block data\n+\n+        if (m_free_chunks) {\n+            // we've already got data in the free list, unlink one element\n+            auto old_head = m_free_chunks;\n+            m_free_chunks = static_cast<ChunkNode*>(m_free_chunks)->next;\n+            return static_cast<T*>(old_head);\n+        }\n+\n+        // free list is empty: get one chunk from allocated block memory.\n+        // It makes sense to not create the fully linked list of an allocated block up-front, for several reasons.\n+        // On the one hand, the latency is higher when we need to iterate and update pointers for the whole block at once.\n+        // More importantly, most systems lazily allocate data. So when we allocate a big block of memory the memory for a page\n+        // is only actually made available to the program when it is first touched. So when we allocate a big block and only use\n+        // very little memory from it, the total memory usage is lower than what has been malloc'ed.\n+        if (m_untouched_memory_iterator == m_untouched_memory_end) {\n+            // slow path, only happens when a new block needs to be allocated\n+            AllocateNewBlock();\n+        }\n+\n+        // peel off one chunk from the untouched memory. The next pointer of in-use elements doesn't matter until it is\n+        // deallocated, only then it is used to form the free list.\n+        const auto tmp = m_untouched_memory_iterator;\n+        m_untouched_memory_iterator = static_cast<char*>(tmp) + m_chunk_size_bytes;\n+        return static_cast<T*>(tmp);\n+    }\n+\n+    /**\n+     * Puts p back into the free list f it was actually allocated from the memory block.\n+     * Otherwise, simply call ::operator delete(p).\n+     */\n+    template <typename T>\n+    void Deallocate(void* p, size_t n) noexcept\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size_bytes = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes == required_chunk_size_bytes && n == 1) {\n+            // put it into the linked list\n+            const auto node = static_cast<ChunkNode*>(p);\n+            node->next = m_free_chunks;\n+            m_free_chunks = node;\n+        } else {\n+            // allocation didn't happen with the pool\n+            ::operator delete(p);\n+        }\n+    }\n+\n+    /**\n+     * Actual size in bytes that is used for one chunk (node allocation)\n+     */\n+    [[nodiscard]] size_t ChunkSizeBytes() const noexcept\n+    {\n+        return m_chunk_size_bytes;\n+    }\n+\n+    /**\n+     * Calculates bytes allocated by the memory resource.\n+     */\n+    [[nodiscard]] size_t DynamicMemoryUsage() const noexcept\n+    {\n+        const size_t alloc_size{(BlockSizeBytes / m_chunk_size_bytes) * m_chunk_size_bytes};\n+        return memusage::MallocUsage(alloc_size) * m_allocated_blocks.size() + memusage::DynamicUsage(m_allocated_blocks);\n+    }\n+\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation. Mostly for debugging / logging / testing.\n+     */\n+    [[nodiscard]] size_t NumFreeChunks() const noexcept\n+    {\n+        size_t length = 0;\n+        auto node = m_free_chunks;\n+        while (node) {\n+            node = static_cast<ChunkNode const*>(node)->next;\n+            ++length;\n+        }\n+        return length;\n+    }\n+\n+    /**\n+     * Number of memory blocks that have been allocated\n+     */\n+    [[nodiscard]] size_t NumBlocks() const noexcept\n+    {\n+        return m_allocated_blocks.size();\n+    }\n+\n+    /**\n+     * Calculates the required chunk size for the given type.\n+     * The memory block needs to be correctly aligned and large enough to hold both T and ChunkNode.\n+     */\n+    template <typename T>\n+    [[nodiscard]] static constexpr size_t CalcRequiredChunkSizeBytes() noexcept\n+    {\n+        const auto alignment_max = std::max(std::alignment_of_v<T>, std::alignment_of_v<ChunkNode>);\n+        const auto size_max = std::max(sizeof(T), sizeof(ChunkNode));\n+\n+        // find closest multiple of alignment_max that holds size_max\n+        return ((size_max + alignment_max - 1U) / alignment_max) * alignment_max;\n+    }\n+\n+private:\n+    /**\n+     * Allocate one full memory block which is used to carve out chunks.\n+     * The block size is the multiple of m_chunk_size_bytes that comes closest to BlockSizeBytes.\n+     */\n+    void AllocateNewBlock()\n+    {\n+        static_assert(sizeof(char) == 1U);\n+\n+        const auto num_chunks = BlockSizeBytes / m_chunk_size_bytes;\n+        m_untouched_memory_iterator = ::operator new(num_chunks* m_chunk_size_bytes);\n+        m_untouched_memory_end = static_cast<char*>(m_untouched_memory_iterator) + num_chunks * m_chunk_size_bytes;\n+        m_allocated_blocks.push_back(m_untouched_memory_iterator);\n+    }\n+\n+    /**\n+     * The MemoryResource's size for the memory chunks that it can give out.\n+     */\n+    size_t const m_chunk_size_bytes;\n+\n+    //! A contains all allocated blocks of memory, used to free the data in the destructor.\n+    std::vector<void*> m_allocated_blocks{};\n+\n+    //! A single linked list of all data available in the MemoryResource. This list is used for allocations of single elements.\n+    void* m_free_chunks = nullptr;\n+\n+    //! Points to the beginning of available memory for carving out chunks.\n+    void* m_untouched_memory_iterator = nullptr;\n+\n+    //! Points to the end of available memory for carving out chunks.\n+    void* m_untouched_memory_end = nullptr;\n+};\n+\n+\n+/**\n+ * Allocator that's usable for node-based containers like std::unordered_map or std::list.\n+ *\n+ * The allocator is stateful, and can be cheaply copied. Its state is an immobile MemoryResource, which\n+ * actually does all the allocation/deallocations. So this class is just a simple wrapper that conforms to the\n+ * required STL interface to be usable for the node-based containers.\n+ */\n+template <typename T>\n+class Allocator\n+{\n+    template <typename U>\n+    friend class Allocator;\n+\n+    template <typename X, typename Y>\n+    friend bool operator==(const Allocator<X>& a, const Allocator<Y>& b) noexcept;\n+\n+public:\n+    using value_type = T;\n+\n+    /**\n+     * The allocator is stateful so we can't use the compile time `is_always_equal` optimization and have to use the runtime operator==.\n+     */\n+    using is_always_equal = std::false_type;\n+\n+    /**\n+     * Move assignment should be a fast operation. In the case of a = std::move(b), we want\n+     * a to be able to use b's allocator, otherwise all elements would have to be recreated with a's old allocator.\n+     */\n+    using propagate_on_container_move_assignment = std::true_type;\n+\n+    /**\n+     * Swapping two containers with unequal allocators who are *not* propagated is undefined\n+     * behavior. Unfortunately this is the default! Obviously, we don't want that.\n+     */\n+    using propagate_on_container_swap = std::true_type; // to avoid the undefined behavior\n+\n+    /**\n+     * Move and swap have to propagate the allocator, so for consistency we do the same for copy assignment.\n+     */\n+    using propagate_on_container_copy_assignment = std::true_type;\n+\n+    /**\n+     * Construct a new Allocator object which will delegate all allocations/deallocations to the memory resource.\n+     */\n+    explicit Allocator(MemoryResource* memory_resource) noexcept\n+        : m_memory_resource(memory_resource)\n+    {\n+    }\n+\n+    /**\n+     * Conversion constructor for rebinding. All Allocators use the same memory_resource.\n+     */\n+    template <typename U>\n+    Allocator(const Allocator<U>& other) noexcept\n+        : m_memory_resource(other.m_memory_resource)\n+    {\n+    }\n+\n+    /**\n+     * Allocates n entries of the given type.\n+     */\n+    T* allocate(size_t n)\n+    {\n+        // Forward all allocations to the memory_resource\n+        return m_memory_resource->Allocate<T>(n);\n+    }\n+\n+\n+    /**\n+     * Deallocates n entries of the given type.\n+     */\n+    void deallocate(T* p, size_t n)\n+    {\n+        m_memory_resource->Deallocate<T>(p, n);\n+    }\n+\n+private:\n+    //! Stateful allocator, where the state is a simple pointer that can be cheaply copied.\n+    MemoryResource* m_memory_resource;\n+};\n+\n+\n+/**\n+ * Since Allocator is stateful, comparison with another one only returns true if it uses the same memory_resource.\n+ */\n+template <typename T, typename U>\n+bool operator==(const Allocator<T>& a, const Allocator<U>& b) noexcept\n+{\n+    // \"Equality of an allocator is determined through the ability of allocating memory with one\n+    // allocator and deallocating it with another.\" - Jonathan M\u00fcller\n+    // See https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+    //\n+    // For us that is the case when both allocators use the same memory resource.\n+    return a.m_memory_resource == b.m_memory_resource;\n+}\n+\n+template <typename T, typename U>\n+bool operator!=(const Allocator<T>& a, const Allocator<U>& b) noexcept\n+{\n+    return !(a == b);\n+}\n+\n+/**\n+ * Helper to create std::unordered_map which uses the node_allocator.\n+ *\n+ * This calculates the size of the container's internally used node correctly for all supported platforms,\n+ * which is also asserted by the unit tests.\n+ */\n+template <typename Key, typename Value, typename Hash = std::hash<Key>, typename Equals = std::equal_to<Key>>\n+class UnorderedMapFactory\n+{\n+public:\n+    using AllocatorType = Allocator<std::pair<const Key, Value>>;\n+    using ContainerType = std::unordered_map<Key, Value, Hash, Equals, AllocatorType>;\n+    static constexpr size_t NodeSizeBytes = memusage::NodeSize<ContainerType>::Value();\n+\n+    /**\n+     * Create the MemoryResource with correctly calculated ChunkSize.\n+     */\n+    [[nodiscard]] static MemoryResource CreateMemoryResource()\n+    {\n+        return MemoryResource{NodeSizeBytes};\n+    }\n+\n+    /**\n+     * Creates the std::unordered_map container, and asserts that the specified memory_resource is correct.\n+     */\n+    [[nodiscard]] static ContainerType CreateContainer(MemoryResource* memory_resource)\n+    {\n+        assert(memory_resource != nullptr && memory_resource->ChunkSizeBytes() == NodeSizeBytes);\n+        return ContainerType{0, Hash{}, Equals{}, AllocatorType{memory_resource}};\n+    }\n+\n+    /**\n+     * Constructs MemoryResource in the uninitialized storage pointed to by ptr.\n+     */\n+    static void Construct(MemoryResource* ptr)\n+    {\n+        assert(ptr != nullptr);\n+        ::new ((void*)ptr) MemoryResource{NodeSizeBytes};\n+    }\n+\n+    /**\n+     * Constructs the container in the uninitialized storage pointed to by ptr, using the given memory_resource as parameter.\n+     */\n+    static void Construct(ContainerType* ptr, MemoryResource* memory_resource)\n+    {\n+        assert(ptr != nullptr && memory_resource != nullptr && memory_resource->ChunkSizeBytes() == NodeSizeBytes);\n+        ::new ((void*)ptr) ContainerType{0, Hash{}, Equals{}, AllocatorType{memory_resource}};\n+    }\n+};",
    "path": "src/support/allocators/node_allocator.h",
    "position": null,
    "original_position": 421,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "952c37a31c39b7acdb5ab2634a354a1c548708a2",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "done in 89c62017f2a099de5353579b08f79037805ca70f",
    "created_at": "2021-10-26T08:49:39Z",
    "updated_at": "2021-10-26T08:49:39Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r736301727",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736301727"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r736301727"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736301727/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": 404,
    "start_side": "RIGHT",
    "line": null,
    "original_line": 422,
    "side": "RIGHT",
    "in_reply_to_id": 734854608
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736304047",
    "pull_request_review_id": 789059441,
    "id": 736304047,
    "node_id": "PRRC_kwDOABII584r4xuv",
    "diff_hunk": "@@ -222,6 +222,7 @@ bool CCoinsViewCache::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlockIn\n bool CCoinsViewCache::Flush() {\n     bool fOk = base->BatchWrite(cacheCoins, hashBlock);\n     cacheCoins.clear();\n+    ReallocateCache();",
    "path": "src/coins.cpp",
    "position": 17,
    "original_position": 17,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "952c37a31c39b7acdb5ab2634a354a1c548708a2",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done that in a separate commit in 1e4a65b21c70ee745a8ae02c3af109f4f5e16422",
    "created_at": "2021-10-26T08:52:12Z",
    "updated_at": "2021-10-26T08:52:12Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r736304047",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736304047"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r736304047"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736304047/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 225,
    "original_line": 225,
    "side": "RIGHT",
    "in_reply_to_id": 734858608
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736401678",
    "pull_request_review_id": 789190496,
    "id": 736401678,
    "node_id": "PRRC_kwDOABII584r5JkO",
    "diff_hunk": "@@ -148,23 +154,61 @@ static inline size_t DynamicUsage(const std::shared_ptr<X>& p)\n     return p ? MallocUsage(sizeof(X)) + MallocUsage(sizeof(stl_shared_counter)) : 0;\n }\n \n-template<typename X>\n-struct unordered_node : private X\n-{\n-private:\n-    void* ptr;\n+template <typename T>\n+struct NodeSize {\n+};\n+\n+template <typename Key, typename V, typename Hash, typename Equals, typename Allocator>\n+struct NodeSize<std::unordered_map<Key, V, Hash, Equals, Allocator>> {",
    "path": "src/memusage.h",
    "position": null,
    "original_position": 27,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "952c37a31c39b7acdb5ab2634a354a1c548708a2",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Added in a91b603 ",
    "created_at": "2021-10-26T10:51:22Z",
    "updated_at": "2021-10-26T10:51:22Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r736401678",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736401678"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r736401678"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736401678/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 165,
    "side": "RIGHT",
    "in_reply_to_id": 734861053
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736869134",
    "pull_request_review_id": 789848072,
    "id": 736869134,
    "node_id": "PRRC_kwDOABII584r67sO",
    "diff_hunk": "@@ -148,23 +154,65 @@ static inline size_t DynamicUsage(const std::shared_ptr<X>& p)\n     return p ? MallocUsage(sizeof(X)) + MallocUsage(sizeof(stl_shared_counter)) : 0;\n }\n \n-template<typename X>\n-struct unordered_node : private X\n-{\n-private:\n-    void* ptr;\n+template <typename T>\n+struct NodeSize {\n+};\n+\n+// It is important that the calculation here matches exactly the behavior of std::unordered_map\n+// so the node_allocator actually works. This is tested in node_allocator_tests/test_allocations_are_used\n+// with multiple configurations (alignments, noexcept hash, node sizes).\n+template <typename Key, typename V, typename Hash, typename Equals, typename Allocator>\n+struct NodeSize<std::unordered_map<Key, V, Hash, Equals, Allocator>> {\n+    [[nodiscard]] static constexpr size_t Value()\n+    {\n+        // libstdc++, libc++, and MSVC implement the nodes differently. To get the correct size\n+        // with the correct alignment, we can simulate that with accordingly nested std::pairs.\n+        using ValueType = std::pair<const Key, V>;\n+\n+#if defined(_MSC_VER)\n+        // list node contains 2 pointers and no hash; see\n+        // https://github.com/microsoft/STL/blob/main/stl/inc/unordered_map and\n+        // https://github.com/microsoft/STL/blob/main/stl/inc/list\n+        return sizeof(std::pair<std::pair<void*, void*>, ValueType>);\n+#else\n+\n+#if defined(_LIBCPP_VERSION) // defined in any C++ header from libc++\n+        // libc++ always stores hash and pointer in the node\n+        // see https://github.com/llvm/llvm-project/blob/release/13.x/libcxx/include/__hash_table#L92\n+        return sizeof(std::pair<ValueType, std::pair<size_t, void*>>);\n+#else\n+        // libstdc++ doesn't store hash when its operator() is noexcept;\n+        // see hashtable_policy.h, struct _Hash_node\n+        // https://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a05689.html\n+        if (noexcept(std::declval<Hash>()(std::declval<const Key&>()))) {\n+            return sizeof(std::pair<void*, ValueType>);\n+        } else {\n+            // hash is stored along ValueType, and that is wrapped with the pointer.\n+            return sizeof(std::pair<void*, std::pair<ValueType, size_t>>);\n+        }\n+#endif\n+#endif\n+    }\n };\n \n template<typename X, typename Y>\n static inline size_t DynamicUsage(const std::unordered_set<X, Y>& s)\n {\n-    return MallocUsage(sizeof(unordered_node<X>)) * s.size() + MallocUsage(sizeof(void*) * s.bucket_count());\n+    return MallocUsage(sizeof(std::pair<X, void*>)) * s.size() + MallocUsage(sizeof(void*) * s.bucket_count());",
    "path": "src/memusage.h",
    "position": null,
    "original_position": 67,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "a91b6032f037ab1a26ac4baa761e809fbfeb1bdd",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "To confirm, replacing `unordered_node<X>` with `std::pair<X, void*>` is just a simplification for consistent style, not a change in behavior?\r\n\r\n(Version: a91b6032f037ab1a26ac4baa761e809fbfeb1bdd)",
    "created_at": "2021-10-26T19:51:22Z",
    "updated_at": "2021-10-27T17:37:19Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r736869134",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736869134"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r736869134"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736869134/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 199,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736984281",
    "pull_request_review_id": 789848072,
    "id": 736984281,
    "node_id": "PRRC_kwDOABII584r7XzZ",
    "diff_hunk": "@@ -0,0 +1,52 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <bench/bench.h>\n+#include <coins.h>\n+#include <memusage.h>\n+#include <support/allocators/node_allocator.h>\n+\n+#include <cstring>\n+#include <iostream>\n+#include <unordered_map>\n+\n+template <typename Map>\n+void BenchFillClearMap(benchmark::Bench& bench, Map& map)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(1);\n+    tx.vin[0].scriptSig = CScript() << OP_2;\n+    tx.vin[0].scriptWitness.stack.push_back({2});\n+    tx.vout.resize(1);\n+    tx.vout[0].scriptPubKey = CScript() << OP_2 << OP_EQUAL;\n+    tx.vout[0].nValue = 10 * COIN;",
    "path": "src/bench/node_allocator.cpp",
    "position": null,
    "original_position": 23,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "a91b6032f037ab1a26ac4baa761e809fbfeb1bdd",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Filling this fake transaction just to throw it all away and call `tx.GetHash`  seems unnecessarily complicated. Could just construct the outpoint with any uint256 instead of a real transaction hash\r\n\r\n(Version: a91b6032f037ab1a26ac4baa761e809fbfeb1bdd)",
    "created_at": "2021-10-26T23:02:51Z",
    "updated_at": "2021-10-27T17:37:20Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r736984281",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736984281"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r736984281"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736984281/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": 17,
    "start_side": "RIGHT",
    "line": null,
    "original_line": 23,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736987229",
    "pull_request_review_id": 789848072,
    "id": 736987229,
    "node_id": "PRRC_kwDOABII584r7Yhd",
    "diff_hunk": "@@ -148,23 +154,65 @@ static inline size_t DynamicUsage(const std::shared_ptr<X>& p)\n     return p ? MallocUsage(sizeof(X)) + MallocUsage(sizeof(stl_shared_counter)) : 0;\n }\n \n-template<typename X>\n-struct unordered_node : private X\n-{\n-private:\n-    void* ptr;\n+template <typename T>\n+struct NodeSize {\n+};\n+\n+// It is important that the calculation here matches exactly the behavior of std::unordered_map\n+// so the node_allocator actually works. This is tested in node_allocator_tests/test_allocations_are_used\n+// with multiple configurations (alignments, noexcept hash, node sizes).\n+template <typename Key, typename V, typename Hash, typename Equals, typename Allocator>\n+struct NodeSize<std::unordered_map<Key, V, Hash, Equals, Allocator>> {\n+    [[nodiscard]] static constexpr size_t Value()\n+    {\n+        // libstdc++, libc++, and MSVC implement the nodes differently. To get the correct size\n+        // with the correct alignment, we can simulate that with accordingly nested std::pairs.\n+        using ValueType = std::pair<const Key, V>;\n+\n+#if defined(_MSC_VER)\n+        // list node contains 2 pointers and no hash; see\n+        // https://github.com/microsoft/STL/blob/main/stl/inc/unordered_map and\n+        // https://github.com/microsoft/STL/blob/main/stl/inc/list\n+        return sizeof(std::pair<std::pair<void*, void*>, ValueType>);\n+#else\n+\n+#if defined(_LIBCPP_VERSION) // defined in any C++ header from libc++\n+        // libc++ always stores hash and pointer in the node\n+        // see https://github.com/llvm/llvm-project/blob/release/13.x/libcxx/include/__hash_table#L92\n+        return sizeof(std::pair<ValueType, std::pair<size_t, void*>>);\n+#else\n+        // libstdc++ doesn't store hash when its operator() is noexcept;\n+        // see hashtable_policy.h, struct _Hash_node\n+        // https://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a05689.html\n+        if (noexcept(std::declval<Hash>()(std::declval<const Key&>()))) {\n+            return sizeof(std::pair<void*, ValueType>);\n+        } else {\n+            // hash is stored along ValueType, and that is wrapped with the pointer.\n+            return sizeof(std::pair<void*, std::pair<ValueType, size_t>>);\n+        }\n+#endif\n+#endif\n+    }\n };\n \n template<typename X, typename Y>\n static inline size_t DynamicUsage(const std::unordered_set<X, Y>& s)\n {\n-    return MallocUsage(sizeof(unordered_node<X>)) * s.size() + MallocUsage(sizeof(void*) * s.bucket_count());\n+    return MallocUsage(sizeof(std::pair<X, void*>)) * s.size() + MallocUsage(sizeof(void*) * s.bucket_count());\n }\n \n-template<typename X, typename Y, typename Z>\n-static inline size_t DynamicUsage(const std::unordered_map<X, Y, Z>& m)\n+template <typename Key, typename Value, typename Hash, typename Equals, typename Alloc>\n+static inline size_t DynamicUsage(const std::unordered_map<Key, Value, Hash, Equals, Alloc>& m)\n {\n-    return MallocUsage(sizeof(unordered_node<std::pair<const X, Y> >)) * m.size() + MallocUsage(sizeof(void*) * m.bucket_count());\n+    using ContainerType = std::unordered_map<Key, Value, Hash, Equals, Alloc>;\n+    if constexpr (std::is_same_v<Alloc, node_allocator::Allocator<std::pair<const Key, Value>, memusage::NodeSize<ContainerType>::Value()>>) {",
    "path": "src/memusage.h",
    "position": null,
    "original_position": 77,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "a91b6032f037ab1a26ac4baa761e809fbfeb1bdd",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Would be good to replace `std::pair<const Key, Value>` with `ContainerType::value_type` to make this more obvious.\r\n\r\n(Version: a91b6032f037ab1a26ac4baa761e809fbfeb1bdd)",
    "created_at": "2021-10-26T23:10:05Z",
    "updated_at": "2021-10-27T17:37:20Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r736987229",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736987229"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r736987229"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736987229/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 208,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736991419",
    "pull_request_review_id": 789848072,
    "id": 736991419,
    "node_id": "PRRC_kwDOABII584r7Zi7",
    "diff_hunk": "@@ -148,23 +154,65 @@ static inline size_t DynamicUsage(const std::shared_ptr<X>& p)\n     return p ? MallocUsage(sizeof(X)) + MallocUsage(sizeof(stl_shared_counter)) : 0;\n }\n \n-template<typename X>\n-struct unordered_node : private X\n-{\n-private:\n-    void* ptr;\n+template <typename T>\n+struct NodeSize {\n+};\n+\n+// It is important that the calculation here matches exactly the behavior of std::unordered_map\n+// so the node_allocator actually works. This is tested in node_allocator_tests/test_allocations_are_used\n+// with multiple configurations (alignments, noexcept hash, node sizes).\n+template <typename Key, typename V, typename Hash, typename Equals, typename Allocator>\n+struct NodeSize<std::unordered_map<Key, V, Hash, Equals, Allocator>> {\n+    [[nodiscard]] static constexpr size_t Value()\n+    {\n+        // libstdc++, libc++, and MSVC implement the nodes differently. To get the correct size\n+        // with the correct alignment, we can simulate that with accordingly nested std::pairs.\n+        using ValueType = std::pair<const Key, V>;\n+\n+#if defined(_MSC_VER)\n+        // list node contains 2 pointers and no hash; see\n+        // https://github.com/microsoft/STL/blob/main/stl/inc/unordered_map and\n+        // https://github.com/microsoft/STL/blob/main/stl/inc/list\n+        return sizeof(std::pair<std::pair<void*, void*>, ValueType>);\n+#else\n+\n+#if defined(_LIBCPP_VERSION) // defined in any C++ header from libc++\n+        // libc++ always stores hash and pointer in the node\n+        // see https://github.com/llvm/llvm-project/blob/release/13.x/libcxx/include/__hash_table#L92\n+        return sizeof(std::pair<ValueType, std::pair<size_t, void*>>);\n+#else\n+        // libstdc++ doesn't store hash when its operator() is noexcept;\n+        // see hashtable_policy.h, struct _Hash_node\n+        // https://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a05689.html\n+        if (noexcept(std::declval<Hash>()(std::declval<const Key&>()))) {\n+            return sizeof(std::pair<void*, ValueType>);\n+        } else {\n+            // hash is stored along ValueType, and that is wrapped with the pointer.\n+            return sizeof(std::pair<void*, std::pair<ValueType, size_t>>);\n+        }\n+#endif\n+#endif\n+    }\n };\n \n template<typename X, typename Y>\n static inline size_t DynamicUsage(const std::unordered_set<X, Y>& s)\n {\n-    return MallocUsage(sizeof(unordered_node<X>)) * s.size() + MallocUsage(sizeof(void*) * s.bucket_count());\n+    return MallocUsage(sizeof(std::pair<X, void*>)) * s.size() + MallocUsage(sizeof(void*) * s.bucket_count());\n }\n \n-template<typename X, typename Y, typename Z>\n-static inline size_t DynamicUsage(const std::unordered_map<X, Y, Z>& m)\n+template <typename Key, typename Value, typename Hash, typename Equals, typename Alloc>\n+static inline size_t DynamicUsage(const std::unordered_map<Key, Value, Hash, Equals, Alloc>& m)\n {\n-    return MallocUsage(sizeof(unordered_node<std::pair<const X, Y> >)) * m.size() + MallocUsage(sizeof(void*) * m.bucket_count());\n+    using ContainerType = std::unordered_map<Key, Value, Hash, Equals, Alloc>;\n+    if constexpr (std::is_same_v<Alloc, node_allocator::Allocator<std::pair<const Key, Value>, memusage::NodeSize<ContainerType>::Value()>>) {\n+        // Assumes that DynamicUsage of the MemoryResource is called separately. We don't do it here\n+        // because multiple maps could use the same MemoryResource.\n+        return MallocUsage(sizeof(void*) * m.bucket_count());\n+    } else {\n+        auto node_size = NodeSize<std::unordered_map<Key, Value, Hash, Equals, Alloc>>::Value();",
    "path": "src/memusage.h",
    "position": null,
    "original_position": 82,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "a91b6032f037ab1a26ac4baa761e809fbfeb1bdd",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Could be shortened to `NodeSize<ContainerType>`\r\n\r\n(Version: a91b6032f037ab1a26ac4baa761e809fbfeb1bdd)",
    "created_at": "2021-10-26T23:20:05Z",
    "updated_at": "2021-10-27T17:37:20Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r736991419",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736991419"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r736991419"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736991419/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 213,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/737604676",
    "pull_request_review_id": 789848072,
    "id": 737604676,
    "node_id": "PRRC_kwDOABII584r9vRE",
    "diff_hunk": "@@ -0,0 +1,406 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <memory>\n+#include <new>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based\n+ * containers that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs pools of memory and uses these to carve out memory for the nodes. Nodes\n+ * that are destroyed by the Allocator are actually put back into a free list for further use. This",
    "path": "src/support/allocators/node_allocator.h",
    "position": null,
    "original_position": 25,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "a91b6032f037ab1a26ac4baa761e809fbfeb1bdd",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Would s/destroyed by the Allocator/freed/ to be clear this happens independently of the allocator, and whether or not it is used.\r\n\r\n(Version: a91b6032f037ab1a26ac4baa761e809fbfeb1bdd)",
    "created_at": "2021-10-27T15:41:39Z",
    "updated_at": "2021-10-27T17:37:20Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r737604676",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/737604676"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r737604676"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/737604676/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 25,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/737607359",
    "pull_request_review_id": 789848072,
    "id": 737607359,
    "node_id": "PRRC_kwDOABII584r9v6_",
    "diff_hunk": "@@ -0,0 +1,406 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <memory>\n+#include <new>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based\n+ * containers that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs pools of memory and uses these to carve out memory for the nodes. Nodes\n+ * that are destroyed by the Allocator are actually put back into a free list for further use. This\n+ * behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored\n+ * in-place. This typically saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with\n+ * low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but\n+ * there is no standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to\n+ * the system. Memory is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on\n+ * proximity. So freeing and malloc'ing again can become a random access pattern which can lead to\n+ * more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers.\n+ * Similar to `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages memory. Currently\n+ * it is only able to provide optimized alloc/free for a single fixed allocation size which is given\n+ * in the constructor. Only allocations that match this size will be provided from the preallocated",
    "path": "src/support/allocators/node_allocator.h",
    "position": null,
    "original_position": 53,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "a91b6032f037ab1a26ac4baa761e809fbfeb1bdd",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Should drop \"which is given in the constructor\", since it's not true anymore and is not a really relevant detail describing the high level behavior here.\r\n\r\n(Version: a91b6032f037ab1a26ac4baa761e809fbfeb1bdd)",
    "created_at": "2021-10-27T15:44:26Z",
    "updated_at": "2021-10-27T17:37:20Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r737607359",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/737607359"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r737607359"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/737607359/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": 52,
    "start_side": "RIGHT",
    "line": null,
    "original_line": 53,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/737617919",
    "pull_request_review_id": 789848072,
    "id": 737617919,
    "node_id": "PRRC_kwDOABII584r9yf_",
    "diff_hunk": "@@ -0,0 +1,406 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <memory>\n+#include <new>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based\n+ * containers that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs pools of memory and uses these to carve out memory for the nodes. Nodes\n+ * that are destroyed by the Allocator are actually put back into a free list for further use. This\n+ * behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored\n+ * in-place. This typically saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with\n+ * low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but\n+ * there is no standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to\n+ * the system. Memory is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on\n+ * proximity. So freeing and malloc'ing again can become a random access pattern which can lead to\n+ * more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers.\n+ * Similar to `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages memory. Currently\n+ * it is only able to provide optimized alloc/free for a single fixed allocation size which is given\n+ * in the constructor. Only allocations that match this size will be provided from the preallocated\n+ * pools of memory; all other requests simply use ::operator new(). To get the correct node size in\n+ * all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.",
    "path": "src/support/allocators/node_allocator.h",
    "position": null,
    "original_position": 56,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "a91b6032f037ab1a26ac4baa761e809fbfeb1bdd",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "It is unexpected to mention std::unordered_map here when everything above is talking about containers generally.  Also unclear what \"all cases\" is referring to. Would drop last two sentences and just say something like:\r\n\r\n> Using node_allocator with a standard container types like std::list, std::unordered_map requires knowing node sizes of those containers which are non-standard implementation details. The \\ref memusage::NodeSize trait and \\ref node_allocator::Factory class can be used to help with this.\r\n\r\n(Version: a91b6032f037ab1a26ac4baa761e809fbfeb1bdd)",
    "created_at": "2021-10-27T15:55:38Z",
    "updated_at": "2021-10-27T17:37:20Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r737617919",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/737617919"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r737617919"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/737617919/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 56,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/737631026",
    "pull_request_review_id": 789848072,
    "id": 737631026,
    "node_id": "PRRC_kwDOABII584r91sy",
    "diff_hunk": "@@ -0,0 +1,406 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <memory>\n+#include <new>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based\n+ * containers that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs pools of memory and uses these to carve out memory for the nodes. Nodes\n+ * that are destroyed by the Allocator are actually put back into a free list for further use. This\n+ * behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored\n+ * in-place. This typically saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with\n+ * low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but\n+ * there is no standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to\n+ * the system. Memory is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on\n+ * proximity. So freeing and malloc'ing again can become a random access pattern which can lead to\n+ * more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers.\n+ * Similar to `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages memory. Currently\n+ * it is only able to provide optimized alloc/free for a single fixed allocation size which is given\n+ * in the constructor. Only allocations that match this size will be provided from the preallocated\n+ * pools of memory; all other requests simply use ::operator new(). To get the correct node size in\n+ * all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios\n+ * in `node_allocator_tests/test_allocations_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall \u201cHow to Write a Custom Allocator\u201d\n+ *   https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer \u201cAn Allocator is a Handle to a Heap\u201d\n+ *   https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *   https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+namespace detail {\n+\n+/**\n+ * In-place linked list of the allocations, used for the free list.\n+ */\n+struct FreeList {\n+    void* next;\n+};\n+\n+/**\n+ * Calculates the required allocation size for the given type.\n+ * The memory needs to be correctly aligned and large enough for both both T and FreeList.\n+ */\n+template <typename T>\n+[[nodiscard]] constexpr size_t RequiredAllocationSizeBytes() noexcept\n+{\n+    const auto alignment_max = std::max(std::alignment_of_v<T>, std::alignment_of_v<FreeList>);\n+    const auto size_max = std::max(sizeof(T), sizeof(FreeList));\n+\n+    // find closest multiple of alignment_max that holds size_max\n+    return ((size_max + alignment_max - 1U) / alignment_max) * alignment_max;\n+}\n+\n+} // namespace detail\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It\n+ * stores a number of memory pools which are used to quickly give out memory of a fixed allocation\n+ * size. The class is purposely kept very simple. It only knows about \"Allocations\" and \"Pools\".\n+ *\n+ * - Pool: MemoryResource allocates one memory pool at a time. These pools are kept around until the\n+ * memory resource is destroyed.\n+ *\n+ * - Allocations: Node-based containers allocate one node at a time. Whenever that happens, the\n+ * MemoryResource's Allocate() gives out memory for one node. These are carved out from a previously\n+ * allocated memory pool, or from a free list if it contains entries. Whenever a node is given back\n+ * with Deallocate(), it is put into that free list.\n+ */\n+template <size_t ALLOCATION_SIZE_BYTES>\n+class MemoryResource\n+{\n+    /**\n+     * Size in bytes to allocate per pool, currently hardcoded to multiple of ALLOCATION_SIZE_BYTES\n+     * that comes closest to 256 KiB.\n+     */\n+    static constexpr size_t POOL_SIZE_BYTES = (262144 / ALLOCATION_SIZE_BYTES) * ALLOCATION_SIZE_BYTES;\n+\n+public:\n+    /**\n+     * Construct a new MemoryResource object that uses the specified allocation size to optimize for.\n+     */\n+    MemoryResource() = default;\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated pools.\n+     *\n+     * There's no Clear() method on purpose, because it would be dangerous. E.g. when calling\n+     * clear() on an unordered_map, it is not certain that all allocated nodes are given back to the\n+     * MemoryResource. Microsoft's STL still uses a control structure that might have the same size\n+     * as the nodes, and therefore needs to be kept around until the map is actually destroyed.\n+     */\n+    ~MemoryResource() = default;\n+\n+    /**\n+     * Allocates memory for n * sizeof(T). Only when n==1 and T's size matches ALLOCATION_SIZE_BYTES\n+     * the pool's memory is used. Otherwise, the allocation is forwarded to ::operator new().\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        if constexpr (ALLOCATION_SIZE_BYTES == detail::RequiredAllocationSizeBytes<T>()) {",
    "path": "src/support/allocators/node_allocator.h",
    "position": null,
    "original_position": 153,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "a91b6032f037ab1a26ac4baa761e809fbfeb1bdd",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "It seems like it would be better to make this a `static_assert` than an `if constexpr`. I also don't see a reason for this method to take an `n` argument. Switching to `static_assert` and dropping `n` argument here would have the following advantages:\r\n\r\n- It would simplify this method and remove footguns where calling it incorrectly could result in bad runtime behavior instead of a compile time errors.\r\n- Moving the size and n checks to `Allocator::allocate` instead of `MemoryResource::Allocate` would allow more flexiblility like falling back to a nested allocator like `std::allocator` instead of global `::operator new` (In theory this would even allow chaining different sized `node_allocator::Allocator` types together so an allocator could transparently direct diffferent sized allocations to different sized pools, and fall back to `std::allocator` if no pool fits)\r\n\r\n(Version: a91b6032f037ab1a26ac4baa761e809fbfeb1bdd)",
    "created_at": "2021-10-27T16:10:13Z",
    "updated_at": "2021-10-27T17:40:41Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r737631026",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/737631026"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r737631026"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/737631026/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 153,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/737638806",
    "pull_request_review_id": 789848072,
    "id": 737638806,
    "node_id": "PRRC_kwDOABII584r93mW",
    "diff_hunk": "@@ -0,0 +1,406 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <memory>\n+#include <new>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based\n+ * containers that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs pools of memory and uses these to carve out memory for the nodes. Nodes\n+ * that are destroyed by the Allocator are actually put back into a free list for further use. This\n+ * behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored\n+ * in-place. This typically saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with\n+ * low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but\n+ * there is no standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to\n+ * the system. Memory is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on\n+ * proximity. So freeing and malloc'ing again can become a random access pattern which can lead to\n+ * more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers.\n+ * Similar to `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages memory. Currently\n+ * it is only able to provide optimized alloc/free for a single fixed allocation size which is given\n+ * in the constructor. Only allocations that match this size will be provided from the preallocated\n+ * pools of memory; all other requests simply use ::operator new(). To get the correct node size in\n+ * all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios\n+ * in `node_allocator_tests/test_allocations_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall \u201cHow to Write a Custom Allocator\u201d\n+ *   https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer \u201cAn Allocator is a Handle to a Heap\u201d\n+ *   https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *   https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+namespace detail {\n+\n+/**\n+ * In-place linked list of the allocations, used for the free list.\n+ */\n+struct FreeList {\n+    void* next;",
    "path": "src/support/allocators/node_allocator.h",
    "position": null,
    "original_position": 78,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "a91b6032f037ab1a26ac4baa761e809fbfeb1bdd",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Would expect `FreeList*` instead of `void*`. `void*` could make sense if these were ever pointers to something besides FreeLists, but if `next` is ever non-null it is always pointing to a FreeList.\r\n\r\n(Version: a91b6032f037ab1a26ac4baa761e809fbfeb1bdd)",
    "created_at": "2021-10-27T16:19:22Z",
    "updated_at": "2021-10-27T17:37:20Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r737638806",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/737638806"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r737638806"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/737638806/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 78,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/737639301",
    "pull_request_review_id": 789848072,
    "id": 737639301,
    "node_id": "PRRC_kwDOABII584r93uF",
    "diff_hunk": "@@ -0,0 +1,406 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <memory>\n+#include <new>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based\n+ * containers that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs pools of memory and uses these to carve out memory for the nodes. Nodes\n+ * that are destroyed by the Allocator are actually put back into a free list for further use. This\n+ * behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored\n+ * in-place. This typically saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with\n+ * low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but\n+ * there is no standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to\n+ * the system. Memory is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on\n+ * proximity. So freeing and malloc'ing again can become a random access pattern which can lead to\n+ * more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers.\n+ * Similar to `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages memory. Currently\n+ * it is only able to provide optimized alloc/free for a single fixed allocation size which is given\n+ * in the constructor. Only allocations that match this size will be provided from the preallocated\n+ * pools of memory; all other requests simply use ::operator new(). To get the correct node size in\n+ * all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios\n+ * in `node_allocator_tests/test_allocations_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall \u201cHow to Write a Custom Allocator\u201d\n+ *   https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer \u201cAn Allocator is a Handle to a Heap\u201d\n+ *   https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *   https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+namespace detail {\n+\n+/**\n+ * In-place linked list of the allocations, used for the free list.\n+ */\n+struct FreeList {\n+    void* next;\n+};\n+\n+/**\n+ * Calculates the required allocation size for the given type.\n+ * The memory needs to be correctly aligned and large enough for both both T and FreeList.\n+ */\n+template <typename T>\n+[[nodiscard]] constexpr size_t RequiredAllocationSizeBytes() noexcept\n+{\n+    const auto alignment_max = std::max(std::alignment_of_v<T>, std::alignment_of_v<FreeList>);\n+    const auto size_max = std::max(sizeof(T), sizeof(FreeList));\n+\n+    // find closest multiple of alignment_max that holds size_max\n+    return ((size_max + alignment_max - 1U) / alignment_max) * alignment_max;\n+}\n+\n+} // namespace detail\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It\n+ * stores a number of memory pools which are used to quickly give out memory of a fixed allocation\n+ * size. The class is purposely kept very simple. It only knows about \"Allocations\" and \"Pools\".\n+ *\n+ * - Pool: MemoryResource allocates one memory pool at a time. These pools are kept around until the\n+ * memory resource is destroyed.\n+ *\n+ * - Allocations: Node-based containers allocate one node at a time. Whenever that happens, the\n+ * MemoryResource's Allocate() gives out memory for one node. These are carved out from a previously\n+ * allocated memory pool, or from a free list if it contains entries. Whenever a node is given back\n+ * with Deallocate(), it is put into that free list.\n+ */\n+template <size_t ALLOCATION_SIZE_BYTES>\n+class MemoryResource\n+{\n+    /**\n+     * Size in bytes to allocate per pool, currently hardcoded to multiple of ALLOCATION_SIZE_BYTES\n+     * that comes closest to 256 KiB.\n+     */\n+    static constexpr size_t POOL_SIZE_BYTES = (262144 / ALLOCATION_SIZE_BYTES) * ALLOCATION_SIZE_BYTES;\n+\n+public:\n+    /**\n+     * Construct a new MemoryResource object that uses the specified allocation size to optimize for.\n+     */\n+    MemoryResource() = default;\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated pools.\n+     *\n+     * There's no Clear() method on purpose, because it would be dangerous. E.g. when calling\n+     * clear() on an unordered_map, it is not certain that all allocated nodes are given back to the\n+     * MemoryResource. Microsoft's STL still uses a control structure that might have the same size\n+     * as the nodes, and therefore needs to be kept around until the map is actually destroyed.\n+     */\n+    ~MemoryResource() = default;\n+\n+    /**\n+     * Allocates memory for n * sizeof(T). Only when n==1 and T's size matches ALLOCATION_SIZE_BYTES\n+     * the pool's memory is used. Otherwise, the allocation is forwarded to ::operator new().\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        if constexpr (ALLOCATION_SIZE_BYTES == detail::RequiredAllocationSizeBytes<T>()) {\n+            if (n != 1) {\n+                // pool is not used so forward to operator new.\n+                return static_cast<T*>(::operator new(n * sizeof(T)));\n+            }\n+\n+            if (m_free_allocations) {\n+                // we've already got data in the free list, unlink one element\n+                auto old_head = m_free_allocations;\n+                m_free_allocations = static_cast<detail::FreeList*>(m_free_allocations)->next;\n+                return static_cast<T*>(old_head);\n+            }\n+\n+            // free list is empty: get one allocation from allocated pool memory.\n+            // It makes sense to not create the fully linked list of an allocated pool up-front, for\n+            // several reasons. On the one hand, the latency is higher when we need to iterate and\n+            // update pointers for the whole pool at once. More importantly, most systems lazily\n+            // allocate data. So when we allocate a big pool of memory the memory for a page is only\n+            // actually made available to the program when it is first touched. So when we allocate\n+            // a big pool and only use very little memory from it, the total memory usage is lower\n+            // than what has been malloc'ed.\n+            if (m_untouched_memory_iterator == m_untouched_memory_end) {\n+                // slow path, only happens when a new pool needs to be allocated\n+                AllocatePool();\n+            }\n+\n+            // peel off one allocation from the untouched memory. The next pointer of in-use\n+            // elements doesn't matter until it is deallocated, only then it is used to form the\n+            // free list.\n+            const auto tmp = m_untouched_memory_iterator;\n+            m_untouched_memory_iterator = static_cast<char*>(tmp) + ALLOCATION_SIZE_BYTES;\n+            return static_cast<T*>(tmp);\n+        } else {\n+            // pool is not used so forward to operator new.\n+            return static_cast<T*>(::operator new(n * sizeof(T)));\n+        }\n+    }\n+\n+    /**\n+     * Puts p back into the free list if it was actually allocated from the memory pool.\n+     * Otherwise, simply call ::operator delete(p).\n+     */\n+    template <typename T>\n+    void Deallocate(void* p, size_t n) noexcept\n+    {\n+        if constexpr (ALLOCATION_SIZE_BYTES == detail::RequiredAllocationSizeBytes<T>()) {\n+            if (n != 1) {\n+                // allocation didn't happen with the pool\n+                ::operator delete(p);\n+                return;\n+            }\n+\n+            // put it into the linked list\n+            const auto allocation = static_cast<detail::FreeList*>(p);\n+            allocation->next = m_free_allocations;\n+            m_free_allocations = allocation;\n+        } else {\n+            // allocation didn't happen with the pool\n+            ::operator delete(p);\n+        }\n+    }\n+\n+    /**\n+     * Calculates bytes allocated by the memory resource.\n+     */\n+    [[nodiscard]] size_t DynamicMemoryUsage() const noexcept\n+    {\n+        return memusage::MallocUsage(POOL_SIZE_BYTES) * m_allocated_pools.size() + memusage::DynamicUsage(m_allocated_pools);\n+    }\n+\n+private:\n+    //! Access to internals for testing purpose only\n+    friend class MemoryResourceTester;\n+\n+    /**\n+     * Allocate one full memory pool which is used to carve out allocations.\n+     */\n+    void AllocatePool()\n+    {\n+        m_allocated_pools.emplace_back(new char[POOL_SIZE_BYTES]);\n+        m_untouched_memory_iterator = m_allocated_pools.back().get();\n+        m_untouched_memory_end = m_allocated_pools.back().get() + POOL_SIZE_BYTES;\n+    }\n+\n+    //! Contains all allocated pools of memory, used to free the data in the destructor.\n+    std::vector<std::unique_ptr<char[]>> m_allocated_pools{};\n+\n+    //! A single linked list of all data available in the MemoryResource. This list is used for\n+    //! allocations of single elements.\n+    void* m_free_allocations = nullptr;",
    "path": "src/support/allocators/node_allocator.h",
    "position": null,
    "original_position": 242,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "a91b6032f037ab1a26ac4baa761e809fbfeb1bdd",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Again seems like type should be `FreeList*` not `void*`\r\n\r\n(Version: a91b6032f037ab1a26ac4baa761e809fbfeb1bdd)",
    "created_at": "2021-10-27T16:20:00Z",
    "updated_at": "2021-10-27T17:37:20Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r737639301",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/737639301"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r737639301"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/737639301/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 242,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/737646193",
    "pull_request_review_id": 789848072,
    "id": 737646193,
    "node_id": "PRRC_kwDOABII584r95Zx",
    "diff_hunk": "@@ -0,0 +1,425 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored in-place. This typically\n+ *   saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but there is no\n+ *   standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on proximity. So freeing\n+ *   and malloc'ing again can become a random access pattern which can lead to more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Currently it is only\n+ * able provide optimized alloc/free for a single fixed node size which is given in the constructor. Only allocations that match this\n+ * size will be provided from the preallocated blocks of memory; all other requests simply use ::operator new().\n+ * To get the correct node size in all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios in\n+ * `node_allocator_tests/test_chunks_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall \u201cHow to Write a Custom Allocator\u201d https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer \u201cAn Allocator is a Handle to a Heap\u201d https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *      https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block, or from a free list if it contains entries.\n+ *   Whenever a node is given back with Deallocate(), it is put into that free list.\n+ */\n+class MemoryResource\n+{\n+    //! Size in bytes to allocate per block, currently hardcoded to 256 KiB.\n+    static constexpr size_t BlockSizeBytes = 262144;\n+\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object that uses the specified chunk size to optimize for.\n+     */\n+    explicit MemoryResource(size_t chunk_size_bytes) : m_chunk_size_bytes(chunk_size_bytes) {}\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated blocks.\n+     *\n+     * There's no Clear() method on purpose, because it would be dangerous. E.g. when calling clear() on\n+     * an unordered_map, it is not certain that all allocated chunks are given back to the MemoryResource.\n+     * Microsoft's STL still uses a control structure that might have the same size as the nodes, and therefore\n+     * needs to be kept around until the map is actually destroyed.\n+     */\n+    ~MemoryResource() noexcept\n+    {\n+        for (auto* block : m_allocated_blocks) {\n+            ::operator delete(block);\n+        }\n+    }\n+\n+    /**\n+     * Allocates memory for n times T. Only when n==1 and T's size matches m_chunk_size_bytes\n+     * the chunking mechanism is used. Otherwise, the allocation is forwarded to ::operator new().\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes != required_chunk_size || n != 1) {\n+            // pool is not used so forward to operator new.\n+            return static_cast<T*>(::operator new(n * sizeof(T)));\n+        }\n+\n+        // chunk size is correct, so we can actually use the pool's block data\n+\n+        if (m_free_chunks) {\n+            // we've already got data in the free list, unlink one element\n+            auto old_head = m_free_chunks;\n+            m_free_chunks = static_cast<ChunkNode*>(m_free_chunks)->next;\n+            return static_cast<T*>(old_head);\n+        }\n+\n+        // free list is empty: get one chunk from allocated block memory.\n+        // It makes sense to not create the fully linked list of an allocated block up-front, for several reasons.\n+        // On the one hand, the latency is higher when we need to iterate and update pointers for the whole block at once.\n+        // More importantly, most systems lazily allocate data. So when we allocate a big block of memory the memory for a page\n+        // is only actually made available to the program when it is first touched. So when we allocate a big block and only use\n+        // very little memory from it, the total memory usage is lower than what has been malloc'ed.\n+        if (m_untouched_memory_iterator == m_untouched_memory_end) {\n+            // slow path, only happens when a new block needs to be allocated\n+            AllocateNewBlock();\n+        }\n+\n+        // peel off one chunk from the untouched memory. The next pointer of in-use elements doesn't matter until it is\n+        // deallocated, only then it is used to form the free list.\n+        const auto tmp = m_untouched_memory_iterator;\n+        m_untouched_memory_iterator = static_cast<char*>(tmp) + m_chunk_size_bytes;\n+        return static_cast<T*>(tmp);\n+    }\n+\n+    /**\n+     * Puts p back into the free list f it was actually allocated from the memory block.\n+     * Otherwise, simply call ::operator delete(p).\n+     */\n+    template <typename T>\n+    void Deallocate(void* p, size_t n) noexcept\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size_bytes = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes == required_chunk_size_bytes && n == 1) {\n+            // put it into the linked list\n+            const auto node = static_cast<ChunkNode*>(p);\n+            node->next = m_free_chunks;\n+            m_free_chunks = node;\n+        } else {\n+            // allocation didn't happen with the pool\n+            ::operator delete(p);\n+        }\n+    }\n+\n+    /**\n+     * Actual size in bytes that is used for one chunk (node allocation)\n+     */\n+    [[nodiscard]] size_t ChunkSizeBytes() const noexcept\n+    {\n+        return m_chunk_size_bytes;\n+    }\n+\n+    /**\n+     * Calculates bytes allocated by the memory resource.\n+     */\n+    [[nodiscard]] size_t DynamicMemoryUsage() const noexcept\n+    {\n+        const size_t alloc_size{(BlockSizeBytes / m_chunk_size_bytes) * m_chunk_size_bytes};\n+        return memusage::MallocUsage(alloc_size) * m_allocated_blocks.size() + memusage::DynamicUsage(m_allocated_blocks);\n+    }\n+\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation. Mostly for debugging / logging / testing.\n+     */\n+    [[nodiscard]] size_t NumFreeChunks() const noexcept\n+    {\n+        size_t length = 0;\n+        auto node = m_free_chunks;\n+        while (node) {\n+            node = static_cast<ChunkNode const*>(node)->next;\n+            ++length;\n+        }\n+        return length;\n+    }\n+\n+    /**\n+     * Number of memory blocks that have been allocated\n+     */\n+    [[nodiscard]] size_t NumBlocks() const noexcept\n+    {\n+        return m_allocated_blocks.size();\n+    }\n+\n+    /**\n+     * Calculates the required chunk size for the given type.\n+     * The memory block needs to be correctly aligned and large enough to hold both T and ChunkNode.\n+     */\n+    template <typename T>\n+    [[nodiscard]] static constexpr size_t CalcRequiredChunkSizeBytes() noexcept\n+    {\n+        const auto alignment_max = std::max(std::alignment_of_v<T>, std::alignment_of_v<ChunkNode>);\n+        const auto size_max = std::max(sizeof(T), sizeof(ChunkNode));\n+\n+        // find closest multiple of alignment_max that holds size_max\n+        return ((size_max + alignment_max - 1U) / alignment_max) * alignment_max;\n+    }\n+\n+private:\n+    /**\n+     * Allocate one full memory block which is used to carve out chunks.\n+     * The block size is the multiple of m_chunk_size_bytes that comes closest to BlockSizeBytes.\n+     */\n+    void AllocateNewBlock()\n+    {\n+        static_assert(sizeof(char) == 1U);\n+\n+        const auto num_chunks = BlockSizeBytes / m_chunk_size_bytes;\n+        m_untouched_memory_iterator = ::operator new(num_chunks* m_chunk_size_bytes);\n+        m_untouched_memory_end = static_cast<char*>(m_untouched_memory_iterator) + num_chunks * m_chunk_size_bytes;\n+        m_allocated_blocks.push_back(m_untouched_memory_iterator);\n+    }\n+\n+    /**\n+     * The MemoryResource's size for the memory chunks that it can give out.\n+     */\n+    size_t const m_chunk_size_bytes;\n+\n+    //! A contains all allocated blocks of memory, used to free the data in the destructor.\n+    std::vector<void*> m_allocated_blocks{};\n+\n+    //! A single linked list of all data available in the MemoryResource. This list is used for allocations of single elements.\n+    void* m_free_chunks = nullptr;\n+\n+    //! Points to the beginning of available memory for carving out chunks.\n+    void* m_untouched_memory_iterator = nullptr;\n+\n+    //! Points to the end of available memory for carving out chunks.\n+    void* m_untouched_memory_end = nullptr;",
    "path": "src/support/allocators/node_allocator.h",
    "position": null,
    "original_position": 267,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "952c37a31c39b7acdb5ab2634a354a1c548708a2",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "If you prefer to keep this variable, I think for clarity it should have a comment like\r\n\r\n// m_untouched_memory_end member variable is redundant, and is always equal to (m_allocated_pools.back().get() + POOL_SIZE_BYTES) whenever it is accessed, but m_untouched_memory_end caches this for clarity and efficiency.\r\n\r\n(Version: a91b6032f037ab1a26ac4baa761e809fbfeb1bdd)\r\n",
    "created_at": "2021-10-27T16:27:02Z",
    "updated_at": "2021-10-28T17:03:32Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r737646193",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/737646193"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r737646193"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/737646193/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 267,
    "side": "RIGHT",
    "in_reply_to_id": 734648036
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/737676396",
    "pull_request_review_id": 789848072,
    "id": 737676396,
    "node_id": "PRRC_kwDOABII584r-Axs",
    "diff_hunk": "@@ -148,23 +154,65 @@ static inline size_t DynamicUsage(const std::shared_ptr<X>& p)\n     return p ? MallocUsage(sizeof(X)) + MallocUsage(sizeof(stl_shared_counter)) : 0;\n }\n \n-template<typename X>\n-struct unordered_node : private X\n-{\n-private:\n-    void* ptr;\n+template <typename T>\n+struct NodeSize {\n+};\n+\n+// It is important that the calculation here matches exactly the behavior of std::unordered_map\n+// so the node_allocator actually works. This is tested in node_allocator_tests/test_allocations_are_used\n+// with multiple configurations (alignments, noexcept hash, node sizes).\n+template <typename Key, typename V, typename Hash, typename Equals, typename Allocator>\n+struct NodeSize<std::unordered_map<Key, V, Hash, Equals, Allocator>> {\n+    [[nodiscard]] static constexpr size_t Value()\n+    {\n+        // libstdc++, libc++, and MSVC implement the nodes differently. To get the correct size\n+        // with the correct alignment, we can simulate that with accordingly nested std::pairs.\n+        using ValueType = std::pair<const Key, V>;\n+\n+#if defined(_MSC_VER)\n+        // list node contains 2 pointers and no hash; see\n+        // https://github.com/microsoft/STL/blob/main/stl/inc/unordered_map and\n+        // https://github.com/microsoft/STL/blob/main/stl/inc/list\n+        return sizeof(std::pair<std::pair<void*, void*>, ValueType>);\n+#else\n+\n+#if defined(_LIBCPP_VERSION) // defined in any C++ header from libc++\n+        // libc++ always stores hash and pointer in the node\n+        // see https://github.com/llvm/llvm-project/blob/release/13.x/libcxx/include/__hash_table#L92\n+        return sizeof(std::pair<ValueType, std::pair<size_t, void*>>);\n+#else\n+        // libstdc++ doesn't store hash when its operator() is noexcept;\n+        // see hashtable_policy.h, struct _Hash_node\n+        // https://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a05689.html\n+        if (noexcept(std::declval<Hash>()(std::declval<const Key&>()))) {\n+            return sizeof(std::pair<void*, ValueType>);\n+        } else {\n+            // hash is stored along ValueType, and that is wrapped with the pointer.\n+            return sizeof(std::pair<void*, std::pair<ValueType, size_t>>);\n+        }\n+#endif\n+#endif\n+    }\n };\n \n template<typename X, typename Y>\n static inline size_t DynamicUsage(const std::unordered_set<X, Y>& s)\n {\n-    return MallocUsage(sizeof(unordered_node<X>)) * s.size() + MallocUsage(sizeof(void*) * s.bucket_count());\n+    return MallocUsage(sizeof(std::pair<X, void*>)) * s.size() + MallocUsage(sizeof(void*) * s.bucket_count());\n }\n \n-template<typename X, typename Y, typename Z>\n-static inline size_t DynamicUsage(const std::unordered_map<X, Y, Z>& m)\n+template <typename Key, typename Value, typename Hash, typename Equals, typename Alloc>\n+static inline size_t DynamicUsage(const std::unordered_map<Key, Value, Hash, Equals, Alloc>& m)\n {\n-    return MallocUsage(sizeof(unordered_node<std::pair<const X, Y> >)) * m.size() + MallocUsage(sizeof(void*) * m.bucket_count());\n+    using ContainerType = std::unordered_map<Key, Value, Hash, Equals, Alloc>;\n+    if constexpr (std::is_same_v<Alloc, node_allocator::Allocator<std::pair<const Key, Value>, memusage::NodeSize<ContainerType>::Value()>>) {\n+        // Assumes that DynamicUsage of the MemoryResource is called separately. We don't do it here\n+        // because multiple maps could use the same MemoryResource.\n+        return MallocUsage(sizeof(void*) * m.bucket_count());",
    "path": "src/memusage.h",
    "position": null,
    "original_position": 80,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "a91b6032f037ab1a26ac4baa761e809fbfeb1bdd",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Having this special case to handle shared memory resources seems clunky, especially because it adds a circular dependency between memusage and node_allocator types, instead of letting node_allocator have a one-way dependency on memusage.\r\n\r\nAlso it seems like awkward accounting to have dynamic usage of containers not actually include the memory they are using, and for all the cost of all memory be attributed to the memory resource with no distinction between allocated and unallocated memory.\r\n\r\nAnother way of doing the accounting would be to keep the containers attributed memory usage unchanged, and just attribute size of unallocated memory to MemoryResource, instead of size of allocated+unallocated memory.\r\n\r\nSpecifically the suggestion would be to:\r\n\r\n* Drop the `if constexpr` special case code here and circular dependency of memusage on node_allocator\r\n* Change definition of `MemoryResource::DynamicMemoryUsage` to only include unallocated space not total space by:\r\n  - Subtracting `POOL_SIZE_BYTES * m_allocated_pools.size()` from current value\r\n  - Adding `m_untouched_memory_end - m_untouched_memory_iterator + (length of m_free_allocations list) * ALLOCATION_SIZE_BYTES`\r\n  - Maybe adding a counter variable to get length of `m_free_allocations` list efficiently\r\n\r\n(Version: a91b6032f037ab1a26ac4baa761e809fbfeb1bdd)",
    "created_at": "2021-10-27T17:05:19Z",
    "updated_at": "2021-10-27T17:37:20Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r737676396",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/737676396"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r737676396"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/737676396/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": 209,
    "start_side": "RIGHT",
    "line": null,
    "original_line": 211,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/737686220",
    "pull_request_review_id": 789848072,
    "id": 737686220,
    "node_id": "PRRC_kwDOABII584r-DLM",
    "diff_hunk": "@@ -0,0 +1,406 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <memory>\n+#include <new>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based\n+ * containers that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs pools of memory and uses these to carve out memory for the nodes. Nodes\n+ * that are destroyed by the Allocator are actually put back into a free list for further use. This\n+ * behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored\n+ * in-place. This typically saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with\n+ * low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but\n+ * there is no standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to\n+ * the system. Memory is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on\n+ * proximity. So freeing and malloc'ing again can become a random access pattern which can lead to\n+ * more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers.\n+ * Similar to `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages memory. Currently\n+ * it is only able to provide optimized alloc/free for a single fixed allocation size which is given\n+ * in the constructor. Only allocations that match this size will be provided from the preallocated\n+ * pools of memory; all other requests simply use ::operator new(). To get the correct node size in\n+ * all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios\n+ * in `node_allocator_tests/test_allocations_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall \u201cHow to Write a Custom Allocator\u201d\n+ *   https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer \u201cAn Allocator is a Handle to a Heap\u201d\n+ *   https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *   https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+namespace detail {\n+\n+/**\n+ * In-place linked list of the allocations, used for the free list.\n+ */\n+struct FreeList {\n+    void* next;\n+};\n+\n+/**\n+ * Calculates the required allocation size for the given type.\n+ * The memory needs to be correctly aligned and large enough for both both T and FreeList.\n+ */\n+template <typename T>\n+[[nodiscard]] constexpr size_t RequiredAllocationSizeBytes() noexcept\n+{\n+    const auto alignment_max = std::max(std::alignment_of_v<T>, std::alignment_of_v<FreeList>);\n+    const auto size_max = std::max(sizeof(T), sizeof(FreeList));\n+\n+    // find closest multiple of alignment_max that holds size_max\n+    return ((size_max + alignment_max - 1U) / alignment_max) * alignment_max;\n+}\n+\n+} // namespace detail\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It\n+ * stores a number of memory pools which are used to quickly give out memory of a fixed allocation\n+ * size. The class is purposely kept very simple. It only knows about \"Allocations\" and \"Pools\".\n+ *\n+ * - Pool: MemoryResource allocates one memory pool at a time. These pools are kept around until the\n+ * memory resource is destroyed.\n+ *\n+ * - Allocations: Node-based containers allocate one node at a time. Whenever that happens, the\n+ * MemoryResource's Allocate() gives out memory for one node. These are carved out from a previously\n+ * allocated memory pool, or from a free list if it contains entries. Whenever a node is given back\n+ * with Deallocate(), it is put into that free list.\n+ */\n+template <size_t ALLOCATION_SIZE_BYTES>\n+class MemoryResource\n+{\n+    /**\n+     * Size in bytes to allocate per pool, currently hardcoded to multiple of ALLOCATION_SIZE_BYTES\n+     * that comes closest to 256 KiB.\n+     */\n+    static constexpr size_t POOL_SIZE_BYTES = (262144 / ALLOCATION_SIZE_BYTES) * ALLOCATION_SIZE_BYTES;\n+\n+public:\n+    /**\n+     * Construct a new MemoryResource object that uses the specified allocation size to optimize for.\n+     */\n+    MemoryResource() = default;\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated pools.\n+     *\n+     * There's no Clear() method on purpose, because it would be dangerous. E.g. when calling\n+     * clear() on an unordered_map, it is not certain that all allocated nodes are given back to the\n+     * MemoryResource. Microsoft's STL still uses a control structure that might have the same size\n+     * as the nodes, and therefore needs to be kept around until the map is actually destroyed.\n+     */\n+    ~MemoryResource() = default;\n+\n+    /**\n+     * Allocates memory for n * sizeof(T). Only when n==1 and T's size matches ALLOCATION_SIZE_BYTES\n+     * the pool's memory is used. Otherwise, the allocation is forwarded to ::operator new().\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        if constexpr (ALLOCATION_SIZE_BYTES == detail::RequiredAllocationSizeBytes<T>()) {\n+            if (n != 1) {\n+                // pool is not used so forward to operator new.\n+                return static_cast<T*>(::operator new(n * sizeof(T)));\n+            }\n+\n+            if (m_free_allocations) {\n+                // we've already got data in the free list, unlink one element\n+                auto old_head = m_free_allocations;\n+                m_free_allocations = static_cast<detail::FreeList*>(m_free_allocations)->next;\n+                return static_cast<T*>(old_head);\n+            }\n+\n+            // free list is empty: get one allocation from allocated pool memory.\n+            // It makes sense to not create the fully linked list of an allocated pool up-front, for\n+            // several reasons. On the one hand, the latency is higher when we need to iterate and\n+            // update pointers for the whole pool at once. More importantly, most systems lazily\n+            // allocate data. So when we allocate a big pool of memory the memory for a page is only\n+            // actually made available to the program when it is first touched. So when we allocate\n+            // a big pool and only use very little memory from it, the total memory usage is lower\n+            // than what has been malloc'ed.\n+            if (m_untouched_memory_iterator == m_untouched_memory_end) {\n+                // slow path, only happens when a new pool needs to be allocated\n+                AllocatePool();\n+            }\n+\n+            // peel off one allocation from the untouched memory. The next pointer of in-use\n+            // elements doesn't matter until it is deallocated, only then it is used to form the\n+            // free list.\n+            const auto tmp = m_untouched_memory_iterator;\n+            m_untouched_memory_iterator = static_cast<char*>(tmp) + ALLOCATION_SIZE_BYTES;\n+            return static_cast<T*>(tmp);\n+        } else {\n+            // pool is not used so forward to operator new.\n+            return static_cast<T*>(::operator new(n * sizeof(T)));\n+        }\n+    }\n+\n+    /**\n+     * Puts p back into the free list if it was actually allocated from the memory pool.\n+     * Otherwise, simply call ::operator delete(p).\n+     */\n+    template <typename T>\n+    void Deallocate(void* p, size_t n) noexcept\n+    {\n+        if constexpr (ALLOCATION_SIZE_BYTES == detail::RequiredAllocationSizeBytes<T>()) {\n+            if (n != 1) {\n+                // allocation didn't happen with the pool\n+                ::operator delete(p);\n+                return;\n+            }\n+\n+            // put it into the linked list\n+            const auto allocation = static_cast<detail::FreeList*>(p);\n+            allocation->next = m_free_allocations;\n+            m_free_allocations = allocation;\n+        } else {\n+            // allocation didn't happen with the pool\n+            ::operator delete(p);\n+        }\n+    }\n+\n+    /**\n+     * Calculates bytes allocated by the memory resource.\n+     */\n+    [[nodiscard]] size_t DynamicMemoryUsage() const noexcept\n+    {\n+        return memusage::MallocUsage(POOL_SIZE_BYTES) * m_allocated_pools.size() + memusage::DynamicUsage(m_allocated_pools);\n+    }\n+\n+private:\n+    //! Access to internals for testing purpose only\n+    friend class MemoryResourceTester;\n+\n+    /**\n+     * Allocate one full memory pool which is used to carve out allocations.\n+     */\n+    void AllocatePool()\n+    {\n+        m_allocated_pools.emplace_back(new char[POOL_SIZE_BYTES]);\n+        m_untouched_memory_iterator = m_allocated_pools.back().get();\n+        m_untouched_memory_end = m_allocated_pools.back().get() + POOL_SIZE_BYTES;\n+    }\n+\n+    //! Contains all allocated pools of memory, used to free the data in the destructor.\n+    std::vector<std::unique_ptr<char[]>> m_allocated_pools{};\n+\n+    //! A single linked list of all data available in the MemoryResource. This list is used for\n+    //! allocations of single elements.\n+    void* m_free_allocations = nullptr;\n+\n+    //! Points to the beginning of available memory for carving out allocations.\n+    void* m_untouched_memory_iterator = nullptr;\n+\n+    //! Points to the end of available memory for carving out allocations.\n+    void* m_untouched_memory_end = nullptr;\n+};\n+\n+\n+/**\n+ * Allocator that's usable for node-based containers like std::unordered_map or std::list.\n+ *\n+ * The allocator is stateful, and can be cheaply copied. Its state is an immobile MemoryResource,\n+ * which actually does all the allocation/deallocations. So this class is just a simple wrapper that\n+ * conforms to the required STL interface to be usable for the node-based containers.\n+ */\n+template <typename T, size_t ALLOCATION_SIZE_BYTES>\n+class Allocator\n+{\n+    template <typename U, size_t AS>\n+    friend class Allocator;\n+\n+    template <typename X, typename Y, size_t AS>\n+    friend bool operator==(const Allocator<X, AS>& a, const Allocator<Y, AS>& b) noexcept;\n+\n+public:\n+    using value_type = T;\n+\n+    /**\n+     * The allocator is stateful so we can't use the compile time `is_always_equal` optimization and\n+     * have to use the runtime operator==.\n+     */\n+    using is_always_equal = std::false_type;\n+\n+    /**\n+     * Move assignment should be a fast operation. In the case of a = std::move(b), we want\n+     * a to be able to use b's allocator, otherwise all elements would have to be recreated with a's\n+     * old allocator.\n+     */\n+    using propagate_on_container_move_assignment = std::true_type;\n+\n+    /**\n+     * Swapping two containers with unequal allocators who are *not* propagated is undefined\n+     * behavior. Unfortunately this is the default! Obviously, we don't want that.\n+     */\n+    using propagate_on_container_swap = std::true_type; // to avoid the undefined behavior\n+\n+    /**\n+     * Move and swap have to propagate the allocator, so for consistency we do the same for copy\n+     * assignment.\n+     */\n+    using propagate_on_container_copy_assignment = std::true_type;\n+\n+    /**\n+     * Construct a new Allocator object which will delegate all allocations/deallocations to the\n+     * memory resource.\n+     */\n+    explicit Allocator(MemoryResource<ALLOCATION_SIZE_BYTES>* memory_resource) noexcept\n+        : m_memory_resource(memory_resource)\n+    {\n+    }\n+\n+    /**\n+     * Conversion constructor for rebinding. All Allocators use the same memory_resource.\n+     *\n+     * The rebound type is determined with the `struct rebind`. The rebind is necessary feature\n+     * for standard allocators, and it happens when the allocator shall be used for different types.\n+     * E.g. for std::unordered_map this happens for allocation of the internally used nodes, for the\n+     * underlying index array, and possibly for some control structure. In fact the type required by\n+     * the standard `std::pair<const Key, Value>` type is never actually used for any allocation\n+     * (which is therefore a stupid requirement, but that's just C++ being C++).\n+     */\n+    template <typename U>\n+    Allocator(const Allocator<U, ALLOCATION_SIZE_BYTES>& other) noexcept\n+        : m_memory_resource(other.m_memory_resource)\n+    {\n+    }\n+\n+    /**\n+     * From the standard: rebind is only optional (provided by std::allocator_traits) if this\n+     * allocator is a template of the form SomeAllocator<T, Args>, where Args is zero or more\n+     * additional template type parameters.\n+     *\n+     * Since we use a size_t as additional argument, it's *not* optional.\n+     * @see https://en.cppreference.com/w/cpp/named_req/Allocator#cite_note-2\n+     */\n+    template <typename U>\n+    struct rebind {\n+        using other = Allocator<U, ALLOCATION_SIZE_BYTES>;\n+    };\n+\n+    /**\n+     * Allocates n entries of the given type.\n+     */\n+    T* allocate(size_t n)\n+    {\n+        // Forward all allocations to the memory_resource\n+        return m_memory_resource->template Allocate<T>(n);\n+    }\n+\n+    /**\n+     * Deallocates n entries of the given type.\n+     */\n+    void deallocate(T* p, size_t n)\n+    {\n+        m_memory_resource->template Deallocate<T>(p, n);\n+    }\n+\n+private:\n+    //! Stateful allocator, where the state is a simple pointer that can be cheaply copied.\n+    MemoryResource<ALLOCATION_SIZE_BYTES>* m_memory_resource;\n+};\n+\n+\n+/**\n+ * Since Allocator is stateful, comparison with another one only returns true if it uses the same\n+ * memory_resource.\n+ */\n+template <typename T, typename U, size_t CS>\n+bool operator==(const Allocator<T, CS>& a, const Allocator<U, CS>& b) noexcept\n+{\n+    // \"Equality of an allocator is determined through the ability of allocating memory with one\n+    // allocator and deallocating it with another.\" - Jonathan M\u00fcller\n+    // See https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+    //\n+    // For us that is the case when both allocators use the same memory resource.\n+    return a.m_memory_resource == b.m_memory_resource;\n+}\n+\n+template <typename T, typename U, size_t CS>\n+bool operator!=(const Allocator<T, CS>& a, const Allocator<U, CS>& b) noexcept\n+{\n+    return !(a == b);\n+}\n+\n+/**\n+ * Helper to create std::unordered_map which uses the node_allocator.\n+ *\n+ * This calculates the size of the container's internally used node correctly for all supported\n+ * platforms, which is also asserted by the unit tests.\n+ */\n+template <typename Key, typename Value, typename Hash = std::hash<Key>, typename Equals = std::equal_to<Key>>\n+class UnorderedMapFactory",
    "path": "src/support/allocators/node_allocator.h",
    "position": null,
    "original_position": 385,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "a91b6032f037ab1a26ac4baa761e809fbfeb1bdd",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "I don't see a reason to tie this to unordered_map. Would suggest renaming this from `UnorderedMapFactory` to just `Factory`, taking a `typename Container` template argument and calling `NodeSize<Container>::Value()` below\r\n\r\n(Version: a91b6032f037ab1a26ac4baa761e809fbfeb1bdd)",
    "created_at": "2021-10-27T17:17:05Z",
    "updated_at": "2021-10-28T17:00:11Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r737686220",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/737686220"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r737686220"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/737686220/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 402,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/737691663",
    "pull_request_review_id": 789848072,
    "id": 737691663,
    "node_id": "PRRC_kwDOABII584r-EgP",
    "diff_hunk": "@@ -0,0 +1,406 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <memory>\n+#include <new>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based\n+ * containers that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs pools of memory and uses these to carve out memory for the nodes. Nodes\n+ * that are destroyed by the Allocator are actually put back into a free list for further use. This\n+ * behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored\n+ * in-place. This typically saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with\n+ * low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but\n+ * there is no standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to\n+ * the system. Memory is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on\n+ * proximity. So freeing and malloc'ing again can become a random access pattern which can lead to\n+ * more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers.\n+ * Similar to `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages memory. Currently\n+ * it is only able to provide optimized alloc/free for a single fixed allocation size which is given\n+ * in the constructor. Only allocations that match this size will be provided from the preallocated\n+ * pools of memory; all other requests simply use ::operator new(). To get the correct node size in\n+ * all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios\n+ * in `node_allocator_tests/test_allocations_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall \u201cHow to Write a Custom Allocator\u201d\n+ *   https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer \u201cAn Allocator is a Handle to a Heap\u201d\n+ *   https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *   https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+namespace detail {\n+\n+/**\n+ * In-place linked list of the allocations, used for the free list.\n+ */\n+struct FreeList {\n+    void* next;\n+};\n+\n+/**\n+ * Calculates the required allocation size for the given type.\n+ * The memory needs to be correctly aligned and large enough for both both T and FreeList.\n+ */\n+template <typename T>\n+[[nodiscard]] constexpr size_t RequiredAllocationSizeBytes() noexcept\n+{\n+    const auto alignment_max = std::max(std::alignment_of_v<T>, std::alignment_of_v<FreeList>);\n+    const auto size_max = std::max(sizeof(T), sizeof(FreeList));\n+\n+    // find closest multiple of alignment_max that holds size_max\n+    return ((size_max + alignment_max - 1U) / alignment_max) * alignment_max;\n+}\n+\n+} // namespace detail\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It\n+ * stores a number of memory pools which are used to quickly give out memory of a fixed allocation\n+ * size. The class is purposely kept very simple. It only knows about \"Allocations\" and \"Pools\".\n+ *\n+ * - Pool: MemoryResource allocates one memory pool at a time. These pools are kept around until the\n+ * memory resource is destroyed.\n+ *\n+ * - Allocations: Node-based containers allocate one node at a time. Whenever that happens, the\n+ * MemoryResource's Allocate() gives out memory for one node. These are carved out from a previously\n+ * allocated memory pool, or from a free list if it contains entries. Whenever a node is given back\n+ * with Deallocate(), it is put into that free list.\n+ */\n+template <size_t ALLOCATION_SIZE_BYTES>\n+class MemoryResource\n+{\n+    /**\n+     * Size in bytes to allocate per pool, currently hardcoded to multiple of ALLOCATION_SIZE_BYTES\n+     * that comes closest to 256 KiB.\n+     */\n+    static constexpr size_t POOL_SIZE_BYTES = (262144 / ALLOCATION_SIZE_BYTES) * ALLOCATION_SIZE_BYTES;\n+\n+public:\n+    /**\n+     * Construct a new MemoryResource object that uses the specified allocation size to optimize for.\n+     */\n+    MemoryResource() = default;\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated pools.\n+     *\n+     * There's no Clear() method on purpose, because it would be dangerous. E.g. when calling\n+     * clear() on an unordered_map, it is not certain that all allocated nodes are given back to the\n+     * MemoryResource. Microsoft's STL still uses a control structure that might have the same size\n+     * as the nodes, and therefore needs to be kept around until the map is actually destroyed.\n+     */\n+    ~MemoryResource() = default;\n+\n+    /**\n+     * Allocates memory for n * sizeof(T). Only when n==1 and T's size matches ALLOCATION_SIZE_BYTES\n+     * the pool's memory is used. Otherwise, the allocation is forwarded to ::operator new().\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        if constexpr (ALLOCATION_SIZE_BYTES == detail::RequiredAllocationSizeBytes<T>()) {\n+            if (n != 1) {\n+                // pool is not used so forward to operator new.\n+                return static_cast<T*>(::operator new(n * sizeof(T)));\n+            }\n+\n+            if (m_free_allocations) {\n+                // we've already got data in the free list, unlink one element\n+                auto old_head = m_free_allocations;\n+                m_free_allocations = static_cast<detail::FreeList*>(m_free_allocations)->next;\n+                return static_cast<T*>(old_head);\n+            }\n+\n+            // free list is empty: get one allocation from allocated pool memory.\n+            // It makes sense to not create the fully linked list of an allocated pool up-front, for\n+            // several reasons. On the one hand, the latency is higher when we need to iterate and\n+            // update pointers for the whole pool at once. More importantly, most systems lazily\n+            // allocate data. So when we allocate a big pool of memory the memory for a page is only\n+            // actually made available to the program when it is first touched. So when we allocate\n+            // a big pool and only use very little memory from it, the total memory usage is lower\n+            // than what has been malloc'ed.\n+            if (m_untouched_memory_iterator == m_untouched_memory_end) {\n+                // slow path, only happens when a new pool needs to be allocated\n+                AllocatePool();\n+            }\n+\n+            // peel off one allocation from the untouched memory. The next pointer of in-use\n+            // elements doesn't matter until it is deallocated, only then it is used to form the\n+            // free list.\n+            const auto tmp = m_untouched_memory_iterator;\n+            m_untouched_memory_iterator = static_cast<char*>(tmp) + ALLOCATION_SIZE_BYTES;\n+            return static_cast<T*>(tmp);\n+        } else {\n+            // pool is not used so forward to operator new.\n+            return static_cast<T*>(::operator new(n * sizeof(T)));\n+        }\n+    }\n+\n+    /**\n+     * Puts p back into the free list if it was actually allocated from the memory pool.\n+     * Otherwise, simply call ::operator delete(p).\n+     */\n+    template <typename T>\n+    void Deallocate(void* p, size_t n) noexcept\n+    {\n+        if constexpr (ALLOCATION_SIZE_BYTES == detail::RequiredAllocationSizeBytes<T>()) {\n+            if (n != 1) {\n+                // allocation didn't happen with the pool\n+                ::operator delete(p);\n+                return;\n+            }\n+\n+            // put it into the linked list\n+            const auto allocation = static_cast<detail::FreeList*>(p);\n+            allocation->next = m_free_allocations;\n+            m_free_allocations = allocation;\n+        } else {\n+            // allocation didn't happen with the pool\n+            ::operator delete(p);\n+        }\n+    }\n+\n+    /**\n+     * Calculates bytes allocated by the memory resource.\n+     */\n+    [[nodiscard]] size_t DynamicMemoryUsage() const noexcept\n+    {\n+        return memusage::MallocUsage(POOL_SIZE_BYTES) * m_allocated_pools.size() + memusage::DynamicUsage(m_allocated_pools);\n+    }\n+\n+private:\n+    //! Access to internals for testing purpose only\n+    friend class MemoryResourceTester;\n+\n+    /**\n+     * Allocate one full memory pool which is used to carve out allocations.\n+     */\n+    void AllocatePool()\n+    {\n+        m_allocated_pools.emplace_back(new char[POOL_SIZE_BYTES]);\n+        m_untouched_memory_iterator = m_allocated_pools.back().get();\n+        m_untouched_memory_end = m_allocated_pools.back().get() + POOL_SIZE_BYTES;\n+    }\n+\n+    //! Contains all allocated pools of memory, used to free the data in the destructor.\n+    std::vector<std::unique_ptr<char[]>> m_allocated_pools{};\n+\n+    //! A single linked list of all data available in the MemoryResource. This list is used for\n+    //! allocations of single elements.\n+    void* m_free_allocations = nullptr;\n+\n+    //! Points to the beginning of available memory for carving out allocations.\n+    void* m_untouched_memory_iterator = nullptr;\n+\n+    //! Points to the end of available memory for carving out allocations.\n+    void* m_untouched_memory_end = nullptr;\n+};\n+\n+\n+/**\n+ * Allocator that's usable for node-based containers like std::unordered_map or std::list.\n+ *\n+ * The allocator is stateful, and can be cheaply copied. Its state is an immobile MemoryResource,\n+ * which actually does all the allocation/deallocations. So this class is just a simple wrapper that\n+ * conforms to the required STL interface to be usable for the node-based containers.\n+ */\n+template <typename T, size_t ALLOCATION_SIZE_BYTES>\n+class Allocator\n+{\n+    template <typename U, size_t AS>\n+    friend class Allocator;\n+\n+    template <typename X, typename Y, size_t AS>\n+    friend bool operator==(const Allocator<X, AS>& a, const Allocator<Y, AS>& b) noexcept;\n+\n+public:\n+    using value_type = T;\n+\n+    /**\n+     * The allocator is stateful so we can't use the compile time `is_always_equal` optimization and\n+     * have to use the runtime operator==.\n+     */\n+    using is_always_equal = std::false_type;\n+\n+    /**\n+     * Move assignment should be a fast operation. In the case of a = std::move(b), we want\n+     * a to be able to use b's allocator, otherwise all elements would have to be recreated with a's\n+     * old allocator.\n+     */\n+    using propagate_on_container_move_assignment = std::true_type;\n+\n+    /**\n+     * Swapping two containers with unequal allocators who are *not* propagated is undefined\n+     * behavior. Unfortunately this is the default! Obviously, we don't want that.\n+     */\n+    using propagate_on_container_swap = std::true_type; // to avoid the undefined behavior\n+\n+    /**\n+     * Move and swap have to propagate the allocator, so for consistency we do the same for copy\n+     * assignment.\n+     */\n+    using propagate_on_container_copy_assignment = std::true_type;\n+\n+    /**\n+     * Construct a new Allocator object which will delegate all allocations/deallocations to the\n+     * memory resource.\n+     */\n+    explicit Allocator(MemoryResource<ALLOCATION_SIZE_BYTES>* memory_resource) noexcept\n+        : m_memory_resource(memory_resource)\n+    {\n+    }\n+\n+    /**\n+     * Conversion constructor for rebinding. All Allocators use the same memory_resource.\n+     *\n+     * The rebound type is determined with the `struct rebind`. The rebind is necessary feature\n+     * for standard allocators, and it happens when the allocator shall be used for different types.\n+     * E.g. for std::unordered_map this happens for allocation of the internally used nodes, for the\n+     * underlying index array, and possibly for some control structure. In fact the type required by\n+     * the standard `std::pair<const Key, Value>` type is never actually used for any allocation\n+     * (which is therefore a stupid requirement, but that's just C++ being C++).\n+     */\n+    template <typename U>\n+    Allocator(const Allocator<U, ALLOCATION_SIZE_BYTES>& other) noexcept\n+        : m_memory_resource(other.m_memory_resource)\n+    {\n+    }\n+\n+    /**\n+     * From the standard: rebind is only optional (provided by std::allocator_traits) if this\n+     * allocator is a template of the form SomeAllocator<T, Args>, where Args is zero or more\n+     * additional template type parameters.\n+     *\n+     * Since we use a size_t as additional argument, it's *not* optional.\n+     * @see https://en.cppreference.com/w/cpp/named_req/Allocator#cite_note-2\n+     */\n+    template <typename U>\n+    struct rebind {\n+        using other = Allocator<U, ALLOCATION_SIZE_BYTES>;\n+    };\n+\n+    /**\n+     * Allocates n entries of the given type.\n+     */\n+    T* allocate(size_t n)\n+    {\n+        // Forward all allocations to the memory_resource\n+        return m_memory_resource->template Allocate<T>(n);\n+    }\n+\n+    /**\n+     * Deallocates n entries of the given type.\n+     */\n+    void deallocate(T* p, size_t n)\n+    {\n+        m_memory_resource->template Deallocate<T>(p, n);\n+    }\n+\n+private:\n+    //! Stateful allocator, where the state is a simple pointer that can be cheaply copied.\n+    MemoryResource<ALLOCATION_SIZE_BYTES>* m_memory_resource;\n+};\n+\n+\n+/**\n+ * Since Allocator is stateful, comparison with another one only returns true if it uses the same\n+ * memory_resource.\n+ */\n+template <typename T, typename U, size_t CS>\n+bool operator==(const Allocator<T, CS>& a, const Allocator<U, CS>& b) noexcept\n+{\n+    // \"Equality of an allocator is determined through the ability of allocating memory with one\n+    // allocator and deallocating it with another.\" - Jonathan M\u00fcller\n+    // See https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+    //\n+    // For us that is the case when both allocators use the same memory resource.\n+    return a.m_memory_resource == b.m_memory_resource;\n+}\n+\n+template <typename T, typename U, size_t CS>\n+bool operator!=(const Allocator<T, CS>& a, const Allocator<U, CS>& b) noexcept\n+{\n+    return !(a == b);\n+}\n+\n+/**\n+ * Helper to create std::unordered_map which uses the node_allocator.\n+ *\n+ * This calculates the size of the container's internally used node correctly for all supported\n+ * platforms, which is also asserted by the unit tests.\n+ */\n+template <typename Key, typename Value, typename Hash = std::hash<Key>, typename Equals = std::equal_to<Key>>\n+class UnorderedMapFactory\n+{\n+public:\n+    static constexpr size_t ALLOCATION_SIZE_BYTES = memusage::NodeSize<std::unordered_map<Key, Value, Hash, Equals>>::Value();\n+    using MemoryResourceType = MemoryResource<ALLOCATION_SIZE_BYTES>;\n+    using AllocatorType = Allocator<std::pair<const Key, Value>, ALLOCATION_SIZE_BYTES>;\n+    using ContainerType = std::unordered_map<Key, Value, Hash, Equals, AllocatorType>;\n+\n+    /**\n+     * Creates the std::unordered_map container, and asserts that the specified memory_resource is\n+     * correct.\n+     */\n+    [[nodiscard]] static ContainerType CreateContainer(MemoryResourceType* memory_resource)",
    "path": "src/support/allocators/node_allocator.h",
    "position": null,
    "original_position": 397,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "a91b6032f037ab1a26ac4baa761e809fbfeb1bdd",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "This `CreateContainer` method seems like a pretty superfluous wrapper around the `ContainerType` constructor. Maybe we don't need a factory class at all and can just provide some template typedefs for ccoins to use:\r\n\r\n```\r\ntemplate<typename BaseContainer>\r\nusing MemoryResourceType = MemoryResource<NodeSize<BaseContainer>::Value()>;\r\n\r\ntemplate<typename BaseContainer>\r\nusing AllocatorType = Allocator<BaseContainer::value_type, NodeSize<BaseContainer>::Value()>;\r\n```\r\n\r\n(Version: a91b6032f037ab1a26ac4baa761e809fbfeb1bdd)",
    "created_at": "2021-10-27T17:24:42Z",
    "updated_at": "2021-10-27T17:37:20Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r737691663",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/737691663"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r737691663"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/737691663/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 417,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/738550995",
    "pull_request_review_id": 792093267,
    "id": 738550995,
    "node_id": "PRRC_kwDOABII584sBWTT",
    "diff_hunk": "@@ -148,23 +154,65 @@ static inline size_t DynamicUsage(const std::shared_ptr<X>& p)\n     return p ? MallocUsage(sizeof(X)) + MallocUsage(sizeof(stl_shared_counter)) : 0;\n }\n \n-template<typename X>\n-struct unordered_node : private X\n-{\n-private:\n-    void* ptr;\n+template <typename T>\n+struct NodeSize {\n+};\n+\n+// It is important that the calculation here matches exactly the behavior of std::unordered_map\n+// so the node_allocator actually works. This is tested in node_allocator_tests/test_allocations_are_used\n+// with multiple configurations (alignments, noexcept hash, node sizes).\n+template <typename Key, typename V, typename Hash, typename Equals, typename Allocator>\n+struct NodeSize<std::unordered_map<Key, V, Hash, Equals, Allocator>> {\n+    [[nodiscard]] static constexpr size_t Value()\n+    {\n+        // libstdc++, libc++, and MSVC implement the nodes differently. To get the correct size\n+        // with the correct alignment, we can simulate that with accordingly nested std::pairs.\n+        using ValueType = std::pair<const Key, V>;",
    "path": "src/memusage.h",
    "position": null,
    "original_position": 35,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "a91b6032f037ab1a26ac4baa761e809fbfeb1bdd",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Putting this comment next to this typedef is a little confusing, because the comment is describing _simulating pairs_ which simulate nonstandard internal data structures, but this pair isn't really simulating anything, since it's actually part of standard container definition.\r\n\r\nWould suggest either moving comment, or only using std::pair for simulated pairs, or doing both things. By only using std::pair for simulated pairs, I mean something like:\r\n\r\n```c++\r\nusing ContainerType = std::unordered_map<Key, Value, Hash, Equals, Alloc>;\r\nusing ValueType = typename ContainerType::value_type;\r\n```\r\n\r\n(Version: a91b6032f037ab1a26ac4baa761e809fbfeb1bdd)",
    "created_at": "2021-10-28T16:15:17Z",
    "updated_at": "2021-10-28T19:29:38Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r738550995",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/738550995"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r738550995"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/738550995/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": 168,
    "start_side": "RIGHT",
    "line": null,
    "original_line": 170,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/738569770",
    "pull_request_review_id": 792093267,
    "id": 738569770,
    "node_id": "PRRC_kwDOABII584sBa4q",
    "diff_hunk": "@@ -148,23 +154,65 @@ static inline size_t DynamicUsage(const std::shared_ptr<X>& p)\n     return p ? MallocUsage(sizeof(X)) + MallocUsage(sizeof(stl_shared_counter)) : 0;\n }\n \n-template<typename X>\n-struct unordered_node : private X\n-{\n-private:\n-    void* ptr;\n+template <typename T>\n+struct NodeSize {\n+};\n+\n+// It is important that the calculation here matches exactly the behavior of std::unordered_map\n+// so the node_allocator actually works. This is tested in node_allocator_tests/test_allocations_are_used\n+// with multiple configurations (alignments, noexcept hash, node sizes).\n+template <typename Key, typename V, typename Hash, typename Equals, typename Allocator>\n+struct NodeSize<std::unordered_map<Key, V, Hash, Equals, Allocator>> {\n+    [[nodiscard]] static constexpr size_t Value()\n+    {\n+        // libstdc++, libc++, and MSVC implement the nodes differently. To get the correct size\n+        // with the correct alignment, we can simulate that with accordingly nested std::pairs.\n+        using ValueType = std::pair<const Key, V>;\n+\n+#if defined(_MSC_VER)\n+        // list node contains 2 pointers and no hash; see\n+        // https://github.com/microsoft/STL/blob/main/stl/inc/unordered_map and\n+        // https://github.com/microsoft/STL/blob/main/stl/inc/list\n+        return sizeof(std::pair<std::pair<void*, void*>, ValueType>);\n+#else\n+\n+#if defined(_LIBCPP_VERSION) // defined in any C++ header from libc++\n+        // libc++ always stores hash and pointer in the node\n+        // see https://github.com/llvm/llvm-project/blob/release/13.x/libcxx/include/__hash_table#L92\n+        return sizeof(std::pair<ValueType, std::pair<size_t, void*>>);\n+#else\n+        // libstdc++ doesn't store hash when its operator() is noexcept;\n+        // see hashtable_policy.h, struct _Hash_node\n+        // https://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a05689.html\n+        if (noexcept(std::declval<Hash>()(std::declval<const Key&>()))) {\n+            return sizeof(std::pair<void*, ValueType>);\n+        } else {\n+            // hash is stored along ValueType, and that is wrapped with the pointer.\n+            return sizeof(std::pair<void*, std::pair<ValueType, size_t>>);\n+        }\n+#endif\n+#endif",
    "path": "src/memusage.h",
    "position": null,
    "original_position": 59,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "a91b6032f037ab1a26ac4baa761e809fbfeb1bdd",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Can you use [#elif](https://en.cppreference.com/w/cpp/preprocessor/conditional) above to get rid of this nesting and just make a flat list of cases?\r\n\r\n(Version: a91b6032f037ab1a26ac4baa761e809fbfeb1bdd)",
    "created_at": "2021-10-28T16:38:33Z",
    "updated_at": "2021-10-28T19:29:38Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r738569770",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/738569770"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r738569770"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/738569770/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": 193,
    "start_side": "RIGHT",
    "line": null,
    "original_line": 188,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/738584696",
    "pull_request_review_id": 792093267,
    "id": 738584696,
    "node_id": "PRRC_kwDOABII584sBeh4",
    "diff_hunk": "@@ -0,0 +1,406 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <memory>\n+#include <new>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based\n+ * containers that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs pools of memory and uses these to carve out memory for the nodes. Nodes\n+ * that are destroyed by the Allocator are actually put back into a free list for further use. This\n+ * behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored\n+ * in-place. This typically saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with\n+ * low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but\n+ * there is no standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to\n+ * the system. Memory is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on\n+ * proximity. So freeing and malloc'ing again can become a random access pattern which can lead to\n+ * more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers.\n+ * Similar to `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages memory. Currently\n+ * it is only able to provide optimized alloc/free for a single fixed allocation size which is given\n+ * in the constructor. Only allocations that match this size will be provided from the preallocated\n+ * pools of memory; all other requests simply use ::operator new(). To get the correct node size in\n+ * all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios\n+ * in `node_allocator_tests/test_allocations_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall \u201cHow to Write a Custom Allocator\u201d\n+ *   https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer \u201cAn Allocator is a Handle to a Heap\u201d\n+ *   https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *   https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+namespace detail {\n+\n+/**\n+ * In-place linked list of the allocations, used for the free list.\n+ */\n+struct FreeList {\n+    void* next;\n+};\n+\n+/**\n+ * Calculates the required allocation size for the given type.\n+ * The memory needs to be correctly aligned and large enough for both both T and FreeList.\n+ */\n+template <typename T>\n+[[nodiscard]] constexpr size_t RequiredAllocationSizeBytes() noexcept\n+{\n+    const auto alignment_max = std::max(std::alignment_of_v<T>, std::alignment_of_v<FreeList>);\n+    const auto size_max = std::max(sizeof(T), sizeof(FreeList));\n+\n+    // find closest multiple of alignment_max that holds size_max\n+    return ((size_max + alignment_max - 1U) / alignment_max) * alignment_max;\n+}\n+\n+} // namespace detail\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It\n+ * stores a number of memory pools which are used to quickly give out memory of a fixed allocation\n+ * size. The class is purposely kept very simple. It only knows about \"Allocations\" and \"Pools\".\n+ *\n+ * - Pool: MemoryResource allocates one memory pool at a time. These pools are kept around until the\n+ * memory resource is destroyed.\n+ *\n+ * - Allocations: Node-based containers allocate one node at a time. Whenever that happens, the\n+ * MemoryResource's Allocate() gives out memory for one node. These are carved out from a previously\n+ * allocated memory pool, or from a free list if it contains entries. Whenever a node is given back\n+ * with Deallocate(), it is put into that free list.\n+ */\n+template <size_t ALLOCATION_SIZE_BYTES>\n+class MemoryResource\n+{\n+    /**\n+     * Size in bytes to allocate per pool, currently hardcoded to multiple of ALLOCATION_SIZE_BYTES\n+     * that comes closest to 256 KiB.\n+     */\n+    static constexpr size_t POOL_SIZE_BYTES = (262144 / ALLOCATION_SIZE_BYTES) * ALLOCATION_SIZE_BYTES;\n+\n+public:\n+    /**\n+     * Construct a new MemoryResource object that uses the specified allocation size to optimize for.\n+     */\n+    MemoryResource() = default;\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated pools.\n+     *\n+     * There's no Clear() method on purpose, because it would be dangerous. E.g. when calling\n+     * clear() on an unordered_map, it is not certain that all allocated nodes are given back to the\n+     * MemoryResource. Microsoft's STL still uses a control structure that might have the same size\n+     * as the nodes, and therefore needs to be kept around until the map is actually destroyed.\n+     */\n+    ~MemoryResource() = default;\n+\n+    /**\n+     * Allocates memory for n * sizeof(T). Only when n==1 and T's size matches ALLOCATION_SIZE_BYTES\n+     * the pool's memory is used. Otherwise, the allocation is forwarded to ::operator new().\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        if constexpr (ALLOCATION_SIZE_BYTES == detail::RequiredAllocationSizeBytes<T>()) {\n+            if (n != 1) {\n+                // pool is not used so forward to operator new.\n+                return static_cast<T*>(::operator new(n * sizeof(T)));\n+            }\n+\n+            if (m_free_allocations) {\n+                // we've already got data in the free list, unlink one element\n+                auto old_head = m_free_allocations;\n+                m_free_allocations = static_cast<detail::FreeList*>(m_free_allocations)->next;\n+                return static_cast<T*>(old_head);\n+            }\n+\n+            // free list is empty: get one allocation from allocated pool memory.\n+            // It makes sense to not create the fully linked list of an allocated pool up-front, for\n+            // several reasons. On the one hand, the latency is higher when we need to iterate and\n+            // update pointers for the whole pool at once. More importantly, most systems lazily\n+            // allocate data. So when we allocate a big pool of memory the memory for a page is only\n+            // actually made available to the program when it is first touched. So when we allocate\n+            // a big pool and only use very little memory from it, the total memory usage is lower\n+            // than what has been malloc'ed.\n+            if (m_untouched_memory_iterator == m_untouched_memory_end) {\n+                // slow path, only happens when a new pool needs to be allocated\n+                AllocatePool();\n+            }\n+\n+            // peel off one allocation from the untouched memory. The next pointer of in-use\n+            // elements doesn't matter until it is deallocated, only then it is used to form the\n+            // free list.\n+            const auto tmp = m_untouched_memory_iterator;\n+            m_untouched_memory_iterator = static_cast<char*>(tmp) + ALLOCATION_SIZE_BYTES;\n+            return static_cast<T*>(tmp);\n+        } else {\n+            // pool is not used so forward to operator new.\n+            return static_cast<T*>(::operator new(n * sizeof(T)));\n+        }\n+    }\n+\n+    /**\n+     * Puts p back into the free list if it was actually allocated from the memory pool.\n+     * Otherwise, simply call ::operator delete(p).\n+     */\n+    template <typename T>\n+    void Deallocate(void* p, size_t n) noexcept\n+    {\n+        if constexpr (ALLOCATION_SIZE_BYTES == detail::RequiredAllocationSizeBytes<T>()) {\n+            if (n != 1) {\n+                // allocation didn't happen with the pool\n+                ::operator delete(p);\n+                return;\n+            }\n+\n+            // put it into the linked list\n+            const auto allocation = static_cast<detail::FreeList*>(p);\n+            allocation->next = m_free_allocations;\n+            m_free_allocations = allocation;\n+        } else {\n+            // allocation didn't happen with the pool\n+            ::operator delete(p);\n+        }\n+    }\n+\n+    /**\n+     * Calculates bytes allocated by the memory resource.\n+     */\n+    [[nodiscard]] size_t DynamicMemoryUsage() const noexcept\n+    {\n+        return memusage::MallocUsage(POOL_SIZE_BYTES) * m_allocated_pools.size() + memusage::DynamicUsage(m_allocated_pools);\n+    }\n+\n+private:\n+    //! Access to internals for testing purpose only\n+    friend class MemoryResourceTester;\n+\n+    /**\n+     * Allocate one full memory pool which is used to carve out allocations.\n+     */\n+    void AllocatePool()\n+    {\n+        m_allocated_pools.emplace_back(new char[POOL_SIZE_BYTES]);\n+        m_untouched_memory_iterator = m_allocated_pools.back().get();\n+        m_untouched_memory_end = m_allocated_pools.back().get() + POOL_SIZE_BYTES;\n+    }\n+\n+    //! Contains all allocated pools of memory, used to free the data in the destructor.\n+    std::vector<std::unique_ptr<char[]>> m_allocated_pools{};\n+\n+    //! A single linked list of all data available in the MemoryResource. This list is used for\n+    //! allocations of single elements.\n+    void* m_free_allocations = nullptr;\n+\n+    //! Points to the beginning of available memory for carving out allocations.\n+    void* m_untouched_memory_iterator = nullptr;\n+\n+    //! Points to the end of available memory for carving out allocations.\n+    void* m_untouched_memory_end = nullptr;\n+};\n+\n+\n+/**\n+ * Allocator that's usable for node-based containers like std::unordered_map or std::list.\n+ *\n+ * The allocator is stateful, and can be cheaply copied. Its state is an immobile MemoryResource,\n+ * which actually does all the allocation/deallocations. So this class is just a simple wrapper that\n+ * conforms to the required STL interface to be usable for the node-based containers.\n+ */\n+template <typename T, size_t ALLOCATION_SIZE_BYTES>\n+class Allocator\n+{\n+    template <typename U, size_t AS>\n+    friend class Allocator;\n+\n+    template <typename X, typename Y, size_t AS>\n+    friend bool operator==(const Allocator<X, AS>& a, const Allocator<Y, AS>& b) noexcept;\n+\n+public:\n+    using value_type = T;\n+\n+    /**\n+     * The allocator is stateful so we can't use the compile time `is_always_equal` optimization and\n+     * have to use the runtime operator==.\n+     */\n+    using is_always_equal = std::false_type;\n+\n+    /**\n+     * Move assignment should be a fast operation. In the case of a = std::move(b), we want\n+     * a to be able to use b's allocator, otherwise all elements would have to be recreated with a's\n+     * old allocator.\n+     */\n+    using propagate_on_container_move_assignment = std::true_type;\n+\n+    /**\n+     * Swapping two containers with unequal allocators who are *not* propagated is undefined\n+     * behavior. Unfortunately this is the default! Obviously, we don't want that.\n+     */\n+    using propagate_on_container_swap = std::true_type; // to avoid the undefined behavior\n+\n+    /**\n+     * Move and swap have to propagate the allocator, so for consistency we do the same for copy\n+     * assignment.\n+     */\n+    using propagate_on_container_copy_assignment = std::true_type;\n+\n+    /**\n+     * Construct a new Allocator object which will delegate all allocations/deallocations to the\n+     * memory resource.\n+     */\n+    explicit Allocator(MemoryResource<ALLOCATION_SIZE_BYTES>* memory_resource) noexcept\n+        : m_memory_resource(memory_resource)\n+    {\n+    }\n+\n+    /**\n+     * Conversion constructor for rebinding. All Allocators use the same memory_resource.\n+     *\n+     * The rebound type is determined with the `struct rebind`. The rebind is necessary feature\n+     * for standard allocators, and it happens when the allocator shall be used for different types.\n+     * E.g. for std::unordered_map this happens for allocation of the internally used nodes, for the\n+     * underlying index array, and possibly for some control structure. In fact the type required by\n+     * the standard `std::pair<const Key, Value>` type is never actually used for any allocation\n+     * (which is therefore a stupid requirement, but that's just C++ being C++).\n+     */\n+    template <typename U>\n+    Allocator(const Allocator<U, ALLOCATION_SIZE_BYTES>& other) noexcept\n+        : m_memory_resource(other.m_memory_resource)\n+    {\n+    }\n+\n+    /**\n+     * From the standard: rebind is only optional (provided by std::allocator_traits) if this\n+     * allocator is a template of the form SomeAllocator<T, Args>, where Args is zero or more\n+     * additional template type parameters.\n+     *\n+     * Since we use a size_t as additional argument, it's *not* optional.\n+     * @see https://en.cppreference.com/w/cpp/named_req/Allocator#cite_note-2\n+     */\n+    template <typename U>\n+    struct rebind {\n+        using other = Allocator<U, ALLOCATION_SIZE_BYTES>;\n+    };\n+\n+    /**\n+     * Allocates n entries of the given type.\n+     */\n+    T* allocate(size_t n)\n+    {\n+        // Forward all allocations to the memory_resource\n+        return m_memory_resource->template Allocate<T>(n);\n+    }\n+\n+    /**\n+     * Deallocates n entries of the given type.\n+     */\n+    void deallocate(T* p, size_t n)\n+    {\n+        m_memory_resource->template Deallocate<T>(p, n);\n+    }\n+\n+private:\n+    //! Stateful allocator, where the state is a simple pointer that can be cheaply copied.\n+    MemoryResource<ALLOCATION_SIZE_BYTES>* m_memory_resource;\n+};\n+\n+\n+/**\n+ * Since Allocator is stateful, comparison with another one only returns true if it uses the same\n+ * memory_resource.\n+ */\n+template <typename T, typename U, size_t CS>\n+bool operator==(const Allocator<T, CS>& a, const Allocator<U, CS>& b) noexcept\n+{\n+    // \"Equality of an allocator is determined through the ability of allocating memory with one\n+    // allocator and deallocating it with another.\" - Jonathan M\u00fcller\n+    // See https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+    //\n+    // For us that is the case when both allocators use the same memory resource.\n+    return a.m_memory_resource == b.m_memory_resource;\n+}\n+\n+template <typename T, typename U, size_t CS>\n+bool operator!=(const Allocator<T, CS>& a, const Allocator<U, CS>& b) noexcept\n+{\n+    return !(a == b);\n+}\n+\n+/**\n+ * Helper to create std::unordered_map which uses the node_allocator.\n+ *\n+ * This calculates the size of the container's internally used node correctly for all supported\n+ * platforms, which is also asserted by the unit tests.\n+ */\n+template <typename Key, typename Value, typename Hash = std::hash<Key>, typename Equals = std::equal_to<Key>>\n+class UnorderedMapFactory\n+{\n+public:\n+    static constexpr size_t ALLOCATION_SIZE_BYTES = memusage::NodeSize<std::unordered_map<Key, Value, Hash, Equals>>::Value();",
    "path": "src/support/allocators/node_allocator.h",
    "position": null,
    "original_position": 388,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "a91b6032f037ab1a26ac4baa761e809fbfeb1bdd",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "In practice, this is probably fine, but logically and in theory, it seems like there is a bug here because this is only using node size to determine allocation size, ignoring node alignment and FreeList size and alignment. It seems like this should be using the `RequiredAllocationSizeBytes` function to take these things into account, like:\r\n\r\n```diff\r\ndiff --git a/src/support/allocators/node_allocator.h b/src/support/allocators/node_allocator.h\r\nindex 7ff94d39700..5b667ca99b8 100644\r\n--- a/src/support/allocators/node_allocator.h\r\n+++ b/src/support/allocators/node_allocator.h\r\n@@ -385,7 +385,8 @@ template <typename Key, typename Value, typename Hash = std::hash<Key>, typename\r\n class UnorderedMapFactory\r\n {\r\n public:\r\n-    static constexpr size_t ALLOCATION_SIZE_BYTES = memusage::NodeSize<std::unordered_map<Key, Value, Hash, Equals>>::Value();\r\n+    static constexpr size_t ALLOCATION_SIZE_BYTES = detail::RequiredAllocationSizeBytes<typename\r\n+                                                    memusage::NodeSize<std::unordered_map<Key, Value, Hash, Equals>>::NodeType>();\r\n     using MemoryResourceType = MemoryResource<ALLOCATION_SIZE_BYTES>;\r\n     using AllocatorType = Allocator<std::pair<const Key, Value>, ALLOCATION_SIZE_BYTES>;\r\n     using ContainerType = std::unordered_map<Key, Value, Hash, Equals, AllocatorType>;\r\ndiff --git a/src/memusage.h b/src/memusage.h\r\nindex fd781f77bf5..af1f33963d6 100644\r\n--- a/src/memusage.h\r\n+++ b/src/memusage.h\r\n@@ -163,35 +163,38 @@ struct NodeSize {\r\n // with multiple configurations (alignments, noexcept hash, node sizes).\r\n template <typename Key, typename V, typename Hash, typename Equals, typename Allocator>\r\n struct NodeSize<std::unordered_map<Key, V, Hash, Equals, Allocator>> {\r\n-    [[nodiscard]] static constexpr size_t Value()\r\n-    {\r\n         // libstdc++, libc++, and MSVC implement the nodes differently. To get the correct size\r\n         // with the correct alignment, we can simulate that with accordingly nested std::pairs.\r\n         using ValueType = std::pair<const Key, V>;\r\n+        using NodeType =\r\n \r\n #if defined(_MSC_VER)\r\n         // list node contains 2 pointers and no hash; see\r\n         // https://github.com/microsoft/STL/blob/main/stl/inc/unordered_map and\r\n         // https://github.com/microsoft/STL/blob/main/stl/inc/list\r\n-        return sizeof(std::pair<std::pair<void*, void*>, ValueType>);\r\n+                      std::pair<std::pair<void*, void*>, ValueType>\r\n #else\r\n \r\n #if defined(_LIBCPP_VERSION) // defined in any C++ header from libc++\r\n         // libc++ always stores hash and pointer in the node\r\n         // see https://github.com/llvm/llvm-project/blob/release/13.x/libcxx/include/__hash_table#L92\r\n-        return sizeof(std::pair<ValueType, std::pair<size_t, void*>>);\r\n+                      std::pair<ValueType, std::pair<size_t, void*>>\r\n #else\r\n+        std::conditional_t<\r\n         // libstdc++ doesn't store hash when its operator() is noexcept;\r\n         // see hashtable_policy.h, struct _Hash_node\r\n         // https://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a05689.html\r\n-        if (noexcept(std::declval<Hash>()(std::declval<const Key&>()))) {\r\n-            return sizeof(std::pair<void*, ValueType>);\r\n-        } else {\r\n+            noexcept(std::declval<Hash>()(std::declval<const Key&>())),\r\n+                          std::pair<void*, ValueType>,\r\n             // hash is stored along ValueType, and that is wrapped with the pointer.\r\n-            return sizeof(std::pair<void*, std::pair<ValueType, size_t>>);\r\n-        }\r\n+                          std::pair<void*, std::pair<ValueType, size_t>>\r\n+        >\r\n #endif\r\n #endif\r\n+    ;\r\n+    [[nodiscard]] static constexpr size_t Value()\r\n+    {\r\n+        return sizeof(NodeType);\r\n     }\r\n };\r\n \r\n``` \r\n\r\nFix above is trying to be minimal but it could be cleaned up more by renaming `NodeSize` to something like `ContainerTraits` and dropping the `Value()` method.\r\n\r\n(Version: a91b6032f037ab1a26ac4baa761e809fbfeb1bdd)",
    "created_at": "2021-10-28T16:57:56Z",
    "updated_at": "2021-10-28T19:29:38Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r738584696",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/738584696"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r738584696"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/738584696/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 388,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/738591542",
    "pull_request_review_id": 792093267,
    "id": 738591542,
    "node_id": "PRRC_kwDOABII584sBgM2",
    "diff_hunk": "@@ -0,0 +1,406 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <memory>\n+#include <new>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based\n+ * containers that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs pools of memory and uses these to carve out memory for the nodes. Nodes\n+ * that are destroyed by the Allocator are actually put back into a free list for further use. This\n+ * behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored\n+ * in-place. This typically saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with\n+ * low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but\n+ * there is no standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to\n+ * the system. Memory is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on\n+ * proximity. So freeing and malloc'ing again can become a random access pattern which can lead to\n+ * more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers.\n+ * Similar to `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages memory. Currently\n+ * it is only able to provide optimized alloc/free for a single fixed allocation size which is given\n+ * in the constructor. Only allocations that match this size will be provided from the preallocated\n+ * pools of memory; all other requests simply use ::operator new(). To get the correct node size in\n+ * all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios\n+ * in `node_allocator_tests/test_allocations_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall \u201cHow to Write a Custom Allocator\u201d\n+ *   https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer \u201cAn Allocator is a Handle to a Heap\u201d\n+ *   https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *   https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+namespace detail {\n+\n+/**\n+ * In-place linked list of the allocations, used for the free list.\n+ */\n+struct FreeList {\n+    void* next;\n+};\n+\n+/**\n+ * Calculates the required allocation size for the given type.\n+ * The memory needs to be correctly aligned and large enough for both both T and FreeList.\n+ */\n+template <typename T>\n+[[nodiscard]] constexpr size_t RequiredAllocationSizeBytes() noexcept\n+{\n+    const auto alignment_max = std::max(std::alignment_of_v<T>, std::alignment_of_v<FreeList>);\n+    const auto size_max = std::max(sizeof(T), sizeof(FreeList));\n+\n+    // find closest multiple of alignment_max that holds size_max\n+    return ((size_max + alignment_max - 1U) / alignment_max) * alignment_max;\n+}\n+\n+} // namespace detail\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It\n+ * stores a number of memory pools which are used to quickly give out memory of a fixed allocation\n+ * size. The class is purposely kept very simple. It only knows about \"Allocations\" and \"Pools\".\n+ *\n+ * - Pool: MemoryResource allocates one memory pool at a time. These pools are kept around until the\n+ * memory resource is destroyed.\n+ *\n+ * - Allocations: Node-based containers allocate one node at a time. Whenever that happens, the\n+ * MemoryResource's Allocate() gives out memory for one node. These are carved out from a previously\n+ * allocated memory pool, or from a free list if it contains entries. Whenever a node is given back\n+ * with Deallocate(), it is put into that free list.\n+ */\n+template <size_t ALLOCATION_SIZE_BYTES>\n+class MemoryResource\n+{\n+    /**\n+     * Size in bytes to allocate per pool, currently hardcoded to multiple of ALLOCATION_SIZE_BYTES\n+     * that comes closest to 256 KiB.\n+     */\n+    static constexpr size_t POOL_SIZE_BYTES = (262144 / ALLOCATION_SIZE_BYTES) * ALLOCATION_SIZE_BYTES;\n+\n+public:\n+    /**\n+     * Construct a new MemoryResource object that uses the specified allocation size to optimize for.\n+     */\n+    MemoryResource() = default;\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated pools.\n+     *\n+     * There's no Clear() method on purpose, because it would be dangerous. E.g. when calling\n+     * clear() on an unordered_map, it is not certain that all allocated nodes are given back to the\n+     * MemoryResource. Microsoft's STL still uses a control structure that might have the same size\n+     * as the nodes, and therefore needs to be kept around until the map is actually destroyed.\n+     */\n+    ~MemoryResource() = default;\n+\n+    /**\n+     * Allocates memory for n * sizeof(T). Only when n==1 and T's size matches ALLOCATION_SIZE_BYTES\n+     * the pool's memory is used. Otherwise, the allocation is forwarded to ::operator new().\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        if constexpr (ALLOCATION_SIZE_BYTES == detail::RequiredAllocationSizeBytes<T>()) {\n+            if (n != 1) {\n+                // pool is not used so forward to operator new.\n+                return static_cast<T*>(::operator new(n * sizeof(T)));\n+            }\n+\n+            if (m_free_allocations) {\n+                // we've already got data in the free list, unlink one element\n+                auto old_head = m_free_allocations;\n+                m_free_allocations = static_cast<detail::FreeList*>(m_free_allocations)->next;\n+                return static_cast<T*>(old_head);\n+            }\n+\n+            // free list is empty: get one allocation from allocated pool memory.\n+            // It makes sense to not create the fully linked list of an allocated pool up-front, for\n+            // several reasons. On the one hand, the latency is higher when we need to iterate and\n+            // update pointers for the whole pool at once. More importantly, most systems lazily\n+            // allocate data. So when we allocate a big pool of memory the memory for a page is only\n+            // actually made available to the program when it is first touched. So when we allocate\n+            // a big pool and only use very little memory from it, the total memory usage is lower\n+            // than what has been malloc'ed.\n+            if (m_untouched_memory_iterator == m_untouched_memory_end) {\n+                // slow path, only happens when a new pool needs to be allocated\n+                AllocatePool();\n+            }\n+\n+            // peel off one allocation from the untouched memory. The next pointer of in-use\n+            // elements doesn't matter until it is deallocated, only then it is used to form the\n+            // free list.\n+            const auto tmp = m_untouched_memory_iterator;\n+            m_untouched_memory_iterator = static_cast<char*>(tmp) + ALLOCATION_SIZE_BYTES;\n+            return static_cast<T*>(tmp);\n+        } else {\n+            // pool is not used so forward to operator new.\n+            return static_cast<T*>(::operator new(n * sizeof(T)));\n+        }\n+    }\n+\n+    /**\n+     * Puts p back into the free list if it was actually allocated from the memory pool.\n+     * Otherwise, simply call ::operator delete(p).\n+     */\n+    template <typename T>\n+    void Deallocate(void* p, size_t n) noexcept\n+    {\n+        if constexpr (ALLOCATION_SIZE_BYTES == detail::RequiredAllocationSizeBytes<T>()) {\n+            if (n != 1) {\n+                // allocation didn't happen with the pool\n+                ::operator delete(p);\n+                return;\n+            }\n+\n+            // put it into the linked list\n+            const auto allocation = static_cast<detail::FreeList*>(p);\n+            allocation->next = m_free_allocations;\n+            m_free_allocations = allocation;\n+        } else {\n+            // allocation didn't happen with the pool\n+            ::operator delete(p);\n+        }\n+    }\n+\n+    /**\n+     * Calculates bytes allocated by the memory resource.\n+     */\n+    [[nodiscard]] size_t DynamicMemoryUsage() const noexcept\n+    {\n+        return memusage::MallocUsage(POOL_SIZE_BYTES) * m_allocated_pools.size() + memusage::DynamicUsage(m_allocated_pools);\n+    }\n+\n+private:\n+    //! Access to internals for testing purpose only\n+    friend class MemoryResourceTester;\n+\n+    /**\n+     * Allocate one full memory pool which is used to carve out allocations.\n+     */\n+    void AllocatePool()\n+    {\n+        m_allocated_pools.emplace_back(new char[POOL_SIZE_BYTES]);\n+        m_untouched_memory_iterator = m_allocated_pools.back().get();\n+        m_untouched_memory_end = m_allocated_pools.back().get() + POOL_SIZE_BYTES;\n+    }\n+\n+    //! Contains all allocated pools of memory, used to free the data in the destructor.\n+    std::vector<std::unique_ptr<char[]>> m_allocated_pools{};\n+\n+    //! A single linked list of all data available in the MemoryResource. This list is used for\n+    //! allocations of single elements.\n+    void* m_free_allocations = nullptr;\n+\n+    //! Points to the beginning of available memory for carving out allocations.\n+    void* m_untouched_memory_iterator = nullptr;\n+\n+    //! Points to the end of available memory for carving out allocations.\n+    void* m_untouched_memory_end = nullptr;\n+};\n+\n+\n+/**\n+ * Allocator that's usable for node-based containers like std::unordered_map or std::list.\n+ *\n+ * The allocator is stateful, and can be cheaply copied. Its state is an immobile MemoryResource,\n+ * which actually does all the allocation/deallocations. So this class is just a simple wrapper that\n+ * conforms to the required STL interface to be usable for the node-based containers.\n+ */\n+template <typename T, size_t ALLOCATION_SIZE_BYTES>\n+class Allocator\n+{\n+    template <typename U, size_t AS>\n+    friend class Allocator;\n+\n+    template <typename X, typename Y, size_t AS>\n+    friend bool operator==(const Allocator<X, AS>& a, const Allocator<Y, AS>& b) noexcept;\n+\n+public:\n+    using value_type = T;\n+\n+    /**\n+     * The allocator is stateful so we can't use the compile time `is_always_equal` optimization and\n+     * have to use the runtime operator==.\n+     */\n+    using is_always_equal = std::false_type;\n+\n+    /**\n+     * Move assignment should be a fast operation. In the case of a = std::move(b), we want\n+     * a to be able to use b's allocator, otherwise all elements would have to be recreated with a's\n+     * old allocator.\n+     */\n+    using propagate_on_container_move_assignment = std::true_type;\n+\n+    /**\n+     * Swapping two containers with unequal allocators who are *not* propagated is undefined\n+     * behavior. Unfortunately this is the default! Obviously, we don't want that.",
    "path": "src/support/allocators/node_allocator.h",
    "position": null,
    "original_position": 286,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "a91b6032f037ab1a26ac4baa761e809fbfeb1bdd",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "I'm curious why this is phrased negatively. Is there some downside to swapping allocators when containers are swapped? Swapping everything in the container when the container is swapped seems like the obvious and good thing to do.\r\n\r\n(Version: a91b6032f037ab1a26ac4baa761e809fbfeb1bdd)\r\n",
    "created_at": "2021-10-28T17:07:16Z",
    "updated_at": "2021-10-28T19:29:38Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r738591542",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/738591542"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r738591542"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/738591542/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": 285,
    "start_side": "RIGHT",
    "line": null,
    "original_line": 286,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/738593890",
    "pull_request_review_id": 792093267,
    "id": 738593890,
    "node_id": "PRRC_kwDOABII584sBgxi",
    "diff_hunk": "@@ -0,0 +1,406 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <memory>\n+#include <new>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based\n+ * containers that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs pools of memory and uses these to carve out memory for the nodes. Nodes\n+ * that are destroyed by the Allocator are actually put back into a free list for further use. This\n+ * behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored\n+ * in-place. This typically saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with\n+ * low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but\n+ * there is no standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to\n+ * the system. Memory is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on\n+ * proximity. So freeing and malloc'ing again can become a random access pattern which can lead to\n+ * more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers.\n+ * Similar to `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages memory. Currently\n+ * it is only able to provide optimized alloc/free for a single fixed allocation size which is given\n+ * in the constructor. Only allocations that match this size will be provided from the preallocated\n+ * pools of memory; all other requests simply use ::operator new(). To get the correct node size in\n+ * all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios\n+ * in `node_allocator_tests/test_allocations_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall \u201cHow to Write a Custom Allocator\u201d\n+ *   https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer \u201cAn Allocator is a Handle to a Heap\u201d\n+ *   https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *   https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+namespace detail {\n+\n+/**\n+ * In-place linked list of the allocations, used for the free list.\n+ */\n+struct FreeList {\n+    void* next;\n+};\n+\n+/**\n+ * Calculates the required allocation size for the given type.\n+ * The memory needs to be correctly aligned and large enough for both both T and FreeList.\n+ */\n+template <typename T>\n+[[nodiscard]] constexpr size_t RequiredAllocationSizeBytes() noexcept\n+{\n+    const auto alignment_max = std::max(std::alignment_of_v<T>, std::alignment_of_v<FreeList>);\n+    const auto size_max = std::max(sizeof(T), sizeof(FreeList));\n+\n+    // find closest multiple of alignment_max that holds size_max\n+    return ((size_max + alignment_max - 1U) / alignment_max) * alignment_max;\n+}\n+\n+} // namespace detail\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It\n+ * stores a number of memory pools which are used to quickly give out memory of a fixed allocation\n+ * size. The class is purposely kept very simple. It only knows about \"Allocations\" and \"Pools\".\n+ *\n+ * - Pool: MemoryResource allocates one memory pool at a time. These pools are kept around until the\n+ * memory resource is destroyed.\n+ *\n+ * - Allocations: Node-based containers allocate one node at a time. Whenever that happens, the\n+ * MemoryResource's Allocate() gives out memory for one node. These are carved out from a previously\n+ * allocated memory pool, or from a free list if it contains entries. Whenever a node is given back\n+ * with Deallocate(), it is put into that free list.\n+ */\n+template <size_t ALLOCATION_SIZE_BYTES>\n+class MemoryResource\n+{\n+    /**\n+     * Size in bytes to allocate per pool, currently hardcoded to multiple of ALLOCATION_SIZE_BYTES\n+     * that comes closest to 256 KiB.\n+     */\n+    static constexpr size_t POOL_SIZE_BYTES = (262144 / ALLOCATION_SIZE_BYTES) * ALLOCATION_SIZE_BYTES;\n+\n+public:\n+    /**\n+     * Construct a new MemoryResource object that uses the specified allocation size to optimize for.\n+     */\n+    MemoryResource() = default;\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated pools.\n+     *\n+     * There's no Clear() method on purpose, because it would be dangerous. E.g. when calling\n+     * clear() on an unordered_map, it is not certain that all allocated nodes are given back to the\n+     * MemoryResource. Microsoft's STL still uses a control structure that might have the same size\n+     * as the nodes, and therefore needs to be kept around until the map is actually destroyed.\n+     */\n+    ~MemoryResource() = default;\n+\n+    /**\n+     * Allocates memory for n * sizeof(T). Only when n==1 and T's size matches ALLOCATION_SIZE_BYTES\n+     * the pool's memory is used. Otherwise, the allocation is forwarded to ::operator new().\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        if constexpr (ALLOCATION_SIZE_BYTES == detail::RequiredAllocationSizeBytes<T>()) {\n+            if (n != 1) {\n+                // pool is not used so forward to operator new.\n+                return static_cast<T*>(::operator new(n * sizeof(T)));\n+            }\n+\n+            if (m_free_allocations) {\n+                // we've already got data in the free list, unlink one element\n+                auto old_head = m_free_allocations;\n+                m_free_allocations = static_cast<detail::FreeList*>(m_free_allocations)->next;\n+                return static_cast<T*>(old_head);\n+            }\n+\n+            // free list is empty: get one allocation from allocated pool memory.\n+            // It makes sense to not create the fully linked list of an allocated pool up-front, for\n+            // several reasons. On the one hand, the latency is higher when we need to iterate and\n+            // update pointers for the whole pool at once. More importantly, most systems lazily\n+            // allocate data. So when we allocate a big pool of memory the memory for a page is only\n+            // actually made available to the program when it is first touched. So when we allocate\n+            // a big pool and only use very little memory from it, the total memory usage is lower\n+            // than what has been malloc'ed.\n+            if (m_untouched_memory_iterator == m_untouched_memory_end) {\n+                // slow path, only happens when a new pool needs to be allocated\n+                AllocatePool();\n+            }\n+\n+            // peel off one allocation from the untouched memory. The next pointer of in-use\n+            // elements doesn't matter until it is deallocated, only then it is used to form the\n+            // free list.\n+            const auto tmp = m_untouched_memory_iterator;\n+            m_untouched_memory_iterator = static_cast<char*>(tmp) + ALLOCATION_SIZE_BYTES;\n+            return static_cast<T*>(tmp);\n+        } else {\n+            // pool is not used so forward to operator new.\n+            return static_cast<T*>(::operator new(n * sizeof(T)));\n+        }\n+    }\n+\n+    /**\n+     * Puts p back into the free list if it was actually allocated from the memory pool.\n+     * Otherwise, simply call ::operator delete(p).\n+     */\n+    template <typename T>\n+    void Deallocate(void* p, size_t n) noexcept\n+    {\n+        if constexpr (ALLOCATION_SIZE_BYTES == detail::RequiredAllocationSizeBytes<T>()) {\n+            if (n != 1) {\n+                // allocation didn't happen with the pool\n+                ::operator delete(p);\n+                return;\n+            }\n+\n+            // put it into the linked list\n+            const auto allocation = static_cast<detail::FreeList*>(p);\n+            allocation->next = m_free_allocations;\n+            m_free_allocations = allocation;\n+        } else {\n+            // allocation didn't happen with the pool\n+            ::operator delete(p);\n+        }\n+    }\n+\n+    /**\n+     * Calculates bytes allocated by the memory resource.\n+     */\n+    [[nodiscard]] size_t DynamicMemoryUsage() const noexcept\n+    {\n+        return memusage::MallocUsage(POOL_SIZE_BYTES) * m_allocated_pools.size() + memusage::DynamicUsage(m_allocated_pools);\n+    }\n+\n+private:\n+    //! Access to internals for testing purpose only\n+    friend class MemoryResourceTester;\n+\n+    /**\n+     * Allocate one full memory pool which is used to carve out allocations.\n+     */\n+    void AllocatePool()\n+    {\n+        m_allocated_pools.emplace_back(new char[POOL_SIZE_BYTES]);\n+        m_untouched_memory_iterator = m_allocated_pools.back().get();\n+        m_untouched_memory_end = m_allocated_pools.back().get() + POOL_SIZE_BYTES;\n+    }\n+\n+    //! Contains all allocated pools of memory, used to free the data in the destructor.\n+    std::vector<std::unique_ptr<char[]>> m_allocated_pools{};\n+\n+    //! A single linked list of all data available in the MemoryResource. This list is used for\n+    //! allocations of single elements.\n+    void* m_free_allocations = nullptr;\n+\n+    //! Points to the beginning of available memory for carving out allocations.\n+    void* m_untouched_memory_iterator = nullptr;\n+\n+    //! Points to the end of available memory for carving out allocations.\n+    void* m_untouched_memory_end = nullptr;\n+};\n+\n+\n+/**\n+ * Allocator that's usable for node-based containers like std::unordered_map or std::list.\n+ *\n+ * The allocator is stateful, and can be cheaply copied. Its state is an immobile MemoryResource,\n+ * which actually does all the allocation/deallocations. So this class is just a simple wrapper that\n+ * conforms to the required STL interface to be usable for the node-based containers.\n+ */\n+template <typename T, size_t ALLOCATION_SIZE_BYTES>\n+class Allocator\n+{\n+    template <typename U, size_t AS>\n+    friend class Allocator;\n+\n+    template <typename X, typename Y, size_t AS>\n+    friend bool operator==(const Allocator<X, AS>& a, const Allocator<Y, AS>& b) noexcept;\n+\n+public:\n+    using value_type = T;\n+\n+    /**\n+     * The allocator is stateful so we can't use the compile time `is_always_equal` optimization and\n+     * have to use the runtime operator==.\n+     */\n+    using is_always_equal = std::false_type;\n+\n+    /**\n+     * Move assignment should be a fast operation. In the case of a = std::move(b), we want\n+     * a to be able to use b's allocator, otherwise all elements would have to be recreated with a's\n+     * old allocator.\n+     */\n+    using propagate_on_container_move_assignment = std::true_type;\n+\n+    /**\n+     * Swapping two containers with unequal allocators who are *not* propagated is undefined\n+     * behavior. Unfortunately this is the default! Obviously, we don't want that.\n+     */\n+    using propagate_on_container_swap = std::true_type; // to avoid the undefined behavior\n+\n+    /**\n+     * Move and swap have to propagate the allocator, so for consistency we do the same for copy\n+     * assignment.",
    "path": "src/support/allocators/node_allocator.h",
    "position": null,
    "original_position": 292,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "a91b6032f037ab1a26ac4baa761e809fbfeb1bdd",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Again wondering why it's phrased like we \"have to\" do these things. Is there some downside, or some particular way this is not ideal for our use-case?\r\n\r\n(Version: a91b6032f037ab1a26ac4baa761e809fbfeb1bdd)",
    "created_at": "2021-10-28T17:10:21Z",
    "updated_at": "2021-10-28T19:29:38Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r738593890",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/738593890"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r738593890"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/738593890/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": 291,
    "start_side": "RIGHT",
    "line": null,
    "original_line": 289,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/738601940",
    "pull_request_review_id": 792093267,
    "id": 738601940,
    "node_id": "PRRC_kwDOABII584sBivU",
    "diff_hunk": "@@ -0,0 +1,406 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <memory>\n+#include <new>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based\n+ * containers that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs pools of memory and uses these to carve out memory for the nodes. Nodes\n+ * that are destroyed by the Allocator are actually put back into a free list for further use. This\n+ * behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored\n+ * in-place. This typically saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with\n+ * low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but\n+ * there is no standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to\n+ * the system. Memory is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on\n+ * proximity. So freeing and malloc'ing again can become a random access pattern which can lead to\n+ * more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers.\n+ * Similar to `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages memory. Currently\n+ * it is only able to provide optimized alloc/free for a single fixed allocation size which is given\n+ * in the constructor. Only allocations that match this size will be provided from the preallocated\n+ * pools of memory; all other requests simply use ::operator new(). To get the correct node size in\n+ * all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios\n+ * in `node_allocator_tests/test_allocations_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall \u201cHow to Write a Custom Allocator\u201d\n+ *   https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer \u201cAn Allocator is a Handle to a Heap\u201d\n+ *   https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *   https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+namespace detail {\n+\n+/**\n+ * In-place linked list of the allocations, used for the free list.\n+ */\n+struct FreeList {\n+    void* next;\n+};\n+\n+/**\n+ * Calculates the required allocation size for the given type.\n+ * The memory needs to be correctly aligned and large enough for both both T and FreeList.\n+ */\n+template <typename T>\n+[[nodiscard]] constexpr size_t RequiredAllocationSizeBytes() noexcept\n+{\n+    const auto alignment_max = std::max(std::alignment_of_v<T>, std::alignment_of_v<FreeList>);\n+    const auto size_max = std::max(sizeof(T), sizeof(FreeList));\n+\n+    // find closest multiple of alignment_max that holds size_max\n+    return ((size_max + alignment_max - 1U) / alignment_max) * alignment_max;\n+}\n+\n+} // namespace detail\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It\n+ * stores a number of memory pools which are used to quickly give out memory of a fixed allocation\n+ * size. The class is purposely kept very simple. It only knows about \"Allocations\" and \"Pools\".\n+ *\n+ * - Pool: MemoryResource allocates one memory pool at a time. These pools are kept around until the\n+ * memory resource is destroyed.\n+ *\n+ * - Allocations: Node-based containers allocate one node at a time. Whenever that happens, the\n+ * MemoryResource's Allocate() gives out memory for one node. These are carved out from a previously\n+ * allocated memory pool, or from a free list if it contains entries. Whenever a node is given back\n+ * with Deallocate(), it is put into that free list.\n+ */\n+template <size_t ALLOCATION_SIZE_BYTES>\n+class MemoryResource\n+{\n+    /**\n+     * Size in bytes to allocate per pool, currently hardcoded to multiple of ALLOCATION_SIZE_BYTES\n+     * that comes closest to 256 KiB.\n+     */\n+    static constexpr size_t POOL_SIZE_BYTES = (262144 / ALLOCATION_SIZE_BYTES) * ALLOCATION_SIZE_BYTES;\n+\n+public:\n+    /**\n+     * Construct a new MemoryResource object that uses the specified allocation size to optimize for.\n+     */\n+    MemoryResource() = default;\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated pools.\n+     *\n+     * There's no Clear() method on purpose, because it would be dangerous. E.g. when calling\n+     * clear() on an unordered_map, it is not certain that all allocated nodes are given back to the\n+     * MemoryResource. Microsoft's STL still uses a control structure that might have the same size\n+     * as the nodes, and therefore needs to be kept around until the map is actually destroyed.\n+     */\n+    ~MemoryResource() = default;\n+\n+    /**\n+     * Allocates memory for n * sizeof(T). Only when n==1 and T's size matches ALLOCATION_SIZE_BYTES\n+     * the pool's memory is used. Otherwise, the allocation is forwarded to ::operator new().\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        if constexpr (ALLOCATION_SIZE_BYTES == detail::RequiredAllocationSizeBytes<T>()) {\n+            if (n != 1) {\n+                // pool is not used so forward to operator new.\n+                return static_cast<T*>(::operator new(n * sizeof(T)));\n+            }\n+\n+            if (m_free_allocations) {\n+                // we've already got data in the free list, unlink one element\n+                auto old_head = m_free_allocations;\n+                m_free_allocations = static_cast<detail::FreeList*>(m_free_allocations)->next;\n+                return static_cast<T*>(old_head);\n+            }\n+\n+            // free list is empty: get one allocation from allocated pool memory.\n+            // It makes sense to not create the fully linked list of an allocated pool up-front, for\n+            // several reasons. On the one hand, the latency is higher when we need to iterate and\n+            // update pointers for the whole pool at once. More importantly, most systems lazily\n+            // allocate data. So when we allocate a big pool of memory the memory for a page is only\n+            // actually made available to the program when it is first touched. So when we allocate\n+            // a big pool and only use very little memory from it, the total memory usage is lower\n+            // than what has been malloc'ed.\n+            if (m_untouched_memory_iterator == m_untouched_memory_end) {\n+                // slow path, only happens when a new pool needs to be allocated\n+                AllocatePool();\n+            }\n+\n+            // peel off one allocation from the untouched memory. The next pointer of in-use\n+            // elements doesn't matter until it is deallocated, only then it is used to form the\n+            // free list.\n+            const auto tmp = m_untouched_memory_iterator;\n+            m_untouched_memory_iterator = static_cast<char*>(tmp) + ALLOCATION_SIZE_BYTES;\n+            return static_cast<T*>(tmp);\n+        } else {\n+            // pool is not used so forward to operator new.\n+            return static_cast<T*>(::operator new(n * sizeof(T)));\n+        }\n+    }\n+\n+    /**\n+     * Puts p back into the free list if it was actually allocated from the memory pool.\n+     * Otherwise, simply call ::operator delete(p).\n+     */\n+    template <typename T>\n+    void Deallocate(void* p, size_t n) noexcept\n+    {\n+        if constexpr (ALLOCATION_SIZE_BYTES == detail::RequiredAllocationSizeBytes<T>()) {\n+            if (n != 1) {\n+                // allocation didn't happen with the pool\n+                ::operator delete(p);\n+                return;\n+            }\n+\n+            // put it into the linked list\n+            const auto allocation = static_cast<detail::FreeList*>(p);\n+            allocation->next = m_free_allocations;\n+            m_free_allocations = allocation;\n+        } else {\n+            // allocation didn't happen with the pool\n+            ::operator delete(p);\n+        }\n+    }\n+\n+    /**\n+     * Calculates bytes allocated by the memory resource.\n+     */\n+    [[nodiscard]] size_t DynamicMemoryUsage() const noexcept\n+    {\n+        return memusage::MallocUsage(POOL_SIZE_BYTES) * m_allocated_pools.size() + memusage::DynamicUsage(m_allocated_pools);\n+    }\n+\n+private:\n+    //! Access to internals for testing purpose only\n+    friend class MemoryResourceTester;\n+\n+    /**\n+     * Allocate one full memory pool which is used to carve out allocations.\n+     */\n+    void AllocatePool()\n+    {\n+        m_allocated_pools.emplace_back(new char[POOL_SIZE_BYTES]);\n+        m_untouched_memory_iterator = m_allocated_pools.back().get();\n+        m_untouched_memory_end = m_allocated_pools.back().get() + POOL_SIZE_BYTES;\n+    }\n+\n+    //! Contains all allocated pools of memory, used to free the data in the destructor.\n+    std::vector<std::unique_ptr<char[]>> m_allocated_pools{};\n+\n+    //! A single linked list of all data available in the MemoryResource. This list is used for\n+    //! allocations of single elements.\n+    void* m_free_allocations = nullptr;\n+\n+    //! Points to the beginning of available memory for carving out allocations.\n+    void* m_untouched_memory_iterator = nullptr;\n+\n+    //! Points to the end of available memory for carving out allocations.\n+    void* m_untouched_memory_end = nullptr;\n+};\n+\n+\n+/**\n+ * Allocator that's usable for node-based containers like std::unordered_map or std::list.\n+ *\n+ * The allocator is stateful, and can be cheaply copied. Its state is an immobile MemoryResource,\n+ * which actually does all the allocation/deallocations. So this class is just a simple wrapper that\n+ * conforms to the required STL interface to be usable for the node-based containers.\n+ */\n+template <typename T, size_t ALLOCATION_SIZE_BYTES>\n+class Allocator\n+{\n+    template <typename U, size_t AS>\n+    friend class Allocator;\n+\n+    template <typename X, typename Y, size_t AS>\n+    friend bool operator==(const Allocator<X, AS>& a, const Allocator<Y, AS>& b) noexcept;\n+\n+public:\n+    using value_type = T;\n+\n+    /**\n+     * The allocator is stateful so we can't use the compile time `is_always_equal` optimization and\n+     * have to use the runtime operator==.\n+     */\n+    using is_always_equal = std::false_type;\n+\n+    /**\n+     * Move assignment should be a fast operation. In the case of a = std::move(b), we want\n+     * a to be able to use b's allocator, otherwise all elements would have to be recreated with a's\n+     * old allocator.\n+     */\n+    using propagate_on_container_move_assignment = std::true_type;\n+\n+    /**\n+     * Swapping two containers with unequal allocators who are *not* propagated is undefined\n+     * behavior. Unfortunately this is the default! Obviously, we don't want that.\n+     */\n+    using propagate_on_container_swap = std::true_type; // to avoid the undefined behavior\n+\n+    /**\n+     * Move and swap have to propagate the allocator, so for consistency we do the same for copy\n+     * assignment.\n+     */\n+    using propagate_on_container_copy_assignment = std::true_type;\n+\n+    /**\n+     * Construct a new Allocator object which will delegate all allocations/deallocations to the\n+     * memory resource.\n+     */\n+    explicit Allocator(MemoryResource<ALLOCATION_SIZE_BYTES>* memory_resource) noexcept\n+        : m_memory_resource(memory_resource)\n+    {\n+    }\n+\n+    /**\n+     * Conversion constructor for rebinding. All Allocators use the same memory_resource.\n+     *\n+     * The rebound type is determined with the `struct rebind`. The rebind is necessary feature\n+     * for standard allocators, and it happens when the allocator shall be used for different types.\n+     * E.g. for std::unordered_map this happens for allocation of the internally used nodes, for the\n+     * underlying index array, and possibly for some control structure. In fact the type required by\n+     * the standard `std::pair<const Key, Value>` type is never actually used for any allocation\n+     * (which is therefore a stupid requirement, but that's just C++ being C++).",
    "path": "src/support/allocators/node_allocator.h",
    "position": null,
    "original_position": 313,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "a91b6032f037ab1a26ac4baa761e809fbfeb1bdd",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "This is interesting. It seems to suggest about the [concern](https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-941067769) that if \"the object size gets computed incorrectly by a future libstdc++ change... we'll silently fall back to old performance\" that in theory we could detect at compile time, not runtime, whether a container implementation was calling `Allocator::allocate` with an unexpected `T` size for that implementation.\r\n\r\nBut it doesn't seem worth implementing this if it requires lots of template trickery or tracking down compile errors on different platforms, especially if NodeSize unit test coverage works OK practically.\r\n\r\n(Version: a91b6032f037ab1a26ac4baa761e809fbfeb1bdd)",
    "created_at": "2021-10-28T17:22:05Z",
    "updated_at": "2021-10-28T19:29:38Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r738601940",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/738601940"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r738601940"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/738601940/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": 311,
    "start_side": "RIGHT",
    "line": null,
    "original_line": 310,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/738609379",
    "pull_request_review_id": 792093267,
    "id": 738609379,
    "node_id": "PRRC_kwDOABII584sBkjj",
    "diff_hunk": "@@ -0,0 +1,424 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <support/allocators/node_allocator.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <list>\n+#include <map>\n+#include <string>\n+#include <type_traits>\n+#include <unordered_map>\n+\n+namespace node_allocator {\n+\n+class MemoryResourceTester\n+{\n+public:\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static size_t NumFreeAllocations(\n+        MemoryResource<ALLOCATION_SIZE_BYTES> const& mr) noexcept\n+    {\n+        size_t length = 0;\n+        auto allocation = mr.m_free_allocations;\n+        while (allocation) {\n+            allocation = static_cast<detail::FreeList const*>(allocation)->next;\n+            ++length;\n+        }\n+        return length;\n+    }\n+\n+    /**\n+     * Number of memory pools that have been allocated\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static size_t NumPools(MemoryResource<ALLOCATION_SIZE_BYTES> const& mr) noexcept\n+    {\n+        return mr.m_allocated_pools.size();\n+    }\n+\n+\n+    /**\n+     * Extracts allocation size from the type\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static constexpr size_t AllocationSizeBytes(MemoryResource<ALLOCATION_SIZE_BYTES> const&) noexcept\n+    {\n+        return ALLOCATION_SIZE_BYTES;\n+    }\n+};\n+\n+} // namespace node_allocator\n+\n+BOOST_FIXTURE_TEST_SUITE(node_allocator_tests, BasicTestingSetup)\n+\n+#define CHECK_MEMORY_RESOURCE(mr, num_free_allocations, num_pools)                   \\\n+    BOOST_CHECK_EQUAL(num_free_allocations,                                          \\\n+                      node_allocator::MemoryResourceTester::NumFreeAllocations(mr)); \\\n+    BOOST_CHECK_EQUAL(num_pools, node_allocator::MemoryResourceTester::NumPools(mr));\n+\n+#define CHECK_IN_RANGE(what, lowerInclusive, upperInclusive) \\",
    "path": "src/test/node_allocator_tests.cpp",
    "position": null,
    "original_position": 67,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "a91b6032f037ab1a26ac4baa761e809fbfeb1bdd",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Probably should use snake case variable names\r\n\r\n(Version: a91b6032f037ab1a26ac4baa761e809fbfeb1bdd)\r\n",
    "created_at": "2021-10-28T17:32:40Z",
    "updated_at": "2021-10-28T19:29:38Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r738609379",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/738609379"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r738609379"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/738609379/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 67,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/738611918",
    "pull_request_review_id": 792093267,
    "id": 738611918,
    "node_id": "PRRC_kwDOABII584sBlLO",
    "diff_hunk": "@@ -0,0 +1,424 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <support/allocators/node_allocator.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <list>\n+#include <map>\n+#include <string>\n+#include <type_traits>\n+#include <unordered_map>\n+\n+namespace node_allocator {\n+\n+class MemoryResourceTester\n+{\n+public:\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static size_t NumFreeAllocations(\n+        MemoryResource<ALLOCATION_SIZE_BYTES> const& mr) noexcept\n+    {\n+        size_t length = 0;\n+        auto allocation = mr.m_free_allocations;\n+        while (allocation) {\n+            allocation = static_cast<detail::FreeList const*>(allocation)->next;\n+            ++length;\n+        }\n+        return length;\n+    }\n+\n+    /**\n+     * Number of memory pools that have been allocated\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static size_t NumPools(MemoryResource<ALLOCATION_SIZE_BYTES> const& mr) noexcept\n+    {\n+        return mr.m_allocated_pools.size();\n+    }\n+\n+\n+    /**\n+     * Extracts allocation size from the type\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static constexpr size_t AllocationSizeBytes(MemoryResource<ALLOCATION_SIZE_BYTES> const&) noexcept\n+    {\n+        return ALLOCATION_SIZE_BYTES;\n+    }\n+};\n+\n+} // namespace node_allocator\n+\n+BOOST_FIXTURE_TEST_SUITE(node_allocator_tests, BasicTestingSetup)\n+\n+#define CHECK_MEMORY_RESOURCE(mr, num_free_allocations, num_pools)                   \\",
    "path": "src/test/node_allocator_tests.cpp",
    "position": null,
    "original_position": 62,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "a91b6032f037ab1a26ac4baa761e809fbfeb1bdd",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Might suggest calling this something like `CHECK_NUMS_FREES_POOLS` just so it's easier to remember what the arguments are to this guy below (and what it is doing).\r\n\r\n(Version: a91b6032f037ab1a26ac4baa761e809fbfeb1bdd)",
    "created_at": "2021-10-28T17:36:08Z",
    "updated_at": "2021-10-28T19:29:38Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r738611918",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/738611918"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r738611918"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/738611918/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 62,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/738618356",
    "pull_request_review_id": 792093267,
    "id": 738618356,
    "node_id": "PRRC_kwDOABII584sBmv0",
    "diff_hunk": "@@ -0,0 +1,424 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <support/allocators/node_allocator.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <list>\n+#include <map>\n+#include <string>\n+#include <type_traits>\n+#include <unordered_map>\n+\n+namespace node_allocator {\n+\n+class MemoryResourceTester\n+{\n+public:\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static size_t NumFreeAllocations(\n+        MemoryResource<ALLOCATION_SIZE_BYTES> const& mr) noexcept\n+    {\n+        size_t length = 0;\n+        auto allocation = mr.m_free_allocations;\n+        while (allocation) {\n+            allocation = static_cast<detail::FreeList const*>(allocation)->next;\n+            ++length;\n+        }\n+        return length;\n+    }\n+\n+    /**\n+     * Number of memory pools that have been allocated\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static size_t NumPools(MemoryResource<ALLOCATION_SIZE_BYTES> const& mr) noexcept\n+    {\n+        return mr.m_allocated_pools.size();\n+    }\n+\n+\n+    /**\n+     * Extracts allocation size from the type\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static constexpr size_t AllocationSizeBytes(MemoryResource<ALLOCATION_SIZE_BYTES> const&) noexcept\n+    {\n+        return ALLOCATION_SIZE_BYTES;\n+    }\n+};\n+\n+} // namespace node_allocator\n+\n+BOOST_FIXTURE_TEST_SUITE(node_allocator_tests, BasicTestingSetup)\n+\n+#define CHECK_MEMORY_RESOURCE(mr, num_free_allocations, num_pools)                   \\\n+    BOOST_CHECK_EQUAL(num_free_allocations,                                          \\\n+                      node_allocator::MemoryResourceTester::NumFreeAllocations(mr)); \\\n+    BOOST_CHECK_EQUAL(num_pools, node_allocator::MemoryResourceTester::NumPools(mr));\n+\n+#define CHECK_IN_RANGE(what, lowerInclusive, upperInclusive) \\\n+    BOOST_TEST(what >= lowerInclusive);                      \\\n+    BOOST_TEST(what <= upperInclusive);\n+\n+BOOST_AUTO_TEST_CASE(too_small)\n+{\n+    node_allocator::MemoryResource<sizeof(void*)> mr{};",
    "path": "src/test/node_allocator_tests.cpp",
    "position": null,
    "original_position": 73,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "a91b6032f037ab1a26ac4baa761e809fbfeb1bdd",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Writing this comment feels like reaching new depths of pedantry, but it doesn't seem guaranteed that `void*` is bigger than `char`. It can't be smaller, because sizeof(char) is always 1, but if they are the same size, then the test isn't really meaningful. I guess my suggestion would be to replace `void*` with a type guaranteed to be bigger like `std::pair<char, char>`.\r\n\r\n(Version: a91b6032f037ab1a26ac4baa761e809fbfeb1bdd)",
    "created_at": "2021-10-28T17:45:23Z",
    "updated_at": "2021-10-28T19:29:38Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r738618356",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/738618356"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r738618356"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/738618356/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 73,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/738629705",
    "pull_request_review_id": 792093267,
    "id": 738629705,
    "node_id": "PRRC_kwDOABII584sBphJ",
    "diff_hunk": "@@ -0,0 +1,424 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <support/allocators/node_allocator.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <list>\n+#include <map>\n+#include <string>\n+#include <type_traits>\n+#include <unordered_map>\n+\n+namespace node_allocator {\n+\n+class MemoryResourceTester\n+{\n+public:\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static size_t NumFreeAllocations(\n+        MemoryResource<ALLOCATION_SIZE_BYTES> const& mr) noexcept\n+    {\n+        size_t length = 0;\n+        auto allocation = mr.m_free_allocations;\n+        while (allocation) {\n+            allocation = static_cast<detail::FreeList const*>(allocation)->next;\n+            ++length;\n+        }\n+        return length;\n+    }\n+\n+    /**\n+     * Number of memory pools that have been allocated\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static size_t NumPools(MemoryResource<ALLOCATION_SIZE_BYTES> const& mr) noexcept\n+    {\n+        return mr.m_allocated_pools.size();\n+    }\n+\n+\n+    /**\n+     * Extracts allocation size from the type\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static constexpr size_t AllocationSizeBytes(MemoryResource<ALLOCATION_SIZE_BYTES> const&) noexcept\n+    {\n+        return ALLOCATION_SIZE_BYTES;\n+    }\n+};\n+\n+} // namespace node_allocator\n+\n+BOOST_FIXTURE_TEST_SUITE(node_allocator_tests, BasicTestingSetup)\n+\n+#define CHECK_MEMORY_RESOURCE(mr, num_free_allocations, num_pools)                   \\\n+    BOOST_CHECK_EQUAL(num_free_allocations,                                          \\\n+                      node_allocator::MemoryResourceTester::NumFreeAllocations(mr)); \\\n+    BOOST_CHECK_EQUAL(num_pools, node_allocator::MemoryResourceTester::NumPools(mr));\n+\n+#define CHECK_IN_RANGE(what, lowerInclusive, upperInclusive) \\\n+    BOOST_TEST(what >= lowerInclusive);                      \\\n+    BOOST_TEST(what <= upperInclusive);\n+\n+BOOST_AUTO_TEST_CASE(too_small)\n+{\n+    node_allocator::MemoryResource<sizeof(void*)> mr{};\n+    void* ptr{mr.Allocate<char>(1)};\n+    BOOST_CHECK(ptr != nullptr);\n+\n+    // mr is used\n+    CHECK_MEMORY_RESOURCE(mr, 0, 1);\n+    mr.Deallocate<char>(ptr, 1);\n+    CHECK_MEMORY_RESOURCE(mr, 1, 1);\n+\n+    // void* works too, use freelist\n+    ptr = mr.Allocate<void*>(1);\n+    BOOST_CHECK(ptr != nullptr);\n+    CHECK_MEMORY_RESOURCE(mr, 0, 1);\n+    mr.Deallocate<char>(ptr, 1);\n+    CHECK_MEMORY_RESOURCE(mr, 1, 1);\n+}\n+\n+BOOST_AUTO_TEST_CASE(std_unordered_map)\n+{\n+    using Factory = node_allocator::UnorderedMapFactory<uint64_t, uint64_t>;\n+\n+    Factory::MemoryResourceType mr{};\n+    auto m = Factory::CreateContainer(&mr);\n+    size_t num_free_allocations = 0;\n+    {\n+        auto a = Factory::CreateContainer(&mr);\n+\n+        // Allocator compares equal because the same memory resource is used\n+        BOOST_CHECK(a.get_allocator() == m.get_allocator());\n+        for (uint64_t i = 0; i < 1000; ++i) {\n+            a[i] = i;\n+        }\n+\n+        num_free_allocations = node_allocator::MemoryResourceTester::NumFreeAllocations(mr);\n+\n+        // create a copy of the map, destroy the map => now a lot more free allocations should be\n+        // available\n+        {\n+            auto b = a;\n+        }\n+\n+        BOOST_CHECK(node_allocator::MemoryResourceTester::NumFreeAllocations(mr) >\n+                    num_free_allocations);",
    "path": "src/test/node_allocator_tests.cpp",
    "position": null,
    "original_position": 115,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "a91b6032f037ab1a26ac4baa761e809fbfeb1bdd",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Could do a stricter check?\r\n\r\n```\r\nBOOST_CHECK(node_allocator::MemoryResourceTester::NumFreeAllocations(mr) >=\r\n                    num_free_allocations + 1000);\r\n```\r\n(Version: a91b6032f037ab1a26ac4baa761e809fbfeb1bdd)\r\n",
    "created_at": "2021-10-28T18:01:13Z",
    "updated_at": "2021-10-28T19:29:38Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r738629705",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/738629705"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r738629705"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/738629705/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": 114,
    "start_side": "RIGHT",
    "line": null,
    "original_line": 115,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/738633199",
    "pull_request_review_id": 792093267,
    "id": 738633199,
    "node_id": "PRRC_kwDOABII584sBqXv",
    "diff_hunk": "@@ -0,0 +1,424 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <support/allocators/node_allocator.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <list>\n+#include <map>\n+#include <string>\n+#include <type_traits>\n+#include <unordered_map>\n+\n+namespace node_allocator {\n+\n+class MemoryResourceTester\n+{\n+public:\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static size_t NumFreeAllocations(\n+        MemoryResource<ALLOCATION_SIZE_BYTES> const& mr) noexcept\n+    {\n+        size_t length = 0;\n+        auto allocation = mr.m_free_allocations;\n+        while (allocation) {\n+            allocation = static_cast<detail::FreeList const*>(allocation)->next;\n+            ++length;\n+        }\n+        return length;\n+    }\n+\n+    /**\n+     * Number of memory pools that have been allocated\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static size_t NumPools(MemoryResource<ALLOCATION_SIZE_BYTES> const& mr) noexcept\n+    {\n+        return mr.m_allocated_pools.size();\n+    }\n+\n+\n+    /**\n+     * Extracts allocation size from the type\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static constexpr size_t AllocationSizeBytes(MemoryResource<ALLOCATION_SIZE_BYTES> const&) noexcept\n+    {\n+        return ALLOCATION_SIZE_BYTES;\n+    }\n+};\n+\n+} // namespace node_allocator\n+\n+BOOST_FIXTURE_TEST_SUITE(node_allocator_tests, BasicTestingSetup)\n+\n+#define CHECK_MEMORY_RESOURCE(mr, num_free_allocations, num_pools)                   \\\n+    BOOST_CHECK_EQUAL(num_free_allocations,                                          \\\n+                      node_allocator::MemoryResourceTester::NumFreeAllocations(mr)); \\\n+    BOOST_CHECK_EQUAL(num_pools, node_allocator::MemoryResourceTester::NumPools(mr));\n+\n+#define CHECK_IN_RANGE(what, lowerInclusive, upperInclusive) \\\n+    BOOST_TEST(what >= lowerInclusive);                      \\\n+    BOOST_TEST(what <= upperInclusive);\n+\n+BOOST_AUTO_TEST_CASE(too_small)\n+{\n+    node_allocator::MemoryResource<sizeof(void*)> mr{};\n+    void* ptr{mr.Allocate<char>(1)};\n+    BOOST_CHECK(ptr != nullptr);\n+\n+    // mr is used\n+    CHECK_MEMORY_RESOURCE(mr, 0, 1);\n+    mr.Deallocate<char>(ptr, 1);\n+    CHECK_MEMORY_RESOURCE(mr, 1, 1);\n+\n+    // void* works too, use freelist\n+    ptr = mr.Allocate<void*>(1);\n+    BOOST_CHECK(ptr != nullptr);\n+    CHECK_MEMORY_RESOURCE(mr, 0, 1);\n+    mr.Deallocate<char>(ptr, 1);\n+    CHECK_MEMORY_RESOURCE(mr, 1, 1);\n+}\n+\n+BOOST_AUTO_TEST_CASE(std_unordered_map)\n+{\n+    using Factory = node_allocator::UnorderedMapFactory<uint64_t, uint64_t>;\n+\n+    Factory::MemoryResourceType mr{};\n+    auto m = Factory::CreateContainer(&mr);\n+    size_t num_free_allocations = 0;\n+    {\n+        auto a = Factory::CreateContainer(&mr);\n+\n+        // Allocator compares equal because the same memory resource is used\n+        BOOST_CHECK(a.get_allocator() == m.get_allocator());\n+        for (uint64_t i = 0; i < 1000; ++i) {\n+            a[i] = i;\n+        }\n+\n+        num_free_allocations = node_allocator::MemoryResourceTester::NumFreeAllocations(mr);\n+\n+        // create a copy of the map, destroy the map => now a lot more free allocations should be\n+        // available\n+        {\n+            auto b = a;\n+        }\n+\n+        BOOST_CHECK(node_allocator::MemoryResourceTester::NumFreeAllocations(mr) >\n+                    num_free_allocations);\n+        num_free_allocations = node_allocator::MemoryResourceTester::NumFreeAllocations(mr);\n+\n+        // creating another copy, and then destroying everything should reuse all the allocations\n+        {\n+            auto b = a;\n+        }\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr),\n+                          num_free_allocations);\n+\n+        // moving the map should not create new nodes\n+        m = std::move(a);\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr),\n+                          num_free_allocations);\n+    }\n+    // a is destroyed, still all allocations should stay roughly the same.",
    "path": "src/test/node_allocator_tests.cpp",
    "position": null,
    "original_position": 130,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "a91b6032f037ab1a26ac4baa761e809fbfeb1bdd",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Can you add \"because its contents were moved to m\" to this comment? I was a little confused by what this was doing at first, and the extra hint would have helped.\r\n\r\n(Version: a91b6032f037ab1a26ac4baa761e809fbfeb1bdd)",
    "created_at": "2021-10-28T18:06:22Z",
    "updated_at": "2021-10-28T19:29:38Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r738633199",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/738633199"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r738633199"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/738633199/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 130,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/738640412",
    "pull_request_review_id": 792093267,
    "id": 738640412,
    "node_id": "PRRC_kwDOABII584sBsIc",
    "diff_hunk": "@@ -0,0 +1,424 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <support/allocators/node_allocator.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <list>\n+#include <map>\n+#include <string>\n+#include <type_traits>\n+#include <unordered_map>\n+\n+namespace node_allocator {\n+\n+class MemoryResourceTester\n+{\n+public:\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static size_t NumFreeAllocations(\n+        MemoryResource<ALLOCATION_SIZE_BYTES> const& mr) noexcept\n+    {\n+        size_t length = 0;\n+        auto allocation = mr.m_free_allocations;\n+        while (allocation) {\n+            allocation = static_cast<detail::FreeList const*>(allocation)->next;\n+            ++length;\n+        }\n+        return length;\n+    }\n+\n+    /**\n+     * Number of memory pools that have been allocated\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static size_t NumPools(MemoryResource<ALLOCATION_SIZE_BYTES> const& mr) noexcept\n+    {\n+        return mr.m_allocated_pools.size();\n+    }\n+\n+\n+    /**\n+     * Extracts allocation size from the type\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static constexpr size_t AllocationSizeBytes(MemoryResource<ALLOCATION_SIZE_BYTES> const&) noexcept\n+    {\n+        return ALLOCATION_SIZE_BYTES;\n+    }\n+};\n+\n+} // namespace node_allocator\n+\n+BOOST_FIXTURE_TEST_SUITE(node_allocator_tests, BasicTestingSetup)\n+\n+#define CHECK_MEMORY_RESOURCE(mr, num_free_allocations, num_pools)                   \\\n+    BOOST_CHECK_EQUAL(num_free_allocations,                                          \\\n+                      node_allocator::MemoryResourceTester::NumFreeAllocations(mr)); \\\n+    BOOST_CHECK_EQUAL(num_pools, node_allocator::MemoryResourceTester::NumPools(mr));\n+\n+#define CHECK_IN_RANGE(what, lowerInclusive, upperInclusive) \\\n+    BOOST_TEST(what >= lowerInclusive);                      \\\n+    BOOST_TEST(what <= upperInclusive);\n+\n+BOOST_AUTO_TEST_CASE(too_small)\n+{\n+    node_allocator::MemoryResource<sizeof(void*)> mr{};\n+    void* ptr{mr.Allocate<char>(1)};\n+    BOOST_CHECK(ptr != nullptr);\n+\n+    // mr is used\n+    CHECK_MEMORY_RESOURCE(mr, 0, 1);\n+    mr.Deallocate<char>(ptr, 1);\n+    CHECK_MEMORY_RESOURCE(mr, 1, 1);\n+\n+    // void* works too, use freelist\n+    ptr = mr.Allocate<void*>(1);\n+    BOOST_CHECK(ptr != nullptr);\n+    CHECK_MEMORY_RESOURCE(mr, 0, 1);\n+    mr.Deallocate<char>(ptr, 1);\n+    CHECK_MEMORY_RESOURCE(mr, 1, 1);\n+}\n+\n+BOOST_AUTO_TEST_CASE(std_unordered_map)\n+{\n+    using Factory = node_allocator::UnorderedMapFactory<uint64_t, uint64_t>;\n+\n+    Factory::MemoryResourceType mr{};\n+    auto m = Factory::CreateContainer(&mr);\n+    size_t num_free_allocations = 0;\n+    {\n+        auto a = Factory::CreateContainer(&mr);\n+\n+        // Allocator compares equal because the same memory resource is used\n+        BOOST_CHECK(a.get_allocator() == m.get_allocator());\n+        for (uint64_t i = 0; i < 1000; ++i) {\n+            a[i] = i;\n+        }\n+\n+        num_free_allocations = node_allocator::MemoryResourceTester::NumFreeAllocations(mr);\n+\n+        // create a copy of the map, destroy the map => now a lot more free allocations should be\n+        // available\n+        {\n+            auto b = a;\n+        }\n+\n+        BOOST_CHECK(node_allocator::MemoryResourceTester::NumFreeAllocations(mr) >\n+                    num_free_allocations);\n+        num_free_allocations = node_allocator::MemoryResourceTester::NumFreeAllocations(mr);\n+\n+        // creating another copy, and then destroying everything should reuse all the allocations\n+        {\n+            auto b = a;\n+        }\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr),\n+                          num_free_allocations);\n+\n+        // moving the map should not create new nodes\n+        m = std::move(a);\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr),\n+                          num_free_allocations);\n+    }\n+    // a is destroyed, still all allocations should stay roughly the same.\n+    BOOST_CHECK(node_allocator::MemoryResourceTester::NumFreeAllocations(mr) <=\n+                num_free_allocations + 5);\n+\n+    m = Factory::CreateContainer(&mr);\n+\n+    // now we got everything free\n+    BOOST_CHECK(node_allocator::MemoryResourceTester::NumFreeAllocations(mr) >\n+                num_free_allocations + 50);",
    "path": "src/test/node_allocator_tests.cpp",
    "position": null,
    "original_position": 138,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "a91b6032f037ab1a26ac4baa761e809fbfeb1bdd",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Why only >50 here, not >=1000 again?\r\n\r\n(Version: a91b6032f037ab1a26ac4baa761e809fbfeb1bdd)",
    "created_at": "2021-10-28T18:16:54Z",
    "updated_at": "2021-10-28T19:29:38Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r738640412",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/738640412"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r738640412"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/738640412/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": 137,
    "start_side": "RIGHT",
    "line": null,
    "original_line": 138,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/738645071",
    "pull_request_review_id": 792093267,
    "id": 738645071,
    "node_id": "PRRC_kwDOABII584sBtRP",
    "diff_hunk": "@@ -0,0 +1,424 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <support/allocators/node_allocator.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <list>\n+#include <map>\n+#include <string>\n+#include <type_traits>\n+#include <unordered_map>\n+\n+namespace node_allocator {\n+\n+class MemoryResourceTester",
    "path": "src/test/node_allocator_tests.cpp",
    "position": 20,
    "original_position": 19,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "a91b6032f037ab1a26ac4baa761e809fbfeb1bdd",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "It seems like another thing these tests could be checking for aside from number of free allocations and number of pools is amount of slack space the last pool (untouched_end - untouched_iterator)/alloc size.\r\n\r\n(Version: a91b6032f037ab1a26ac4baa761e809fbfeb1bdd)",
    "created_at": "2021-10-28T18:23:52Z",
    "updated_at": "2021-10-28T19:29:38Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r738645071",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/738645071"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r738645071"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/738645071/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 20,
    "original_line": 20,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/738649391",
    "pull_request_review_id": 792093267,
    "id": 738649391,
    "node_id": "PRRC_kwDOABII584sBuUv",
    "diff_hunk": "@@ -0,0 +1,424 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <support/allocators/node_allocator.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <list>\n+#include <map>\n+#include <string>\n+#include <type_traits>\n+#include <unordered_map>\n+\n+namespace node_allocator {\n+\n+class MemoryResourceTester\n+{\n+public:\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static size_t NumFreeAllocations(\n+        MemoryResource<ALLOCATION_SIZE_BYTES> const& mr) noexcept\n+    {\n+        size_t length = 0;\n+        auto allocation = mr.m_free_allocations;\n+        while (allocation) {\n+            allocation = static_cast<detail::FreeList const*>(allocation)->next;\n+            ++length;\n+        }\n+        return length;\n+    }\n+\n+    /**\n+     * Number of memory pools that have been allocated\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static size_t NumPools(MemoryResource<ALLOCATION_SIZE_BYTES> const& mr) noexcept\n+    {\n+        return mr.m_allocated_pools.size();\n+    }\n+\n+\n+    /**\n+     * Extracts allocation size from the type\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static constexpr size_t AllocationSizeBytes(MemoryResource<ALLOCATION_SIZE_BYTES> const&) noexcept\n+    {\n+        return ALLOCATION_SIZE_BYTES;\n+    }\n+};\n+\n+} // namespace node_allocator\n+\n+BOOST_FIXTURE_TEST_SUITE(node_allocator_tests, BasicTestingSetup)\n+\n+#define CHECK_MEMORY_RESOURCE(mr, num_free_allocations, num_pools)                   \\\n+    BOOST_CHECK_EQUAL(num_free_allocations,                                          \\\n+                      node_allocator::MemoryResourceTester::NumFreeAllocations(mr)); \\\n+    BOOST_CHECK_EQUAL(num_pools, node_allocator::MemoryResourceTester::NumPools(mr));\n+\n+#define CHECK_IN_RANGE(what, lowerInclusive, upperInclusive) \\\n+    BOOST_TEST(what >= lowerInclusive);                      \\\n+    BOOST_TEST(what <= upperInclusive);\n+\n+BOOST_AUTO_TEST_CASE(too_small)\n+{\n+    node_allocator::MemoryResource<sizeof(void*)> mr{};\n+    void* ptr{mr.Allocate<char>(1)};\n+    BOOST_CHECK(ptr != nullptr);\n+\n+    // mr is used\n+    CHECK_MEMORY_RESOURCE(mr, 0, 1);\n+    mr.Deallocate<char>(ptr, 1);\n+    CHECK_MEMORY_RESOURCE(mr, 1, 1);\n+\n+    // void* works too, use freelist\n+    ptr = mr.Allocate<void*>(1);\n+    BOOST_CHECK(ptr != nullptr);\n+    CHECK_MEMORY_RESOURCE(mr, 0, 1);\n+    mr.Deallocate<char>(ptr, 1);\n+    CHECK_MEMORY_RESOURCE(mr, 1, 1);\n+}\n+\n+BOOST_AUTO_TEST_CASE(std_unordered_map)\n+{\n+    using Factory = node_allocator::UnorderedMapFactory<uint64_t, uint64_t>;\n+\n+    Factory::MemoryResourceType mr{};\n+    auto m = Factory::CreateContainer(&mr);\n+    size_t num_free_allocations = 0;\n+    {\n+        auto a = Factory::CreateContainer(&mr);\n+\n+        // Allocator compares equal because the same memory resource is used\n+        BOOST_CHECK(a.get_allocator() == m.get_allocator());\n+        for (uint64_t i = 0; i < 1000; ++i) {\n+            a[i] = i;\n+        }\n+\n+        num_free_allocations = node_allocator::MemoryResourceTester::NumFreeAllocations(mr);\n+\n+        // create a copy of the map, destroy the map => now a lot more free allocations should be\n+        // available\n+        {\n+            auto b = a;\n+        }\n+\n+        BOOST_CHECK(node_allocator::MemoryResourceTester::NumFreeAllocations(mr) >\n+                    num_free_allocations);\n+        num_free_allocations = node_allocator::MemoryResourceTester::NumFreeAllocations(mr);\n+\n+        // creating another copy, and then destroying everything should reuse all the allocations\n+        {\n+            auto b = a;\n+        }\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr),\n+                          num_free_allocations);\n+\n+        // moving the map should not create new nodes\n+        m = std::move(a);\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr),\n+                          num_free_allocations);\n+    }\n+    // a is destroyed, still all allocations should stay roughly the same.\n+    BOOST_CHECK(node_allocator::MemoryResourceTester::NumFreeAllocations(mr) <=\n+                num_free_allocations + 5);\n+\n+    m = Factory::CreateContainer(&mr);\n+\n+    // now we got everything free\n+    BOOST_CHECK(node_allocator::MemoryResourceTester::NumFreeAllocations(mr) >\n+                num_free_allocations + 50);\n+}\n+\n+BOOST_AUTO_TEST_CASE(different_memoryresource_assignment)\n+{\n+    using Factory = node_allocator::UnorderedMapFactory<uint64_t, uint64_t>;",
    "path": "src/test/node_allocator_tests.cpp",
    "position": null,
    "original_position": 143,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "a91b6032f037ab1a26ac4baa761e809fbfeb1bdd",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "I get that it makes sense to have test coverage for std::unordered_map, but I feel like it would be if ideal if unordered_map vagaries with IN_RANGE(1U, 2U) (101U, 102U) soft checks were confined to ~one test, and all other tests used a simpler container like `std::list` that was easier to think about and had better defined allocation behavior, so the tests would be easier to understand, less fragile, and in some places more meaningful.\r\n\r\nNot saying you should rewrite all tests, but this might be something to think about doing selectively or for new tests.\r\n\r\n(Version: a91b6032f037ab1a26ac4baa761e809fbfeb1bdd)",
    "created_at": "2021-10-28T18:30:33Z",
    "updated_at": "2021-10-28T19:29:38Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r738649391",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/738649391"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r738649391"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/738649391/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 146,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/738664163",
    "pull_request_review_id": 792093267,
    "id": 738664163,
    "node_id": "PRRC_kwDOABII584sBx7j",
    "diff_hunk": "@@ -0,0 +1,424 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <support/allocators/node_allocator.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <list>\n+#include <map>\n+#include <string>\n+#include <type_traits>\n+#include <unordered_map>\n+\n+namespace node_allocator {\n+\n+class MemoryResourceTester\n+{\n+public:\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static size_t NumFreeAllocations(\n+        MemoryResource<ALLOCATION_SIZE_BYTES> const& mr) noexcept\n+    {\n+        size_t length = 0;\n+        auto allocation = mr.m_free_allocations;\n+        while (allocation) {\n+            allocation = static_cast<detail::FreeList const*>(allocation)->next;\n+            ++length;\n+        }\n+        return length;\n+    }\n+\n+    /**\n+     * Number of memory pools that have been allocated\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static size_t NumPools(MemoryResource<ALLOCATION_SIZE_BYTES> const& mr) noexcept\n+    {\n+        return mr.m_allocated_pools.size();\n+    }\n+\n+\n+    /**\n+     * Extracts allocation size from the type\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static constexpr size_t AllocationSizeBytes(MemoryResource<ALLOCATION_SIZE_BYTES> const&) noexcept\n+    {\n+        return ALLOCATION_SIZE_BYTES;\n+    }\n+};\n+\n+} // namespace node_allocator\n+\n+BOOST_FIXTURE_TEST_SUITE(node_allocator_tests, BasicTestingSetup)\n+\n+#define CHECK_MEMORY_RESOURCE(mr, num_free_allocations, num_pools)                   \\\n+    BOOST_CHECK_EQUAL(num_free_allocations,                                          \\\n+                      node_allocator::MemoryResourceTester::NumFreeAllocations(mr)); \\\n+    BOOST_CHECK_EQUAL(num_pools, node_allocator::MemoryResourceTester::NumPools(mr));\n+\n+#define CHECK_IN_RANGE(what, lowerInclusive, upperInclusive) \\\n+    BOOST_TEST(what >= lowerInclusive);                      \\\n+    BOOST_TEST(what <= upperInclusive);\n+\n+BOOST_AUTO_TEST_CASE(too_small)\n+{\n+    node_allocator::MemoryResource<sizeof(void*)> mr{};\n+    void* ptr{mr.Allocate<char>(1)};\n+    BOOST_CHECK(ptr != nullptr);\n+\n+    // mr is used\n+    CHECK_MEMORY_RESOURCE(mr, 0, 1);\n+    mr.Deallocate<char>(ptr, 1);\n+    CHECK_MEMORY_RESOURCE(mr, 1, 1);\n+\n+    // void* works too, use freelist\n+    ptr = mr.Allocate<void*>(1);\n+    BOOST_CHECK(ptr != nullptr);\n+    CHECK_MEMORY_RESOURCE(mr, 0, 1);\n+    mr.Deallocate<char>(ptr, 1);\n+    CHECK_MEMORY_RESOURCE(mr, 1, 1);\n+}\n+\n+BOOST_AUTO_TEST_CASE(std_unordered_map)\n+{\n+    using Factory = node_allocator::UnorderedMapFactory<uint64_t, uint64_t>;\n+\n+    Factory::MemoryResourceType mr{};\n+    auto m = Factory::CreateContainer(&mr);\n+    size_t num_free_allocations = 0;\n+    {\n+        auto a = Factory::CreateContainer(&mr);\n+\n+        // Allocator compares equal because the same memory resource is used\n+        BOOST_CHECK(a.get_allocator() == m.get_allocator());\n+        for (uint64_t i = 0; i < 1000; ++i) {\n+            a[i] = i;\n+        }\n+\n+        num_free_allocations = node_allocator::MemoryResourceTester::NumFreeAllocations(mr);\n+\n+        // create a copy of the map, destroy the map => now a lot more free allocations should be\n+        // available\n+        {\n+            auto b = a;\n+        }\n+\n+        BOOST_CHECK(node_allocator::MemoryResourceTester::NumFreeAllocations(mr) >\n+                    num_free_allocations);\n+        num_free_allocations = node_allocator::MemoryResourceTester::NumFreeAllocations(mr);\n+\n+        // creating another copy, and then destroying everything should reuse all the allocations\n+        {\n+            auto b = a;\n+        }\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr),\n+                          num_free_allocations);\n+\n+        // moving the map should not create new nodes\n+        m = std::move(a);\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr),\n+                          num_free_allocations);\n+    }\n+    // a is destroyed, still all allocations should stay roughly the same.\n+    BOOST_CHECK(node_allocator::MemoryResourceTester::NumFreeAllocations(mr) <=\n+                num_free_allocations + 5);\n+\n+    m = Factory::CreateContainer(&mr);\n+\n+    // now we got everything free\n+    BOOST_CHECK(node_allocator::MemoryResourceTester::NumFreeAllocations(mr) >\n+                num_free_allocations + 50);\n+}\n+\n+BOOST_AUTO_TEST_CASE(different_memoryresource_assignment)\n+{\n+    using Factory = node_allocator::UnorderedMapFactory<uint64_t, uint64_t>;\n+\n+    Factory::MemoryResourceType mr_a{};\n+    Factory::MemoryResourceType mr_b{};\n+\n+    {\n+        auto map_a = Factory::CreateContainer(&mr_a);\n+        for (int i = 0; i < 100; ++i) {\n+            map_a[i] = i;\n+        }\n+\n+        {\n+            auto map_b = Factory::CreateContainer(&mr_b);\n+            map_b[123] = 321;\n+            BOOST_CHECK(map_a.get_allocator() != map_b.get_allocator());\n+            BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 0);\n+            BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumPools(mr_b), 1);\n+\n+            map_b = map_a;\n+\n+            // map_a now uses mr_b, since propagate_on_container_copy_assignment is std::true_type\n+            BOOST_CHECK(map_a.get_allocator() == map_b.get_allocator());\n+            CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 1U, 2U);\n+            BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumPools(mr_b), 1);\n+\n+            // map_b was now recreated with data from map_a, using mr_a as the memory resource.\n+        }\n+\n+        // map_b destroyed, should not have any effect on mr_b\n+        CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 1U, 2U);\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumPools(mr_b), 1);\n+        // but we'll get more free allocations in mr_a\n+        CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 100U, 101U);\n+    }\n+\n+    // finally map_a is destroyed, getting more free allocations.\n+    CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 200U, 202U);\n+}\n+\n+\n+BOOST_AUTO_TEST_CASE(different_memoryresource_move)\n+{\n+    using Factory = node_allocator::UnorderedMapFactory<uint64_t, uint64_t>;\n+\n+    Factory::MemoryResourceType mr_a{};\n+    Factory::MemoryResourceType mr_b{};\n+\n+    {\n+        auto map_a = Factory::CreateContainer(&mr_a);\n+        for (int i = 0; i < 100; ++i) {\n+            map_a[i] = i;\n+        }\n+\n+        {\n+            auto map_b = Factory::CreateContainer(&mr_b);\n+            map_b[123] = 321;\n+\n+            map_b = std::move(map_a);\n+\n+            // map_a now uses mr_b, since propagate_on_container_move_assignment is std::true_type\n+            BOOST_CHECK(map_a.get_allocator() == map_b.get_allocator());\n+            CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 1U, 2U);\n+            BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumPools(mr_b), 1);\n+\n+            // map_b was now recreated with data from map_a, using mr_a as the memory resource.\n+        }\n+\n+        // map_b destroyed, should not have any effect on mr_b.\n+        CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 1U, 2U);\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumPools(mr_b), 1);\n+        // but we'll get more free allocations in mr_a\n+        CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 100U, 101U);\n+    }\n+\n+    // finally map_a is destroyed, but since it was moved, no more free allocations.\n+    CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 100U, 102U);\n+}\n+\n+\n+BOOST_AUTO_TEST_CASE(different_memoryresource_swap)",
    "path": "src/test/node_allocator_tests.cpp",
    "position": null,
    "original_position": 222,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "a91b6032f037ab1a26ac4baa761e809fbfeb1bdd",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Amount of code duplication between different_memoryresource_* tests is a little eye-watering. This seems like a place where `BOOST_FIXTURE_TEST_CASE` and a test fixture with `unordered_map m_map_a` and `optional<unordered_map> m_map_b` members and some helper methods would cut down duplication and make the checks more human readable.\r\n\r\n(Version: a91b6032f037ab1a26ac4baa761e809fbfeb1bdd)",
    "created_at": "2021-10-28T18:52:57Z",
    "updated_at": "2021-10-28T19:29:38Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r738664163",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/738664163"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r738664163"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/738664163/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 222,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/738666780",
    "pull_request_review_id": 792093267,
    "id": 738666780,
    "node_id": "PRRC_kwDOABII584sBykc",
    "diff_hunk": "@@ -0,0 +1,424 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <support/allocators/node_allocator.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <list>\n+#include <map>\n+#include <string>\n+#include <type_traits>\n+#include <unordered_map>\n+\n+namespace node_allocator {\n+\n+class MemoryResourceTester\n+{\n+public:\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static size_t NumFreeAllocations(\n+        MemoryResource<ALLOCATION_SIZE_BYTES> const& mr) noexcept\n+    {\n+        size_t length = 0;\n+        auto allocation = mr.m_free_allocations;\n+        while (allocation) {\n+            allocation = static_cast<detail::FreeList const*>(allocation)->next;\n+            ++length;\n+        }\n+        return length;\n+    }\n+\n+    /**\n+     * Number of memory pools that have been allocated\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static size_t NumPools(MemoryResource<ALLOCATION_SIZE_BYTES> const& mr) noexcept\n+    {\n+        return mr.m_allocated_pools.size();\n+    }\n+\n+\n+    /**\n+     * Extracts allocation size from the type\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static constexpr size_t AllocationSizeBytes(MemoryResource<ALLOCATION_SIZE_BYTES> const&) noexcept\n+    {\n+        return ALLOCATION_SIZE_BYTES;\n+    }\n+};\n+\n+} // namespace node_allocator\n+\n+BOOST_FIXTURE_TEST_SUITE(node_allocator_tests, BasicTestingSetup)\n+\n+#define CHECK_MEMORY_RESOURCE(mr, num_free_allocations, num_pools)                   \\\n+    BOOST_CHECK_EQUAL(num_free_allocations,                                          \\\n+                      node_allocator::MemoryResourceTester::NumFreeAllocations(mr)); \\\n+    BOOST_CHECK_EQUAL(num_pools, node_allocator::MemoryResourceTester::NumPools(mr));\n+\n+#define CHECK_IN_RANGE(what, lowerInclusive, upperInclusive) \\\n+    BOOST_TEST(what >= lowerInclusive);                      \\\n+    BOOST_TEST(what <= upperInclusive);\n+\n+BOOST_AUTO_TEST_CASE(too_small)\n+{\n+    node_allocator::MemoryResource<sizeof(void*)> mr{};\n+    void* ptr{mr.Allocate<char>(1)};\n+    BOOST_CHECK(ptr != nullptr);\n+\n+    // mr is used\n+    CHECK_MEMORY_RESOURCE(mr, 0, 1);\n+    mr.Deallocate<char>(ptr, 1);\n+    CHECK_MEMORY_RESOURCE(mr, 1, 1);\n+\n+    // void* works too, use freelist\n+    ptr = mr.Allocate<void*>(1);\n+    BOOST_CHECK(ptr != nullptr);\n+    CHECK_MEMORY_RESOURCE(mr, 0, 1);\n+    mr.Deallocate<char>(ptr, 1);\n+    CHECK_MEMORY_RESOURCE(mr, 1, 1);\n+}\n+\n+BOOST_AUTO_TEST_CASE(std_unordered_map)\n+{\n+    using Factory = node_allocator::UnorderedMapFactory<uint64_t, uint64_t>;\n+\n+    Factory::MemoryResourceType mr{};\n+    auto m = Factory::CreateContainer(&mr);\n+    size_t num_free_allocations = 0;\n+    {\n+        auto a = Factory::CreateContainer(&mr);\n+\n+        // Allocator compares equal because the same memory resource is used\n+        BOOST_CHECK(a.get_allocator() == m.get_allocator());\n+        for (uint64_t i = 0; i < 1000; ++i) {\n+            a[i] = i;\n+        }\n+\n+        num_free_allocations = node_allocator::MemoryResourceTester::NumFreeAllocations(mr);\n+\n+        // create a copy of the map, destroy the map => now a lot more free allocations should be\n+        // available\n+        {\n+            auto b = a;\n+        }\n+\n+        BOOST_CHECK(node_allocator::MemoryResourceTester::NumFreeAllocations(mr) >\n+                    num_free_allocations);\n+        num_free_allocations = node_allocator::MemoryResourceTester::NumFreeAllocations(mr);\n+\n+        // creating another copy, and then destroying everything should reuse all the allocations\n+        {\n+            auto b = a;\n+        }\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr),\n+                          num_free_allocations);\n+\n+        // moving the map should not create new nodes\n+        m = std::move(a);\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr),\n+                          num_free_allocations);\n+    }\n+    // a is destroyed, still all allocations should stay roughly the same.\n+    BOOST_CHECK(node_allocator::MemoryResourceTester::NumFreeAllocations(mr) <=\n+                num_free_allocations + 5);\n+\n+    m = Factory::CreateContainer(&mr);\n+\n+    // now we got everything free\n+    BOOST_CHECK(node_allocator::MemoryResourceTester::NumFreeAllocations(mr) >\n+                num_free_allocations + 50);\n+}\n+\n+BOOST_AUTO_TEST_CASE(different_memoryresource_assignment)\n+{\n+    using Factory = node_allocator::UnorderedMapFactory<uint64_t, uint64_t>;\n+\n+    Factory::MemoryResourceType mr_a{};\n+    Factory::MemoryResourceType mr_b{};\n+\n+    {\n+        auto map_a = Factory::CreateContainer(&mr_a);\n+        for (int i = 0; i < 100; ++i) {\n+            map_a[i] = i;\n+        }\n+\n+        {\n+            auto map_b = Factory::CreateContainer(&mr_b);\n+            map_b[123] = 321;\n+            BOOST_CHECK(map_a.get_allocator() != map_b.get_allocator());\n+            BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 0);\n+            BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumPools(mr_b), 1);\n+\n+            map_b = map_a;\n+\n+            // map_a now uses mr_b, since propagate_on_container_copy_assignment is std::true_type\n+            BOOST_CHECK(map_a.get_allocator() == map_b.get_allocator());\n+            CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 1U, 2U);\n+            BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumPools(mr_b), 1);\n+\n+            // map_b was now recreated with data from map_a, using mr_a as the memory resource.\n+        }\n+\n+        // map_b destroyed, should not have any effect on mr_b\n+        CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 1U, 2U);\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumPools(mr_b), 1);\n+        // but we'll get more free allocations in mr_a\n+        CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 100U, 101U);\n+    }\n+\n+    // finally map_a is destroyed, getting more free allocations.\n+    CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 200U, 202U);\n+}\n+\n+\n+BOOST_AUTO_TEST_CASE(different_memoryresource_move)\n+{\n+    using Factory = node_allocator::UnorderedMapFactory<uint64_t, uint64_t>;\n+\n+    Factory::MemoryResourceType mr_a{};\n+    Factory::MemoryResourceType mr_b{};\n+\n+    {\n+        auto map_a = Factory::CreateContainer(&mr_a);\n+        for (int i = 0; i < 100; ++i) {\n+            map_a[i] = i;\n+        }\n+\n+        {\n+            auto map_b = Factory::CreateContainer(&mr_b);\n+            map_b[123] = 321;\n+\n+            map_b = std::move(map_a);\n+\n+            // map_a now uses mr_b, since propagate_on_container_move_assignment is std::true_type\n+            BOOST_CHECK(map_a.get_allocator() == map_b.get_allocator());\n+            CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 1U, 2U);\n+            BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumPools(mr_b), 1);\n+\n+            // map_b was now recreated with data from map_a, using mr_a as the memory resource.\n+        }\n+\n+        // map_b destroyed, should not have any effect on mr_b.\n+        CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 1U, 2U);\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumPools(mr_b), 1);\n+        // but we'll get more free allocations in mr_a\n+        CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 100U, 101U);\n+    }\n+\n+    // finally map_a is destroyed, but since it was moved, no more free allocations.\n+    CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 100U, 102U);\n+}\n+\n+\n+BOOST_AUTO_TEST_CASE(different_memoryresource_swap)\n+{\n+    using Factory = node_allocator::UnorderedMapFactory<uint64_t, uint64_t>;\n+\n+    Factory::MemoryResourceType mr_a{};\n+    Factory::MemoryResourceType mr_b{};\n+\n+    {\n+        auto map_a = Factory::CreateContainer(&mr_a);\n+        for (int i = 0; i < 100; ++i) {\n+            map_a[i] = i;\n+        }\n+\n+        {\n+            auto map_b = Factory::CreateContainer(&mr_b);\n+            map_b[123] = 321;\n+\n+            auto alloc_a = map_a.get_allocator();\n+            auto alloc_b = map_b.get_allocator();\n+\n+            std::swap(map_a, map_b);\n+\n+            // The maps have swapped, so their allocators have swapped, too.\n+            // No additional allocations have occurred!\n+            BOOST_CHECK(map_a.get_allocator() != map_b.get_allocator());\n+            BOOST_CHECK(alloc_a == map_b.get_allocator());\n+            BOOST_CHECK(alloc_b == map_a.get_allocator());\n+        }\n+\n+        // map_b destroyed, so mr_a must have plenty of free allocations now\n+        CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 100U, 101U);\n+\n+        // nothing happened to map_a, so mr_b still has no free allocations\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 0);\n+    }\n+\n+    // finally map_a is destroyed, so we got an entry back for mr_b.\n+    CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 100U, 101U);\n+    CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 1U, 2U);\n+}\n+\n+// some structs with defined alignment and customizeable size\n+\n+namespace {\n+\n+template <size_t S>\n+struct alignas(1) A1 {\n+    char data[S];\n+};\n+\n+template <size_t S>\n+struct alignas(2) A2 {\n+    char data[S];\n+};\n+\n+template <size_t S>\n+struct alignas(4) A4 {\n+    char data[S];\n+};\n+\n+template <size_t S>\n+struct alignas(8) A8 {\n+    char data[S];\n+};\n+\n+template <size_t S>\n+struct alignas(16) A16 {\n+    char data[S];\n+};\n+\n+template <size_t S>\n+struct alignas(32) A32 {\n+    char data[S];\n+};",
    "path": "src/test/node_allocator_tests.cpp",
    "position": null,
    "original_position": 295,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "a91b6032f037ab1a26ac4baa761e809fbfeb1bdd",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Could all of this just be\r\n\r\n```c++\r\ntemplate<size_t SIZE, size_t ALIGN>\r\nstruct alignas(ALIGN) A {\r\n    char data[SIZE];\r\n};\r\n```\r\n\r\n?\r\n\r\n(Version: a91b6032f037ab1a26ac4baa761e809fbfeb1bdd)\r\n",
    "created_at": "2021-10-28T18:56:55Z",
    "updated_at": "2021-10-28T19:29:38Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r738666780",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/738666780"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r738666780"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/738666780/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": 267,
    "start_side": "RIGHT",
    "line": null,
    "original_line": 246,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/738672539",
    "pull_request_review_id": 792093267,
    "id": 738672539,
    "node_id": "PRRC_kwDOABII584sBz-b",
    "diff_hunk": "@@ -0,0 +1,424 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <support/allocators/node_allocator.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <list>\n+#include <map>\n+#include <string>\n+#include <type_traits>\n+#include <unordered_map>\n+\n+namespace node_allocator {\n+\n+class MemoryResourceTester\n+{\n+public:\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static size_t NumFreeAllocations(\n+        MemoryResource<ALLOCATION_SIZE_BYTES> const& mr) noexcept\n+    {\n+        size_t length = 0;\n+        auto allocation = mr.m_free_allocations;\n+        while (allocation) {\n+            allocation = static_cast<detail::FreeList const*>(allocation)->next;\n+            ++length;\n+        }\n+        return length;\n+    }\n+\n+    /**\n+     * Number of memory pools that have been allocated\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static size_t NumPools(MemoryResource<ALLOCATION_SIZE_BYTES> const& mr) noexcept\n+    {\n+        return mr.m_allocated_pools.size();\n+    }\n+\n+\n+    /**\n+     * Extracts allocation size from the type\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static constexpr size_t AllocationSizeBytes(MemoryResource<ALLOCATION_SIZE_BYTES> const&) noexcept\n+    {\n+        return ALLOCATION_SIZE_BYTES;\n+    }\n+};\n+\n+} // namespace node_allocator\n+\n+BOOST_FIXTURE_TEST_SUITE(node_allocator_tests, BasicTestingSetup)\n+\n+#define CHECK_MEMORY_RESOURCE(mr, num_free_allocations, num_pools)                   \\\n+    BOOST_CHECK_EQUAL(num_free_allocations,                                          \\\n+                      node_allocator::MemoryResourceTester::NumFreeAllocations(mr)); \\\n+    BOOST_CHECK_EQUAL(num_pools, node_allocator::MemoryResourceTester::NumPools(mr));\n+\n+#define CHECK_IN_RANGE(what, lowerInclusive, upperInclusive) \\\n+    BOOST_TEST(what >= lowerInclusive);                      \\\n+    BOOST_TEST(what <= upperInclusive);\n+\n+BOOST_AUTO_TEST_CASE(too_small)\n+{\n+    node_allocator::MemoryResource<sizeof(void*)> mr{};\n+    void* ptr{mr.Allocate<char>(1)};\n+    BOOST_CHECK(ptr != nullptr);\n+\n+    // mr is used\n+    CHECK_MEMORY_RESOURCE(mr, 0, 1);\n+    mr.Deallocate<char>(ptr, 1);\n+    CHECK_MEMORY_RESOURCE(mr, 1, 1);\n+\n+    // void* works too, use freelist\n+    ptr = mr.Allocate<void*>(1);\n+    BOOST_CHECK(ptr != nullptr);\n+    CHECK_MEMORY_RESOURCE(mr, 0, 1);\n+    mr.Deallocate<char>(ptr, 1);\n+    CHECK_MEMORY_RESOURCE(mr, 1, 1);\n+}\n+\n+BOOST_AUTO_TEST_CASE(std_unordered_map)\n+{\n+    using Factory = node_allocator::UnorderedMapFactory<uint64_t, uint64_t>;\n+\n+    Factory::MemoryResourceType mr{};\n+    auto m = Factory::CreateContainer(&mr);\n+    size_t num_free_allocations = 0;\n+    {\n+        auto a = Factory::CreateContainer(&mr);\n+\n+        // Allocator compares equal because the same memory resource is used\n+        BOOST_CHECK(a.get_allocator() == m.get_allocator());\n+        for (uint64_t i = 0; i < 1000; ++i) {\n+            a[i] = i;\n+        }\n+\n+        num_free_allocations = node_allocator::MemoryResourceTester::NumFreeAllocations(mr);\n+\n+        // create a copy of the map, destroy the map => now a lot more free allocations should be\n+        // available\n+        {\n+            auto b = a;\n+        }\n+\n+        BOOST_CHECK(node_allocator::MemoryResourceTester::NumFreeAllocations(mr) >\n+                    num_free_allocations);\n+        num_free_allocations = node_allocator::MemoryResourceTester::NumFreeAllocations(mr);\n+\n+        // creating another copy, and then destroying everything should reuse all the allocations\n+        {\n+            auto b = a;\n+        }\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr),\n+                          num_free_allocations);\n+\n+        // moving the map should not create new nodes\n+        m = std::move(a);\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr),\n+                          num_free_allocations);\n+    }\n+    // a is destroyed, still all allocations should stay roughly the same.\n+    BOOST_CHECK(node_allocator::MemoryResourceTester::NumFreeAllocations(mr) <=\n+                num_free_allocations + 5);\n+\n+    m = Factory::CreateContainer(&mr);\n+\n+    // now we got everything free\n+    BOOST_CHECK(node_allocator::MemoryResourceTester::NumFreeAllocations(mr) >\n+                num_free_allocations + 50);\n+}\n+\n+BOOST_AUTO_TEST_CASE(different_memoryresource_assignment)\n+{\n+    using Factory = node_allocator::UnorderedMapFactory<uint64_t, uint64_t>;\n+\n+    Factory::MemoryResourceType mr_a{};\n+    Factory::MemoryResourceType mr_b{};\n+\n+    {\n+        auto map_a = Factory::CreateContainer(&mr_a);\n+        for (int i = 0; i < 100; ++i) {\n+            map_a[i] = i;\n+        }\n+\n+        {\n+            auto map_b = Factory::CreateContainer(&mr_b);\n+            map_b[123] = 321;\n+            BOOST_CHECK(map_a.get_allocator() != map_b.get_allocator());\n+            BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 0);\n+            BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumPools(mr_b), 1);\n+\n+            map_b = map_a;\n+\n+            // map_a now uses mr_b, since propagate_on_container_copy_assignment is std::true_type\n+            BOOST_CHECK(map_a.get_allocator() == map_b.get_allocator());\n+            CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 1U, 2U);\n+            BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumPools(mr_b), 1);\n+\n+            // map_b was now recreated with data from map_a, using mr_a as the memory resource.\n+        }\n+\n+        // map_b destroyed, should not have any effect on mr_b\n+        CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 1U, 2U);\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumPools(mr_b), 1);\n+        // but we'll get more free allocations in mr_a\n+        CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 100U, 101U);\n+    }\n+\n+    // finally map_a is destroyed, getting more free allocations.\n+    CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 200U, 202U);\n+}\n+\n+\n+BOOST_AUTO_TEST_CASE(different_memoryresource_move)\n+{\n+    using Factory = node_allocator::UnorderedMapFactory<uint64_t, uint64_t>;\n+\n+    Factory::MemoryResourceType mr_a{};\n+    Factory::MemoryResourceType mr_b{};\n+\n+    {\n+        auto map_a = Factory::CreateContainer(&mr_a);\n+        for (int i = 0; i < 100; ++i) {\n+            map_a[i] = i;\n+        }\n+\n+        {\n+            auto map_b = Factory::CreateContainer(&mr_b);\n+            map_b[123] = 321;\n+\n+            map_b = std::move(map_a);\n+\n+            // map_a now uses mr_b, since propagate_on_container_move_assignment is std::true_type\n+            BOOST_CHECK(map_a.get_allocator() == map_b.get_allocator());\n+            CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 1U, 2U);\n+            BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumPools(mr_b), 1);\n+\n+            // map_b was now recreated with data from map_a, using mr_a as the memory resource.\n+        }\n+\n+        // map_b destroyed, should not have any effect on mr_b.\n+        CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 1U, 2U);\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumPools(mr_b), 1);\n+        // but we'll get more free allocations in mr_a\n+        CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 100U, 101U);\n+    }\n+\n+    // finally map_a is destroyed, but since it was moved, no more free allocations.\n+    CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 100U, 102U);\n+}\n+\n+\n+BOOST_AUTO_TEST_CASE(different_memoryresource_swap)\n+{\n+    using Factory = node_allocator::UnorderedMapFactory<uint64_t, uint64_t>;\n+\n+    Factory::MemoryResourceType mr_a{};\n+    Factory::MemoryResourceType mr_b{};\n+\n+    {\n+        auto map_a = Factory::CreateContainer(&mr_a);\n+        for (int i = 0; i < 100; ++i) {\n+            map_a[i] = i;\n+        }\n+\n+        {\n+            auto map_b = Factory::CreateContainer(&mr_b);\n+            map_b[123] = 321;\n+\n+            auto alloc_a = map_a.get_allocator();\n+            auto alloc_b = map_b.get_allocator();\n+\n+            std::swap(map_a, map_b);\n+\n+            // The maps have swapped, so their allocators have swapped, too.\n+            // No additional allocations have occurred!\n+            BOOST_CHECK(map_a.get_allocator() != map_b.get_allocator());\n+            BOOST_CHECK(alloc_a == map_b.get_allocator());\n+            BOOST_CHECK(alloc_b == map_a.get_allocator());\n+        }\n+\n+        // map_b destroyed, so mr_a must have plenty of free allocations now\n+        CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 100U, 101U);\n+\n+        // nothing happened to map_a, so mr_b still has no free allocations\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 0);\n+    }\n+\n+    // finally map_a is destroyed, so we got an entry back for mr_b.\n+    CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 100U, 101U);\n+    CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 1U, 2U);\n+}\n+\n+// some structs with defined alignment and customizeable size\n+\n+namespace {\n+\n+template <size_t S>\n+struct alignas(1) A1 {\n+    char data[S];\n+};\n+\n+template <size_t S>\n+struct alignas(2) A2 {\n+    char data[S];\n+};\n+\n+template <size_t S>\n+struct alignas(4) A4 {\n+    char data[S];\n+};\n+\n+template <size_t S>\n+struct alignas(8) A8 {\n+    char data[S];\n+};\n+\n+template <size_t S>\n+struct alignas(16) A16 {\n+    char data[S];\n+};\n+\n+template <size_t S>\n+struct alignas(32) A32 {\n+    char data[S];\n+};\n+\n+} // namespace\n+\n+BOOST_AUTO_TEST_CASE(calc_required_allocation_size)\n+{\n+    static_assert(sizeof(A1<1>) == 1U);\n+    static_assert(std::alignment_of_v<A1<1>> == 1U);\n+\n+    static_assert(sizeof(A16<1>) == 16U);\n+    static_assert(std::alignment_of_v<A16<1>> == 16U);\n+    static_assert(sizeof(A16<16>) == 16U);\n+    static_assert(std::alignment_of_v<A16<16>> == 16U);\n+    static_assert(sizeof(A16<24>) == 32U);\n+    static_assert(std::alignment_of_v<A16<24>> == 16U);\n+\n+#if UINTPTR_MAX == 0xFFFFFFFFFFFFFFFF\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A1<1>>());\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A1<7>>());\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A1<8>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A1<9>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A1<15>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A1<16>>());\n+    static_assert(24U == node_allocator::detail::RequiredAllocationSizeBytes<A1<17>>());\n+    static_assert(104U == node_allocator::detail::RequiredAllocationSizeBytes<A1<100>>());\n+\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A4<4>>());\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A4<7>>());\n+    static_assert(104U == node_allocator::detail::RequiredAllocationSizeBytes<A4<100>>());\n+    static_assert(104U == node_allocator::detail::RequiredAllocationSizeBytes<A8<100>>());\n+\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A8<1>>());\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A8<8>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A8<16>>());\n+\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A16<1>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A16<8>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A16<16>>());\n+    static_assert(32U == node_allocator::detail::RequiredAllocationSizeBytes<A16<17>>());",
    "path": "src/test/node_allocator_tests.cpp",
    "position": null,
    "original_position": 333,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "a91b6032f037ab1a26ac4baa761e809fbfeb1bdd",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "IMO would be good to move these A8 and bigger checks out of the preprocessor block to deduplicate and make it obvious these are all the same whether you have have 4 byte or 8 byte pointers.\r\n\r\n(Version: a91b6032f037ab1a26ac4baa761e809fbfeb1bdd)",
    "created_at": "2021-10-28T19:05:36Z",
    "updated_at": "2021-10-28T19:29:38Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r738672539",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/738672539"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r738672539"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/738672539/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": 326,
    "start_side": "RIGHT",
    "line": null,
    "original_line": 333,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/738674496",
    "pull_request_review_id": 792093267,
    "id": 738674496,
    "node_id": "PRRC_kwDOABII584sB0dA",
    "diff_hunk": "@@ -0,0 +1,424 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <support/allocators/node_allocator.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <list>\n+#include <map>\n+#include <string>\n+#include <type_traits>\n+#include <unordered_map>\n+\n+namespace node_allocator {\n+\n+class MemoryResourceTester\n+{\n+public:\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static size_t NumFreeAllocations(\n+        MemoryResource<ALLOCATION_SIZE_BYTES> const& mr) noexcept\n+    {\n+        size_t length = 0;\n+        auto allocation = mr.m_free_allocations;\n+        while (allocation) {\n+            allocation = static_cast<detail::FreeList const*>(allocation)->next;\n+            ++length;\n+        }\n+        return length;\n+    }\n+\n+    /**\n+     * Number of memory pools that have been allocated\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static size_t NumPools(MemoryResource<ALLOCATION_SIZE_BYTES> const& mr) noexcept\n+    {\n+        return mr.m_allocated_pools.size();\n+    }\n+\n+\n+    /**\n+     * Extracts allocation size from the type\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static constexpr size_t AllocationSizeBytes(MemoryResource<ALLOCATION_SIZE_BYTES> const&) noexcept\n+    {\n+        return ALLOCATION_SIZE_BYTES;\n+    }\n+};\n+\n+} // namespace node_allocator\n+\n+BOOST_FIXTURE_TEST_SUITE(node_allocator_tests, BasicTestingSetup)\n+\n+#define CHECK_MEMORY_RESOURCE(mr, num_free_allocations, num_pools)                   \\\n+    BOOST_CHECK_EQUAL(num_free_allocations,                                          \\\n+                      node_allocator::MemoryResourceTester::NumFreeAllocations(mr)); \\\n+    BOOST_CHECK_EQUAL(num_pools, node_allocator::MemoryResourceTester::NumPools(mr));\n+\n+#define CHECK_IN_RANGE(what, lowerInclusive, upperInclusive) \\\n+    BOOST_TEST(what >= lowerInclusive);                      \\\n+    BOOST_TEST(what <= upperInclusive);\n+\n+BOOST_AUTO_TEST_CASE(too_small)\n+{\n+    node_allocator::MemoryResource<sizeof(void*)> mr{};\n+    void* ptr{mr.Allocate<char>(1)};\n+    BOOST_CHECK(ptr != nullptr);\n+\n+    // mr is used\n+    CHECK_MEMORY_RESOURCE(mr, 0, 1);\n+    mr.Deallocate<char>(ptr, 1);\n+    CHECK_MEMORY_RESOURCE(mr, 1, 1);\n+\n+    // void* works too, use freelist\n+    ptr = mr.Allocate<void*>(1);\n+    BOOST_CHECK(ptr != nullptr);\n+    CHECK_MEMORY_RESOURCE(mr, 0, 1);\n+    mr.Deallocate<char>(ptr, 1);\n+    CHECK_MEMORY_RESOURCE(mr, 1, 1);\n+}\n+\n+BOOST_AUTO_TEST_CASE(std_unordered_map)\n+{\n+    using Factory = node_allocator::UnorderedMapFactory<uint64_t, uint64_t>;\n+\n+    Factory::MemoryResourceType mr{};\n+    auto m = Factory::CreateContainer(&mr);\n+    size_t num_free_allocations = 0;\n+    {\n+        auto a = Factory::CreateContainer(&mr);\n+\n+        // Allocator compares equal because the same memory resource is used\n+        BOOST_CHECK(a.get_allocator() == m.get_allocator());\n+        for (uint64_t i = 0; i < 1000; ++i) {\n+            a[i] = i;\n+        }\n+\n+        num_free_allocations = node_allocator::MemoryResourceTester::NumFreeAllocations(mr);\n+\n+        // create a copy of the map, destroy the map => now a lot more free allocations should be\n+        // available\n+        {\n+            auto b = a;\n+        }\n+\n+        BOOST_CHECK(node_allocator::MemoryResourceTester::NumFreeAllocations(mr) >\n+                    num_free_allocations);\n+        num_free_allocations = node_allocator::MemoryResourceTester::NumFreeAllocations(mr);\n+\n+        // creating another copy, and then destroying everything should reuse all the allocations\n+        {\n+            auto b = a;\n+        }\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr),\n+                          num_free_allocations);\n+\n+        // moving the map should not create new nodes\n+        m = std::move(a);\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr),\n+                          num_free_allocations);\n+    }\n+    // a is destroyed, still all allocations should stay roughly the same.\n+    BOOST_CHECK(node_allocator::MemoryResourceTester::NumFreeAllocations(mr) <=\n+                num_free_allocations + 5);\n+\n+    m = Factory::CreateContainer(&mr);\n+\n+    // now we got everything free\n+    BOOST_CHECK(node_allocator::MemoryResourceTester::NumFreeAllocations(mr) >\n+                num_free_allocations + 50);\n+}\n+\n+BOOST_AUTO_TEST_CASE(different_memoryresource_assignment)\n+{\n+    using Factory = node_allocator::UnorderedMapFactory<uint64_t, uint64_t>;\n+\n+    Factory::MemoryResourceType mr_a{};\n+    Factory::MemoryResourceType mr_b{};\n+\n+    {\n+        auto map_a = Factory::CreateContainer(&mr_a);\n+        for (int i = 0; i < 100; ++i) {\n+            map_a[i] = i;\n+        }\n+\n+        {\n+            auto map_b = Factory::CreateContainer(&mr_b);\n+            map_b[123] = 321;\n+            BOOST_CHECK(map_a.get_allocator() != map_b.get_allocator());\n+            BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 0);\n+            BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumPools(mr_b), 1);\n+\n+            map_b = map_a;\n+\n+            // map_a now uses mr_b, since propagate_on_container_copy_assignment is std::true_type\n+            BOOST_CHECK(map_a.get_allocator() == map_b.get_allocator());\n+            CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 1U, 2U);\n+            BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumPools(mr_b), 1);\n+\n+            // map_b was now recreated with data from map_a, using mr_a as the memory resource.\n+        }\n+\n+        // map_b destroyed, should not have any effect on mr_b\n+        CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 1U, 2U);\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumPools(mr_b), 1);\n+        // but we'll get more free allocations in mr_a\n+        CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 100U, 101U);\n+    }\n+\n+    // finally map_a is destroyed, getting more free allocations.\n+    CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 200U, 202U);\n+}\n+\n+\n+BOOST_AUTO_TEST_CASE(different_memoryresource_move)\n+{\n+    using Factory = node_allocator::UnorderedMapFactory<uint64_t, uint64_t>;\n+\n+    Factory::MemoryResourceType mr_a{};\n+    Factory::MemoryResourceType mr_b{};\n+\n+    {\n+        auto map_a = Factory::CreateContainer(&mr_a);\n+        for (int i = 0; i < 100; ++i) {\n+            map_a[i] = i;\n+        }\n+\n+        {\n+            auto map_b = Factory::CreateContainer(&mr_b);\n+            map_b[123] = 321;\n+\n+            map_b = std::move(map_a);\n+\n+            // map_a now uses mr_b, since propagate_on_container_move_assignment is std::true_type\n+            BOOST_CHECK(map_a.get_allocator() == map_b.get_allocator());\n+            CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 1U, 2U);\n+            BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumPools(mr_b), 1);\n+\n+            // map_b was now recreated with data from map_a, using mr_a as the memory resource.\n+        }\n+\n+        // map_b destroyed, should not have any effect on mr_b.\n+        CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 1U, 2U);\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumPools(mr_b), 1);\n+        // but we'll get more free allocations in mr_a\n+        CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 100U, 101U);\n+    }\n+\n+    // finally map_a is destroyed, but since it was moved, no more free allocations.\n+    CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 100U, 102U);\n+}\n+\n+\n+BOOST_AUTO_TEST_CASE(different_memoryresource_swap)\n+{\n+    using Factory = node_allocator::UnorderedMapFactory<uint64_t, uint64_t>;\n+\n+    Factory::MemoryResourceType mr_a{};\n+    Factory::MemoryResourceType mr_b{};\n+\n+    {\n+        auto map_a = Factory::CreateContainer(&mr_a);\n+        for (int i = 0; i < 100; ++i) {\n+            map_a[i] = i;\n+        }\n+\n+        {\n+            auto map_b = Factory::CreateContainer(&mr_b);\n+            map_b[123] = 321;\n+\n+            auto alloc_a = map_a.get_allocator();\n+            auto alloc_b = map_b.get_allocator();\n+\n+            std::swap(map_a, map_b);\n+\n+            // The maps have swapped, so their allocators have swapped, too.\n+            // No additional allocations have occurred!\n+            BOOST_CHECK(map_a.get_allocator() != map_b.get_allocator());\n+            BOOST_CHECK(alloc_a == map_b.get_allocator());\n+            BOOST_CHECK(alloc_b == map_a.get_allocator());\n+        }\n+\n+        // map_b destroyed, so mr_a must have plenty of free allocations now\n+        CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 100U, 101U);\n+\n+        // nothing happened to map_a, so mr_b still has no free allocations\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 0);\n+    }\n+\n+    // finally map_a is destroyed, so we got an entry back for mr_b.\n+    CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 100U, 101U);\n+    CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 1U, 2U);\n+}\n+\n+// some structs with defined alignment and customizeable size\n+\n+namespace {\n+\n+template <size_t S>\n+struct alignas(1) A1 {\n+    char data[S];\n+};\n+\n+template <size_t S>\n+struct alignas(2) A2 {\n+    char data[S];\n+};\n+\n+template <size_t S>\n+struct alignas(4) A4 {\n+    char data[S];\n+};\n+\n+template <size_t S>\n+struct alignas(8) A8 {\n+    char data[S];\n+};\n+\n+template <size_t S>\n+struct alignas(16) A16 {\n+    char data[S];\n+};\n+\n+template <size_t S>\n+struct alignas(32) A32 {\n+    char data[S];\n+};\n+\n+} // namespace\n+\n+BOOST_AUTO_TEST_CASE(calc_required_allocation_size)\n+{\n+    static_assert(sizeof(A1<1>) == 1U);\n+    static_assert(std::alignment_of_v<A1<1>> == 1U);\n+\n+    static_assert(sizeof(A16<1>) == 16U);\n+    static_assert(std::alignment_of_v<A16<1>> == 16U);\n+    static_assert(sizeof(A16<16>) == 16U);\n+    static_assert(std::alignment_of_v<A16<16>> == 16U);\n+    static_assert(sizeof(A16<24>) == 32U);\n+    static_assert(std::alignment_of_v<A16<24>> == 16U);\n+\n+#if UINTPTR_MAX == 0xFFFFFFFFFFFFFFFF\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A1<1>>());\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A1<7>>());\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A1<8>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A1<9>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A1<15>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A1<16>>());\n+    static_assert(24U == node_allocator::detail::RequiredAllocationSizeBytes<A1<17>>());\n+    static_assert(104U == node_allocator::detail::RequiredAllocationSizeBytes<A1<100>>());\n+\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A4<4>>());\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A4<7>>());\n+    static_assert(104U == node_allocator::detail::RequiredAllocationSizeBytes<A4<100>>());\n+    static_assert(104U == node_allocator::detail::RequiredAllocationSizeBytes<A8<100>>());\n+\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A8<1>>());\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A8<8>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A8<16>>());\n+\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A16<1>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A16<8>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A16<16>>());\n+    static_assert(32U == node_allocator::detail::RequiredAllocationSizeBytes<A16<17>>());\n+#elif UINTPTR_MAX == 0xFFFFFFFF\n+    static_assert(4U == node_allocator::detail::RequiredAllocationSizeBytes<A1<1>>());\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A1<7>>());\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A1<8>>());\n+    static_assert(12U == node_allocator::detail::RequiredAllocationSizeBytes<A1<9>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A1<15>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A1<16>>());\n+    static_assert(20U == node_allocator::detail::RequiredAllocationSizeBytes<A1<17>>());\n+    static_assert(100U == node_allocator::detail::RequiredAllocationSizeBytes<A1<100>>());\n+\n+    static_assert(4U == node_allocator::detail::RequiredAllocationSizeBytes<A4<4>>());\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A4<7>>());\n+    static_assert(100U == node_allocator::detail::RequiredAllocationSizeBytes<A4<100>>());\n+    static_assert(104U == node_allocator::detail::RequiredAllocationSizeBytes<A8<100>>());\n+\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A8<1>>());\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A8<8>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A8<16>>());\n+\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A16<1>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A16<8>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A16<16>>());\n+    static_assert(32U == node_allocator::detail::RequiredAllocationSizeBytes<A16<17>>());\n+#else\n+#error \"Invalid sizeof(void*)\"\n+#endif\n+}\n+\n+namespace {\n+\n+template <typename T>\n+struct NotNoexceptHash {\n+    size_t operator()(const T& x) const /* noexcept */ { return std::hash<T>{}(x); }",
    "path": "src/test/node_allocator_tests.cpp",
    "position": null,
    "original_position": 366,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "a91b6032f037ab1a26ac4baa761e809fbfeb1bdd",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Suggest writing `/* not noexcept */` to make comment intent more plain.\r\n\r\nAlso, I have only the vaguest understanding of noexcept but could this be [`noexcept(false)`](https://en.cppreference.com/w/cpp/language/noexcept_spec)?\r\n\r\n(Version: a91b6032f037ab1a26ac4baa761e809fbfeb1bdd)\r\n",
    "created_at": "2021-10-28T19:08:29Z",
    "updated_at": "2021-10-28T19:29:38Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r738674496",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/738674496"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r738674496"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/738674496/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 366,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/738677808",
    "pull_request_review_id": 792093267,
    "id": 738677808,
    "node_id": "PRRC_kwDOABII584sB1Qw",
    "diff_hunk": "@@ -0,0 +1,424 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <support/allocators/node_allocator.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <list>\n+#include <map>\n+#include <string>\n+#include <type_traits>\n+#include <unordered_map>\n+\n+namespace node_allocator {\n+\n+class MemoryResourceTester\n+{\n+public:\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static size_t NumFreeAllocations(\n+        MemoryResource<ALLOCATION_SIZE_BYTES> const& mr) noexcept\n+    {\n+        size_t length = 0;\n+        auto allocation = mr.m_free_allocations;\n+        while (allocation) {\n+            allocation = static_cast<detail::FreeList const*>(allocation)->next;\n+            ++length;\n+        }\n+        return length;\n+    }\n+\n+    /**\n+     * Number of memory pools that have been allocated\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static size_t NumPools(MemoryResource<ALLOCATION_SIZE_BYTES> const& mr) noexcept\n+    {\n+        return mr.m_allocated_pools.size();\n+    }\n+\n+\n+    /**\n+     * Extracts allocation size from the type\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static constexpr size_t AllocationSizeBytes(MemoryResource<ALLOCATION_SIZE_BYTES> const&) noexcept\n+    {\n+        return ALLOCATION_SIZE_BYTES;\n+    }\n+};\n+\n+} // namespace node_allocator\n+\n+BOOST_FIXTURE_TEST_SUITE(node_allocator_tests, BasicTestingSetup)\n+\n+#define CHECK_MEMORY_RESOURCE(mr, num_free_allocations, num_pools)                   \\\n+    BOOST_CHECK_EQUAL(num_free_allocations,                                          \\\n+                      node_allocator::MemoryResourceTester::NumFreeAllocations(mr)); \\\n+    BOOST_CHECK_EQUAL(num_pools, node_allocator::MemoryResourceTester::NumPools(mr));\n+\n+#define CHECK_IN_RANGE(what, lowerInclusive, upperInclusive) \\\n+    BOOST_TEST(what >= lowerInclusive);                      \\\n+    BOOST_TEST(what <= upperInclusive);\n+\n+BOOST_AUTO_TEST_CASE(too_small)\n+{\n+    node_allocator::MemoryResource<sizeof(void*)> mr{};\n+    void* ptr{mr.Allocate<char>(1)};\n+    BOOST_CHECK(ptr != nullptr);\n+\n+    // mr is used\n+    CHECK_MEMORY_RESOURCE(mr, 0, 1);\n+    mr.Deallocate<char>(ptr, 1);\n+    CHECK_MEMORY_RESOURCE(mr, 1, 1);\n+\n+    // void* works too, use freelist\n+    ptr = mr.Allocate<void*>(1);\n+    BOOST_CHECK(ptr != nullptr);\n+    CHECK_MEMORY_RESOURCE(mr, 0, 1);\n+    mr.Deallocate<char>(ptr, 1);\n+    CHECK_MEMORY_RESOURCE(mr, 1, 1);\n+}\n+\n+BOOST_AUTO_TEST_CASE(std_unordered_map)\n+{\n+    using Factory = node_allocator::UnorderedMapFactory<uint64_t, uint64_t>;\n+\n+    Factory::MemoryResourceType mr{};\n+    auto m = Factory::CreateContainer(&mr);\n+    size_t num_free_allocations = 0;\n+    {\n+        auto a = Factory::CreateContainer(&mr);\n+\n+        // Allocator compares equal because the same memory resource is used\n+        BOOST_CHECK(a.get_allocator() == m.get_allocator());\n+        for (uint64_t i = 0; i < 1000; ++i) {\n+            a[i] = i;\n+        }\n+\n+        num_free_allocations = node_allocator::MemoryResourceTester::NumFreeAllocations(mr);\n+\n+        // create a copy of the map, destroy the map => now a lot more free allocations should be\n+        // available\n+        {\n+            auto b = a;\n+        }\n+\n+        BOOST_CHECK(node_allocator::MemoryResourceTester::NumFreeAllocations(mr) >\n+                    num_free_allocations);\n+        num_free_allocations = node_allocator::MemoryResourceTester::NumFreeAllocations(mr);\n+\n+        // creating another copy, and then destroying everything should reuse all the allocations\n+        {\n+            auto b = a;\n+        }\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr),\n+                          num_free_allocations);\n+\n+        // moving the map should not create new nodes\n+        m = std::move(a);\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr),\n+                          num_free_allocations);\n+    }\n+    // a is destroyed, still all allocations should stay roughly the same.\n+    BOOST_CHECK(node_allocator::MemoryResourceTester::NumFreeAllocations(mr) <=\n+                num_free_allocations + 5);\n+\n+    m = Factory::CreateContainer(&mr);\n+\n+    // now we got everything free\n+    BOOST_CHECK(node_allocator::MemoryResourceTester::NumFreeAllocations(mr) >\n+                num_free_allocations + 50);\n+}\n+\n+BOOST_AUTO_TEST_CASE(different_memoryresource_assignment)\n+{\n+    using Factory = node_allocator::UnorderedMapFactory<uint64_t, uint64_t>;\n+\n+    Factory::MemoryResourceType mr_a{};\n+    Factory::MemoryResourceType mr_b{};\n+\n+    {\n+        auto map_a = Factory::CreateContainer(&mr_a);\n+        for (int i = 0; i < 100; ++i) {\n+            map_a[i] = i;\n+        }\n+\n+        {\n+            auto map_b = Factory::CreateContainer(&mr_b);\n+            map_b[123] = 321;\n+            BOOST_CHECK(map_a.get_allocator() != map_b.get_allocator());\n+            BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 0);\n+            BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumPools(mr_b), 1);\n+\n+            map_b = map_a;\n+\n+            // map_a now uses mr_b, since propagate_on_container_copy_assignment is std::true_type\n+            BOOST_CHECK(map_a.get_allocator() == map_b.get_allocator());\n+            CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 1U, 2U);\n+            BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumPools(mr_b), 1);\n+\n+            // map_b was now recreated with data from map_a, using mr_a as the memory resource.\n+        }\n+\n+        // map_b destroyed, should not have any effect on mr_b\n+        CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 1U, 2U);\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumPools(mr_b), 1);\n+        // but we'll get more free allocations in mr_a\n+        CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 100U, 101U);\n+    }\n+\n+    // finally map_a is destroyed, getting more free allocations.\n+    CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 200U, 202U);\n+}\n+\n+\n+BOOST_AUTO_TEST_CASE(different_memoryresource_move)\n+{\n+    using Factory = node_allocator::UnorderedMapFactory<uint64_t, uint64_t>;\n+\n+    Factory::MemoryResourceType mr_a{};\n+    Factory::MemoryResourceType mr_b{};\n+\n+    {\n+        auto map_a = Factory::CreateContainer(&mr_a);\n+        for (int i = 0; i < 100; ++i) {\n+            map_a[i] = i;\n+        }\n+\n+        {\n+            auto map_b = Factory::CreateContainer(&mr_b);\n+            map_b[123] = 321;\n+\n+            map_b = std::move(map_a);\n+\n+            // map_a now uses mr_b, since propagate_on_container_move_assignment is std::true_type\n+            BOOST_CHECK(map_a.get_allocator() == map_b.get_allocator());\n+            CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 1U, 2U);\n+            BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumPools(mr_b), 1);\n+\n+            // map_b was now recreated with data from map_a, using mr_a as the memory resource.\n+        }\n+\n+        // map_b destroyed, should not have any effect on mr_b.\n+        CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 1U, 2U);\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumPools(mr_b), 1);\n+        // but we'll get more free allocations in mr_a\n+        CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 100U, 101U);\n+    }\n+\n+    // finally map_a is destroyed, but since it was moved, no more free allocations.\n+    CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 100U, 102U);\n+}\n+\n+\n+BOOST_AUTO_TEST_CASE(different_memoryresource_swap)\n+{\n+    using Factory = node_allocator::UnorderedMapFactory<uint64_t, uint64_t>;\n+\n+    Factory::MemoryResourceType mr_a{};\n+    Factory::MemoryResourceType mr_b{};\n+\n+    {\n+        auto map_a = Factory::CreateContainer(&mr_a);\n+        for (int i = 0; i < 100; ++i) {\n+            map_a[i] = i;\n+        }\n+\n+        {\n+            auto map_b = Factory::CreateContainer(&mr_b);\n+            map_b[123] = 321;\n+\n+            auto alloc_a = map_a.get_allocator();\n+            auto alloc_b = map_b.get_allocator();\n+\n+            std::swap(map_a, map_b);\n+\n+            // The maps have swapped, so their allocators have swapped, too.\n+            // No additional allocations have occurred!\n+            BOOST_CHECK(map_a.get_allocator() != map_b.get_allocator());\n+            BOOST_CHECK(alloc_a == map_b.get_allocator());\n+            BOOST_CHECK(alloc_b == map_a.get_allocator());\n+        }\n+\n+        // map_b destroyed, so mr_a must have plenty of free allocations now\n+        CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 100U, 101U);\n+\n+        // nothing happened to map_a, so mr_b still has no free allocations\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 0);\n+    }\n+\n+    // finally map_a is destroyed, so we got an entry back for mr_b.\n+    CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 100U, 101U);\n+    CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 1U, 2U);\n+}\n+\n+// some structs with defined alignment and customizeable size\n+\n+namespace {\n+\n+template <size_t S>\n+struct alignas(1) A1 {\n+    char data[S];\n+};\n+\n+template <size_t S>\n+struct alignas(2) A2 {\n+    char data[S];\n+};\n+\n+template <size_t S>\n+struct alignas(4) A4 {\n+    char data[S];\n+};\n+\n+template <size_t S>\n+struct alignas(8) A8 {\n+    char data[S];\n+};\n+\n+template <size_t S>\n+struct alignas(16) A16 {\n+    char data[S];\n+};\n+\n+template <size_t S>\n+struct alignas(32) A32 {\n+    char data[S];\n+};\n+\n+} // namespace\n+\n+BOOST_AUTO_TEST_CASE(calc_required_allocation_size)\n+{\n+    static_assert(sizeof(A1<1>) == 1U);\n+    static_assert(std::alignment_of_v<A1<1>> == 1U);\n+\n+    static_assert(sizeof(A16<1>) == 16U);\n+    static_assert(std::alignment_of_v<A16<1>> == 16U);\n+    static_assert(sizeof(A16<16>) == 16U);\n+    static_assert(std::alignment_of_v<A16<16>> == 16U);\n+    static_assert(sizeof(A16<24>) == 32U);\n+    static_assert(std::alignment_of_v<A16<24>> == 16U);\n+\n+#if UINTPTR_MAX == 0xFFFFFFFFFFFFFFFF\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A1<1>>());\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A1<7>>());\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A1<8>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A1<9>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A1<15>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A1<16>>());\n+    static_assert(24U == node_allocator::detail::RequiredAllocationSizeBytes<A1<17>>());\n+    static_assert(104U == node_allocator::detail::RequiredAllocationSizeBytes<A1<100>>());\n+\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A4<4>>());\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A4<7>>());\n+    static_assert(104U == node_allocator::detail::RequiredAllocationSizeBytes<A4<100>>());\n+    static_assert(104U == node_allocator::detail::RequiredAllocationSizeBytes<A8<100>>());\n+\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A8<1>>());\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A8<8>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A8<16>>());\n+\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A16<1>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A16<8>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A16<16>>());\n+    static_assert(32U == node_allocator::detail::RequiredAllocationSizeBytes<A16<17>>());\n+#elif UINTPTR_MAX == 0xFFFFFFFF\n+    static_assert(4U == node_allocator::detail::RequiredAllocationSizeBytes<A1<1>>());\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A1<7>>());\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A1<8>>());\n+    static_assert(12U == node_allocator::detail::RequiredAllocationSizeBytes<A1<9>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A1<15>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A1<16>>());\n+    static_assert(20U == node_allocator::detail::RequiredAllocationSizeBytes<A1<17>>());\n+    static_assert(100U == node_allocator::detail::RequiredAllocationSizeBytes<A1<100>>());\n+\n+    static_assert(4U == node_allocator::detail::RequiredAllocationSizeBytes<A4<4>>());\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A4<7>>());\n+    static_assert(100U == node_allocator::detail::RequiredAllocationSizeBytes<A4<100>>());\n+    static_assert(104U == node_allocator::detail::RequiredAllocationSizeBytes<A8<100>>());\n+\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A8<1>>());\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A8<8>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A8<16>>());\n+\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A16<1>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A16<8>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A16<16>>());\n+    static_assert(32U == node_allocator::detail::RequiredAllocationSizeBytes<A16<17>>());\n+#else\n+#error \"Invalid sizeof(void*)\"\n+#endif\n+}\n+\n+namespace {\n+\n+template <typename T>\n+struct NotNoexceptHash {\n+    size_t operator()(const T& x) const /* noexcept */ { return std::hash<T>{}(x); }\n+};\n+\n+} // namespace\n+\n+template <typename Key, typename Value, typename Hash = std::hash<Key>>\n+void TestAllocationsAreUsed()\n+{\n+    using Factory = node_allocator::UnorderedMapFactory<Key, Value, Hash>;\n+    typename Factory::MemoryResourceType mr{};\n+    BOOST_TEST_MESSAGE(\n+        strprintf(\"%u sizeof(void*), %u/%u/%u sizeof Key/Value/Pair, %u ALLOCATION_SIZE_BYTES\",\n+                  sizeof(void*), sizeof(Key), sizeof(Value), sizeof(std::pair<const Key, Value>),\n+                  node_allocator::MemoryResourceTester::AllocationSizeBytes(mr)));\n+    {\n+        auto map = Factory::CreateContainer(&mr);\n+        for (size_t i = 0; i < 5; ++i) {\n+            map[i];\n+        }\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr), 0);\n+        map.clear();\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr), 5);\n+\n+        for (size_t i = 0; i < 5; ++i) {\n+            map[i];\n+        }\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr), 0);\n+        map.clear();\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr), 5);\n+    }\n+\n+    // makes sure clear frees all allocations. With MSVC there might be an additional allocation\n+    // used for a control structure.",
    "path": "src/test/node_allocator_tests.cpp",
    "position": null,
    "original_position": 398,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "a91b6032f037ab1a26ac4baa761e809fbfeb1bdd",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "The hidden mystery of node_allocator_tests is revealed! This is reason for all the IN_RANGE(101, 102) stuff :arrow_up:. I wish there was a spoiler tag.\r\n\r\n(Version: a91b6032f037ab1a26ac4baa761e809fbfeb1bdd)",
    "created_at": "2021-10-28T19:13:31Z",
    "updated_at": "2021-10-28T19:29:38Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r738677808",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/738677808"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r738677808"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/738677808/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": 397,
    "start_side": "RIGHT",
    "line": null,
    "original_line": 398,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/739020569",
    "pull_request_review_id": 792741454,
    "id": 739020569,
    "node_id": "PRRC_kwDOABII584sDI8Z",
    "diff_hunk": "@@ -0,0 +1,406 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <memory>\n+#include <new>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based\n+ * containers that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs pools of memory and uses these to carve out memory for the nodes. Nodes\n+ * that are destroyed by the Allocator are actually put back into a free list for further use. This\n+ * behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored\n+ * in-place. This typically saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with\n+ * low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but\n+ * there is no standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to\n+ * the system. Memory is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on\n+ * proximity. So freeing and malloc'ing again can become a random access pattern which can lead to\n+ * more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers.\n+ * Similar to `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages memory. Currently\n+ * it is only able to provide optimized alloc/free for a single fixed allocation size which is given\n+ * in the constructor. Only allocations that match this size will be provided from the preallocated\n+ * pools of memory; all other requests simply use ::operator new(). To get the correct node size in\n+ * all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios\n+ * in `node_allocator_tests/test_allocations_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall \u201cHow to Write a Custom Allocator\u201d\n+ *   https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer \u201cAn Allocator is a Handle to a Heap\u201d\n+ *   https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *   https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+namespace detail {\n+\n+/**\n+ * In-place linked list of the allocations, used for the free list.\n+ */\n+struct FreeList {\n+    void* next;\n+};\n+\n+/**\n+ * Calculates the required allocation size for the given type.\n+ * The memory needs to be correctly aligned and large enough for both both T and FreeList.\n+ */\n+template <typename T>\n+[[nodiscard]] constexpr size_t RequiredAllocationSizeBytes() noexcept\n+{\n+    const auto alignment_max = std::max(std::alignment_of_v<T>, std::alignment_of_v<FreeList>);\n+    const auto size_max = std::max(sizeof(T), sizeof(FreeList));\n+\n+    // find closest multiple of alignment_max that holds size_max\n+    return ((size_max + alignment_max - 1U) / alignment_max) * alignment_max;\n+}\n+\n+} // namespace detail\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It\n+ * stores a number of memory pools which are used to quickly give out memory of a fixed allocation\n+ * size. The class is purposely kept very simple. It only knows about \"Allocations\" and \"Pools\".\n+ *\n+ * - Pool: MemoryResource allocates one memory pool at a time. These pools are kept around until the\n+ * memory resource is destroyed.\n+ *\n+ * - Allocations: Node-based containers allocate one node at a time. Whenever that happens, the\n+ * MemoryResource's Allocate() gives out memory for one node. These are carved out from a previously\n+ * allocated memory pool, or from a free list if it contains entries. Whenever a node is given back\n+ * with Deallocate(), it is put into that free list.\n+ */\n+template <size_t ALLOCATION_SIZE_BYTES>\n+class MemoryResource\n+{\n+    /**\n+     * Size in bytes to allocate per pool, currently hardcoded to multiple of ALLOCATION_SIZE_BYTES\n+     * that comes closest to 256 KiB.\n+     */\n+    static constexpr size_t POOL_SIZE_BYTES = (262144 / ALLOCATION_SIZE_BYTES) * ALLOCATION_SIZE_BYTES;\n+\n+public:\n+    /**\n+     * Construct a new MemoryResource object that uses the specified allocation size to optimize for.\n+     */\n+    MemoryResource() = default;\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated pools.\n+     *\n+     * There's no Clear() method on purpose, because it would be dangerous. E.g. when calling\n+     * clear() on an unordered_map, it is not certain that all allocated nodes are given back to the\n+     * MemoryResource. Microsoft's STL still uses a control structure that might have the same size\n+     * as the nodes, and therefore needs to be kept around until the map is actually destroyed.\n+     */\n+    ~MemoryResource() = default;\n+\n+    /**\n+     * Allocates memory for n * sizeof(T). Only when n==1 and T's size matches ALLOCATION_SIZE_BYTES\n+     * the pool's memory is used. Otherwise, the allocation is forwarded to ::operator new().\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        if constexpr (ALLOCATION_SIZE_BYTES == detail::RequiredAllocationSizeBytes<T>()) {\n+            if (n != 1) {\n+                // pool is not used so forward to operator new.\n+                return static_cast<T*>(::operator new(n * sizeof(T)));\n+            }\n+\n+            if (m_free_allocations) {\n+                // we've already got data in the free list, unlink one element\n+                auto old_head = m_free_allocations;\n+                m_free_allocations = static_cast<detail::FreeList*>(m_free_allocations)->next;\n+                return static_cast<T*>(old_head);\n+            }\n+\n+            // free list is empty: get one allocation from allocated pool memory.\n+            // It makes sense to not create the fully linked list of an allocated pool up-front, for\n+            // several reasons. On the one hand, the latency is higher when we need to iterate and\n+            // update pointers for the whole pool at once. More importantly, most systems lazily\n+            // allocate data. So when we allocate a big pool of memory the memory for a page is only\n+            // actually made available to the program when it is first touched. So when we allocate\n+            // a big pool and only use very little memory from it, the total memory usage is lower\n+            // than what has been malloc'ed.\n+            if (m_untouched_memory_iterator == m_untouched_memory_end) {\n+                // slow path, only happens when a new pool needs to be allocated\n+                AllocatePool();\n+            }\n+\n+            // peel off one allocation from the untouched memory. The next pointer of in-use\n+            // elements doesn't matter until it is deallocated, only then it is used to form the\n+            // free list.\n+            const auto tmp = m_untouched_memory_iterator;\n+            m_untouched_memory_iterator = static_cast<char*>(tmp) + ALLOCATION_SIZE_BYTES;\n+            return static_cast<T*>(tmp);\n+        } else {\n+            // pool is not used so forward to operator new.\n+            return static_cast<T*>(::operator new(n * sizeof(T)));\n+        }\n+    }\n+\n+    /**\n+     * Puts p back into the free list if it was actually allocated from the memory pool.\n+     * Otherwise, simply call ::operator delete(p).\n+     */\n+    template <typename T>\n+    void Deallocate(void* p, size_t n) noexcept\n+    {\n+        if constexpr (ALLOCATION_SIZE_BYTES == detail::RequiredAllocationSizeBytes<T>()) {\n+            if (n != 1) {\n+                // allocation didn't happen with the pool\n+                ::operator delete(p);\n+                return;\n+            }\n+\n+            // put it into the linked list\n+            const auto allocation = static_cast<detail::FreeList*>(p);\n+            allocation->next = m_free_allocations;\n+            m_free_allocations = allocation;\n+        } else {\n+            // allocation didn't happen with the pool\n+            ::operator delete(p);\n+        }\n+    }\n+\n+    /**\n+     * Calculates bytes allocated by the memory resource.\n+     */\n+    [[nodiscard]] size_t DynamicMemoryUsage() const noexcept\n+    {\n+        return memusage::MallocUsage(POOL_SIZE_BYTES) * m_allocated_pools.size() + memusage::DynamicUsage(m_allocated_pools);\n+    }\n+\n+private:\n+    //! Access to internals for testing purpose only\n+    friend class MemoryResourceTester;\n+\n+    /**\n+     * Allocate one full memory pool which is used to carve out allocations.\n+     */\n+    void AllocatePool()\n+    {\n+        m_allocated_pools.emplace_back(new char[POOL_SIZE_BYTES]);\n+        m_untouched_memory_iterator = m_allocated_pools.back().get();\n+        m_untouched_memory_end = m_allocated_pools.back().get() + POOL_SIZE_BYTES;\n+    }\n+\n+    //! Contains all allocated pools of memory, used to free the data in the destructor.\n+    std::vector<std::unique_ptr<char[]>> m_allocated_pools{};\n+\n+    //! A single linked list of all data available in the MemoryResource. This list is used for\n+    //! allocations of single elements.\n+    void* m_free_allocations = nullptr;\n+\n+    //! Points to the beginning of available memory for carving out allocations.\n+    void* m_untouched_memory_iterator = nullptr;\n+\n+    //! Points to the end of available memory for carving out allocations.\n+    void* m_untouched_memory_end = nullptr;\n+};\n+\n+\n+/**\n+ * Allocator that's usable for node-based containers like std::unordered_map or std::list.\n+ *\n+ * The allocator is stateful, and can be cheaply copied. Its state is an immobile MemoryResource,\n+ * which actually does all the allocation/deallocations. So this class is just a simple wrapper that\n+ * conforms to the required STL interface to be usable for the node-based containers.\n+ */\n+template <typename T, size_t ALLOCATION_SIZE_BYTES>\n+class Allocator\n+{\n+    template <typename U, size_t AS>\n+    friend class Allocator;\n+\n+    template <typename X, typename Y, size_t AS>\n+    friend bool operator==(const Allocator<X, AS>& a, const Allocator<Y, AS>& b) noexcept;\n+\n+public:\n+    using value_type = T;\n+\n+    /**\n+     * The allocator is stateful so we can't use the compile time `is_always_equal` optimization and\n+     * have to use the runtime operator==.\n+     */\n+    using is_always_equal = std::false_type;\n+\n+    /**\n+     * Move assignment should be a fast operation. In the case of a = std::move(b), we want\n+     * a to be able to use b's allocator, otherwise all elements would have to be recreated with a's\n+     * old allocator.\n+     */\n+    using propagate_on_container_move_assignment = std::true_type;\n+\n+    /**\n+     * Swapping two containers with unequal allocators who are *not* propagated is undefined\n+     * behavior. Unfortunately this is the default! Obviously, we don't want that.",
    "path": "src/support/allocators/node_allocator.h",
    "position": null,
    "original_position": 286,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "a91b6032f037ab1a26ac4baa761e809fbfeb1bdd",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "I'll reword my comment, I meant that the default for `propagate_on_container_swap` is `std::false_type`, which is bad because that's undefined behavior. I'll change the comment:\r\n\r\n```cpp\r\n    /**\r\n     * The default for propagate_on_container_swap is std::false_type. This is bad,because swapping\r\n     * two containers with unequal allocators but not propagating the allocator is undefined\r\n     * behavior! Obviously, we want so swap the allocator as well, so we set that to true.\r\n     *\r\n     * see https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\r\n     */\r\n```",
    "created_at": "2021-10-29T08:08:09Z",
    "updated_at": "2021-10-29T08:08:09Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r739020569",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/739020569"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r739020569"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/739020569/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": 285,
    "start_side": "RIGHT",
    "line": null,
    "original_line": 286,
    "side": "RIGHT",
    "in_reply_to_id": 738591542
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/739022522",
    "pull_request_review_id": 792744166,
    "id": 739022522,
    "node_id": "PRRC_kwDOABII584sDJa6",
    "diff_hunk": "@@ -148,23 +154,65 @@ static inline size_t DynamicUsage(const std::shared_ptr<X>& p)\n     return p ? MallocUsage(sizeof(X)) + MallocUsage(sizeof(stl_shared_counter)) : 0;\n }\n \n-template<typename X>\n-struct unordered_node : private X\n-{\n-private:\n-    void* ptr;\n+template <typename T>\n+struct NodeSize {\n+};\n+\n+// It is important that the calculation here matches exactly the behavior of std::unordered_map\n+// so the node_allocator actually works. This is tested in node_allocator_tests/test_allocations_are_used\n+// with multiple configurations (alignments, noexcept hash, node sizes).\n+template <typename Key, typename V, typename Hash, typename Equals, typename Allocator>\n+struct NodeSize<std::unordered_map<Key, V, Hash, Equals, Allocator>> {\n+    [[nodiscard]] static constexpr size_t Value()\n+    {\n+        // libstdc++, libc++, and MSVC implement the nodes differently. To get the correct size\n+        // with the correct alignment, we can simulate that with accordingly nested std::pairs.\n+        using ValueType = std::pair<const Key, V>;\n+\n+#if defined(_MSC_VER)\n+        // list node contains 2 pointers and no hash; see\n+        // https://github.com/microsoft/STL/blob/main/stl/inc/unordered_map and\n+        // https://github.com/microsoft/STL/blob/main/stl/inc/list\n+        return sizeof(std::pair<std::pair<void*, void*>, ValueType>);\n+#else\n+\n+#if defined(_LIBCPP_VERSION) // defined in any C++ header from libc++\n+        // libc++ always stores hash and pointer in the node\n+        // see https://github.com/llvm/llvm-project/blob/release/13.x/libcxx/include/__hash_table#L92\n+        return sizeof(std::pair<ValueType, std::pair<size_t, void*>>);\n+#else\n+        // libstdc++ doesn't store hash when its operator() is noexcept;\n+        // see hashtable_policy.h, struct _Hash_node\n+        // https://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a05689.html\n+        if (noexcept(std::declval<Hash>()(std::declval<const Key&>()))) {\n+            return sizeof(std::pair<void*, ValueType>);\n+        } else {\n+            // hash is stored along ValueType, and that is wrapped with the pointer.\n+            return sizeof(std::pair<void*, std::pair<ValueType, size_t>>);\n+        }\n+#endif\n+#endif\n+    }\n };\n \n template<typename X, typename Y>\n static inline size_t DynamicUsage(const std::unordered_set<X, Y>& s)\n {\n-    return MallocUsage(sizeof(unordered_node<X>)) * s.size() + MallocUsage(sizeof(void*) * s.bucket_count());\n+    return MallocUsage(sizeof(std::pair<X, void*>)) * s.size() + MallocUsage(sizeof(void*) * s.bucket_count());",
    "path": "src/memusage.h",
    "position": null,
    "original_position": 67,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "a91b6032f037ab1a26ac4baa761e809fbfeb1bdd",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "exactly, I found it simpler & less code to just use `std::pair<...>` than writing many unordered_node implementations.",
    "created_at": "2021-10-29T08:11:02Z",
    "updated_at": "2021-10-29T08:11:02Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r739022522",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/739022522"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r739022522"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/739022522/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 199,
    "side": "RIGHT",
    "in_reply_to_id": 736869134
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/739024690",
    "pull_request_review_id": 792747328,
    "id": 739024690,
    "node_id": "PRRC_kwDOABII584sDJ8y",
    "diff_hunk": "@@ -0,0 +1,424 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <support/allocators/node_allocator.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <list>\n+#include <map>\n+#include <string>\n+#include <type_traits>\n+#include <unordered_map>\n+\n+namespace node_allocator {\n+\n+class MemoryResourceTester\n+{\n+public:\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static size_t NumFreeAllocations(\n+        MemoryResource<ALLOCATION_SIZE_BYTES> const& mr) noexcept\n+    {\n+        size_t length = 0;\n+        auto allocation = mr.m_free_allocations;\n+        while (allocation) {\n+            allocation = static_cast<detail::FreeList const*>(allocation)->next;\n+            ++length;\n+        }\n+        return length;\n+    }\n+\n+    /**\n+     * Number of memory pools that have been allocated\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static size_t NumPools(MemoryResource<ALLOCATION_SIZE_BYTES> const& mr) noexcept\n+    {\n+        return mr.m_allocated_pools.size();\n+    }\n+\n+\n+    /**\n+     * Extracts allocation size from the type\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static constexpr size_t AllocationSizeBytes(MemoryResource<ALLOCATION_SIZE_BYTES> const&) noexcept\n+    {\n+        return ALLOCATION_SIZE_BYTES;\n+    }\n+};\n+\n+} // namespace node_allocator\n+\n+BOOST_FIXTURE_TEST_SUITE(node_allocator_tests, BasicTestingSetup)\n+\n+#define CHECK_MEMORY_RESOURCE(mr, num_free_allocations, num_pools)                   \\\n+    BOOST_CHECK_EQUAL(num_free_allocations,                                          \\\n+                      node_allocator::MemoryResourceTester::NumFreeAllocations(mr)); \\\n+    BOOST_CHECK_EQUAL(num_pools, node_allocator::MemoryResourceTester::NumPools(mr));\n+\n+#define CHECK_IN_RANGE(what, lowerInclusive, upperInclusive) \\\n+    BOOST_TEST(what >= lowerInclusive);                      \\\n+    BOOST_TEST(what <= upperInclusive);\n+\n+BOOST_AUTO_TEST_CASE(too_small)\n+{\n+    node_allocator::MemoryResource<sizeof(void*)> mr{};\n+    void* ptr{mr.Allocate<char>(1)};\n+    BOOST_CHECK(ptr != nullptr);\n+\n+    // mr is used\n+    CHECK_MEMORY_RESOURCE(mr, 0, 1);\n+    mr.Deallocate<char>(ptr, 1);\n+    CHECK_MEMORY_RESOURCE(mr, 1, 1);\n+\n+    // void* works too, use freelist\n+    ptr = mr.Allocate<void*>(1);\n+    BOOST_CHECK(ptr != nullptr);\n+    CHECK_MEMORY_RESOURCE(mr, 0, 1);\n+    mr.Deallocate<char>(ptr, 1);\n+    CHECK_MEMORY_RESOURCE(mr, 1, 1);\n+}\n+\n+BOOST_AUTO_TEST_CASE(std_unordered_map)\n+{\n+    using Factory = node_allocator::UnorderedMapFactory<uint64_t, uint64_t>;\n+\n+    Factory::MemoryResourceType mr{};\n+    auto m = Factory::CreateContainer(&mr);\n+    size_t num_free_allocations = 0;\n+    {\n+        auto a = Factory::CreateContainer(&mr);\n+\n+        // Allocator compares equal because the same memory resource is used\n+        BOOST_CHECK(a.get_allocator() == m.get_allocator());\n+        for (uint64_t i = 0; i < 1000; ++i) {\n+            a[i] = i;\n+        }\n+\n+        num_free_allocations = node_allocator::MemoryResourceTester::NumFreeAllocations(mr);\n+\n+        // create a copy of the map, destroy the map => now a lot more free allocations should be\n+        // available\n+        {\n+            auto b = a;\n+        }\n+\n+        BOOST_CHECK(node_allocator::MemoryResourceTester::NumFreeAllocations(mr) >\n+                    num_free_allocations);\n+        num_free_allocations = node_allocator::MemoryResourceTester::NumFreeAllocations(mr);\n+\n+        // creating another copy, and then destroying everything should reuse all the allocations\n+        {\n+            auto b = a;\n+        }\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr),\n+                          num_free_allocations);\n+\n+        // moving the map should not create new nodes\n+        m = std::move(a);\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr),\n+                          num_free_allocations);\n+    }\n+    // a is destroyed, still all allocations should stay roughly the same.\n+    BOOST_CHECK(node_allocator::MemoryResourceTester::NumFreeAllocations(mr) <=\n+                num_free_allocations + 5);\n+\n+    m = Factory::CreateContainer(&mr);\n+\n+    // now we got everything free\n+    BOOST_CHECK(node_allocator::MemoryResourceTester::NumFreeAllocations(mr) >\n+                num_free_allocations + 50);\n+}\n+\n+BOOST_AUTO_TEST_CASE(different_memoryresource_assignment)\n+{\n+    using Factory = node_allocator::UnorderedMapFactory<uint64_t, uint64_t>;\n+\n+    Factory::MemoryResourceType mr_a{};\n+    Factory::MemoryResourceType mr_b{};\n+\n+    {\n+        auto map_a = Factory::CreateContainer(&mr_a);\n+        for (int i = 0; i < 100; ++i) {\n+            map_a[i] = i;\n+        }\n+\n+        {\n+            auto map_b = Factory::CreateContainer(&mr_b);\n+            map_b[123] = 321;\n+            BOOST_CHECK(map_a.get_allocator() != map_b.get_allocator());\n+            BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 0);\n+            BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumPools(mr_b), 1);\n+\n+            map_b = map_a;\n+\n+            // map_a now uses mr_b, since propagate_on_container_copy_assignment is std::true_type\n+            BOOST_CHECK(map_a.get_allocator() == map_b.get_allocator());\n+            CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 1U, 2U);\n+            BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumPools(mr_b), 1);\n+\n+            // map_b was now recreated with data from map_a, using mr_a as the memory resource.\n+        }\n+\n+        // map_b destroyed, should not have any effect on mr_b\n+        CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 1U, 2U);\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumPools(mr_b), 1);\n+        // but we'll get more free allocations in mr_a\n+        CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 100U, 101U);\n+    }\n+\n+    // finally map_a is destroyed, getting more free allocations.\n+    CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 200U, 202U);\n+}\n+\n+\n+BOOST_AUTO_TEST_CASE(different_memoryresource_move)\n+{\n+    using Factory = node_allocator::UnorderedMapFactory<uint64_t, uint64_t>;\n+\n+    Factory::MemoryResourceType mr_a{};\n+    Factory::MemoryResourceType mr_b{};\n+\n+    {\n+        auto map_a = Factory::CreateContainer(&mr_a);\n+        for (int i = 0; i < 100; ++i) {\n+            map_a[i] = i;\n+        }\n+\n+        {\n+            auto map_b = Factory::CreateContainer(&mr_b);\n+            map_b[123] = 321;\n+\n+            map_b = std::move(map_a);\n+\n+            // map_a now uses mr_b, since propagate_on_container_move_assignment is std::true_type\n+            BOOST_CHECK(map_a.get_allocator() == map_b.get_allocator());\n+            CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 1U, 2U);\n+            BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumPools(mr_b), 1);\n+\n+            // map_b was now recreated with data from map_a, using mr_a as the memory resource.\n+        }\n+\n+        // map_b destroyed, should not have any effect on mr_b.\n+        CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 1U, 2U);\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumPools(mr_b), 1);\n+        // but we'll get more free allocations in mr_a\n+        CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 100U, 101U);\n+    }\n+\n+    // finally map_a is destroyed, but since it was moved, no more free allocations.\n+    CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 100U, 102U);\n+}\n+\n+\n+BOOST_AUTO_TEST_CASE(different_memoryresource_swap)\n+{\n+    using Factory = node_allocator::UnorderedMapFactory<uint64_t, uint64_t>;\n+\n+    Factory::MemoryResourceType mr_a{};\n+    Factory::MemoryResourceType mr_b{};\n+\n+    {\n+        auto map_a = Factory::CreateContainer(&mr_a);\n+        for (int i = 0; i < 100; ++i) {\n+            map_a[i] = i;\n+        }\n+\n+        {\n+            auto map_b = Factory::CreateContainer(&mr_b);\n+            map_b[123] = 321;\n+\n+            auto alloc_a = map_a.get_allocator();\n+            auto alloc_b = map_b.get_allocator();\n+\n+            std::swap(map_a, map_b);\n+\n+            // The maps have swapped, so their allocators have swapped, too.\n+            // No additional allocations have occurred!\n+            BOOST_CHECK(map_a.get_allocator() != map_b.get_allocator());\n+            BOOST_CHECK(alloc_a == map_b.get_allocator());\n+            BOOST_CHECK(alloc_b == map_a.get_allocator());\n+        }\n+\n+        // map_b destroyed, so mr_a must have plenty of free allocations now\n+        CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 100U, 101U);\n+\n+        // nothing happened to map_a, so mr_b still has no free allocations\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 0);\n+    }\n+\n+    // finally map_a is destroyed, so we got an entry back for mr_b.\n+    CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 100U, 101U);\n+    CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 1U, 2U);\n+}\n+\n+// some structs with defined alignment and customizeable size\n+\n+namespace {\n+\n+template <size_t S>\n+struct alignas(1) A1 {\n+    char data[S];\n+};\n+\n+template <size_t S>\n+struct alignas(2) A2 {\n+    char data[S];\n+};\n+\n+template <size_t S>\n+struct alignas(4) A4 {\n+    char data[S];\n+};\n+\n+template <size_t S>\n+struct alignas(8) A8 {\n+    char data[S];\n+};\n+\n+template <size_t S>\n+struct alignas(16) A16 {\n+    char data[S];\n+};\n+\n+template <size_t S>\n+struct alignas(32) A32 {\n+    char data[S];\n+};\n+\n+} // namespace\n+\n+BOOST_AUTO_TEST_CASE(calc_required_allocation_size)\n+{\n+    static_assert(sizeof(A1<1>) == 1U);\n+    static_assert(std::alignment_of_v<A1<1>> == 1U);\n+\n+    static_assert(sizeof(A16<1>) == 16U);\n+    static_assert(std::alignment_of_v<A16<1>> == 16U);\n+    static_assert(sizeof(A16<16>) == 16U);\n+    static_assert(std::alignment_of_v<A16<16>> == 16U);\n+    static_assert(sizeof(A16<24>) == 32U);\n+    static_assert(std::alignment_of_v<A16<24>> == 16U);\n+\n+#if UINTPTR_MAX == 0xFFFFFFFFFFFFFFFF\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A1<1>>());\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A1<7>>());\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A1<8>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A1<9>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A1<15>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A1<16>>());\n+    static_assert(24U == node_allocator::detail::RequiredAllocationSizeBytes<A1<17>>());\n+    static_assert(104U == node_allocator::detail::RequiredAllocationSizeBytes<A1<100>>());\n+\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A4<4>>());\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A4<7>>());\n+    static_assert(104U == node_allocator::detail::RequiredAllocationSizeBytes<A4<100>>());\n+    static_assert(104U == node_allocator::detail::RequiredAllocationSizeBytes<A8<100>>());\n+\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A8<1>>());\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A8<8>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A8<16>>());\n+\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A16<1>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A16<8>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A16<16>>());\n+    static_assert(32U == node_allocator::detail::RequiredAllocationSizeBytes<A16<17>>());\n+#elif UINTPTR_MAX == 0xFFFFFFFF\n+    static_assert(4U == node_allocator::detail::RequiredAllocationSizeBytes<A1<1>>());\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A1<7>>());\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A1<8>>());\n+    static_assert(12U == node_allocator::detail::RequiredAllocationSizeBytes<A1<9>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A1<15>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A1<16>>());\n+    static_assert(20U == node_allocator::detail::RequiredAllocationSizeBytes<A1<17>>());\n+    static_assert(100U == node_allocator::detail::RequiredAllocationSizeBytes<A1<100>>());\n+\n+    static_assert(4U == node_allocator::detail::RequiredAllocationSizeBytes<A4<4>>());\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A4<7>>());\n+    static_assert(100U == node_allocator::detail::RequiredAllocationSizeBytes<A4<100>>());\n+    static_assert(104U == node_allocator::detail::RequiredAllocationSizeBytes<A8<100>>());\n+\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A8<1>>());\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A8<8>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A8<16>>());\n+\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A16<1>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A16<8>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A16<16>>());\n+    static_assert(32U == node_allocator::detail::RequiredAllocationSizeBytes<A16<17>>());\n+#else\n+#error \"Invalid sizeof(void*)\"\n+#endif\n+}\n+\n+namespace {\n+\n+template <typename T>\n+struct NotNoexceptHash {\n+    size_t operator()(const T& x) const /* noexcept */ { return std::hash<T>{}(x); }\n+};\n+\n+} // namespace\n+\n+template <typename Key, typename Value, typename Hash = std::hash<Key>>\n+void TestAllocationsAreUsed()\n+{\n+    using Factory = node_allocator::UnorderedMapFactory<Key, Value, Hash>;\n+    typename Factory::MemoryResourceType mr{};\n+    BOOST_TEST_MESSAGE(\n+        strprintf(\"%u sizeof(void*), %u/%u/%u sizeof Key/Value/Pair, %u ALLOCATION_SIZE_BYTES\",\n+                  sizeof(void*), sizeof(Key), sizeof(Value), sizeof(std::pair<const Key, Value>),\n+                  node_allocator::MemoryResourceTester::AllocationSizeBytes(mr)));\n+    {\n+        auto map = Factory::CreateContainer(&mr);\n+        for (size_t i = 0; i < 5; ++i) {\n+            map[i];\n+        }\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr), 0);\n+        map.clear();\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr), 5);\n+\n+        for (size_t i = 0; i < 5; ++i) {\n+            map[i];\n+        }\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr), 0);\n+        map.clear();\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr), 5);\n+    }\n+\n+    // makes sure clear frees all allocations. With MSVC there might be an additional allocation\n+    // used for a control structure.",
    "path": "src/test/node_allocator_tests.cpp",
    "position": null,
    "original_position": 398,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "a91b6032f037ab1a26ac4baa761e809fbfeb1bdd",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Maybe I shouldn't have but that reveal at the very last place where that `CHECK_IN_RANGE` is used :sweat_smile:",
    "created_at": "2021-10-29T08:13:23Z",
    "updated_at": "2021-10-29T08:13:23Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r739024690",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/739024690"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r739024690"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/739024690/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": 397,
    "start_side": "RIGHT",
    "line": null,
    "original_line": 398,
    "side": "RIGHT",
    "in_reply_to_id": 738677808
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/739026986",
    "pull_request_review_id": 792750183,
    "id": 739026986,
    "node_id": "PRRC_kwDOABII584sDKgq",
    "diff_hunk": "@@ -0,0 +1,424 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <support/allocators/node_allocator.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <list>\n+#include <map>\n+#include <string>\n+#include <type_traits>\n+#include <unordered_map>\n+\n+namespace node_allocator {\n+\n+class MemoryResourceTester\n+{\n+public:\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static size_t NumFreeAllocations(\n+        MemoryResource<ALLOCATION_SIZE_BYTES> const& mr) noexcept\n+    {\n+        size_t length = 0;\n+        auto allocation = mr.m_free_allocations;\n+        while (allocation) {\n+            allocation = static_cast<detail::FreeList const*>(allocation)->next;\n+            ++length;\n+        }\n+        return length;\n+    }\n+\n+    /**\n+     * Number of memory pools that have been allocated\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static size_t NumPools(MemoryResource<ALLOCATION_SIZE_BYTES> const& mr) noexcept\n+    {\n+        return mr.m_allocated_pools.size();\n+    }\n+\n+\n+    /**\n+     * Extracts allocation size from the type\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static constexpr size_t AllocationSizeBytes(MemoryResource<ALLOCATION_SIZE_BYTES> const&) noexcept\n+    {\n+        return ALLOCATION_SIZE_BYTES;\n+    }\n+};\n+\n+} // namespace node_allocator\n+\n+BOOST_FIXTURE_TEST_SUITE(node_allocator_tests, BasicTestingSetup)\n+\n+#define CHECK_MEMORY_RESOURCE(mr, num_free_allocations, num_pools)                   \\\n+    BOOST_CHECK_EQUAL(num_free_allocations,                                          \\\n+                      node_allocator::MemoryResourceTester::NumFreeAllocations(mr)); \\\n+    BOOST_CHECK_EQUAL(num_pools, node_allocator::MemoryResourceTester::NumPools(mr));\n+\n+#define CHECK_IN_RANGE(what, lowerInclusive, upperInclusive) \\\n+    BOOST_TEST(what >= lowerInclusive);                      \\\n+    BOOST_TEST(what <= upperInclusive);\n+\n+BOOST_AUTO_TEST_CASE(too_small)\n+{\n+    node_allocator::MemoryResource<sizeof(void*)> mr{};\n+    void* ptr{mr.Allocate<char>(1)};\n+    BOOST_CHECK(ptr != nullptr);\n+\n+    // mr is used\n+    CHECK_MEMORY_RESOURCE(mr, 0, 1);\n+    mr.Deallocate<char>(ptr, 1);\n+    CHECK_MEMORY_RESOURCE(mr, 1, 1);\n+\n+    // void* works too, use freelist\n+    ptr = mr.Allocate<void*>(1);\n+    BOOST_CHECK(ptr != nullptr);\n+    CHECK_MEMORY_RESOURCE(mr, 0, 1);\n+    mr.Deallocate<char>(ptr, 1);\n+    CHECK_MEMORY_RESOURCE(mr, 1, 1);\n+}\n+\n+BOOST_AUTO_TEST_CASE(std_unordered_map)\n+{\n+    using Factory = node_allocator::UnorderedMapFactory<uint64_t, uint64_t>;\n+\n+    Factory::MemoryResourceType mr{};\n+    auto m = Factory::CreateContainer(&mr);\n+    size_t num_free_allocations = 0;\n+    {\n+        auto a = Factory::CreateContainer(&mr);\n+\n+        // Allocator compares equal because the same memory resource is used\n+        BOOST_CHECK(a.get_allocator() == m.get_allocator());\n+        for (uint64_t i = 0; i < 1000; ++i) {\n+            a[i] = i;\n+        }\n+\n+        num_free_allocations = node_allocator::MemoryResourceTester::NumFreeAllocations(mr);\n+\n+        // create a copy of the map, destroy the map => now a lot more free allocations should be\n+        // available\n+        {\n+            auto b = a;\n+        }\n+\n+        BOOST_CHECK(node_allocator::MemoryResourceTester::NumFreeAllocations(mr) >\n+                    num_free_allocations);\n+        num_free_allocations = node_allocator::MemoryResourceTester::NumFreeAllocations(mr);\n+\n+        // creating another copy, and then destroying everything should reuse all the allocations\n+        {\n+            auto b = a;\n+        }\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr),\n+                          num_free_allocations);\n+\n+        // moving the map should not create new nodes\n+        m = std::move(a);\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr),\n+                          num_free_allocations);\n+    }\n+    // a is destroyed, still all allocations should stay roughly the same.\n+    BOOST_CHECK(node_allocator::MemoryResourceTester::NumFreeAllocations(mr) <=\n+                num_free_allocations + 5);\n+\n+    m = Factory::CreateContainer(&mr);\n+\n+    // now we got everything free\n+    BOOST_CHECK(node_allocator::MemoryResourceTester::NumFreeAllocations(mr) >\n+                num_free_allocations + 50);\n+}\n+\n+BOOST_AUTO_TEST_CASE(different_memoryresource_assignment)\n+{\n+    using Factory = node_allocator::UnorderedMapFactory<uint64_t, uint64_t>;\n+\n+    Factory::MemoryResourceType mr_a{};\n+    Factory::MemoryResourceType mr_b{};\n+\n+    {\n+        auto map_a = Factory::CreateContainer(&mr_a);\n+        for (int i = 0; i < 100; ++i) {\n+            map_a[i] = i;\n+        }\n+\n+        {\n+            auto map_b = Factory::CreateContainer(&mr_b);\n+            map_b[123] = 321;\n+            BOOST_CHECK(map_a.get_allocator() != map_b.get_allocator());\n+            BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 0);\n+            BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumPools(mr_b), 1);\n+\n+            map_b = map_a;\n+\n+            // map_a now uses mr_b, since propagate_on_container_copy_assignment is std::true_type\n+            BOOST_CHECK(map_a.get_allocator() == map_b.get_allocator());\n+            CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 1U, 2U);\n+            BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumPools(mr_b), 1);\n+\n+            // map_b was now recreated with data from map_a, using mr_a as the memory resource.\n+        }\n+\n+        // map_b destroyed, should not have any effect on mr_b\n+        CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 1U, 2U);\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumPools(mr_b), 1);\n+        // but we'll get more free allocations in mr_a\n+        CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 100U, 101U);\n+    }\n+\n+    // finally map_a is destroyed, getting more free allocations.\n+    CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 200U, 202U);\n+}\n+\n+\n+BOOST_AUTO_TEST_CASE(different_memoryresource_move)\n+{\n+    using Factory = node_allocator::UnorderedMapFactory<uint64_t, uint64_t>;\n+\n+    Factory::MemoryResourceType mr_a{};\n+    Factory::MemoryResourceType mr_b{};\n+\n+    {\n+        auto map_a = Factory::CreateContainer(&mr_a);\n+        for (int i = 0; i < 100; ++i) {\n+            map_a[i] = i;\n+        }\n+\n+        {\n+            auto map_b = Factory::CreateContainer(&mr_b);\n+            map_b[123] = 321;\n+\n+            map_b = std::move(map_a);\n+\n+            // map_a now uses mr_b, since propagate_on_container_move_assignment is std::true_type\n+            BOOST_CHECK(map_a.get_allocator() == map_b.get_allocator());\n+            CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 1U, 2U);\n+            BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumPools(mr_b), 1);\n+\n+            // map_b was now recreated with data from map_a, using mr_a as the memory resource.\n+        }\n+\n+        // map_b destroyed, should not have any effect on mr_b.\n+        CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 1U, 2U);\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumPools(mr_b), 1);\n+        // but we'll get more free allocations in mr_a\n+        CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 100U, 101U);\n+    }\n+\n+    // finally map_a is destroyed, but since it was moved, no more free allocations.\n+    CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 100U, 102U);\n+}\n+\n+\n+BOOST_AUTO_TEST_CASE(different_memoryresource_swap)\n+{\n+    using Factory = node_allocator::UnorderedMapFactory<uint64_t, uint64_t>;\n+\n+    Factory::MemoryResourceType mr_a{};\n+    Factory::MemoryResourceType mr_b{};\n+\n+    {\n+        auto map_a = Factory::CreateContainer(&mr_a);\n+        for (int i = 0; i < 100; ++i) {\n+            map_a[i] = i;\n+        }\n+\n+        {\n+            auto map_b = Factory::CreateContainer(&mr_b);\n+            map_b[123] = 321;\n+\n+            auto alloc_a = map_a.get_allocator();\n+            auto alloc_b = map_b.get_allocator();\n+\n+            std::swap(map_a, map_b);\n+\n+            // The maps have swapped, so their allocators have swapped, too.\n+            // No additional allocations have occurred!\n+            BOOST_CHECK(map_a.get_allocator() != map_b.get_allocator());\n+            BOOST_CHECK(alloc_a == map_b.get_allocator());\n+            BOOST_CHECK(alloc_b == map_a.get_allocator());\n+        }\n+\n+        // map_b destroyed, so mr_a must have plenty of free allocations now\n+        CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 100U, 101U);\n+\n+        // nothing happened to map_a, so mr_b still has no free allocations\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 0);\n+    }\n+\n+    // finally map_a is destroyed, so we got an entry back for mr_b.\n+    CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 100U, 101U);\n+    CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 1U, 2U);\n+}\n+\n+// some structs with defined alignment and customizeable size\n+\n+namespace {\n+\n+template <size_t S>\n+struct alignas(1) A1 {\n+    char data[S];\n+};\n+\n+template <size_t S>\n+struct alignas(2) A2 {\n+    char data[S];\n+};\n+\n+template <size_t S>\n+struct alignas(4) A4 {\n+    char data[S];\n+};\n+\n+template <size_t S>\n+struct alignas(8) A8 {\n+    char data[S];\n+};\n+\n+template <size_t S>\n+struct alignas(16) A16 {\n+    char data[S];\n+};\n+\n+template <size_t S>\n+struct alignas(32) A32 {\n+    char data[S];\n+};",
    "path": "src/test/node_allocator_tests.cpp",
    "position": null,
    "original_position": 295,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "a91b6032f037ab1a26ac4baa761e809fbfeb1bdd",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Ah, I didn't know that it's possible to use a template argument in `alignas`, that simplifies things :+1: ",
    "created_at": "2021-10-29T08:16:20Z",
    "updated_at": "2021-10-29T08:16:21Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r739026986",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/739026986"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r739026986"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/739026986/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": 267,
    "start_side": "RIGHT",
    "line": null,
    "original_line": 246,
    "side": "RIGHT",
    "in_reply_to_id": 738666780
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/743735888",
    "pull_request_review_id": 798995659,
    "id": 743735888,
    "node_id": "PRRC_kwDOABII584sVIJQ",
    "diff_hunk": "@@ -0,0 +1,52 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <bench/bench.h>\n+#include <coins.h>\n+#include <memusage.h>\n+#include <support/allocators/node_allocator.h>\n+\n+#include <cstring>\n+#include <iostream>\n+#include <unordered_map>\n+\n+template <typename Map>\n+void BenchFillClearMap(benchmark::Bench& bench, Map& map)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(1);\n+    tx.vin[0].scriptSig = CScript() << OP_2;\n+    tx.vin[0].scriptWitness.stack.push_back({2});\n+    tx.vout.resize(1);\n+    tx.vout[0].scriptPubKey = CScript() << OP_2 << OP_EQUAL;\n+    tx.vout[0].nValue = 10 * COIN;",
    "path": "src/bench/node_allocator.cpp",
    "position": null,
    "original_position": 23,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "a91b6032f037ab1a26ac4baa761e809fbfeb1bdd",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "right! I just copied that code without really thinking too much about it. I'll clean that up.",
    "created_at": "2021-11-05T14:58:32Z",
    "updated_at": "2021-11-05T14:58:32Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r743735888",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/743735888"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r743735888"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/743735888/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": 17,
    "start_side": "RIGHT",
    "line": null,
    "original_line": 23,
    "side": "RIGHT",
    "in_reply_to_id": 736984281
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744084248",
    "pull_request_review_id": 799421879,
    "id": 744084248,
    "node_id": "PRRC_kwDOABII584sWdMY",
    "diff_hunk": "@@ -0,0 +1,406 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <memory>\n+#include <new>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based\n+ * containers that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs pools of memory and uses these to carve out memory for the nodes. Nodes\n+ * that are destroyed by the Allocator are actually put back into a free list for further use. This\n+ * behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored\n+ * in-place. This typically saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with\n+ * low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but\n+ * there is no standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to\n+ * the system. Memory is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on\n+ * proximity. So freeing and malloc'ing again can become a random access pattern which can lead to\n+ * more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers.\n+ * Similar to `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages memory. Currently\n+ * it is only able to provide optimized alloc/free for a single fixed allocation size which is given\n+ * in the constructor. Only allocations that match this size will be provided from the preallocated\n+ * pools of memory; all other requests simply use ::operator new(). To get the correct node size in\n+ * all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios\n+ * in `node_allocator_tests/test_allocations_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall \u201cHow to Write a Custom Allocator\u201d\n+ *   https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer \u201cAn Allocator is a Handle to a Heap\u201d\n+ *   https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *   https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+namespace detail {\n+\n+/**\n+ * In-place linked list of the allocations, used for the free list.\n+ */\n+struct FreeList {\n+    void* next;",
    "path": "src/support/allocators/node_allocator.h",
    "position": null,
    "original_position": 78,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "a91b6032f037ab1a26ac4baa761e809fbfeb1bdd",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Reading through the code again I now think that I actually have undefined behavior: I'm basically `reinterpret_cast`ing `T*` to `FreeList*`, and both types are completely unrelated, so according to the type aliasing rules accessing this is undefined behavior:\r\n\r\n> Performing a class member access that designates a non-static data member or a non-static member function on a glvalue that does not actually designate an object of the appropriate type - such as one obtained through a reinterpret_cast - results in undefined behavior\r\n\r\nSee https://en.cppreference.com/w/cpp/language/reinterpret_cast\r\n\r\nThis can be fixed by using `memcpy`, and then I can also relax the alignment.",
    "created_at": "2021-11-06T06:41:29Z",
    "updated_at": "2021-11-06T06:41:29Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r744084248",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744084248"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r744084248"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744084248/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 78,
    "side": "RIGHT",
    "in_reply_to_id": 737638806
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744096236",
    "pull_request_review_id": 799425158,
    "id": 744096236,
    "node_id": "PRRC_kwDOABII584sWgHs",
    "diff_hunk": "@@ -0,0 +1,406 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <memory>\n+#include <new>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based\n+ * containers that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs pools of memory and uses these to carve out memory for the nodes. Nodes\n+ * that are destroyed by the Allocator are actually put back into a free list for further use. This\n+ * behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored\n+ * in-place. This typically saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with\n+ * low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but\n+ * there is no standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to\n+ * the system. Memory is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on\n+ * proximity. So freeing and malloc'ing again can become a random access pattern which can lead to\n+ * more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers.\n+ * Similar to `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages memory. Currently\n+ * it is only able to provide optimized alloc/free for a single fixed allocation size which is given\n+ * in the constructor. Only allocations that match this size will be provided from the preallocated\n+ * pools of memory; all other requests simply use ::operator new(). To get the correct node size in\n+ * all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios\n+ * in `node_allocator_tests/test_allocations_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall \u201cHow to Write a Custom Allocator\u201d\n+ *   https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer \u201cAn Allocator is a Handle to a Heap\u201d\n+ *   https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *   https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+namespace detail {\n+\n+/**\n+ * In-place linked list of the allocations, used for the free list.\n+ */\n+struct FreeList {\n+    void* next;",
    "path": "src/support/allocators/node_allocator.h",
    "position": null,
    "original_position": 78,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "a91b6032f037ab1a26ac4baa761e809fbfeb1bdd",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "I guess I didn't have enough coffee yet. I can't use reinterpret_cast, but since the `T` was already destroyed, I can use placement new in that memory to create the `FreeList`. No reinterpret_cast needed at all.",
    "created_at": "2021-11-06T07:46:57Z",
    "updated_at": "2021-11-06T07:46:57Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r744096236",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744096236"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r744096236"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744096236/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 78,
    "side": "RIGHT",
    "in_reply_to_id": 737638806
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744111409",
    "pull_request_review_id": 799435545,
    "id": 744111409,
    "node_id": "PRRC_kwDOABII584sWj0x",
    "diff_hunk": "@@ -0,0 +1,406 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <memory>\n+#include <new>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based\n+ * containers that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs pools of memory and uses these to carve out memory for the nodes. Nodes\n+ * that are destroyed by the Allocator are actually put back into a free list for further use. This\n+ * behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored\n+ * in-place. This typically saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with\n+ * low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but\n+ * there is no standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to\n+ * the system. Memory is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on\n+ * proximity. So freeing and malloc'ing again can become a random access pattern which can lead to\n+ * more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers.\n+ * Similar to `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages memory. Currently\n+ * it is only able to provide optimized alloc/free for a single fixed allocation size which is given\n+ * in the constructor. Only allocations that match this size will be provided from the preallocated\n+ * pools of memory; all other requests simply use ::operator new(). To get the correct node size in\n+ * all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios\n+ * in `node_allocator_tests/test_allocations_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall \u201cHow to Write a Custom Allocator\u201d\n+ *   https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer \u201cAn Allocator is a Handle to a Heap\u201d\n+ *   https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *   https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+namespace detail {\n+\n+/**\n+ * In-place linked list of the allocations, used for the free list.\n+ */\n+struct FreeList {\n+    void* next;\n+};\n+\n+/**\n+ * Calculates the required allocation size for the given type.\n+ * The memory needs to be correctly aligned and large enough for both both T and FreeList.\n+ */\n+template <typename T>\n+[[nodiscard]] constexpr size_t RequiredAllocationSizeBytes() noexcept\n+{\n+    const auto alignment_max = std::max(std::alignment_of_v<T>, std::alignment_of_v<FreeList>);\n+    const auto size_max = std::max(sizeof(T), sizeof(FreeList));\n+\n+    // find closest multiple of alignment_max that holds size_max\n+    return ((size_max + alignment_max - 1U) / alignment_max) * alignment_max;\n+}\n+\n+} // namespace detail\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It\n+ * stores a number of memory pools which are used to quickly give out memory of a fixed allocation\n+ * size. The class is purposely kept very simple. It only knows about \"Allocations\" and \"Pools\".\n+ *\n+ * - Pool: MemoryResource allocates one memory pool at a time. These pools are kept around until the\n+ * memory resource is destroyed.\n+ *\n+ * - Allocations: Node-based containers allocate one node at a time. Whenever that happens, the\n+ * MemoryResource's Allocate() gives out memory for one node. These are carved out from a previously\n+ * allocated memory pool, or from a free list if it contains entries. Whenever a node is given back\n+ * with Deallocate(), it is put into that free list.\n+ */\n+template <size_t ALLOCATION_SIZE_BYTES>\n+class MemoryResource\n+{\n+    /**\n+     * Size in bytes to allocate per pool, currently hardcoded to multiple of ALLOCATION_SIZE_BYTES\n+     * that comes closest to 256 KiB.\n+     */\n+    static constexpr size_t POOL_SIZE_BYTES = (262144 / ALLOCATION_SIZE_BYTES) * ALLOCATION_SIZE_BYTES;\n+\n+public:\n+    /**\n+     * Construct a new MemoryResource object that uses the specified allocation size to optimize for.\n+     */\n+    MemoryResource() = default;\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated pools.\n+     *\n+     * There's no Clear() method on purpose, because it would be dangerous. E.g. when calling\n+     * clear() on an unordered_map, it is not certain that all allocated nodes are given back to the\n+     * MemoryResource. Microsoft's STL still uses a control structure that might have the same size\n+     * as the nodes, and therefore needs to be kept around until the map is actually destroyed.\n+     */\n+    ~MemoryResource() = default;\n+\n+    /**\n+     * Allocates memory for n * sizeof(T). Only when n==1 and T's size matches ALLOCATION_SIZE_BYTES\n+     * the pool's memory is used. Otherwise, the allocation is forwarded to ::operator new().\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        if constexpr (ALLOCATION_SIZE_BYTES == detail::RequiredAllocationSizeBytes<T>()) {\n+            if (n != 1) {\n+                // pool is not used so forward to operator new.\n+                return static_cast<T*>(::operator new(n * sizeof(T)));\n+            }\n+\n+            if (m_free_allocations) {\n+                // we've already got data in the free list, unlink one element\n+                auto old_head = m_free_allocations;\n+                m_free_allocations = static_cast<detail::FreeList*>(m_free_allocations)->next;\n+                return static_cast<T*>(old_head);\n+            }\n+\n+            // free list is empty: get one allocation from allocated pool memory.\n+            // It makes sense to not create the fully linked list of an allocated pool up-front, for\n+            // several reasons. On the one hand, the latency is higher when we need to iterate and\n+            // update pointers for the whole pool at once. More importantly, most systems lazily\n+            // allocate data. So when we allocate a big pool of memory the memory for a page is only\n+            // actually made available to the program when it is first touched. So when we allocate\n+            // a big pool and only use very little memory from it, the total memory usage is lower\n+            // than what has been malloc'ed.\n+            if (m_untouched_memory_iterator == m_untouched_memory_end) {\n+                // slow path, only happens when a new pool needs to be allocated\n+                AllocatePool();\n+            }\n+\n+            // peel off one allocation from the untouched memory. The next pointer of in-use\n+            // elements doesn't matter until it is deallocated, only then it is used to form the\n+            // free list.\n+            const auto tmp = m_untouched_memory_iterator;\n+            m_untouched_memory_iterator = static_cast<char*>(tmp) + ALLOCATION_SIZE_BYTES;\n+            return static_cast<T*>(tmp);\n+        } else {\n+            // pool is not used so forward to operator new.\n+            return static_cast<T*>(::operator new(n * sizeof(T)));\n+        }\n+    }\n+\n+    /**\n+     * Puts p back into the free list if it was actually allocated from the memory pool.\n+     * Otherwise, simply call ::operator delete(p).\n+     */\n+    template <typename T>\n+    void Deallocate(void* p, size_t n) noexcept\n+    {\n+        if constexpr (ALLOCATION_SIZE_BYTES == detail::RequiredAllocationSizeBytes<T>()) {\n+            if (n != 1) {\n+                // allocation didn't happen with the pool\n+                ::operator delete(p);\n+                return;\n+            }\n+\n+            // put it into the linked list\n+            const auto allocation = static_cast<detail::FreeList*>(p);\n+            allocation->next = m_free_allocations;\n+            m_free_allocations = allocation;\n+        } else {\n+            // allocation didn't happen with the pool\n+            ::operator delete(p);\n+        }\n+    }\n+\n+    /**\n+     * Calculates bytes allocated by the memory resource.\n+     */\n+    [[nodiscard]] size_t DynamicMemoryUsage() const noexcept\n+    {\n+        return memusage::MallocUsage(POOL_SIZE_BYTES) * m_allocated_pools.size() + memusage::DynamicUsage(m_allocated_pools);\n+    }\n+\n+private:\n+    //! Access to internals for testing purpose only\n+    friend class MemoryResourceTester;\n+\n+    /**\n+     * Allocate one full memory pool which is used to carve out allocations.\n+     */\n+    void AllocatePool()\n+    {\n+        m_allocated_pools.emplace_back(new char[POOL_SIZE_BYTES]);\n+        m_untouched_memory_iterator = m_allocated_pools.back().get();\n+        m_untouched_memory_end = m_allocated_pools.back().get() + POOL_SIZE_BYTES;\n+    }\n+\n+    //! Contains all allocated pools of memory, used to free the data in the destructor.\n+    std::vector<std::unique_ptr<char[]>> m_allocated_pools{};\n+\n+    //! A single linked list of all data available in the MemoryResource. This list is used for\n+    //! allocations of single elements.\n+    void* m_free_allocations = nullptr;\n+\n+    //! Points to the beginning of available memory for carving out allocations.\n+    void* m_untouched_memory_iterator = nullptr;\n+\n+    //! Points to the end of available memory for carving out allocations.\n+    void* m_untouched_memory_end = nullptr;\n+};\n+\n+\n+/**\n+ * Allocator that's usable for node-based containers like std::unordered_map or std::list.\n+ *\n+ * The allocator is stateful, and can be cheaply copied. Its state is an immobile MemoryResource,\n+ * which actually does all the allocation/deallocations. So this class is just a simple wrapper that\n+ * conforms to the required STL interface to be usable for the node-based containers.\n+ */\n+template <typename T, size_t ALLOCATION_SIZE_BYTES>\n+class Allocator\n+{\n+    template <typename U, size_t AS>\n+    friend class Allocator;\n+\n+    template <typename X, typename Y, size_t AS>\n+    friend bool operator==(const Allocator<X, AS>& a, const Allocator<Y, AS>& b) noexcept;\n+\n+public:\n+    using value_type = T;\n+\n+    /**\n+     * The allocator is stateful so we can't use the compile time `is_always_equal` optimization and\n+     * have to use the runtime operator==.\n+     */\n+    using is_always_equal = std::false_type;\n+\n+    /**\n+     * Move assignment should be a fast operation. In the case of a = std::move(b), we want\n+     * a to be able to use b's allocator, otherwise all elements would have to be recreated with a's\n+     * old allocator.\n+     */\n+    using propagate_on_container_move_assignment = std::true_type;\n+\n+    /**\n+     * Swapping two containers with unequal allocators who are *not* propagated is undefined\n+     * behavior. Unfortunately this is the default! Obviously, we don't want that.\n+     */\n+    using propagate_on_container_swap = std::true_type; // to avoid the undefined behavior\n+\n+    /**\n+     * Move and swap have to propagate the allocator, so for consistency we do the same for copy\n+     * assignment.\n+     */\n+    using propagate_on_container_copy_assignment = std::true_type;\n+\n+    /**\n+     * Construct a new Allocator object which will delegate all allocations/deallocations to the\n+     * memory resource.\n+     */\n+    explicit Allocator(MemoryResource<ALLOCATION_SIZE_BYTES>* memory_resource) noexcept\n+        : m_memory_resource(memory_resource)\n+    {\n+    }\n+\n+    /**\n+     * Conversion constructor for rebinding. All Allocators use the same memory_resource.\n+     *\n+     * The rebound type is determined with the `struct rebind`. The rebind is necessary feature\n+     * for standard allocators, and it happens when the allocator shall be used for different types.\n+     * E.g. for std::unordered_map this happens for allocation of the internally used nodes, for the\n+     * underlying index array, and possibly for some control structure. In fact the type required by\n+     * the standard `std::pair<const Key, Value>` type is never actually used for any allocation\n+     * (which is therefore a stupid requirement, but that's just C++ being C++).\n+     */\n+    template <typename U>\n+    Allocator(const Allocator<U, ALLOCATION_SIZE_BYTES>& other) noexcept\n+        : m_memory_resource(other.m_memory_resource)\n+    {\n+    }\n+\n+    /**\n+     * From the standard: rebind is only optional (provided by std::allocator_traits) if this\n+     * allocator is a template of the form SomeAllocator<T, Args>, where Args is zero or more\n+     * additional template type parameters.\n+     *\n+     * Since we use a size_t as additional argument, it's *not* optional.\n+     * @see https://en.cppreference.com/w/cpp/named_req/Allocator#cite_note-2\n+     */\n+    template <typename U>\n+    struct rebind {\n+        using other = Allocator<U, ALLOCATION_SIZE_BYTES>;\n+    };\n+\n+    /**\n+     * Allocates n entries of the given type.\n+     */\n+    T* allocate(size_t n)\n+    {\n+        // Forward all allocations to the memory_resource\n+        return m_memory_resource->template Allocate<T>(n);\n+    }\n+\n+    /**\n+     * Deallocates n entries of the given type.\n+     */\n+    void deallocate(T* p, size_t n)\n+    {\n+        m_memory_resource->template Deallocate<T>(p, n);\n+    }\n+\n+private:\n+    //! Stateful allocator, where the state is a simple pointer that can be cheaply copied.\n+    MemoryResource<ALLOCATION_SIZE_BYTES>* m_memory_resource;\n+};\n+\n+\n+/**\n+ * Since Allocator is stateful, comparison with another one only returns true if it uses the same\n+ * memory_resource.\n+ */\n+template <typename T, typename U, size_t CS>\n+bool operator==(const Allocator<T, CS>& a, const Allocator<U, CS>& b) noexcept\n+{\n+    // \"Equality of an allocator is determined through the ability of allocating memory with one\n+    // allocator and deallocating it with another.\" - Jonathan M\u00fcller\n+    // See https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+    //\n+    // For us that is the case when both allocators use the same memory resource.\n+    return a.m_memory_resource == b.m_memory_resource;\n+}\n+\n+template <typename T, typename U, size_t CS>\n+bool operator!=(const Allocator<T, CS>& a, const Allocator<U, CS>& b) noexcept\n+{\n+    return !(a == b);\n+}\n+\n+/**\n+ * Helper to create std::unordered_map which uses the node_allocator.\n+ *\n+ * This calculates the size of the container's internally used node correctly for all supported\n+ * platforms, which is also asserted by the unit tests.\n+ */\n+template <typename Key, typename Value, typename Hash = std::hash<Key>, typename Equals = std::equal_to<Key>>\n+class UnorderedMapFactory\n+{\n+public:\n+    static constexpr size_t ALLOCATION_SIZE_BYTES = memusage::NodeSize<std::unordered_map<Key, Value, Hash, Equals>>::Value();\n+    using MemoryResourceType = MemoryResource<ALLOCATION_SIZE_BYTES>;\n+    using AllocatorType = Allocator<std::pair<const Key, Value>, ALLOCATION_SIZE_BYTES>;\n+    using ContainerType = std::unordered_map<Key, Value, Hash, Equals, AllocatorType>;\n+\n+    /**\n+     * Creates the std::unordered_map container, and asserts that the specified memory_resource is\n+     * correct.\n+     */\n+    [[nodiscard]] static ContainerType CreateContainer(MemoryResourceType* memory_resource)",
    "path": "src/support/allocators/node_allocator.h",
    "position": null,
    "original_position": 397,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "a91b6032f037ab1a26ac4baa761e809fbfeb1bdd",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "I'd like to keep the `CreateContainer` here because otherwise constructing an unordered_map is quite a lot of non-obvious code, like first argument is always 0, then create a temporary hash of the correct typ, equals, and finally the Allocator.",
    "created_at": "2021-11-06T10:50:24Z",
    "updated_at": "2021-11-06T10:50:25Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r744111409",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744111409"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r744111409"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744111409/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 417,
    "side": "RIGHT",
    "in_reply_to_id": 737691663
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744113403",
    "pull_request_review_id": 799436948,
    "id": 744113403,
    "node_id": "PRRC_kwDOABII584sWkT7",
    "diff_hunk": "@@ -0,0 +1,406 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <memory>\n+#include <new>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based\n+ * containers that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs pools of memory and uses these to carve out memory for the nodes. Nodes\n+ * that are destroyed by the Allocator are actually put back into a free list for further use. This\n+ * behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored\n+ * in-place. This typically saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with\n+ * low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but\n+ * there is no standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to\n+ * the system. Memory is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on\n+ * proximity. So freeing and malloc'ing again can become a random access pattern which can lead to\n+ * more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers.\n+ * Similar to `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages memory. Currently\n+ * it is only able to provide optimized alloc/free for a single fixed allocation size which is given\n+ * in the constructor. Only allocations that match this size will be provided from the preallocated\n+ * pools of memory; all other requests simply use ::operator new(). To get the correct node size in\n+ * all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios\n+ * in `node_allocator_tests/test_allocations_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall \u201cHow to Write a Custom Allocator\u201d\n+ *   https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer \u201cAn Allocator is a Handle to a Heap\u201d\n+ *   https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *   https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+namespace detail {\n+\n+/**\n+ * In-place linked list of the allocations, used for the free list.\n+ */\n+struct FreeList {\n+    void* next;\n+};\n+\n+/**\n+ * Calculates the required allocation size for the given type.\n+ * The memory needs to be correctly aligned and large enough for both both T and FreeList.\n+ */\n+template <typename T>\n+[[nodiscard]] constexpr size_t RequiredAllocationSizeBytes() noexcept\n+{\n+    const auto alignment_max = std::max(std::alignment_of_v<T>, std::alignment_of_v<FreeList>);\n+    const auto size_max = std::max(sizeof(T), sizeof(FreeList));\n+\n+    // find closest multiple of alignment_max that holds size_max\n+    return ((size_max + alignment_max - 1U) / alignment_max) * alignment_max;\n+}\n+\n+} // namespace detail\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It\n+ * stores a number of memory pools which are used to quickly give out memory of a fixed allocation\n+ * size. The class is purposely kept very simple. It only knows about \"Allocations\" and \"Pools\".\n+ *\n+ * - Pool: MemoryResource allocates one memory pool at a time. These pools are kept around until the\n+ * memory resource is destroyed.\n+ *\n+ * - Allocations: Node-based containers allocate one node at a time. Whenever that happens, the\n+ * MemoryResource's Allocate() gives out memory for one node. These are carved out from a previously\n+ * allocated memory pool, or from a free list if it contains entries. Whenever a node is given back\n+ * with Deallocate(), it is put into that free list.\n+ */\n+template <size_t ALLOCATION_SIZE_BYTES>\n+class MemoryResource\n+{\n+    /**\n+     * Size in bytes to allocate per pool, currently hardcoded to multiple of ALLOCATION_SIZE_BYTES\n+     * that comes closest to 256 KiB.\n+     */\n+    static constexpr size_t POOL_SIZE_BYTES = (262144 / ALLOCATION_SIZE_BYTES) * ALLOCATION_SIZE_BYTES;\n+\n+public:\n+    /**\n+     * Construct a new MemoryResource object that uses the specified allocation size to optimize for.\n+     */\n+    MemoryResource() = default;\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated pools.\n+     *\n+     * There's no Clear() method on purpose, because it would be dangerous. E.g. when calling\n+     * clear() on an unordered_map, it is not certain that all allocated nodes are given back to the\n+     * MemoryResource. Microsoft's STL still uses a control structure that might have the same size\n+     * as the nodes, and therefore needs to be kept around until the map is actually destroyed.\n+     */\n+    ~MemoryResource() = default;\n+\n+    /**\n+     * Allocates memory for n * sizeof(T). Only when n==1 and T's size matches ALLOCATION_SIZE_BYTES\n+     * the pool's memory is used. Otherwise, the allocation is forwarded to ::operator new().\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        if constexpr (ALLOCATION_SIZE_BYTES == detail::RequiredAllocationSizeBytes<T>()) {\n+            if (n != 1) {\n+                // pool is not used so forward to operator new.\n+                return static_cast<T*>(::operator new(n * sizeof(T)));\n+            }\n+\n+            if (m_free_allocations) {\n+                // we've already got data in the free list, unlink one element\n+                auto old_head = m_free_allocations;\n+                m_free_allocations = static_cast<detail::FreeList*>(m_free_allocations)->next;\n+                return static_cast<T*>(old_head);\n+            }\n+\n+            // free list is empty: get one allocation from allocated pool memory.\n+            // It makes sense to not create the fully linked list of an allocated pool up-front, for\n+            // several reasons. On the one hand, the latency is higher when we need to iterate and\n+            // update pointers for the whole pool at once. More importantly, most systems lazily\n+            // allocate data. So when we allocate a big pool of memory the memory for a page is only\n+            // actually made available to the program when it is first touched. So when we allocate\n+            // a big pool and only use very little memory from it, the total memory usage is lower\n+            // than what has been malloc'ed.\n+            if (m_untouched_memory_iterator == m_untouched_memory_end) {\n+                // slow path, only happens when a new pool needs to be allocated\n+                AllocatePool();\n+            }\n+\n+            // peel off one allocation from the untouched memory. The next pointer of in-use\n+            // elements doesn't matter until it is deallocated, only then it is used to form the\n+            // free list.\n+            const auto tmp = m_untouched_memory_iterator;\n+            m_untouched_memory_iterator = static_cast<char*>(tmp) + ALLOCATION_SIZE_BYTES;\n+            return static_cast<T*>(tmp);\n+        } else {\n+            // pool is not used so forward to operator new.\n+            return static_cast<T*>(::operator new(n * sizeof(T)));\n+        }\n+    }\n+\n+    /**\n+     * Puts p back into the free list if it was actually allocated from the memory pool.\n+     * Otherwise, simply call ::operator delete(p).\n+     */\n+    template <typename T>\n+    void Deallocate(void* p, size_t n) noexcept\n+    {\n+        if constexpr (ALLOCATION_SIZE_BYTES == detail::RequiredAllocationSizeBytes<T>()) {\n+            if (n != 1) {\n+                // allocation didn't happen with the pool\n+                ::operator delete(p);\n+                return;\n+            }\n+\n+            // put it into the linked list\n+            const auto allocation = static_cast<detail::FreeList*>(p);\n+            allocation->next = m_free_allocations;\n+            m_free_allocations = allocation;\n+        } else {\n+            // allocation didn't happen with the pool\n+            ::operator delete(p);\n+        }\n+    }\n+\n+    /**\n+     * Calculates bytes allocated by the memory resource.\n+     */\n+    [[nodiscard]] size_t DynamicMemoryUsage() const noexcept\n+    {\n+        return memusage::MallocUsage(POOL_SIZE_BYTES) * m_allocated_pools.size() + memusage::DynamicUsage(m_allocated_pools);\n+    }\n+\n+private:\n+    //! Access to internals for testing purpose only\n+    friend class MemoryResourceTester;\n+\n+    /**\n+     * Allocate one full memory pool which is used to carve out allocations.\n+     */\n+    void AllocatePool()\n+    {\n+        m_allocated_pools.emplace_back(new char[POOL_SIZE_BYTES]);\n+        m_untouched_memory_iterator = m_allocated_pools.back().get();\n+        m_untouched_memory_end = m_allocated_pools.back().get() + POOL_SIZE_BYTES;\n+    }\n+\n+    //! Contains all allocated pools of memory, used to free the data in the destructor.\n+    std::vector<std::unique_ptr<char[]>> m_allocated_pools{};\n+\n+    //! A single linked list of all data available in the MemoryResource. This list is used for\n+    //! allocations of single elements.\n+    void* m_free_allocations = nullptr;\n+\n+    //! Points to the beginning of available memory for carving out allocations.\n+    void* m_untouched_memory_iterator = nullptr;\n+\n+    //! Points to the end of available memory for carving out allocations.\n+    void* m_untouched_memory_end = nullptr;\n+};\n+\n+\n+/**\n+ * Allocator that's usable for node-based containers like std::unordered_map or std::list.\n+ *\n+ * The allocator is stateful, and can be cheaply copied. Its state is an immobile MemoryResource,\n+ * which actually does all the allocation/deallocations. So this class is just a simple wrapper that\n+ * conforms to the required STL interface to be usable for the node-based containers.\n+ */\n+template <typename T, size_t ALLOCATION_SIZE_BYTES>\n+class Allocator\n+{\n+    template <typename U, size_t AS>\n+    friend class Allocator;\n+\n+    template <typename X, typename Y, size_t AS>\n+    friend bool operator==(const Allocator<X, AS>& a, const Allocator<Y, AS>& b) noexcept;\n+\n+public:\n+    using value_type = T;\n+\n+    /**\n+     * The allocator is stateful so we can't use the compile time `is_always_equal` optimization and\n+     * have to use the runtime operator==.\n+     */\n+    using is_always_equal = std::false_type;\n+\n+    /**\n+     * Move assignment should be a fast operation. In the case of a = std::move(b), we want\n+     * a to be able to use b's allocator, otherwise all elements would have to be recreated with a's\n+     * old allocator.\n+     */\n+    using propagate_on_container_move_assignment = std::true_type;\n+\n+    /**\n+     * Swapping two containers with unequal allocators who are *not* propagated is undefined\n+     * behavior. Unfortunately this is the default! Obviously, we don't want that.\n+     */\n+    using propagate_on_container_swap = std::true_type; // to avoid the undefined behavior\n+\n+    /**\n+     * Move and swap have to propagate the allocator, so for consistency we do the same for copy\n+     * assignment.\n+     */\n+    using propagate_on_container_copy_assignment = std::true_type;\n+\n+    /**\n+     * Construct a new Allocator object which will delegate all allocations/deallocations to the\n+     * memory resource.\n+     */\n+    explicit Allocator(MemoryResource<ALLOCATION_SIZE_BYTES>* memory_resource) noexcept\n+        : m_memory_resource(memory_resource)\n+    {\n+    }\n+\n+    /**\n+     * Conversion constructor for rebinding. All Allocators use the same memory_resource.\n+     *\n+     * The rebound type is determined with the `struct rebind`. The rebind is necessary feature\n+     * for standard allocators, and it happens when the allocator shall be used for different types.\n+     * E.g. for std::unordered_map this happens for allocation of the internally used nodes, for the\n+     * underlying index array, and possibly for some control structure. In fact the type required by\n+     * the standard `std::pair<const Key, Value>` type is never actually used for any allocation\n+     * (which is therefore a stupid requirement, but that's just C++ being C++).\n+     */\n+    template <typename U>\n+    Allocator(const Allocator<U, ALLOCATION_SIZE_BYTES>& other) noexcept\n+        : m_memory_resource(other.m_memory_resource)\n+    {\n+    }\n+\n+    /**\n+     * From the standard: rebind is only optional (provided by std::allocator_traits) if this\n+     * allocator is a template of the form SomeAllocator<T, Args>, where Args is zero or more\n+     * additional template type parameters.\n+     *\n+     * Since we use a size_t as additional argument, it's *not* optional.\n+     * @see https://en.cppreference.com/w/cpp/named_req/Allocator#cite_note-2\n+     */\n+    template <typename U>\n+    struct rebind {\n+        using other = Allocator<U, ALLOCATION_SIZE_BYTES>;\n+    };\n+\n+    /**\n+     * Allocates n entries of the given type.\n+     */\n+    T* allocate(size_t n)\n+    {\n+        // Forward all allocations to the memory_resource\n+        return m_memory_resource->template Allocate<T>(n);\n+    }\n+\n+    /**\n+     * Deallocates n entries of the given type.\n+     */\n+    void deallocate(T* p, size_t n)\n+    {\n+        m_memory_resource->template Deallocate<T>(p, n);\n+    }\n+\n+private:\n+    //! Stateful allocator, where the state is a simple pointer that can be cheaply copied.\n+    MemoryResource<ALLOCATION_SIZE_BYTES>* m_memory_resource;\n+};\n+\n+\n+/**\n+ * Since Allocator is stateful, comparison with another one only returns true if it uses the same\n+ * memory_resource.\n+ */\n+template <typename T, typename U, size_t CS>\n+bool operator==(const Allocator<T, CS>& a, const Allocator<U, CS>& b) noexcept\n+{\n+    // \"Equality of an allocator is determined through the ability of allocating memory with one\n+    // allocator and deallocating it with another.\" - Jonathan M\u00fcller\n+    // See https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+    //\n+    // For us that is the case when both allocators use the same memory resource.\n+    return a.m_memory_resource == b.m_memory_resource;\n+}\n+\n+template <typename T, typename U, size_t CS>\n+bool operator!=(const Allocator<T, CS>& a, const Allocator<U, CS>& b) noexcept\n+{\n+    return !(a == b);\n+}\n+\n+/**\n+ * Helper to create std::unordered_map which uses the node_allocator.\n+ *\n+ * This calculates the size of the container's internally used node correctly for all supported\n+ * platforms, which is also asserted by the unit tests.\n+ */\n+template <typename Key, typename Value, typename Hash = std::hash<Key>, typename Equals = std::equal_to<Key>>\n+class UnorderedMapFactory\n+{\n+public:\n+    static constexpr size_t ALLOCATION_SIZE_BYTES = memusage::NodeSize<std::unordered_map<Key, Value, Hash, Equals>>::Value();",
    "path": "src/support/allocators/node_allocator.h",
    "position": null,
    "original_position": 388,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "a91b6032f037ab1a26ac4baa761e809fbfeb1bdd",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Thanks, and I agree that is the correct way to do it. I don't think it was a bug though, at least the worst thing that could happen was that it falls back to default `::operator new`, but for that there are unit tests too.",
    "created_at": "2021-11-06T11:14:11Z",
    "updated_at": "2021-11-06T11:14:11Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r744113403",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744113403"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r744113403"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744113403/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 388,
    "side": "RIGHT",
    "in_reply_to_id": 738584696
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744113774",
    "pull_request_review_id": 799437137,
    "id": 744113774,
    "node_id": "PRRC_kwDOABII584sWkZu",
    "diff_hunk": "@@ -0,0 +1,406 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <memory>\n+#include <new>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based\n+ * containers that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs pools of memory and uses these to carve out memory for the nodes. Nodes\n+ * that are destroyed by the Allocator are actually put back into a free list for further use. This\n+ * behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored\n+ * in-place. This typically saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with\n+ * low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but\n+ * there is no standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to\n+ * the system. Memory is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on\n+ * proximity. So freeing and malloc'ing again can become a random access pattern which can lead to\n+ * more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers.\n+ * Similar to `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages memory. Currently\n+ * it is only able to provide optimized alloc/free for a single fixed allocation size which is given\n+ * in the constructor. Only allocations that match this size will be provided from the preallocated\n+ * pools of memory; all other requests simply use ::operator new(). To get the correct node size in\n+ * all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios\n+ * in `node_allocator_tests/test_allocations_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall \u201cHow to Write a Custom Allocator\u201d\n+ *   https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer \u201cAn Allocator is a Handle to a Heap\u201d\n+ *   https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *   https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+namespace detail {\n+\n+/**\n+ * In-place linked list of the allocations, used for the free list.\n+ */\n+struct FreeList {\n+    void* next;\n+};\n+\n+/**\n+ * Calculates the required allocation size for the given type.\n+ * The memory needs to be correctly aligned and large enough for both both T and FreeList.\n+ */\n+template <typename T>\n+[[nodiscard]] constexpr size_t RequiredAllocationSizeBytes() noexcept\n+{\n+    const auto alignment_max = std::max(std::alignment_of_v<T>, std::alignment_of_v<FreeList>);\n+    const auto size_max = std::max(sizeof(T), sizeof(FreeList));\n+\n+    // find closest multiple of alignment_max that holds size_max\n+    return ((size_max + alignment_max - 1U) / alignment_max) * alignment_max;\n+}\n+\n+} // namespace detail\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It\n+ * stores a number of memory pools which are used to quickly give out memory of a fixed allocation\n+ * size. The class is purposely kept very simple. It only knows about \"Allocations\" and \"Pools\".\n+ *\n+ * - Pool: MemoryResource allocates one memory pool at a time. These pools are kept around until the\n+ * memory resource is destroyed.\n+ *\n+ * - Allocations: Node-based containers allocate one node at a time. Whenever that happens, the\n+ * MemoryResource's Allocate() gives out memory for one node. These are carved out from a previously\n+ * allocated memory pool, or from a free list if it contains entries. Whenever a node is given back\n+ * with Deallocate(), it is put into that free list.\n+ */\n+template <size_t ALLOCATION_SIZE_BYTES>\n+class MemoryResource\n+{\n+    /**\n+     * Size in bytes to allocate per pool, currently hardcoded to multiple of ALLOCATION_SIZE_BYTES\n+     * that comes closest to 256 KiB.\n+     */\n+    static constexpr size_t POOL_SIZE_BYTES = (262144 / ALLOCATION_SIZE_BYTES) * ALLOCATION_SIZE_BYTES;\n+\n+public:\n+    /**\n+     * Construct a new MemoryResource object that uses the specified allocation size to optimize for.\n+     */\n+    MemoryResource() = default;\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated pools.\n+     *\n+     * There's no Clear() method on purpose, because it would be dangerous. E.g. when calling\n+     * clear() on an unordered_map, it is not certain that all allocated nodes are given back to the\n+     * MemoryResource. Microsoft's STL still uses a control structure that might have the same size\n+     * as the nodes, and therefore needs to be kept around until the map is actually destroyed.\n+     */\n+    ~MemoryResource() = default;\n+\n+    /**\n+     * Allocates memory for n * sizeof(T). Only when n==1 and T's size matches ALLOCATION_SIZE_BYTES\n+     * the pool's memory is used. Otherwise, the allocation is forwarded to ::operator new().\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        if constexpr (ALLOCATION_SIZE_BYTES == detail::RequiredAllocationSizeBytes<T>()) {\n+            if (n != 1) {\n+                // pool is not used so forward to operator new.\n+                return static_cast<T*>(::operator new(n * sizeof(T)));\n+            }\n+\n+            if (m_free_allocations) {\n+                // we've already got data in the free list, unlink one element\n+                auto old_head = m_free_allocations;\n+                m_free_allocations = static_cast<detail::FreeList*>(m_free_allocations)->next;\n+                return static_cast<T*>(old_head);\n+            }\n+\n+            // free list is empty: get one allocation from allocated pool memory.\n+            // It makes sense to not create the fully linked list of an allocated pool up-front, for\n+            // several reasons. On the one hand, the latency is higher when we need to iterate and\n+            // update pointers for the whole pool at once. More importantly, most systems lazily\n+            // allocate data. So when we allocate a big pool of memory the memory for a page is only\n+            // actually made available to the program when it is first touched. So when we allocate\n+            // a big pool and only use very little memory from it, the total memory usage is lower\n+            // than what has been malloc'ed.\n+            if (m_untouched_memory_iterator == m_untouched_memory_end) {\n+                // slow path, only happens when a new pool needs to be allocated\n+                AllocatePool();\n+            }\n+\n+            // peel off one allocation from the untouched memory. The next pointer of in-use\n+            // elements doesn't matter until it is deallocated, only then it is used to form the\n+            // free list.\n+            const auto tmp = m_untouched_memory_iterator;\n+            m_untouched_memory_iterator = static_cast<char*>(tmp) + ALLOCATION_SIZE_BYTES;\n+            return static_cast<T*>(tmp);\n+        } else {\n+            // pool is not used so forward to operator new.\n+            return static_cast<T*>(::operator new(n * sizeof(T)));\n+        }\n+    }\n+\n+    /**\n+     * Puts p back into the free list if it was actually allocated from the memory pool.\n+     * Otherwise, simply call ::operator delete(p).\n+     */\n+    template <typename T>\n+    void Deallocate(void* p, size_t n) noexcept\n+    {\n+        if constexpr (ALLOCATION_SIZE_BYTES == detail::RequiredAllocationSizeBytes<T>()) {\n+            if (n != 1) {\n+                // allocation didn't happen with the pool\n+                ::operator delete(p);\n+                return;\n+            }\n+\n+            // put it into the linked list\n+            const auto allocation = static_cast<detail::FreeList*>(p);\n+            allocation->next = m_free_allocations;\n+            m_free_allocations = allocation;\n+        } else {\n+            // allocation didn't happen with the pool\n+            ::operator delete(p);\n+        }\n+    }\n+\n+    /**\n+     * Calculates bytes allocated by the memory resource.\n+     */\n+    [[nodiscard]] size_t DynamicMemoryUsage() const noexcept\n+    {\n+        return memusage::MallocUsage(POOL_SIZE_BYTES) * m_allocated_pools.size() + memusage::DynamicUsage(m_allocated_pools);\n+    }\n+\n+private:\n+    //! Access to internals for testing purpose only\n+    friend class MemoryResourceTester;\n+\n+    /**\n+     * Allocate one full memory pool which is used to carve out allocations.\n+     */\n+    void AllocatePool()\n+    {\n+        m_allocated_pools.emplace_back(new char[POOL_SIZE_BYTES]);\n+        m_untouched_memory_iterator = m_allocated_pools.back().get();\n+        m_untouched_memory_end = m_allocated_pools.back().get() + POOL_SIZE_BYTES;\n+    }\n+\n+    //! Contains all allocated pools of memory, used to free the data in the destructor.\n+    std::vector<std::unique_ptr<char[]>> m_allocated_pools{};\n+\n+    //! A single linked list of all data available in the MemoryResource. This list is used for\n+    //! allocations of single elements.\n+    void* m_free_allocations = nullptr;\n+\n+    //! Points to the beginning of available memory for carving out allocations.\n+    void* m_untouched_memory_iterator = nullptr;\n+\n+    //! Points to the end of available memory for carving out allocations.\n+    void* m_untouched_memory_end = nullptr;\n+};\n+\n+\n+/**\n+ * Allocator that's usable for node-based containers like std::unordered_map or std::list.\n+ *\n+ * The allocator is stateful, and can be cheaply copied. Its state is an immobile MemoryResource,\n+ * which actually does all the allocation/deallocations. So this class is just a simple wrapper that\n+ * conforms to the required STL interface to be usable for the node-based containers.\n+ */\n+template <typename T, size_t ALLOCATION_SIZE_BYTES>\n+class Allocator\n+{\n+    template <typename U, size_t AS>\n+    friend class Allocator;\n+\n+    template <typename X, typename Y, size_t AS>\n+    friend bool operator==(const Allocator<X, AS>& a, const Allocator<Y, AS>& b) noexcept;\n+\n+public:\n+    using value_type = T;\n+\n+    /**\n+     * The allocator is stateful so we can't use the compile time `is_always_equal` optimization and\n+     * have to use the runtime operator==.\n+     */\n+    using is_always_equal = std::false_type;\n+\n+    /**\n+     * Move assignment should be a fast operation. In the case of a = std::move(b), we want\n+     * a to be able to use b's allocator, otherwise all elements would have to be recreated with a's\n+     * old allocator.\n+     */\n+    using propagate_on_container_move_assignment = std::true_type;\n+\n+    /**\n+     * Swapping two containers with unequal allocators who are *not* propagated is undefined\n+     * behavior. Unfortunately this is the default! Obviously, we don't want that.\n+     */\n+    using propagate_on_container_swap = std::true_type; // to avoid the undefined behavior\n+\n+    /**\n+     * Move and swap have to propagate the allocator, so for consistency we do the same for copy\n+     * assignment.",
    "path": "src/support/allocators/node_allocator.h",
    "position": null,
    "original_position": 292,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "a91b6032f037ab1a26ac4baa761e809fbfeb1bdd",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "no real downside, it's just that because the allocator has a state it also has to be propagated.",
    "created_at": "2021-11-06T11:17:30Z",
    "updated_at": "2021-11-06T11:17:30Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r744113774",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744113774"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r744113774"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744113774/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": 291,
    "start_side": "RIGHT",
    "line": null,
    "original_line": 289,
    "side": "RIGHT",
    "in_reply_to_id": 738593890
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744114802",
    "pull_request_review_id": 799437808,
    "id": 744114802,
    "node_id": "PRRC_kwDOABII584sWkpy",
    "diff_hunk": "@@ -0,0 +1,424 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <support/allocators/node_allocator.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <list>\n+#include <map>\n+#include <string>\n+#include <type_traits>\n+#include <unordered_map>\n+\n+namespace node_allocator {\n+\n+class MemoryResourceTester\n+{\n+public:\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static size_t NumFreeAllocations(\n+        MemoryResource<ALLOCATION_SIZE_BYTES> const& mr) noexcept\n+    {\n+        size_t length = 0;\n+        auto allocation = mr.m_free_allocations;\n+        while (allocation) {\n+            allocation = static_cast<detail::FreeList const*>(allocation)->next;\n+            ++length;\n+        }\n+        return length;\n+    }\n+\n+    /**\n+     * Number of memory pools that have been allocated\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static size_t NumPools(MemoryResource<ALLOCATION_SIZE_BYTES> const& mr) noexcept\n+    {\n+        return mr.m_allocated_pools.size();\n+    }\n+\n+\n+    /**\n+     * Extracts allocation size from the type\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static constexpr size_t AllocationSizeBytes(MemoryResource<ALLOCATION_SIZE_BYTES> const&) noexcept\n+    {\n+        return ALLOCATION_SIZE_BYTES;\n+    }\n+};\n+\n+} // namespace node_allocator\n+\n+BOOST_FIXTURE_TEST_SUITE(node_allocator_tests, BasicTestingSetup)\n+\n+#define CHECK_MEMORY_RESOURCE(mr, num_free_allocations, num_pools)                   \\\n+    BOOST_CHECK_EQUAL(num_free_allocations,                                          \\\n+                      node_allocator::MemoryResourceTester::NumFreeAllocations(mr)); \\\n+    BOOST_CHECK_EQUAL(num_pools, node_allocator::MemoryResourceTester::NumPools(mr));\n+\n+#define CHECK_IN_RANGE(what, lowerInclusive, upperInclusive) \\\n+    BOOST_TEST(what >= lowerInclusive);                      \\\n+    BOOST_TEST(what <= upperInclusive);\n+\n+BOOST_AUTO_TEST_CASE(too_small)\n+{\n+    node_allocator::MemoryResource<sizeof(void*)> mr{};\n+    void* ptr{mr.Allocate<char>(1)};\n+    BOOST_CHECK(ptr != nullptr);\n+\n+    // mr is used\n+    CHECK_MEMORY_RESOURCE(mr, 0, 1);\n+    mr.Deallocate<char>(ptr, 1);\n+    CHECK_MEMORY_RESOURCE(mr, 1, 1);\n+\n+    // void* works too, use freelist\n+    ptr = mr.Allocate<void*>(1);\n+    BOOST_CHECK(ptr != nullptr);\n+    CHECK_MEMORY_RESOURCE(mr, 0, 1);\n+    mr.Deallocate<char>(ptr, 1);\n+    CHECK_MEMORY_RESOURCE(mr, 1, 1);\n+}\n+\n+BOOST_AUTO_TEST_CASE(std_unordered_map)\n+{\n+    using Factory = node_allocator::UnorderedMapFactory<uint64_t, uint64_t>;\n+\n+    Factory::MemoryResourceType mr{};\n+    auto m = Factory::CreateContainer(&mr);\n+    size_t num_free_allocations = 0;\n+    {\n+        auto a = Factory::CreateContainer(&mr);\n+\n+        // Allocator compares equal because the same memory resource is used\n+        BOOST_CHECK(a.get_allocator() == m.get_allocator());\n+        for (uint64_t i = 0; i < 1000; ++i) {\n+            a[i] = i;\n+        }\n+\n+        num_free_allocations = node_allocator::MemoryResourceTester::NumFreeAllocations(mr);\n+\n+        // create a copy of the map, destroy the map => now a lot more free allocations should be\n+        // available\n+        {\n+            auto b = a;\n+        }\n+\n+        BOOST_CHECK(node_allocator::MemoryResourceTester::NumFreeAllocations(mr) >\n+                    num_free_allocations);\n+        num_free_allocations = node_allocator::MemoryResourceTester::NumFreeAllocations(mr);\n+\n+        // creating another copy, and then destroying everything should reuse all the allocations\n+        {\n+            auto b = a;\n+        }\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr),\n+                          num_free_allocations);\n+\n+        // moving the map should not create new nodes\n+        m = std::move(a);\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr),\n+                          num_free_allocations);\n+    }\n+    // a is destroyed, still all allocations should stay roughly the same.\n+    BOOST_CHECK(node_allocator::MemoryResourceTester::NumFreeAllocations(mr) <=\n+                num_free_allocations + 5);\n+\n+    m = Factory::CreateContainer(&mr);\n+\n+    // now we got everything free\n+    BOOST_CHECK(node_allocator::MemoryResourceTester::NumFreeAllocations(mr) >\n+                num_free_allocations + 50);",
    "path": "src/test/node_allocator_tests.cpp",
    "position": null,
    "original_position": 138,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "a91b6032f037ab1a26ac4baa761e809fbfeb1bdd",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "it sure can be made stricter :+1: ",
    "created_at": "2021-11-06T11:29:25Z",
    "updated_at": "2021-11-06T11:29:25Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r744114802",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744114802"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r744114802"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744114802/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": 137,
    "start_side": "RIGHT",
    "line": null,
    "original_line": 138,
    "side": "RIGHT",
    "in_reply_to_id": 738640412
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744115818",
    "pull_request_review_id": 799438471,
    "id": 744115818,
    "node_id": "PRRC_kwDOABII584sWk5q",
    "diff_hunk": "@@ -0,0 +1,424 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <support/allocators/node_allocator.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <list>\n+#include <map>\n+#include <string>\n+#include <type_traits>\n+#include <unordered_map>\n+\n+namespace node_allocator {\n+\n+class MemoryResourceTester\n+{\n+public:\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static size_t NumFreeAllocations(\n+        MemoryResource<ALLOCATION_SIZE_BYTES> const& mr) noexcept\n+    {\n+        size_t length = 0;\n+        auto allocation = mr.m_free_allocations;\n+        while (allocation) {\n+            allocation = static_cast<detail::FreeList const*>(allocation)->next;\n+            ++length;\n+        }\n+        return length;\n+    }\n+\n+    /**\n+     * Number of memory pools that have been allocated\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static size_t NumPools(MemoryResource<ALLOCATION_SIZE_BYTES> const& mr) noexcept\n+    {\n+        return mr.m_allocated_pools.size();\n+    }\n+\n+\n+    /**\n+     * Extracts allocation size from the type\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static constexpr size_t AllocationSizeBytes(MemoryResource<ALLOCATION_SIZE_BYTES> const&) noexcept\n+    {\n+        return ALLOCATION_SIZE_BYTES;\n+    }\n+};\n+\n+} // namespace node_allocator\n+\n+BOOST_FIXTURE_TEST_SUITE(node_allocator_tests, BasicTestingSetup)\n+\n+#define CHECK_MEMORY_RESOURCE(mr, num_free_allocations, num_pools)                   \\\n+    BOOST_CHECK_EQUAL(num_free_allocations,                                          \\\n+                      node_allocator::MemoryResourceTester::NumFreeAllocations(mr)); \\\n+    BOOST_CHECK_EQUAL(num_pools, node_allocator::MemoryResourceTester::NumPools(mr));\n+\n+#define CHECK_IN_RANGE(what, lowerInclusive, upperInclusive) \\\n+    BOOST_TEST(what >= lowerInclusive);                      \\\n+    BOOST_TEST(what <= upperInclusive);\n+\n+BOOST_AUTO_TEST_CASE(too_small)\n+{\n+    node_allocator::MemoryResource<sizeof(void*)> mr{};\n+    void* ptr{mr.Allocate<char>(1)};\n+    BOOST_CHECK(ptr != nullptr);\n+\n+    // mr is used\n+    CHECK_MEMORY_RESOURCE(mr, 0, 1);\n+    mr.Deallocate<char>(ptr, 1);\n+    CHECK_MEMORY_RESOURCE(mr, 1, 1);\n+\n+    // void* works too, use freelist\n+    ptr = mr.Allocate<void*>(1);\n+    BOOST_CHECK(ptr != nullptr);\n+    CHECK_MEMORY_RESOURCE(mr, 0, 1);\n+    mr.Deallocate<char>(ptr, 1);\n+    CHECK_MEMORY_RESOURCE(mr, 1, 1);\n+}\n+\n+BOOST_AUTO_TEST_CASE(std_unordered_map)\n+{\n+    using Factory = node_allocator::UnorderedMapFactory<uint64_t, uint64_t>;\n+\n+    Factory::MemoryResourceType mr{};\n+    auto m = Factory::CreateContainer(&mr);\n+    size_t num_free_allocations = 0;\n+    {\n+        auto a = Factory::CreateContainer(&mr);\n+\n+        // Allocator compares equal because the same memory resource is used\n+        BOOST_CHECK(a.get_allocator() == m.get_allocator());\n+        for (uint64_t i = 0; i < 1000; ++i) {\n+            a[i] = i;\n+        }\n+\n+        num_free_allocations = node_allocator::MemoryResourceTester::NumFreeAllocations(mr);\n+\n+        // create a copy of the map, destroy the map => now a lot more free allocations should be\n+        // available\n+        {\n+            auto b = a;\n+        }\n+\n+        BOOST_CHECK(node_allocator::MemoryResourceTester::NumFreeAllocations(mr) >\n+                    num_free_allocations);\n+        num_free_allocations = node_allocator::MemoryResourceTester::NumFreeAllocations(mr);\n+\n+        // creating another copy, and then destroying everything should reuse all the allocations\n+        {\n+            auto b = a;\n+        }\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr),\n+                          num_free_allocations);\n+\n+        // moving the map should not create new nodes\n+        m = std::move(a);\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr),\n+                          num_free_allocations);\n+    }\n+    // a is destroyed, still all allocations should stay roughly the same.\n+    BOOST_CHECK(node_allocator::MemoryResourceTester::NumFreeAllocations(mr) <=\n+                num_free_allocations + 5);\n+\n+    m = Factory::CreateContainer(&mr);\n+\n+    // now we got everything free\n+    BOOST_CHECK(node_allocator::MemoryResourceTester::NumFreeAllocations(mr) >\n+                num_free_allocations + 50);\n+}\n+\n+BOOST_AUTO_TEST_CASE(different_memoryresource_assignment)\n+{\n+    using Factory = node_allocator::UnorderedMapFactory<uint64_t, uint64_t>;\n+\n+    Factory::MemoryResourceType mr_a{};\n+    Factory::MemoryResourceType mr_b{};\n+\n+    {\n+        auto map_a = Factory::CreateContainer(&mr_a);\n+        for (int i = 0; i < 100; ++i) {\n+            map_a[i] = i;\n+        }\n+\n+        {\n+            auto map_b = Factory::CreateContainer(&mr_b);\n+            map_b[123] = 321;\n+            BOOST_CHECK(map_a.get_allocator() != map_b.get_allocator());\n+            BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 0);\n+            BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumPools(mr_b), 1);\n+\n+            map_b = map_a;\n+\n+            // map_a now uses mr_b, since propagate_on_container_copy_assignment is std::true_type\n+            BOOST_CHECK(map_a.get_allocator() == map_b.get_allocator());\n+            CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 1U, 2U);\n+            BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumPools(mr_b), 1);\n+\n+            // map_b was now recreated with data from map_a, using mr_a as the memory resource.\n+        }\n+\n+        // map_b destroyed, should not have any effect on mr_b\n+        CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 1U, 2U);\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumPools(mr_b), 1);\n+        // but we'll get more free allocations in mr_a\n+        CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 100U, 101U);\n+    }\n+\n+    // finally map_a is destroyed, getting more free allocations.\n+    CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 200U, 202U);\n+}\n+\n+\n+BOOST_AUTO_TEST_CASE(different_memoryresource_move)\n+{\n+    using Factory = node_allocator::UnorderedMapFactory<uint64_t, uint64_t>;\n+\n+    Factory::MemoryResourceType mr_a{};\n+    Factory::MemoryResourceType mr_b{};\n+\n+    {\n+        auto map_a = Factory::CreateContainer(&mr_a);\n+        for (int i = 0; i < 100; ++i) {\n+            map_a[i] = i;\n+        }\n+\n+        {\n+            auto map_b = Factory::CreateContainer(&mr_b);\n+            map_b[123] = 321;\n+\n+            map_b = std::move(map_a);\n+\n+            // map_a now uses mr_b, since propagate_on_container_move_assignment is std::true_type\n+            BOOST_CHECK(map_a.get_allocator() == map_b.get_allocator());\n+            CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 1U, 2U);\n+            BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumPools(mr_b), 1);\n+\n+            // map_b was now recreated with data from map_a, using mr_a as the memory resource.\n+        }\n+\n+        // map_b destroyed, should not have any effect on mr_b.\n+        CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 1U, 2U);\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumPools(mr_b), 1);\n+        // but we'll get more free allocations in mr_a\n+        CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 100U, 101U);\n+    }\n+\n+    // finally map_a is destroyed, but since it was moved, no more free allocations.\n+    CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 100U, 102U);\n+}\n+\n+\n+BOOST_AUTO_TEST_CASE(different_memoryresource_swap)\n+{\n+    using Factory = node_allocator::UnorderedMapFactory<uint64_t, uint64_t>;\n+\n+    Factory::MemoryResourceType mr_a{};\n+    Factory::MemoryResourceType mr_b{};\n+\n+    {\n+        auto map_a = Factory::CreateContainer(&mr_a);\n+        for (int i = 0; i < 100; ++i) {\n+            map_a[i] = i;\n+        }\n+\n+        {\n+            auto map_b = Factory::CreateContainer(&mr_b);\n+            map_b[123] = 321;\n+\n+            auto alloc_a = map_a.get_allocator();\n+            auto alloc_b = map_b.get_allocator();\n+\n+            std::swap(map_a, map_b);\n+\n+            // The maps have swapped, so their allocators have swapped, too.\n+            // No additional allocations have occurred!\n+            BOOST_CHECK(map_a.get_allocator() != map_b.get_allocator());\n+            BOOST_CHECK(alloc_a == map_b.get_allocator());\n+            BOOST_CHECK(alloc_b == map_a.get_allocator());\n+        }\n+\n+        // map_b destroyed, so mr_a must have plenty of free allocations now\n+        CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 100U, 101U);\n+\n+        // nothing happened to map_a, so mr_b still has no free allocations\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 0);\n+    }\n+\n+    // finally map_a is destroyed, so we got an entry back for mr_b.\n+    CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 100U, 101U);\n+    CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 1U, 2U);\n+}\n+\n+// some structs with defined alignment and customizeable size\n+\n+namespace {\n+\n+template <size_t S>\n+struct alignas(1) A1 {\n+    char data[S];\n+};\n+\n+template <size_t S>\n+struct alignas(2) A2 {\n+    char data[S];\n+};\n+\n+template <size_t S>\n+struct alignas(4) A4 {\n+    char data[S];\n+};\n+\n+template <size_t S>\n+struct alignas(8) A8 {\n+    char data[S];\n+};\n+\n+template <size_t S>\n+struct alignas(16) A16 {\n+    char data[S];\n+};\n+\n+template <size_t S>\n+struct alignas(32) A32 {\n+    char data[S];\n+};\n+\n+} // namespace\n+\n+BOOST_AUTO_TEST_CASE(calc_required_allocation_size)\n+{\n+    static_assert(sizeof(A1<1>) == 1U);\n+    static_assert(std::alignment_of_v<A1<1>> == 1U);\n+\n+    static_assert(sizeof(A16<1>) == 16U);\n+    static_assert(std::alignment_of_v<A16<1>> == 16U);\n+    static_assert(sizeof(A16<16>) == 16U);\n+    static_assert(std::alignment_of_v<A16<16>> == 16U);\n+    static_assert(sizeof(A16<24>) == 32U);\n+    static_assert(std::alignment_of_v<A16<24>> == 16U);\n+\n+#if UINTPTR_MAX == 0xFFFFFFFFFFFFFFFF\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A1<1>>());\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A1<7>>());\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A1<8>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A1<9>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A1<15>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A1<16>>());\n+    static_assert(24U == node_allocator::detail::RequiredAllocationSizeBytes<A1<17>>());\n+    static_assert(104U == node_allocator::detail::RequiredAllocationSizeBytes<A1<100>>());\n+\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A4<4>>());\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A4<7>>());\n+    static_assert(104U == node_allocator::detail::RequiredAllocationSizeBytes<A4<100>>());\n+    static_assert(104U == node_allocator::detail::RequiredAllocationSizeBytes<A8<100>>());\n+\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A8<1>>());\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A8<8>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A8<16>>());\n+\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A16<1>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A16<8>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A16<16>>());\n+    static_assert(32U == node_allocator::detail::RequiredAllocationSizeBytes<A16<17>>());\n+#elif UINTPTR_MAX == 0xFFFFFFFF\n+    static_assert(4U == node_allocator::detail::RequiredAllocationSizeBytes<A1<1>>());\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A1<7>>());\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A1<8>>());\n+    static_assert(12U == node_allocator::detail::RequiredAllocationSizeBytes<A1<9>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A1<15>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A1<16>>());\n+    static_assert(20U == node_allocator::detail::RequiredAllocationSizeBytes<A1<17>>());\n+    static_assert(100U == node_allocator::detail::RequiredAllocationSizeBytes<A1<100>>());\n+\n+    static_assert(4U == node_allocator::detail::RequiredAllocationSizeBytes<A4<4>>());\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A4<7>>());\n+    static_assert(100U == node_allocator::detail::RequiredAllocationSizeBytes<A4<100>>());\n+    static_assert(104U == node_allocator::detail::RequiredAllocationSizeBytes<A8<100>>());\n+\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A8<1>>());\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A8<8>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A8<16>>());\n+\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A16<1>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A16<8>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A16<16>>());\n+    static_assert(32U == node_allocator::detail::RequiredAllocationSizeBytes<A16<17>>());\n+#else\n+#error \"Invalid sizeof(void*)\"\n+#endif\n+}\n+\n+namespace {\n+\n+template <typename T>\n+struct NotNoexceptHash {\n+    size_t operator()(const T& x) const /* noexcept */ { return std::hash<T>{}(x); }",
    "path": "src/test/node_allocator_tests.cpp",
    "position": null,
    "original_position": 366,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "a91b6032f037ab1a26ac4baa761e809fbfeb1bdd",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "`noexcept(false)` and writing nothing is equivalent",
    "created_at": "2021-11-06T11:41:53Z",
    "updated_at": "2021-11-06T11:41:53Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r744115818",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744115818"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r744115818"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744115818/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 366,
    "side": "RIGHT",
    "in_reply_to_id": 738674496
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744290144",
    "pull_request_review_id": 799565520,
    "id": 744290144,
    "node_id": "PRRC_kwDOABII584sXPdg",
    "diff_hunk": "@@ -0,0 +1,52 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <bench/bench.h>\n+#include <coins.h>\n+#include <memusage.h>\n+#include <support/allocators/node_allocator.h>\n+\n+#include <cstring>\n+#include <iostream>\n+#include <unordered_map>\n+\n+template <typename Map>\n+void BenchFillClearMap(benchmark::Bench& bench, Map& map)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(1);\n+    tx.vin[0].scriptSig = CScript() << OP_2;\n+    tx.vin[0].scriptWitness.stack.push_back({2});\n+    tx.vout.resize(1);\n+    tx.vout[0].scriptPubKey = CScript() << OP_2 << OP_EQUAL;\n+    tx.vout[0].nValue = 10 * COIN;",
    "path": "src/bench/node_allocator.cpp",
    "position": null,
    "original_position": 23,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "a91b6032f037ab1a26ac4baa761e809fbfeb1bdd",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done in e2a5547f12e5da2718ba17ebac5d5aeb5a2e24d5",
    "created_at": "2021-11-07T17:24:56Z",
    "updated_at": "2021-11-07T17:24:56Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r744290144",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744290144"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r744290144"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744290144/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": 17,
    "start_side": "RIGHT",
    "line": null,
    "original_line": 23,
    "side": "RIGHT",
    "in_reply_to_id": 736984281
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744290224",
    "pull_request_review_id": 799565608,
    "id": 744290224,
    "node_id": "PRRC_kwDOABII584sXPew",
    "diff_hunk": "@@ -148,23 +154,65 @@ static inline size_t DynamicUsage(const std::shared_ptr<X>& p)\n     return p ? MallocUsage(sizeof(X)) + MallocUsage(sizeof(stl_shared_counter)) : 0;\n }\n \n-template<typename X>\n-struct unordered_node : private X\n-{\n-private:\n-    void* ptr;\n+template <typename T>\n+struct NodeSize {\n+};\n+\n+// It is important that the calculation here matches exactly the behavior of std::unordered_map\n+// so the node_allocator actually works. This is tested in node_allocator_tests/test_allocations_are_used\n+// with multiple configurations (alignments, noexcept hash, node sizes).\n+template <typename Key, typename V, typename Hash, typename Equals, typename Allocator>\n+struct NodeSize<std::unordered_map<Key, V, Hash, Equals, Allocator>> {\n+    [[nodiscard]] static constexpr size_t Value()\n+    {\n+        // libstdc++, libc++, and MSVC implement the nodes differently. To get the correct size\n+        // with the correct alignment, we can simulate that with accordingly nested std::pairs.\n+        using ValueType = std::pair<const Key, V>;\n+\n+#if defined(_MSC_VER)\n+        // list node contains 2 pointers and no hash; see\n+        // https://github.com/microsoft/STL/blob/main/stl/inc/unordered_map and\n+        // https://github.com/microsoft/STL/blob/main/stl/inc/list\n+        return sizeof(std::pair<std::pair<void*, void*>, ValueType>);\n+#else\n+\n+#if defined(_LIBCPP_VERSION) // defined in any C++ header from libc++\n+        // libc++ always stores hash and pointer in the node\n+        // see https://github.com/llvm/llvm-project/blob/release/13.x/libcxx/include/__hash_table#L92\n+        return sizeof(std::pair<ValueType, std::pair<size_t, void*>>);\n+#else\n+        // libstdc++ doesn't store hash when its operator() is noexcept;\n+        // see hashtable_policy.h, struct _Hash_node\n+        // https://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a05689.html\n+        if (noexcept(std::declval<Hash>()(std::declval<const Key&>()))) {\n+            return sizeof(std::pair<void*, ValueType>);\n+        } else {\n+            // hash is stored along ValueType, and that is wrapped with the pointer.\n+            return sizeof(std::pair<void*, std::pair<ValueType, size_t>>);\n+        }\n+#endif\n+#endif\n+    }\n };\n \n template<typename X, typename Y>\n static inline size_t DynamicUsage(const std::unordered_set<X, Y>& s)\n {\n-    return MallocUsage(sizeof(unordered_node<X>)) * s.size() + MallocUsage(sizeof(void*) * s.bucket_count());\n+    return MallocUsage(sizeof(std::pair<X, void*>)) * s.size() + MallocUsage(sizeof(void*) * s.bucket_count());\n }\n \n-template<typename X, typename Y, typename Z>\n-static inline size_t DynamicUsage(const std::unordered_map<X, Y, Z>& m)\n+template <typename Key, typename Value, typename Hash, typename Equals, typename Alloc>\n+static inline size_t DynamicUsage(const std::unordered_map<Key, Value, Hash, Equals, Alloc>& m)\n {\n-    return MallocUsage(sizeof(unordered_node<std::pair<const X, Y> >)) * m.size() + MallocUsage(sizeof(void*) * m.bucket_count());\n+    using ContainerType = std::unordered_map<Key, Value, Hash, Equals, Alloc>;\n+    if constexpr (std::is_same_v<Alloc, node_allocator::Allocator<std::pair<const Key, Value>, memusage::NodeSize<ContainerType>::Value()>>) {\n+        // Assumes that DynamicUsage of the MemoryResource is called separately. We don't do it here\n+        // because multiple maps could use the same MemoryResource.\n+        return MallocUsage(sizeof(void*) * m.bucket_count());\n+    } else {\n+        auto node_size = NodeSize<std::unordered_map<Key, Value, Hash, Equals, Alloc>>::Value();",
    "path": "src/memusage.h",
    "position": null,
    "original_position": 82,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "a91b6032f037ab1a26ac4baa761e809fbfeb1bdd",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Split that code up into two methods in e2a5547f12e5da2718ba17ebac5d5aeb5a2e24d5",
    "created_at": "2021-11-07T17:26:00Z",
    "updated_at": "2021-11-07T17:26:00Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r744290224",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744290224"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r744290224"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744290224/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 213,
    "side": "RIGHT",
    "in_reply_to_id": 736991419
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744290282",
    "pull_request_review_id": 799565667,
    "id": 744290282,
    "node_id": "PRRC_kwDOABII584sXPfq",
    "diff_hunk": "@@ -148,23 +154,65 @@ static inline size_t DynamicUsage(const std::shared_ptr<X>& p)\n     return p ? MallocUsage(sizeof(X)) + MallocUsage(sizeof(stl_shared_counter)) : 0;\n }\n \n-template<typename X>\n-struct unordered_node : private X\n-{\n-private:\n-    void* ptr;\n+template <typename T>\n+struct NodeSize {\n+};\n+\n+// It is important that the calculation here matches exactly the behavior of std::unordered_map\n+// so the node_allocator actually works. This is tested in node_allocator_tests/test_allocations_are_used\n+// with multiple configurations (alignments, noexcept hash, node sizes).\n+template <typename Key, typename V, typename Hash, typename Equals, typename Allocator>\n+struct NodeSize<std::unordered_map<Key, V, Hash, Equals, Allocator>> {\n+    [[nodiscard]] static constexpr size_t Value()\n+    {\n+        // libstdc++, libc++, and MSVC implement the nodes differently. To get the correct size\n+        // with the correct alignment, we can simulate that with accordingly nested std::pairs.\n+        using ValueType = std::pair<const Key, V>;\n+\n+#if defined(_MSC_VER)\n+        // list node contains 2 pointers and no hash; see\n+        // https://github.com/microsoft/STL/blob/main/stl/inc/unordered_map and\n+        // https://github.com/microsoft/STL/blob/main/stl/inc/list\n+        return sizeof(std::pair<std::pair<void*, void*>, ValueType>);\n+#else\n+\n+#if defined(_LIBCPP_VERSION) // defined in any C++ header from libc++\n+        // libc++ always stores hash and pointer in the node\n+        // see https://github.com/llvm/llvm-project/blob/release/13.x/libcxx/include/__hash_table#L92\n+        return sizeof(std::pair<ValueType, std::pair<size_t, void*>>);\n+#else\n+        // libstdc++ doesn't store hash when its operator() is noexcept;\n+        // see hashtable_policy.h, struct _Hash_node\n+        // https://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a05689.html\n+        if (noexcept(std::declval<Hash>()(std::declval<const Key&>()))) {\n+            return sizeof(std::pair<void*, ValueType>);\n+        } else {\n+            // hash is stored along ValueType, and that is wrapped with the pointer.\n+            return sizeof(std::pair<void*, std::pair<ValueType, size_t>>);\n+        }\n+#endif\n+#endif\n+    }\n };\n \n template<typename X, typename Y>\n static inline size_t DynamicUsage(const std::unordered_set<X, Y>& s)\n {\n-    return MallocUsage(sizeof(unordered_node<X>)) * s.size() + MallocUsage(sizeof(void*) * s.bucket_count());\n+    return MallocUsage(sizeof(std::pair<X, void*>)) * s.size() + MallocUsage(sizeof(void*) * s.bucket_count());\n }\n \n-template<typename X, typename Y, typename Z>\n-static inline size_t DynamicUsage(const std::unordered_map<X, Y, Z>& m)\n+template <typename Key, typename Value, typename Hash, typename Equals, typename Alloc>\n+static inline size_t DynamicUsage(const std::unordered_map<Key, Value, Hash, Equals, Alloc>& m)\n {\n-    return MallocUsage(sizeof(unordered_node<std::pair<const X, Y> >)) * m.size() + MallocUsage(sizeof(void*) * m.bucket_count());\n+    using ContainerType = std::unordered_map<Key, Value, Hash, Equals, Alloc>;\n+    if constexpr (std::is_same_v<Alloc, node_allocator::Allocator<std::pair<const Key, Value>, memusage::NodeSize<ContainerType>::Value()>>) {",
    "path": "src/memusage.h",
    "position": null,
    "original_position": 77,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "a91b6032f037ab1a26ac4baa761e809fbfeb1bdd",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "done in e2a5547f12e5da2718ba17ebac5d5aeb5a2e24d5",
    "created_at": "2021-11-07T17:26:41Z",
    "updated_at": "2021-11-07T17:26:41Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r744290282",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744290282"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r744290282"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744290282/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 208,
    "side": "RIGHT",
    "in_reply_to_id": 736987229
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744290330",
    "pull_request_review_id": 799565704,
    "id": 744290330,
    "node_id": "PRRC_kwDOABII584sXPga",
    "diff_hunk": "@@ -0,0 +1,406 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <memory>\n+#include <new>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based\n+ * containers that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs pools of memory and uses these to carve out memory for the nodes. Nodes\n+ * that are destroyed by the Allocator are actually put back into a free list for further use. This",
    "path": "src/support/allocators/node_allocator.h",
    "position": null,
    "original_position": 25,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "a91b6032f037ab1a26ac4baa761e809fbfeb1bdd",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "done in e2a5547f12e5da2718ba17ebac5d5aeb5a2e24d5",
    "created_at": "2021-11-07T17:27:09Z",
    "updated_at": "2021-11-07T17:27:10Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r744290330",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744290330"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r744290330"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744290330/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 25,
    "side": "RIGHT",
    "in_reply_to_id": 737604676
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744290597",
    "pull_request_review_id": 799565871,
    "id": 744290597,
    "node_id": "PRRC_kwDOABII584sXPkl",
    "diff_hunk": "@@ -0,0 +1,406 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <memory>\n+#include <new>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based\n+ * containers that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs pools of memory and uses these to carve out memory for the nodes. Nodes\n+ * that are destroyed by the Allocator are actually put back into a free list for further use. This\n+ * behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored\n+ * in-place. This typically saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with\n+ * low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but\n+ * there is no standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to\n+ * the system. Memory is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on\n+ * proximity. So freeing and malloc'ing again can become a random access pattern which can lead to\n+ * more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers.\n+ * Similar to `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages memory. Currently\n+ * it is only able to provide optimized alloc/free for a single fixed allocation size which is given\n+ * in the constructor. Only allocations that match this size will be provided from the preallocated\n+ * pools of memory; all other requests simply use ::operator new(). To get the correct node size in\n+ * all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.",
    "path": "src/support/allocators/node_allocator.h",
    "position": null,
    "original_position": 56,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "a91b6032f037ab1a26ac4baa761e809fbfeb1bdd",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "done in e2a5547f12e5da2718ba17ebac5d5aeb5a2e24d5",
    "created_at": "2021-11-07T17:29:11Z",
    "updated_at": "2021-11-07T17:29:11Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r744290597",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744290597"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r744290597"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744290597/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 56,
    "side": "RIGHT",
    "in_reply_to_id": 737617919
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744290749",
    "pull_request_review_id": 799565963,
    "id": 744290749,
    "node_id": "PRRC_kwDOABII584sXPm9",
    "diff_hunk": "@@ -0,0 +1,406 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <memory>\n+#include <new>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based\n+ * containers that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs pools of memory and uses these to carve out memory for the nodes. Nodes\n+ * that are destroyed by the Allocator are actually put back into a free list for further use. This\n+ * behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored\n+ * in-place. This typically saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with\n+ * low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but\n+ * there is no standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to\n+ * the system. Memory is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on\n+ * proximity. So freeing and malloc'ing again can become a random access pattern which can lead to\n+ * more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers.\n+ * Similar to `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages memory. Currently\n+ * it is only able to provide optimized alloc/free for a single fixed allocation size which is given\n+ * in the constructor. Only allocations that match this size will be provided from the preallocated\n+ * pools of memory; all other requests simply use ::operator new(). To get the correct node size in\n+ * all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios\n+ * in `node_allocator_tests/test_allocations_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall \u201cHow to Write a Custom Allocator\u201d\n+ *   https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer \u201cAn Allocator is a Handle to a Heap\u201d\n+ *   https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *   https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+namespace detail {\n+\n+/**\n+ * In-place linked list of the allocations, used for the free list.\n+ */\n+struct FreeList {\n+    void* next;\n+};\n+\n+/**\n+ * Calculates the required allocation size for the given type.\n+ * The memory needs to be correctly aligned and large enough for both both T and FreeList.\n+ */\n+template <typename T>\n+[[nodiscard]] constexpr size_t RequiredAllocationSizeBytes() noexcept\n+{\n+    const auto alignment_max = std::max(std::alignment_of_v<T>, std::alignment_of_v<FreeList>);\n+    const auto size_max = std::max(sizeof(T), sizeof(FreeList));\n+\n+    // find closest multiple of alignment_max that holds size_max\n+    return ((size_max + alignment_max - 1U) / alignment_max) * alignment_max;\n+}\n+\n+} // namespace detail\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It\n+ * stores a number of memory pools which are used to quickly give out memory of a fixed allocation\n+ * size. The class is purposely kept very simple. It only knows about \"Allocations\" and \"Pools\".\n+ *\n+ * - Pool: MemoryResource allocates one memory pool at a time. These pools are kept around until the\n+ * memory resource is destroyed.\n+ *\n+ * - Allocations: Node-based containers allocate one node at a time. Whenever that happens, the\n+ * MemoryResource's Allocate() gives out memory for one node. These are carved out from a previously\n+ * allocated memory pool, or from a free list if it contains entries. Whenever a node is given back\n+ * with Deallocate(), it is put into that free list.\n+ */\n+template <size_t ALLOCATION_SIZE_BYTES>\n+class MemoryResource\n+{\n+    /**\n+     * Size in bytes to allocate per pool, currently hardcoded to multiple of ALLOCATION_SIZE_BYTES\n+     * that comes closest to 256 KiB.\n+     */\n+    static constexpr size_t POOL_SIZE_BYTES = (262144 / ALLOCATION_SIZE_BYTES) * ALLOCATION_SIZE_BYTES;\n+\n+public:\n+    /**\n+     * Construct a new MemoryResource object that uses the specified allocation size to optimize for.\n+     */\n+    MemoryResource() = default;\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated pools.\n+     *\n+     * There's no Clear() method on purpose, because it would be dangerous. E.g. when calling\n+     * clear() on an unordered_map, it is not certain that all allocated nodes are given back to the\n+     * MemoryResource. Microsoft's STL still uses a control structure that might have the same size\n+     * as the nodes, and therefore needs to be kept around until the map is actually destroyed.\n+     */\n+    ~MemoryResource() = default;\n+\n+    /**\n+     * Allocates memory for n * sizeof(T). Only when n==1 and T's size matches ALLOCATION_SIZE_BYTES\n+     * the pool's memory is used. Otherwise, the allocation is forwarded to ::operator new().\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        if constexpr (ALLOCATION_SIZE_BYTES == detail::RequiredAllocationSizeBytes<T>()) {",
    "path": "src/support/allocators/node_allocator.h",
    "position": null,
    "original_position": 153,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "a91b6032f037ab1a26ac4baa761e809fbfeb1bdd",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Hm, I don't really want to add a counter for `m_free_allocations` but also don't want to iterate through the freelist. I think it's ok to keep the `MemoryResource::DynamicMemoryUsage` as it is because all that memory is the responsibility of that class. I got rid of the `if constexpr` though in e2a5547f12e5da2718ba17ebac5d5aeb5a2e24d5.\r\n",
    "created_at": "2021-11-07T17:30:17Z",
    "updated_at": "2021-11-07T17:30:17Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r744290749",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744290749"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r744290749"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744290749/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 153,
    "side": "RIGHT",
    "in_reply_to_id": 737631026
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744290919",
    "pull_request_review_id": 799566073,
    "id": 744290919,
    "node_id": "PRRC_kwDOABII584sXPpn",
    "diff_hunk": "@@ -0,0 +1,406 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <memory>\n+#include <new>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based\n+ * containers that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs pools of memory and uses these to carve out memory for the nodes. Nodes\n+ * that are destroyed by the Allocator are actually put back into a free list for further use. This\n+ * behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored\n+ * in-place. This typically saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with\n+ * low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but\n+ * there is no standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to\n+ * the system. Memory is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on\n+ * proximity. So freeing and malloc'ing again can become a random access pattern which can lead to\n+ * more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers.\n+ * Similar to `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages memory. Currently\n+ * it is only able to provide optimized alloc/free for a single fixed allocation size which is given\n+ * in the constructor. Only allocations that match this size will be provided from the preallocated\n+ * pools of memory; all other requests simply use ::operator new(). To get the correct node size in\n+ * all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios\n+ * in `node_allocator_tests/test_allocations_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall \u201cHow to Write a Custom Allocator\u201d\n+ *   https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer \u201cAn Allocator is a Handle to a Heap\u201d\n+ *   https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *   https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+namespace detail {\n+\n+/**\n+ * In-place linked list of the allocations, used for the free list.\n+ */\n+struct FreeList {\n+    void* next;",
    "path": "src/support/allocators/node_allocator.h",
    "position": null,
    "original_position": 78,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "a91b6032f037ab1a26ac4baa761e809fbfeb1bdd",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "`MemoryResource::Deallocate` now uses pacement new in e2a5547f12e5da2718ba17ebac5d5aeb5a2e24d5, and uses the returned pointer.",
    "created_at": "2021-11-07T17:31:44Z",
    "updated_at": "2021-11-07T17:31:44Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r744290919",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744290919"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r744290919"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744290919/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 78,
    "side": "RIGHT",
    "in_reply_to_id": 737638806
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744291003",
    "pull_request_review_id": 799566136,
    "id": 744291003,
    "node_id": "PRRC_kwDOABII584sXPq7",
    "diff_hunk": "@@ -0,0 +1,406 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <memory>\n+#include <new>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based\n+ * containers that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs pools of memory and uses these to carve out memory for the nodes. Nodes\n+ * that are destroyed by the Allocator are actually put back into a free list for further use. This\n+ * behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored\n+ * in-place. This typically saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with\n+ * low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but\n+ * there is no standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to\n+ * the system. Memory is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on\n+ * proximity. So freeing and malloc'ing again can become a random access pattern which can lead to\n+ * more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers.\n+ * Similar to `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages memory. Currently\n+ * it is only able to provide optimized alloc/free for a single fixed allocation size which is given\n+ * in the constructor. Only allocations that match this size will be provided from the preallocated\n+ * pools of memory; all other requests simply use ::operator new(). To get the correct node size in\n+ * all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios\n+ * in `node_allocator_tests/test_allocations_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall \u201cHow to Write a Custom Allocator\u201d\n+ *   https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer \u201cAn Allocator is a Handle to a Heap\u201d\n+ *   https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *   https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+namespace detail {\n+\n+/**\n+ * In-place linked list of the allocations, used for the free list.\n+ */\n+struct FreeList {\n+    void* next;\n+};\n+\n+/**\n+ * Calculates the required allocation size for the given type.\n+ * The memory needs to be correctly aligned and large enough for both both T and FreeList.\n+ */\n+template <typename T>\n+[[nodiscard]] constexpr size_t RequiredAllocationSizeBytes() noexcept\n+{\n+    const auto alignment_max = std::max(std::alignment_of_v<T>, std::alignment_of_v<FreeList>);\n+    const auto size_max = std::max(sizeof(T), sizeof(FreeList));\n+\n+    // find closest multiple of alignment_max that holds size_max\n+    return ((size_max + alignment_max - 1U) / alignment_max) * alignment_max;\n+}\n+\n+} // namespace detail\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It\n+ * stores a number of memory pools which are used to quickly give out memory of a fixed allocation\n+ * size. The class is purposely kept very simple. It only knows about \"Allocations\" and \"Pools\".\n+ *\n+ * - Pool: MemoryResource allocates one memory pool at a time. These pools are kept around until the\n+ * memory resource is destroyed.\n+ *\n+ * - Allocations: Node-based containers allocate one node at a time. Whenever that happens, the\n+ * MemoryResource's Allocate() gives out memory for one node. These are carved out from a previously\n+ * allocated memory pool, or from a free list if it contains entries. Whenever a node is given back\n+ * with Deallocate(), it is put into that free list.\n+ */\n+template <size_t ALLOCATION_SIZE_BYTES>\n+class MemoryResource\n+{\n+    /**\n+     * Size in bytes to allocate per pool, currently hardcoded to multiple of ALLOCATION_SIZE_BYTES\n+     * that comes closest to 256 KiB.\n+     */\n+    static constexpr size_t POOL_SIZE_BYTES = (262144 / ALLOCATION_SIZE_BYTES) * ALLOCATION_SIZE_BYTES;\n+\n+public:\n+    /**\n+     * Construct a new MemoryResource object that uses the specified allocation size to optimize for.\n+     */\n+    MemoryResource() = default;\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated pools.\n+     *\n+     * There's no Clear() method on purpose, because it would be dangerous. E.g. when calling\n+     * clear() on an unordered_map, it is not certain that all allocated nodes are given back to the\n+     * MemoryResource. Microsoft's STL still uses a control structure that might have the same size\n+     * as the nodes, and therefore needs to be kept around until the map is actually destroyed.\n+     */\n+    ~MemoryResource() = default;\n+\n+    /**\n+     * Allocates memory for n * sizeof(T). Only when n==1 and T's size matches ALLOCATION_SIZE_BYTES\n+     * the pool's memory is used. Otherwise, the allocation is forwarded to ::operator new().\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        if constexpr (ALLOCATION_SIZE_BYTES == detail::RequiredAllocationSizeBytes<T>()) {\n+            if (n != 1) {\n+                // pool is not used so forward to operator new.\n+                return static_cast<T*>(::operator new(n * sizeof(T)));\n+            }\n+\n+            if (m_free_allocations) {\n+                // we've already got data in the free list, unlink one element\n+                auto old_head = m_free_allocations;\n+                m_free_allocations = static_cast<detail::FreeList*>(m_free_allocations)->next;\n+                return static_cast<T*>(old_head);\n+            }\n+\n+            // free list is empty: get one allocation from allocated pool memory.\n+            // It makes sense to not create the fully linked list of an allocated pool up-front, for\n+            // several reasons. On the one hand, the latency is higher when we need to iterate and\n+            // update pointers for the whole pool at once. More importantly, most systems lazily\n+            // allocate data. So when we allocate a big pool of memory the memory for a page is only\n+            // actually made available to the program when it is first touched. So when we allocate\n+            // a big pool and only use very little memory from it, the total memory usage is lower\n+            // than what has been malloc'ed.\n+            if (m_untouched_memory_iterator == m_untouched_memory_end) {\n+                // slow path, only happens when a new pool needs to be allocated\n+                AllocatePool();\n+            }\n+\n+            // peel off one allocation from the untouched memory. The next pointer of in-use\n+            // elements doesn't matter until it is deallocated, only then it is used to form the\n+            // free list.\n+            const auto tmp = m_untouched_memory_iterator;\n+            m_untouched_memory_iterator = static_cast<char*>(tmp) + ALLOCATION_SIZE_BYTES;\n+            return static_cast<T*>(tmp);\n+        } else {\n+            // pool is not used so forward to operator new.\n+            return static_cast<T*>(::operator new(n * sizeof(T)));\n+        }\n+    }\n+\n+    /**\n+     * Puts p back into the free list if it was actually allocated from the memory pool.\n+     * Otherwise, simply call ::operator delete(p).\n+     */\n+    template <typename T>\n+    void Deallocate(void* p, size_t n) noexcept\n+    {\n+        if constexpr (ALLOCATION_SIZE_BYTES == detail::RequiredAllocationSizeBytes<T>()) {\n+            if (n != 1) {\n+                // allocation didn't happen with the pool\n+                ::operator delete(p);\n+                return;\n+            }\n+\n+            // put it into the linked list\n+            const auto allocation = static_cast<detail::FreeList*>(p);\n+            allocation->next = m_free_allocations;\n+            m_free_allocations = allocation;\n+        } else {\n+            // allocation didn't happen with the pool\n+            ::operator delete(p);\n+        }\n+    }\n+\n+    /**\n+     * Calculates bytes allocated by the memory resource.\n+     */\n+    [[nodiscard]] size_t DynamicMemoryUsage() const noexcept\n+    {\n+        return memusage::MallocUsage(POOL_SIZE_BYTES) * m_allocated_pools.size() + memusage::DynamicUsage(m_allocated_pools);\n+    }\n+\n+private:\n+    //! Access to internals for testing purpose only\n+    friend class MemoryResourceTester;\n+\n+    /**\n+     * Allocate one full memory pool which is used to carve out allocations.\n+     */\n+    void AllocatePool()\n+    {\n+        m_allocated_pools.emplace_back(new char[POOL_SIZE_BYTES]);\n+        m_untouched_memory_iterator = m_allocated_pools.back().get();\n+        m_untouched_memory_end = m_allocated_pools.back().get() + POOL_SIZE_BYTES;\n+    }\n+\n+    //! Contains all allocated pools of memory, used to free the data in the destructor.\n+    std::vector<std::unique_ptr<char[]>> m_allocated_pools{};\n+\n+    //! A single linked list of all data available in the MemoryResource. This list is used for\n+    //! allocations of single elements.\n+    void* m_free_allocations = nullptr;",
    "path": "src/support/allocators/node_allocator.h",
    "position": null,
    "original_position": 242,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "a91b6032f037ab1a26ac4baa761e809fbfeb1bdd",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "done in e2a5547f12e5da2718ba17ebac5d5aeb5a2e24d5. I also changed the `m_untouched_memory_iterator` and `m_untouched_memory_end` from `void*` to `char*`.",
    "created_at": "2021-11-07T17:32:28Z",
    "updated_at": "2021-11-07T17:32:28Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r744291003",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744291003"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r744291003"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744291003/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 242,
    "side": "RIGHT",
    "in_reply_to_id": 737639301
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744292595",
    "pull_request_review_id": 799567333,
    "id": 744292595,
    "node_id": "PRRC_kwDOABII584sXQDz",
    "diff_hunk": "@@ -148,23 +154,65 @@ static inline size_t DynamicUsage(const std::shared_ptr<X>& p)\n     return p ? MallocUsage(sizeof(X)) + MallocUsage(sizeof(stl_shared_counter)) : 0;\n }\n \n-template<typename X>\n-struct unordered_node : private X\n-{\n-private:\n-    void* ptr;\n+template <typename T>\n+struct NodeSize {\n+};\n+\n+// It is important that the calculation here matches exactly the behavior of std::unordered_map\n+// so the node_allocator actually works. This is tested in node_allocator_tests/test_allocations_are_used\n+// with multiple configurations (alignments, noexcept hash, node sizes).\n+template <typename Key, typename V, typename Hash, typename Equals, typename Allocator>\n+struct NodeSize<std::unordered_map<Key, V, Hash, Equals, Allocator>> {\n+    [[nodiscard]] static constexpr size_t Value()\n+    {\n+        // libstdc++, libc++, and MSVC implement the nodes differently. To get the correct size\n+        // with the correct alignment, we can simulate that with accordingly nested std::pairs.\n+        using ValueType = std::pair<const Key, V>;",
    "path": "src/memusage.h",
    "position": null,
    "original_position": 35,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "a91b6032f037ab1a26ac4baa761e809fbfeb1bdd",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Moved comment in e2a5547f12e5da2718ba17ebac5d5aeb5a2e24d5",
    "created_at": "2021-11-07T17:46:26Z",
    "updated_at": "2021-11-07T17:46:26Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r744292595",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744292595"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r744292595"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744292595/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": 168,
    "start_side": "RIGHT",
    "line": null,
    "original_line": 170,
    "side": "RIGHT",
    "in_reply_to_id": 738550995
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744292623",
    "pull_request_review_id": 799567367,
    "id": 744292623,
    "node_id": "PRRC_kwDOABII584sXQEP",
    "diff_hunk": "@@ -148,23 +154,65 @@ static inline size_t DynamicUsage(const std::shared_ptr<X>& p)\n     return p ? MallocUsage(sizeof(X)) + MallocUsage(sizeof(stl_shared_counter)) : 0;\n }\n \n-template<typename X>\n-struct unordered_node : private X\n-{\n-private:\n-    void* ptr;\n+template <typename T>\n+struct NodeSize {\n+};\n+\n+// It is important that the calculation here matches exactly the behavior of std::unordered_map\n+// so the node_allocator actually works. This is tested in node_allocator_tests/test_allocations_are_used\n+// with multiple configurations (alignments, noexcept hash, node sizes).\n+template <typename Key, typename V, typename Hash, typename Equals, typename Allocator>\n+struct NodeSize<std::unordered_map<Key, V, Hash, Equals, Allocator>> {\n+    [[nodiscard]] static constexpr size_t Value()\n+    {\n+        // libstdc++, libc++, and MSVC implement the nodes differently. To get the correct size\n+        // with the correct alignment, we can simulate that with accordingly nested std::pairs.\n+        using ValueType = std::pair<const Key, V>;\n+\n+#if defined(_MSC_VER)\n+        // list node contains 2 pointers and no hash; see\n+        // https://github.com/microsoft/STL/blob/main/stl/inc/unordered_map and\n+        // https://github.com/microsoft/STL/blob/main/stl/inc/list\n+        return sizeof(std::pair<std::pair<void*, void*>, ValueType>);\n+#else\n+\n+#if defined(_LIBCPP_VERSION) // defined in any C++ header from libc++\n+        // libc++ always stores hash and pointer in the node\n+        // see https://github.com/llvm/llvm-project/blob/release/13.x/libcxx/include/__hash_table#L92\n+        return sizeof(std::pair<ValueType, std::pair<size_t, void*>>);\n+#else\n+        // libstdc++ doesn't store hash when its operator() is noexcept;\n+        // see hashtable_policy.h, struct _Hash_node\n+        // https://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a05689.html\n+        if (noexcept(std::declval<Hash>()(std::declval<const Key&>()))) {\n+            return sizeof(std::pair<void*, ValueType>);\n+        } else {\n+            // hash is stored along ValueType, and that is wrapped with the pointer.\n+            return sizeof(std::pair<void*, std::pair<ValueType, size_t>>);\n+        }\n+#endif\n+#endif",
    "path": "src/memusage.h",
    "position": null,
    "original_position": 59,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "a91b6032f037ab1a26ac4baa761e809fbfeb1bdd",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "done in e2a5547f12e5da2718ba17ebac5d5aeb5a2e24d5",
    "created_at": "2021-11-07T17:46:44Z",
    "updated_at": "2021-11-07T17:46:45Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r744292623",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744292623"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r744292623"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744292623/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": 193,
    "start_side": "RIGHT",
    "line": null,
    "original_line": 188,
    "side": "RIGHT",
    "in_reply_to_id": 738569770
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744292648",
    "pull_request_review_id": 799567401,
    "id": 744292648,
    "node_id": "PRRC_kwDOABII584sXQEo",
    "diff_hunk": "@@ -0,0 +1,406 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <memory>\n+#include <new>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based\n+ * containers that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs pools of memory and uses these to carve out memory for the nodes. Nodes\n+ * that are destroyed by the Allocator are actually put back into a free list for further use. This\n+ * behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored\n+ * in-place. This typically saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with\n+ * low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but\n+ * there is no standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to\n+ * the system. Memory is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on\n+ * proximity. So freeing and malloc'ing again can become a random access pattern which can lead to\n+ * more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers.\n+ * Similar to `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages memory. Currently\n+ * it is only able to provide optimized alloc/free for a single fixed allocation size which is given\n+ * in the constructor. Only allocations that match this size will be provided from the preallocated\n+ * pools of memory; all other requests simply use ::operator new(). To get the correct node size in\n+ * all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios\n+ * in `node_allocator_tests/test_allocations_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall \u201cHow to Write a Custom Allocator\u201d\n+ *   https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer \u201cAn Allocator is a Handle to a Heap\u201d\n+ *   https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *   https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+namespace detail {\n+\n+/**\n+ * In-place linked list of the allocations, used for the free list.\n+ */\n+struct FreeList {\n+    void* next;\n+};\n+\n+/**\n+ * Calculates the required allocation size for the given type.\n+ * The memory needs to be correctly aligned and large enough for both both T and FreeList.\n+ */\n+template <typename T>\n+[[nodiscard]] constexpr size_t RequiredAllocationSizeBytes() noexcept\n+{\n+    const auto alignment_max = std::max(std::alignment_of_v<T>, std::alignment_of_v<FreeList>);\n+    const auto size_max = std::max(sizeof(T), sizeof(FreeList));\n+\n+    // find closest multiple of alignment_max that holds size_max\n+    return ((size_max + alignment_max - 1U) / alignment_max) * alignment_max;\n+}\n+\n+} // namespace detail\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It\n+ * stores a number of memory pools which are used to quickly give out memory of a fixed allocation\n+ * size. The class is purposely kept very simple. It only knows about \"Allocations\" and \"Pools\".\n+ *\n+ * - Pool: MemoryResource allocates one memory pool at a time. These pools are kept around until the\n+ * memory resource is destroyed.\n+ *\n+ * - Allocations: Node-based containers allocate one node at a time. Whenever that happens, the\n+ * MemoryResource's Allocate() gives out memory for one node. These are carved out from a previously\n+ * allocated memory pool, or from a free list if it contains entries. Whenever a node is given back\n+ * with Deallocate(), it is put into that free list.\n+ */\n+template <size_t ALLOCATION_SIZE_BYTES>\n+class MemoryResource\n+{\n+    /**\n+     * Size in bytes to allocate per pool, currently hardcoded to multiple of ALLOCATION_SIZE_BYTES\n+     * that comes closest to 256 KiB.\n+     */\n+    static constexpr size_t POOL_SIZE_BYTES = (262144 / ALLOCATION_SIZE_BYTES) * ALLOCATION_SIZE_BYTES;\n+\n+public:\n+    /**\n+     * Construct a new MemoryResource object that uses the specified allocation size to optimize for.\n+     */\n+    MemoryResource() = default;\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated pools.\n+     *\n+     * There's no Clear() method on purpose, because it would be dangerous. E.g. when calling\n+     * clear() on an unordered_map, it is not certain that all allocated nodes are given back to the\n+     * MemoryResource. Microsoft's STL still uses a control structure that might have the same size\n+     * as the nodes, and therefore needs to be kept around until the map is actually destroyed.\n+     */\n+    ~MemoryResource() = default;\n+\n+    /**\n+     * Allocates memory for n * sizeof(T). Only when n==1 and T's size matches ALLOCATION_SIZE_BYTES\n+     * the pool's memory is used. Otherwise, the allocation is forwarded to ::operator new().\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        if constexpr (ALLOCATION_SIZE_BYTES == detail::RequiredAllocationSizeBytes<T>()) {\n+            if (n != 1) {\n+                // pool is not used so forward to operator new.\n+                return static_cast<T*>(::operator new(n * sizeof(T)));\n+            }\n+\n+            if (m_free_allocations) {\n+                // we've already got data in the free list, unlink one element\n+                auto old_head = m_free_allocations;\n+                m_free_allocations = static_cast<detail::FreeList*>(m_free_allocations)->next;\n+                return static_cast<T*>(old_head);\n+            }\n+\n+            // free list is empty: get one allocation from allocated pool memory.\n+            // It makes sense to not create the fully linked list of an allocated pool up-front, for\n+            // several reasons. On the one hand, the latency is higher when we need to iterate and\n+            // update pointers for the whole pool at once. More importantly, most systems lazily\n+            // allocate data. So when we allocate a big pool of memory the memory for a page is only\n+            // actually made available to the program when it is first touched. So when we allocate\n+            // a big pool and only use very little memory from it, the total memory usage is lower\n+            // than what has been malloc'ed.\n+            if (m_untouched_memory_iterator == m_untouched_memory_end) {\n+                // slow path, only happens when a new pool needs to be allocated\n+                AllocatePool();\n+            }\n+\n+            // peel off one allocation from the untouched memory. The next pointer of in-use\n+            // elements doesn't matter until it is deallocated, only then it is used to form the\n+            // free list.\n+            const auto tmp = m_untouched_memory_iterator;\n+            m_untouched_memory_iterator = static_cast<char*>(tmp) + ALLOCATION_SIZE_BYTES;\n+            return static_cast<T*>(tmp);\n+        } else {\n+            // pool is not used so forward to operator new.\n+            return static_cast<T*>(::operator new(n * sizeof(T)));\n+        }\n+    }\n+\n+    /**\n+     * Puts p back into the free list if it was actually allocated from the memory pool.\n+     * Otherwise, simply call ::operator delete(p).\n+     */\n+    template <typename T>\n+    void Deallocate(void* p, size_t n) noexcept\n+    {\n+        if constexpr (ALLOCATION_SIZE_BYTES == detail::RequiredAllocationSizeBytes<T>()) {\n+            if (n != 1) {\n+                // allocation didn't happen with the pool\n+                ::operator delete(p);\n+                return;\n+            }\n+\n+            // put it into the linked list\n+            const auto allocation = static_cast<detail::FreeList*>(p);\n+            allocation->next = m_free_allocations;\n+            m_free_allocations = allocation;\n+        } else {\n+            // allocation didn't happen with the pool\n+            ::operator delete(p);\n+        }\n+    }\n+\n+    /**\n+     * Calculates bytes allocated by the memory resource.\n+     */\n+    [[nodiscard]] size_t DynamicMemoryUsage() const noexcept\n+    {\n+        return memusage::MallocUsage(POOL_SIZE_BYTES) * m_allocated_pools.size() + memusage::DynamicUsage(m_allocated_pools);\n+    }\n+\n+private:\n+    //! Access to internals for testing purpose only\n+    friend class MemoryResourceTester;\n+\n+    /**\n+     * Allocate one full memory pool which is used to carve out allocations.\n+     */\n+    void AllocatePool()\n+    {\n+        m_allocated_pools.emplace_back(new char[POOL_SIZE_BYTES]);\n+        m_untouched_memory_iterator = m_allocated_pools.back().get();\n+        m_untouched_memory_end = m_allocated_pools.back().get() + POOL_SIZE_BYTES;\n+    }\n+\n+    //! Contains all allocated pools of memory, used to free the data in the destructor.\n+    std::vector<std::unique_ptr<char[]>> m_allocated_pools{};\n+\n+    //! A single linked list of all data available in the MemoryResource. This list is used for\n+    //! allocations of single elements.\n+    void* m_free_allocations = nullptr;\n+\n+    //! Points to the beginning of available memory for carving out allocations.\n+    void* m_untouched_memory_iterator = nullptr;\n+\n+    //! Points to the end of available memory for carving out allocations.\n+    void* m_untouched_memory_end = nullptr;\n+};\n+\n+\n+/**\n+ * Allocator that's usable for node-based containers like std::unordered_map or std::list.\n+ *\n+ * The allocator is stateful, and can be cheaply copied. Its state is an immobile MemoryResource,\n+ * which actually does all the allocation/deallocations. So this class is just a simple wrapper that\n+ * conforms to the required STL interface to be usable for the node-based containers.\n+ */\n+template <typename T, size_t ALLOCATION_SIZE_BYTES>\n+class Allocator\n+{\n+    template <typename U, size_t AS>\n+    friend class Allocator;\n+\n+    template <typename X, typename Y, size_t AS>\n+    friend bool operator==(const Allocator<X, AS>& a, const Allocator<Y, AS>& b) noexcept;\n+\n+public:\n+    using value_type = T;\n+\n+    /**\n+     * The allocator is stateful so we can't use the compile time `is_always_equal` optimization and\n+     * have to use the runtime operator==.\n+     */\n+    using is_always_equal = std::false_type;\n+\n+    /**\n+     * Move assignment should be a fast operation. In the case of a = std::move(b), we want\n+     * a to be able to use b's allocator, otherwise all elements would have to be recreated with a's\n+     * old allocator.\n+     */\n+    using propagate_on_container_move_assignment = std::true_type;\n+\n+    /**\n+     * Swapping two containers with unequal allocators who are *not* propagated is undefined\n+     * behavior. Unfortunately this is the default! Obviously, we don't want that.\n+     */\n+    using propagate_on_container_swap = std::true_type; // to avoid the undefined behavior\n+\n+    /**\n+     * Move and swap have to propagate the allocator, so for consistency we do the same for copy\n+     * assignment.\n+     */\n+    using propagate_on_container_copy_assignment = std::true_type;\n+\n+    /**\n+     * Construct a new Allocator object which will delegate all allocations/deallocations to the\n+     * memory resource.\n+     */\n+    explicit Allocator(MemoryResource<ALLOCATION_SIZE_BYTES>* memory_resource) noexcept\n+        : m_memory_resource(memory_resource)\n+    {\n+    }\n+\n+    /**\n+     * Conversion constructor for rebinding. All Allocators use the same memory_resource.\n+     *\n+     * The rebound type is determined with the `struct rebind`. The rebind is necessary feature\n+     * for standard allocators, and it happens when the allocator shall be used for different types.\n+     * E.g. for std::unordered_map this happens for allocation of the internally used nodes, for the\n+     * underlying index array, and possibly for some control structure. In fact the type required by\n+     * the standard `std::pair<const Key, Value>` type is never actually used for any allocation\n+     * (which is therefore a stupid requirement, but that's just C++ being C++).\n+     */\n+    template <typename U>\n+    Allocator(const Allocator<U, ALLOCATION_SIZE_BYTES>& other) noexcept\n+        : m_memory_resource(other.m_memory_resource)\n+    {\n+    }\n+\n+    /**\n+     * From the standard: rebind is only optional (provided by std::allocator_traits) if this\n+     * allocator is a template of the form SomeAllocator<T, Args>, where Args is zero or more\n+     * additional template type parameters.\n+     *\n+     * Since we use a size_t as additional argument, it's *not* optional.\n+     * @see https://en.cppreference.com/w/cpp/named_req/Allocator#cite_note-2\n+     */\n+    template <typename U>\n+    struct rebind {\n+        using other = Allocator<U, ALLOCATION_SIZE_BYTES>;\n+    };\n+\n+    /**\n+     * Allocates n entries of the given type.\n+     */\n+    T* allocate(size_t n)\n+    {\n+        // Forward all allocations to the memory_resource\n+        return m_memory_resource->template Allocate<T>(n);\n+    }\n+\n+    /**\n+     * Deallocates n entries of the given type.\n+     */\n+    void deallocate(T* p, size_t n)\n+    {\n+        m_memory_resource->template Deallocate<T>(p, n);\n+    }\n+\n+private:\n+    //! Stateful allocator, where the state is a simple pointer that can be cheaply copied.\n+    MemoryResource<ALLOCATION_SIZE_BYTES>* m_memory_resource;\n+};\n+\n+\n+/**\n+ * Since Allocator is stateful, comparison with another one only returns true if it uses the same\n+ * memory_resource.\n+ */\n+template <typename T, typename U, size_t CS>\n+bool operator==(const Allocator<T, CS>& a, const Allocator<U, CS>& b) noexcept\n+{\n+    // \"Equality of an allocator is determined through the ability of allocating memory with one\n+    // allocator and deallocating it with another.\" - Jonathan M\u00fcller\n+    // See https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+    //\n+    // For us that is the case when both allocators use the same memory resource.\n+    return a.m_memory_resource == b.m_memory_resource;\n+}\n+\n+template <typename T, typename U, size_t CS>\n+bool operator!=(const Allocator<T, CS>& a, const Allocator<U, CS>& b) noexcept\n+{\n+    return !(a == b);\n+}\n+\n+/**\n+ * Helper to create std::unordered_map which uses the node_allocator.\n+ *\n+ * This calculates the size of the container's internally used node correctly for all supported\n+ * platforms, which is also asserted by the unit tests.\n+ */\n+template <typename Key, typename Value, typename Hash = std::hash<Key>, typename Equals = std::equal_to<Key>>\n+class UnorderedMapFactory\n+{\n+public:\n+    static constexpr size_t ALLOCATION_SIZE_BYTES = memusage::NodeSize<std::unordered_map<Key, Value, Hash, Equals>>::Value();",
    "path": "src/support/allocators/node_allocator.h",
    "position": null,
    "original_position": 388,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "a91b6032f037ab1a26ac4baa761e809fbfeb1bdd",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Done in e2a5547f12e5da2718ba17ebac5d5aeb5a2e24d5",
    "created_at": "2021-11-07T17:47:10Z",
    "updated_at": "2021-11-07T17:47:11Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r744292648",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744292648"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r744292648"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744292648/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 388,
    "side": "RIGHT",
    "in_reply_to_id": 738584696
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744292730",
    "pull_request_review_id": 799567447,
    "id": 744292730,
    "node_id": "PRRC_kwDOABII584sXQF6",
    "diff_hunk": "@@ -0,0 +1,406 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <memory>\n+#include <new>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based\n+ * containers that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs pools of memory and uses these to carve out memory for the nodes. Nodes\n+ * that are destroyed by the Allocator are actually put back into a free list for further use. This\n+ * behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored\n+ * in-place. This typically saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with\n+ * low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but\n+ * there is no standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to\n+ * the system. Memory is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on\n+ * proximity. So freeing and malloc'ing again can become a random access pattern which can lead to\n+ * more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers.\n+ * Similar to `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages memory. Currently\n+ * it is only able to provide optimized alloc/free for a single fixed allocation size which is given\n+ * in the constructor. Only allocations that match this size will be provided from the preallocated\n+ * pools of memory; all other requests simply use ::operator new(). To get the correct node size in\n+ * all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios\n+ * in `node_allocator_tests/test_allocations_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall \u201cHow to Write a Custom Allocator\u201d\n+ *   https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer \u201cAn Allocator is a Handle to a Heap\u201d\n+ *   https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *   https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+namespace detail {\n+\n+/**\n+ * In-place linked list of the allocations, used for the free list.\n+ */\n+struct FreeList {\n+    void* next;\n+};\n+\n+/**\n+ * Calculates the required allocation size for the given type.\n+ * The memory needs to be correctly aligned and large enough for both both T and FreeList.\n+ */\n+template <typename T>\n+[[nodiscard]] constexpr size_t RequiredAllocationSizeBytes() noexcept\n+{\n+    const auto alignment_max = std::max(std::alignment_of_v<T>, std::alignment_of_v<FreeList>);\n+    const auto size_max = std::max(sizeof(T), sizeof(FreeList));\n+\n+    // find closest multiple of alignment_max that holds size_max\n+    return ((size_max + alignment_max - 1U) / alignment_max) * alignment_max;\n+}\n+\n+} // namespace detail\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It\n+ * stores a number of memory pools which are used to quickly give out memory of a fixed allocation\n+ * size. The class is purposely kept very simple. It only knows about \"Allocations\" and \"Pools\".\n+ *\n+ * - Pool: MemoryResource allocates one memory pool at a time. These pools are kept around until the\n+ * memory resource is destroyed.\n+ *\n+ * - Allocations: Node-based containers allocate one node at a time. Whenever that happens, the\n+ * MemoryResource's Allocate() gives out memory for one node. These are carved out from a previously\n+ * allocated memory pool, or from a free list if it contains entries. Whenever a node is given back\n+ * with Deallocate(), it is put into that free list.\n+ */\n+template <size_t ALLOCATION_SIZE_BYTES>\n+class MemoryResource\n+{\n+    /**\n+     * Size in bytes to allocate per pool, currently hardcoded to multiple of ALLOCATION_SIZE_BYTES\n+     * that comes closest to 256 KiB.\n+     */\n+    static constexpr size_t POOL_SIZE_BYTES = (262144 / ALLOCATION_SIZE_BYTES) * ALLOCATION_SIZE_BYTES;\n+\n+public:\n+    /**\n+     * Construct a new MemoryResource object that uses the specified allocation size to optimize for.\n+     */\n+    MemoryResource() = default;\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated pools.\n+     *\n+     * There's no Clear() method on purpose, because it would be dangerous. E.g. when calling\n+     * clear() on an unordered_map, it is not certain that all allocated nodes are given back to the\n+     * MemoryResource. Microsoft's STL still uses a control structure that might have the same size\n+     * as the nodes, and therefore needs to be kept around until the map is actually destroyed.\n+     */\n+    ~MemoryResource() = default;\n+\n+    /**\n+     * Allocates memory for n * sizeof(T). Only when n==1 and T's size matches ALLOCATION_SIZE_BYTES\n+     * the pool's memory is used. Otherwise, the allocation is forwarded to ::operator new().\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        if constexpr (ALLOCATION_SIZE_BYTES == detail::RequiredAllocationSizeBytes<T>()) {\n+            if (n != 1) {\n+                // pool is not used so forward to operator new.\n+                return static_cast<T*>(::operator new(n * sizeof(T)));\n+            }\n+\n+            if (m_free_allocations) {\n+                // we've already got data in the free list, unlink one element\n+                auto old_head = m_free_allocations;\n+                m_free_allocations = static_cast<detail::FreeList*>(m_free_allocations)->next;\n+                return static_cast<T*>(old_head);\n+            }\n+\n+            // free list is empty: get one allocation from allocated pool memory.\n+            // It makes sense to not create the fully linked list of an allocated pool up-front, for\n+            // several reasons. On the one hand, the latency is higher when we need to iterate and\n+            // update pointers for the whole pool at once. More importantly, most systems lazily\n+            // allocate data. So when we allocate a big pool of memory the memory for a page is only\n+            // actually made available to the program when it is first touched. So when we allocate\n+            // a big pool and only use very little memory from it, the total memory usage is lower\n+            // than what has been malloc'ed.\n+            if (m_untouched_memory_iterator == m_untouched_memory_end) {\n+                // slow path, only happens when a new pool needs to be allocated\n+                AllocatePool();\n+            }\n+\n+            // peel off one allocation from the untouched memory. The next pointer of in-use\n+            // elements doesn't matter until it is deallocated, only then it is used to form the\n+            // free list.\n+            const auto tmp = m_untouched_memory_iterator;\n+            m_untouched_memory_iterator = static_cast<char*>(tmp) + ALLOCATION_SIZE_BYTES;\n+            return static_cast<T*>(tmp);\n+        } else {\n+            // pool is not used so forward to operator new.\n+            return static_cast<T*>(::operator new(n * sizeof(T)));\n+        }\n+    }\n+\n+    /**\n+     * Puts p back into the free list if it was actually allocated from the memory pool.\n+     * Otherwise, simply call ::operator delete(p).\n+     */\n+    template <typename T>\n+    void Deallocate(void* p, size_t n) noexcept\n+    {\n+        if constexpr (ALLOCATION_SIZE_BYTES == detail::RequiredAllocationSizeBytes<T>()) {\n+            if (n != 1) {\n+                // allocation didn't happen with the pool\n+                ::operator delete(p);\n+                return;\n+            }\n+\n+            // put it into the linked list\n+            const auto allocation = static_cast<detail::FreeList*>(p);\n+            allocation->next = m_free_allocations;\n+            m_free_allocations = allocation;\n+        } else {\n+            // allocation didn't happen with the pool\n+            ::operator delete(p);\n+        }\n+    }\n+\n+    /**\n+     * Calculates bytes allocated by the memory resource.\n+     */\n+    [[nodiscard]] size_t DynamicMemoryUsage() const noexcept\n+    {\n+        return memusage::MallocUsage(POOL_SIZE_BYTES) * m_allocated_pools.size() + memusage::DynamicUsage(m_allocated_pools);\n+    }\n+\n+private:\n+    //! Access to internals for testing purpose only\n+    friend class MemoryResourceTester;\n+\n+    /**\n+     * Allocate one full memory pool which is used to carve out allocations.\n+     */\n+    void AllocatePool()\n+    {\n+        m_allocated_pools.emplace_back(new char[POOL_SIZE_BYTES]);\n+        m_untouched_memory_iterator = m_allocated_pools.back().get();\n+        m_untouched_memory_end = m_allocated_pools.back().get() + POOL_SIZE_BYTES;\n+    }\n+\n+    //! Contains all allocated pools of memory, used to free the data in the destructor.\n+    std::vector<std::unique_ptr<char[]>> m_allocated_pools{};\n+\n+    //! A single linked list of all data available in the MemoryResource. This list is used for\n+    //! allocations of single elements.\n+    void* m_free_allocations = nullptr;\n+\n+    //! Points to the beginning of available memory for carving out allocations.\n+    void* m_untouched_memory_iterator = nullptr;\n+\n+    //! Points to the end of available memory for carving out allocations.\n+    void* m_untouched_memory_end = nullptr;\n+};\n+\n+\n+/**\n+ * Allocator that's usable for node-based containers like std::unordered_map or std::list.\n+ *\n+ * The allocator is stateful, and can be cheaply copied. Its state is an immobile MemoryResource,\n+ * which actually does all the allocation/deallocations. So this class is just a simple wrapper that\n+ * conforms to the required STL interface to be usable for the node-based containers.\n+ */\n+template <typename T, size_t ALLOCATION_SIZE_BYTES>\n+class Allocator\n+{\n+    template <typename U, size_t AS>\n+    friend class Allocator;\n+\n+    template <typename X, typename Y, size_t AS>\n+    friend bool operator==(const Allocator<X, AS>& a, const Allocator<Y, AS>& b) noexcept;\n+\n+public:\n+    using value_type = T;\n+\n+    /**\n+     * The allocator is stateful so we can't use the compile time `is_always_equal` optimization and\n+     * have to use the runtime operator==.\n+     */\n+    using is_always_equal = std::false_type;\n+\n+    /**\n+     * Move assignment should be a fast operation. In the case of a = std::move(b), we want\n+     * a to be able to use b's allocator, otherwise all elements would have to be recreated with a's\n+     * old allocator.\n+     */\n+    using propagate_on_container_move_assignment = std::true_type;\n+\n+    /**\n+     * Swapping two containers with unequal allocators who are *not* propagated is undefined\n+     * behavior. Unfortunately this is the default! Obviously, we don't want that.",
    "path": "src/support/allocators/node_allocator.h",
    "position": null,
    "original_position": 286,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "a91b6032f037ab1a26ac4baa761e809fbfeb1bdd",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "changed in e2a5547f12e5da2718ba17ebac5d5aeb5a2e24d5",
    "created_at": "2021-11-07T17:47:42Z",
    "updated_at": "2021-11-07T17:47:42Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r744292730",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744292730"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r744292730"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744292730/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": 285,
    "start_side": "RIGHT",
    "line": null,
    "original_line": 286,
    "side": "RIGHT",
    "in_reply_to_id": 738591542
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744292887",
    "pull_request_review_id": 799567557,
    "id": 744292887,
    "node_id": "PRRC_kwDOABII584sXQIX",
    "diff_hunk": "@@ -0,0 +1,424 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <support/allocators/node_allocator.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <list>\n+#include <map>\n+#include <string>\n+#include <type_traits>\n+#include <unordered_map>\n+\n+namespace node_allocator {\n+\n+class MemoryResourceTester\n+{\n+public:\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static size_t NumFreeAllocations(\n+        MemoryResource<ALLOCATION_SIZE_BYTES> const& mr) noexcept\n+    {\n+        size_t length = 0;\n+        auto allocation = mr.m_free_allocations;\n+        while (allocation) {\n+            allocation = static_cast<detail::FreeList const*>(allocation)->next;\n+            ++length;\n+        }\n+        return length;\n+    }\n+\n+    /**\n+     * Number of memory pools that have been allocated\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static size_t NumPools(MemoryResource<ALLOCATION_SIZE_BYTES> const& mr) noexcept\n+    {\n+        return mr.m_allocated_pools.size();\n+    }\n+\n+\n+    /**\n+     * Extracts allocation size from the type\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static constexpr size_t AllocationSizeBytes(MemoryResource<ALLOCATION_SIZE_BYTES> const&) noexcept\n+    {\n+        return ALLOCATION_SIZE_BYTES;\n+    }\n+};\n+\n+} // namespace node_allocator\n+\n+BOOST_FIXTURE_TEST_SUITE(node_allocator_tests, BasicTestingSetup)\n+\n+#define CHECK_MEMORY_RESOURCE(mr, num_free_allocations, num_pools)                   \\\n+    BOOST_CHECK_EQUAL(num_free_allocations,                                          \\\n+                      node_allocator::MemoryResourceTester::NumFreeAllocations(mr)); \\\n+    BOOST_CHECK_EQUAL(num_pools, node_allocator::MemoryResourceTester::NumPools(mr));\n+\n+#define CHECK_IN_RANGE(what, lowerInclusive, upperInclusive) \\",
    "path": "src/test/node_allocator_tests.cpp",
    "position": null,
    "original_position": 67,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "a91b6032f037ab1a26ac4baa761e809fbfeb1bdd",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "done in e2a5547f12e5da2718ba17ebac5d5aeb5a2e24d5",
    "created_at": "2021-11-07T17:49:05Z",
    "updated_at": "2021-11-07T17:49:05Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r744292887",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744292887"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r744292887"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744292887/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 67,
    "side": "RIGHT",
    "in_reply_to_id": 738609379
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744292960",
    "pull_request_review_id": 799567604,
    "id": 744292960,
    "node_id": "PRRC_kwDOABII584sXQJg",
    "diff_hunk": "@@ -0,0 +1,424 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <support/allocators/node_allocator.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <list>\n+#include <map>\n+#include <string>\n+#include <type_traits>\n+#include <unordered_map>\n+\n+namespace node_allocator {\n+\n+class MemoryResourceTester\n+{\n+public:\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static size_t NumFreeAllocations(\n+        MemoryResource<ALLOCATION_SIZE_BYTES> const& mr) noexcept\n+    {\n+        size_t length = 0;\n+        auto allocation = mr.m_free_allocations;\n+        while (allocation) {\n+            allocation = static_cast<detail::FreeList const*>(allocation)->next;\n+            ++length;\n+        }\n+        return length;\n+    }\n+\n+    /**\n+     * Number of memory pools that have been allocated\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static size_t NumPools(MemoryResource<ALLOCATION_SIZE_BYTES> const& mr) noexcept\n+    {\n+        return mr.m_allocated_pools.size();\n+    }\n+\n+\n+    /**\n+     * Extracts allocation size from the type\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static constexpr size_t AllocationSizeBytes(MemoryResource<ALLOCATION_SIZE_BYTES> const&) noexcept\n+    {\n+        return ALLOCATION_SIZE_BYTES;\n+    }\n+};\n+\n+} // namespace node_allocator\n+\n+BOOST_FIXTURE_TEST_SUITE(node_allocator_tests, BasicTestingSetup)\n+\n+#define CHECK_MEMORY_RESOURCE(mr, num_free_allocations, num_pools)                   \\",
    "path": "src/test/node_allocator_tests.cpp",
    "position": null,
    "original_position": 62,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "a91b6032f037ab1a26ac4baa761e809fbfeb1bdd",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "done in e2a5547f12e5da2718ba17ebac5d5aeb5a2e24d5",
    "created_at": "2021-11-07T17:49:42Z",
    "updated_at": "2021-11-07T17:49:42Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r744292960",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744292960"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r744292960"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744292960/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 62,
    "side": "RIGHT",
    "in_reply_to_id": 738611918
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744293033",
    "pull_request_review_id": 799567641,
    "id": 744293033,
    "node_id": "PRRC_kwDOABII584sXQKp",
    "diff_hunk": "@@ -0,0 +1,424 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <support/allocators/node_allocator.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <list>\n+#include <map>\n+#include <string>\n+#include <type_traits>\n+#include <unordered_map>\n+\n+namespace node_allocator {\n+\n+class MemoryResourceTester\n+{\n+public:\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static size_t NumFreeAllocations(\n+        MemoryResource<ALLOCATION_SIZE_BYTES> const& mr) noexcept\n+    {\n+        size_t length = 0;\n+        auto allocation = mr.m_free_allocations;\n+        while (allocation) {\n+            allocation = static_cast<detail::FreeList const*>(allocation)->next;\n+            ++length;\n+        }\n+        return length;\n+    }\n+\n+    /**\n+     * Number of memory pools that have been allocated\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static size_t NumPools(MemoryResource<ALLOCATION_SIZE_BYTES> const& mr) noexcept\n+    {\n+        return mr.m_allocated_pools.size();\n+    }\n+\n+\n+    /**\n+     * Extracts allocation size from the type\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static constexpr size_t AllocationSizeBytes(MemoryResource<ALLOCATION_SIZE_BYTES> const&) noexcept\n+    {\n+        return ALLOCATION_SIZE_BYTES;\n+    }\n+};\n+\n+} // namespace node_allocator\n+\n+BOOST_FIXTURE_TEST_SUITE(node_allocator_tests, BasicTestingSetup)\n+\n+#define CHECK_MEMORY_RESOURCE(mr, num_free_allocations, num_pools)                   \\\n+    BOOST_CHECK_EQUAL(num_free_allocations,                                          \\\n+                      node_allocator::MemoryResourceTester::NumFreeAllocations(mr)); \\\n+    BOOST_CHECK_EQUAL(num_pools, node_allocator::MemoryResourceTester::NumPools(mr));\n+\n+#define CHECK_IN_RANGE(what, lowerInclusive, upperInclusive) \\\n+    BOOST_TEST(what >= lowerInclusive);                      \\\n+    BOOST_TEST(what <= upperInclusive);\n+\n+BOOST_AUTO_TEST_CASE(too_small)\n+{\n+    node_allocator::MemoryResource<sizeof(void*)> mr{};\n+    void* ptr{mr.Allocate<char>(1)};\n+    BOOST_CHECK(ptr != nullptr);\n+\n+    // mr is used\n+    CHECK_MEMORY_RESOURCE(mr, 0, 1);\n+    mr.Deallocate<char>(ptr, 1);\n+    CHECK_MEMORY_RESOURCE(mr, 1, 1);\n+\n+    // void* works too, use freelist\n+    ptr = mr.Allocate<void*>(1);\n+    BOOST_CHECK(ptr != nullptr);\n+    CHECK_MEMORY_RESOURCE(mr, 0, 1);\n+    mr.Deallocate<char>(ptr, 1);\n+    CHECK_MEMORY_RESOURCE(mr, 1, 1);\n+}\n+\n+BOOST_AUTO_TEST_CASE(std_unordered_map)\n+{\n+    using Factory = node_allocator::UnorderedMapFactory<uint64_t, uint64_t>;\n+\n+    Factory::MemoryResourceType mr{};\n+    auto m = Factory::CreateContainer(&mr);\n+    size_t num_free_allocations = 0;\n+    {\n+        auto a = Factory::CreateContainer(&mr);\n+\n+        // Allocator compares equal because the same memory resource is used\n+        BOOST_CHECK(a.get_allocator() == m.get_allocator());\n+        for (uint64_t i = 0; i < 1000; ++i) {\n+            a[i] = i;\n+        }\n+\n+        num_free_allocations = node_allocator::MemoryResourceTester::NumFreeAllocations(mr);\n+\n+        // create a copy of the map, destroy the map => now a lot more free allocations should be\n+        // available\n+        {\n+            auto b = a;\n+        }\n+\n+        BOOST_CHECK(node_allocator::MemoryResourceTester::NumFreeAllocations(mr) >\n+                    num_free_allocations);",
    "path": "src/test/node_allocator_tests.cpp",
    "position": null,
    "original_position": 115,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "a91b6032f037ab1a26ac4baa761e809fbfeb1bdd",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "stricter check in e2a5547f12e5da2718ba17ebac5d5aeb5a2e24d5",
    "created_at": "2021-11-07T17:50:15Z",
    "updated_at": "2021-11-07T17:50:15Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r744293033",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744293033"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r744293033"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744293033/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": 114,
    "start_side": "RIGHT",
    "line": null,
    "original_line": 115,
    "side": "RIGHT",
    "in_reply_to_id": 738629705
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744293137",
    "pull_request_review_id": 799567713,
    "id": 744293137,
    "node_id": "PRRC_kwDOABII584sXQMR",
    "diff_hunk": "@@ -0,0 +1,424 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <support/allocators/node_allocator.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <list>\n+#include <map>\n+#include <string>\n+#include <type_traits>\n+#include <unordered_map>\n+\n+namespace node_allocator {\n+\n+class MemoryResourceTester\n+{\n+public:\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static size_t NumFreeAllocations(\n+        MemoryResource<ALLOCATION_SIZE_BYTES> const& mr) noexcept\n+    {\n+        size_t length = 0;\n+        auto allocation = mr.m_free_allocations;\n+        while (allocation) {\n+            allocation = static_cast<detail::FreeList const*>(allocation)->next;\n+            ++length;\n+        }\n+        return length;\n+    }\n+\n+    /**\n+     * Number of memory pools that have been allocated\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static size_t NumPools(MemoryResource<ALLOCATION_SIZE_BYTES> const& mr) noexcept\n+    {\n+        return mr.m_allocated_pools.size();\n+    }\n+\n+\n+    /**\n+     * Extracts allocation size from the type\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static constexpr size_t AllocationSizeBytes(MemoryResource<ALLOCATION_SIZE_BYTES> const&) noexcept\n+    {\n+        return ALLOCATION_SIZE_BYTES;\n+    }\n+};\n+\n+} // namespace node_allocator\n+\n+BOOST_FIXTURE_TEST_SUITE(node_allocator_tests, BasicTestingSetup)\n+\n+#define CHECK_MEMORY_RESOURCE(mr, num_free_allocations, num_pools)                   \\\n+    BOOST_CHECK_EQUAL(num_free_allocations,                                          \\\n+                      node_allocator::MemoryResourceTester::NumFreeAllocations(mr)); \\\n+    BOOST_CHECK_EQUAL(num_pools, node_allocator::MemoryResourceTester::NumPools(mr));\n+\n+#define CHECK_IN_RANGE(what, lowerInclusive, upperInclusive) \\\n+    BOOST_TEST(what >= lowerInclusive);                      \\\n+    BOOST_TEST(what <= upperInclusive);\n+\n+BOOST_AUTO_TEST_CASE(too_small)\n+{\n+    node_allocator::MemoryResource<sizeof(void*)> mr{};\n+    void* ptr{mr.Allocate<char>(1)};\n+    BOOST_CHECK(ptr != nullptr);\n+\n+    // mr is used\n+    CHECK_MEMORY_RESOURCE(mr, 0, 1);\n+    mr.Deallocate<char>(ptr, 1);\n+    CHECK_MEMORY_RESOURCE(mr, 1, 1);\n+\n+    // void* works too, use freelist\n+    ptr = mr.Allocate<void*>(1);\n+    BOOST_CHECK(ptr != nullptr);\n+    CHECK_MEMORY_RESOURCE(mr, 0, 1);\n+    mr.Deallocate<char>(ptr, 1);\n+    CHECK_MEMORY_RESOURCE(mr, 1, 1);\n+}\n+\n+BOOST_AUTO_TEST_CASE(std_unordered_map)\n+{\n+    using Factory = node_allocator::UnorderedMapFactory<uint64_t, uint64_t>;\n+\n+    Factory::MemoryResourceType mr{};\n+    auto m = Factory::CreateContainer(&mr);\n+    size_t num_free_allocations = 0;\n+    {\n+        auto a = Factory::CreateContainer(&mr);\n+\n+        // Allocator compares equal because the same memory resource is used\n+        BOOST_CHECK(a.get_allocator() == m.get_allocator());\n+        for (uint64_t i = 0; i < 1000; ++i) {\n+            a[i] = i;\n+        }\n+\n+        num_free_allocations = node_allocator::MemoryResourceTester::NumFreeAllocations(mr);\n+\n+        // create a copy of the map, destroy the map => now a lot more free allocations should be\n+        // available\n+        {\n+            auto b = a;\n+        }\n+\n+        BOOST_CHECK(node_allocator::MemoryResourceTester::NumFreeAllocations(mr) >\n+                    num_free_allocations);\n+        num_free_allocations = node_allocator::MemoryResourceTester::NumFreeAllocations(mr);\n+\n+        // creating another copy, and then destroying everything should reuse all the allocations\n+        {\n+            auto b = a;\n+        }\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr),\n+                          num_free_allocations);\n+\n+        // moving the map should not create new nodes\n+        m = std::move(a);\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr),\n+                          num_free_allocations);\n+    }\n+    // a is destroyed, still all allocations should stay roughly the same.\n+    BOOST_CHECK(node_allocator::MemoryResourceTester::NumFreeAllocations(mr) <=\n+                num_free_allocations + 5);\n+\n+    m = Factory::CreateContainer(&mr);\n+\n+    // now we got everything free\n+    BOOST_CHECK(node_allocator::MemoryResourceTester::NumFreeAllocations(mr) >\n+                num_free_allocations + 50);\n+}\n+\n+BOOST_AUTO_TEST_CASE(different_memoryresource_assignment)\n+{\n+    using Factory = node_allocator::UnorderedMapFactory<uint64_t, uint64_t>;\n+\n+    Factory::MemoryResourceType mr_a{};\n+    Factory::MemoryResourceType mr_b{};\n+\n+    {\n+        auto map_a = Factory::CreateContainer(&mr_a);\n+        for (int i = 0; i < 100; ++i) {\n+            map_a[i] = i;\n+        }\n+\n+        {\n+            auto map_b = Factory::CreateContainer(&mr_b);\n+            map_b[123] = 321;\n+            BOOST_CHECK(map_a.get_allocator() != map_b.get_allocator());\n+            BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 0);\n+            BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumPools(mr_b), 1);\n+\n+            map_b = map_a;\n+\n+            // map_a now uses mr_b, since propagate_on_container_copy_assignment is std::true_type\n+            BOOST_CHECK(map_a.get_allocator() == map_b.get_allocator());\n+            CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 1U, 2U);\n+            BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumPools(mr_b), 1);\n+\n+            // map_b was now recreated with data from map_a, using mr_a as the memory resource.\n+        }\n+\n+        // map_b destroyed, should not have any effect on mr_b\n+        CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 1U, 2U);\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumPools(mr_b), 1);\n+        // but we'll get more free allocations in mr_a\n+        CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 100U, 101U);\n+    }\n+\n+    // finally map_a is destroyed, getting more free allocations.\n+    CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 200U, 202U);\n+}\n+\n+\n+BOOST_AUTO_TEST_CASE(different_memoryresource_move)\n+{\n+    using Factory = node_allocator::UnorderedMapFactory<uint64_t, uint64_t>;\n+\n+    Factory::MemoryResourceType mr_a{};\n+    Factory::MemoryResourceType mr_b{};\n+\n+    {\n+        auto map_a = Factory::CreateContainer(&mr_a);\n+        for (int i = 0; i < 100; ++i) {\n+            map_a[i] = i;\n+        }\n+\n+        {\n+            auto map_b = Factory::CreateContainer(&mr_b);\n+            map_b[123] = 321;\n+\n+            map_b = std::move(map_a);\n+\n+            // map_a now uses mr_b, since propagate_on_container_move_assignment is std::true_type\n+            BOOST_CHECK(map_a.get_allocator() == map_b.get_allocator());\n+            CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 1U, 2U);\n+            BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumPools(mr_b), 1);\n+\n+            // map_b was now recreated with data from map_a, using mr_a as the memory resource.\n+        }\n+\n+        // map_b destroyed, should not have any effect on mr_b.\n+        CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 1U, 2U);\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumPools(mr_b), 1);\n+        // but we'll get more free allocations in mr_a\n+        CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 100U, 101U);\n+    }\n+\n+    // finally map_a is destroyed, but since it was moved, no more free allocations.\n+    CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 100U, 102U);\n+}\n+\n+\n+BOOST_AUTO_TEST_CASE(different_memoryresource_swap)\n+{\n+    using Factory = node_allocator::UnorderedMapFactory<uint64_t, uint64_t>;\n+\n+    Factory::MemoryResourceType mr_a{};\n+    Factory::MemoryResourceType mr_b{};\n+\n+    {\n+        auto map_a = Factory::CreateContainer(&mr_a);\n+        for (int i = 0; i < 100; ++i) {\n+            map_a[i] = i;\n+        }\n+\n+        {\n+            auto map_b = Factory::CreateContainer(&mr_b);\n+            map_b[123] = 321;\n+\n+            auto alloc_a = map_a.get_allocator();\n+            auto alloc_b = map_b.get_allocator();\n+\n+            std::swap(map_a, map_b);\n+\n+            // The maps have swapped, so their allocators have swapped, too.\n+            // No additional allocations have occurred!\n+            BOOST_CHECK(map_a.get_allocator() != map_b.get_allocator());\n+            BOOST_CHECK(alloc_a == map_b.get_allocator());\n+            BOOST_CHECK(alloc_b == map_a.get_allocator());\n+        }\n+\n+        // map_b destroyed, so mr_a must have plenty of free allocations now\n+        CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 100U, 101U);\n+\n+        // nothing happened to map_a, so mr_b still has no free allocations\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 0);\n+    }\n+\n+    // finally map_a is destroyed, so we got an entry back for mr_b.\n+    CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 100U, 101U);\n+    CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 1U, 2U);\n+}\n+\n+// some structs with defined alignment and customizeable size\n+\n+namespace {\n+\n+template <size_t S>\n+struct alignas(1) A1 {\n+    char data[S];\n+};\n+\n+template <size_t S>\n+struct alignas(2) A2 {\n+    char data[S];\n+};\n+\n+template <size_t S>\n+struct alignas(4) A4 {\n+    char data[S];\n+};\n+\n+template <size_t S>\n+struct alignas(8) A8 {\n+    char data[S];\n+};\n+\n+template <size_t S>\n+struct alignas(16) A16 {\n+    char data[S];\n+};\n+\n+template <size_t S>\n+struct alignas(32) A32 {\n+    char data[S];\n+};",
    "path": "src/test/node_allocator_tests.cpp",
    "position": null,
    "original_position": 295,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "a91b6032f037ab1a26ac4baa761e809fbfeb1bdd",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "done in e2a5547f12e5da2718ba17ebac5d5aeb5a2e24d5, and renamed the struct to `AlignedSize`",
    "created_at": "2021-11-07T17:51:04Z",
    "updated_at": "2021-11-07T17:51:04Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r744293137",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744293137"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r744293137"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744293137/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": 267,
    "start_side": "RIGHT",
    "line": null,
    "original_line": 246,
    "side": "RIGHT",
    "in_reply_to_id": 738666780
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744293305",
    "pull_request_review_id": 799567812,
    "id": 744293305,
    "node_id": "PRRC_kwDOABII584sXQO5",
    "diff_hunk": "@@ -0,0 +1,424 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <support/allocators/node_allocator.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <list>\n+#include <map>\n+#include <string>\n+#include <type_traits>\n+#include <unordered_map>\n+\n+namespace node_allocator {\n+\n+class MemoryResourceTester\n+{\n+public:\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static size_t NumFreeAllocations(\n+        MemoryResource<ALLOCATION_SIZE_BYTES> const& mr) noexcept\n+    {\n+        size_t length = 0;\n+        auto allocation = mr.m_free_allocations;\n+        while (allocation) {\n+            allocation = static_cast<detail::FreeList const*>(allocation)->next;\n+            ++length;\n+        }\n+        return length;\n+    }\n+\n+    /**\n+     * Number of memory pools that have been allocated\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static size_t NumPools(MemoryResource<ALLOCATION_SIZE_BYTES> const& mr) noexcept\n+    {\n+        return mr.m_allocated_pools.size();\n+    }\n+\n+\n+    /**\n+     * Extracts allocation size from the type\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static constexpr size_t AllocationSizeBytes(MemoryResource<ALLOCATION_SIZE_BYTES> const&) noexcept\n+    {\n+        return ALLOCATION_SIZE_BYTES;\n+    }\n+};\n+\n+} // namespace node_allocator\n+\n+BOOST_FIXTURE_TEST_SUITE(node_allocator_tests, BasicTestingSetup)\n+\n+#define CHECK_MEMORY_RESOURCE(mr, num_free_allocations, num_pools)                   \\\n+    BOOST_CHECK_EQUAL(num_free_allocations,                                          \\\n+                      node_allocator::MemoryResourceTester::NumFreeAllocations(mr)); \\\n+    BOOST_CHECK_EQUAL(num_pools, node_allocator::MemoryResourceTester::NumPools(mr));\n+\n+#define CHECK_IN_RANGE(what, lowerInclusive, upperInclusive) \\\n+    BOOST_TEST(what >= lowerInclusive);                      \\\n+    BOOST_TEST(what <= upperInclusive);\n+\n+BOOST_AUTO_TEST_CASE(too_small)\n+{\n+    node_allocator::MemoryResource<sizeof(void*)> mr{};\n+    void* ptr{mr.Allocate<char>(1)};\n+    BOOST_CHECK(ptr != nullptr);\n+\n+    // mr is used\n+    CHECK_MEMORY_RESOURCE(mr, 0, 1);\n+    mr.Deallocate<char>(ptr, 1);\n+    CHECK_MEMORY_RESOURCE(mr, 1, 1);\n+\n+    // void* works too, use freelist\n+    ptr = mr.Allocate<void*>(1);\n+    BOOST_CHECK(ptr != nullptr);\n+    CHECK_MEMORY_RESOURCE(mr, 0, 1);\n+    mr.Deallocate<char>(ptr, 1);\n+    CHECK_MEMORY_RESOURCE(mr, 1, 1);\n+}\n+\n+BOOST_AUTO_TEST_CASE(std_unordered_map)\n+{\n+    using Factory = node_allocator::UnorderedMapFactory<uint64_t, uint64_t>;\n+\n+    Factory::MemoryResourceType mr{};\n+    auto m = Factory::CreateContainer(&mr);\n+    size_t num_free_allocations = 0;\n+    {\n+        auto a = Factory::CreateContainer(&mr);\n+\n+        // Allocator compares equal because the same memory resource is used\n+        BOOST_CHECK(a.get_allocator() == m.get_allocator());\n+        for (uint64_t i = 0; i < 1000; ++i) {\n+            a[i] = i;\n+        }\n+\n+        num_free_allocations = node_allocator::MemoryResourceTester::NumFreeAllocations(mr);\n+\n+        // create a copy of the map, destroy the map => now a lot more free allocations should be\n+        // available\n+        {\n+            auto b = a;\n+        }\n+\n+        BOOST_CHECK(node_allocator::MemoryResourceTester::NumFreeAllocations(mr) >\n+                    num_free_allocations);\n+        num_free_allocations = node_allocator::MemoryResourceTester::NumFreeAllocations(mr);\n+\n+        // creating another copy, and then destroying everything should reuse all the allocations\n+        {\n+            auto b = a;\n+        }\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr),\n+                          num_free_allocations);\n+\n+        // moving the map should not create new nodes\n+        m = std::move(a);\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr),\n+                          num_free_allocations);\n+    }\n+    // a is destroyed, still all allocations should stay roughly the same.\n+    BOOST_CHECK(node_allocator::MemoryResourceTester::NumFreeAllocations(mr) <=\n+                num_free_allocations + 5);\n+\n+    m = Factory::CreateContainer(&mr);\n+\n+    // now we got everything free\n+    BOOST_CHECK(node_allocator::MemoryResourceTester::NumFreeAllocations(mr) >\n+                num_free_allocations + 50);\n+}\n+\n+BOOST_AUTO_TEST_CASE(different_memoryresource_assignment)\n+{\n+    using Factory = node_allocator::UnorderedMapFactory<uint64_t, uint64_t>;\n+\n+    Factory::MemoryResourceType mr_a{};\n+    Factory::MemoryResourceType mr_b{};\n+\n+    {\n+        auto map_a = Factory::CreateContainer(&mr_a);\n+        for (int i = 0; i < 100; ++i) {\n+            map_a[i] = i;\n+        }\n+\n+        {\n+            auto map_b = Factory::CreateContainer(&mr_b);\n+            map_b[123] = 321;\n+            BOOST_CHECK(map_a.get_allocator() != map_b.get_allocator());\n+            BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 0);\n+            BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumPools(mr_b), 1);\n+\n+            map_b = map_a;\n+\n+            // map_a now uses mr_b, since propagate_on_container_copy_assignment is std::true_type\n+            BOOST_CHECK(map_a.get_allocator() == map_b.get_allocator());\n+            CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 1U, 2U);\n+            BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumPools(mr_b), 1);\n+\n+            // map_b was now recreated with data from map_a, using mr_a as the memory resource.\n+        }\n+\n+        // map_b destroyed, should not have any effect on mr_b\n+        CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 1U, 2U);\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumPools(mr_b), 1);\n+        // but we'll get more free allocations in mr_a\n+        CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 100U, 101U);\n+    }\n+\n+    // finally map_a is destroyed, getting more free allocations.\n+    CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 200U, 202U);\n+}\n+\n+\n+BOOST_AUTO_TEST_CASE(different_memoryresource_move)\n+{\n+    using Factory = node_allocator::UnorderedMapFactory<uint64_t, uint64_t>;\n+\n+    Factory::MemoryResourceType mr_a{};\n+    Factory::MemoryResourceType mr_b{};\n+\n+    {\n+        auto map_a = Factory::CreateContainer(&mr_a);\n+        for (int i = 0; i < 100; ++i) {\n+            map_a[i] = i;\n+        }\n+\n+        {\n+            auto map_b = Factory::CreateContainer(&mr_b);\n+            map_b[123] = 321;\n+\n+            map_b = std::move(map_a);\n+\n+            // map_a now uses mr_b, since propagate_on_container_move_assignment is std::true_type\n+            BOOST_CHECK(map_a.get_allocator() == map_b.get_allocator());\n+            CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 1U, 2U);\n+            BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumPools(mr_b), 1);\n+\n+            // map_b was now recreated with data from map_a, using mr_a as the memory resource.\n+        }\n+\n+        // map_b destroyed, should not have any effect on mr_b.\n+        CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 1U, 2U);\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumPools(mr_b), 1);\n+        // but we'll get more free allocations in mr_a\n+        CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 100U, 101U);\n+    }\n+\n+    // finally map_a is destroyed, but since it was moved, no more free allocations.\n+    CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 100U, 102U);\n+}\n+\n+\n+BOOST_AUTO_TEST_CASE(different_memoryresource_swap)\n+{\n+    using Factory = node_allocator::UnorderedMapFactory<uint64_t, uint64_t>;\n+\n+    Factory::MemoryResourceType mr_a{};\n+    Factory::MemoryResourceType mr_b{};\n+\n+    {\n+        auto map_a = Factory::CreateContainer(&mr_a);\n+        for (int i = 0; i < 100; ++i) {\n+            map_a[i] = i;\n+        }\n+\n+        {\n+            auto map_b = Factory::CreateContainer(&mr_b);\n+            map_b[123] = 321;\n+\n+            auto alloc_a = map_a.get_allocator();\n+            auto alloc_b = map_b.get_allocator();\n+\n+            std::swap(map_a, map_b);\n+\n+            // The maps have swapped, so their allocators have swapped, too.\n+            // No additional allocations have occurred!\n+            BOOST_CHECK(map_a.get_allocator() != map_b.get_allocator());\n+            BOOST_CHECK(alloc_a == map_b.get_allocator());\n+            BOOST_CHECK(alloc_b == map_a.get_allocator());\n+        }\n+\n+        // map_b destroyed, so mr_a must have plenty of free allocations now\n+        CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 100U, 101U);\n+\n+        // nothing happened to map_a, so mr_b still has no free allocations\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 0);\n+    }\n+\n+    // finally map_a is destroyed, so we got an entry back for mr_b.\n+    CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 100U, 101U);\n+    CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 1U, 2U);\n+}\n+\n+// some structs with defined alignment and customizeable size\n+\n+namespace {\n+\n+template <size_t S>\n+struct alignas(1) A1 {\n+    char data[S];\n+};\n+\n+template <size_t S>\n+struct alignas(2) A2 {\n+    char data[S];\n+};\n+\n+template <size_t S>\n+struct alignas(4) A4 {\n+    char data[S];\n+};\n+\n+template <size_t S>\n+struct alignas(8) A8 {\n+    char data[S];\n+};\n+\n+template <size_t S>\n+struct alignas(16) A16 {\n+    char data[S];\n+};\n+\n+template <size_t S>\n+struct alignas(32) A32 {\n+    char data[S];\n+};\n+\n+} // namespace\n+\n+BOOST_AUTO_TEST_CASE(calc_required_allocation_size)\n+{\n+    static_assert(sizeof(A1<1>) == 1U);\n+    static_assert(std::alignment_of_v<A1<1>> == 1U);\n+\n+    static_assert(sizeof(A16<1>) == 16U);\n+    static_assert(std::alignment_of_v<A16<1>> == 16U);\n+    static_assert(sizeof(A16<16>) == 16U);\n+    static_assert(std::alignment_of_v<A16<16>> == 16U);\n+    static_assert(sizeof(A16<24>) == 32U);\n+    static_assert(std::alignment_of_v<A16<24>> == 16U);\n+\n+#if UINTPTR_MAX == 0xFFFFFFFFFFFFFFFF\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A1<1>>());\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A1<7>>());\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A1<8>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A1<9>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A1<15>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A1<16>>());\n+    static_assert(24U == node_allocator::detail::RequiredAllocationSizeBytes<A1<17>>());\n+    static_assert(104U == node_allocator::detail::RequiredAllocationSizeBytes<A1<100>>());\n+\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A4<4>>());\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A4<7>>());\n+    static_assert(104U == node_allocator::detail::RequiredAllocationSizeBytes<A4<100>>());\n+    static_assert(104U == node_allocator::detail::RequiredAllocationSizeBytes<A8<100>>());\n+\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A8<1>>());\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A8<8>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A8<16>>());\n+\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A16<1>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A16<8>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A16<16>>());\n+    static_assert(32U == node_allocator::detail::RequiredAllocationSizeBytes<A16<17>>());\n+#elif UINTPTR_MAX == 0xFFFFFFFF\n+    static_assert(4U == node_allocator::detail::RequiredAllocationSizeBytes<A1<1>>());\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A1<7>>());\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A1<8>>());\n+    static_assert(12U == node_allocator::detail::RequiredAllocationSizeBytes<A1<9>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A1<15>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A1<16>>());\n+    static_assert(20U == node_allocator::detail::RequiredAllocationSizeBytes<A1<17>>());\n+    static_assert(100U == node_allocator::detail::RequiredAllocationSizeBytes<A1<100>>());\n+\n+    static_assert(4U == node_allocator::detail::RequiredAllocationSizeBytes<A4<4>>());\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A4<7>>());\n+    static_assert(100U == node_allocator::detail::RequiredAllocationSizeBytes<A4<100>>());\n+    static_assert(104U == node_allocator::detail::RequiredAllocationSizeBytes<A8<100>>());\n+\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A8<1>>());\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A8<8>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A8<16>>());\n+\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A16<1>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A16<8>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A16<16>>());\n+    static_assert(32U == node_allocator::detail::RequiredAllocationSizeBytes<A16<17>>());\n+#else\n+#error \"Invalid sizeof(void*)\"\n+#endif\n+}\n+\n+namespace {\n+\n+template <typename T>\n+struct NotNoexceptHash {\n+    size_t operator()(const T& x) const /* noexcept */ { return std::hash<T>{}(x); }\n+};\n+\n+} // namespace\n+\n+template <typename Key, typename Value, typename Hash = std::hash<Key>>\n+void TestAllocationsAreUsed()\n+{\n+    using Factory = node_allocator::UnorderedMapFactory<Key, Value, Hash>;\n+    typename Factory::MemoryResourceType mr{};\n+    BOOST_TEST_MESSAGE(\n+        strprintf(\"%u sizeof(void*), %u/%u/%u sizeof Key/Value/Pair, %u ALLOCATION_SIZE_BYTES\",\n+                  sizeof(void*), sizeof(Key), sizeof(Value), sizeof(std::pair<const Key, Value>),\n+                  node_allocator::MemoryResourceTester::AllocationSizeBytes(mr)));\n+    {\n+        auto map = Factory::CreateContainer(&mr);\n+        for (size_t i = 0; i < 5; ++i) {\n+            map[i];\n+        }\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr), 0);\n+        map.clear();\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr), 5);\n+\n+        for (size_t i = 0; i < 5; ++i) {\n+            map[i];\n+        }\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr), 0);\n+        map.clear();\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr), 5);\n+    }\n+\n+    // makes sure clear frees all allocations. With MSVC there might be an additional allocation\n+    // used for a control structure.",
    "path": "src/test/node_allocator_tests.cpp",
    "position": null,
    "original_position": 398,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "a91b6032f037ab1a26ac4baa761e809fbfeb1bdd",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Moved that comment up in e2a5547f12e5da2718ba17ebac5d5aeb5a2e24d5",
    "created_at": "2021-11-07T17:52:19Z",
    "updated_at": "2021-11-07T17:52:19Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r744293305",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744293305"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r744293305"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744293305/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": 397,
    "start_side": "RIGHT",
    "line": null,
    "original_line": 398,
    "side": "RIGHT",
    "in_reply_to_id": 738677808
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744293678",
    "pull_request_review_id": 799568073,
    "id": 744293678,
    "node_id": "PRRC_kwDOABII584sXQUu",
    "diff_hunk": "@@ -0,0 +1,424 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <support/allocators/node_allocator.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <list>\n+#include <map>\n+#include <string>\n+#include <type_traits>\n+#include <unordered_map>\n+\n+namespace node_allocator {\n+\n+class MemoryResourceTester\n+{\n+public:\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static size_t NumFreeAllocations(\n+        MemoryResource<ALLOCATION_SIZE_BYTES> const& mr) noexcept\n+    {\n+        size_t length = 0;\n+        auto allocation = mr.m_free_allocations;\n+        while (allocation) {\n+            allocation = static_cast<detail::FreeList const*>(allocation)->next;\n+            ++length;\n+        }\n+        return length;\n+    }\n+\n+    /**\n+     * Number of memory pools that have been allocated\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static size_t NumPools(MemoryResource<ALLOCATION_SIZE_BYTES> const& mr) noexcept\n+    {\n+        return mr.m_allocated_pools.size();\n+    }\n+\n+\n+    /**\n+     * Extracts allocation size from the type\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static constexpr size_t AllocationSizeBytes(MemoryResource<ALLOCATION_SIZE_BYTES> const&) noexcept\n+    {\n+        return ALLOCATION_SIZE_BYTES;\n+    }\n+};\n+\n+} // namespace node_allocator\n+\n+BOOST_FIXTURE_TEST_SUITE(node_allocator_tests, BasicTestingSetup)\n+\n+#define CHECK_MEMORY_RESOURCE(mr, num_free_allocations, num_pools)                   \\\n+    BOOST_CHECK_EQUAL(num_free_allocations,                                          \\\n+                      node_allocator::MemoryResourceTester::NumFreeAllocations(mr)); \\\n+    BOOST_CHECK_EQUAL(num_pools, node_allocator::MemoryResourceTester::NumPools(mr));\n+\n+#define CHECK_IN_RANGE(what, lowerInclusive, upperInclusive) \\\n+    BOOST_TEST(what >= lowerInclusive);                      \\\n+    BOOST_TEST(what <= upperInclusive);\n+\n+BOOST_AUTO_TEST_CASE(too_small)\n+{\n+    node_allocator::MemoryResource<sizeof(void*)> mr{};\n+    void* ptr{mr.Allocate<char>(1)};\n+    BOOST_CHECK(ptr != nullptr);\n+\n+    // mr is used\n+    CHECK_MEMORY_RESOURCE(mr, 0, 1);\n+    mr.Deallocate<char>(ptr, 1);\n+    CHECK_MEMORY_RESOURCE(mr, 1, 1);\n+\n+    // void* works too, use freelist\n+    ptr = mr.Allocate<void*>(1);\n+    BOOST_CHECK(ptr != nullptr);\n+    CHECK_MEMORY_RESOURCE(mr, 0, 1);\n+    mr.Deallocate<char>(ptr, 1);\n+    CHECK_MEMORY_RESOURCE(mr, 1, 1);\n+}\n+\n+BOOST_AUTO_TEST_CASE(std_unordered_map)\n+{\n+    using Factory = node_allocator::UnorderedMapFactory<uint64_t, uint64_t>;\n+\n+    Factory::MemoryResourceType mr{};\n+    auto m = Factory::CreateContainer(&mr);\n+    size_t num_free_allocations = 0;\n+    {\n+        auto a = Factory::CreateContainer(&mr);\n+\n+        // Allocator compares equal because the same memory resource is used\n+        BOOST_CHECK(a.get_allocator() == m.get_allocator());\n+        for (uint64_t i = 0; i < 1000; ++i) {\n+            a[i] = i;\n+        }\n+\n+        num_free_allocations = node_allocator::MemoryResourceTester::NumFreeAllocations(mr);\n+\n+        // create a copy of the map, destroy the map => now a lot more free allocations should be\n+        // available\n+        {\n+            auto b = a;\n+        }\n+\n+        BOOST_CHECK(node_allocator::MemoryResourceTester::NumFreeAllocations(mr) >\n+                    num_free_allocations);\n+        num_free_allocations = node_allocator::MemoryResourceTester::NumFreeAllocations(mr);\n+\n+        // creating another copy, and then destroying everything should reuse all the allocations\n+        {\n+            auto b = a;\n+        }\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr),\n+                          num_free_allocations);\n+\n+        // moving the map should not create new nodes\n+        m = std::move(a);\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr),\n+                          num_free_allocations);\n+    }\n+    // a is destroyed, still all allocations should stay roughly the same.\n+    BOOST_CHECK(node_allocator::MemoryResourceTester::NumFreeAllocations(mr) <=\n+                num_free_allocations + 5);\n+\n+    m = Factory::CreateContainer(&mr);\n+\n+    // now we got everything free\n+    BOOST_CHECK(node_allocator::MemoryResourceTester::NumFreeAllocations(mr) >\n+                num_free_allocations + 50);\n+}\n+\n+BOOST_AUTO_TEST_CASE(different_memoryresource_assignment)\n+{\n+    using Factory = node_allocator::UnorderedMapFactory<uint64_t, uint64_t>;\n+\n+    Factory::MemoryResourceType mr_a{};\n+    Factory::MemoryResourceType mr_b{};\n+\n+    {\n+        auto map_a = Factory::CreateContainer(&mr_a);\n+        for (int i = 0; i < 100; ++i) {\n+            map_a[i] = i;\n+        }\n+\n+        {\n+            auto map_b = Factory::CreateContainer(&mr_b);\n+            map_b[123] = 321;\n+            BOOST_CHECK(map_a.get_allocator() != map_b.get_allocator());\n+            BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 0);\n+            BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumPools(mr_b), 1);\n+\n+            map_b = map_a;\n+\n+            // map_a now uses mr_b, since propagate_on_container_copy_assignment is std::true_type\n+            BOOST_CHECK(map_a.get_allocator() == map_b.get_allocator());\n+            CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 1U, 2U);\n+            BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumPools(mr_b), 1);\n+\n+            // map_b was now recreated with data from map_a, using mr_a as the memory resource.\n+        }\n+\n+        // map_b destroyed, should not have any effect on mr_b\n+        CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 1U, 2U);\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumPools(mr_b), 1);\n+        // but we'll get more free allocations in mr_a\n+        CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 100U, 101U);\n+    }\n+\n+    // finally map_a is destroyed, getting more free allocations.\n+    CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 200U, 202U);\n+}\n+\n+\n+BOOST_AUTO_TEST_CASE(different_memoryresource_move)\n+{\n+    using Factory = node_allocator::UnorderedMapFactory<uint64_t, uint64_t>;\n+\n+    Factory::MemoryResourceType mr_a{};\n+    Factory::MemoryResourceType mr_b{};\n+\n+    {\n+        auto map_a = Factory::CreateContainer(&mr_a);\n+        for (int i = 0; i < 100; ++i) {\n+            map_a[i] = i;\n+        }\n+\n+        {\n+            auto map_b = Factory::CreateContainer(&mr_b);\n+            map_b[123] = 321;\n+\n+            map_b = std::move(map_a);\n+\n+            // map_a now uses mr_b, since propagate_on_container_move_assignment is std::true_type\n+            BOOST_CHECK(map_a.get_allocator() == map_b.get_allocator());\n+            CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 1U, 2U);\n+            BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumPools(mr_b), 1);\n+\n+            // map_b was now recreated with data from map_a, using mr_a as the memory resource.\n+        }\n+\n+        // map_b destroyed, should not have any effect on mr_b.\n+        CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 1U, 2U);\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumPools(mr_b), 1);\n+        // but we'll get more free allocations in mr_a\n+        CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 100U, 101U);\n+    }\n+\n+    // finally map_a is destroyed, but since it was moved, no more free allocations.\n+    CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 100U, 102U);\n+}\n+\n+\n+BOOST_AUTO_TEST_CASE(different_memoryresource_swap)\n+{\n+    using Factory = node_allocator::UnorderedMapFactory<uint64_t, uint64_t>;\n+\n+    Factory::MemoryResourceType mr_a{};\n+    Factory::MemoryResourceType mr_b{};\n+\n+    {\n+        auto map_a = Factory::CreateContainer(&mr_a);\n+        for (int i = 0; i < 100; ++i) {\n+            map_a[i] = i;\n+        }\n+\n+        {\n+            auto map_b = Factory::CreateContainer(&mr_b);\n+            map_b[123] = 321;\n+\n+            auto alloc_a = map_a.get_allocator();\n+            auto alloc_b = map_b.get_allocator();\n+\n+            std::swap(map_a, map_b);\n+\n+            // The maps have swapped, so their allocators have swapped, too.\n+            // No additional allocations have occurred!\n+            BOOST_CHECK(map_a.get_allocator() != map_b.get_allocator());\n+            BOOST_CHECK(alloc_a == map_b.get_allocator());\n+            BOOST_CHECK(alloc_b == map_a.get_allocator());\n+        }\n+\n+        // map_b destroyed, so mr_a must have plenty of free allocations now\n+        CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 100U, 101U);\n+\n+        // nothing happened to map_a, so mr_b still has no free allocations\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 0);\n+    }\n+\n+    // finally map_a is destroyed, so we got an entry back for mr_b.\n+    CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 100U, 101U);\n+    CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 1U, 2U);\n+}\n+\n+// some structs with defined alignment and customizeable size\n+\n+namespace {\n+\n+template <size_t S>\n+struct alignas(1) A1 {\n+    char data[S];\n+};\n+\n+template <size_t S>\n+struct alignas(2) A2 {\n+    char data[S];\n+};\n+\n+template <size_t S>\n+struct alignas(4) A4 {\n+    char data[S];\n+};\n+\n+template <size_t S>\n+struct alignas(8) A8 {\n+    char data[S];\n+};\n+\n+template <size_t S>\n+struct alignas(16) A16 {\n+    char data[S];\n+};\n+\n+template <size_t S>\n+struct alignas(32) A32 {\n+    char data[S];\n+};\n+\n+} // namespace\n+\n+BOOST_AUTO_TEST_CASE(calc_required_allocation_size)\n+{\n+    static_assert(sizeof(A1<1>) == 1U);\n+    static_assert(std::alignment_of_v<A1<1>> == 1U);\n+\n+    static_assert(sizeof(A16<1>) == 16U);\n+    static_assert(std::alignment_of_v<A16<1>> == 16U);\n+    static_assert(sizeof(A16<16>) == 16U);\n+    static_assert(std::alignment_of_v<A16<16>> == 16U);\n+    static_assert(sizeof(A16<24>) == 32U);\n+    static_assert(std::alignment_of_v<A16<24>> == 16U);\n+\n+#if UINTPTR_MAX == 0xFFFFFFFFFFFFFFFF\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A1<1>>());\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A1<7>>());\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A1<8>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A1<9>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A1<15>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A1<16>>());\n+    static_assert(24U == node_allocator::detail::RequiredAllocationSizeBytes<A1<17>>());\n+    static_assert(104U == node_allocator::detail::RequiredAllocationSizeBytes<A1<100>>());\n+\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A4<4>>());\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A4<7>>());\n+    static_assert(104U == node_allocator::detail::RequiredAllocationSizeBytes<A4<100>>());\n+    static_assert(104U == node_allocator::detail::RequiredAllocationSizeBytes<A8<100>>());\n+\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A8<1>>());\n+    static_assert(8U == node_allocator::detail::RequiredAllocationSizeBytes<A8<8>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A8<16>>());\n+\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A16<1>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A16<8>>());\n+    static_assert(16U == node_allocator::detail::RequiredAllocationSizeBytes<A16<16>>());\n+    static_assert(32U == node_allocator::detail::RequiredAllocationSizeBytes<A16<17>>());",
    "path": "src/test/node_allocator_tests.cpp",
    "position": null,
    "original_position": 333,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "a91b6032f037ab1a26ac4baa761e809fbfeb1bdd",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "deduplicated in e2a5547f12e5da2718ba17ebac5d5aeb5a2e24d5. Also I have added a\r\n\r\n```cpp\r\nstatic_assert(__STDCPP_DEFAULT_NEW_ALIGNMENT__ >= std::alignment_of_v<T>, \"make sure AllocatePool() aligns correctly\");\r\n```\r\nInto `Allocate`, because actually the 16 byte alignments are not allowed when the pools are not correctly aligned as well.",
    "created_at": "2021-11-07T17:55:55Z",
    "updated_at": "2021-11-07T17:55:56Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r744293678",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744293678"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r744293678"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744293678/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": 326,
    "start_side": "RIGHT",
    "line": null,
    "original_line": 333,
    "side": "RIGHT",
    "in_reply_to_id": 738672539
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744293738",
    "pull_request_review_id": 799568107,
    "id": 744293738,
    "node_id": "PRRC_kwDOABII584sXQVq",
    "diff_hunk": "@@ -0,0 +1,424 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <support/allocators/node_allocator.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <list>\n+#include <map>\n+#include <string>\n+#include <type_traits>\n+#include <unordered_map>\n+\n+namespace node_allocator {\n+\n+class MemoryResourceTester\n+{\n+public:\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static size_t NumFreeAllocations(\n+        MemoryResource<ALLOCATION_SIZE_BYTES> const& mr) noexcept\n+    {\n+        size_t length = 0;\n+        auto allocation = mr.m_free_allocations;\n+        while (allocation) {\n+            allocation = static_cast<detail::FreeList const*>(allocation)->next;\n+            ++length;\n+        }\n+        return length;\n+    }\n+\n+    /**\n+     * Number of memory pools that have been allocated\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static size_t NumPools(MemoryResource<ALLOCATION_SIZE_BYTES> const& mr) noexcept\n+    {\n+        return mr.m_allocated_pools.size();\n+    }\n+\n+\n+    /**\n+     * Extracts allocation size from the type\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static constexpr size_t AllocationSizeBytes(MemoryResource<ALLOCATION_SIZE_BYTES> const&) noexcept\n+    {\n+        return ALLOCATION_SIZE_BYTES;\n+    }\n+};\n+\n+} // namespace node_allocator\n+\n+BOOST_FIXTURE_TEST_SUITE(node_allocator_tests, BasicTestingSetup)\n+\n+#define CHECK_MEMORY_RESOURCE(mr, num_free_allocations, num_pools)                   \\\n+    BOOST_CHECK_EQUAL(num_free_allocations,                                          \\\n+                      node_allocator::MemoryResourceTester::NumFreeAllocations(mr)); \\\n+    BOOST_CHECK_EQUAL(num_pools, node_allocator::MemoryResourceTester::NumPools(mr));\n+\n+#define CHECK_IN_RANGE(what, lowerInclusive, upperInclusive) \\\n+    BOOST_TEST(what >= lowerInclusive);                      \\\n+    BOOST_TEST(what <= upperInclusive);\n+\n+BOOST_AUTO_TEST_CASE(too_small)\n+{\n+    node_allocator::MemoryResource<sizeof(void*)> mr{};\n+    void* ptr{mr.Allocate<char>(1)};\n+    BOOST_CHECK(ptr != nullptr);\n+\n+    // mr is used\n+    CHECK_MEMORY_RESOURCE(mr, 0, 1);\n+    mr.Deallocate<char>(ptr, 1);\n+    CHECK_MEMORY_RESOURCE(mr, 1, 1);\n+\n+    // void* works too, use freelist\n+    ptr = mr.Allocate<void*>(1);\n+    BOOST_CHECK(ptr != nullptr);\n+    CHECK_MEMORY_RESOURCE(mr, 0, 1);\n+    mr.Deallocate<char>(ptr, 1);\n+    CHECK_MEMORY_RESOURCE(mr, 1, 1);\n+}\n+\n+BOOST_AUTO_TEST_CASE(std_unordered_map)\n+{\n+    using Factory = node_allocator::UnorderedMapFactory<uint64_t, uint64_t>;\n+\n+    Factory::MemoryResourceType mr{};\n+    auto m = Factory::CreateContainer(&mr);\n+    size_t num_free_allocations = 0;\n+    {\n+        auto a = Factory::CreateContainer(&mr);\n+\n+        // Allocator compares equal because the same memory resource is used\n+        BOOST_CHECK(a.get_allocator() == m.get_allocator());\n+        for (uint64_t i = 0; i < 1000; ++i) {\n+            a[i] = i;\n+        }\n+\n+        num_free_allocations = node_allocator::MemoryResourceTester::NumFreeAllocations(mr);\n+\n+        // create a copy of the map, destroy the map => now a lot more free allocations should be\n+        // available\n+        {\n+            auto b = a;\n+        }\n+\n+        BOOST_CHECK(node_allocator::MemoryResourceTester::NumFreeAllocations(mr) >\n+                    num_free_allocations);\n+        num_free_allocations = node_allocator::MemoryResourceTester::NumFreeAllocations(mr);\n+\n+        // creating another copy, and then destroying everything should reuse all the allocations\n+        {\n+            auto b = a;\n+        }\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr),\n+                          num_free_allocations);\n+\n+        // moving the map should not create new nodes\n+        m = std::move(a);\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr),\n+                          num_free_allocations);\n+    }\n+    // a is destroyed, still all allocations should stay roughly the same.\n+    BOOST_CHECK(node_allocator::MemoryResourceTester::NumFreeAllocations(mr) <=\n+                num_free_allocations + 5);\n+\n+    m = Factory::CreateContainer(&mr);\n+\n+    // now we got everything free\n+    BOOST_CHECK(node_allocator::MemoryResourceTester::NumFreeAllocations(mr) >\n+                num_free_allocations + 50);\n+}\n+\n+BOOST_AUTO_TEST_CASE(different_memoryresource_assignment)\n+{\n+    using Factory = node_allocator::UnorderedMapFactory<uint64_t, uint64_t>;\n+\n+    Factory::MemoryResourceType mr_a{};\n+    Factory::MemoryResourceType mr_b{};\n+\n+    {\n+        auto map_a = Factory::CreateContainer(&mr_a);\n+        for (int i = 0; i < 100; ++i) {\n+            map_a[i] = i;\n+        }\n+\n+        {\n+            auto map_b = Factory::CreateContainer(&mr_b);\n+            map_b[123] = 321;\n+            BOOST_CHECK(map_a.get_allocator() != map_b.get_allocator());\n+            BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 0);\n+            BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumPools(mr_b), 1);\n+\n+            map_b = map_a;\n+\n+            // map_a now uses mr_b, since propagate_on_container_copy_assignment is std::true_type\n+            BOOST_CHECK(map_a.get_allocator() == map_b.get_allocator());\n+            CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 1U, 2U);\n+            BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumPools(mr_b), 1);\n+\n+            // map_b was now recreated with data from map_a, using mr_a as the memory resource.\n+        }\n+\n+        // map_b destroyed, should not have any effect on mr_b\n+        CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 1U, 2U);\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumPools(mr_b), 1);\n+        // but we'll get more free allocations in mr_a\n+        CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 100U, 101U);\n+    }\n+\n+    // finally map_a is destroyed, getting more free allocations.\n+    CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 200U, 202U);\n+}\n+\n+\n+BOOST_AUTO_TEST_CASE(different_memoryresource_move)\n+{\n+    using Factory = node_allocator::UnorderedMapFactory<uint64_t, uint64_t>;\n+\n+    Factory::MemoryResourceType mr_a{};\n+    Factory::MemoryResourceType mr_b{};\n+\n+    {\n+        auto map_a = Factory::CreateContainer(&mr_a);\n+        for (int i = 0; i < 100; ++i) {\n+            map_a[i] = i;\n+        }\n+\n+        {\n+            auto map_b = Factory::CreateContainer(&mr_b);\n+            map_b[123] = 321;\n+\n+            map_b = std::move(map_a);\n+\n+            // map_a now uses mr_b, since propagate_on_container_move_assignment is std::true_type\n+            BOOST_CHECK(map_a.get_allocator() == map_b.get_allocator());\n+            CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 1U, 2U);\n+            BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumPools(mr_b), 1);\n+\n+            // map_b was now recreated with data from map_a, using mr_a as the memory resource.\n+        }\n+\n+        // map_b destroyed, should not have any effect on mr_b.\n+        CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 1U, 2U);\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumPools(mr_b), 1);\n+        // but we'll get more free allocations in mr_a\n+        CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 100U, 101U);\n+    }\n+\n+    // finally map_a is destroyed, but since it was moved, no more free allocations.\n+    CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 100U, 102U);\n+}\n+\n+\n+BOOST_AUTO_TEST_CASE(different_memoryresource_swap)",
    "path": "src/test/node_allocator_tests.cpp",
    "position": null,
    "original_position": 222,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "a91b6032f037ab1a26ac4baa761e809fbfeb1bdd",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "deduplicated in e2a5547f12e5da2718ba17ebac5d5aeb5a2e24d5",
    "created_at": "2021-11-07T17:56:23Z",
    "updated_at": "2021-11-07T17:56:23Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r744293738",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744293738"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r744293738"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744293738/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 222,
    "side": "RIGHT",
    "in_reply_to_id": 738664163
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744293834",
    "pull_request_review_id": 799568164,
    "id": 744293834,
    "node_id": "PRRC_kwDOABII584sXQXK",
    "diff_hunk": "@@ -0,0 +1,424 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <support/allocators/node_allocator.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <list>\n+#include <map>\n+#include <string>\n+#include <type_traits>\n+#include <unordered_map>\n+\n+namespace node_allocator {\n+\n+class MemoryResourceTester\n+{\n+public:\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static size_t NumFreeAllocations(\n+        MemoryResource<ALLOCATION_SIZE_BYTES> const& mr) noexcept\n+    {\n+        size_t length = 0;\n+        auto allocation = mr.m_free_allocations;\n+        while (allocation) {\n+            allocation = static_cast<detail::FreeList const*>(allocation)->next;\n+            ++length;\n+        }\n+        return length;\n+    }\n+\n+    /**\n+     * Number of memory pools that have been allocated\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static size_t NumPools(MemoryResource<ALLOCATION_SIZE_BYTES> const& mr) noexcept\n+    {\n+        return mr.m_allocated_pools.size();\n+    }\n+\n+\n+    /**\n+     * Extracts allocation size from the type\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static constexpr size_t AllocationSizeBytes(MemoryResource<ALLOCATION_SIZE_BYTES> const&) noexcept\n+    {\n+        return ALLOCATION_SIZE_BYTES;\n+    }\n+};\n+\n+} // namespace node_allocator\n+\n+BOOST_FIXTURE_TEST_SUITE(node_allocator_tests, BasicTestingSetup)\n+\n+#define CHECK_MEMORY_RESOURCE(mr, num_free_allocations, num_pools)                   \\\n+    BOOST_CHECK_EQUAL(num_free_allocations,                                          \\\n+                      node_allocator::MemoryResourceTester::NumFreeAllocations(mr)); \\\n+    BOOST_CHECK_EQUAL(num_pools, node_allocator::MemoryResourceTester::NumPools(mr));\n+\n+#define CHECK_IN_RANGE(what, lowerInclusive, upperInclusive) \\\n+    BOOST_TEST(what >= lowerInclusive);                      \\\n+    BOOST_TEST(what <= upperInclusive);\n+\n+BOOST_AUTO_TEST_CASE(too_small)\n+{\n+    node_allocator::MemoryResource<sizeof(void*)> mr{};\n+    void* ptr{mr.Allocate<char>(1)};\n+    BOOST_CHECK(ptr != nullptr);\n+\n+    // mr is used\n+    CHECK_MEMORY_RESOURCE(mr, 0, 1);\n+    mr.Deallocate<char>(ptr, 1);\n+    CHECK_MEMORY_RESOURCE(mr, 1, 1);\n+\n+    // void* works too, use freelist\n+    ptr = mr.Allocate<void*>(1);\n+    BOOST_CHECK(ptr != nullptr);\n+    CHECK_MEMORY_RESOURCE(mr, 0, 1);\n+    mr.Deallocate<char>(ptr, 1);\n+    CHECK_MEMORY_RESOURCE(mr, 1, 1);\n+}\n+\n+BOOST_AUTO_TEST_CASE(std_unordered_map)\n+{\n+    using Factory = node_allocator::UnorderedMapFactory<uint64_t, uint64_t>;\n+\n+    Factory::MemoryResourceType mr{};\n+    auto m = Factory::CreateContainer(&mr);\n+    size_t num_free_allocations = 0;\n+    {\n+        auto a = Factory::CreateContainer(&mr);\n+\n+        // Allocator compares equal because the same memory resource is used\n+        BOOST_CHECK(a.get_allocator() == m.get_allocator());\n+        for (uint64_t i = 0; i < 1000; ++i) {\n+            a[i] = i;\n+        }\n+\n+        num_free_allocations = node_allocator::MemoryResourceTester::NumFreeAllocations(mr);\n+\n+        // create a copy of the map, destroy the map => now a lot more free allocations should be\n+        // available\n+        {\n+            auto b = a;\n+        }\n+\n+        BOOST_CHECK(node_allocator::MemoryResourceTester::NumFreeAllocations(mr) >\n+                    num_free_allocations);\n+        num_free_allocations = node_allocator::MemoryResourceTester::NumFreeAllocations(mr);\n+\n+        // creating another copy, and then destroying everything should reuse all the allocations\n+        {\n+            auto b = a;\n+        }\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr),\n+                          num_free_allocations);\n+\n+        // moving the map should not create new nodes\n+        m = std::move(a);\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr),\n+                          num_free_allocations);\n+    }\n+    // a is destroyed, still all allocations should stay roughly the same.\n+    BOOST_CHECK(node_allocator::MemoryResourceTester::NumFreeAllocations(mr) <=\n+                num_free_allocations + 5);\n+\n+    m = Factory::CreateContainer(&mr);\n+\n+    // now we got everything free\n+    BOOST_CHECK(node_allocator::MemoryResourceTester::NumFreeAllocations(mr) >\n+                num_free_allocations + 50);",
    "path": "src/test/node_allocator_tests.cpp",
    "position": null,
    "original_position": 138,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "a91b6032f037ab1a26ac4baa761e809fbfeb1bdd",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "stricter in e2a5547f12e5da2718ba17ebac5d5aeb5a2e24d5",
    "created_at": "2021-11-07T17:57:07Z",
    "updated_at": "2021-11-07T17:57:08Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r744293834",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744293834"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r744293834"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/744293834/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": 137,
    "start_side": "RIGHT",
    "line": null,
    "original_line": 138,
    "side": "RIGHT",
    "in_reply_to_id": 738640412
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/748692014",
    "pull_request_review_id": 805346315,
    "id": 748692014,
    "node_id": "PRRC_kwDOABII584soCIu",
    "diff_hunk": "@@ -148,23 +154,65 @@ static inline size_t DynamicUsage(const std::shared_ptr<X>& p)\n     return p ? MallocUsage(sizeof(X)) + MallocUsage(sizeof(stl_shared_counter)) : 0;\n }\n \n-template<typename X>\n-struct unordered_node : private X\n-{\n-private:\n-    void* ptr;\n+template <typename T>\n+struct NodeSize {\n+};\n+\n+// It is important that the calculation here matches exactly the behavior of std::unordered_map\n+// so the node_allocator actually works. This is tested in node_allocator_tests/test_allocations_are_used\n+// with multiple configurations (alignments, noexcept hash, node sizes).\n+template <typename Key, typename V, typename Hash, typename Equals, typename Allocator>\n+struct NodeSize<std::unordered_map<Key, V, Hash, Equals, Allocator>> {\n+    [[nodiscard]] static constexpr size_t Value()\n+    {\n+        // libstdc++, libc++, and MSVC implement the nodes differently. To get the correct size\n+        // with the correct alignment, we can simulate that with accordingly nested std::pairs.\n+        using ValueType = std::pair<const Key, V>;\n+\n+#if defined(_MSC_VER)\n+        // list node contains 2 pointers and no hash; see\n+        // https://github.com/microsoft/STL/blob/main/stl/inc/unordered_map and\n+        // https://github.com/microsoft/STL/blob/main/stl/inc/list\n+        return sizeof(std::pair<std::pair<void*, void*>, ValueType>);\n+#else\n+\n+#if defined(_LIBCPP_VERSION) // defined in any C++ header from libc++\n+        // libc++ always stores hash and pointer in the node\n+        // see https://github.com/llvm/llvm-project/blob/release/13.x/libcxx/include/__hash_table#L92\n+        return sizeof(std::pair<ValueType, std::pair<size_t, void*>>);\n+#else\n+        // libstdc++ doesn't store hash when its operator() is noexcept;\n+        // see hashtable_policy.h, struct _Hash_node\n+        // https://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a05689.html\n+        if (noexcept(std::declval<Hash>()(std::declval<const Key&>()))) {\n+            return sizeof(std::pair<void*, ValueType>);\n+        } else {\n+            // hash is stored along ValueType, and that is wrapped with the pointer.\n+            return sizeof(std::pair<void*, std::pair<ValueType, size_t>>);\n+        }\n+#endif\n+#endif\n+    }\n };\n \n template<typename X, typename Y>\n static inline size_t DynamicUsage(const std::unordered_set<X, Y>& s)\n {\n-    return MallocUsage(sizeof(unordered_node<X>)) * s.size() + MallocUsage(sizeof(void*) * s.bucket_count());\n+    return MallocUsage(sizeof(std::pair<X, void*>)) * s.size() + MallocUsage(sizeof(void*) * s.bucket_count());\n }\n \n-template<typename X, typename Y, typename Z>\n-static inline size_t DynamicUsage(const std::unordered_map<X, Y, Z>& m)\n+template <typename Key, typename Value, typename Hash, typename Equals, typename Alloc>\n+static inline size_t DynamicUsage(const std::unordered_map<Key, Value, Hash, Equals, Alloc>& m)\n {\n-    return MallocUsage(sizeof(unordered_node<std::pair<const X, Y> >)) * m.size() + MallocUsage(sizeof(void*) * m.bucket_count());\n+    using ContainerType = std::unordered_map<Key, Value, Hash, Equals, Alloc>;\n+    if constexpr (std::is_same_v<Alloc, node_allocator::Allocator<std::pair<const Key, Value>, memusage::NodeSize<ContainerType>::Value()>>) {\n+        // Assumes that DynamicUsage of the MemoryResource is called separately. We don't do it here\n+        // because multiple maps could use the same MemoryResource.\n+        return MallocUsage(sizeof(void*) * m.bucket_count());",
    "path": "src/memusage.h",
    "position": null,
    "original_position": 80,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "a91b6032f037ab1a26ac4baa761e809fbfeb1bdd",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "I've played with this for a while now, but it doesn't work that way because in memusage.h I still need to know if the `node_allocator` is used for a container, because the node sizes are different. For the standard `std::unordered_map` I need to use `memusage::MallocUsage` for the nodes, and for `node_allocator` I have use the node size directly. So I need at least a forward declaration of `node_allocator::Allocator`. But that is fine I guess, I'll create a forward declaration then there's no circular dependency any more.\r\n\r\nAlso I'll split up `NodeSize` calculation into a separate independent file that both `memusage` and the allocator can use, so there are no circular dependency for that too.",
    "created_at": "2021-11-13T07:09:03Z",
    "updated_at": "2021-11-13T07:09:03Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r748692014",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/748692014"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r748692014"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/748692014/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": 209,
    "start_side": "RIGHT",
    "line": null,
    "original_line": 211,
    "side": "RIGHT",
    "in_reply_to_id": 737676396
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/752618528",
    "pull_request_review_id": 810445216,
    "id": 752618528,
    "node_id": "PRRC_kwDOABII584s3Awg",
    "diff_hunk": "@@ -0,0 +1,110 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <support/allocators/node_allocator/node_size.h>\n+#include <test/node_allocator_helpers.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <tuple>\n+#include <typeindex>\n+#include <unordered_map>\n+\n+namespace {\n+\n+struct AllocationInfo {\n+    AllocationInfo(size_t size) : size(size) {}\n+\n+    const size_t size{};\n+    size_t num_allocations{};\n+};\n+\n+/**\n+ * Singleton used by CountSingleAllocationsAllocator to record allocations for each type\n+ */\n+std::unordered_map<std::type_index, AllocationInfo>& SingletonAllocationInfo()\n+{\n+    static std::unordered_map<std::type_index, AllocationInfo> map{};\n+    return map;\n+}\n+\n+/**\n+ * A minimal allocator that records all n==1 allocations into SingletonAllocationInfo().\n+ * That way we can actually find out the size of the allocated nodes.\n+ */\n+template <typename T>\n+struct CountSingleAllocationsAllocator {\n+public:\n+    using value_type = T;\n+    using propagate_on_container_move_assignment = std::true_type;\n+    using is_always_equal = std::true_type;\n+\n+    CountSingleAllocationsAllocator() = default;\n+    CountSingleAllocationsAllocator(const CountSingleAllocationsAllocator&) noexcept = default;\n+\n+    template <typename U>\n+    CountSingleAllocationsAllocator(CountSingleAllocationsAllocator<U> const&) noexcept\n+    {\n+    }\n+\n+    T* allocate(size_t n)\n+    {\n+        if (n == 1) {\n+            auto [it, isInserted] = SingletonAllocationInfo().try_emplace(std::type_index(typeid(T)), sizeof(T));\n+            it->second.num_allocations += 1;\n+        }\n+        return static_cast<T*>(::operator new(n * sizeof(T)));\n+    }\n+\n+    void deallocate(T* p, size_t n)\n+    {\n+        ::operator delete(p);\n+    }\n+};\n+\n+template <typename Key, typename Value, typename Hash = std::hash<Key>>\n+void TestCorrectNodeSize()\n+{\n+    std::unordered_map<Key, Value, Hash, std::equal_to<Key>, CountSingleAllocationsAllocator<std::pair<const Key, Value>>> map;\n+\n+    SingletonAllocationInfo().clear();\n+\n+    const size_t num_entries = 123;\n+    for (size_t i = 0; i < num_entries; ++i) {\n+        map[i];\n+    }\n+\n+    // there should be a entry with exactly 123 allocations\n+    auto it = std::find_if(SingletonAllocationInfo().begin(), SingletonAllocationInfo().end(), [](const auto& kv) {",
    "path": "src/test/node_size_tests.cpp",
    "position": 80,
    "original_position": 80,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "119c3b90d6b7e9b81915a09f5ca5370f2ef1ea57",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "In commit \"Correctly calculate node size for std::unordered_map\" (119c3b90d6b7e9b81915a09f5ca5370f2ef1ea57)\r\n\r\nMight be good to replace this with a loop and verify there is exactly 1 entry with 123 allocations (and the expected size), instead of at least 1.",
    "created_at": "2021-11-18T20:55:43Z",
    "updated_at": "2021-11-22T21:51:34Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r752618528",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/752618528"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r752618528"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/752618528/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 80,
    "original_line": 80,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/754399389",
    "pull_request_review_id": 810445216,
    "id": 754399389,
    "node_id": "PRRC_kwDOABII584s9zid",
    "diff_hunk": "@@ -0,0 +1,222 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_ALLOCATOR_H\n+\n+#include <support/allocators/node_allocator/allocator_fwd.h>\n+#include <support/allocators/node_allocator/memory_resource.h>\n+\n+#include <cstdint>\n+#include <new>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based\n+ * containers that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs pools of memory and uses these to carve out memory for the nodes. Nodes\n+ * that are freed by the Allocator are actually put back into a free list for further use. This\n+ * behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored\n+ * in-place. This typically saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with\n+ * low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but\n+ * there is no standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to\n+ * the system. Memory is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on\n+ * proximity. So freeing and malloc'ing again can become a random access pattern which can lead to\n+ * more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers.\n+ * Similar to `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages memory. Currently\n+ * it is only able to provide optimized alloc/free for a single fixed allocation size which is given\n+ * in the constructor. Only allocations that match this size will be provided from the preallocated",
    "path": "src/support/allocators/node_allocator/allocator.h",
    "position": 51,
    "original_position": 51,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "96d8e33acaa079491403d8e8afa6709978dec205",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "In commit \"Add allocator for node based containers\" (96d8e33acaa079491403d8e8afa6709978dec205)\r\n\r\nWould drop \"which is given in constructor\" (no longer true)",
    "created_at": "2021-11-22T15:41:28Z",
    "updated_at": "2021-11-22T21:51:34Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r754399389",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/754399389"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r754399389"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/754399389/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": 50,
    "original_start_line": 50,
    "start_side": "RIGHT",
    "line": 51,
    "original_line": 51,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/754440401",
    "pull_request_review_id": 810445216,
    "id": 754440401,
    "node_id": "PRRC_kwDOABII584s99jR",
    "diff_hunk": "@@ -0,0 +1,360 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <support/allocators/node_allocator/factory.h>\n+#include <test/node_allocator_helpers.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <list>\n+#include <map>\n+#include <string>\n+#include <type_traits>\n+#include <unordered_map>\n+\n+namespace node_allocator {\n+\n+class MemoryResourceTester\n+{\n+public:\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static size_t NumFreeAllocations(\n+        MemoryResource<ALLOCATION_SIZE_BYTES> const& mr) noexcept\n+    {\n+        size_t length = 0;\n+        auto allocation = mr.m_free_allocations;\n+        while (allocation) {\n+            allocation = static_cast<detail::FreeList const*>(allocation)->next;\n+            ++length;\n+        }\n+        return length;\n+    }\n+\n+    /**\n+     * Number of memory pools that have been allocated\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static size_t NumPools(MemoryResource<ALLOCATION_SIZE_BYTES> const& mr) noexcept\n+    {\n+        return mr.m_allocated_pools.size();\n+    }\n+\n+\n+    /**\n+     * Extracts allocation size from the type\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static constexpr size_t AllocationSizeBytes(MemoryResource<ALLOCATION_SIZE_BYTES> const&) noexcept\n+    {\n+        return ALLOCATION_SIZE_BYTES;\n+    }\n+};\n+\n+} // namespace node_allocator\n+\n+#define CHECK_IN_RANGE(what, lower_inclusive, upper_inclusive) \\\n+    BOOST_TEST(what >= lower_inclusive);                       \\\n+    BOOST_TEST(what <= upper_inclusive);\n+\n+namespace {\n+\n+struct TwoMapsSetup {\n+    using Factory = node_allocator::Factory<std::unordered_map<uint64_t, uint64_t>>;\n+    Factory::MemoryResourceType mr_a{};\n+    Factory::MemoryResourceType mr_b{};\n+\n+    std::optional<Factory::ContainerType> map_a{};\n+    std::optional<Factory::ContainerType> map_b{};\n+\n+    TwoMapsSetup()\n+    {\n+        map_a = Factory::CreateContainer(&mr_a);\n+        for (int i = 0; i < 100; ++i) {\n+            (*map_a)[i] = i;\n+        }\n+\n+        map_b = Factory::CreateContainer(&mr_b);\n+        (*map_b)[123] = 321;\n+\n+        BOOST_CHECK(map_a->get_allocator() != map_b->get_allocator());\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 0);\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumPools(mr_b), 1);\n+    }\n+\n+    void DestroyMapBAndCheckAfterAssignment()\n+    {\n+        // map_a now uses mr_b, since propagate_on_container_copy_assignment is std::true_type\n+        BOOST_CHECK(map_a->get_allocator() == map_b->get_allocator());\n+\n+        // With MSVC there might be an additional allocation used for a control structure, so we\n+        // can't just use BOOST_CHECK_EQUAL.\n+        CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 1U, 2U);\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumPools(mr_b), 1);\n+\n+        // map_b was now recreated with data from map_a, using mr_a as the memory resource.\n+        map_b.reset();\n+\n+        // map_b destroyed, should not have any effect on mr_b\n+        CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 1U, 2U);\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumPools(mr_b), 1);\n+\n+        // but we'll get more free allocations in mr_a\n+        CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 100U, 101U);\n+    }\n+};\n+\n+template <typename Key, typename Value, typename Hash = std::hash<Key>>\n+void TestAllocationsAreUsed()\n+{\n+    using Factory = node_allocator::Factory<std::unordered_map<Key, Value, Hash>>;\n+    typename Factory::MemoryResourceType mr{};\n+    BOOST_TEST_MESSAGE(\n+        strprintf(\"%u sizeof(void*), %u/%u/%u sizeof Key/Value/Pair, %u ALLOCATION_SIZE_BYTES\",\n+                  sizeof(void*), sizeof(Key), sizeof(Value), sizeof(std::pair<const Key, Value>),\n+                  node_allocator::MemoryResourceTester::AllocationSizeBytes(mr)));\n+    {\n+        auto map = Factory::CreateContainer(&mr);\n+        for (size_t i = 0; i < 5; ++i) {\n+            map[i];\n+        }\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr), 0);\n+        map.clear();\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr), 5);\n+\n+        for (size_t i = 0; i < 5; ++i) {\n+            map[i];\n+        }\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr), 0);\n+        map.clear();\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr), 5);\n+    }\n+\n+    CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr), 5, 6);\n+}\n+\n+} // namespace\n+\n+BOOST_FIXTURE_TEST_SUITE(node_allocator_tests, BasicTestingSetup)\n+\n+#define CHECK_NUMS_FREES_POOLS(mr, num_free_allocations, num_pools)                  \\\n+    BOOST_CHECK_EQUAL(num_free_allocations,                                          \\\n+                      node_allocator::MemoryResourceTester::NumFreeAllocations(mr)); \\\n+    BOOST_CHECK_EQUAL(num_pools, node_allocator::MemoryResourceTester::NumPools(mr));\n+\n+BOOST_AUTO_TEST_CASE(too_small)",
    "path": "src/test/node_allocator_tests.cpp",
    "position": 150,
    "original_position": 150,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "96d8e33acaa079491403d8e8afa6709978dec205",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "In commit \"Add allocator for node based containers\" (96d8e33acaa079491403d8e8afa6709978dec205)\r\n\r\nPurpose of this test could be a made a little clearer with comment like \"Verify that MemoryResource specialized for a larger char pair type will do smaller single char allocations as well\"",
    "created_at": "2021-11-22T16:25:00Z",
    "updated_at": "2021-11-22T21:51:34Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r754440401",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/754440401"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r754440401"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/754440401/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 150,
    "original_line": 150,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/754441290",
    "pull_request_review_id": 810445216,
    "id": 754441290,
    "node_id": "PRRC_kwDOABII584s99xK",
    "diff_hunk": "@@ -0,0 +1,360 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <support/allocators/node_allocator/factory.h>\n+#include <test/node_allocator_helpers.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <list>\n+#include <map>\n+#include <string>\n+#include <type_traits>\n+#include <unordered_map>\n+\n+namespace node_allocator {\n+\n+class MemoryResourceTester\n+{\n+public:\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static size_t NumFreeAllocations(\n+        MemoryResource<ALLOCATION_SIZE_BYTES> const& mr) noexcept\n+    {\n+        size_t length = 0;\n+        auto allocation = mr.m_free_allocations;\n+        while (allocation) {\n+            allocation = static_cast<detail::FreeList const*>(allocation)->next;\n+            ++length;\n+        }\n+        return length;\n+    }\n+\n+    /**\n+     * Number of memory pools that have been allocated\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static size_t NumPools(MemoryResource<ALLOCATION_SIZE_BYTES> const& mr) noexcept\n+    {\n+        return mr.m_allocated_pools.size();\n+    }\n+\n+\n+    /**\n+     * Extracts allocation size from the type\n+     */\n+    template <size_t ALLOCATION_SIZE_BYTES>\n+    [[nodiscard]] static constexpr size_t AllocationSizeBytes(MemoryResource<ALLOCATION_SIZE_BYTES> const&) noexcept\n+    {\n+        return ALLOCATION_SIZE_BYTES;\n+    }\n+};\n+\n+} // namespace node_allocator\n+\n+#define CHECK_IN_RANGE(what, lower_inclusive, upper_inclusive) \\\n+    BOOST_TEST(what >= lower_inclusive);                       \\\n+    BOOST_TEST(what <= upper_inclusive);\n+\n+namespace {\n+\n+struct TwoMapsSetup {\n+    using Factory = node_allocator::Factory<std::unordered_map<uint64_t, uint64_t>>;\n+    Factory::MemoryResourceType mr_a{};\n+    Factory::MemoryResourceType mr_b{};\n+\n+    std::optional<Factory::ContainerType> map_a{};\n+    std::optional<Factory::ContainerType> map_b{};\n+\n+    TwoMapsSetup()\n+    {\n+        map_a = Factory::CreateContainer(&mr_a);\n+        for (int i = 0; i < 100; ++i) {\n+            (*map_a)[i] = i;\n+        }\n+\n+        map_b = Factory::CreateContainer(&mr_b);\n+        (*map_b)[123] = 321;\n+\n+        BOOST_CHECK(map_a->get_allocator() != map_b->get_allocator());\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 0);\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumPools(mr_b), 1);\n+    }\n+\n+    void DestroyMapBAndCheckAfterAssignment()\n+    {\n+        // map_a now uses mr_b, since propagate_on_container_copy_assignment is std::true_type\n+        BOOST_CHECK(map_a->get_allocator() == map_b->get_allocator());\n+\n+        // With MSVC there might be an additional allocation used for a control structure, so we\n+        // can't just use BOOST_CHECK_EQUAL.\n+        CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 1U, 2U);\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumPools(mr_b), 1);\n+\n+        // map_b was now recreated with data from map_a, using mr_a as the memory resource.\n+        map_b.reset();\n+\n+        // map_b destroyed, should not have any effect on mr_b\n+        CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_b), 1U, 2U);\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumPools(mr_b), 1);\n+\n+        // but we'll get more free allocations in mr_a\n+        CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr_a), 100U, 101U);\n+    }\n+};\n+\n+template <typename Key, typename Value, typename Hash = std::hash<Key>>\n+void TestAllocationsAreUsed()\n+{\n+    using Factory = node_allocator::Factory<std::unordered_map<Key, Value, Hash>>;\n+    typename Factory::MemoryResourceType mr{};\n+    BOOST_TEST_MESSAGE(\n+        strprintf(\"%u sizeof(void*), %u/%u/%u sizeof Key/Value/Pair, %u ALLOCATION_SIZE_BYTES\",\n+                  sizeof(void*), sizeof(Key), sizeof(Value), sizeof(std::pair<const Key, Value>),\n+                  node_allocator::MemoryResourceTester::AllocationSizeBytes(mr)));\n+    {\n+        auto map = Factory::CreateContainer(&mr);\n+        for (size_t i = 0; i < 5; ++i) {\n+            map[i];\n+        }\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr), 0);\n+        map.clear();\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr), 5);\n+\n+        for (size_t i = 0; i < 5; ++i) {\n+            map[i];\n+        }\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr), 0);\n+        map.clear();\n+        BOOST_CHECK_EQUAL(node_allocator::MemoryResourceTester::NumFreeAllocations(mr), 5);\n+    }\n+\n+    CHECK_IN_RANGE(node_allocator::MemoryResourceTester::NumFreeAllocations(mr), 5, 6);\n+}\n+\n+} // namespace\n+\n+BOOST_FIXTURE_TEST_SUITE(node_allocator_tests, BasicTestingSetup)\n+\n+#define CHECK_NUMS_FREES_POOLS(mr, num_free_allocations, num_pools)                  \\\n+    BOOST_CHECK_EQUAL(num_free_allocations,                                          \\\n+                      node_allocator::MemoryResourceTester::NumFreeAllocations(mr)); \\\n+    BOOST_CHECK_EQUAL(num_pools, node_allocator::MemoryResourceTester::NumPools(mr));\n+\n+BOOST_AUTO_TEST_CASE(too_small)\n+{\n+    using T = std::pair<char, char>;\n+    node_allocator::MemoryResource<node_allocator::detail::RequiredAllocationSizeBytes<T>()> mr{};\n+    void* ptr{mr.Allocate<char>()};\n+    BOOST_CHECK(ptr != nullptr);\n+\n+    // mr is used\n+    CHECK_NUMS_FREES_POOLS(mr, 0, 1);\n+    mr.Deallocate<char>(ptr);\n+    CHECK_NUMS_FREES_POOLS(mr, 1, 1);\n+\n+    // void* works too, use freelist",
    "path": "src/test/node_allocator_tests.cpp",
    "position": 162,
    "original_position": 162,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "96d8e33acaa079491403d8e8afa6709978dec205",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "In commit \"Add allocator for node based containers\" (96d8e33acaa079491403d8e8afa6709978dec205)\r\n\r\nTest is no longer using void*. Probably would just say `// freelist is used` or drop comment.",
    "created_at": "2021-11-22T16:25:55Z",
    "updated_at": "2021-11-22T21:51:34Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r754441290",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/754441290"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r754441290"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/754441290/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 162,
    "original_line": 162,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/754483868",
    "pull_request_review_id": 810445216,
    "id": 754483868,
    "node_id": "PRRC_kwDOABII584s-IKc",
    "diff_hunk": "@@ -147,8 +155,8 @@ BOOST_AUTO_TEST_CASE(getcoinscachesizestate)\n             CoinsCacheSizeState::OK);\n     }\n \n-    // Flushing the view doesn't take us back to OK because cacheCoins has\n-    // preallocated memory that doesn't get reclaimed even after flush.\n+    // Flushing the view does take us back to OK because cacheCoins' MemoryResource frees its",
    "path": "src/test/validation_flush_tests.cpp",
    "position": 80,
    "original_position": 80,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "66f745394ddfb546b9d0d29fe764110944dea158",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "In commit \"Make use of node_allocator in CCoinsMap\" (66f745394ddfb546b9d0d29fe764110944dea158)\r\n\r\nExtra punctuation here `s/cacheCoins' MemoryResource/cacheCoinsMemoryResource/`",
    "created_at": "2021-11-22T17:17:01Z",
    "updated_at": "2021-11-22T21:51:34Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r754483868",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/754483868"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r754483868"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/754483868/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 158,
    "original_line": 158,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/754518240",
    "pull_request_review_id": 810445216,
    "id": 754518240,
    "node_id": "PRRC_kwDOABII584s-Qjg",
    "diff_hunk": "@@ -0,0 +1,196 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <cstddef>\n+#include <memory>\n+#include <type_traits>\n+#include <utility>\n+#include <vector>\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_MEMORY_RESOURCE_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_MEMORY_RESOURCE_H\n+\n+namespace node_allocator {\n+\n+namespace detail {\n+\n+/**\n+ * In-place linked list of the allocations, used for the free list.\n+ */\n+struct FreeList {\n+    FreeList* next;\n+};\n+\n+static_assert(std::is_trivially_destructible_v<FreeList>, \"make sure we don't need to manually destruct the FreeList\");\n+\n+/**\n+ * Calculates the required allocation size for the given type.\n+ * The memory needs to be correctly aligned and large enough for both both T and FreeList.\n+ */\n+template <typename T>\n+[[nodiscard]] constexpr size_t RequiredAllocationSizeBytes() noexcept\n+{\n+    const auto alignment_max = std::max(std::alignment_of_v<T>, std::alignment_of_v<FreeList>);\n+    const auto size_max = std::max(sizeof(T), sizeof(FreeList));\n+\n+    // find closest multiple of alignment_max that holds size_max\n+    return ((size_max + alignment_max - 1U) / alignment_max) * alignment_max;\n+}\n+\n+/**\n+ * Calculates dynamic memory usage of a MemoryResource. Not a member of MemoryResource so we can implement this\n+ * in a cpp and don't depend on memusage.h in the header.\n+ */\n+[[nodiscard]] size_t DynamicMemoryUsage(size_t pool_size_bytes, std::vector<std::unique_ptr<char[]>> const& allocated_pools);\n+\n+} // namespace detail\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It\n+ * stores a number of memory pools which are used to quickly give out memory of a fixed allocation\n+ * size. The class is purposely kept very simple. It only knows about \"Allocations\" and \"Pools\".\n+ *\n+ * - Pool: MemoryResource allocates one memory pool at a time. These pools are kept around until the\n+ * memory resource is destroyed.\n+ *\n+ * - Allocations: Node-based containers allocate one node at a time. Whenever that happens, the\n+ * MemoryResource's Allocate() gives out memory for one node. These are carved out from a previously\n+ * allocated memory pool, or from a free list if it contains entries. Whenever a node is given back\n+ * with Deallocate(), it is put into that free list.\n+ */\n+template <size_t ALLOCATION_SIZE_BYTES>\n+class MemoryResource\n+{\n+    /**\n+     * Size in bytes to allocate per pool, currently hardcoded to multiple of ALLOCATION_SIZE_BYTES\n+     * that comes closest to 256 KiB.\n+     */\n+    static constexpr size_t POOL_SIZE_BYTES = (262144 / ALLOCATION_SIZE_BYTES) * ALLOCATION_SIZE_BYTES;\n+\n+public:\n+    /**\n+     * Construct a new MemoryResource object that uses the specified allocation size to optimize for.\n+     */\n+    MemoryResource() = default;\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated pools.\n+     *\n+     * There's no Clear() method on purpose, because it would be dangerous. E.g. when calling\n+     * clear() on an unordered_map, it is not certain that all allocated nodes are given back to the\n+     * MemoryResource. Microsoft's STL still uses a control structure that might have the same size\n+     * as the nodes, and therefore needs to be kept around until the map is actually destroyed.\n+     */\n+    ~MemoryResource() = default;\n+\n+    /**\n+     * Allocates memory for sizeof(T).\n+     *\n+     * @tparam T Object to allocate memory for.\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate()\n+    {\n+        static_assert(ALLOCATION_SIZE_BYTES == detail::RequiredAllocationSizeBytes<T>());\n+        static_assert(__STDCPP_DEFAULT_NEW_ALIGNMENT__ >= std::alignment_of_v<T>, \"make sure AllocatePool() aligns correctly\");",
    "path": "src/support/allocators/node_allocator/memory_resource.h",
    "position": 104,
    "original_position": 104,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "96d8e33acaa079491403d8e8afa6709978dec205",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "In commit \"Add allocator for node based containers\" (96d8e33acaa079491403d8e8afa6709978dec205)\r\n\r\nIt doesn't seem like this static_assert is verifying anything related to our code. It's not calling any of our own functions, just verifying a relationship between `__STDCPP_DEFAULT_NEW_ALIGNMENT__` and `std::alignment_of`. Also assert message doesn't seem to make sense. Check might make more sense inside the RequiredAllocationSizeBytes function than outside here.",
    "created_at": "2021-11-22T18:02:43Z",
    "updated_at": "2021-11-22T21:51:34Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r754518240",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/754518240"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r754518240"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/754518240/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 104,
    "original_line": 104,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/754529782",
    "pull_request_review_id": 812877929,
    "id": 754529782,
    "node_id": "PRRC_kwDOABII584s-TX2",
    "diff_hunk": "@@ -0,0 +1,27 @@\n+#ifndef BITCOIN_TEST_NODE_ALLOCATOR_HELPERS_H\n+#define BITCOIN_TEST_NODE_ALLOCATOR_HELPERS_H\n+\n+#include <cstddef>\n+#include <utility>\n+\n+/**\n+ * Wrapper around std::hash, but without noexcept. Useful for testing unordered containers\n+ * because they potentially behave differently with/without a noexcept hash.\n+ */\n+template <typename T>\n+struct NotNoexceptHash {\n+    size_t operator()(const T& x) const /* not noexcept */",
    "path": "src/test/node_allocator_helpers.h",
    "position": 13,
    "original_position": 13,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "119c3b90d6b7e9b81915a09f5ca5370f2ef1ea57",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "I'm somewhat surprised that the compiler/language doesn't automatically declare a function non-throwing if all its calls are declared to be noexcept. Are you sure that's not a risk here?",
    "created_at": "2021-11-22T18:19:48Z",
    "updated_at": "2021-11-22T21:54:49Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r754529782",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/754529782"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r754529782"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/754529782/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 13,
    "original_line": 13,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/754617015",
    "pull_request_review_id": 810445216,
    "id": 754617015,
    "node_id": "PRRC_kwDOABII584s-oq3",
    "diff_hunk": "@@ -0,0 +1,60 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_NODE_SIZE_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_NODE_SIZE_H\n+\n+#include <cstddef>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+\n+namespace node_allocator {\n+\n+/**\n+ * Calculates memory usage of nodes for different containers.\n+ */\n+template <typename T>\n+struct NodeSize;\n+\n+/**\n+ * It is important that the calculation here matches exactly the behavior of std::unordered_map\n+ * so the node_allocator actually works. This is tested in node_allocator_tests/test_allocations_are_used\n+ * with multiple configurations (alignments, noexcept hash, node sizes).\n+ */\n+template <typename Key, typename V, typename Hash, typename Equals, typename Allocator>\n+struct NodeSize<std::unordered_map<Key, V, Hash, Equals, Allocator>> {",
    "path": "src/support/allocators/node_allocator/node_size.h",
    "position": 27,
    "original_position": 27,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "119c3b90d6b7e9b81915a09f5ca5370f2ef1ea57",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "In commit \"Correctly calculate node size for std::unordered_map\" (119c3b90d6b7e9b81915a09f5ca5370f2ef1ea57)\r\n\r\nI think it would make more sense to move this class back to `src/memusage.h`, or to a new `src/memusage_nodesize.h` file, instead of making it part of `node_allocator`. This is a helper class for figuring out memory usage of a standard container, so functionally it is more related to memusage than node_allocator. Memusage needs this to function, while node_allocator::Allocator and node_allocator::MemoryResource are both usable without it. Also, In the future, we may also want to experiment with writing new allocators, and it would be nice if they could reuse this `NodeSize` class without having to reinvent it or depend on `node_allocator` themselves. Also, combined with other suggestions, moving this class out of node_allocator would allow us to break the node_allocator <-> memusage cyclic dependency and have node_allocator just depend on memusage in one direction.\r\n\r\n(Moving this class out of node_allocator could also let you split off the first two commits of this PR into their own PR so this PR could be smaller, even though I do think this PR is small enough and wouldn't see a need for that.)",
    "created_at": "2021-11-22T20:37:12Z",
    "updated_at": "2021-11-22T21:51:34Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r754617015",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/754617015"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r754617015"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/754617015/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 27,
    "original_line": 27,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/754634360",
    "pull_request_review_id": 812877929,
    "id": 754634360,
    "node_id": "PRRC_kwDOABII584s-s54",
    "diff_hunk": "@@ -0,0 +1,60 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_NODE_SIZE_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_NODE_SIZE_H\n+\n+#include <cstddef>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+\n+namespace node_allocator {\n+\n+/**\n+ * Calculates memory usage of nodes for different containers.\n+ */\n+template <typename T>\n+struct NodeSize;\n+\n+/**\n+ * It is important that the calculation here matches exactly the behavior of std::unordered_map\n+ * so the node_allocator actually works. This is tested in node_allocator_tests/test_allocations_are_used\n+ * with multiple configurations (alignments, noexcept hash, node sizes).\n+ */\n+template <typename Key, typename V, typename Hash, typename Equals, typename Allocator>\n+struct NodeSize<std::unordered_map<Key, V, Hash, Equals, Allocator>> {\n+    using ContainerType = std::unordered_map<Key, V, Hash, Equals, Allocator>;\n+    using ValueType = typename ContainerType::value_type;\n+\n+#if defined(_MSC_VER)\n+    // libstdc++, libc++, and MSVC implement the nodes differently. To get the correct size with\n+    // the correct alignment, we can simulate the memory layouts with accordingly nested std::pairs.\n+    //\n+    // list node contains 2 pointers and no hash; see\n+    // https://github.com/microsoft/STL/blob/main/stl/inc/unordered_map and\n+    // https://github.com/microsoft/STL/blob/main/stl/inc/list\n+    using SimulatedNodeType = std::pair<std::pair<void*, void*>, ValueType>;\n+#elif defined(_LIBCPP_VERSION) // defined in any C++ header from libc++\n+    // libc++ always stores hash and pointer in the node\n+    // see https://github.com/llvm/llvm-project/blob/release/13.x/libcxx/include/__hash_table#L92\n+    using SimulatedNodeType = std::pair<ValueType, std::pair<size_t, void*>>;\n+#else\n+    // libstdc++ doesn't store hash when its operator() is noexcept;\n+    // see hashtable_policy.h, struct _Hash_node\n+    // https://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a05689.html\n+    using SimulatedNodeType = std::conditional_t<noexcept(std::declval<Hash>()(std::declval<const Key&>())),\n+                                                 std::pair<void*, ValueType>,                     // no hash stored\n+                                                 std::pair<void*, std::pair<ValueType, size_t>>>; // hash stored along ValueType, and that is wrapped with the pointer.\n+#endif\n+\n+    [[nodiscard]] static constexpr size_t Value()",
    "path": "src/support/allocators/node_allocator/node_size.h",
    "position": 52,
    "original_position": 52,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "119c3b90d6b7e9b81915a09f5ca5370f2ef1ea57",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Nit: I think with C++17, this can be a constexpr static member variable, rather than a function (`static constexpr size_t VALUE = sizeof(SimulatedNodeType);`).",
    "created_at": "2021-11-22T21:05:52Z",
    "updated_at": "2021-11-22T21:54:50Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r754634360",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/754634360"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r754634360"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/754634360/reactions",
      "total_count": 1,
      "+1": 1,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 52,
    "original_line": 52,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/754650139",
    "pull_request_review_id": 810445216,
    "id": 754650139,
    "node_id": "PRRC_kwDOABII584s-wwb",
    "diff_hunk": "@@ -169,6 +170,14 @@ static inline size_t DynamicUsage(const std::unordered_map<Key, Value, Hash, Equ\n     return MallocUsage(node_size) * m.size() + MallocUsage(sizeof(void*) * m.bucket_count());\n }\n \n+template <typename Key, typename Value, typename Hash, typename Equals, typename AllocT, size_t AllocS>\n+static inline size_t DynamicUsage(const std::unordered_map<Key, Value, Hash, Equals, node_allocator::Allocator<AllocT, AllocS>>& m)\n+{\n+    // Since node_allocator is used, the memory of the nodes are the MemoryResource's responsibility and\n+    // won't be added here. Also multiple maps could use the same MemoryResource.\n+    return MallocUsage(sizeof(void*) * m.bucket_count());",
    "path": "src/memusage.h",
    "position": 28,
    "original_position": 17,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "96d8e33acaa079491403d8e8afa6709978dec205",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "In commit \"Add allocator for node based containers\" (96d8e33acaa079491403d8e8afa6709978dec205)\r\n\r\nI still think it's unfortunate to be adding this `memusage` specialization when it is not necessary. I don't like how it:\r\n\r\n- Makes memusage.h depend node_allocator, when the job of memusage is just to tell us about memory usage of standard types, and it shouldn't need to be referencing a particular specialized allocator.\r\n- Redefines the concept of memory usage for this one unordered_map+node_allocator container to not consider memory allocated by the container to be \"used\" by the container, even though the container allocated that memory, and is still responsible for deallocating (if not freeing) it.\r\n- Will require new specializations of map+node_allocator or list+node_allocator to be added here if node_allocator is used with other map or list containers in the future.\r\n\r\nI think code can be simpler, definition of \"usage\" can be more consistent, and cyclic dependencies and special cases can be removed using earlier suggestions from https://github.com/bitcoin/bitcoin/pull/22702#discussion_r737676396, and only downside would be adding a counter variable. On top of the current PR, changes would look like:\r\n\r\n\r\n<details><summary>Diff</summary><p>\r\n\r\n```diff\r\ndiff --git a/src/Makefile.am b/src/Makefile.am\r\nindex b39d03fe8cb..9d09682e243 100644\r\n--- a/src/Makefile.am\r\n+++ b/src/Makefile.am\r\n@@ -217,7 +217,6 @@ BITCOIN_CORE_H = \\\r\n   shutdown.h \\\r\n   signet.h \\\r\n   streams.h \\\r\n-  support/allocators/node_allocator/allocator_fwd.h \\\r\n   support/allocators/node_allocator/allocator.h \\\r\n   support/allocators/node_allocator/factory.h \\\r\n   support/allocators/node_allocator/memory_resource.h \\\r\n@@ -575,7 +574,6 @@ libbitcoin_util_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\r\n libbitcoin_util_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\r\n libbitcoin_util_a_SOURCES = \\\r\n   support/lockedpool.cpp \\\r\n-  support/allocators/node_allocator/memory_resource.cpp \\\r\n   chainparamsbase.cpp \\\r\n   clientversion.cpp \\\r\n   compat/glibcxx_sanity.cpp \\\r\ndiff --git a/src/memusage.h b/src/memusage.h\r\nindex bc20ee4052c..b9faff9b2d9 100644\r\n--- a/src/memusage.h\r\n+++ b/src/memusage.h\r\n@@ -7,7 +7,6 @@\r\n \r\n #include <indirectmap.h>\r\n #include <prevector.h>\r\n-#include <support/allocators/node_allocator/allocator_fwd.h>\r\n #include <support/allocators/node_allocator/node_size.h>\r\n \r\n #include <stdlib.h>\r\n@@ -163,21 +162,13 @@ static inline size_t DynamicUsage(const std::unordered_set<X, Y>& s)\r\n     return MallocUsage(sizeof(unordered_node<X>)) * s.size() + MallocUsage(sizeof(void*) * s.bucket_count());\r\n }\r\n \r\n-template <typename Key, typename Value, typename Hash, typename Equals>\r\n-static inline size_t DynamicUsage(const std::unordered_map<Key, Value, Hash, Equals>& m)\r\n+template <typename Key, typename Value, typename Hash, typename Equals, typename Alloc>\r\n+static inline size_t DynamicUsage(const std::unordered_map<Key, Value, Hash, Equals, Alloc>& m)\r\n {\r\n-    auto node_size = node_allocator::NodeSize<std::unordered_map<Key, Value, Hash, Equals>>::Value();\r\n+    auto node_size = node_allocator::NodeSize<std::unordered_map<Key, Value, Hash, Equals, Alloc>>::Value();\r\n     return MallocUsage(node_size) * m.size() + MallocUsage(sizeof(void*) * m.bucket_count());\r\n }\r\n \r\n-template <typename Key, typename Value, typename Hash, typename Equals, typename AllocT, size_t AllocS>\r\n-static inline size_t DynamicUsage(const std::unordered_map<Key, Value, Hash, Equals, node_allocator::Allocator<AllocT, AllocS>>& m)\r\n-{\r\n-    // Since node_allocator is used, the memory of the nodes are the MemoryResource's responsibility and\r\n-    // won't be added here. Also multiple maps could use the same MemoryResource.\r\n-    return MallocUsage(sizeof(void*) * m.bucket_count());\r\n-}\r\n-\r\n }\r\n \r\n #endif // BITCOIN_MEMUSAGE_H\r\ndiff --git a/src/support/allocators/node_allocator/allocator.h b/src/support/allocators/node_allocator/allocator.h\r\nindex 778471bb20b..c728ab8638a 100644\r\n--- a/src/support/allocators/node_allocator/allocator.h\r\n+++ b/src/support/allocators/node_allocator/allocator.h\r\n@@ -5,7 +5,6 @@\r\n #ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_ALLOCATOR_H\r\n #define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_ALLOCATOR_H\r\n \r\n-#include <support/allocators/node_allocator/allocator_fwd.h>\r\n #include <support/allocators/node_allocator/memory_resource.h>\r\n \r\n #include <cstdint>\r\ndiff --git a/src/support/allocators/node_allocator/allocator_fwd.h b/src/support/allocators/node_allocator/allocator_fwd.h\r\ndeleted file mode 100644\r\nindex e3fa0ddd889..00000000000\r\n--- a/src/support/allocators/node_allocator/allocator_fwd.h\r\n+++ /dev/null\r\n@@ -1,17 +0,0 @@\r\n-// Copyright (c) 2021 The Bitcoin Core developers\r\n-// Distributed under the MIT software license, see the accompanying\r\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\r\n-\r\n-#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_ALLOCATOR_FWD_H\r\n-#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_ALLOCATOR_FWD_H\r\n-\r\n-#include <cstddef>\r\n-\r\n-namespace node_allocator {\r\n-\r\n-template <typename T, size_t ALLOCATION_SIZE_BYTES>\r\n-class Allocator;\r\n-\r\n-} // namespace node_allocator\r\n-\r\n-#endif // BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_ALLOCATOR_FWD_H\r\ndiff --git a/src/support/allocators/node_allocator/memory_resource.cpp b/src/support/allocators/node_allocator/memory_resource.cpp\r\ndeleted file mode 100644\r\nindex 368752fa2b9..00000000000\r\n--- a/src/support/allocators/node_allocator/memory_resource.cpp\r\n+++ /dev/null\r\n@@ -1,12 +0,0 @@\r\n-#include <support/allocators/node_allocator/memory_resource.h>\r\n-\r\n-#include <memusage.h>\r\n-\r\n-namespace node_allocator::detail {\r\n-\r\n-size_t DynamicMemoryUsage(size_t pool_size_bytes, std::vector<std::unique_ptr<char[]>> const& allocated_pools)\r\n-{\r\n-    return memusage::MallocUsage(pool_size_bytes) * allocated_pools.size() + memusage::DynamicUsage(allocated_pools);\r\n-}\r\n-\r\n-} // namespace node_allocator::detail\r\ndiff --git a/src/support/allocators/node_allocator/memory_resource.h b/src/support/allocators/node_allocator/memory_resource.h\r\nindex f4ba0138924..e60e847c86d 100644\r\n--- a/src/support/allocators/node_allocator/memory_resource.h\r\n+++ b/src/support/allocators/node_allocator/memory_resource.h\r\n@@ -8,6 +8,8 @@\r\n #include <utility>\r\n #include <vector>\r\n \r\n+#include <memusage.h>\r\n+\r\n #ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_MEMORY_RESOURCE_H\r\n #define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_MEMORY_RESOURCE_H\r\n \r\n@@ -38,12 +40,6 @@ template <typename T>\r\n     return ((size_max + alignment_max - 1U) / alignment_max) * alignment_max;\r\n }\r\n \r\n-/**\r\n- * Calculates dynamic memory usage of a MemoryResource. Not a member of MemoryResource so we can implement this\r\n- * in a cpp and don't depend on memusage.h in the header.\r\n- */\r\n-[[nodiscard]] size_t DynamicMemoryUsage(size_t pool_size_bytes, std::vector<std::unique_ptr<char[]>> const& allocated_pools);\r\n-\r\n } // namespace detail\r\n \r\n /**\r\n@@ -102,6 +98,7 @@ public:\r\n     {\r\n         static_assert(ALLOCATION_SIZE_BYTES == detail::RequiredAllocationSizeBytes<T>());\r\n         static_assert(__STDCPP_DEFAULT_NEW_ALIGNMENT__ >= std::alignment_of_v<T>, \"make sure AllocatePool() aligns correctly\");\r\n+        ++m_allocations;\r\n \r\n         if (m_free_allocations) {\r\n             // we've already got data in the free list, unlink one element\r\n@@ -138,6 +135,7 @@ public:\r\n     void Deallocate(void* p) noexcept\r\n     {\r\n         static_assert(ALLOCATION_SIZE_BYTES == detail::RequiredAllocationSizeBytes<T>());\r\n+        --m_allocations;\r\n \r\n         // put it into the linked list.\r\n         //\r\n@@ -150,11 +148,11 @@ public:\r\n     }\r\n \r\n     /**\r\n-     * Calculates bytes allocated by the memory resource.\r\n+     * Calculates number of bytes allocated to the memory resource minus number of bytes allocated from the memory resource.\r\n      */\r\n     [[nodiscard]] size_t DynamicMemoryUsage() const noexcept\r\n     {\r\n-        return detail::DynamicMemoryUsage(POOL_SIZE_BYTES, m_allocated_pools);\r\n+        return memusage::MallocUsage(POOL_SIZE_BYTES) * m_allocated_pools.size() + memusage::DynamicUsage(m_allocated_pools) - ALLOCATION_SIZE_BYTES * m_allocations;\r\n     }\r\n \r\n private:\r\n@@ -171,6 +169,9 @@ private:\r\n         m_untouched_memory_end = m_untouched_memory_iterator + POOL_SIZE_BYTES;\r\n     }\r\n \r\n+    //! Number of current allocations.\r\n+    size_t m_allocations = 0;\r\n+\r\n     //! Contains all allocated pools of memory, used to free the data in the destructor.\r\n     std::vector<std::unique_ptr<char[]>> m_allocated_pools{};\r\n \r\n\r\n```\r\n</p></details>",
    "created_at": "2021-11-22T21:32:09Z",
    "updated_at": "2021-11-30T20:02:37Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r754650139",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/754650139"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r754650139"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/754650139/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": 176,
    "original_start_line": 176,
    "start_side": "RIGHT",
    "line": 178,
    "original_line": 178,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/756597523",
    "pull_request_review_id": 815591284,
    "id": 756597523,
    "node_id": "PRRC_kwDOABII584tGMMT",
    "diff_hunk": "@@ -0,0 +1,196 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <cstddef>\n+#include <memory>\n+#include <type_traits>\n+#include <utility>\n+#include <vector>\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_MEMORY_RESOURCE_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_MEMORY_RESOURCE_H\n+\n+namespace node_allocator {\n+\n+namespace detail {\n+\n+/**\n+ * In-place linked list of the allocations, used for the free list.\n+ */\n+struct FreeList {\n+    FreeList* next;\n+};\n+\n+static_assert(std::is_trivially_destructible_v<FreeList>, \"make sure we don't need to manually destruct the FreeList\");\n+\n+/**\n+ * Calculates the required allocation size for the given type.\n+ * The memory needs to be correctly aligned and large enough for both both T and FreeList.\n+ */\n+template <typename T>\n+[[nodiscard]] constexpr size_t RequiredAllocationSizeBytes() noexcept\n+{\n+    const auto alignment_max = std::max(std::alignment_of_v<T>, std::alignment_of_v<FreeList>);\n+    const auto size_max = std::max(sizeof(T), sizeof(FreeList));\n+\n+    // find closest multiple of alignment_max that holds size_max\n+    return ((size_max + alignment_max - 1U) / alignment_max) * alignment_max;\n+}\n+\n+/**\n+ * Calculates dynamic memory usage of a MemoryResource. Not a member of MemoryResource so we can implement this\n+ * in a cpp and don't depend on memusage.h in the header.\n+ */\n+[[nodiscard]] size_t DynamicMemoryUsage(size_t pool_size_bytes, std::vector<std::unique_ptr<char[]>> const& allocated_pools);\n+\n+} // namespace detail\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It\n+ * stores a number of memory pools which are used to quickly give out memory of a fixed allocation\n+ * size. The class is purposely kept very simple. It only knows about \"Allocations\" and \"Pools\".\n+ *\n+ * - Pool: MemoryResource allocates one memory pool at a time. These pools are kept around until the\n+ * memory resource is destroyed.\n+ *\n+ * - Allocations: Node-based containers allocate one node at a time. Whenever that happens, the\n+ * MemoryResource's Allocate() gives out memory for one node. These are carved out from a previously\n+ * allocated memory pool, or from a free list if it contains entries. Whenever a node is given back\n+ * with Deallocate(), it is put into that free list.\n+ */\n+template <size_t ALLOCATION_SIZE_BYTES>\n+class MemoryResource\n+{\n+    /**\n+     * Size in bytes to allocate per pool, currently hardcoded to multiple of ALLOCATION_SIZE_BYTES\n+     * that comes closest to 256 KiB.\n+     */\n+    static constexpr size_t POOL_SIZE_BYTES = (262144 / ALLOCATION_SIZE_BYTES) * ALLOCATION_SIZE_BYTES;\n+\n+public:\n+    /**\n+     * Construct a new MemoryResource object that uses the specified allocation size to optimize for.\n+     */\n+    MemoryResource() = default;\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated pools.\n+     *\n+     * There's no Clear() method on purpose, because it would be dangerous. E.g. when calling\n+     * clear() on an unordered_map, it is not certain that all allocated nodes are given back to the\n+     * MemoryResource. Microsoft's STL still uses a control structure that might have the same size\n+     * as the nodes, and therefore needs to be kept around until the map is actually destroyed.\n+     */\n+    ~MemoryResource() = default;\n+\n+    /**\n+     * Allocates memory for sizeof(T).\n+     *\n+     * @tparam T Object to allocate memory for.\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate()\n+    {\n+        static_assert(ALLOCATION_SIZE_BYTES == detail::RequiredAllocationSizeBytes<T>());\n+        static_assert(__STDCPP_DEFAULT_NEW_ALIGNMENT__ >= std::alignment_of_v<T>, \"make sure AllocatePool() aligns correctly\");",
    "path": "src/support/allocators/node_allocator/memory_resource.h",
    "position": 104,
    "original_position": 104,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "96d8e33acaa079491403d8e8afa6709978dec205",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "I think that check is necessary. In `AllocatePool` I'm doing `new char[POOL_SIZE_BYTES]`, and this uses `__STDCPP_DEFAULT_NEW_ALIGNMENT__` as the alignment for the pool's memory. So if you try to use the node_allocator with a type that has an alignment > `__STDCPP_DEFAULT_NEW_ALIGNMENT__` this is a problem, even when `detail::RequiredAllocationSizeBytes` is done correctly. I had a test case that used 16 byte alignment, and with that `static_assert` that test failed on a 32bit machine.",
    "created_at": "2021-11-25T06:15:56Z",
    "updated_at": "2021-11-25T06:15:56Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r756597523",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/756597523"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r756597523"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/756597523/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 104,
    "original_line": 104,
    "side": "RIGHT",
    "in_reply_to_id": 754518240
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/756600644",
    "pull_request_review_id": 815595337,
    "id": 756600644,
    "node_id": "PRRC_kwDOABII584tGM9E",
    "diff_hunk": "@@ -0,0 +1,27 @@\n+#ifndef BITCOIN_TEST_NODE_ALLOCATOR_HELPERS_H\n+#define BITCOIN_TEST_NODE_ALLOCATOR_HELPERS_H\n+\n+#include <cstddef>\n+#include <utility>\n+\n+/**\n+ * Wrapper around std::hash, but without noexcept. Useful for testing unordered containers\n+ * because they potentially behave differently with/without a noexcept hash.\n+ */\n+template <typename T>\n+struct NotNoexceptHash {\n+    size_t operator()(const T& x) const /* not noexcept */",
    "path": "src/test/node_allocator_helpers.h",
    "position": 13,
    "original_position": 13,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "119c3b90d6b7e9b81915a09f5ca5370f2ef1ea57",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "I think this is safe, the standard says that only a handful functions are implicitly nothrowing: default ctor and dtor, move & copy ctor, move & assignment operator. There has been a proposal for a `noexcept(auto)` to add implicitly nothrowing anywhere else, but it seems that there were too many problems.",
    "created_at": "2021-11-25T06:23:50Z",
    "updated_at": "2021-11-25T06:23:50Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r756600644",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/756600644"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r756600644"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/756600644/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 13,
    "original_line": 13,
    "side": "RIGHT",
    "in_reply_to_id": 754529782
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/757753231",
    "pull_request_review_id": 817112936,
    "id": 757753231,
    "node_id": "PRRC_kwDOABII584tKmWP",
    "diff_hunk": "@@ -169,6 +170,14 @@ static inline size_t DynamicUsage(const std::unordered_map<Key, Value, Hash, Equ\n     return MallocUsage(node_size) * m.size() + MallocUsage(sizeof(void*) * m.bucket_count());\n }\n \n+template <typename Key, typename Value, typename Hash, typename Equals, typename AllocT, size_t AllocS>\n+static inline size_t DynamicUsage(const std::unordered_map<Key, Value, Hash, Equals, node_allocator::Allocator<AllocT, AllocS>>& m)\n+{\n+    // Since node_allocator is used, the memory of the nodes are the MemoryResource's responsibility and\n+    // won't be added here. Also multiple maps could use the same MemoryResource.\n+    return MallocUsage(sizeof(void*) * m.bucket_count());",
    "path": "src/memusage.h",
    "position": 28,
    "original_position": 17,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "96d8e33acaa079491403d8e8afa6709978dec205",
    "user": {
      "login": "martinus",
      "id": 14386,
      "node_id": "MDQ6VXNlcjE0Mzg2",
      "avatar_url": "https://avatars.githubusercontent.com/u/14386?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/martinus",
      "html_url": "https://github.com/martinus",
      "followers_url": "https://api.github.com/users/martinus/followers",
      "following_url": "https://api.github.com/users/martinus/following{/other_user}",
      "gists_url": "https://api.github.com/users/martinus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/martinus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/martinus/subscriptions",
      "organizations_url": "https://api.github.com/users/martinus/orgs",
      "repos_url": "https://api.github.com/users/martinus/repos",
      "events_url": "https://api.github.com/users/martinus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/martinus/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Thanks for the patch! This makes discussion a lot easier. I think there's one bug in it, this now overestimates memory usage. In `memusage.h` all maps are now calculated like this:\r\n\r\n```cpp\r\nreturn MallocUsage(node_size) * m.size() + MallocUsage(sizeof(void*) * m.bucket_count());\r\n```\r\nTo correct for the incorrectly added `MallocUsage(node_size) * m.size()` it should be `memoryusage::MallocUsage(ALLOCATION_SIZE_BYTES) * m_allocations`. That should be correct in most cases, but it might not be when `RequiredAllocationSizeBytes<typename NodeSize...>` (in `factory.h`) gives a different result than the NodeSize. The only way to do this correctly is to also pass the result of `NodeSize` to the `MemoryResource`, but this complicates things.\r\n\r\nI also don't like that in most cases `memoryresource.DynamicMemoryUsage()` will return a negative number (causing `size_t` underflow) to correct for the overestimation in memusage. This will happen whenever the overestimation is large enough.",
    "created_at": "2021-11-27T07:40:10Z",
    "updated_at": "2021-11-27T07:40:10Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r757753231",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/757753231"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r757753231"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/757753231/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": 176,
    "original_start_line": 176,
    "start_side": "RIGHT",
    "line": 178,
    "original_line": 178,
    "side": "RIGHT",
    "in_reply_to_id": 754650139
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/759607661",
    "pull_request_review_id": 819484786,
    "id": 759607661,
    "node_id": "PRRC_kwDOABII584tRrFt",
    "diff_hunk": "@@ -0,0 +1,196 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <cstddef>\n+#include <memory>\n+#include <type_traits>\n+#include <utility>\n+#include <vector>\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_MEMORY_RESOURCE_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_MEMORY_RESOURCE_H\n+\n+namespace node_allocator {\n+\n+namespace detail {\n+\n+/**\n+ * In-place linked list of the allocations, used for the free list.\n+ */\n+struct FreeList {\n+    FreeList* next;\n+};\n+\n+static_assert(std::is_trivially_destructible_v<FreeList>, \"make sure we don't need to manually destruct the FreeList\");\n+\n+/**\n+ * Calculates the required allocation size for the given type.\n+ * The memory needs to be correctly aligned and large enough for both both T and FreeList.\n+ */\n+template <typename T>\n+[[nodiscard]] constexpr size_t RequiredAllocationSizeBytes() noexcept\n+{\n+    const auto alignment_max = std::max(std::alignment_of_v<T>, std::alignment_of_v<FreeList>);\n+    const auto size_max = std::max(sizeof(T), sizeof(FreeList));\n+\n+    // find closest multiple of alignment_max that holds size_max\n+    return ((size_max + alignment_max - 1U) / alignment_max) * alignment_max;\n+}\n+\n+/**\n+ * Calculates dynamic memory usage of a MemoryResource. Not a member of MemoryResource so we can implement this\n+ * in a cpp and don't depend on memusage.h in the header.\n+ */\n+[[nodiscard]] size_t DynamicMemoryUsage(size_t pool_size_bytes, std::vector<std::unique_ptr<char[]>> const& allocated_pools);\n+\n+} // namespace detail\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It\n+ * stores a number of memory pools which are used to quickly give out memory of a fixed allocation\n+ * size. The class is purposely kept very simple. It only knows about \"Allocations\" and \"Pools\".\n+ *\n+ * - Pool: MemoryResource allocates one memory pool at a time. These pools are kept around until the\n+ * memory resource is destroyed.\n+ *\n+ * - Allocations: Node-based containers allocate one node at a time. Whenever that happens, the\n+ * MemoryResource's Allocate() gives out memory for one node. These are carved out from a previously\n+ * allocated memory pool, or from a free list if it contains entries. Whenever a node is given back\n+ * with Deallocate(), it is put into that free list.\n+ */\n+template <size_t ALLOCATION_SIZE_BYTES>\n+class MemoryResource\n+{\n+    /**\n+     * Size in bytes to allocate per pool, currently hardcoded to multiple of ALLOCATION_SIZE_BYTES\n+     * that comes closest to 256 KiB.\n+     */\n+    static constexpr size_t POOL_SIZE_BYTES = (262144 / ALLOCATION_SIZE_BYTES) * ALLOCATION_SIZE_BYTES;\n+\n+public:\n+    /**\n+     * Construct a new MemoryResource object that uses the specified allocation size to optimize for.\n+     */\n+    MemoryResource() = default;\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated pools.\n+     *\n+     * There's no Clear() method on purpose, because it would be dangerous. E.g. when calling\n+     * clear() on an unordered_map, it is not certain that all allocated nodes are given back to the\n+     * MemoryResource. Microsoft's STL still uses a control structure that might have the same size\n+     * as the nodes, and therefore needs to be kept around until the map is actually destroyed.\n+     */\n+    ~MemoryResource() = default;\n+\n+    /**\n+     * Allocates memory for sizeof(T).\n+     *\n+     * @tparam T Object to allocate memory for.\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate()\n+    {\n+        static_assert(ALLOCATION_SIZE_BYTES == detail::RequiredAllocationSizeBytes<T>());\n+        static_assert(__STDCPP_DEFAULT_NEW_ALIGNMENT__ >= std::alignment_of_v<T>, \"make sure AllocatePool() aligns correctly\");",
    "path": "src/support/allocators/node_allocator/memory_resource.h",
    "position": 104,
    "original_position": 104,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "96d8e33acaa079491403d8e8afa6709978dec205",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "re: https://github.com/bitcoin/bitcoin/pull/22702#discussion_r756597523\r\n\r\n> I think that check is necessary. In `AllocatePool` I'm doing `new char[POOL_SIZE_BYTES]`\r\n\r\nMaybe can move check closer to where it's needed\r\n\r\n<details><summary>Diff</summary><p>\r\n\r\n```diff\r\ndiff --git a/src/support/allocators/node_allocator/memory_resource.h b/src/support/allocators/node_allocator/memory_resource.h\r\nindex f4ba0138924..cf956da318f 100644\r\n--- a/src/support/allocators/node_allocator/memory_resource.h\r\n+++ b/src/support/allocators/node_allocator/memory_resource.h\r\n@@ -101,7 +101,6 @@ public:\r\n     [[nodiscard]] T* Allocate()\r\n     {\r\n         static_assert(ALLOCATION_SIZE_BYTES == detail::RequiredAllocationSizeBytes<T>());\r\n-        static_assert(__STDCPP_DEFAULT_NEW_ALIGNMENT__ >= std::alignment_of_v<T>, \"make sure AllocatePool() aligns correctly\");\r\n \r\n         if (m_free_allocations) {\r\n             // we've already got data in the free list, unlink one element\r\n@@ -120,7 +119,7 @@ public:\r\n         // than what has been malloc'ed.\r\n         if (m_untouched_memory_iterator == m_untouched_memory_end) {\r\n             // slow path, only happens when a new pool needs to be allocated\r\n-            AllocatePool();\r\n+            AllocatePool<T>();\r\n         }\r\n \r\n         // peel off one allocation from the untouched memory. The next pointer of in-use\r\n@@ -164,8 +163,10 @@ private:\r\n     /**\r\n      * Allocate one full memory pool which is used to carve out allocations.\r\n      */\r\n+    template <typename T>\r\n     void AllocatePool()\r\n     {\r\n+        static_assert(__STDCPP_DEFAULT_NEW_ALIGNMENT__ >= std::alignment_of_v<T>, \"make sure alignment is compatible with T\");\r\n         m_allocated_pools.emplace_back(new char[POOL_SIZE_BYTES]);\r\n         m_untouched_memory_iterator = m_allocated_pools.back().get();\r\n         m_untouched_memory_end = m_untouched_memory_iterator + POOL_SIZE_BYTES;\r\n\r\n```\r\n</p>",
    "created_at": "2021-11-30T19:47:16Z",
    "updated_at": "2021-11-30T20:24:34Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r759607661",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/759607661"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r759607661"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/759607661/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 104,
    "original_line": 104,
    "side": "RIGHT",
    "in_reply_to_id": 754518240
  },
  {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/759616047",
    "pull_request_review_id": 819484786,
    "id": 759616047,
    "node_id": "PRRC_kwDOABII584tRtIv",
    "diff_hunk": "@@ -169,6 +170,14 @@ static inline size_t DynamicUsage(const std::unordered_map<Key, Value, Hash, Equ\n     return MallocUsage(node_size) * m.size() + MallocUsage(sizeof(void*) * m.bucket_count());\n }\n \n+template <typename Key, typename Value, typename Hash, typename Equals, typename AllocT, size_t AllocS>\n+static inline size_t DynamicUsage(const std::unordered_map<Key, Value, Hash, Equals, node_allocator::Allocator<AllocT, AllocS>>& m)\n+{\n+    // Since node_allocator is used, the memory of the nodes are the MemoryResource's responsibility and\n+    // won't be added here. Also multiple maps could use the same MemoryResource.\n+    return MallocUsage(sizeof(void*) * m.bucket_count());",
    "path": "src/memusage.h",
    "position": 28,
    "original_position": 17,
    "commit_id": "8dfd71ca7fddf1a9436d04a16f5a8d9d98ee8c74",
    "original_commit_id": "96d8e33acaa079491403d8e8afa6709978dec205",
    "user": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "re: https://github.com/bitcoin/bitcoin/pull/22702#discussion_r754650139\r\n\r\n> Thanks for the patch! This makes discussion a lot easier. I think there's one bug in it [...]\r\n\r\nThat's a good catch, but there is an easier fix for for that bug. Space internally wasted by MemoryResource should count towards MemoryResource usage. The fix actually simplifies code even more\r\n\r\n<details><summary>Diff</summary><p>\r\n\r\n```diff\r\ndiff --git a/src/support/allocators/node_allocator/memory_resource.h b/src/support/allocators/node_allocator/memory_resource.h\r\nindex e60e847c86d..c1bf680e071 100644\r\n--- a/src/support/allocators/node_allocator/memory_resource.h\r\n+++ b/src/support/allocators/node_allocator/memory_resource.h\r\n@@ -98,7 +98,7 @@ public:\r\n     {\r\n         static_assert(ALLOCATION_SIZE_BYTES == detail::RequiredAllocationSizeBytes<T>());\r\n         static_assert(__STDCPP_DEFAULT_NEW_ALIGNMENT__ >= std::alignment_of_v<T>, \"make sure AllocatePool() aligns correctly\");\r\n-        ++m_allocations;\r\n+        m_allocated += sizeof(T);\r\n \r\n         if (m_free_allocations) {\r\n             // we've already got data in the free list, unlink one element\r\n@@ -135,7 +135,7 @@ public:\r\n     void Deallocate(void* p) noexcept\r\n     {\r\n         static_assert(ALLOCATION_SIZE_BYTES == detail::RequiredAllocationSizeBytes<T>());\r\n-        --m_allocations;\r\n+        m_allocated -= sizeof(T);\r\n \r\n         // put it into the linked list.\r\n         //\r\n@@ -152,7 +152,7 @@ public:\r\n      */\r\n     [[nodiscard]] size_t DynamicMemoryUsage() const noexcept\r\n     {\r\n-        return memusage::MallocUsage(POOL_SIZE_BYTES) * m_allocated_pools.size() + memusage::DynamicUsage(m_allocated_pools) - ALLOCATION_SIZE_BYTES * m_allocations;\r\n+        return memusage::MallocUsage(POOL_SIZE_BYTES) * m_allocated_pools.size() + memusage::DynamicUsage(m_allocated_pools) - m_allocated;\r\n     }\r\n \r\n private:\r\n@@ -169,8 +169,8 @@ private:\r\n         m_untouched_memory_end = m_untouched_memory_iterator + POOL_SIZE_BYTES;\r\n     }\r\n \r\n-    //! Number of current allocations.\r\n-    size_t m_allocations = 0;\r\n+    //! Number of bytes allocated.\r\n+    size_t m_allocated = 0;\r\n \r\n     //! Contains all allocated pools of memory, used to free the data in the destructor.\r\n     std::vector<std::unique_ptr<char[]>> m_allocated_pools{};\r\n\r\n```\r\n</p></details>\r\n\r\n> I also don't like that in most cases `memoryresource.DynamicMemoryUsage()` will return a negative number (causing `size_t` underflow) to correct for the overestimation in memusage. This will happen whenever the overestimation is large enough.\r\n\r\nI don't understand this. The only negative term in the DynamicMemoryUsage calculation is the actual number of bytes allocated, not a memusage estimate. The result should always be positive, and higher with more memusage overestimation.",
    "created_at": "2021-11-30T19:59:18Z",
    "updated_at": "2021-11-30T20:24:34Z",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r759616047",
    "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/759616047"
      },
      "html": {
        "href": "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r759616047"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
      }
    },
    "reactions": {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/759616047/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "start_line": 176,
    "original_start_line": 176,
    "start_side": "RIGHT",
    "line": 178,
    "original_line": 178,
    "side": "RIGHT",
    "in_reply_to_id": 754650139
  }
]