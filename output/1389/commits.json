[
  {
    "sha": "587f929c6462698a674fe8add2f301161219d05a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1ODdmOTI5YzY0NjI2OThhNjc0ZmU4YWRkMmYzMDExNjEyMTlkMDVh",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-05-24T17:02:21Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-05-31T16:12:35Z"
      },
      "message": "Rework network config settings",
      "tree": {
        "sha": "1a1f3dde2af5e4fe19a66d692df94e8b223560db",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1a1f3dde2af5e4fe19a66d692df94e8b223560db"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/587f929c6462698a674fe8add2f301161219d05a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/587f929c6462698a674fe8add2f301161219d05a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/587f929c6462698a674fe8add2f301161219d05a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/587f929c6462698a674fe8add2f301161219d05a/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "50fac686541686191647ddabd87d6dae75c24c52",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/50fac686541686191647ddabd87d6dae75c24c52",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/50fac686541686191647ddabd87d6dae75c24c52"
      }
    ],
    "stats": {
      "total": 401,
      "additions": 237,
      "deletions": 164
    },
    "files": [
      {
        "sha": "e31022d822b5368e56033f44b5b3c5a49394d8c4",
        "filename": "src/bitcoinrpc.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/587f929c6462698a674fe8add2f301161219d05a/src/bitcoinrpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/587f929c6462698a674fe8add2f301161219d05a/src/bitcoinrpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoinrpc.cpp?ref=587f929c6462698a674fe8add2f301161219d05a",
        "patch": "@@ -531,14 +531,17 @@ Value getinfo(const Array& params, bool fHelp)\n             \"getinfo\\n\"\n             \"Returns an object containing various state info.\");\n \n+    CService addrProxy;\n+    GetProxy(NET_IPV4, addrProxy);\n+\n     Object obj;\n     obj.push_back(Pair(\"version\",       (int)CLIENT_VERSION));\n     obj.push_back(Pair(\"protocolversion\",(int)PROTOCOL_VERSION));\n     obj.push_back(Pair(\"walletversion\", pwalletMain->GetVersion()));\n     obj.push_back(Pair(\"balance\",       ValueFromAmount(pwalletMain->GetBalance())));\n     obj.push_back(Pair(\"blocks\",        (int)nBestHeight));\n     obj.push_back(Pair(\"connections\",   (int)vNodes.size()));\n-    obj.push_back(Pair(\"proxy\",         (fUseProxy ? addrProxy.ToStringIPPort() : string())));\n+    obj.push_back(Pair(\"proxy\",         (addrProxy.IsValid() ? addrProxy.ToStringIPPort() : string())));\n     obj.push_back(Pair(\"difficulty\",    (double)GetDifficulty()));\n     obj.push_back(Pair(\"testnet\",       fTestNet));\n     obj.push_back(Pair(\"keypoololdest\", (boost::int64_t)pwalletMain->GetOldestKeyPoolTime()));"
      },
      {
        "sha": "f6f443d77d382ae00b80a44823e936adc36d370d",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 65,
        "deletions": 54,
        "changes": 119,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/587f929c6462698a674fe8add2f301161219d05a/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/587f929c6462698a674fe8add2f301161219d05a/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=587f929c6462698a674fe8add2f301161219d05a",
        "patch": "@@ -182,12 +182,15 @@ bool static InitWarning(const std::string &str)\n }\n \n \n-bool static Bind(const CService &addr) {\n+bool static Bind(const CService &addr, bool fError = true) {\n     if (IsLimited(addr))\n         return false;\n     std::string strError;\n-    if (!BindListenPort(addr, strError))\n-        return InitError(strError);\n+    if (!BindListenPort(addr, strError)) {\n+        if (fError)\n+            return InitError(strError);\n+        return false;\n+    }\n     return true;\n }\n \n@@ -204,20 +207,18 @@ std::string HelpMessage()\n         \"  -dblogsize=<n>         \" + _(\"Set database disk log size in megabytes (default: 100)\") + \"\\n\" +\n         \"  -timeout=<n>           \" + _(\"Specify connection timeout (in milliseconds)\") + \"\\n\" +\n         \"  -proxy=<ip:port>       \" + _(\"Connect through socks proxy\") + \"\\n\" +\n-        \"  -socks=<n>             \" + _(\"Select the version of socks proxy to use (4 or 5, 5 is default)\") + \"\\n\" +\n-        \"  -noproxy=<net>         \" + _(\"Do not use proxy for connections to network <net> (IPv4 or IPv6)\") + \"\\n\" +\n+        \"  -socks=<n>             \" + _(\"Select the version of socks proxy to use (4-5, default: 5)\") + \"\\n\" +\n         \"  -dns                   \" + _(\"Allow DNS lookups for -addnode, -seednode and -connect\") + \"\\n\" +\n-        \"  -proxydns              \" + _(\"Pass DNS requests to (SOCKS5) proxy\") + \"\\n\" +\n         \"  -port=<port>           \" + _(\"Listen for connections on <port> (default: 8333 or testnet: 18333)\") + \"\\n\" +\n         \"  -maxconnections=<n>    \" + _(\"Maintain at most <n> connections to peers (default: 125)\") + \"\\n\" +\n         \"  -addnode=<ip>          \" + _(\"Add a node to connect to and attempt to keep the connection open\") + \"\\n\" +\n-        \"  -connect=<ip>          \" + _(\"Connect only to the specified node\") + \"\\n\" +\n+        \"  -connect=<ip>          \" + _(\"Connect only to the specified node(s)\") + \"\\n\" +\n         \"  -seednode=<ip>         \" + _(\"Connect to a node to retrieve peer addresses, and disconnect\") + \"\\n\" +\n         \"  -externalip=<ip>       \" + _(\"Specify your own public address\") + \"\\n\" +\n         \"  -onlynet=<net>         \" + _(\"Only connect to nodes in network <net> (IPv4 or IPv6)\") + \"\\n\" +\n-        \"  -discover              \" + _(\"Try to discover public IP address (default: 1)\") + \"\\n\" +\n+        \"  -discover              \" + _(\"Discover own IP address (default: 1 when listening and no -externalip)\") + \"\\n\" +\n         \"  -irc                   \" + _(\"Find peers using internet relay chat (default: 0)\") + \"\\n\" +\n-        \"  -listen                \" + _(\"Accept connections from outside (default: 1)\") + \"\\n\" +\n+        \"  -listen                \" + _(\"Accept connections from outside (default: 1 if no -proxy or -connect)\") + \"\\n\" +\n         \"  -bind=<addr>           \" + _(\"Bind to given address. Use [host]:port notation for IPv6\") + \"\\n\" +\n         \"  -dnsseed               \" + _(\"Find peers using DNS lookup (default: 1)\") + \"\\n\" +\n         \"  -banscore=<n>          \" + _(\"Threshold for disconnecting misbehaving peers (default: 100)\") + \"\\n\" +\n@@ -226,9 +227,9 @@ std::string HelpMessage()\n         \"  -maxsendbuffer=<n>     \" + _(\"Maximum per-connection send buffer, <n>*1000 bytes (default: 10000)\") + \"\\n\" +\n #ifdef USE_UPNP\n #if USE_UPNP\n-        \"  -upnp                  \" + _(\"Use Universal Plug and Play to map the listening port (default: 1)\") + \"\\n\" +\n+        \"  -upnp                  \" + _(\"Use UPnP to map the listening port (default: 1 when listening)\") + \"\\n\" +\n #else\n-        \"  -upnp                  \" + _(\"Use Universal Plug and Play to map the listening port (default: 0)\") + \"\\n\" +\n+        \"  -upnp                  \" + _(\"Use UPnP to map the listening port (default: 0)\") + \"\\n\" +\n #endif\n #endif\n         \"  -detachdb              \" + _(\"Detach block and address databases. Increases shutdown time (default: 0)\") + \"\\n\" +\n@@ -308,30 +309,38 @@ bool AppInit2()\n     // ********************************************************* Step 2: parameter interactions\n \n     fTestNet = GetBoolArg(\"-testnet\");\n-    if (fTestNet)\n-    {\n+    if (fTestNet) {\n         SoftSetBoolArg(\"-irc\", true);\n     }\n \n-    if (mapArgs.count(\"-connect\"))\n-        SoftSetBoolArg(\"-dnsseed\", false);\n-\n-    // even in Tor mode, if -bind is specified, you really want -listen\n-    if (mapArgs.count(\"-bind\"))\n+    if (mapArgs.count(\"-bind\")) {\n+        // when specifying an explicit binding address, you want to listen on it\n+        // even when -connect or -proxy is specified\n         SoftSetBoolArg(\"-listen\", true);\n+    }\n \n-    bool fTor = (fUseProxy && addrProxy.GetPort() == 9050);\n-    if (fTor)\n-    {\n-        // Use SoftSetBoolArg here so user can override any of these if they wish.\n-        // Note: the GetBoolArg() calls for all of these must happen later.\n+    if (mapArgs.count(\"-connect\")) {\n+        // when only connecting to trusted nodes, do not seed via DNS, or listen by default\n+        SoftSetBoolArg(\"-dnsseed\", false);\n+        SoftSetBoolArg(\"-listen\", false);\n+    }\n+\n+    if (mapArgs.count(\"-proxy\")) {\n+        // to protect privacy, do not listen by default if a proxy server is specified\n         SoftSetBoolArg(\"-listen\", false);\n-        SoftSetBoolArg(\"-irc\", false);\n-        SoftSetBoolArg(\"-proxydns\", true);\n+    }\n+\n+    if (GetBoolArg(\"-listen\", true)) {\n+        // do not map ports or try to retrieve public IP when not listening (pointless)\n         SoftSetBoolArg(\"-upnp\", false);\n         SoftSetBoolArg(\"-discover\", false);\n     }\n \n+    if (mapArgs.count(\"-externalip\")) {\n+        // if an explicit public IP is specified, do not try to find others\n+        SoftSetBoolArg(\"-discover\", false);\n+    }\n+\n     // ********************************************************* Step 3: parameter-to-internal-flags\n \n     fDebug = GetBoolArg(\"-debug\");\n@@ -425,30 +434,8 @@ bool AppInit2()\n \n     // ********************************************************* Step 5: network initialization\n \n-    if (mapArgs.count(\"-proxy\"))\n-    {\n-        fUseProxy = true;\n-        addrProxy = CService(mapArgs[\"-proxy\"], 9050);\n-        if (!addrProxy.IsValid())\n-            return InitError(strprintf(_(\"Invalid -proxy address: '%s'\"), mapArgs[\"-proxy\"].c_str()));\n-    }\n-\n-    if (mapArgs.count(\"-noproxy\"))\n-    {\n-        BOOST_FOREACH(std::string snet, mapMultiArgs[\"-noproxy\"]) {\n-            enum Network net = ParseNetwork(snet);\n-            if (net == NET_UNROUTABLE)\n-                return InitError(strprintf(_(\"Unknown network specified in -noproxy: '%s'\"), snet.c_str()));\n-            SetNoProxy(net);\n-        }\n-    }\n+    int nSocksVersion = GetArg(\"-socks\", 5);\n \n-    fNameLookup = GetBoolArg(\"-dns\");\n-    fProxyNameLookup = GetBoolArg(\"-proxydns\");\n-    if (fProxyNameLookup)\n-        fNameLookup = true;\n-    fNoListen = !GetBoolArg(\"-listen\", true);\n-    nSocksVersion = GetArg(\"-socks\", 5);\n     if (nSocksVersion != 4 && nSocksVersion != 5)\n         return InitError(strprintf(_(\"Unknown -socks proxy version requested: %i\"), nSocksVersion));\n \n@@ -467,8 +454,29 @@ bool AppInit2()\n         }\n     }\n \n-    BOOST_FOREACH(string strDest, mapMultiArgs[\"-seednode\"])\n-        AddOneShot(strDest);\n+    if (mapArgs.count(\"-proxy\")) {\n+        CService addrProxy = CService(mapArgs[\"-proxy\"], 9050);\n+        if (!addrProxy.IsValid())\n+            return InitError(strprintf(_(\"Invalid -proxy address: '%s'\"), mapArgs[\"-proxy\"].c_str()));\n+\n+        if (!IsLimited(NET_IPV4))\n+            SetProxy(NET_IPV4, addrProxy, nSocksVersion);\n+        if (nSocksVersion > 4) {\n+#ifdef USE_IPV6\n+            if (!IsLimited(NET_IPV6))\n+                SetProxy(NET_IPV6, addrProxy, nSocksVersion);\n+#endif\n+            SetNameProxy(addrProxy, nSocksVersion);\n+        }\n+    }\n+\n+    // see Step 2: parameter interactions for more information about these\n+    fNoListen = !GetBoolArg(\"-listen\", true);\n+    fDiscover = GetBoolArg(\"-discover\", true);\n+    fNameLookup = GetBoolArg(\"-dns\", true);\n+#ifdef USE_UPNP\n+    fUseUPnP = GetBoolArg(\"-upnp\", USE_UPNP);\n+#endif\n \n     bool fBound = false;\n     if (!fNoListen)\n@@ -484,15 +492,15 @@ bool AppInit2()\n         } else {\n             struct in_addr inaddr_any;\n             inaddr_any.s_addr = INADDR_ANY;\n-            if (!IsLimited(NET_IPV4))\n-                fBound |= Bind(CService(inaddr_any, GetListenPort()));\n #ifdef USE_IPV6\n             if (!IsLimited(NET_IPV6))\n-                fBound |= Bind(CService(in6addr_any, GetListenPort()));\n+                fBound |= Bind(CService(in6addr_any, GetListenPort()), false);\n #endif\n+            if (!IsLimited(NET_IPV4))\n+                fBound |= Bind(CService(inaddr_any, GetListenPort()), !fBound);\n         }\n         if (!fBound)\n-            return InitError(_(\"Not listening on any port\"));\n+            return InitError(_(\"Failed to listen on any port. Use -listen=0 if you want this.\"));\n     }\n \n     if (mapArgs.count(\"-externalip\"))\n@@ -505,6 +513,9 @@ bool AppInit2()\n         }\n     }\n \n+    BOOST_FOREACH(string strDest, mapMultiArgs[\"-seednode\"])\n+        AddOneShot(strDest);\n+\n     // ********************************************************* Step 6: load blockchain\n \n     if (GetBoolArg(\"-loadblockindextest\"))"
      },
      {
        "sha": "185be02f29c0007296872c882ec65fd21a1b0ab2",
        "filename": "src/irc.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/587f929c6462698a674fe8add2f301161219d05a/src/irc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/587f929c6462698a674fe8add2f301161219d05a/src/irc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/irc.cpp?ref=587f929c6462698a674fe8add2f301161219d05a",
        "patch": "@@ -176,8 +176,6 @@ bool GetIPFromIRC(SOCKET hSocket, string strMyName, CNetAddr& ipRet)\n     // Hybrid IRC used by lfnet always returns IP when you userhost yourself,\n     // but in case another IRC is ever used this should work.\n     printf(\"GetIPFromIRC() got userhost %s\\n\", strHost.c_str());\n-    if (fUseProxy)\n-        return false;\n     CNetAddr addr(strHost, true);\n     if (!addr.IsValid())\n         return false;\n@@ -281,7 +279,7 @@ void ThreadIRCSeed2(void* parg)\n         if (GetIPFromIRC(hSocket, strMyName, addrFromIRC))\n         {\n             printf(\"GetIPFromIRC() returned %s\\n\", addrFromIRC.ToString().c_str());\n-            if (!fUseProxy && addrFromIRC.IsRoutable())\n+            if (addrFromIRC.IsRoutable())\n             {\n                 // IRC lets you to re-nick\n                 AddLocal(addrFromIRC, LOCAL_IRC);"
      },
      {
        "sha": "50a740d160977d6c8a65d1ce4044deb2173f8bf4",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/587f929c6462698a674fe8add2f301161219d05a/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/587f929c6462698a674fe8add2f301161219d05a/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=587f929c6462698a674fe8add2f301161219d05a",
        "patch": "@@ -2377,7 +2377,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n         if (!pfrom->fInbound)\n         {\n             // Advertise our address\n-            if (!fNoListen && !fUseProxy && !IsInitialBlockDownload())\n+            if (!fNoListen && !IsInitialBlockDownload())\n             {\n                 CAddress addr = GetLocalAddress(&pfrom->addr);\n                 if (addr.IsRoutable())\n@@ -3035,7 +3035,7 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n                         pnode->setAddrKnown.clear();\n \n                     // Rebroadcast our address\n-                    if (!fNoListen && !fUseProxy)\n+                    if (!fNoListen)\n                     {\n                         CAddress addr = GetLocalAddress(&pnode->addr);\n                         if (addr.IsRoutable())"
      },
      {
        "sha": "d510709082eaaad990dfc67175bd6170722997b0",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 19,
        "deletions": 35,
        "changes": 54,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/587f929c6462698a674fe8add2f301161219d05a/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/587f929c6462698a674fe8add2f301161219d05a/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=587f929c6462698a674fe8add2f301161219d05a",
        "patch": "@@ -47,7 +47,8 @@ struct LocalServiceInfo {\n // Global state variables\n //\n bool fClient = false;\n-static bool fUseUPnP = false;\n+bool fDiscover = true;\n+bool fUseUPnP = false;\n uint64 nLocalServices = (fClient ? 0 : NODE_NETWORK);\n static CCriticalSection cs_mapLocalHost;\n static map<CNetAddr, LocalServiceInfo> mapLocalHost;\n@@ -99,7 +100,7 @@ void CNode::PushGetBlocks(CBlockIndex* pindexBegin, uint256 hashEnd)\n // find 'best' local address for a particular peer\n bool GetLocal(CService& addr, const CNetAddr *paddrPeer)\n {\n-    if (fUseProxy || mapArgs.count(\"-connect\") || fNoListen)\n+    if (fNoListen)\n         return false;\n \n     int nBestScore = -1;\n@@ -211,7 +212,7 @@ bool AddLocal(const CService& addr, int nScore)\n     if (!addr.IsRoutable())\n         return false;\n \n-    if (!GetBoolArg(\"-discover\", true) && nScore < LOCAL_MANUAL)\n+    if (!fDiscover && nScore < LOCAL_MANUAL)\n         return false;\n \n     if (IsLimited(addr))\n@@ -345,9 +346,6 @@ bool GetMyExternalIP(CNetAddr& ipRet)\n     const char* pszGet;\n     const char* pszKeyword;\n \n-    if (fNoListen||fUseProxy)\n-        return false;\n-\n     for (int nLookup = 0; nLookup <= 1; nLookup++)\n     for (int nHost = 1; nHost <= 2; nHost++)\n     {\n@@ -542,7 +540,7 @@ void CNode::PushVersion()\n {\n     /// when NTP implemented, change to just nTime = GetAdjustedTime()\n     int64 nTime = (fInbound ? GetAdjustedTime() : GetTime());\n-    CAddress addrYou = (fUseProxy ? CAddress(CService(\"0.0.0.0\",0)) : addr);\n+    CAddress addrYou = (addr.IsRoutable() && !IsProxy(addr) ? addr : CAddress(CService(\"0.0.0.0\",0)));\n     CAddress addrMe = GetLocalAddress(&addr);\n     RAND_bytes((unsigned char*)&nLocalHostNonce, sizeof(nLocalHostNonce));\n     PushMessage(\"version\", PROTOCOL_VERSION, nLocalServices, nTime, addrYou, addrMe,\n@@ -1016,7 +1014,7 @@ void ThreadMapPort2(void* parg)\n     r = UPNP_GetValidIGD(devlist, &urls, &data, lanaddr, sizeof(lanaddr));\n     if (r == 1)\n     {\n-        if (GetBoolArg(\"-discover\", true)) {\n+        if (fDiscover) {\n             char externalIPAddress[40];\n             r = UPNP_GetExternalIPAddress(urls.controlURL, data.first.servicetype, externalIPAddress);\n             if(r != UPNPCOMMAND_SUCCESS)\n@@ -1093,20 +1091,16 @@ void ThreadMapPort2(void* parg)\n     }\n }\n \n-void MapPort(bool fMapPort)\n+void MapPort()\n {\n-    if (fUseUPnP != fMapPort)\n-    {\n-        fUseUPnP = fMapPort;\n-    }\n     if (fUseUPnP && vnThreadsRunning[THREAD_UPNP] < 1)\n     {\n         if (!CreateThread(ThreadMapPort, NULL))\n             printf(\"Error: ThreadMapPort(ThreadMapPort) failed\\n\");\n     }\n }\n #else\n-void MapPort(bool /* unused fMapPort */)\n+void MapPort()\n {\n     // Intentionally left blank.\n }\n@@ -1160,7 +1154,7 @@ void ThreadDNSAddressSeed2(void* parg)\n         printf(\"Loading addresses from DNS seeds (could take a while)\\n\");\n \n         for (unsigned int seed_idx = 0; seed_idx < ARRAYLEN(strDNSSeed); seed_idx++) {\n-            if (fProxyNameLookup) {\n+            if (GetNameProxy()) {\n                 AddOneShot(strDNSSeed[seed_idx][1]);\n             } else {\n                 vector<CNetAddr> vaddr;\n@@ -1394,8 +1388,7 @@ void ThreadOpenConnections2(void* parg)\n             return;\n \n         // Add seed nodes if IRC isn't working\n-        bool fTOR = (fUseProxy && addrProxy.GetPort() == 9050);\n-        if (addrman.size()==0 && (GetTime() - nStart > 60 || fTOR) && !fTestNet)\n+        if (addrman.size()==0 && (GetTime() - nStart > 60) && !fTestNet)\n         {\n             std::vector<CAddress> vAdd;\n             for (unsigned int i = 0; i < ARRAYLEN(pnSeed); i++)\n@@ -1492,7 +1485,7 @@ void ThreadOpenAddedConnections2(void* parg)\n     if (mapArgs.count(\"-addnode\") == 0)\n         return;\n \n-    if (fProxyNameLookup) {\n+    if (GetNameProxy()) {\n         while(!fShutdown) {\n             BOOST_FOREACH(string& strAddNode, mapMultiArgs[\"-addnode\"]) {\n                 CAddress addr;\n@@ -1778,15 +1771,15 @@ bool BindListenPort(const CService &addrBind, string& strError)\n \n     vhListenSocket.push_back(hListenSocket);\n \n-    if (addrBind.IsRoutable() && GetBoolArg(\"-discover\", true))\n+    if (addrBind.IsRoutable() && fDiscover)\n         AddLocal(addrBind, LOCAL_BIND);\n \n     return true;\n }\n \n void static Discover()\n {\n-    if (!GetBoolArg(\"-discover\", true))\n+    if (!fDiscover)\n         return;\n \n #ifdef WIN32\n@@ -1835,22 +1828,11 @@ void static Discover()\n     }\n #endif\n \n-    if (!fUseProxy && !mapArgs.count(\"-connect\") && !fNoListen)\n-    {\n-        CreateThread(ThreadGetMyExternalIP, NULL);\n-    }\n+    CreateThread(ThreadGetMyExternalIP, NULL);\n }\n \n void StartNode(void* parg)\n {\n-#ifdef USE_UPNP\n-#if USE_UPNP\n-    fUseUPnP = GetBoolArg(\"-upnp\", true);\n-#else\n-    fUseUPnP = GetBoolArg(\"-upnp\", false);\n-#endif\n-#endif\n-\n     if (semOutbound == NULL) {\n         // initialize semaphore\n         int nMaxOutbound = min(MAX_OUTBOUND_CONNECTIONS, (int)GetArg(\"-maxconnections\", 125));\n@@ -1873,8 +1855,8 @@ void StartNode(void* parg)\n             printf(\"Error: CreateThread(ThreadDNSAddressSeed) failed\\n\");\n \n     // Map ports with UPnP\n-    if (fHaveUPnP)\n-        MapPort(fUseUPnP);\n+    if (fUseUPnP)\n+        MapPort();\n \n     // Get addresses from IRC and advertise ours\n     if (!CreateThread(ThreadIRCSeed, NULL))\n@@ -1930,7 +1912,9 @@ bool StopNode()\n     if (vnThreadsRunning[THREAD_MINER] > 0) printf(\"ThreadBitcoinMiner still running\\n\");\n     if (vnThreadsRunning[THREAD_RPCLISTENER] > 0) printf(\"ThreadRPCListener still running\\n\");\n     if (vnThreadsRunning[THREAD_RPCHANDLER] > 0) printf(\"ThreadsRPCServer still running\\n\");\n-    if (fHaveUPnP && vnThreadsRunning[THREAD_UPNP] > 0) printf(\"ThreadMapPort still running\\n\");\n+#ifdef USE_UPNP\n+    if (vnThreadsRunning[THREAD_UPNP] > 0) printf(\"ThreadMapPort still running\\n\");\n+#endif\n     if (vnThreadsRunning[THREAD_DNSSEED] > 0) printf(\"ThreadDNSAddressSeed still running\\n\");\n     if (vnThreadsRunning[THREAD_ADDEDCONNECTIONS] > 0) printf(\"ThreadOpenAddedConnections still running\\n\");\n     if (vnThreadsRunning[THREAD_DUMPADDRESS] > 0) printf(\"ThreadDumpAddresses still running\\n\");"
      },
      {
        "sha": "c9c965722eeafb142e684474dc7a75fcc4ffc5dc",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/587f929c6462698a674fe8add2f301161219d05a/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/587f929c6462698a674fe8add2f301161219d05a/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=587f929c6462698a674fe8add2f301161219d05a",
        "patch": "@@ -36,7 +36,7 @@ void AddressCurrentlyConnected(const CService& addr);\n CNode* FindNode(const CNetAddr& ip);\n CNode* FindNode(const CService& ip);\n CNode* ConnectNode(CAddress addrConnect, const char *strDest = NULL, int64 nTimeout=0);\n-void MapPort(bool fMapPort);\n+void MapPort();\n unsigned short GetListenPort();\n bool BindListenPort(const CService &bindAddr, std::string& strError=REF(std::string()));\n void StartNode(void* parg);\n@@ -110,6 +110,8 @@ enum threadId\n };\n \n extern bool fClient;\n+extern bool fDiscover;\n+extern bool fUseUPnP;\n extern uint64 nLocalServices;\n extern uint64 nLocalHostNonce;\n extern boost::array<int, THREAD_MAX> vnThreadsRunning;"
      },
      {
        "sha": "80b0e32c39526405f11ba234d58e2621c3595199",
        "filename": "src/netbase.cpp",
        "status": "modified",
        "additions": 77,
        "deletions": 42,
        "changes": 119,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/587f929c6462698a674fe8add2f301161219d05a/src/netbase.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/587f929c6462698a674fe8add2f301161219d05a/src/netbase.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.cpp?ref=587f929c6462698a674fe8add2f301161219d05a",
        "patch": "@@ -16,14 +16,11 @@\n using namespace std;\n \n // Settings\n-int nSocksVersion = 5;\n-int fUseProxy = false;\n-bool fProxyNameLookup = false;\n-bool fNameLookup = false;\n-CService addrProxy(\"127.0.0.1\",9050);\n+typedef std::pair<CService, int> proxyType;\n+static proxyType proxyInfo[NET_MAX];\n+static proxyType nameproxyInfo;\n int nConnectTimeout = 5000;\n-static bool vfNoProxy[NET_MAX] = {};\n-\n+bool fNameLookup = false;\n \n static const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };\n \n@@ -36,11 +33,6 @@ enum Network ParseNetwork(std::string net) {\n     return NET_UNROUTABLE;\n }\n \n-void SetNoProxy(enum Network net, bool fNoProxy) {\n-    assert(net >= 0 && net < NET_MAX);\n-    vfNoProxy[net] = fNoProxy;\n-}\n-\n bool static LookupIntern(const char *pszName, std::vector<CNetAddr>& vIP, unsigned int nMaxSolutions, bool fAllowLookup)\n {\n     vIP.clear();\n@@ -431,29 +423,71 @@ bool static ConnectSocketDirectly(const CService &addrConnect, SOCKET& hSocketRe\n     return true;\n }\n \n+bool SetProxy(enum Network net, CService addrProxy, int nSocksVersion) {\n+    assert(net >= 0 && net < NET_MAX);\n+    if (nSocksVersion != 0 && nSocksVersion != 4 && nSocksVersion != 5)\n+        return false;\n+    if (nSocksVersion != 0 && !addrProxy.IsValid())\n+        return false;\n+    proxyInfo[net] = std::make_pair(addrProxy, nSocksVersion);\n+    return true;\n+}\n+\n+bool GetProxy(enum Network net, CService &addrProxy) {\n+    assert(net >= 0 && net < NET_MAX);\n+    if (!proxyInfo[net].second)\n+        return false;\n+    addrProxy = proxyInfo[net].first;\n+    return true;\n+}\n+\n+bool SetNameProxy(CService addrProxy, int nSocksVersion) {\n+    if (nSocksVersion != 0 && nSocksVersion != 5)\n+        return false;\n+    if (nSocksVersion != 0 && !addrProxy.IsValid())\n+        return false;\n+    nameproxyInfo = std::make_pair(addrProxy, nSocksVersion);\n+    return true;\n+}\n+\n+bool GetNameProxy() {\n+    return nameproxyInfo.second != 0;\n+}\n+\n+bool IsProxy(const CNetAddr &addr) {\n+    for (int i=0; i<NET_MAX; i++) {\n+        if (proxyInfo[i].second && (addr == (CNetAddr)proxyInfo[i].first))\n+            return true;\n+    }\n+    return false;\n+}\n+\n bool ConnectSocket(const CService &addrDest, SOCKET& hSocketRet, int nTimeout)\n {\n+    const proxyType &proxy = proxyInfo[addrDest.GetNetwork()];\n+\n+    // no proxy needed\n+    if (!proxy.second)\n+        return ConnectSocketDirectly(addrDest, hSocketRet, nTimeout);\n+\n     SOCKET hSocket = INVALID_SOCKET;\n-    bool fProxy = (fUseProxy && addrDest.IsRoutable() && !vfNoProxy[addrDest.GetNetwork()]);\n \n-    if (!ConnectSocketDirectly(fProxy ? addrProxy : addrDest, hSocket, nTimeout))\n+    // first connect to proxy server\n+    if (!ConnectSocketDirectly(proxy.first, hSocket, nTimeout))\n+        return false;\n+ \n+    // do socks negotiation\n+    switch (proxy.second) {\n+    case 4:\n+        if (!Socks4(addrDest, hSocket))\n+            return false;\n+        break;\n+    case 5:\n+        if (!Socks5(addrDest.ToStringIP(), addrDest.GetPort(), hSocket))\n+            return false;\n+        break;\n+    default:\n         return false;\n-\n-    if (fProxy)\n-    {\n-        switch(nSocksVersion)\n-        {\n-            case 4:\n-                if (!Socks4(addrDest, hSocket))\n-                    return false;\n-                break;\n-\n-            case 5:\n-            default:\n-                if (!Socks5(addrDest.ToStringIP(), addrDest.GetPort(), hSocket))\n-                    return false;\n-                break;\n-        } \n     }\n \n     hSocketRet = hSocket;\n@@ -465,6 +499,7 @@ bool ConnectSocketByName(CService &addr, SOCKET& hSocketRet, const char *pszDest\n     string strDest(pszDest);\n     int port = portDefault;\n \n+    // split hostname and port\n     size_t colon = strDest.find_last_of(':');\n     if (colon != strDest.npos) {\n         char *endp = NULL;\n@@ -479,26 +514,26 @@ bool ConnectSocketByName(CService &addr, SOCKET& hSocketRet, const char *pszDest\n         strDest = strDest.substr(1, strDest.size()-2);\n \n     SOCKET hSocket = INVALID_SOCKET;\n-    CService addrResolved(CNetAddr(strDest, fNameLookup && !fProxyNameLookup), port);\n+    CService addrResolved(CNetAddr(strDest, fNameLookup && !nameproxyInfo.second), port);\n     if (addrResolved.IsValid()) {\n         addr = addrResolved;\n         return ConnectSocket(addr, hSocketRet, nTimeout);\n     }\n     addr = CService(\"0.0.0.0:0\");\n-    if (!fNameLookup)\n+    if (!nameproxyInfo.second)\n         return false;\n-    if (!ConnectSocketDirectly(addrProxy, hSocket, nTimeout))\n+    if (!ConnectSocketDirectly(nameproxyInfo.first, hSocket, nTimeout))\n         return false;\n \n-    switch(nSocksVersion)\n-        {\n-            case 4: return false;\n-            case 5:\n-            default:\n-                if (!Socks5(strDest, port, hSocket))\n-                    return false;\n-                break;\n-        }\n+    switch(nameproxyInfo.second)\n+    {\n+        default:\n+        case 4: return false;\n+        case 5:\n+            if (!Socks5(strDest, port, hSocket))\n+                return false;\n+            break;\n+    }\n \n     hSocketRet = hSocket;\n     return true;"
      },
      {
        "sha": "0f6fc9b49938768d0d7e848d12e8fe4c14f3cf2a",
        "filename": "src/netbase.h",
        "status": "modified",
        "additions": 8,
        "deletions": 9,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/587f929c6462698a674fe8add2f301161219d05a/src/netbase.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/587f929c6462698a674fe8add2f301161219d05a/src/netbase.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.h?ref=587f929c6462698a674fe8add2f301161219d05a",
        "patch": "@@ -28,8 +28,8 @@ enum Network\n     NET_MAX\n };\n \n-enum Network ParseNetwork(std::string net);\n-void SetNoProxy(enum Network net, bool fNoProxy = true);\n+extern int nConnectTimeout;\n+extern bool fNameLookup;\n \n /** IP address (IPv6, or IPv4 using mapped IPv6 range (::FFFF:0:0/96)) */\n class CNetAddr\n@@ -132,6 +132,12 @@ class CService : public CNetAddr\n             )\n };\n \n+enum Network ParseNetwork(std::string net);\n+bool SetProxy(enum Network net, CService addrProxy, int nSocksVersion = 5);\n+bool GetProxy(enum Network net, CService &addrProxy);\n+bool IsProxy(const CNetAddr &addr);\n+bool SetNameProxy(CService addrProxy, int nSocksVersion = 5);\n+bool GetNameProxy();\n bool LookupHost(const char *pszName, std::vector<CNetAddr>& vIP, unsigned int nMaxSolutions = 0, bool fAllowLookup = true);\n bool LookupHostNumeric(const char *pszName, std::vector<CNetAddr>& vIP, unsigned int nMaxSolutions = 0);\n bool Lookup(const char *pszName, CService& addr, int portDefault = 0, bool fAllowLookup = true);\n@@ -140,11 +146,4 @@ bool LookupNumeric(const char *pszName, CService& addr, int portDefault = 0);\n bool ConnectSocket(const CService &addr, SOCKET& hSocketRet, int nTimeout = nConnectTimeout);\n bool ConnectSocketByName(CService &addr, SOCKET& hSocketRet, const char *pszDest, int portDefault = 0, int nTimeout = nConnectTimeout);\n \n-// Settings\n-extern int nSocksVersion;\n-extern int fUseProxy;\n-extern bool fProxyNameLookup;\n-extern bool fNameLookup;\n-extern CService addrProxy;\n-\n #endif"
      },
      {
        "sha": "50374ddc4be432f4c86f15265b0f402cc782236d",
        "filename": "src/qt/optionsdialog.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/587f929c6462698a674fe8add2f301161219d05a/src/qt/optionsdialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/587f929c6462698a674fe8add2f301161219d05a/src/qt/optionsdialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/optionsdialog.cpp?ref=587f929c6462698a674fe8add2f301161219d05a",
        "patch": "@@ -390,7 +390,7 @@ void NetworkOptionsPage::setMapper(MonitoredDataMapper *mapper)\n {\n     // Map model to widgets\n     mapper->addMapping(map_port_upnp, OptionsModel::MapPortUPnP);\n-    mapper->addMapping(connect_socks4, OptionsModel::ConnectSOCKS4);\n+    mapper->addMapping(connect_socks4, OptionsModel::ProxyUse);\n     mapper->addMapping(proxy_ip, OptionsModel::ProxyIP);\n     mapper->addMapping(proxy_port, OptionsModel::ProxyPort);\n }"
      },
      {
        "sha": "e65694bb5201294f057d05bd2738de8f9dafbfb6",
        "filename": "src/qt/optionsmodel.cpp",
        "status": "modified",
        "additions": 55,
        "deletions": 15,
        "changes": 70,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/587f929c6462698a674fe8add2f301161219d05a/src/qt/optionsmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/587f929c6462698a674fe8add2f301161219d05a/src/qt/optionsmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/optionsmodel.cpp?ref=587f929c6462698a674fe8add2f301161219d05a",
        "patch": "@@ -12,6 +12,29 @@ OptionsModel::OptionsModel(QObject *parent) :\n     Init();\n }\n \n+bool static ApplyProxySettings()\n+{\n+    QSettings settings;\n+    CService addrProxy(settings.value(\"addrProxy\", \"127.0.0.1:9050\").toString().toStdString());\n+    int nSocksVersion(settings.value(\"nSocksVersion\", 5).toInt());\n+    if (!settings.value(\"fUseProxy\", false).toBool()) {\n+        addrProxy = CService();\n+        nSocksVersion = 0;\n+    }\n+    if (nSocksVersion && !addrProxy.IsValid())\n+        return false;\n+    if (!IsLimited(NET_IPV4))\n+        SetProxy(NET_IPV4, addrProxy, nSocksVersion);\n+    if (nSocksVersion > 4) {\n+#ifdef USE_IPV6\n+        if (!IsLimited(NET_IPV6))\n+            SetProxy(NET_IPV6, addrProxy, nSocksVersion);\n+#endif\n+        SetNameProxy(addrProxy, nSocksVersion);\n+    }\n+    return true;\n+}\n+\n void OptionsModel::Init()\n {\n     QSettings settings;\n@@ -75,20 +98,21 @@ bool OptionsModel::Upgrade()\n         CAddress addrProxyAddress;\n         if (walletdb.ReadSetting(\"addrProxy\", addrProxyAddress))\n         {\n-            addrProxy = addrProxyAddress;\n-            settings.setValue(\"addrProxy\", addrProxy.ToStringIPPort().c_str());\n+            settings.setValue(\"addrProxy\", addrProxyAddress.ToStringIPPort().c_str());\n             walletdb.EraseSetting(\"addrProxy\");\n         }\n     }\n     catch (std::ios_base::failure &e)\n     {\n         // 0.6.0rc1 saved this as a CService, which causes failure when parsing as a CAddress\n+        CService addrProxy;\n         if (walletdb.ReadSetting(\"addrProxy\", addrProxy))\n         {\n             settings.setValue(\"addrProxy\", addrProxy.ToStringIPPort().c_str());\n             walletdb.EraseSetting(\"addrProxy\");\n         }\n     }\n+    ApplyProxySettings();\n     Init();\n \n     return true;\n@@ -115,12 +139,24 @@ QVariant OptionsModel::data(const QModelIndex & index, int role) const\n             return settings.value(\"fUseUPnP\", GetBoolArg(\"-upnp\", true));\n         case MinimizeOnClose:\n             return QVariant(fMinimizeOnClose);\n-        case ConnectSOCKS4:\n+        case ProxyUse:\n             return settings.value(\"fUseProxy\", false);\n-        case ProxyIP:\n-            return QVariant(QString::fromStdString(addrProxy.ToStringIP()));\n-        case ProxyPort:\n-            return QVariant(addrProxy.GetPort());\n+        case ProxySocksVersion:\n+            return settings.value(\"nSocksVersion\", false);\n+        case ProxyIP: {\n+            CService addrProxy;\n+            if (GetProxy(NET_IPV4, addrProxy))\n+                return QVariant(QString::fromStdString(addrProxy.ToStringIP()));\n+            else\n+                return QVariant(QString::fromStdString(\"localhost\"));\n+        }\n+        case ProxyPort: {\n+            CService addrProxy;\n+            if (GetProxy(NET_IPV4, addrProxy))\n+                return QVariant(addrProxy.GetPort());\n+            else\n+                return 9050;\n+        }\n         case Fee:\n             return QVariant(nTransactionFee);\n         case DisplayUnit:\n@@ -137,7 +173,6 @@ QVariant OptionsModel::data(const QModelIndex & index, int role) const\n     }\n     return QVariant();\n }\n-\n bool OptionsModel::setData(const QModelIndex & index, const QVariant & value, int role)\n {\n     bool successful = true; /* set to false on parse error */\n@@ -155,27 +190,29 @@ bool OptionsModel::setData(const QModelIndex & index, const QVariant & value, in\n             break;\n         case MapPortUPnP:\n             {\n-                bool bUseUPnP = value.toBool();\n-                settings.setValue(\"fUseUPnP\", bUseUPnP);\n-                MapPort(bUseUPnP);\n+                fUseUPnP = value.toBool();\n+                settings.setValue(\"fUseUPnP\", fUseUPnP);\n+                MapPort();\n             }\n             break;\n         case MinimizeOnClose:\n             fMinimizeOnClose = value.toBool();\n             settings.setValue(\"fMinimizeOnClose\", fMinimizeOnClose);\n             break;\n-        case ConnectSOCKS4:\n-            fUseProxy = value.toBool();\n-            settings.setValue(\"fUseProxy\", fUseProxy);\n+        case ProxyUse:\n+            settings.setValue(\"fUseProxy\", value.toBool());\n+            ApplyProxySettings();\n             break;\n         case ProxyIP:\n             {\n-                // Use CAddress to parse and check IP\n+                CService addrProxy(\"127.0.0.1\", 9050);\n+                GetProxy(NET_IPV4, addrProxy);\n                 CNetAddr addr(value.toString().toStdString());\n                 if (addr.IsValid())\n                 {\n                     addrProxy.SetIP(addr);\n                     settings.setValue(\"addrProxy\", addrProxy.ToStringIPPort().c_str());\n+                    successful = ApplyProxySettings();\n                 }\n                 else\n                 {\n@@ -185,11 +222,14 @@ bool OptionsModel::setData(const QModelIndex & index, const QVariant & value, in\n             break;\n         case ProxyPort:\n             {\n+                CService addrProxy(\"127.0.0.1\", 9050);\n+                GetProxy(NET_IPV4, addrProxy);\n                 int nPort = atoi(value.toString().toAscii().data());\n                 if (nPort > 0 && nPort < std::numeric_limits<unsigned short>::max())\n                 {\n                     addrProxy.SetPort(nPort);\n                     settings.setValue(\"addrProxy\", addrProxy.ToStringIPPort().c_str());\n+                    successful = ApplyProxySettings();\n                 }\n                 else\n                 {"
      },
      {
        "sha": "c74a8dfb43b919ee852632df4d36459a2c4f6f83",
        "filename": "src/qt/optionsmodel.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/587f929c6462698a674fe8add2f301161219d05a/src/qt/optionsmodel.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/587f929c6462698a674fe8add2f301161219d05a/src/qt/optionsmodel.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/optionsmodel.h?ref=587f929c6462698a674fe8add2f301161219d05a",
        "patch": "@@ -20,7 +20,8 @@ class OptionsModel : public QAbstractListModel\n         MinimizeToTray, // bool\n         MapPortUPnP, // bool\n         MinimizeOnClose, // bool\n-        ConnectSOCKS4, // bool\n+        ProxyUse, // bool\n+        ProxySocksVersion, // int\n         ProxyIP, // QString\n         ProxyPort, // QString\n         Fee, // qint64"
      }
    ]
  }
]