[
  {
    "sha": "5891f870d68d90408aa5ce5b597fb574f2d2cbca",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1ODkxZjg3MGQ2OGQ5MDQwOGFhNWNlNWI1OTdmYjU3NGYyZDJjYmNh",
    "commit": {
      "author": {
        "name": "Peter Todd",
        "email": "pete@petertodd.org",
        "date": "2015-10-22T18:13:18Z"
      },
      "committer": {
        "name": "Peter Todd",
        "email": "pete@petertodd.org",
        "date": "2015-11-10T19:14:06Z"
      },
      "message": "Add opt-in full-RBF to mempool\n\nReplaces transactions already in the mempool if a new transaction seen\nwith a higher fee, specifically both a higher fee per KB and a higher\nabsolute fee. Children are evaluateed for replacement as well, using the\nmempool package tracking to calculate replaced fees/size. Transactions\ncan opt-out of transaction replacement by setting nSequence >= maxint-1\non all inputs. (which all wallets do already)",
      "tree": {
        "sha": "eb7c975bcace8a191f1d88db8a78c73c58ccb8fe",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/eb7c975bcace8a191f1d88db8a78c73c58ccb8fe"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5891f870d68d90408aa5ce5b597fb574f2d2cbca",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5891f870d68d90408aa5ce5b597fb574f2d2cbca",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5891f870d68d90408aa5ce5b597fb574f2d2cbca",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5891f870d68d90408aa5ce5b597fb574f2d2cbca/comments",
    "author": {
      "login": "petertodd",
      "id": 7042,
      "node_id": "MDQ6VXNlcjcwNDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7042?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/petertodd",
      "html_url": "https://github.com/petertodd",
      "followers_url": "https://api.github.com/users/petertodd/followers",
      "following_url": "https://api.github.com/users/petertodd/following{/other_user}",
      "gists_url": "https://api.github.com/users/petertodd/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/petertodd/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/petertodd/subscriptions",
      "organizations_url": "https://api.github.com/users/petertodd/orgs",
      "repos_url": "https://api.github.com/users/petertodd/repos",
      "events_url": "https://api.github.com/users/petertodd/events{/privacy}",
      "received_events_url": "https://api.github.com/users/petertodd/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "petertodd",
      "id": 7042,
      "node_id": "MDQ6VXNlcjcwNDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7042?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/petertodd",
      "html_url": "https://github.com/petertodd",
      "followers_url": "https://api.github.com/users/petertodd/followers",
      "following_url": "https://api.github.com/users/petertodd/following{/other_user}",
      "gists_url": "https://api.github.com/users/petertodd/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/petertodd/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/petertodd/subscriptions",
      "organizations_url": "https://api.github.com/users/petertodd/orgs",
      "repos_url": "https://api.github.com/users/petertodd/repos",
      "events_url": "https://api.github.com/users/petertodd/events{/privacy}",
      "received_events_url": "https://api.github.com/users/petertodd/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "de7d4591a7ce064ba64c36ccb729f1d94c21aa90",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/de7d4591a7ce064ba64c36ccb729f1d94c21aa90",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/de7d4591a7ce064ba64c36ccb729f1d94c21aa90"
      }
    ],
    "stats": {
      "total": 126,
      "additions": 121,
      "deletions": 5
    },
    "files": [
      {
        "sha": "274a336ee2fb14f4088d790f6c8b1bc070b8d74d",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 121,
        "deletions": 5,
        "changes": 126,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5891f870d68d90408aa5ce5b597fb574f2d2cbca/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5891f870d68d90408aa5ce5b597fb574f2d2cbca/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=5891f870d68d90408aa5ce5b597fb574f2d2cbca",
        "patch": "@@ -831,15 +831,42 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n         return state.Invalid(false, REJECT_ALREADY_KNOWN, \"txn-already-in-mempool\");\n \n     // Check for conflicts with in-memory transactions\n+    set<uint256> setConflicts;\n     {\n     LOCK(pool.cs); // protect pool.mapNextTx\n-    for (unsigned int i = 0; i < tx.vin.size(); i++)\n+    BOOST_FOREACH(const CTxIn &txin, tx.vin)\n     {\n-        COutPoint outpoint = tx.vin[i].prevout;\n-        if (pool.mapNextTx.count(outpoint))\n+        if (pool.mapNextTx.count(txin.prevout))\n         {\n-            // Disable replacement feature for now\n-            return state.Invalid(false, REJECT_CONFLICT, \"txn-mempool-conflict\");\n+            const CTransaction *ptxConflicting = pool.mapNextTx[txin.prevout].ptx;\n+            if (!setConflicts.count(ptxConflicting->GetHash()))\n+            {\n+                // Allow opt-out of transaction replacement by setting\n+                // nSequence >= maxint-1 on all inputs.\n+                //\n+                // maxint-1 is picked to still allow use of nLockTime by\n+                // non-replacable transactions. All inputs rather than just one\n+                // is for the sake of multi-party protocols, where we don't\n+                // want a single party to be able to disable replacement.\n+                //\n+                // The opt-out ignores descendants as anyone relying on\n+                // first-seen mempool behavior should be checking all\n+                // unconfirmed ancestors anyway; doing otherwise is hopelessly\n+                // insecure.\n+                bool fReplacementOptOut = true;\n+                BOOST_FOREACH(const CTxIn &txin, ptxConflicting->vin)\n+                {\n+                    if (txin.nSequence < std::numeric_limits<unsigned int>::max()-1)\n+                    {\n+                        fReplacementOptOut = false;\n+                        break;\n+                    }\n+                }\n+                if (fReplacementOptOut)\n+                    return state.Invalid(false, REJECT_CONFLICT, \"txn-mempool-conflict\");\n+\n+                setConflicts.insert(ptxConflicting->GetHash());\n+            }\n         }\n     }\n     }\n@@ -957,6 +984,82 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n             return state.DoS(0, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", false, errString);\n         }\n \n+        // A transaction that spends outputs that would be replaced by it is invalid. Now\n+        // that we have the set of all ancestors we can detect this\n+        // pathological case by making sure setConflicts and setAncestors don't\n+        // intersect.\n+        BOOST_FOREACH(CTxMemPool::txiter ancestorIt, setAncestors)\n+        {\n+            const uint256 &hashAncestor = ancestorIt->GetTx().GetHash();\n+            if (setConflicts.count(hashAncestor))\n+            {\n+                return state.DoS(10, error(\"AcceptToMemoryPool: %s spends conflicting transaction %s\",\n+                                           hash.ToString(),\n+                                           hashAncestor.ToString()),\n+                                 REJECT_INVALID, \"bad-txns-spends-conflicting-tx\");\n+            }\n+        }\n+\n+        // Check if it's economically rational to mine this transaction rather\n+        // than the ones it replaces.\n+        CAmount nConflictingFees = 0;\n+        size_t nConflictingSize = 0;\n+        if (setConflicts.size())\n+        {\n+            LOCK(pool.cs);\n+\n+            // For efficiency we simply sum up the pre-calculated\n+            // fees/size-with-descendants values from the mempool package\n+            // tracking; this does mean the pathological case of diamond tx\n+            // graphs will be overcounted.\n+            BOOST_FOREACH(const uint256 hashConflicting, setConflicts)\n+            {\n+                CTxMemPool::txiter mi = pool.mapTx.find(hashConflicting);\n+                if (mi == pool.mapTx.end())\n+                    continue;\n+                nConflictingFees += mi->GetFeesWithDescendants();\n+                nConflictingSize += mi->GetSizeWithDescendants();\n+            }\n+\n+            // First of all we can't allow a replacement unless it pays greater\n+            // fees than the transactions it conflicts with - if we did the\n+            // bandwidth used by those conflicting transactions would not be\n+            // paid for\n+            if (nFees < nConflictingFees)\n+            {\n+                return state.DoS(0, error(\"AcceptToMemoryPool: rejecting replacement %s, less fees than conflicting txs; %s < %s\",\n+                                          hash.ToString(), FormatMoney(nFees), FormatMoney(nConflictingFees)),\n+                                 REJECT_INSUFFICIENTFEE, \"insufficient fee\");\n+            }\n+\n+            // Secondly in addition to paying more fees than the conflicts the\n+            // new transaction must additionally pay for its own bandwidth.\n+            CAmount nDeltaFees = nFees - nConflictingFees;\n+            if (nDeltaFees < ::minRelayTxFee.GetFee(nSize))\n+            {\n+                return state.DoS(0,\n+                        error(\"AcceptToMemoryPool: rejecting replacement %s, not enough additional fees to relay; %s < %s\",\n+                              hash.ToString(),\n+                              FormatMoney(nDeltaFees),\n+                              FormatMoney(::minRelayTxFee.GetFee(nSize))),\n+                        REJECT_INSUFFICIENTFEE, \"insufficient fee\");\n+            }\n+\n+            // Finally replace only if we end up with a larger fees-per-kb than\n+            // the replacements.\n+            CFeeRate oldFeeRate(nConflictingFees, nConflictingSize);\n+            CFeeRate newFeeRate(nFees, nSize);\n+            if (newFeeRate <= oldFeeRate)\n+            {\n+                return state.DoS(0,\n+                        error(\"AcceptToMemoryPool: rejecting replacement %s; new feerate %s <= old feerate %s\",\n+                              hash.ToString(),\n+                              newFeeRate.ToString(),\n+                              oldFeeRate.ToString()),\n+                        REJECT_INSUFFICIENTFEE, \"insufficient fee\");\n+            }\n+        }\n+\n         // Check against previous transactions\n         // This is done last to help prevent CPU exhaustion denial-of-service attacks.\n         if (!CheckInputs(tx, state, view, true, STANDARD_SCRIPT_VERIFY_FLAGS, true))\n@@ -977,6 +1080,19 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n                 __func__, hash.ToString(), FormatStateMessage(state));\n         }\n \n+        // Remove conflicting transactions from the mempool\n+        list<CTransaction> ltxConflicted;\n+        pool.removeConflicts(tx, ltxConflicted);\n+\n+        BOOST_FOREACH(const CTransaction &txConflicted, ltxConflicted)\n+        {\n+            LogPrint(\"mempool\", \"replacing tx %s with %s for %s BTC additional fees, %d delta bytes\\n\",\n+                    txConflicted.GetHash().ToString(),\n+                    hash.ToString(),\n+                    FormatMoney(nFees - nConflictingFees),\n+                    (int)nSize - (int)nConflictingSize);\n+        }\n+\n         // Store transaction in memory\n         pool.addUnchecked(hash, entry, setAncestors, !IsInitialBlockDownload());\n "
      }
    ]
  },
  {
    "sha": "0137e6fafd08788879193c1155883364237869f1",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowMTM3ZTZmYWZkMDg3ODg4NzkxOTNjMTE1NTg4MzM2NDIzNzg2OWYx",
    "commit": {
      "author": {
        "name": "Peter Todd",
        "email": "pete@petertodd.org",
        "date": "2015-10-22T21:05:52Z"
      },
      "committer": {
        "name": "Peter Todd",
        "email": "pete@petertodd.org",
        "date": "2015-11-10T19:14:07Z"
      },
      "message": "Add tests for transaction replacement",
      "tree": {
        "sha": "e9450f16329e5276b65fc023af81fb6e32e8c0fa",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e9450f16329e5276b65fc023af81fb6e32e8c0fa"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0137e6fafd08788879193c1155883364237869f1",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0137e6fafd08788879193c1155883364237869f1",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0137e6fafd08788879193c1155883364237869f1",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0137e6fafd08788879193c1155883364237869f1/comments",
    "author": {
      "login": "petertodd",
      "id": 7042,
      "node_id": "MDQ6VXNlcjcwNDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7042?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/petertodd",
      "html_url": "https://github.com/petertodd",
      "followers_url": "https://api.github.com/users/petertodd/followers",
      "following_url": "https://api.github.com/users/petertodd/following{/other_user}",
      "gists_url": "https://api.github.com/users/petertodd/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/petertodd/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/petertodd/subscriptions",
      "organizations_url": "https://api.github.com/users/petertodd/orgs",
      "repos_url": "https://api.github.com/users/petertodd/repos",
      "events_url": "https://api.github.com/users/petertodd/events{/privacy}",
      "received_events_url": "https://api.github.com/users/petertodd/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "petertodd",
      "id": 7042,
      "node_id": "MDQ6VXNlcjcwNDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7042?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/petertodd",
      "html_url": "https://github.com/petertodd",
      "followers_url": "https://api.github.com/users/petertodd/followers",
      "following_url": "https://api.github.com/users/petertodd/following{/other_user}",
      "gists_url": "https://api.github.com/users/petertodd/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/petertodd/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/petertodd/subscriptions",
      "organizations_url": "https://api.github.com/users/petertodd/orgs",
      "repos_url": "https://api.github.com/users/petertodd/repos",
      "events_url": "https://api.github.com/users/petertodd/events{/privacy}",
      "received_events_url": "https://api.github.com/users/petertodd/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5891f870d68d90408aa5ce5b597fb574f2d2cbca",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5891f870d68d90408aa5ce5b597fb574f2d2cbca",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5891f870d68d90408aa5ce5b597fb574f2d2cbca"
      }
    ],
    "stats": {
      "total": 294,
      "additions": 294,
      "deletions": 0
    },
    "files": [
      {
        "sha": "b2c4f4657aebb1a2bffcc5e7a7d1c3bcdefdd56f",
        "filename": "qa/replace-by-fee/.gitignore",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0137e6fafd08788879193c1155883364237869f1/qa/replace-by-fee/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0137e6fafd08788879193c1155883364237869f1/qa/replace-by-fee/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/replace-by-fee/.gitignore?ref=0137e6fafd08788879193c1155883364237869f1",
        "patch": "@@ -0,0 +1 @@\n+python-bitcoinlib"
      },
      {
        "sha": "baad86de9a47564132aa68f805982bd0eb49c3ad",
        "filename": "qa/replace-by-fee/README.md",
        "status": "added",
        "additions": 13,
        "deletions": 0,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0137e6fafd08788879193c1155883364237869f1/qa/replace-by-fee/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0137e6fafd08788879193c1155883364237869f1/qa/replace-by-fee/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/replace-by-fee/README.md?ref=0137e6fafd08788879193c1155883364237869f1",
        "patch": "@@ -0,0 +1,13 @@\n+Replace-by-fee regression tests\n+===============================\n+\n+First get version v0.5.0 of the python-bitcoinlib library. In this directory\n+run:\n+\n+    git clone -n https://github.com/petertodd/python-bitcoinlib\n+    (cd python-bitcoinlib && git checkout 8270bfd9c6ac37907d75db3d8b9152d61c7255cd)\n+\n+Then run the tests themselves with a bitcoind available running in regtest\n+mode:\n+\n+    ./rbf-tests.py"
      },
      {
        "sha": "391159a86aaa7f19f7a5911f612c77381b8dbe32",
        "filename": "qa/replace-by-fee/rbf-tests.py",
        "status": "added",
        "additions": 280,
        "deletions": 0,
        "changes": 280,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0137e6fafd08788879193c1155883364237869f1/qa/replace-by-fee/rbf-tests.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0137e6fafd08788879193c1155883364237869f1/qa/replace-by-fee/rbf-tests.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/replace-by-fee/rbf-tests.py?ref=0137e6fafd08788879193c1155883364237869f1",
        "patch": "@@ -0,0 +1,280 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2015 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#\n+# Test replace-by-fee\n+#\n+\n+import os\n+import sys\n+\n+# Add python-bitcoinlib to module search path:\n+sys.path.append(os.path.join(os.path.dirname(os.path.abspath(__file__)), \"python-bitcoinlib\"))\n+\n+import unittest\n+\n+import bitcoin\n+bitcoin.SelectParams('regtest')\n+\n+import bitcoin.rpc\n+\n+from bitcoin.core import *\n+from bitcoin.core.script import *\n+from bitcoin.wallet import *\n+\n+MAX_REPLACEMENT_LIMIT = 100\n+\n+class Test_ReplaceByFee(unittest.TestCase):\n+    proxy = None\n+\n+    @classmethod\n+    def setUpClass(cls):\n+        if cls.proxy is None:\n+            cls.proxy = bitcoin.rpc.Proxy()\n+\n+    @classmethod\n+    def tearDownClass(cls):\n+        # Make sure mining works\n+        mempool_size = 1\n+        while mempool_size:\n+            cls.proxy.call('generate',1)\n+            new_mempool_size = len(cls.proxy.getrawmempool())\n+\n+            # It's possible to get stuck in a loop here if the mempool has\n+            # transactions that can't be mined.\n+            assert(new_mempool_size != mempool_size)\n+            mempool_size = new_mempool_size\n+\n+    def make_txout(self, amount, scriptPubKey=CScript([1])):\n+        \"\"\"Create a txout with a given amount and scriptPubKey\n+\n+        Mines coins as needed.\n+        \"\"\"\n+        fee = 1*COIN\n+        while self.proxy.getbalance() < amount + fee:\n+            self.proxy.call('generate', 100)\n+\n+        addr = P2SHBitcoinAddress.from_redeemScript(CScript([]))\n+        txid = self.proxy.sendtoaddress(addr, amount + fee)\n+\n+        tx1 = self.proxy.getrawtransaction(txid)\n+\n+        i = None\n+        for i, txout in enumerate(tx1.vout):\n+            if txout.scriptPubKey == addr.to_scriptPubKey():\n+                break\n+        assert i is not None\n+\n+        tx2 = CTransaction([CTxIn(COutPoint(txid, i), CScript([1, CScript([])]), nSequence=0)],\n+                           [CTxOut(amount, scriptPubKey)])\n+\n+        tx2_txid = self.proxy.sendrawtransaction(tx2, True)\n+\n+        return COutPoint(tx2_txid, 0)\n+\n+    def test_simple_doublespend(self):\n+        \"\"\"Simple doublespend\"\"\"\n+        tx0_outpoint = self.make_txout(1.1*COIN)\n+\n+        tx1a = CTransaction([CTxIn(tx0_outpoint, nSequence=0)],\n+                            [CTxOut(1*COIN, CScript([b'a']))])\n+        tx1a_txid = self.proxy.sendrawtransaction(tx1a, True)\n+\n+        # Should fail because we haven't changed the fee\n+        tx1b = CTransaction([CTxIn(tx0_outpoint, nSequence=0)],\n+                            [CTxOut(1*COIN, CScript([b'b']))])\n+\n+        try:\n+            tx1b_txid = self.proxy.sendrawtransaction(tx1b, True)\n+        except bitcoin.rpc.JSONRPCException as exp:\n+            self.assertEqual(exp.error['code'], -26) # insufficient fee\n+        else:\n+            self.fail()\n+\n+        # Extra 0.1 BTC fee\n+        tx1b = CTransaction([CTxIn(tx0_outpoint, nSequence=0)],\n+                            [CTxOut(0.9*COIN, CScript([b'b']))])\n+        tx1b_txid = self.proxy.sendrawtransaction(tx1b, True)\n+\n+        # tx1a is in fact replaced\n+        with self.assertRaises(IndexError):\n+            self.proxy.getrawtransaction(tx1a_txid)\n+\n+        self.assertEqual(tx1b, self.proxy.getrawtransaction(tx1b_txid))\n+\n+    def test_doublespend_chain(self):\n+        \"\"\"Doublespend of a long chain\"\"\"\n+\n+        initial_nValue = 50*COIN\n+        tx0_outpoint = self.make_txout(initial_nValue)\n+\n+        prevout = tx0_outpoint\n+        remaining_value = initial_nValue\n+        chain_txids = []\n+        while remaining_value > 10*COIN:\n+            remaining_value -= 1*COIN\n+            tx = CTransaction([CTxIn(prevout, nSequence=0)],\n+                              [CTxOut(remaining_value, CScript([1]))])\n+            txid = self.proxy.sendrawtransaction(tx, True)\n+            chain_txids.append(txid)\n+            prevout = COutPoint(txid, 0)\n+\n+        # Whether the double-spend is allowed is evaluated by including all\n+        # child fees - 40 BTC - so this attempt is rejected.\n+        dbl_tx = CTransaction([CTxIn(tx0_outpoint, nSequence=0)],\n+                              [CTxOut(initial_nValue - 30*COIN, CScript([1]))])\n+\n+        try:\n+            self.proxy.sendrawtransaction(dbl_tx, True)\n+        except bitcoin.rpc.JSONRPCException as exp:\n+            self.assertEqual(exp.error['code'], -26) # insufficient fee\n+        else:\n+            self.fail()\n+\n+        # Accepted with sufficient fee\n+        dbl_tx = CTransaction([CTxIn(tx0_outpoint, nSequence=0)],\n+                              [CTxOut(1*COIN, CScript([1]))])\n+        self.proxy.sendrawtransaction(dbl_tx, True)\n+\n+        for doublespent_txid in chain_txids:\n+            with self.assertRaises(IndexError):\n+                self.proxy.getrawtransaction(doublespent_txid)\n+\n+    def test_doublespend_tree(self):\n+        \"\"\"Doublespend of a big tree of transactions\"\"\"\n+\n+        initial_nValue = 50*COIN\n+        tx0_outpoint = self.make_txout(initial_nValue)\n+\n+        def branch(prevout, initial_value, max_txs, *, tree_width=5, fee=0.0001*COIN, _total_txs=None):\n+            if _total_txs is None:\n+                _total_txs = [0]\n+            if _total_txs[0] >= max_txs:\n+                return\n+\n+            txout_value = (initial_value - fee) // tree_width\n+            if txout_value < fee:\n+                return\n+\n+            vout = [CTxOut(txout_value, CScript([i+1]))\n+                    for i in range(tree_width)]\n+            tx = CTransaction([CTxIn(prevout, nSequence=0)],\n+                              vout)\n+\n+            self.assertTrue(len(tx.serialize()) < 100000)\n+            txid = self.proxy.sendrawtransaction(tx, True)\n+            yield tx\n+            _total_txs[0] += 1\n+\n+            for i, txout in enumerate(tx.vout):\n+                yield from branch(COutPoint(txid, i), txout_value,\n+                                  max_txs,\n+                                  tree_width=tree_width, fee=fee,\n+                                  _total_txs=_total_txs)\n+\n+        fee = 0.0001*COIN\n+        n = MAX_REPLACEMENT_LIMIT\n+        tree_txs = list(branch(tx0_outpoint, initial_nValue, n, fee=fee))\n+        self.assertEqual(len(tree_txs), n)\n+\n+        # Attempt double-spend, will fail because too little fee paid\n+        dbl_tx = CTransaction([CTxIn(tx0_outpoint, nSequence=0)],\n+                              [CTxOut(initial_nValue - fee*n, CScript([1]))])\n+        try:\n+            self.proxy.sendrawtransaction(dbl_tx, True)\n+        except bitcoin.rpc.JSONRPCException as exp:\n+            self.assertEqual(exp.error['code'], -26) # insufficient fee\n+        else:\n+            self.fail()\n+\n+        # 1 BTC fee is enough\n+        dbl_tx = CTransaction([CTxIn(tx0_outpoint, nSequence=0)],\n+                              [CTxOut(initial_nValue - fee*n - 1*COIN, CScript([1]))])\n+        self.proxy.sendrawtransaction(dbl_tx, True)\n+\n+        for tx in tree_txs:\n+            with self.assertRaises(IndexError):\n+                self.proxy.getrawtransaction(tx.GetHash())\n+\n+        # Try again, but with more total transactions than the \"max txs\n+        # double-spent at once\" anti-DoS limit.\n+        for n in (MAX_REPLACEMENT_LIMIT, MAX_REPLACEMENT_LIMIT*2):\n+            fee = 0.0001*COIN\n+            tx0_outpoint = self.make_txout(initial_nValue)\n+            tree_txs = list(branch(tx0_outpoint, initial_nValue, n, fee=fee))\n+            self.assertEqual(len(tree_txs), n)\n+\n+            dbl_tx = CTransaction([CTxIn(tx0_outpoint, nSequence=0)],\n+                                  [CTxOut(initial_nValue - fee*n, CScript([1]))])\n+            try:\n+                self.proxy.sendrawtransaction(dbl_tx, True)\n+            except bitcoin.rpc.JSONRPCException as exp:\n+                self.assertEqual(exp.error['code'], -26)\n+            else:\n+                self.fail()\n+\n+            for tx in tree_txs:\n+                self.proxy.getrawtransaction(tx.GetHash())\n+\n+    def test_replacement_feeperkb(self):\n+        \"\"\"Replacement requires overall fee-per-KB to be higher\"\"\"\n+        tx0_outpoint = self.make_txout(1.1*COIN)\n+\n+        tx1a = CTransaction([CTxIn(tx0_outpoint, nSequence=0)],\n+                            [CTxOut(1*COIN, CScript([b'a']))])\n+        tx1a_txid = self.proxy.sendrawtransaction(tx1a, True)\n+\n+        # Higher fee, but the fee per KB is much lower, so the replacement is\n+        # rejected.\n+        tx1b = CTransaction([CTxIn(tx0_outpoint, nSequence=0)],\n+                            [CTxOut(0.001*COIN,\n+                                    CScript([b'a'*999000]))])\n+\n+        try:\n+            tx1b_txid = self.proxy.sendrawtransaction(tx1b, True)\n+        except bitcoin.rpc.JSONRPCException as exp:\n+            self.assertEqual(exp.error['code'], -26) # insufficient fee\n+        else:\n+            self.fail()\n+\n+    def test_spends_of_conflicting_outputs(self):\n+        \"\"\"Replacements that spend conflicting tx outputs are rejected\"\"\"\n+        utxo1 = self.make_txout(1.2*COIN)\n+        utxo2 = self.make_txout(3.0*COIN)\n+\n+        tx1a = CTransaction([CTxIn(utxo1, nSequence=0)],\n+                            [CTxOut(1.1*COIN, CScript([b'a']))])\n+        tx1a_txid = self.proxy.sendrawtransaction(tx1a, True)\n+\n+        # Direct spend an output of the transaction we're replacing.\n+        tx2 = CTransaction([CTxIn(utxo1, nSequence=0), CTxIn(utxo2, nSequence=0),\n+                            CTxIn(COutPoint(tx1a_txid, 0), nSequence=0)],\n+                           tx1a.vout)\n+\n+        try:\n+            tx2_txid = self.proxy.sendrawtransaction(tx2, True)\n+        except bitcoin.rpc.JSONRPCException as exp:\n+            self.assertEqual(exp.error['code'], -26)\n+        else:\n+            self.fail()\n+\n+        # Spend tx1a's output to test the indirect case.\n+        tx1b = CTransaction([CTxIn(COutPoint(tx1a_txid, 0), nSequence=0)],\n+                            [CTxOut(1.0*COIN, CScript([b'a']))])\n+        tx1b_txid = self.proxy.sendrawtransaction(tx1b, True)\n+\n+        tx2 = CTransaction([CTxIn(utxo1, nSequence=0), CTxIn(utxo2, nSequence=0),\n+                            CTxIn(COutPoint(tx1b_txid, 0))],\n+                           tx1a.vout)\n+\n+        try:\n+            tx2_txid = self.proxy.sendrawtransaction(tx2, True)\n+        except bitcoin.rpc.JSONRPCException as exp:\n+            self.assertEqual(exp.error['code'], -26)\n+        else:\n+            self.fail()\n+\n+if __name__ == '__main__':\n+    unittest.main()"
      }
    ]
  },
  {
    "sha": "fc8c19a07c20ab63f6a69f7494f486204d8f2b7a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYzhjMTlhMDdjMjBhYjYzZjZhNjlmNzQ5NGY0ODYyMDRkOGYyYjdh",
    "commit": {
      "author": {
        "name": "Peter Todd",
        "email": "pete@petertodd.org",
        "date": "2015-10-30T02:55:48Z"
      },
      "committer": {
        "name": "Peter Todd",
        "email": "pete@petertodd.org",
        "date": "2015-11-10T19:14:07Z"
      },
      "message": "Prevent low feerate txs from (directly) replacing high feerate txs\n\nPreviously all conflicting transactions were evaluated as a whole to\ndetermine if the feerate was being increased. This meant that low\nfeerate children pulled the feerate down, potentially allowing a high\ntransaction with a high feerate to be replaced by one with a lower\nfeerate.",
      "tree": {
        "sha": "d238f7f8bc0690e2c5f5f813f97c83632f2c3f72",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d238f7f8bc0690e2c5f5f813f97c83632f2c3f72"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fc8c19a07c20ab63f6a69f7494f486204d8f2b7a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fc8c19a07c20ab63f6a69f7494f486204d8f2b7a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fc8c19a07c20ab63f6a69f7494f486204d8f2b7a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fc8c19a07c20ab63f6a69f7494f486204d8f2b7a/comments",
    "author": {
      "login": "petertodd",
      "id": 7042,
      "node_id": "MDQ6VXNlcjcwNDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7042?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/petertodd",
      "html_url": "https://github.com/petertodd",
      "followers_url": "https://api.github.com/users/petertodd/followers",
      "following_url": "https://api.github.com/users/petertodd/following{/other_user}",
      "gists_url": "https://api.github.com/users/petertodd/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/petertodd/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/petertodd/subscriptions",
      "organizations_url": "https://api.github.com/users/petertodd/orgs",
      "repos_url": "https://api.github.com/users/petertodd/repos",
      "events_url": "https://api.github.com/users/petertodd/events{/privacy}",
      "received_events_url": "https://api.github.com/users/petertodd/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "petertodd",
      "id": 7042,
      "node_id": "MDQ6VXNlcjcwNDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7042?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/petertodd",
      "html_url": "https://github.com/petertodd",
      "followers_url": "https://api.github.com/users/petertodd/followers",
      "following_url": "https://api.github.com/users/petertodd/following{/other_user}",
      "gists_url": "https://api.github.com/users/petertodd/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/petertodd/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/petertodd/subscriptions",
      "organizations_url": "https://api.github.com/users/petertodd/orgs",
      "repos_url": "https://api.github.com/users/petertodd/repos",
      "events_url": "https://api.github.com/users/petertodd/events{/privacy}",
      "received_events_url": "https://api.github.com/users/petertodd/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "0137e6fafd08788879193c1155883364237869f1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0137e6fafd08788879193c1155883364237869f1",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0137e6fafd08788879193c1155883364237869f1"
      }
    ],
    "stats": {
      "total": 64,
      "additions": 39,
      "deletions": 25
    },
    "files": [
      {
        "sha": "5173da64126b805f005c3be7a6ea5003c2d7e67b",
        "filename": "qa/replace-by-fee/rbf-tests.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fc8c19a07c20ab63f6a69f7494f486204d8f2b7a/qa/replace-by-fee/rbf-tests.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fc8c19a07c20ab63f6a69f7494f486204d8f2b7a/qa/replace-by-fee/rbf-tests.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/replace-by-fee/rbf-tests.py?ref=fc8c19a07c20ab63f6a69f7494f486204d8f2b7a",
        "patch": "@@ -219,7 +219,7 @@ def branch(prevout, initial_value, max_txs, *, tree_width=5, fee=0.0001*COIN, _t\n                 self.proxy.getrawtransaction(tx.GetHash())\n \n     def test_replacement_feeperkb(self):\n-        \"\"\"Replacement requires overall fee-per-KB to be higher\"\"\"\n+        \"\"\"Replacement requires fee-per-KB to be higher\"\"\"\n         tx0_outpoint = self.make_txout(1.1*COIN)\n \n         tx1a = CTransaction([CTxIn(tx0_outpoint, nSequence=0)],"
      },
      {
        "sha": "10d661b2a8de37f75b21ca8a0c169db817b7a4b9",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 38,
        "deletions": 24,
        "changes": 62,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fc8c19a07c20ab63f6a69f7494f486204d8f2b7a/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fc8c19a07c20ab63f6a69f7494f486204d8f2b7a/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=fc8c19a07c20ab63f6a69f7494f486204d8f2b7a",
        "patch": "@@ -1008,32 +1008,60 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n         {\n             LOCK(pool.cs);\n \n-            // For efficiency we simply sum up the pre-calculated\n-            // fees/size-with-descendants values from the mempool package\n-            // tracking; this does mean the pathological case of diamond tx\n-            // graphs will be overcounted.\n+            CFeeRate newFeeRate(nFees, nSize);\n             BOOST_FOREACH(const uint256 hashConflicting, setConflicts)\n             {\n                 CTxMemPool::txiter mi = pool.mapTx.find(hashConflicting);\n                 if (mi == pool.mapTx.end())\n                     continue;\n+\n+                // Don't allow the replacement to reduce the feerate of the\n+                // mempool.\n+                //\n+                // We usually don't want to accept replacements with lower\n+                // feerates than what they replaced as that would lower the\n+                // feerate of the next block. Requiring that the feerate always\n+                // be increased is also an easy-to-reason about way to prevent\n+                // DoS attacks via replacements.\n+                //\n+                // The mining code doesn't (currently) take children into\n+                // account (CPFP) so we only consider the feerates of\n+                // transactions being directly replaced, not their indirect\n+                // descendants. While that does mean high feerate children are\n+                // ignored when deciding whether or not to replace, we do\n+                // require the replacement to pay more overall fees too,\n+                // mitigating most cases.\n+                CFeeRate oldFeeRate(mi->GetFee(), mi->GetTxSize());\n+                if (newFeeRate <= oldFeeRate)\n+                {\n+                    return state.DoS(0,\n+                            error(\"AcceptToMemoryPool: rejecting replacement %s; new feerate %s <= old feerate %s\",\n+                                  hash.ToString(),\n+                                  newFeeRate.ToString(),\n+                                  oldFeeRate.ToString()),\n+                            REJECT_INSUFFICIENTFEE, \"insufficient fee\");\n+                }\n+\n+                // For efficiency we simply sum up the pre-calculated\n+                // fees/size-with-descendants values from the mempool package\n+                // tracking; this does mean the pathological case of diamond tx\n+                // graphs will be overcounted.\n                 nConflictingFees += mi->GetFeesWithDescendants();\n                 nConflictingSize += mi->GetSizeWithDescendants();\n             }\n \n-            // First of all we can't allow a replacement unless it pays greater\n-            // fees than the transactions it conflicts with - if we did the\n-            // bandwidth used by those conflicting transactions would not be\n-            // paid for\n+            // The replacement must pay greater fees than the transactions it\n+            // replaces - if we did the bandwidth used by those conflicting\n+            // transactions would not be paid for.\n             if (nFees < nConflictingFees)\n             {\n                 return state.DoS(0, error(\"AcceptToMemoryPool: rejecting replacement %s, less fees than conflicting txs; %s < %s\",\n                                           hash.ToString(), FormatMoney(nFees), FormatMoney(nConflictingFees)),\n                                  REJECT_INSUFFICIENTFEE, \"insufficient fee\");\n             }\n \n-            // Secondly in addition to paying more fees than the conflicts the\n-            // new transaction must additionally pay for its own bandwidth.\n+            // Finally in addition to paying more fees than the conflicts the\n+            // new transaction must pay for its own bandwidth.\n             CAmount nDeltaFees = nFees - nConflictingFees;\n             if (nDeltaFees < ::minRelayTxFee.GetFee(nSize))\n             {\n@@ -1044,20 +1072,6 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n                               FormatMoney(::minRelayTxFee.GetFee(nSize))),\n                         REJECT_INSUFFICIENTFEE, \"insufficient fee\");\n             }\n-\n-            // Finally replace only if we end up with a larger fees-per-kb than\n-            // the replacements.\n-            CFeeRate oldFeeRate(nConflictingFees, nConflictingSize);\n-            CFeeRate newFeeRate(nFees, nSize);\n-            if (newFeeRate <= oldFeeRate)\n-            {\n-                return state.DoS(0,\n-                        error(\"AcceptToMemoryPool: rejecting replacement %s; new feerate %s <= old feerate %s\",\n-                              hash.ToString(),\n-                              newFeeRate.ToString(),\n-                              oldFeeRate.ToString()),\n-                        REJECT_INSUFFICIENTFEE, \"insufficient fee\");\n-            }\n         }\n \n         // Check against previous transactions"
      }
    ]
  },
  {
    "sha": "b272ecfdb39f976dd61e35bacb22047da02b3416",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiMjcyZWNmZGIzOWY5NzZkZDYxZTM1YmFjYjIyMDQ3ZGEwMmIzNDE2",
    "commit": {
      "author": {
        "name": "Peter Todd",
        "email": "pete@petertodd.org",
        "date": "2015-10-30T04:04:00Z"
      },
      "committer": {
        "name": "Peter Todd",
        "email": "pete@petertodd.org",
        "date": "2015-11-10T19:14:07Z"
      },
      "message": "Reject replacements that add new unconfirmed inputs",
      "tree": {
        "sha": "a9897306c70c1940d610fd0d82bcf4b1a8a11664",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a9897306c70c1940d610fd0d82bcf4b1a8a11664"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b272ecfdb39f976dd61e35bacb22047da02b3416",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b272ecfdb39f976dd61e35bacb22047da02b3416",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b272ecfdb39f976dd61e35bacb22047da02b3416",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b272ecfdb39f976dd61e35bacb22047da02b3416/comments",
    "author": {
      "login": "petertodd",
      "id": 7042,
      "node_id": "MDQ6VXNlcjcwNDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7042?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/petertodd",
      "html_url": "https://github.com/petertodd",
      "followers_url": "https://api.github.com/users/petertodd/followers",
      "following_url": "https://api.github.com/users/petertodd/following{/other_user}",
      "gists_url": "https://api.github.com/users/petertodd/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/petertodd/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/petertodd/subscriptions",
      "organizations_url": "https://api.github.com/users/petertodd/orgs",
      "repos_url": "https://api.github.com/users/petertodd/repos",
      "events_url": "https://api.github.com/users/petertodd/events{/privacy}",
      "received_events_url": "https://api.github.com/users/petertodd/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "petertodd",
      "id": 7042,
      "node_id": "MDQ6VXNlcjcwNDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7042?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/petertodd",
      "html_url": "https://github.com/petertodd",
      "followers_url": "https://api.github.com/users/petertodd/followers",
      "following_url": "https://api.github.com/users/petertodd/following{/other_user}",
      "gists_url": "https://api.github.com/users/petertodd/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/petertodd/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/petertodd/subscriptions",
      "organizations_url": "https://api.github.com/users/petertodd/orgs",
      "repos_url": "https://api.github.com/users/petertodd/repos",
      "events_url": "https://api.github.com/users/petertodd/events{/privacy}",
      "received_events_url": "https://api.github.com/users/petertodd/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fc8c19a07c20ab63f6a69f7494f486204d8f2b7a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fc8c19a07c20ab63f6a69f7494f486204d8f2b7a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fc8c19a07c20ab63f6a69f7494f486204d8f2b7a"
      }
    ],
    "stats": {
      "total": 63,
      "additions": 59,
      "deletions": 4
    },
    "files": [
      {
        "sha": "b48748fb4b2dc0a117b50c10d941bec46de5c53d",
        "filename": "qa/replace-by-fee/rbf-tests.py",
        "status": "modified",
        "additions": 35,
        "deletions": 4,
        "changes": 39,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b272ecfdb39f976dd61e35bacb22047da02b3416/qa/replace-by-fee/rbf-tests.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b272ecfdb39f976dd61e35bacb22047da02b3416/qa/replace-by-fee/rbf-tests.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/replace-by-fee/rbf-tests.py?ref=b272ecfdb39f976dd61e35bacb22047da02b3416",
        "patch": "@@ -35,22 +35,30 @@ def setUpClass(cls):\n             cls.proxy = bitcoin.rpc.Proxy()\n \n     @classmethod\n-    def tearDownClass(cls):\n-        # Make sure mining works\n+    def mine_mempool(cls):\n+        \"\"\"Mine until mempool is empty\"\"\"\n         mempool_size = 1\n         while mempool_size:\n-            cls.proxy.call('generate',1)\n+            cls.proxy.call('generate', 1)\n             new_mempool_size = len(cls.proxy.getrawmempool())\n \n             # It's possible to get stuck in a loop here if the mempool has\n             # transactions that can't be mined.\n             assert(new_mempool_size != mempool_size)\n             mempool_size = new_mempool_size\n \n-    def make_txout(self, amount, scriptPubKey=CScript([1])):\n+    @classmethod\n+    def tearDownClass(cls):\n+        # Make sure mining works\n+        cls.mine_mempool()\n+\n+    def make_txout(self, amount, confirmed=True, scriptPubKey=CScript([1])):\n         \"\"\"Create a txout with a given amount and scriptPubKey\n \n         Mines coins as needed.\n+\n+        confirmed - txouts created will be confirmed in the blockchain;\n+                    unconfirmed otherwise.\n         \"\"\"\n         fee = 1*COIN\n         while self.proxy.getbalance() < amount + fee:\n@@ -72,6 +80,10 @@ def make_txout(self, amount, scriptPubKey=CScript([1])):\n \n         tx2_txid = self.proxy.sendrawtransaction(tx2, True)\n \n+        # If requested, ensure txouts are confirmed.\n+        if confirmed:\n+            self.mine_mempool()\n+\n         return COutPoint(tx2_txid, 0)\n \n     def test_simple_doublespend(self):\n@@ -276,5 +288,24 @@ def test_spends_of_conflicting_outputs(self):\n         else:\n             self.fail()\n \n+    def test_new_unconfirmed_inputs(self):\n+        \"\"\"Replacements that add new unconfirmed inputs are rejected\"\"\"\n+        confirmed_utxo = self.make_txout(1.1*COIN)\n+        unconfirmed_utxo = self.make_txout(0.1*COIN, False)\n+\n+        tx1 = CTransaction([CTxIn(confirmed_utxo)],\n+                           [CTxOut(1.0*COIN, CScript([b'a']))])\n+        tx1_txid = self.proxy.sendrawtransaction(tx1, True)\n+\n+        tx2 = CTransaction([CTxIn(confirmed_utxo), CTxIn(unconfirmed_utxo)],\n+                           tx1.vout)\n+\n+        try:\n+            tx2_txid = self.proxy.sendrawtransaction(tx2, True)\n+        except bitcoin.rpc.JSONRPCException as exp:\n+            self.assertEqual(exp.error['code'], -26)\n+        else:\n+            self.fail()\n+\n if __name__ == '__main__':\n     unittest.main()"
      },
      {
        "sha": "6e238f552e2be786c1b1cfba96704bd8d590a64c",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 24,
        "deletions": 0,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b272ecfdb39f976dd61e35bacb22047da02b3416/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b272ecfdb39f976dd61e35bacb22047da02b3416/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=b272ecfdb39f976dd61e35bacb22047da02b3416",
        "patch": "@@ -1009,6 +1009,7 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n             LOCK(pool.cs);\n \n             CFeeRate newFeeRate(nFees, nSize);\n+            set<uint256> setConflictsParents;\n             BOOST_FOREACH(const uint256 hashConflicting, setConflicts)\n             {\n                 CTxMemPool::txiter mi = pool.mapTx.find(hashConflicting);\n@@ -1042,6 +1043,11 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n                             REJECT_INSUFFICIENTFEE, \"insufficient fee\");\n                 }\n \n+                BOOST_FOREACH(const CTxIn &txin, mi->GetTx().vin)\n+                {\n+                    setConflictsParents.insert(txin.prevout.hash);\n+                }\n+\n                 // For efficiency we simply sum up the pre-calculated\n                 // fees/size-with-descendants values from the mempool package\n                 // tracking; this does mean the pathological case of diamond tx\n@@ -1050,6 +1056,24 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n                 nConflictingSize += mi->GetSizeWithDescendants();\n             }\n \n+            for (unsigned int j = 0; j < tx.vin.size(); j++)\n+            {\n+                // We don't want to accept replacements that require low\n+                // feerate junk to be mined first. Ideally we'd keep track of\n+                // the ancestor feerates and make the decision based on that,\n+                // but for now requiring all new inputs to be confirmed works.\n+                if (!setConflictsParents.count(tx.vin[j].prevout.hash))\n+                {\n+                    // Rather than check the UTXO set - potentially expensive -\n+                    // it's cheaper to just check if the new input refers to a\n+                    // tx that's in the mempool.\n+                    if (pool.mapTx.find(tx.vin[j].prevout.hash) != pool.mapTx.end())\n+                        return state.DoS(0, error(\"AcceptToMemoryPool: replacement %s adds unconfirmed input, idx %d\",\n+                                                  hash.ToString(), j),\n+                                         REJECT_NONSTANDARD, \"replacement-adds-unconfirmed\");\n+                }\n+            }\n+\n             // The replacement must pay greater fees than the transactions it\n             // replaces - if we did the bandwidth used by those conflicting\n             // transactions would not be paid for."
      }
    ]
  },
  {
    "sha": "73d904009dc25ddfe5d6c4a91a13673c8f5cf87a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3M2Q5MDQwMDlkYzI1ZGRmZTVkNmM0YTkxYTEzNjczYzhmNWNmODdh",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2015-10-30T02:49:00Z"
      },
      "committer": {
        "name": "Peter Todd",
        "email": "pete@petertodd.org",
        "date": "2015-11-10T19:14:07Z"
      },
      "message": "Improve RBF replacement criteria\n\nFix the calculation of conflicting size/conflicting fees.",
      "tree": {
        "sha": "0e4407ac15d3977fbe0efa613876a897a8b62e3d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0e4407ac15d3977fbe0efa613876a897a8b62e3d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/73d904009dc25ddfe5d6c4a91a13673c8f5cf87a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/73d904009dc25ddfe5d6c4a91a13673c8f5cf87a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/73d904009dc25ddfe5d6c4a91a13673c8f5cf87a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/73d904009dc25ddfe5d6c4a91a13673c8f5cf87a/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "petertodd",
      "id": 7042,
      "node_id": "MDQ6VXNlcjcwNDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7042?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/petertodd",
      "html_url": "https://github.com/petertodd",
      "followers_url": "https://api.github.com/users/petertodd/followers",
      "following_url": "https://api.github.com/users/petertodd/following{/other_user}",
      "gists_url": "https://api.github.com/users/petertodd/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/petertodd/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/petertodd/subscriptions",
      "organizations_url": "https://api.github.com/users/petertodd/orgs",
      "repos_url": "https://api.github.com/users/petertodd/repos",
      "events_url": "https://api.github.com/users/petertodd/events{/privacy}",
      "received_events_url": "https://api.github.com/users/petertodd/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b272ecfdb39f976dd61e35bacb22047da02b3416",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b272ecfdb39f976dd61e35bacb22047da02b3416",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b272ecfdb39f976dd61e35bacb22047da02b3416"
      }
    ],
    "stats": {
      "total": 68,
      "additions": 52,
      "deletions": 16
    },
    "files": [
      {
        "sha": "79d4c91b77a56f0ed387902263ac36091d3c37d7",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 47,
        "deletions": 12,
        "changes": 59,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/73d904009dc25ddfe5d6c4a91a13673c8f5cf87a/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/73d904009dc25ddfe5d6c4a91a13673c8f5cf87a/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=73d904009dc25ddfe5d6c4a91a13673c8f5cf87a",
        "patch": "@@ -1004,18 +1004,39 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n         // than the ones it replaces.\n         CAmount nConflictingFees = 0;\n         size_t nConflictingSize = 0;\n+        uint64_t nConflictingCount = 0;\n+        CTxMemPool::setEntries allConflicting;\n         if (setConflicts.size())\n         {\n             LOCK(pool.cs);\n \n             CFeeRate newFeeRate(nFees, nSize);\n             set<uint256> setConflictsParents;\n-            BOOST_FOREACH(const uint256 hashConflicting, setConflicts)\n+            const int maxDescendantsToVisit = 100;\n+            CTxMemPool::setEntries setIterConflicting;\n+            BOOST_FOREACH(const uint256 &hashConflicting, setConflicts)\n             {\n                 CTxMemPool::txiter mi = pool.mapTx.find(hashConflicting);\n                 if (mi == pool.mapTx.end())\n                     continue;\n \n+                // Save these to avoid repeated lookups\n+                setIterConflicting.insert(mi);\n+\n+                // If this entry is \"dirty\", then we don't have descendant\n+                // state for this transaction, which means we probably have\n+                // lots of in-mempool descendants.\n+                // Don't allow replacements of dirty transactions, to ensure\n+                // that we don't spend too much time walking descendants.\n+                // This should be rare.\n+                if (mi->IsDirty()) {\n+                    return state.DoS(0,\n+                            error(\"AcceptToMemoryPool: rejecting replacement %s; cannot replace tx %s with untracked descendants\",\n+                                hash.ToString(),\n+                                mi->GetTx().GetHash().ToString()),\n+                            REJECT_NONSTANDARD, \"too many potential replacements\");\n+                }\n+\n                 // Don't allow the replacement to reduce the feerate of the\n                 // mempool.\n                 //\n@@ -1048,12 +1069,28 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n                     setConflictsParents.insert(txin.prevout.hash);\n                 }\n \n-                // For efficiency we simply sum up the pre-calculated\n-                // fees/size-with-descendants values from the mempool package\n-                // tracking; this does mean the pathological case of diamond tx\n-                // graphs will be overcounted.\n-                nConflictingFees += mi->GetFeesWithDescendants();\n-                nConflictingSize += mi->GetSizeWithDescendants();\n+                nConflictingCount += mi->GetCountWithDescendants();\n+            }\n+            // This potentially overestimates the number of actual descendants\n+            // but we just want to be conservative to avoid doing too much\n+            // work.\n+            if (nConflictingCount <= maxDescendantsToVisit) {\n+                // If not too many to replace, then calculate the set of\n+                // transactions that would have to be evicted\n+                BOOST_FOREACH(CTxMemPool::txiter it, setIterConflicting) {\n+                    pool.CalculateDescendants(it, allConflicting);\n+                }\n+                BOOST_FOREACH(CTxMemPool::txiter it, allConflicting) {\n+                    nConflictingFees += it->GetFee();\n+                    nConflictingSize += it->GetTxSize();\n+                }\n+            } else {\n+                return state.DoS(0,\n+                        error(\"AcceptToMemoryPool: rejecting replacement %s; too many potential replacements (%d > %d)\\n\",\n+                            hash.ToString(),\n+                            nConflictingCount,\n+                            maxDescendantsToVisit),\n+                        REJECT_NONSTANDARD, \"too many potential replacements\");\n             }\n \n             for (unsigned int j = 0; j < tx.vin.size(); j++)\n@@ -1119,17 +1156,15 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n         }\n \n         // Remove conflicting transactions from the mempool\n-        list<CTransaction> ltxConflicted;\n-        pool.removeConflicts(tx, ltxConflicted);\n-\n-        BOOST_FOREACH(const CTransaction &txConflicted, ltxConflicted)\n+        BOOST_FOREACH(const CTxMemPool::txiter it, allConflicting)\n         {\n             LogPrint(\"mempool\", \"replacing tx %s with %s for %s BTC additional fees, %d delta bytes\\n\",\n-                    txConflicted.GetHash().ToString(),\n+                    it->GetTx().GetHash().ToString(),\n                     hash.ToString(),\n                     FormatMoney(nFees - nConflictingFees),\n                     (int)nSize - (int)nConflictingSize);\n         }\n+        pool.RemoveStaged(allConflicting);\n \n         // Store transaction in memory\n         pool.addUnchecked(hash, entry, setAncestors, !IsInitialBlockDownload());"
      },
      {
        "sha": "3d8ac435f56b6c31d4c7c814d384a8377db640a6",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 5,
        "deletions": 4,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/73d904009dc25ddfe5d6c4a91a13673c8f5cf87a/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/73d904009dc25ddfe5d6c4a91a13673c8f5cf87a/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=73d904009dc25ddfe5d6c4a91a13673c8f5cf87a",
        "patch": "@@ -420,6 +420,11 @@ class CTxMemPool\n      */\n     bool CalculateMemPoolAncestors(const CTxMemPoolEntry &entry, setEntries &setAncestors, uint64_t limitAncestorCount, uint64_t limitAncestorSize, uint64_t limitDescendantCount, uint64_t limitDescendantSize, std::string &errString, bool fSearchForParents = true);\n \n+    /** Populate setDescendants with all in-mempool descendants of hash.\n+     *  Assumes that setDescendants includes all in-mempool descendants of anything\n+     *  already in it.  */\n+    void CalculateDescendants(txiter it, setEntries &setDescendants);\n+\n     /** The minimum fee to get into the mempool, which may itself not be enough\n       *  for larger-sized transactions.\n       *  The minReasonableRelayFee constructor arg is used to bound the time it\n@@ -493,10 +498,6 @@ class CTxMemPool\n     void UpdateForRemoveFromMempool(const setEntries &entriesToRemove);\n     /** Sever link between specified transaction and direct children. */\n     void UpdateChildrenForRemoval(txiter entry);\n-    /** Populate setDescendants with all in-mempool descendants of hash.\n-     *  Assumes that setDescendants includes all in-mempool descendants of anything\n-     *  already in it.  */\n-    void CalculateDescendants(txiter it, setEntries &setDescendants);\n \n     /** Before calling removeUnchecked for a given transaction,\n      *  UpdateForRemoveFromMempool must be called on the entire (dependent) set"
      }
    ]
  },
  {
    "sha": "20367d831fe0fdb92678d03552866c266aabbd83",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyMDM2N2Q4MzFmZTBmZGI5MjY3OGQwMzU1Mjg2NmMyNjZhYWJiZDgz",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2015-10-30T15:26:31Z"
      },
      "committer": {
        "name": "Peter Todd",
        "email": "pete@petertodd.org",
        "date": "2015-11-10T19:14:07Z"
      },
      "message": "Add test for max replacement limit",
      "tree": {
        "sha": "4ca3d4559adbe586b0fe896f02015a39a4e0ffb2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4ca3d4559adbe586b0fe896f02015a39a4e0ffb2"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/20367d831fe0fdb92678d03552866c266aabbd83",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/20367d831fe0fdb92678d03552866c266aabbd83",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/20367d831fe0fdb92678d03552866c266aabbd83",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/20367d831fe0fdb92678d03552866c266aabbd83/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "petertodd",
      "id": 7042,
      "node_id": "MDQ6VXNlcjcwNDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7042?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/petertodd",
      "html_url": "https://github.com/petertodd",
      "followers_url": "https://api.github.com/users/petertodd/followers",
      "following_url": "https://api.github.com/users/petertodd/following{/other_user}",
      "gists_url": "https://api.github.com/users/petertodd/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/petertodd/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/petertodd/subscriptions",
      "organizations_url": "https://api.github.com/users/petertodd/orgs",
      "repos_url": "https://api.github.com/users/petertodd/repos",
      "events_url": "https://api.github.com/users/petertodd/events{/privacy}",
      "received_events_url": "https://api.github.com/users/petertodd/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "73d904009dc25ddfe5d6c4a91a13673c8f5cf87a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/73d904009dc25ddfe5d6c4a91a13673c8f5cf87a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/73d904009dc25ddfe5d6c4a91a13673c8f5cf87a"
      }
    ],
    "stats": {
      "total": 48,
      "additions": 48,
      "deletions": 0
    },
    "files": [
      {
        "sha": "60be905262f4fed8fe3e905b6ecb5c022349d347",
        "filename": "qa/replace-by-fee/rbf-tests.py",
        "status": "modified",
        "additions": 48,
        "deletions": 0,
        "changes": 48,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/20367d831fe0fdb92678d03552866c266aabbd83/qa/replace-by-fee/rbf-tests.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/20367d831fe0fdb92678d03552866c266aabbd83/qa/replace-by-fee/rbf-tests.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/replace-by-fee/rbf-tests.py?ref=20367d831fe0fdb92678d03552866c266aabbd83",
        "patch": "@@ -307,5 +307,53 @@ def test_new_unconfirmed_inputs(self):\n         else:\n             self.fail()\n \n+    def test_too_many_replacements(self):\n+        \"\"\"Replacements that evict too many transactions are rejected\"\"\"\n+        # Try directly replacing more than MAX_REPLACEMENT_LIMIT\n+        # transactions\n+\n+        # Start by creating a single transaction with many outputs\n+        initial_nValue = 10*COIN\n+        utxo = self.make_txout(initial_nValue)\n+        fee = 0.0001*COIN\n+        split_value = int((initial_nValue-fee)/(MAX_REPLACEMENT_LIMIT+1))\n+        actual_fee = initial_nValue - split_value*(MAX_REPLACEMENT_LIMIT+1)\n+\n+        outputs = []\n+        for i in range(MAX_REPLACEMENT_LIMIT+1):\n+            outputs.append(CTxOut(split_value, CScript([1])))\n+\n+        splitting_tx = CTransaction([CTxIn(utxo, nSequence=0)], outputs)\n+        txid = self.proxy.sendrawtransaction(splitting_tx, True)\n+\n+        # Now spend each of those outputs individually\n+        for i in range(MAX_REPLACEMENT_LIMIT+1):\n+            tx_i = CTransaction([CTxIn(COutPoint(txid, i), nSequence=0)],\n+                                [CTxOut(split_value-fee, CScript([b'a']))])\n+            self.proxy.sendrawtransaction(tx_i, True)\n+\n+        # Now create doublespend of the whole lot, should fail\n+        # Need a big enough fee to cover all spending transactions and have\n+        # a higher fee rate\n+        double_spend_value = (split_value-100*fee)*(MAX_REPLACEMENT_LIMIT+1)\n+        inputs = []\n+        for i in range(MAX_REPLACEMENT_LIMIT+1):\n+            inputs.append(CTxIn(COutPoint(txid, i), nSequence=0))\n+        double_tx = CTransaction(inputs, [CTxOut(double_spend_value, CScript([b'a']))])\n+\n+        try:\n+            self.proxy.sendrawtransaction(double_tx, True)\n+        except bitcoin.rpc.JSONRPCException as exp:\n+            self.assertEqual(exp.error['code'], -26)\n+            self.assertEqual(\"too many potential replacements\" in exp.error['message'], True)\n+        else:\n+            self.fail()\n+\n+        # If we remove an input, it should pass\n+        double_tx = CTransaction(inputs[0:-1],\n+                                 [CTxOut(double_spend_value, CScript([b'a']))])\n+\n+        self.proxy.sendrawtransaction(double_tx, True)\n+\n if __name__ == '__main__':\n     unittest.main()"
      }
    ]
  },
  {
    "sha": "97203f5606bf76a233928adafb0ce22f15caf7ae",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5NzIwM2Y1NjA2YmY3NmEyMzM5MjhhZGFmYjBjZTIyZjE1Y2FmN2Fl",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2015-10-30T18:55:32Z"
      },
      "committer": {
        "name": "Peter Todd",
        "email": "pete@petertodd.org",
        "date": "2015-11-10T19:14:46Z"
      },
      "message": "Port test to rpc-test framework",
      "tree": {
        "sha": "c74c5b0bfe8c74a54492a4a9c10305f137f9d257",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c74c5b0bfe8c74a54492a4a9c10305f137f9d257"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/97203f5606bf76a233928adafb0ce22f15caf7ae",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGrBAABCACVBQJWQkIoXhSAAAAAABUAQGJsb2NraGFzaEBiaXRjb2luLm9yZzAw\nMDAwMDAwMDAwMDAwMDAwM2M2OTBjMzJjOTEwMDI0NjRhMDEwOWZiMWJlZGM1YTlm\nNDEzYmE0ZjY2NTgzOTEvFIAAAAAAFQARcGthLWFkZHJlc3NAZ251cGcub3JncGV0\nZUBwZXRlcnRvZC5vcmcACgkQwIXyHOf0udwEEAf/RjIbVdNyS+N2LwWZBJmd+FN3\nn6oMv13S9dzaeSJoVea7VnUv2rpQHmptugqQFSwzio/Hk50DyfHWQSsChWXrAdKK\n9miTwvkk+/Oz8CHPUYtQkThrfo/mH+pPSahXFrHGm8fn5GjdgHacSH2HxVq1P/9y\nBpPTMoTk3Xp5wIA4OMBdcRKA0DCCt291X7taY4HGvGcJ+Ik7UFgq4AEGxYy76PW8\nSbKllngrB6e4TUmbtUCpYQhqg+1vky0CIsp4ugUquyy+1Bh2ld1lytaSwAZYSJYN\nvk2dJBviDMBiX3tXi0eMuAJ2LAPbvmj4KXG6td5f8L5PVIbm8flbTM2wtZLoJA==\n=0U6Z\n-----END PGP SIGNATURE-----",
        "payload": "tree c74c5b0bfe8c74a54492a4a9c10305f137f9d257\nparent 20367d831fe0fdb92678d03552866c266aabbd83\nauthor Suhas Daftuar <sdaftuar@chaincode.com> 1446231332 -0400\ncommitter Peter Todd <pete@petertodd.org> 1447182886 -0500\n\nPort test to rpc-test framework\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/97203f5606bf76a233928adafb0ce22f15caf7ae",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/97203f5606bf76a233928adafb0ce22f15caf7ae",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/97203f5606bf76a233928adafb0ce22f15caf7ae/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "petertodd",
      "id": 7042,
      "node_id": "MDQ6VXNlcjcwNDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7042?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/petertodd",
      "html_url": "https://github.com/petertodd",
      "followers_url": "https://api.github.com/users/petertodd/followers",
      "following_url": "https://api.github.com/users/petertodd/following{/other_user}",
      "gists_url": "https://api.github.com/users/petertodd/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/petertodd/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/petertodd/subscriptions",
      "organizations_url": "https://api.github.com/users/petertodd/orgs",
      "repos_url": "https://api.github.com/users/petertodd/repos",
      "events_url": "https://api.github.com/users/petertodd/events{/privacy}",
      "received_events_url": "https://api.github.com/users/petertodd/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "20367d831fe0fdb92678d03552866c266aabbd83",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/20367d831fe0fdb92678d03552866c266aabbd83",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/20367d831fe0fdb92678d03552866c266aabbd83"
      }
    ],
    "stats": {
      "total": 513,
      "additions": 513,
      "deletions": 0
    },
    "files": [
      {
        "sha": "86a416edc45d451ea78a4604063b93c57b0b532f",
        "filename": "qa/pull-tester/rpc-tests.py",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/97203f5606bf76a233928adafb0ce22f15caf7ae/qa/pull-tester/rpc-tests.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/97203f5606bf76a233928adafb0ce22f15caf7ae/qa/pull-tester/rpc-tests.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/pull-tester/rpc-tests.py?ref=97203f5606bf76a233928adafb0ce22f15caf7ae",
        "patch": "@@ -92,6 +92,7 @@\n     'p2p-acceptblock.py',\n     'mempool_packages.py',\n     'maxuploadtarget.py',\n+    'replace-by-fee.py',\n ]\n \n #Enable ZMQ tests"
      },
      {
        "sha": "537a1ed8d9712bd7bd71c658e24d9563da683e3f",
        "filename": "qa/rpc-tests/replace-by-fee.py",
        "status": "added",
        "additions": 512,
        "deletions": 0,
        "changes": 512,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/97203f5606bf76a233928adafb0ce22f15caf7ae/qa/rpc-tests/replace-by-fee.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/97203f5606bf76a233928adafb0ce22f15caf7ae/qa/rpc-tests/replace-by-fee.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/replace-by-fee.py?ref=97203f5606bf76a233928adafb0ce22f15caf7ae",
        "patch": "@@ -0,0 +1,512 @@\n+#!/usr/bin/env python2\n+# Copyright (c) 2014-2015 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#\n+# Test replace by fee code\n+#\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+from test_framework.script import *\n+from test_framework.mininode import *\n+import binascii\n+\n+COIN = 100000000\n+MAX_REPLACEMENT_LIMIT = 100\n+\n+def satoshi_round(amount):\n+    return Decimal(amount).quantize(Decimal('0.00000001'), rounding=ROUND_DOWN)\n+\n+def txToHex(tx):\n+    return binascii.hexlify(tx.serialize()).decode('utf-8')\n+\n+def make_utxo(node, amount, confirmed=True, scriptPubKey=CScript([1])):\n+    \"\"\"Create a txout with a given amount and scriptPubKey\n+\n+    Mines coins as needed.\n+\n+    confirmed - txouts created will be confirmed in the blockchain;\n+                unconfirmed otherwise.\n+    \"\"\"\n+    fee = 1*COIN\n+    while node.getbalance() < satoshi_round((amount + fee)/COIN):\n+        node.generate(100)\n+        #print (node.getbalance(), amount, fee)\n+\n+    new_addr = node.getnewaddress()\n+    #print new_addr\n+    txid = node.sendtoaddress(new_addr, satoshi_round((amount+fee)/COIN))\n+    tx1 = node.getrawtransaction(txid, 1)\n+    txid = int(txid, 16)\n+    i = None\n+\n+    for i, txout in enumerate(tx1['vout']):\n+        #print i, txout['scriptPubKey']['addresses']\n+        if txout['scriptPubKey']['addresses'] == [new_addr]:\n+            #print i\n+            break\n+    assert i is not None\n+\n+    tx2 = CTransaction()\n+    tx2.vin = [CTxIn(COutPoint(txid, i))]\n+    tx2.vout = [CTxOut(amount, scriptPubKey)]\n+    tx2.rehash()\n+\n+    tx2_hex = binascii.hexlify(tx2.serialize()).decode('utf-8')\n+    #print tx2_hex\n+\n+    signed_tx = node.signrawtransaction(binascii.hexlify(tx2.serialize()).decode('utf-8'))\n+\n+    txid = node.sendrawtransaction(signed_tx['hex'], True)\n+\n+    # If requested, ensure txouts are confirmed.\n+    if confirmed:\n+        while len(node.getrawmempool()):\n+            node.generate(1)\n+\n+    return COutPoint(int(txid, 16), 0)\n+\n+class ReplaceByFeeTest(BitcoinTestFramework):\n+\n+    def setup_network(self):\n+        self.nodes = []\n+        self.nodes.append(start_node(0, self.options.tmpdir, [\"-maxorphantx=1000\",\n+                                                              \"-relaypriority=0\", \"-whitelist=127.0.0.1\"]))\n+        self.is_network_split = False\n+\n+    def run_test(self):\n+        make_utxo(self.nodes[0], 1*COIN)\n+\n+        print \"Running test simple doublespend...\"\n+        self.test_simple_doublespend()\n+\n+        print \"Running test doublespend chain...\"\n+        self.test_doublespend_chain()\n+\n+        print \"Running test doublespend tree...\"\n+        self.test_doublespend_tree()\n+\n+        print \"Running test replacement feeperkb...\"\n+        self.test_replacement_feeperkb()\n+\n+        print \"Running test spends of conflicting outputs...\"\n+        self.test_spends_of_conflicting_outputs()\n+\n+        print \"Running test new unconfirmed inputs...\"\n+        self.test_new_unconfirmed_inputs()\n+\n+        print \"Running test too many replacements...\"\n+        self.test_too_many_replacements()\n+\n+        print \"Running test opt-in...\"\n+        self.test_opt_in()\n+\n+        print \"Passed\\n\"\n+\n+    def test_simple_doublespend(self):\n+        \"\"\"Simple doublespend\"\"\"\n+        tx0_outpoint = make_utxo(self.nodes[0], 1.1*COIN)\n+\n+        tx1a = CTransaction()\n+        tx1a.vin = [CTxIn(tx0_outpoint, nSequence=0)]\n+        tx1a.vout = [CTxOut(1*COIN, CScript([b'a']))]\n+        tx1a_hex = txToHex(tx1a)\n+        tx1a_txid = self.nodes[0].sendrawtransaction(tx1a_hex, True)\n+\n+        # Should fail because we haven't changed the fee\n+        tx1b = CTransaction()\n+        tx1b.vin = [CTxIn(tx0_outpoint, nSequence=0)]\n+        tx1b.vout = [CTxOut(1*COIN, CScript([b'b']))]\n+        tx1b_hex = txToHex(tx1b)\n+\n+        try:\n+            tx1b_txid = self.nodes[0].sendrawtransaction(tx1b_hex, True)\n+        except JSONRPCException as exp:\n+            assert_equal(exp.error['code'], -26) # insufficient fee\n+        else:\n+            assert(False)\n+\n+        # Extra 0.1 BTC fee\n+        tx1b = CTransaction()\n+        tx1b.vin = [CTxIn(tx0_outpoint, nSequence=0)]\n+        tx1b.vout = [CTxOut(0.9*COIN, CScript([b'b']))]\n+        tx1b_hex = txToHex(tx1b)\n+        tx1b_txid = self.nodes[0].sendrawtransaction(tx1b_hex, True)\n+\n+        mempool = self.nodes[0].getrawmempool()\n+\n+        assert (tx1a_txid not in mempool)\n+        assert (tx1b_txid in mempool)\n+\n+        assert_equal(tx1b_hex, self.nodes[0].getrawtransaction(tx1b_txid))\n+\n+    def test_doublespend_chain(self):\n+        \"\"\"Doublespend of a long chain\"\"\"\n+\n+        initial_nValue = 50*COIN\n+        tx0_outpoint = make_utxo(self.nodes[0], initial_nValue)\n+\n+        prevout = tx0_outpoint\n+        remaining_value = initial_nValue\n+        chain_txids = []\n+        while remaining_value > 10*COIN:\n+            remaining_value -= 1*COIN\n+            tx = CTransaction()\n+            tx.vin = [CTxIn(prevout, nSequence=0)]\n+            tx.vout = [CTxOut(remaining_value, CScript([1]))]\n+            tx_hex = txToHex(tx)\n+            txid = self.nodes[0].sendrawtransaction(tx_hex, True)\n+            chain_txids.append(txid)\n+            prevout = COutPoint(int(txid, 16), 0)\n+\n+        # Whether the double-spend is allowed is evaluated by including all\n+        # child fees - 40 BTC - so this attempt is rejected.\n+        dbl_tx = CTransaction()\n+        dbl_tx.vin = [CTxIn(tx0_outpoint, nSequence=0)]\n+        dbl_tx.vout = [CTxOut(initial_nValue - 30*COIN, CScript([1]))]\n+        dbl_tx_hex = txToHex(dbl_tx)\n+\n+        try:\n+            self.nodes[0].sendrawtransaction(dbl_tx_hex, True)\n+        except JSONRPCException as exp:\n+            assert_equal(exp.error['code'], -26) # insufficient fee\n+        else:\n+            assert(False) # transaction mistakenly accepted!\n+\n+        # Accepted with sufficient fee\n+        dbl_tx = CTransaction()\n+        dbl_tx.vin = [CTxIn(tx0_outpoint, nSequence=0)]\n+        dbl_tx.vout = [CTxOut(1*COIN, CScript([1]))]\n+        dbl_tx_hex = txToHex(dbl_tx)\n+        self.nodes[0].sendrawtransaction(dbl_tx_hex, True)\n+\n+        mempool = self.nodes[0].getrawmempool()\n+        for doublespent_txid in chain_txids:\n+            assert(doublespent_txid not in mempool)\n+\n+    def test_doublespend_tree(self):\n+        \"\"\"Doublespend of a big tree of transactions\"\"\"\n+\n+        initial_nValue = 50*COIN\n+        tx0_outpoint = make_utxo(self.nodes[0], initial_nValue)\n+\n+        def branch(prevout, initial_value, max_txs, tree_width=5, fee=0.0001*COIN, _total_txs=None):\n+            if _total_txs is None:\n+                _total_txs = [0]\n+            if _total_txs[0] >= max_txs:\n+                return\n+\n+            txout_value = (initial_value - fee) // tree_width\n+            if txout_value < fee:\n+                return\n+\n+            vout = [CTxOut(txout_value, CScript([i+1]))\n+                    for i in range(tree_width)]\n+            tx = CTransaction()\n+            tx.vin = [CTxIn(prevout, nSequence=0)]\n+            tx.vout = vout\n+            tx_hex = txToHex(tx)\n+\n+            assert(len(tx.serialize()) < 100000)\n+            txid = self.nodes[0].sendrawtransaction(tx_hex, True)\n+            yield tx\n+            _total_txs[0] += 1\n+\n+            txid = int(txid, 16)\n+\n+            for i, txout in enumerate(tx.vout):\n+                for x in branch(COutPoint(txid, i), txout_value,\n+                                  max_txs,\n+                                  tree_width=tree_width, fee=fee,\n+                                  _total_txs=_total_txs):\n+                    yield x\n+\n+        fee = 0.0001*COIN\n+        n = MAX_REPLACEMENT_LIMIT\n+        tree_txs = list(branch(tx0_outpoint, initial_nValue, n, fee=fee))\n+        assert_equal(len(tree_txs), n)\n+\n+        # Attempt double-spend, will fail because too little fee paid\n+        dbl_tx = CTransaction()\n+        dbl_tx.vin = [CTxIn(tx0_outpoint, nSequence=0)]\n+        dbl_tx.vout = [CTxOut(initial_nValue - fee*n, CScript([1]))]\n+        dbl_tx_hex = txToHex(dbl_tx)\n+        try:\n+            self.nodes[0].sendrawtransaction(dbl_tx_hex, True)\n+        except JSONRPCException as exp:\n+            assert_equal(exp.error['code'], -26) # insufficient fee\n+        else:\n+            assert(False)\n+\n+        # 1 BTC fee is enough\n+        dbl_tx = CTransaction()\n+        dbl_tx.vin = [CTxIn(tx0_outpoint, nSequence=0)]\n+        dbl_tx.vout = [CTxOut(initial_nValue - fee*n - 1*COIN, CScript([1]))]\n+        dbl_tx_hex = txToHex(dbl_tx)\n+        self.nodes[0].sendrawtransaction(dbl_tx_hex, True)\n+\n+        mempool = self.nodes[0].getrawmempool()\n+\n+        for tx in tree_txs:\n+            tx.rehash()\n+            assert (tx.hash not in mempool)\n+\n+        # Try again, but with more total transactions than the \"max txs\n+        # double-spent at once\" anti-DoS limit.\n+        for n in (MAX_REPLACEMENT_LIMIT+1, MAX_REPLACEMENT_LIMIT*2):\n+            fee = 0.0001*COIN\n+            tx0_outpoint = make_utxo(self.nodes[0], initial_nValue)\n+            tree_txs = list(branch(tx0_outpoint, initial_nValue, n, fee=fee))\n+            assert_equal(len(tree_txs), n)\n+\n+            dbl_tx = CTransaction()\n+            dbl_tx.vin = [CTxIn(tx0_outpoint, nSequence=0)]\n+            dbl_tx.vout = [CTxOut(initial_nValue - 2*fee*n, CScript([1]))]\n+            dbl_tx_hex = txToHex(dbl_tx)\n+            try:\n+                self.nodes[0].sendrawtransaction(dbl_tx_hex, True)\n+            except JSONRPCException as exp:\n+                assert_equal(exp.error['code'], -26)\n+                assert_equal(\"too many potential replacements\" in exp.error['message'], True)\n+            else:\n+                assert(False)\n+\n+            for tx in tree_txs:\n+                tx.rehash()\n+                self.nodes[0].getrawtransaction(tx.hash)\n+\n+    def test_replacement_feeperkb(self):\n+        \"\"\"Replacement requires fee-per-KB to be higher\"\"\"\n+        tx0_outpoint = make_utxo(self.nodes[0], 1.1*COIN)\n+\n+        tx1a = CTransaction()\n+        tx1a.vin = [CTxIn(tx0_outpoint, nSequence=0)]\n+        tx1a.vout = [CTxOut(1*COIN, CScript([b'a']))]\n+        tx1a_hex = txToHex(tx1a)\n+        tx1a_txid = self.nodes[0].sendrawtransaction(tx1a_hex, True)\n+\n+        # Higher fee, but the fee per KB is much lower, so the replacement is\n+        # rejected.\n+        tx1b = CTransaction()\n+        tx1b.vin = [CTxIn(tx0_outpoint, nSequence=0)]\n+        tx1b.vout = [CTxOut(0.001*COIN, CScript([b'a'*999000]))]\n+        tx1b_hex = txToHex(tx1b)\n+\n+        try:\n+            tx1b_txid = self.nodes[0].sendrawtransaction(tx1b_hex, True)\n+        except JSONRPCException as exp:\n+            assert_equal(exp.error['code'], -26) # insufficient fee\n+        else:\n+            assert(False)\n+\n+    def test_spends_of_conflicting_outputs(self):\n+        \"\"\"Replacements that spend conflicting tx outputs are rejected\"\"\"\n+        utxo1 = make_utxo(self.nodes[0], 1.2*COIN)\n+        utxo2 = make_utxo(self.nodes[0], 3.0*COIN)\n+\n+        tx1a = CTransaction()\n+        tx1a.vin = [CTxIn(utxo1, nSequence=0)]\n+        tx1a.vout = [CTxOut(1.1*COIN, CScript([b'a']))]\n+        tx1a_hex = txToHex(tx1a)\n+        tx1a_txid = self.nodes[0].sendrawtransaction(tx1a_hex, True)\n+\n+        tx1a_txid = int(tx1a_txid, 16)\n+\n+        # Direct spend an output of the transaction we're replacing.\n+        tx2 = CTransaction()\n+        tx2.vin = [CTxIn(utxo1, nSequence=0), CTxIn(utxo2, nSequence=0)]\n+        tx2.vin.append(CTxIn(COutPoint(tx1a_txid, 0), nSequence=0))\n+        tx2.vout = tx1a.vout\n+        tx2_hex = txToHex(tx2)\n+\n+        try:\n+            tx2_txid = self.nodes[0].sendrawtransaction(tx2_hex, True)\n+        except JSONRPCException as exp:\n+            assert_equal(exp.error['code'], -26)\n+        else:\n+            assert(False)\n+\n+        # Spend tx1a's output to test the indirect case.\n+        tx1b = CTransaction()\n+        tx1b.vin = [CTxIn(COutPoint(tx1a_txid, 0), nSequence=0)]\n+        tx1b.vout = [CTxOut(1.0*COIN, CScript([b'a']))]\n+        tx1b_hex = txToHex(tx1b)\n+        tx1b_txid = self.nodes[0].sendrawtransaction(tx1b_hex, True)\n+        tx1b_txid = int(tx1b_txid, 16)\n+\n+        tx2 = CTransaction()\n+        tx2.vin = [CTxIn(utxo1, nSequence=0), CTxIn(utxo2, nSequence=0),\n+                   CTxIn(COutPoint(tx1b_txid, 0))]\n+        tx2.vout = tx1a.vout\n+        tx2_hex = txToHex(tx2)\n+\n+        try:\n+            tx2_txid = self.nodes[0].sendrawtransaction(tx2_hex, True)\n+        except JSONRPCException as exp:\n+            assert_equal(exp.error['code'], -26)\n+        else:\n+            assert(False)\n+\n+    def test_new_unconfirmed_inputs(self):\n+        \"\"\"Replacements that add new unconfirmed inputs are rejected\"\"\"\n+        confirmed_utxo = make_utxo(self.nodes[0], 1.1*COIN)\n+        unconfirmed_utxo = make_utxo(self.nodes[0], 0.1*COIN, False)\n+\n+        tx1 = CTransaction()\n+        tx1.vin = [CTxIn(confirmed_utxo)]\n+        tx1.vout = [CTxOut(1.0*COIN, CScript([b'a']))]\n+        tx1_hex = txToHex(tx1)\n+        tx1_txid = self.nodes[0].sendrawtransaction(tx1_hex, True)\n+\n+        tx2 = CTransaction()\n+        tx2.vin = [CTxIn(confirmed_utxo), CTxIn(unconfirmed_utxo)]\n+        tx2.vout = tx1.vout\n+        tx2_hex = txToHex(tx2)\n+\n+        try:\n+            tx2_txid = self.nodes[0].sendrawtransaction(tx2_hex, True)\n+        except JSONRPCException as exp:\n+            assert_equal(exp.error['code'], -26)\n+        else:\n+            assert(False)\n+\n+    def test_too_many_replacements(self):\n+        \"\"\"Replacements that evict too many transactions are rejected\"\"\"\n+        # Try directly replacing more than MAX_REPLACEMENT_LIMIT\n+        # transactions\n+\n+        # Start by creating a single transaction with many outputs\n+        initial_nValue = 10*COIN\n+        utxo = make_utxo(self.nodes[0], initial_nValue)\n+        fee = 0.0001*COIN\n+        split_value = int((initial_nValue-fee)/(MAX_REPLACEMENT_LIMIT+1))\n+        actual_fee = initial_nValue - split_value*(MAX_REPLACEMENT_LIMIT+1)\n+\n+        outputs = []\n+        for i in range(MAX_REPLACEMENT_LIMIT+1):\n+            outputs.append(CTxOut(split_value, CScript([1])))\n+\n+        splitting_tx = CTransaction()\n+        splitting_tx.vin = [CTxIn(utxo, nSequence=0)]\n+        splitting_tx.vout = outputs\n+        splitting_tx_hex = txToHex(splitting_tx)\n+\n+        txid = self.nodes[0].sendrawtransaction(splitting_tx_hex, True)\n+        txid = int(txid, 16)\n+\n+        # Now spend each of those outputs individually\n+        for i in range(MAX_REPLACEMENT_LIMIT+1):\n+            tx_i = CTransaction()\n+            tx_i.vin = [CTxIn(COutPoint(txid, i), nSequence=0)]\n+            tx_i.vout = [CTxOut(split_value-fee, CScript([b'a']))]\n+            tx_i_hex = txToHex(tx_i)\n+            self.nodes[0].sendrawtransaction(tx_i_hex, True)\n+\n+        # Now create doublespend of the whole lot; should fail.\n+        # Need a big enough fee to cover all spending transactions and have\n+        # a higher fee rate\n+        double_spend_value = (split_value-100*fee)*(MAX_REPLACEMENT_LIMIT+1)\n+        inputs = []\n+        for i in range(MAX_REPLACEMENT_LIMIT+1):\n+            inputs.append(CTxIn(COutPoint(txid, i), nSequence=0))\n+        double_tx = CTransaction()\n+        double_tx.vin = inputs\n+        double_tx.vout = [CTxOut(double_spend_value, CScript([b'a']))]\n+        double_tx_hex = txToHex(double_tx)\n+\n+        try:\n+            self.nodes[0].sendrawtransaction(double_tx_hex, True)\n+        except JSONRPCException as exp:\n+            assert_equal(exp.error['code'], -26)\n+            assert_equal(\"too many potential replacements\" in exp.error['message'], True)\n+        else:\n+            assert(False)\n+\n+        # If we remove an input, it should pass\n+        double_tx = CTransaction()\n+        double_tx.vin = inputs[0:-1]\n+        double_tx.vout = [CTxOut(double_spend_value, CScript([b'a']))]\n+        double_tx_hex = txToHex(double_tx)\n+        self.nodes[0].sendrawtransaction(double_tx_hex, True)\n+\n+    def test_opt_in(self):\n+        \"\"\" Replacing should only work if orig tx opted in \"\"\"\n+        tx0_outpoint = make_utxo(self.nodes[0], 1.1*COIN)\n+\n+        # Create a non-opting in transaction\n+        tx1a = CTransaction()\n+        tx1a.vin = [CTxIn(tx0_outpoint, nSequence=0xffffffff)]\n+        tx1a.vout = [CTxOut(1*COIN, CScript([b'a']))]\n+        tx1a_hex = txToHex(tx1a)\n+        tx1a_txid = self.nodes[0].sendrawtransaction(tx1a_hex, True)\n+\n+        # Shouldn't be able to double-spend\n+        tx1b = CTransaction()\n+        tx1b.vin = [CTxIn(tx0_outpoint, nSequence=0)]\n+        tx1b.vout = [CTxOut(0.9*COIN, CScript([b'b']))]\n+        tx1b_hex = txToHex(tx1b)\n+\n+        try:\n+            tx1b_txid = self.nodes[0].sendrawtransaction(tx1b_hex, True)\n+        except JSONRPCException as exp:\n+            assert_equal(exp.error['code'], -26)\n+        else:\n+            print tx1b_txid\n+            assert(False)\n+\n+        tx1_outpoint = make_utxo(self.nodes[0], 1.1*COIN)\n+\n+        # Create a different non-opting in transaction\n+        tx2a = CTransaction()\n+        tx2a.vin = [CTxIn(tx1_outpoint, nSequence=0xfffffffe)]\n+        tx2a.vout = [CTxOut(1*COIN, CScript([b'a']))]\n+        tx2a_hex = txToHex(tx2a)\n+        tx2a_txid = self.nodes[0].sendrawtransaction(tx2a_hex, True)\n+\n+        # Still shouldn't be able to double-spend\n+        tx2b = CTransaction()\n+        tx2b.vin = [CTxIn(tx1_outpoint, nSequence=0)]\n+        tx2b.vout = [CTxOut(0.9*COIN, CScript([b'b']))]\n+        tx2b_hex = txToHex(tx2b)\n+\n+        try:\n+            tx2b_txid = self.nodes[0].sendrawtransaction(tx2b_hex, True)\n+        except JSONRPCException as exp:\n+            assert_equal(exp.error['code'], -26)\n+        else:\n+            assert(False)\n+\n+        # Now create a new transaction that spends from tx1a and tx2a\n+        # opt-in on one of the inputs\n+        # Transaction should be replaceable on either input\n+\n+        tx1a_txid = int(tx1a_txid, 16)\n+        tx2a_txid = int(tx2a_txid, 16)\n+\n+        tx3a = CTransaction()\n+        tx3a.vin = [CTxIn(COutPoint(tx1a_txid, 0), nSequence=0xffffffff),\n+                    CTxIn(COutPoint(tx2a_txid, 0), nSequence=0xfffffffd)]\n+        tx3a.vout = [CTxOut(0.9*COIN, CScript([b'c'])), CTxOut(0.9*COIN, CScript([b'd']))]\n+        tx3a_hex = txToHex(tx3a)\n+\n+        self.nodes[0].sendrawtransaction(tx3a_hex, True)\n+\n+        tx3b = CTransaction()\n+        tx3b.vin = [CTxIn(COutPoint(tx1a_txid, 0), nSequence=0)]\n+        tx3b.vout = [CTxOut(0.5*COIN, CScript([b'e']))]\n+        tx3b_hex = txToHex(tx3b)\n+\n+        tx3c = CTransaction()\n+        tx3c.vin = [CTxIn(COutPoint(tx2a_txid, 0), nSequence=0)]\n+        tx3c.vout = [CTxOut(0.5*COIN, CScript([b'f']))]\n+        tx3c_hex = txToHex(tx3c)\n+\n+        self.nodes[0].sendrawtransaction(tx3b_hex, True)\n+        # If tx3b was accepted, tx3c won't look like a replacement,\n+        # but make sure it is accepted anyway\n+        self.nodes[0].sendrawtransaction(tx3c_hex, True)\n+\n+if __name__ == '__main__':\n+    ReplaceByFeeTest().main()"
      }
    ]
  },
  {
    "sha": "16a2f93629f75d182871f288f0396afe6cdc8504",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxNmEyZjkzNjI5Zjc1ZDE4Mjg3MWYyODhmMDM5NmFmZTZjZGM4NTA0",
    "commit": {
      "author": {
        "name": "Peter Todd",
        "email": "pete@petertodd.org",
        "date": "2015-11-10T22:58:06Z"
      },
      "committer": {
        "name": "Peter Todd",
        "email": "pete@petertodd.org",
        "date": "2015-11-10T23:00:24Z"
      },
      "message": "Fix incorrect locking of mempool during RBF replacement\n\nPreviously RemoveStaged() was called without pool.cs held.",
      "tree": {
        "sha": "8c35d8db6297f5c195bf7df4ee4f1281810ba671",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8c35d8db6297f5c195bf7df4ee4f1281810ba671"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/16a2f93629f75d182871f288f0396afe6cdc8504",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGrBAABCACVBQJWQncsXhSAAAAAABUAQGJsb2NraGFzaEBiaXRjb2luLm9yZzAw\nMDAwMDAwMDAwMDAwMDAwNDAzZGQxOTMwYWI5NDFmOWVjODBiZGIyYjYyYmJkMzRl\nZjI4NGYzZmM0MzliNWIvFIAAAAAAFQARcGthLWFkZHJlc3NAZ251cGcub3JncGV0\nZUBwZXRlcnRvZC5vcmcACgkQwIXyHOf0udxytwf/Z89nrPdrwQfMlaFO/DxN4Bv6\n9TsloifQXc7ibGM6iL8//+QYEqSFGWzmZxs2SqGWnwOCoR3FqG7BG90J534d8NLu\nyAhgyfeg73kV8LeWlRzHWmmgVPM4YuDALAxjmXiLJlUHliijq6O2+iCp0c/GtjLx\n56r5VSzg2BELadYg/WrQfocMKXmuEy+8MukMOIaKpXrqsOtDCksIoJa7ZxKcTgQh\ntT1cg583cHZzgQss/HiyJQkqMXumc1npMITV3VJJC1cEwDe8u4m75mNQM2gtXSXS\nbkiBmIpD1+nzdcMGTHxfzyjUU3xn2zw8pANaX2p0NM5Lmfmn4E1emvx/KvuSug==\n=6Ih9\n-----END PGP SIGNATURE-----",
        "payload": "tree 8c35d8db6297f5c195bf7df4ee4f1281810ba671\nparent 97203f5606bf76a233928adafb0ce22f15caf7ae\nauthor Peter Todd <pete@petertodd.org> 1447196286 -0500\ncommitter Peter Todd <pete@petertodd.org> 1447196424 -0500\n\nFix incorrect locking of mempool during RBF replacement\n\nPreviously RemoveStaged() was called without pool.cs held.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/16a2f93629f75d182871f288f0396afe6cdc8504",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/16a2f93629f75d182871f288f0396afe6cdc8504",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/16a2f93629f75d182871f288f0396afe6cdc8504/comments",
    "author": {
      "login": "petertodd",
      "id": 7042,
      "node_id": "MDQ6VXNlcjcwNDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7042?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/petertodd",
      "html_url": "https://github.com/petertodd",
      "followers_url": "https://api.github.com/users/petertodd/followers",
      "following_url": "https://api.github.com/users/petertodd/following{/other_user}",
      "gists_url": "https://api.github.com/users/petertodd/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/petertodd/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/petertodd/subscriptions",
      "organizations_url": "https://api.github.com/users/petertodd/orgs",
      "repos_url": "https://api.github.com/users/petertodd/repos",
      "events_url": "https://api.github.com/users/petertodd/events{/privacy}",
      "received_events_url": "https://api.github.com/users/petertodd/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "petertodd",
      "id": 7042,
      "node_id": "MDQ6VXNlcjcwNDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7042?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/petertodd",
      "html_url": "https://github.com/petertodd",
      "followers_url": "https://api.github.com/users/petertodd/followers",
      "following_url": "https://api.github.com/users/petertodd/following{/other_user}",
      "gists_url": "https://api.github.com/users/petertodd/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/petertodd/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/petertodd/subscriptions",
      "organizations_url": "https://api.github.com/users/petertodd/orgs",
      "repos_url": "https://api.github.com/users/petertodd/repos",
      "events_url": "https://api.github.com/users/petertodd/events{/privacy}",
      "received_events_url": "https://api.github.com/users/petertodd/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "97203f5606bf76a233928adafb0ce22f15caf7ae",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/97203f5606bf76a233928adafb0ce22f15caf7ae",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/97203f5606bf76a233928adafb0ce22f15caf7ae"
      }
    ],
    "stats": {
      "total": 7,
      "additions": 5,
      "deletions": 2
    },
    "files": [
      {
        "sha": "e3527a83d15f1bcb5a3e9bc6ea770c048450fe1c",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 2,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/16a2f93629f75d182871f288f0396afe6cdc8504/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/16a2f93629f75d182871f288f0396afe6cdc8504/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=16a2f93629f75d182871f288f0396afe6cdc8504",
        "patch": "@@ -1006,10 +1006,13 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n         size_t nConflictingSize = 0;\n         uint64_t nConflictingCount = 0;\n         CTxMemPool::setEntries allConflicting;\n+\n+        // If we don't hold the lock allConflicting might be incomplete; the\n+        // subsequent RemoveStaged() and addUnchecked() calls don't guarantee\n+        // mempool consistency for us.\n+        LOCK(pool.cs);\n         if (setConflicts.size())\n         {\n-            LOCK(pool.cs);\n-\n             CFeeRate newFeeRate(nFees, nSize);\n             set<uint256> setConflictsParents;\n             const int maxDescendantsToVisit = 100;"
      }
    ]
  },
  {
    "sha": "63b5840257a0b892228dfa9cce943b5a2bb94e1a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2M2I1ODQwMjU3YTBiODkyMjI4ZGZhOWNjZTk0M2I1YTJiYjk0ZTFh",
    "commit": {
      "author": {
        "name": "Peter Todd",
        "email": "pete@petertodd.org",
        "date": "2015-11-20T21:23:01Z"
      },
      "committer": {
        "name": "Peter Todd",
        "email": "pete@petertodd.org",
        "date": "2015-11-20T21:23:01Z"
      },
      "message": "Fix usage of local python-bitcoinlib\n\nPreviously was using the system-wide python-bitcoinlib, if it existed,\nrather than the local copy that you check out in the README.",
      "tree": {
        "sha": "bea21499af9d8cf4d2667a9115986ba18d310e1d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/bea21499af9d8cf4d2667a9115986ba18d310e1d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/63b5840257a0b892228dfa9cce943b5a2bb94e1a",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGrBAABCACVBQJWT49JXhSAAAAAABUAQGJsb2NraGFzaEBiaXRjb2luLm9yZzAw\nMDAwMDAwMDAwMDAwMDAwZDFmMWJjMDU4ZDUxODY0ZmJkMGRmNTZhODdkNDBjMzg0\nOTZiMzYxMjYzMmM2NzgvFIAAAAAAFQARcGthLWFkZHJlc3NAZ251cGcub3JncGV0\nZUBwZXRlcnRvZC5vcmcACgkQwIXyHOf0udykZwgAiklmtLupNAocwohMsLpz5BOO\nwA+cDIMw9iuV1yjh04AitYrhMBo/fxM9ZmqY7GQkJ9IfZnYO37mMelFf4nBQCmc9\n72TTDcDlB/3M6OP5auijj2iOIwOR45+gWx4s2//YaAIs1mN/U+CDWwwa3H0bhlpM\nBlwS0DLAcSj2NP+b4o07YsnNXcCZSdK2BFEMedYKZsEpS5Ut1QUoPD557h0KnwXm\nfbP28fZmxgDESqFQ8w4TaI5kAFQv9/qvA8RilPSxMcCRVBlrQdRgxxpVSP9heCa8\nuuKN/r/+dkilk+7A2S/QDHpfKiVEReU/FiDBtN0b8Bro6bGp/rFqsSmToCgJJQ==\n=X5dq\n-----END PGP SIGNATURE-----",
        "payload": "tree bea21499af9d8cf4d2667a9115986ba18d310e1d\nparent 16a2f93629f75d182871f288f0396afe6cdc8504\nauthor Peter Todd <pete@petertodd.org> 1448054581 -0500\ncommitter Peter Todd <pete@petertodd.org> 1448054581 -0500\n\nFix usage of local python-bitcoinlib\n\nPreviously was using the system-wide python-bitcoinlib, if it existed,\nrather than the local copy that you check out in the README.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/63b5840257a0b892228dfa9cce943b5a2bb94e1a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/63b5840257a0b892228dfa9cce943b5a2bb94e1a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/63b5840257a0b892228dfa9cce943b5a2bb94e1a/comments",
    "author": {
      "login": "petertodd",
      "id": 7042,
      "node_id": "MDQ6VXNlcjcwNDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7042?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/petertodd",
      "html_url": "https://github.com/petertodd",
      "followers_url": "https://api.github.com/users/petertodd/followers",
      "following_url": "https://api.github.com/users/petertodd/following{/other_user}",
      "gists_url": "https://api.github.com/users/petertodd/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/petertodd/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/petertodd/subscriptions",
      "organizations_url": "https://api.github.com/users/petertodd/orgs",
      "repos_url": "https://api.github.com/users/petertodd/repos",
      "events_url": "https://api.github.com/users/petertodd/events{/privacy}",
      "received_events_url": "https://api.github.com/users/petertodd/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "petertodd",
      "id": 7042,
      "node_id": "MDQ6VXNlcjcwNDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7042?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/petertodd",
      "html_url": "https://github.com/petertodd",
      "followers_url": "https://api.github.com/users/petertodd/followers",
      "following_url": "https://api.github.com/users/petertodd/following{/other_user}",
      "gists_url": "https://api.github.com/users/petertodd/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/petertodd/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/petertodd/subscriptions",
      "organizations_url": "https://api.github.com/users/petertodd/orgs",
      "repos_url": "https://api.github.com/users/petertodd/repos",
      "events_url": "https://api.github.com/users/petertodd/events{/privacy}",
      "received_events_url": "https://api.github.com/users/petertodd/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "16a2f93629f75d182871f288f0396afe6cdc8504",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/16a2f93629f75d182871f288f0396afe6cdc8504",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/16a2f93629f75d182871f288f0396afe6cdc8504"
      }
    ],
    "stats": {
      "total": 5,
      "additions": 3,
      "deletions": 2
    },
    "files": [
      {
        "sha": "1ee6c838752568ff7909ff2923381ca73127377a",
        "filename": "qa/replace-by-fee/rbf-tests.py",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/63b5840257a0b892228dfa9cce943b5a2bb94e1a/qa/replace-by-fee/rbf-tests.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/63b5840257a0b892228dfa9cce943b5a2bb94e1a/qa/replace-by-fee/rbf-tests.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/replace-by-fee/rbf-tests.py?ref=63b5840257a0b892228dfa9cce943b5a2bb94e1a",
        "patch": "@@ -10,8 +10,9 @@\n import os\n import sys\n \n-# Add python-bitcoinlib to module search path:\n-sys.path.append(os.path.join(os.path.dirname(os.path.abspath(__file__)), \"python-bitcoinlib\"))\n+# Add python-bitcoinlib to module search path, prior to any system-wide\n+# python-bitcoinlib.\n+sys.path.insert(0, os.path.join(os.path.dirname(os.path.abspath(__file__)), \"python-bitcoinlib\"))\n \n import unittest\n "
      }
    ]
  }
]