[
  {
    "sha": "ef3988ca369900206b0cfc32cc1958aee0e43710",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplZjM5ODhjYTM2OTkwMDIwNmIwY2ZjMzJjYzE5NThhZWUwZTQzNzEw",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2013-01-26T23:14:11Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieterw@google.com",
        "date": "2013-01-30T02:56:44Z"
      },
      "message": "CValidationState framework",
      "tree": {
        "sha": "9cd1ecf802bd159238ece0954200b98a45d01bf3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9cd1ecf802bd159238ece0954200b98a45d01bf3"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ef3988ca369900206b0cfc32cc1958aee0e43710",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ef3988ca369900206b0cfc32cc1958aee0e43710",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ef3988ca369900206b0cfc32cc1958aee0e43710",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ef3988ca369900206b0cfc32cc1958aee0e43710/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": null,
    "parents": [
      {
        "sha": "2835080e164527ecc2db31e68d86ab8a8337c62b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2835080e164527ecc2db31e68d86ab8a8337c62b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2835080e164527ecc2db31e68d86ab8a8337c62b"
      }
    ],
    "stats": {
      "total": 439,
      "additions": 226,
      "deletions": 213
    },
    "files": [
      {
        "sha": "c87850b66478f303c6b8d35911927b6469385455",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ef3988ca369900206b0cfc32cc1958aee0e43710/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ef3988ca369900206b0cfc32cc1958aee0e43710/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=ef3988ca369900206b0cfc32cc1958aee0e43710",
        "patch": "@@ -936,7 +936,8 @@ bool AppInit2()\n \n     // scan for better chains in the block chain database, that are not yet connected in the active best chain\n     uiInterface.InitMessage(_(\"Importing blocks from block database...\"));\n-    if (!ConnectBestBlock())\n+    CValidationState state;\n+    if (!ConnectBestBlock(state))\n         strErrors << \"Failed to connect best block\";\n \n     CImportData *pimport = new CImportData();"
      },
      {
        "sha": "413698a76d29f9b9e3be2fd7698d40d972b75ee3",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 148,
        "deletions": 175,
        "changes": 323,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ef3988ca369900206b0cfc32cc1958aee0e43710/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ef3988ca369900206b0cfc32cc1958aee0e43710/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=ef3988ca369900206b0cfc32cc1958aee0e43710",
        "patch": "@@ -524,49 +524,49 @@ int CMerkleTx::SetMerkleBranch(const CBlock* pblock)\n \n \n \n-bool CTransaction::CheckTransaction() const\n+bool CTransaction::CheckTransaction(CValidationState &state) const\n {\n     // Basic checks that don't depend on any context\n     if (vin.empty())\n-        return DoS(10, error(\"CTransaction::CheckTransaction() : vin empty\"));\n+        return state.DoS(10, error(\"CTransaction::CheckTransaction() : vin empty\"));\n     if (vout.empty())\n-        return DoS(10, error(\"CTransaction::CheckTransaction() : vout empty\"));\n+        return state.DoS(10, error(\"CTransaction::CheckTransaction() : vout empty\"));\n     // Size limits\n     if (::GetSerializeSize(*this, SER_NETWORK, PROTOCOL_VERSION) > MAX_BLOCK_SIZE)\n-        return DoS(100, error(\"CTransaction::CheckTransaction() : size limits failed\"));\n+        return state.DoS(100, error(\"CTransaction::CheckTransaction() : size limits failed\"));\n \n     // Check for negative or overflow output values\n     int64 nValueOut = 0;\n     BOOST_FOREACH(const CTxOut& txout, vout)\n     {\n         if (txout.nValue < 0)\n-            return DoS(100, error(\"CTransaction::CheckTransaction() : txout.nValue negative\"));\n+            return state.DoS(100, error(\"CTransaction::CheckTransaction() : txout.nValue negative\"));\n         if (txout.nValue > MAX_MONEY)\n-            return DoS(100, error(\"CTransaction::CheckTransaction() : txout.nValue too high\"));\n+            return state.DoS(100, error(\"CTransaction::CheckTransaction() : txout.nValue too high\"));\n         nValueOut += txout.nValue;\n         if (!MoneyRange(nValueOut))\n-            return DoS(100, error(\"CTransaction::CheckTransaction() : txout total out of range\"));\n+            return state.DoS(100, error(\"CTransaction::CheckTransaction() : txout total out of range\"));\n     }\n \n     // Check for duplicate inputs\n     set<COutPoint> vInOutPoints;\n     BOOST_FOREACH(const CTxIn& txin, vin)\n     {\n         if (vInOutPoints.count(txin.prevout))\n-            return false;\n+            return state.DoS(100, error(\"CTransaction::CheckTransaction() : duplicate inputs\"));\n         vInOutPoints.insert(txin.prevout);\n     }\n \n     if (IsCoinBase())\n     {\n         if (vin[0].scriptSig.size() < 2 || vin[0].scriptSig.size() > 100)\n-            return DoS(100, error(\"CTransaction::CheckTransaction() : coinbase script size\"));\n+            return state.DoS(100, error(\"CTransaction::CheckTransaction() : coinbase script size\"));\n     }\n     else\n     {\n         BOOST_FOREACH(const CTxIn& txin, vin)\n             if (txin.prevout.IsNull())\n-                return DoS(10, error(\"CTransaction::CheckTransaction() : prevout is null\"));\n+                return state.DoS(10, error(\"CTransaction::CheckTransaction() : prevout is null\"));\n     }\n \n     return true;\n@@ -633,18 +633,18 @@ void CTxMemPool::pruneSpent(const uint256 &hashTx, CCoins &coins)\n     }\n }\n \n-bool CTxMemPool::accept(CTransaction &tx, bool fCheckInputs, bool fLimitFree,\n+bool CTxMemPool::accept(CValidationState &state, CTransaction &tx, bool fCheckInputs, bool fLimitFree,\n                         bool* pfMissingInputs)\n {\n     if (pfMissingInputs)\n         *pfMissingInputs = false;\n \n-    if (!tx.CheckTransaction())\n+    if (!tx.CheckTransaction(state))\n         return error(\"CTxMemPool::accept() : CheckTransaction failed\");\n \n     // Coinbase is only valid in a block, not as a loose transaction\n     if (tx.IsCoinBase())\n-        return tx.DoS(100, error(\"CTxMemPool::accept() : coinbase as individual tx\"));\n+        return state.DoS(100, error(\"CTxMemPool::accept() : coinbase as individual tx\"));\n \n     // To help v0.1.5 clients who would see it as a negative number\n     if ((int64)tx.nLockTime > std::numeric_limits<int>::max())\n@@ -717,7 +717,7 @@ bool CTxMemPool::accept(CTransaction &tx, bool fCheckInputs, bool fLimitFree,\n \n         // are the actual inputs available?\n         if (!tx.HaveInputs(view))\n-            return error(\"CTxMemPool::accept() : inputs already spent\");\n+            return state.Invalid(error(\"CTxMemPool::accept() : inputs already spent\"));\n \n         // Bring the best block into scope\n         view.GetBestBlock();\n@@ -769,7 +769,7 @@ bool CTxMemPool::accept(CTransaction &tx, bool fCheckInputs, bool fLimitFree,\n \n         // Check against previous transactions\n         // This is done last to help prevent CPU exhaustion denial-of-service attacks.\n-        if (!tx.CheckInputs(view, true, SCRIPT_VERIFY_P2SH))\n+        if (!tx.CheckInputs(state, view, true, SCRIPT_VERIFY_P2SH))\n         {\n             return error(\"CTxMemPool::accept() : ConnectInputs failed %s\", hash.ToString().substr(0,10).c_str());\n         }\n@@ -798,9 +798,9 @@ bool CTxMemPool::accept(CTransaction &tx, bool fCheckInputs, bool fLimitFree,\n     return true;\n }\n \n-bool CTransaction::AcceptToMemoryPool(bool fCheckInputs, bool fLimitFree, bool* pfMissingInputs)\n+bool CTransaction::AcceptToMemoryPool(CValidationState &state, bool fCheckInputs, bool fLimitFree, bool* pfMissingInputs)\n {\n-    return mempool.accept(*this, fCheckInputs, fLimitFree, pfMissingInputs);\n+    return mempool.accept(state, *this, fCheckInputs, fLimitFree, pfMissingInputs);\n }\n \n bool CTxMemPool::addUnchecked(const uint256& hash, CTransaction &tx)\n@@ -913,7 +913,8 @@ int CMerkleTx::GetBlocksToMaturity() const\n \n bool CMerkleTx::AcceptToMemoryPool(bool fCheckInputs, bool fLimitFree)\n {\n-    return CTransaction::AcceptToMemoryPool(fCheckInputs, fLimitFree);\n+    CValidationState state;\n+    return CTransaction::AcceptToMemoryPool(state, fCheckInputs, fLimitFree);\n }\n \n \n@@ -1209,11 +1210,13 @@ void static InvalidBlockFound(CBlockIndex *pindex) {\n     pblocktree->WriteBlockIndex(CDiskBlockIndex(pindex));\n     setBlockIndexValid.erase(pindex);\n     InvalidChainFound(pindex);\n-    if (pindex->pnext)\n-        ConnectBestBlock(); // reorganise away from the failed block\n+    if (pindex->pnext) {\n+        CValidationState stateDummy;\n+        ConnectBestBlock(stateDummy); // reorganise away from the failed block\n+    }\n }\n \n-bool ConnectBestBlock() {\n+bool ConnectBestBlock(CValidationState &state) {\n     do {\n         CBlockIndex *pindexNewBest;\n \n@@ -1252,7 +1255,8 @@ bool ConnectBestBlock() {\n                 BOOST_FOREACH(CBlockIndex *pindexSwitch, vAttach) {\n                     if (fRequestShutdown)\n                         break;\n-                    if (!SetBestChain(pindexSwitch))\n+                    CValidationState state;\n+                    if (!SetBestChain(state, pindexSwitch))\n                         return false;\n                 }\n                 return true;\n@@ -1315,22 +1319,20 @@ unsigned int CTransaction::GetP2SHSigOpCount(CCoinsViewCache& inputs) const\n     return nSigOps;\n }\n \n-bool CTransaction::UpdateCoins(CCoinsViewCache &inputs, CTxUndo &txundo, int nHeight, const uint256 &txhash) const\n+bool CTransaction::UpdateCoins(CValidationState &state, CCoinsViewCache &inputs, CTxUndo &txundo, int nHeight, const uint256 &txhash) const\n {\n     // mark inputs spent\n     if (!IsCoinBase()) {\n         BOOST_FOREACH(const CTxIn &txin, vin) {\n             CCoins &coins = inputs.GetCoins(txin.prevout.hash);\n             CTxInUndo undo;\n-            if (!coins.Spend(txin.prevout, undo))\n-                return error(\"UpdateCoins() : cannot spend input\");\n+            assert(coins.Spend(txin.prevout, undo));\n             txundo.vprevout.push_back(undo);\n         }\n     }\n \n     // add outputs\n-    if (!inputs.SetCoins(txhash, CCoins(*this, nHeight)))\n-        return error(\"UpdateCoins() : cannot update output\");\n+    assert(inputs.SetCoins(txhash, CCoins(*this, nHeight)));\n \n     return true;\n }\n@@ -1368,7 +1370,7 @@ bool VerifySignature(const CCoins& txFrom, const CTransaction& txTo, unsigned in\n     return CScriptCheck(txFrom, txTo, nIn, flags, nHashType)();\n }\n \n-bool CTransaction::CheckInputs(CCoinsViewCache &inputs, bool fScriptChecks, unsigned int flags, std::vector<CScriptCheck> *pvChecks) const\n+bool CTransaction::CheckInputs(CValidationState &state, CCoinsViewCache &inputs, bool fScriptChecks, unsigned int flags, std::vector<CScriptCheck> *pvChecks) const\n {\n     if (!IsCoinBase())\n     {\n@@ -1378,7 +1380,7 @@ bool CTransaction::CheckInputs(CCoinsViewCache &inputs, bool fScriptChecks, unsi\n         // This doesn't trigger the DoS code on purpose; if it did, it would make it easier\n         // for an attacker to attempt to split the network.\n         if (!HaveInputs(inputs))\n-            return error(\"CheckInputs() : %s inputs unavailable\", GetHash().ToString().substr(0,10).c_str());\n+            return state.Invalid(error(\"CheckInputs() : %s inputs unavailable\", GetHash().ToString().substr(0,10).c_str()));\n \n         // While checking, GetBestBlock() refers to the parent block.\n         // This is also true for mempool checks.\n@@ -1393,26 +1395,26 @@ bool CTransaction::CheckInputs(CCoinsViewCache &inputs, bool fScriptChecks, unsi\n             // If prev is coinbase, check that it's matured\n             if (coins.IsCoinBase()) {\n                 if (nSpendHeight - coins.nHeight < COINBASE_MATURITY)\n-                    return error(\"CheckInputs() : tried to spend coinbase at depth %d\", nSpendHeight - coins.nHeight);\n+                    return state.Invalid(error(\"CheckInputs() : tried to spend coinbase at depth %d\", nSpendHeight - coins.nHeight));\n             }\n \n             // Check for negative or overflow input values\n             nValueIn += coins.vout[prevout.n].nValue;\n             if (!MoneyRange(coins.vout[prevout.n].nValue) || !MoneyRange(nValueIn))\n-                return DoS(100, error(\"CheckInputs() : txin values out of range\"));\n+                return state.DoS(100, error(\"CheckInputs() : txin values out of range\"));\n \n         }\n \n         if (nValueIn < GetValueOut())\n-            return DoS(100, error(\"ChecktInputs() : %s value in < value out\", GetHash().ToString().substr(0,10).c_str()));\n+            return state.DoS(100, error(\"ChecktInputs() : %s value in < value out\", GetHash().ToString().substr(0,10).c_str()));\n \n         // Tally transaction fees\n         int64 nTxFee = nValueIn - GetValueOut();\n         if (nTxFee < 0)\n-            return DoS(100, error(\"CheckInputs() : %s nTxFee < 0\", GetHash().ToString().substr(0,10).c_str()));\n+            return state.DoS(100, error(\"CheckInputs() : %s nTxFee < 0\", GetHash().ToString().substr(0,10).c_str()));\n         nFees += nTxFee;\n         if (!MoneyRange(nFees))\n-            return DoS(100, error(\"CheckInputs() : nFees out of range\"));\n+            return state.DoS(100, error(\"CheckInputs() : nFees out of range\"));\n \n         // The first loop above does all the inexpensive checks.\n         // Only if ALL inputs pass do we perform expensive ECDSA signature checks.\n@@ -1432,7 +1434,7 @@ bool CTransaction::CheckInputs(CCoinsViewCache &inputs, bool fScriptChecks, unsi\n                     pvChecks->push_back(CScriptCheck());\n                     check.swap(pvChecks->back());\n                 } else if (!check())\n-                    return DoS(100,false);\n+                    return state.DoS(100,false);\n             }\n         }\n     }\n@@ -1441,56 +1443,9 @@ bool CTransaction::CheckInputs(CCoinsViewCache &inputs, bool fScriptChecks, unsi\n }\n \n \n-bool CTransaction::ClientCheckInputs() const\n-{\n-    if (IsCoinBase())\n-        return false;\n-\n-    // Take over previous transactions' spent pointers\n-    {\n-        LOCK(mempool.cs);\n-        int64 nValueIn = 0;\n-        for (unsigned int i = 0; i < vin.size(); i++)\n-        {\n-            // Get prev tx from single transactions in memory\n-            COutPoint prevout = vin[i].prevout;\n-            if (!mempool.exists(prevout.hash))\n-                return false;\n-            CTransaction& txPrev = mempool.lookup(prevout.hash);\n-\n-            if (prevout.n >= txPrev.vout.size())\n-                return false;\n-\n-            // Verify signature\n-            if (!VerifySignature(CCoins(txPrev, -1), *this, i, SCRIPT_VERIFY_P2SH, 0))\n-                return error(\"ConnectInputs() : VerifySignature failed\");\n-\n-            ///// this is redundant with the mempool.mapNextTx stuff,\n-            ///// not sure which I want to get rid of\n-            ///// this has to go away now that posNext is gone\n-            // // Check for conflicts\n-            // if (!txPrev.vout[prevout.n].posNext.IsNull())\n-            //     return error(\"ConnectInputs() : prev tx already used\");\n-            //\n-            // // Flag outpoints as used\n-            // txPrev.vout[prevout.n].posNext = posThisTx;\n-\n-            nValueIn += txPrev.vout[prevout.n].nValue;\n-\n-            if (!MoneyRange(txPrev.vout[prevout.n].nValue) || !MoneyRange(nValueIn))\n-                return error(\"ClientConnectInputs() : txin values out of range\");\n-        }\n-        if (GetValueOut() > nValueIn)\n-            return false;\n-    }\n-\n-    return true;\n-}\n-\n-\n \n \n-bool CBlock::DisconnectBlock(CBlockIndex *pindex, CCoinsViewCache &view, bool *pfClean)\n+bool CBlock::DisconnectBlock(CValidationState &state, CBlockIndex *pindex, CCoinsViewCache &view, bool *pfClean)\n {\n     assert(pindex == view.GetBestBlock());\n \n@@ -1591,7 +1546,7 @@ void static FlushBlockFile()\n     }\n }\n \n-bool FindUndoPos(int nFile, CDiskBlockPos &pos, unsigned int nAddSize);\n+bool FindUndoPos(CValidationState &state, int nFile, CDiskBlockPos &pos, unsigned int nAddSize);\n \n static CCheckQueue<CScriptCheck> scriptcheckqueue(128);\n \n@@ -1606,10 +1561,10 @@ void ThreadScriptCheckQuit() {\n     scriptcheckqueue.Quit();\n }\n \n-bool CBlock::ConnectBlock(CBlockIndex* pindex, CCoinsViewCache &view, bool fJustCheck)\n+bool CBlock::ConnectBlock(CValidationState &state, CBlockIndex* pindex, CCoinsViewCache &view, bool fJustCheck)\n {\n     // Check it again in case a previous version let a bad block in\n-    if (!CheckBlock(!fJustCheck, !fJustCheck))\n+    if (!CheckBlock(state, !fJustCheck, !fJustCheck))\n         return false;\n \n     // verify that the view's current state corresponds to the previous block\n@@ -1674,12 +1629,12 @@ bool CBlock::ConnectBlock(CBlockIndex* pindex, CCoinsViewCache &view, bool fJust\n         nInputs += tx.vin.size();\n         nSigOps += tx.GetLegacySigOpCount();\n         if (nSigOps > MAX_BLOCK_SIGOPS)\n-            return DoS(100, error(\"ConnectBlock() : too many sigops\"));\n+            return state.DoS(100, error(\"ConnectBlock() : too many sigops\"));\n \n         if (!tx.IsCoinBase())\n         {\n             if (!tx.HaveInputs(view))\n-                return DoS(100, error(\"ConnectBlock() : inputs missing/spent\"));\n+                return state.DoS(100, error(\"ConnectBlock() : inputs missing/spent\"));\n \n             if (fStrictPayToScriptHash)\n             {\n@@ -1688,19 +1643,19 @@ bool CBlock::ConnectBlock(CBlockIndex* pindex, CCoinsViewCache &view, bool fJust\n                 // an incredibly-expensive-to-validate block.\n                 nSigOps += tx.GetP2SHSigOpCount(view);\n                 if (nSigOps > MAX_BLOCK_SIGOPS)\n-                     return DoS(100, error(\"ConnectBlock() : too many sigops\"));\n+                     return state.DoS(100, error(\"ConnectBlock() : too many sigops\"));\n             }\n \n             nFees += tx.GetValueIn(view)-tx.GetValueOut();\n \n             std::vector<CScriptCheck> vChecks;\n-            if (!tx.CheckInputs(view, fScriptChecks, flags, nScriptCheckThreads ? &vChecks : NULL))\n+            if (!tx.CheckInputs(state, view, fScriptChecks, flags, nScriptCheckThreads ? &vChecks : NULL))\n                 return false;\n             control.Add(vChecks);\n         }\n \n         CTxUndo txundo;\n-        if (!tx.UpdateCoins(view, txundo, pindex->nHeight, GetTxHash(i)))\n+        if (!tx.UpdateCoins(state, view, txundo, pindex->nHeight, GetTxHash(i)))\n             return error(\"ConnectBlock() : UpdateInputs failed\");\n         if (!tx.IsCoinBase())\n             blockundo.vtxundo.push_back(txundo);\n@@ -1713,10 +1668,10 @@ bool CBlock::ConnectBlock(CBlockIndex* pindex, CCoinsViewCache &view, bool fJust\n         printf(\"- Connect %u transactions: %.2fms (%.3fms/tx, %.3fms/txin)\\n\", (unsigned)vtx.size(), 0.001 * nTime, 0.001 * nTime / vtx.size(), nInputs <= 1 ? 0 : 0.001 * nTime / (nInputs-1));\n \n     if (vtx[0].GetValueOut() > GetBlockValue(pindex->nHeight, nFees))\n-        return error(\"ConnectBlock() : coinbase pays too much (actual=%\"PRI64d\" vs limit=%\"PRI64d\")\", vtx[0].GetValueOut(), GetBlockValue(pindex->nHeight, nFees));\n+        return state.Invalid(error(\"ConnectBlock() : coinbase pays too much (actual=%\"PRI64d\" vs limit=%\"PRI64d\")\", vtx[0].GetValueOut(), GetBlockValue(pindex->nHeight, nFees)));\n \n     if (!control.Wait())\n-        return DoS(100, false);\n+        return state.DoS(100, false);\n     int64 nTime2 = GetTimeMicros() - nStart;\n     if (fBenchmark)\n         printf(\"- Verify %u txins: %.2fms (%.3fms/txin)\\n\", nInputs - 1, 0.001 * nTime2, nInputs <= 1 ? 0 : 0.001 * nTime2 / (nInputs-1));\n@@ -1729,10 +1684,10 @@ bool CBlock::ConnectBlock(CBlockIndex* pindex, CCoinsViewCache &view, bool fJust\n     {\n         if (pindex->GetUndoPos().IsNull()) {\n             CDiskBlockPos pos;\n-            if (!FindUndoPos(pindex->nFile, pos, ::GetSerializeSize(blockundo, SER_DISK, CLIENT_VERSION) + 40))\n+            if (!FindUndoPos(state, pindex->nFile, pos, ::GetSerializeSize(blockundo, SER_DISK, CLIENT_VERSION) + 40))\n                 return error(\"ConnectBlock() : FindUndoPos failed\");\n             if (!blockundo.WriteToDisk(pos, pindex->pprev->GetBlockHash()))\n-                return error(\"ConnectBlock() : CBlockUndo::WriteToDisk failed\");\n+                return state.Error(error(\"ConnectBlock() : CBlockUndo::WriteToDisk failed\"));\n \n             // update nUndoPos in block index\n             pindex->nUndoPos = pos.nPos;\n@@ -1743,15 +1698,16 @@ bool CBlock::ConnectBlock(CBlockIndex* pindex, CCoinsViewCache &view, bool fJust\n \n         CDiskBlockIndex blockindex(pindex);\n         if (!pblocktree->WriteBlockIndex(blockindex))\n-            return error(\"ConnectBlock() : WriteBlockIndex failed\");\n+            return state.Error(error(\"ConnectBlock() : WriteBlockIndex failed\"));\n     }\n \n     if (fTxIndex)\n-        pblocktree->WriteTxIndex(vPos);\n+        if (!pblocktree->WriteTxIndex(vPos))\n+            return state.Error(error(\"ConnectBlock() : WriteTxIndex failed\"));\n \n     // add this block to the view's block chain\n     if (!view.SetBestBlock(pindex))\n-        return false;\n+        return state.Error();\n \n     // Watch for transactions paying to me\n     for (unsigned int i=0; i<vtx.size(); i++)\n@@ -1760,7 +1716,7 @@ bool CBlock::ConnectBlock(CBlockIndex* pindex, CCoinsViewCache &view, bool fJust\n     return true;\n }\n \n-bool SetBestChain(CBlockIndex* pindexNew)\n+bool SetBestChain(CValidationState &state, CBlockIndex* pindexNew)\n {\n     // All modifications to the coin state will be done in this cache.\n     // Only when all have succeeded, we push it to pcoinsTip.\n@@ -1773,11 +1729,11 @@ bool SetBestChain(CBlockIndex* pindexNew)\n     {\n         while (plonger->nHeight > pfork->nHeight)\n             if (!(plonger = plonger->pprev))\n-                return error(\"SetBestChain() : plonger->pprev is null\");\n+                return state.Error(error(\"SetBestChain() : plonger->pprev is null\"));\n         if (pfork == plonger)\n             break;\n         if (!(pfork = pfork->pprev))\n-            return error(\"SetBestChain() : pfork->pprev is null\");\n+            return state.Error(error(\"SetBestChain() : pfork->pprev is null\"));\n     }\n \n     // List of what to disconnect (typically nothing)\n@@ -1801,9 +1757,9 @@ bool SetBestChain(CBlockIndex* pindexNew)\n     BOOST_FOREACH(CBlockIndex* pindex, vDisconnect) {\n         CBlock block;\n         if (!block.ReadFromDisk(pindex))\n-            return error(\"SetBestBlock() : ReadFromDisk for disconnect failed\");\n+            return state.Error(error(\"SetBestBlock() : ReadFromDisk for disconnect failed\"));\n         int64 nStart = GetTimeMicros();\n-        if (!block.DisconnectBlock(pindex, view))\n+        if (!block.DisconnectBlock(state, pindex, view))\n             return error(\"SetBestBlock() : DisconnectBlock %s failed\", BlockHashStr(pindex->GetBlockHash()).c_str());\n         if (fBenchmark)\n             printf(\"- Disconnect: %.2fms\\n\", (GetTimeMicros() - nStart) * 0.001);\n@@ -1821,11 +1777,13 @@ bool SetBestChain(CBlockIndex* pindexNew)\n     BOOST_FOREACH(CBlockIndex *pindex, vConnect) {\n         CBlock block;\n         if (!block.ReadFromDisk(pindex))\n-            return error(\"SetBestBlock() : ReadFromDisk for connect failed\");\n+            return state.Error(error(\"SetBestBlock() : ReadFromDisk for connect failed\"));\n         int64 nStart = GetTimeMicros();\n-        if (!block.ConnectBlock(pindex, view)) {\n-            InvalidChainFound(pindexNew);\n-            InvalidBlockFound(pindex);\n+        if (!block.ConnectBlock(state, pindex, view)) {\n+            if (state.IsInvalid()) {\n+                InvalidChainFound(pindexNew);\n+                InvalidBlockFound(pindex);\n+            }\n             return error(\"SetBestBlock() : ConnectBlock %s failed\", BlockHashStr(pindex->GetBlockHash()).c_str());\n         }\n         if (fBenchmark)\n@@ -1840,7 +1798,7 @@ bool SetBestChain(CBlockIndex* pindexNew)\n     int64 nStart = GetTimeMicros();\n     int nModified = view.GetCacheSize();\n     if (!view.Flush())\n-        return error(\"SetBestBlock() : unable to modify coin state\");\n+        return state.Error(error(\"SetBestBlock() : unable to modify coin state\"));\n     int64 nTime = GetTimeMicros() - nStart;\n     if (fBenchmark)\n         printf(\"- Flush %i transactions: %.2fms (%.4fms/tx)\\n\", nModified, 0.001 * nTime, 0.001 * nTime / nModified);\n@@ -1851,7 +1809,7 @@ bool SetBestChain(CBlockIndex* pindexNew)\n         FlushBlockFile();\n         pblocktree->Sync();\n         if (!pcoinsTip->Flush())\n-            return false;\n+            return state.Error();\n     }\n \n     // At this point, all changes have been done to the database.\n@@ -1868,8 +1826,11 @@ bool SetBestChain(CBlockIndex* pindexNew)\n             pindex->pprev->pnext = pindex;\n \n     // Resurrect memory transactions that were in the disconnected branch\n-    BOOST_FOREACH(CTransaction& tx, vResurrect)\n-        tx.AcceptToMemoryPool(true, false);\n+    BOOST_FOREACH(CTransaction& tx, vResurrect) {\n+        // ignore validation errors in resurrected transactions\n+        CValidationState stateDummy;\n+        tx.AcceptToMemoryPool(stateDummy, true, false);\n+    }\n \n     // Delete redundant memory transactions that are in the connected branch\n     BOOST_FOREACH(CTransaction& tx, vDelete) {\n@@ -1926,17 +1887,17 @@ bool SetBestChain(CBlockIndex* pindexNew)\n }\n \n \n-bool CBlock::AddToBlockIndex(const CDiskBlockPos &pos)\n+bool CBlock::AddToBlockIndex(CValidationState &state, const CDiskBlockPos &pos)\n {\n     // Check for duplicate\n     uint256 hash = GetHash();\n     if (mapBlockIndex.count(hash))\n-        return error(\"AddToBlockIndex() : %s already exists\", BlockHashStr(hash).c_str());\n+        return state.Invalid(error(\"AddToBlockIndex() : %s already exists\", BlockHashStr(hash).c_str()));\n \n     // Construct new block index object\n     CBlockIndex* pindexNew = new CBlockIndex(*this);\n     if (!pindexNew)\n-        return error(\"AddToBlockIndex() : new CBlockIndex failed\");\n+        return state.Error(error(\"AddToBlockIndex() : new CBlockIndex failed\"));\n     map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.insert(make_pair(hash, pindexNew)).first;\n     pindexNew->phashBlock = &((*mi).first);\n     map<uint256, CBlockIndex*>::iterator miPrev = mapBlockIndex.find(hashPrevBlock);\n@@ -1954,10 +1915,11 @@ bool CBlock::AddToBlockIndex(const CDiskBlockPos &pos)\n     pindexNew->nStatus = BLOCK_VALID_TRANSACTIONS | BLOCK_HAVE_DATA;\n     setBlockIndexValid.insert(pindexNew);\n \n-    pblocktree->WriteBlockIndex(CDiskBlockIndex(pindexNew));\n+    if (!pblocktree->WriteBlockIndex(CDiskBlockIndex(pindexNew)))\n+        return state.Error(error(\"AddToBlockIndex() : writing block index failed\"));\n \n     // New best?\n-    if (!ConnectBestBlock())\n+    if (!ConnectBestBlock(state))\n         return false;\n \n     if (pindexNew == pindexBest)\n@@ -1968,14 +1930,15 @@ bool CBlock::AddToBlockIndex(const CDiskBlockPos &pos)\n         hashPrevBestCoinBase = GetTxHash(0);\n     }\n \n-    pblocktree->Flush();\n+    if (!pblocktree->Flush())\n+        return state.Error(\"AddToBlockIndex() : failed to sync block tree\");\n \n     uiInterface.NotifyBlocksChanged();\n     return true;\n }\n \n \n-bool FindBlockPos(CDiskBlockPos &pos, unsigned int nAddSize, unsigned int nHeight, uint64 nTime, bool fKnown = false)\n+bool FindBlockPos(CValidationState &state, CDiskBlockPos &pos, unsigned int nAddSize, unsigned int nHeight, uint64 nTime, bool fKnown = false)\n {\n     bool fUpdatedLast = false;\n \n@@ -2017,19 +1980,19 @@ bool FindBlockPos(CDiskBlockPos &pos, unsigned int nAddSize, unsigned int nHeigh\n                 }\n             }\n             else\n-                return error(\"FindBlockPos() : out of disk space\");\n+                return state.Error(error(\"FindBlockPos() : out of disk space\"));\n         }\n     }\n \n     if (!pblocktree->WriteBlockFileInfo(nLastBlockFile, infoLastBlockFile))\n-        return error(\"FindBlockPos() : cannot write updated block info\");\n+        return state.Error(error(\"FindBlockPos() : cannot write updated block info\"));\n     if (fUpdatedLast)\n         pblocktree->WriteLastBlockFile(nLastBlockFile);\n \n     return true;\n }\n \n-bool FindUndoPos(int nFile, CDiskBlockPos &pos, unsigned int nAddSize)\n+bool FindUndoPos(CValidationState &state, int nFile, CDiskBlockPos &pos, unsigned int nAddSize)\n {\n     pos.nFile = nFile;\n \n@@ -2040,15 +2003,15 @@ bool FindUndoPos(int nFile, CDiskBlockPos &pos, unsigned int nAddSize)\n         pos.nPos = infoLastBlockFile.nUndoSize;\n         nNewSize = (infoLastBlockFile.nUndoSize += nAddSize);\n         if (!pblocktree->WriteBlockFileInfo(nLastBlockFile, infoLastBlockFile))\n-            return error(\"FindUndoPos() : cannot write updated block info\");\n+            return state.Error(error(\"FindUndoPos() : cannot write updated block info\"));\n     } else {\n         CBlockFileInfo info;\n         if (!pblocktree->ReadBlockFileInfo(nFile, info))\n-            return error(\"FindUndoPos() : cannot read block info\");\n+            return state.Error(error(\"FindUndoPos() : cannot read block info\"));\n         pos.nPos = info.nUndoSize;\n         nNewSize = (info.nUndoSize += nAddSize);\n         if (!pblocktree->WriteBlockFileInfo(nFile, info))\n-            return error(\"FindUndoPos() : cannot write updated block info\");\n+            return state.Error(error(\"FindUndoPos() : cannot write updated block info\"));\n     }\n \n     unsigned int nOldChunks = (pos.nPos + UNDOFILE_CHUNK_SIZE - 1) / UNDOFILE_CHUNK_SIZE;\n@@ -2063,41 +2026,41 @@ bool FindUndoPos(int nFile, CDiskBlockPos &pos, unsigned int nAddSize)\n             }\n         }\n         else\n-            return error(\"FindUndoPos() : out of disk space\");\n+            return state.Error(error(\"FindUndoPos() : out of disk space\"));\n     }\n \n     return true;\n }\n \n \n-bool CBlock::CheckBlock(bool fCheckPOW, bool fCheckMerkleRoot) const\n+bool CBlock::CheckBlock(CValidationState &state, bool fCheckPOW, bool fCheckMerkleRoot) const\n {\n     // These are checks that are independent of context\n     // that can be verified before saving an orphan block.\n \n     // Size limits\n     if (vtx.empty() || vtx.size() > MAX_BLOCK_SIZE || ::GetSerializeSize(*this, SER_NETWORK, PROTOCOL_VERSION) > MAX_BLOCK_SIZE)\n-        return DoS(100, error(\"CheckBlock() : size limits failed\"));\n+        return state.DoS(100, error(\"CheckBlock() : size limits failed\"));\n \n     // Check proof of work matches claimed amount\n     if (fCheckPOW && !CheckProofOfWork(GetHash(), nBits))\n-        return DoS(50, error(\"CheckBlock() : proof of work failed\"));\n+        return state.DoS(50, error(\"CheckBlock() : proof of work failed\"));\n \n     // Check timestamp\n     if (GetBlockTime() > GetAdjustedTime() + 2 * 60 * 60)\n-        return error(\"CheckBlock() : block timestamp too far in the future\");\n+        return state.Invalid(error(\"CheckBlock() : block timestamp too far in the future\"));\n \n     // First transaction must be coinbase, the rest must not be\n     if (vtx.empty() || !vtx[0].IsCoinBase())\n-        return DoS(100, error(\"CheckBlock() : first tx is not coinbase\"));\n+        return state.DoS(100, error(\"CheckBlock() : first tx is not coinbase\"));\n     for (unsigned int i = 1; i < vtx.size(); i++)\n         if (vtx[i].IsCoinBase())\n-            return DoS(100, error(\"CheckBlock() : more than one coinbase\"));\n+            return state.DoS(100, error(\"CheckBlock() : more than one coinbase\"));\n \n     // Check transactions\n     BOOST_FOREACH(const CTransaction& tx, vtx)\n-        if (!tx.CheckTransaction())\n-            return DoS(tx.nDoS, error(\"CheckBlock() : CheckTransaction failed\"));\n+        if (!tx.CheckTransaction(state))\n+            return error(\"CheckBlock() : CheckTransaction failed\");\n \n     // Build the merkle tree already. We need it anyway later, and it makes the\n     // block cache the transaction hashes, which means they don't need to be\n@@ -2111,64 +2074,64 @@ bool CBlock::CheckBlock(bool fCheckPOW, bool fCheckMerkleRoot) const\n         uniqueTx.insert(GetTxHash(i));\n     }\n     if (uniqueTx.size() != vtx.size())\n-        return DoS(100, error(\"CheckBlock() : duplicate transaction\"));\n+        return state.DoS(100, error(\"CheckBlock() : duplicate transaction\"));\n \n     unsigned int nSigOps = 0;\n     BOOST_FOREACH(const CTransaction& tx, vtx)\n     {\n         nSigOps += tx.GetLegacySigOpCount();\n     }\n     if (nSigOps > MAX_BLOCK_SIGOPS)\n-        return DoS(100, error(\"CheckBlock() : out-of-bounds SigOpCount\"));\n+        return state.DoS(100, error(\"CheckBlock() : out-of-bounds SigOpCount\"));\n \n     // Check merkle root\n     if (fCheckMerkleRoot && hashMerkleRoot != BuildMerkleTree())\n-        return DoS(100, error(\"CheckBlock() : hashMerkleRoot mismatch\"));\n+        return state.DoS(100, error(\"CheckBlock() : hashMerkleRoot mismatch\"));\n \n     return true;\n }\n \n-bool CBlock::AcceptBlock(CDiskBlockPos *dbp)\n+bool CBlock::AcceptBlock(CValidationState &state, CDiskBlockPos *dbp)\n {\n     // Check for duplicate\n     uint256 hash = GetHash();\n     if (mapBlockIndex.count(hash))\n-        return error(\"AcceptBlock() : block already in mapBlockIndex\");\n+        return state.Invalid(error(\"AcceptBlock() : block already in mapBlockIndex\"));\n \n     // Get prev block index\n     CBlockIndex* pindexPrev = NULL;\n     int nHeight = 0;\n     if (hash != hashGenesisBlock) {\n         map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashPrevBlock);\n         if (mi == mapBlockIndex.end())\n-            return DoS(10, error(\"AcceptBlock() : prev block not found\"));\n+            return state.DoS(10, error(\"AcceptBlock() : prev block not found\"));\n         pindexPrev = (*mi).second;\n         nHeight = pindexPrev->nHeight+1;\n \n         // Check proof of work\n         if (nBits != GetNextWorkRequired(pindexPrev, this))\n-            return DoS(100, error(\"AcceptBlock() : incorrect proof of work\"));\n+            return state.DoS(100, error(\"AcceptBlock() : incorrect proof of work\"));\n \n         // Check timestamp against prev\n         if (GetBlockTime() <= pindexPrev->GetMedianTimePast())\n-            return error(\"AcceptBlock() : block's timestamp is too early\");\n+            return state.Invalid(error(\"AcceptBlock() : block's timestamp is too early\"));\n \n         // Check that all transactions are finalized\n         BOOST_FOREACH(const CTransaction& tx, vtx)\n             if (!tx.IsFinal(nHeight, GetBlockTime()))\n-                return DoS(10, error(\"AcceptBlock() : contains a non-final transaction\"));\n+                return state.DoS(10, error(\"AcceptBlock() : contains a non-final transaction\"));\n \n         // Check that the block chain matches the known block chain up to a checkpoint\n         if (!Checkpoints::CheckBlock(nHeight, hash))\n-            return DoS(100, error(\"AcceptBlock() : rejected by checkpoint lock-in at %d\", nHeight));\n+            return state.DoS(100, error(\"AcceptBlock() : rejected by checkpoint lock-in at %d\", nHeight));\n \n         // Reject block.nVersion=1 blocks when 95% (75% on testnet) of the network has upgraded:\n         if (nVersion < 2)\n         {\n             if ((!fTestNet && CBlockIndex::IsSuperMajority(2, pindexPrev, 950, 1000)) ||\n                 (fTestNet && CBlockIndex::IsSuperMajority(2, pindexPrev, 75, 100)))\n             {\n-                return error(\"AcceptBlock() : rejected nVersion=1 block\");\n+                return state.Invalid(error(\"AcceptBlock() : rejected nVersion=1 block\"));\n             }\n         }\n         // Enforce block.nVersion=2 rule that the coinbase starts with serialized block height\n@@ -2180,7 +2143,7 @@ bool CBlock::AcceptBlock(CDiskBlockPos *dbp)\n             {\n                 CScript expect = CScript() << nHeight;\n                 if (!std::equal(expect.begin(), expect.end(), vtx[0].vin[0].scriptSig.begin()))\n-                    return DoS(100, error(\"AcceptBlock() : block height mismatch in coinbase\"));\n+                    return state.DoS(100, error(\"AcceptBlock() : block height mismatch in coinbase\"));\n             }\n         }\n     }\n@@ -2190,12 +2153,12 @@ bool CBlock::AcceptBlock(CDiskBlockPos *dbp)\n     CDiskBlockPos blockPos;\n     if (dbp != NULL)\n         blockPos = *dbp;\n-    if (!FindBlockPos(blockPos, nBlockSize+8, nHeight, nTime, dbp != NULL))\n+    if (!FindBlockPos(state, blockPos, nBlockSize+8, nHeight, nTime, dbp != NULL))\n         return error(\"AcceptBlock() : FindBlockPos failed\");\n     if (dbp == NULL)\n         if (!WriteToDisk(blockPos))\n-            return error(\"AcceptBlock() : WriteToDisk failed\");\n-    if (!AddToBlockIndex(blockPos))\n+            return state.Error(error(\"AcceptBlock() : WriteToDisk failed\"));\n+    if (!AddToBlockIndex(state, blockPos))\n         return error(\"AcceptBlock() : AddToBlockIndex failed\");\n \n     // Relay inventory, but don't relay old inventory during initial block download\n@@ -2223,17 +2186,17 @@ bool CBlockIndex::IsSuperMajority(int minVersion, const CBlockIndex* pstart, uns\n     return (nFound >= nRequired);\n }\n \n-bool ProcessBlock(CNode* pfrom, CBlock* pblock, CDiskBlockPos *dbp)\n+bool ProcessBlock(CValidationState &state, CNode* pfrom, CBlock* pblock, CDiskBlockPos *dbp)\n {\n     // Check for duplicate\n     uint256 hash = pblock->GetHash();\n     if (mapBlockIndex.count(hash))\n-        return error(\"ProcessBlock() : already have block %d %s\", mapBlockIndex[hash]->nHeight, BlockHashStr(hash).c_str());\n+        return state.Invalid(error(\"ProcessBlock() : already have block %d %s\", mapBlockIndex[hash]->nHeight, BlockHashStr(hash).c_str()));\n     if (mapOrphanBlocks.count(hash))\n-        return error(\"ProcessBlock() : already have block (orphan) %s\", BlockHashStr(hash).c_str());\n+        return state.Invalid(error(\"ProcessBlock() : already have block (orphan) %s\", BlockHashStr(hash).c_str()));\n \n     // Preliminary checks\n-    if (!pblock->CheckBlock())\n+    if (!pblock->CheckBlock(state))\n         return error(\"ProcessBlock() : CheckBlock FAILED\");\n \n     CBlockIndex* pcheckpoint = Checkpoints::GetLastCheckpoint(mapBlockIndex);\n@@ -2243,19 +2206,15 @@ bool ProcessBlock(CNode* pfrom, CBlock* pblock, CDiskBlockPos *dbp)\n         int64 deltaTime = pblock->GetBlockTime() - pcheckpoint->nTime;\n         if (deltaTime < 0)\n         {\n-            if (pfrom)\n-                pfrom->Misbehaving(100);\n-            return error(\"ProcessBlock() : block with timestamp before last checkpoint\");\n+            return state.DoS(100, error(\"ProcessBlock() : block with timestamp before last checkpoint\"));\n         }\n         CBigNum bnNewBlock;\n         bnNewBlock.SetCompact(pblock->nBits);\n         CBigNum bnRequired;\n         bnRequired.SetCompact(ComputeMinWork(pcheckpoint->nBits, deltaTime));\n         if (bnNewBlock > bnRequired)\n         {\n-            if (pfrom)\n-                pfrom->Misbehaving(100);\n-            return error(\"ProcessBlock() : block with too little proof-of-work\");\n+            return state.DoS(100, error(\"ProcessBlock() : block with too little proof-of-work\"));\n         }\n     }\n \n@@ -2278,7 +2237,7 @@ bool ProcessBlock(CNode* pfrom, CBlock* pblock, CDiskBlockPos *dbp)\n     }\n \n     // Store to disk\n-    if (!pblock->AcceptBlock(dbp))\n+    if (!pblock->AcceptBlock(state, dbp))\n         return error(\"ProcessBlock() : AcceptBlock FAILED\");\n \n     // Recursively process any orphan blocks that depended on this one\n@@ -2292,7 +2251,7 @@ bool ProcessBlock(CNode* pfrom, CBlock* pblock, CDiskBlockPos *dbp)\n              ++mi)\n         {\n             CBlock* pblockOrphan = (*mi).second;\n-            if (pblockOrphan->AcceptBlock())\n+            if (pblockOrphan->AcceptBlock(state))\n                 vWorkQueue.push_back(pblockOrphan->GetHash());\n             mapOrphanBlocks.erase(pblockOrphan->GetHash());\n             delete pblockOrphan;\n@@ -2621,6 +2580,7 @@ bool VerifyDB() {\n     CBlockIndex* pindexState = pindexBest;\n     CBlockIndex* pindexFailure = NULL;\n     int nGoodTransactions = 0;\n+    CValidationState state;\n     for (CBlockIndex* pindex = pindexBest; pindex && pindex->pprev; pindex = pindex->pprev)\n     {\n         if (fRequestShutdown || pindex->nHeight < nBestHeight-nCheckDepth)\n@@ -2630,7 +2590,7 @@ bool VerifyDB() {\n         if (!block.ReadFromDisk(pindex))\n             return error(\"VerifyDB() : *** block.ReadFromDisk failed at %d, hash=%s\", pindex->nHeight, pindex->GetBlockHash().ToString().c_str());\n         // check level 1: verify block validity\n-        if (nCheckLevel >= 1 && !block.CheckBlock())\n+        if (nCheckLevel >= 1 && !block.CheckBlock(state))\n             return error(\"VerifyDB() : *** found bad block at %d, hash=%s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString().c_str());\n         // check level 2: verify undo validity\n         if (nCheckLevel >= 2 && pindex) {\n@@ -2644,7 +2604,7 @@ bool VerifyDB() {\n         // check level 3: check for inconsistencies during memory-only disconnect of tip blocks\n         if (nCheckLevel >= 3 && pindex == pindexState && (coins.GetCacheSize() + pcoinsTip->GetCacheSize()) <= 2*nCoinCacheSize + 32000) {\n             bool fClean = true;\n-            if (!block.DisconnectBlock(pindex, coins, &fClean))\n+            if (!block.DisconnectBlock(state, pindex, coins, &fClean))\n                 return error(\"VerifyDB() : *** irrecoverable inconsistency in block data at %d, hash=%s\", pindex->nHeight, pindex->GetBlockHash().ToString().c_str());\n             pindexState = pindex->pprev;\n             if (!fClean) {\n@@ -2665,7 +2625,7 @@ bool VerifyDB() {\n              CBlock block;\n              if (!block.ReadFromDisk(pindex))\n                  return error(\"VerifyDB() : *** block.ReadFromDisk failed at %d, hash=%s\", pindex->nHeight, pindex->GetBlockHash().ToString().c_str());\n-             if (!block.ConnectBlock(pindex, coins))\n+             if (!block.ConnectBlock(state, pindex, coins))\n                  return error(\"VerifyDB() : *** found unconnectable block at %d, hash=%s\", pindex->nHeight, pindex->GetBlockHash().ToString().c_str());\n         }\n     }\n@@ -2746,11 +2706,12 @@ bool LoadBlockIndex()\n         // Start new block file\n         unsigned int nBlockSize = ::GetSerializeSize(block, SER_DISK, CLIENT_VERSION);\n         CDiskBlockPos blockPos;\n-        if (!FindBlockPos(blockPos, nBlockSize+8, 0, block.nTime))\n+        CValidationState state;\n+        if (!FindBlockPos(state, blockPos, nBlockSize+8, 0, block.nTime))\n             return error(\"AcceptBlock() : FindBlockPos failed\");\n         if (!block.WriteToDisk(blockPos))\n             return error(\"LoadBlockIndex() : writing genesis block to disk failed\");\n-        if (!block.AddToBlockIndex(blockPos))\n+        if (!block.AddToBlockIndex(state, blockPos))\n             return error(\"LoadBlockIndex() : genesis block not accepted\");\n     }\n \n@@ -2880,8 +2841,11 @@ bool LoadExternalBlockFile(FILE* fileIn, CDiskBlockPos *dbp)\n                     LOCK(cs_main);\n                     if (dbp)\n                         dbp->nPos = nBlockPos;\n-                    if (ProcessBlock(NULL, &block, dbp))\n+                    CValidationState state;\n+                    if (ProcessBlock(state, NULL, &block, dbp))\n                         nLoaded++;\n+                    if (state.IsError())\n+                        break;\n                 }\n             } catch (std::exception &e) {\n                 printf(\"%s() : Deserialize or I/O error caught during load\\n\", __PRETTY_FUNCTION__);\n@@ -3457,7 +3421,8 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n         pfrom->AddInventoryKnown(inv);\n \n         bool fMissingInputs = false;\n-        if (tx.AcceptToMemoryPool(true, true, &fMissingInputs))\n+        CValidationState state;\n+        if (tx.AcceptToMemoryPool(state, true, true, &fMissingInputs))\n         {\n             RelayTransaction(tx, inv.hash, vMsg);\n             mapAlreadyAskedFor.erase(inv);\n@@ -3478,7 +3443,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n                     CInv inv(MSG_TX, tx.GetHash());\n                     bool fMissingInputs2 = false;\n \n-                    if (tx.AcceptToMemoryPool(true, true, &fMissingInputs2))\n+                    if (tx.AcceptToMemoryPool(state, true, true, &fMissingInputs2))\n                     {\n                         printf(\"   accepted orphan tx %s\\n\", inv.hash.ToString().substr(0,10).c_str());\n                         RelayTransaction(tx, inv.hash, vMsg);\n@@ -3507,7 +3472,9 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n             if (nEvicted > 0)\n                 printf(\"mapOrphan overflow, removed %u tx\\n\", nEvicted);\n         }\n-        if (tx.nDoS) pfrom->Misbehaving(tx.nDoS);\n+        int nDoS;\n+        if (state.IsInvalid(nDoS))\n+            pfrom->Misbehaving(nDoS);\n     }\n \n \n@@ -3522,9 +3489,12 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n         CInv inv(MSG_BLOCK, block.GetHash());\n         pfrom->AddInventoryKnown(inv);\n \n-        if (ProcessBlock(pfrom, &block))\n+        CValidationState state;\n+        if (ProcessBlock(state, pfrom, &block))\n             mapAlreadyAskedFor.erase(inv);\n-        if (block.nDoS) pfrom->Misbehaving(block.nDoS);\n+        int nDoS;\n+        if (state.IsInvalid(nDoS))\n+            pfrom->Misbehaving(nDoS);\n     }\n \n \n@@ -4274,12 +4244,13 @@ CBlockTemplate* CreateNewBlock(CReserveKey& reservekey)\n             if (nBlockSigOps + nTxSigOps >= MAX_BLOCK_SIGOPS)\n                 continue;\n \n-            if (!tx.CheckInputs(viewTemp, true, SCRIPT_VERIFY_P2SH))\n+            CValidationState state;\n+            if (!tx.CheckInputs(state, viewTemp, true, SCRIPT_VERIFY_P2SH))\n                 continue;\n \n             CTxUndo txundo;\n             uint256 hash = tx.GetHash();\n-            if (!tx.UpdateCoins(viewTemp, txundo, pindexPrev->nHeight+1, hash))\n+            if (!tx.UpdateCoins(state, viewTemp, txundo, pindexPrev->nHeight+1, hash))\n                 continue;\n \n             // push changes from the second layer cache to the first one\n@@ -4337,7 +4308,8 @@ CBlockTemplate* CreateNewBlock(CReserveKey& reservekey)\n         indexDummy.pprev = pindexPrev;\n         indexDummy.nHeight = pindexPrev->nHeight + 1;\n         CCoinsViewCache viewNew(*pcoinsTip, true);\n-        if (!pblock->ConnectBlock(&indexDummy, viewNew, true))\n+        CValidationState state;\n+        if (!pblock->ConnectBlock(state, &indexDummy, viewNew, true))\n             throw std::runtime_error(\"CreateNewBlock() : ConnectBlock failed\");\n     }\n \n@@ -4439,7 +4411,8 @@ bool CheckWork(CBlock* pblock, CWallet& wallet, CReserveKey& reservekey)\n         }\n \n         // Process this block the same as if we had received it from another node\n-        if (!ProcessBlock(NULL, pblock))\n+        CValidationState state;\n+        if (!ProcessBlock(state, NULL, pblock))\n             return error(\"BitcoinMiner : ProcessBlock, block not accepted\");\n     }\n "
      },
      {
        "sha": "9c2029c9b720d6f35bbec0249e375eb993a25d0e",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 57,
        "deletions": 27,
        "changes": 84,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ef3988ca369900206b0cfc32cc1958aee0e43710/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ef3988ca369900206b0cfc32cc1958aee0e43710/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=ef3988ca369900206b0cfc32cc1958aee0e43710",
        "patch": "@@ -112,17 +112,19 @@ class CTxUndo;\n class CCoinsView;\n class CCoinsViewCache;\n class CScriptCheck;\n+class CValidationState;\n \n struct CBlockTemplate;\n \n+\n /** Register a wallet to receive updates from core */\n void RegisterWallet(CWallet* pwalletIn);\n /** Unregister a wallet from core */\n void UnregisterWallet(CWallet* pwalletIn);\n /** Push an updated transaction to all registered wallets */\n void SyncWithWallets(const uint256 &hash, const CTransaction& tx, const CBlock* pblock = NULL, bool fUpdate = false);\n /** Process an incoming block */\n-bool ProcessBlock(CNode* pfrom, CBlock* pblock, CDiskBlockPos *dbp = NULL);\n+bool ProcessBlock(CValidationState &state, CNode* pfrom, CBlock* pblock, CDiskBlockPos *dbp = NULL);\n /** Check whether enough disk space is available for an incoming block */\n bool CheckDiskSpace(uint64 nAdditionalBytes = 0);\n /** Open a block file (blk?????.dat) */\n@@ -172,9 +174,9 @@ std::string GetWarnings(std::string strFor);\n /** Retrieve a transaction (from memory pool, or from disk, if possible) */\n bool GetTransaction(const uint256 &hash, CTransaction &tx, uint256 &hashBlock, bool fAllowSlow = false);\n /** Connect/disconnect blocks until pindexNew is the new tip of the active block chain */\n-bool SetBestChain(CBlockIndex* pindexNew);\n+bool SetBestChain(CValidationState &state, CBlockIndex* pindexNew);\n /** Find the best known block, and make it the tip of the block chain */\n-bool ConnectBestBlock();\n+bool ConnectBestBlock(CValidationState &state);\n /** Create a new block index entry for a given block hash */\n CBlockIndex * InsertBlockIndex(uint256 hash);\n /** Verify a signature */\n@@ -454,7 +456,6 @@ class CTxOut\n \n \n \n-\n enum GetMinFee_mode\n {\n     GMF_BLOCK,\n@@ -474,10 +475,6 @@ class CTransaction\n     std::vector<CTxOut> vout;\n     unsigned int nLockTime;\n \n-    // Denial-of-service detection:\n-    mutable int nDoS;\n-    bool DoS(int nDoSIn, bool fIn) const { nDoS += nDoSIn; return fIn; }\n-\n     CTransaction()\n     {\n         SetNull();\n@@ -498,7 +495,6 @@ class CTransaction\n         vin.clear();\n         vout.clear();\n         nLockTime = 0;\n-        nDoS = 0;  // Denial-of-service prevention\n     }\n \n     bool IsNull() const\n@@ -654,27 +650,24 @@ class CTransaction\n     }\n \n \n-    // Do all possible client-mode checks\n-    bool ClientCheckInputs() const;\n-\n     // Check whether all prevouts of this transaction are present in the UTXO set represented by view\n     bool HaveInputs(CCoinsViewCache &view) const;\n \n     // Check whether all inputs of this transaction are valid (no double spends, scripts & sigs, amounts)\n     // This does not modify the UTXO set. If pvChecks is not NULL, script checks are pushed onto it\n     // instead of being performed inline.\n-    bool CheckInputs(CCoinsViewCache &view, bool fScriptChecks = true,\n+    bool CheckInputs(CValidationState &state, CCoinsViewCache &view, bool fScriptChecks = true,\n                      unsigned int flags = SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_STRICTENC,\n                      std::vector<CScriptCheck> *pvChecks = NULL) const;\n \n     // Apply the effects of this transaction on the UTXO set represented by view\n-    bool UpdateCoins(CCoinsViewCache &view, CTxUndo &txundo, int nHeight, const uint256 &txhash) const;\n+    bool UpdateCoins(CValidationState &state, CCoinsViewCache &view, CTxUndo &txundo, int nHeight, const uint256 &txhash) const;\n \n     // Context-independent validity checks\n-    bool CheckTransaction() const;\n+    bool CheckTransaction(CValidationState &state) const;\n \n     // Try to accept this transaction into the memory pool\n-    bool AcceptToMemoryPool(bool fCheckInputs=true, bool fLimitFree = true, bool* pfMissingInputs=NULL);\n+    bool AcceptToMemoryPool(CValidationState &state, bool fCheckInputs=true, bool fLimitFree = true, bool* pfMissingInputs=NULL);\n \n protected:\n     static const CTxOut &GetOutputFor(const CTxIn& input, CCoinsViewCache& mapInputs);\n@@ -1320,10 +1313,6 @@ class CBlock : public CBlockHeader\n     // memory only\n     mutable std::vector<uint256> vMerkleTree;\n \n-    // Denial-of-service detection:\n-    mutable int nDoS;\n-    bool DoS(int nDoSIn, bool fIn) const { nDoS += nDoSIn; return fIn; }\n-\n     CBlock()\n     {\n         SetNull();\n@@ -1346,7 +1335,6 @@ class CBlock : public CBlockHeader\n         CBlockHeader::SetNull();\n         vtx.clear();\n         vMerkleTree.clear();\n-        nDoS = 0;\n     }\n \n     CBlockHeader GetBlockHeader() const\n@@ -1494,23 +1482,23 @@ class CBlock : public CBlockHeader\n      *  In case pfClean is provided, operation will try to be tolerant about errors, and *pfClean\n      *  will be true if no problems were found. Otherwise, the return value will be false in case\n      *  of problems. Note that in any case, coins may be modified. */\n-    bool DisconnectBlock(CBlockIndex *pindex, CCoinsViewCache &coins, bool *pfClean = NULL);\n+    bool DisconnectBlock(CValidationState &state, CBlockIndex *pindex, CCoinsViewCache &coins, bool *pfClean = NULL);\n \n     // Apply the effects of this block (with given index) on the UTXO set represented by coins\n-    bool ConnectBlock(CBlockIndex *pindex, CCoinsViewCache &coins, bool fJustCheck=false);\n+    bool ConnectBlock(CValidationState &state, CBlockIndex *pindex, CCoinsViewCache &coins, bool fJustCheck=false);\n \n     // Read a block from disk\n     bool ReadFromDisk(const CBlockIndex* pindex);\n \n     // Add this block to the block index, and if necessary, switch the active block chain to this\n-    bool AddToBlockIndex(const CDiskBlockPos &pos);\n+    bool AddToBlockIndex(CValidationState &state, const CDiskBlockPos &pos);\n \n     // Context-independent validity checks\n-    bool CheckBlock(bool fCheckPOW=true, bool fCheckMerkleRoot=true) const;\n+    bool CheckBlock(CValidationState &state, bool fCheckPOW=true, bool fCheckMerkleRoot=true) const;\n \n     // Store block on disk\n     // if dbp is provided, the file is known to already reside on disk\n-    bool AcceptBlock(CDiskBlockPos *dbp = NULL);\n+    bool AcceptBlock(CValidationState &state, CDiskBlockPos *dbp = NULL);\n };\n \n \n@@ -1877,6 +1865,48 @@ class CDiskBlockIndex : public CBlockIndex\n     }\n };\n \n+/** Capture information about block/transaction validation */\n+class CValidationState {\n+private:\n+    enum mode_state {\n+        MODE_VALID,   // everything ok\n+        MODE_INVALID, // network rule violation (DoS value may be set)\n+        MODE_ERROR,   // run-time error\n+    } mode;\n+    int nDoS;\n+public:\n+    CValidationState() : mode(MODE_VALID), nDoS(0) {}\n+    bool DoS(int level, bool ret = false) {\n+        if (mode == MODE_ERROR)\n+            return ret;\n+        nDoS += level;\n+        mode = MODE_INVALID;\n+        return ret;\n+    }\n+    bool Invalid(bool ret = false) {\n+        return DoS(0, ret);\n+    }\n+    bool Error(bool ret = false) {\n+        mode = MODE_ERROR;\n+        return ret;\n+    }\n+    bool IsValid() {\n+        return mode == MODE_VALID;\n+    }\n+    bool IsInvalid() {\n+        return mode == MODE_INVALID;\n+    }\n+    bool IsError() {\n+        return mode == MODE_ERROR;\n+    }\n+    bool IsInvalid(int &nDoSOut) {\n+        if (IsInvalid()) {\n+            nDoSOut = nDoS;\n+            return true;\n+        }\n+        return false;\n+    }\n+};\n \n \n \n@@ -2025,7 +2055,7 @@ class CTxMemPool\n     std::map<uint256, CTransaction> mapTx;\n     std::map<COutPoint, CInPoint> mapNextTx;\n \n-    bool accept(CTransaction &tx, bool fCheckInputs, bool fLimitFree, bool* pfMissingInputs);\n+    bool accept(CValidationState &state, CTransaction &tx, bool fCheckInputs, bool fLimitFree, bool* pfMissingInputs);\n     bool addUnchecked(const uint256& hash, CTransaction &tx);\n     bool remove(const CTransaction &tx, bool fRecursive = false);\n     bool removeConflicts(const CTransaction &tx);"
      },
      {
        "sha": "b9ebcb4001849bb77e51faf20370813e014cde69",
        "filename": "src/rpcmining.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ef3988ca369900206b0cfc32cc1958aee0e43710/src/rpcmining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ef3988ca369900206b0cfc32cc1958aee0e43710/src/rpcmining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcmining.cpp?ref=ef3988ca369900206b0cfc32cc1958aee0e43710",
        "patch": "@@ -365,9 +365,10 @@ Value submitblock(const Array& params, bool fHelp)\n         throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"Block decode failed\");\n     }\n \n-    bool fAccepted = ProcessBlock(NULL, &pblock);\n+    CValidationState state;\n+    bool fAccepted = ProcessBlock(state, NULL, &pblock);\n     if (!fAccepted)\n-        return \"rejected\";\n+        return \"rejected\"; // TODO: report validation state\n \n     return Value::null;\n }"
      },
      {
        "sha": "5224051ace8cff62499a6cc8e7b686761454435b",
        "filename": "src/rpcrawtransaction.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ef3988ca369900206b0cfc32cc1958aee0e43710/src/rpcrawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ef3988ca369900206b0cfc32cc1958aee0e43710/src/rpcrawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcrawtransaction.cpp?ref=ef3988ca369900206b0cfc32cc1958aee0e43710",
        "patch": "@@ -546,8 +546,9 @@ Value sendrawtransaction(const Array& params, bool fHelp)\n         fHave = view.GetCoins(hashTx, existingCoins);\n         if (!fHave) {\n             // push to local node\n-            if (!tx.AcceptToMemoryPool(true, false))\n-                throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX rejected\");\n+            CValidationState state;\n+            if (!tx.AcceptToMemoryPool(state, true, false))\n+                throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX rejected\"); // TODO: report validation state\n         }\n     }\n     if (fHave) {"
      },
      {
        "sha": "af284653dd9bab8f235d03e53d4db617ed2592dc",
        "filename": "src/test/miner_tests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ef3988ca369900206b0cfc32cc1958aee0e43710/src/test/miner_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ef3988ca369900206b0cfc32cc1958aee0e43710/src/test/miner_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/miner_tests.cpp?ref=ef3988ca369900206b0cfc32cc1958aee0e43710",
        "patch": "@@ -73,7 +73,9 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n             txFirst.push_back(new CTransaction(pblock->vtx[0]));\n         pblock->hashMerkleRoot = pblock->BuildMerkleTree();\n         pblock->nNonce = blockinfo[i].nonce;\n-        assert(ProcessBlock(NULL, pblock));\n+        CValidationState state;\n+        BOOST_CHECK(ProcessBlock(state, NULL, pblock));\n+        BOOST_CHECK(state.IsValid());\n         pblock->hashPrevBlock = pblock->GetHash();\n     }\n     delete pblocktemplate;"
      },
      {
        "sha": "f44d46fdb8c4475383a78f67708205c7e0da0649",
        "filename": "src/test/transaction_tests.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 4,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ef3988ca369900206b0cfc32cc1958aee0e43710/src/test/transaction_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ef3988ca369900206b0cfc32cc1958aee0e43710/src/test/transaction_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/transaction_tests.cpp?ref=ef3988ca369900206b0cfc32cc1958aee0e43710",
        "patch": "@@ -66,7 +66,9 @@ BOOST_AUTO_TEST_CASE(tx_valid)\n             CTransaction tx;\n             stream >> tx;\n \n-                BOOST_CHECK_MESSAGE(tx.CheckTransaction(), strTest);\n+            CValidationState state;\n+            BOOST_CHECK_MESSAGE(tx.CheckTransaction(state), strTest);\n+            BOOST_CHECK(state.IsValid());\n \n             for (unsigned int i = 0; i < tx.vin.size(); i++)\n             {\n@@ -133,7 +135,8 @@ BOOST_AUTO_TEST_CASE(tx_invalid)\n             CTransaction tx;\n             stream >> tx;\n \n-            fValid = tx.CheckTransaction();\n+            CValidationState state;\n+            fValid = tx.CheckTransaction(state) && state.IsValid();\n \n             for (unsigned int i = 0; i < tx.vin.size() && fValid; i++)\n             {\n@@ -159,11 +162,12 @@ BOOST_AUTO_TEST_CASE(basic_transaction_tests)\n     CDataStream stream(vch, SER_DISK, CLIENT_VERSION);\n     CTransaction tx;\n     stream >> tx;\n-    BOOST_CHECK_MESSAGE(tx.CheckTransaction(), \"Simple deserialized transaction should be valid.\");\n+    CValidationState state;\n+    BOOST_CHECK_MESSAGE(tx.CheckTransaction(state) && state.IsValid(), \"Simple deserialized transaction should be valid.\");\n \n     // Check that duplicate txins fail\n     tx.vin.push_back(tx.vin[0]);\n-    BOOST_CHECK_MESSAGE(!tx.CheckTransaction(), \"Transaction with duplicate txins should be invalid.\");\n+    BOOST_CHECK_MESSAGE(!tx.CheckTransaction(state) || !state.IsValid(), \"Transaction with duplicate txins should be invalid.\");\n }\n \n //"
      },
      {
        "sha": "fe9bce21e806b270a96f6aeeaf5933ed15408a49",
        "filename": "src/walletdb.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ef3988ca369900206b0cfc32cc1958aee0e43710/src/walletdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ef3988ca369900206b0cfc32cc1958aee0e43710/src/walletdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/walletdb.cpp?ref=ef3988ca369900206b0cfc32cc1958aee0e43710",
        "patch": "@@ -203,7 +203,8 @@ ReadKeyValue(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue,\n             ssKey >> hash;\n             CWalletTx& wtx = pwallet->mapWallet[hash];\n             ssValue >> wtx;\n-            if (wtx.CheckTransaction() && (wtx.GetHash() == hash))\n+            CValidationState state;\n+            if (wtx.CheckTransaction(state) && (wtx.GetHash() == hash) && state.IsValid())\n                 wtx.BindWallet(pwallet);\n             else\n             {"
      }
    ]
  },
  {
    "sha": "86c82bf9d09f4b3f9c29cc49a4615efd8c60a152",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4NmM4MmJmOWQwOWY0YjNmOWMyOWNjNDlhNDYxNWVmZDhjNjBhMTUy",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2013-01-26T23:15:45Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieterw@google.com",
        "date": "2013-01-30T02:56:44Z"
      },
      "message": "Treat coinbase value violation as DoS",
      "tree": {
        "sha": "88c9f0bfae377f71a22ed5eae532c1e9da6dc841",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/88c9f0bfae377f71a22ed5eae532c1e9da6dc841"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/86c82bf9d09f4b3f9c29cc49a4615efd8c60a152",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/86c82bf9d09f4b3f9c29cc49a4615efd8c60a152",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/86c82bf9d09f4b3f9c29cc49a4615efd8c60a152",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/86c82bf9d09f4b3f9c29cc49a4615efd8c60a152/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": null,
    "parents": [
      {
        "sha": "ef3988ca369900206b0cfc32cc1958aee0e43710",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ef3988ca369900206b0cfc32cc1958aee0e43710",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ef3988ca369900206b0cfc32cc1958aee0e43710"
      }
    ],
    "stats": {
      "total": 2,
      "additions": 1,
      "deletions": 1
    },
    "files": [
      {
        "sha": "1d881c0a3579efdc88df64763c256b5464325d5c",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/86c82bf9d09f4b3f9c29cc49a4615efd8c60a152/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/86c82bf9d09f4b3f9c29cc49a4615efd8c60a152/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=86c82bf9d09f4b3f9c29cc49a4615efd8c60a152",
        "patch": "@@ -1668,7 +1668,7 @@ bool CBlock::ConnectBlock(CValidationState &state, CBlockIndex* pindex, CCoinsVi\n         printf(\"- Connect %u transactions: %.2fms (%.3fms/tx, %.3fms/txin)\\n\", (unsigned)vtx.size(), 0.001 * nTime, 0.001 * nTime / vtx.size(), nInputs <= 1 ? 0 : 0.001 * nTime / (nInputs-1));\n \n     if (vtx[0].GetValueOut() > GetBlockValue(pindex->nHeight, nFees))\n-        return state.Invalid(error(\"ConnectBlock() : coinbase pays too much (actual=%\"PRI64d\" vs limit=%\"PRI64d\")\", vtx[0].GetValueOut(), GetBlockValue(pindex->nHeight, nFees)));\n+        return state.DoS(100, error(\"ConnectBlock() : coinbase pays too much (actual=%\"PRI64d\" vs limit=%\"PRI64d\")\", vtx[0].GetValueOut(), GetBlockValue(pindex->nHeight, nFees)));\n \n     if (!control.Wait())\n         return state.DoS(100, false);"
      }
    ]
  },
  {
    "sha": "18379c80874ad6f4fa0e962dd2046e2fa7ecd287",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxODM3OWM4MDg3NGFkNmY0ZmEwZTk2MmRkMjA0NmUyZmE3ZWNkMjg3",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2013-01-26T23:22:15Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieterw@google.com",
        "date": "2013-01-30T02:56:45Z"
      },
      "message": "Add disk space checks before flushing CCoins cache",
      "tree": {
        "sha": "a60dfa3a57c9195d2583b6cb45879658d319c8a3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a60dfa3a57c9195d2583b6cb45879658d319c8a3"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/18379c80874ad6f4fa0e962dd2046e2fa7ecd287",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/18379c80874ad6f4fa0e962dd2046e2fa7ecd287",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/18379c80874ad6f4fa0e962dd2046e2fa7ecd287",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/18379c80874ad6f4fa0e962dd2046e2fa7ecd287/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": null,
    "parents": [
      {
        "sha": "86c82bf9d09f4b3f9c29cc49a4615efd8c60a152",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/86c82bf9d09f4b3f9c29cc49a4615efd8c60a152",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/86c82bf9d09f4b3f9c29cc49a4615efd8c60a152"
      }
    ],
    "stats": {
      "total": 7,
      "additions": 7,
      "deletions": 0
    },
    "files": [
      {
        "sha": "2b4acccb9ec9b7230318efad0d361351acd11ab8",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/18379c80874ad6f4fa0e962dd2046e2fa7ecd287/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/18379c80874ad6f4fa0e962dd2046e2fa7ecd287/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=18379c80874ad6f4fa0e962dd2046e2fa7ecd287",
        "patch": "@@ -1806,6 +1806,13 @@ bool SetBestChain(CValidationState &state, CBlockIndex* pindexNew)\n     // Make sure it's successfully written to disk before changing memory structure\n     bool fIsInitialDownload = IsInitialBlockDownload();\n     if (!fIsInitialDownload || pcoinsTip->GetCacheSize() > nCoinCacheSize) {\n+        // Typical CCoins structures on disk are around 100 bytes in size.\n+        // Pushing a new one to the database can cause it to be written\n+        // twice (once in the log, and once in the tables). This is already\n+        // an overestimation, as most will delete an existing entry or\n+        // overwrite one. Still, use a conservative safety factor of 2.\n+        if (!CheckDiskSpace(100 * 2 * 2 * pcoinsTip->GetCacheSize()))\n+            return state.Error();\n         FlushBlockFile();\n         pblocktree->Sync();\n         if (!pcoinsTip->Flush())"
      }
    ]
  },
  {
    "sha": "7851033dd687e826df82c1ec841480710468ce8c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3ODUxMDMzZGQ2ODdlODI2ZGY4MmMxZWM4NDE0ODA3MTA0NjhjZThj",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2013-01-27T00:24:06Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieterw@google.com",
        "date": "2013-01-30T02:56:45Z"
      },
      "message": "Improve dealing with abort conditions",
      "tree": {
        "sha": "1e44c5d08afca9b9f7e72b04bbf77f1857f75476",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1e44c5d08afca9b9f7e72b04bbf77f1857f75476"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7851033dd687e826df82c1ec841480710468ce8c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7851033dd687e826df82c1ec841480710468ce8c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7851033dd687e826df82c1ec841480710468ce8c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7851033dd687e826df82c1ec841480710468ce8c/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": null,
    "parents": [
      {
        "sha": "18379c80874ad6f4fa0e962dd2046e2fa7ecd287",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/18379c80874ad6f4fa0e962dd2046e2fa7ecd287",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/18379c80874ad6f4fa0e962dd2046e2fa7ecd287"
      }
    ],
    "stats": {
      "total": 79,
      "additions": 42,
      "deletions": 37
    },
    "files": [
      {
        "sha": "82ef88b85575e457a0ffab56165500a7fba66d94",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 34,
        "deletions": 35,
        "changes": 69,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7851033dd687e826df82c1ec841480710468ce8c/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7851033dd687e826df82c1ec841480710468ce8c/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=7851033dd687e826df82c1ec841480710468ce8c",
        "patch": "@@ -1687,7 +1687,7 @@ bool CBlock::ConnectBlock(CValidationState &state, CBlockIndex* pindex, CCoinsVi\n             if (!FindUndoPos(state, pindex->nFile, pos, ::GetSerializeSize(blockundo, SER_DISK, CLIENT_VERSION) + 40))\n                 return error(\"ConnectBlock() : FindUndoPos failed\");\n             if (!blockundo.WriteToDisk(pos, pindex->pprev->GetBlockHash()))\n-                return state.Error(error(\"ConnectBlock() : CBlockUndo::WriteToDisk failed\"));\n+                return state.Abort(_(\"Error: failed to write undo data\"));\n \n             // update nUndoPos in block index\n             pindex->nUndoPos = pos.nPos;\n@@ -1698,16 +1698,15 @@ bool CBlock::ConnectBlock(CValidationState &state, CBlockIndex* pindex, CCoinsVi\n \n         CDiskBlockIndex blockindex(pindex);\n         if (!pblocktree->WriteBlockIndex(blockindex))\n-            return state.Error(error(\"ConnectBlock() : WriteBlockIndex failed\"));\n+            return state.Abort(_(\"Error: failed to write block index\"));\n     }\n \n     if (fTxIndex)\n         if (!pblocktree->WriteTxIndex(vPos))\n-            return state.Error(error(\"ConnectBlock() : WriteTxIndex failed\"));\n+            return state.Abort(_(\"Error: failed to write transaction index\"));\n \n     // add this block to the view's block chain\n-    if (!view.SetBestBlock(pindex))\n-        return state.Error();\n+    assert(view.SetBestBlock(pindex));\n \n     // Watch for transactions paying to me\n     for (unsigned int i=0; i<vtx.size(); i++)\n@@ -1727,13 +1726,14 @@ bool SetBestChain(CValidationState &state, CBlockIndex* pindexNew)\n     CBlockIndex* plonger = pindexNew;\n     while (pfork && pfork != plonger)\n     {\n-        while (plonger->nHeight > pfork->nHeight)\n-            if (!(plonger = plonger->pprev))\n-                return state.Error(error(\"SetBestChain() : plonger->pprev is null\"));\n+        while (plonger->nHeight > pfork->nHeight) {\n+            plonger = plonger->pprev;\n+            assert(plonger != NULL);\n+        }\n         if (pfork == plonger)\n             break;\n-        if (!(pfork = pfork->pprev))\n-            return state.Error(error(\"SetBestChain() : pfork->pprev is null\"));\n+        pfork = pfork->pprev;\n+        assert(pfork != NULL);\n     }\n \n     // List of what to disconnect (typically nothing)\n@@ -1757,7 +1757,7 @@ bool SetBestChain(CValidationState &state, CBlockIndex* pindexNew)\n     BOOST_FOREACH(CBlockIndex* pindex, vDisconnect) {\n         CBlock block;\n         if (!block.ReadFromDisk(pindex))\n-            return state.Error(error(\"SetBestBlock() : ReadFromDisk for disconnect failed\"));\n+            return state.Abort(_(\"Error: failed to read block\"));\n         int64 nStart = GetTimeMicros();\n         if (!block.DisconnectBlock(state, pindex, view))\n             return error(\"SetBestBlock() : DisconnectBlock %s failed\", BlockHashStr(pindex->GetBlockHash()).c_str());\n@@ -1777,7 +1777,7 @@ bool SetBestChain(CValidationState &state, CBlockIndex* pindexNew)\n     BOOST_FOREACH(CBlockIndex *pindex, vConnect) {\n         CBlock block;\n         if (!block.ReadFromDisk(pindex))\n-            return state.Error(error(\"SetBestBlock() : ReadFromDisk for connect failed\"));\n+            return state.Abort(_(\"Error: failed to read block\"));\n         int64 nStart = GetTimeMicros();\n         if (!block.ConnectBlock(state, pindex, view)) {\n             if (state.IsInvalid()) {\n@@ -1797,8 +1797,7 @@ bool SetBestChain(CValidationState &state, CBlockIndex* pindexNew)\n     // Flush changes to global coin state\n     int64 nStart = GetTimeMicros();\n     int nModified = view.GetCacheSize();\n-    if (!view.Flush())\n-        return state.Error(error(\"SetBestBlock() : unable to modify coin state\"));\n+    assert(view.Flush());\n     int64 nTime = GetTimeMicros() - nStart;\n     if (fBenchmark)\n         printf(\"- Flush %i transactions: %.2fms (%.4fms/tx)\\n\", nModified, 0.001 * nTime, 0.001 * nTime / nModified);\n@@ -1816,7 +1815,7 @@ bool SetBestChain(CValidationState &state, CBlockIndex* pindexNew)\n         FlushBlockFile();\n         pblocktree->Sync();\n         if (!pcoinsTip->Flush())\n-            return state.Error();\n+            return state.Abort(_(\"Error: failed to write to coin database\"));\n     }\n \n     // At this point, all changes have been done to the database.\n@@ -1903,8 +1902,7 @@ bool CBlock::AddToBlockIndex(CValidationState &state, const CDiskBlockPos &pos)\n \n     // Construct new block index object\n     CBlockIndex* pindexNew = new CBlockIndex(*this);\n-    if (!pindexNew)\n-        return state.Error(error(\"AddToBlockIndex() : new CBlockIndex failed\"));\n+    assert(pindexNew);\n     map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.insert(make_pair(hash, pindexNew)).first;\n     pindexNew->phashBlock = &((*mi).first);\n     map<uint256, CBlockIndex*>::iterator miPrev = mapBlockIndex.find(hashPrevBlock);\n@@ -1923,7 +1921,7 @@ bool CBlock::AddToBlockIndex(CValidationState &state, const CDiskBlockPos &pos)\n     setBlockIndexValid.insert(pindexNew);\n \n     if (!pblocktree->WriteBlockIndex(CDiskBlockIndex(pindexNew)))\n-        return state.Error(error(\"AddToBlockIndex() : writing block index failed\"));\n+        return state.Abort(_(\"Error: failed to write block index\"));\n \n     // New best?\n     if (!ConnectBestBlock(state))\n@@ -1938,7 +1936,7 @@ bool CBlock::AddToBlockIndex(CValidationState &state, const CDiskBlockPos &pos)\n     }\n \n     if (!pblocktree->Flush())\n-        return state.Error(\"AddToBlockIndex() : failed to sync block tree\");\n+        return state.Abort(_(\"Error: failed to sync block index\"));\n \n     uiInterface.NotifyBlocksChanged();\n     return true;\n@@ -1987,12 +1985,12 @@ bool FindBlockPos(CValidationState &state, CDiskBlockPos &pos, unsigned int nAdd\n                 }\n             }\n             else\n-                return state.Error(error(\"FindBlockPos() : out of disk space\"));\n+                return state.Error();\n         }\n     }\n \n     if (!pblocktree->WriteBlockFileInfo(nLastBlockFile, infoLastBlockFile))\n-        return state.Error(error(\"FindBlockPos() : cannot write updated block info\"));\n+        return state.Abort(_(\"Error: failed to write file info\"));\n     if (fUpdatedLast)\n         pblocktree->WriteLastBlockFile(nLastBlockFile);\n \n@@ -2010,15 +2008,15 @@ bool FindUndoPos(CValidationState &state, int nFile, CDiskBlockPos &pos, unsigne\n         pos.nPos = infoLastBlockFile.nUndoSize;\n         nNewSize = (infoLastBlockFile.nUndoSize += nAddSize);\n         if (!pblocktree->WriteBlockFileInfo(nLastBlockFile, infoLastBlockFile))\n-            return state.Error(error(\"FindUndoPos() : cannot write updated block info\"));\n+            return state.Abort(_(\"Error: failed to write block info\"));\n     } else {\n         CBlockFileInfo info;\n         if (!pblocktree->ReadBlockFileInfo(nFile, info))\n-            return state.Error(error(\"FindUndoPos() : cannot read block info\"));\n+            return state.Abort(_(\"Error: failed to read block info\"));\n         pos.nPos = info.nUndoSize;\n         nNewSize = (info.nUndoSize += nAddSize);\n         if (!pblocktree->WriteBlockFileInfo(nFile, info))\n-            return state.Error(error(\"FindUndoPos() : cannot write updated block info\"));\n+            return state.Abort(_(\"Error: failed to write block info\"));\n     }\n \n     unsigned int nOldChunks = (pos.nPos + UNDOFILE_CHUNK_SIZE - 1) / UNDOFILE_CHUNK_SIZE;\n@@ -2033,7 +2031,7 @@ bool FindUndoPos(CValidationState &state, int nFile, CDiskBlockPos &pos, unsigne\n             }\n         }\n         else\n-            return state.Error(error(\"FindUndoPos() : out of disk space\"));\n+            return state.Error();\n     }\n \n     return true;\n@@ -2164,7 +2162,7 @@ bool CBlock::AcceptBlock(CValidationState &state, CDiskBlockPos *dbp)\n         return error(\"AcceptBlock() : FindBlockPos failed\");\n     if (dbp == NULL)\n         if (!WriteToDisk(blockPos))\n-            return state.Error(error(\"AcceptBlock() : WriteToDisk failed\"));\n+            return state.Abort(_(\"Error: failed to write block\"));\n     if (!AddToBlockIndex(state, blockPos))\n         return error(\"AcceptBlock() : AddToBlockIndex failed\");\n \n@@ -2430,22 +2428,23 @@ uint256 CPartialMerkleTree::ExtractMatches(std::vector<uint256> &vMatch) {\n \n \n \n+bool AbortNode(const std::string &strMessage) {\n+    fRequestShutdown = true;\n+    strMiscWarning = strMessage;\n+    printf(\"*** %s\\n\", strMessage.c_str());\n+    uiInterface.ThreadSafeMessageBox(strMessage, \"\", CClientUIInterface::MSG_ERROR);\n+    StartShutdown();\n+    return false;\n+}\n \n bool CheckDiskSpace(uint64 nAdditionalBytes)\n {\n     uint64 nFreeBytesAvailable = filesystem::space(GetDataDir()).available;\n \n     // Check for nMinDiskSpace bytes (currently 50MB)\n     if (nFreeBytesAvailable < nMinDiskSpace + nAdditionalBytes)\n-    {\n-        fShutdown = true;\n-        string strMessage = _(\"Error: Disk space is low!\");\n-        strMiscWarning = strMessage;\n-        printf(\"*** %s\\n\", strMessage.c_str());\n-        uiInterface.ThreadSafeMessageBox(strMessage, \"\", CClientUIInterface::MSG_ERROR);\n-        StartShutdown();\n-        return false;\n-    }\n+        return AbortNode(_(\"Error: Disk space is low!\"));\n+\n     return true;\n }\n "
      },
      {
        "sha": "8498fc2edd3b1a9b3b37f6ea97ee241be01cdfb9",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 8,
        "deletions": 2,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7851033dd687e826df82c1ec841480710468ce8c/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7851033dd687e826df82c1ec841480710468ce8c/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=7851033dd687e826df82c1ec841480710468ce8c",
        "patch": "@@ -181,6 +181,8 @@ bool ConnectBestBlock(CValidationState &state);\n CBlockIndex * InsertBlockIndex(uint256 hash);\n /** Verify a signature */\n bool VerifySignature(const CCoins& txFrom, const CTransaction& txTo, unsigned int nIn, unsigned int flags, int nHashType);\n+/** Abort with a message */\n+bool AbortNode(const std::string &msg);\n \n \n \n@@ -1886,9 +1888,13 @@ class CValidationState {\n     bool Invalid(bool ret = false) {\n         return DoS(0, ret);\n     }\n-    bool Error(bool ret = false) {\n+    bool Error() {\n         mode = MODE_ERROR;\n-        return ret;\n+        return false;\n+    }\n+    bool Abort(const std::string &msg) {\n+        AbortNode(msg);\n+        return Error();\n     }\n     bool IsValid() {\n         return mode == MODE_VALID;"
      }
    ]
  },
  {
    "sha": "421218d3040279c84616891e8d14b05576b07c57",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0MjEyMThkMzA0MDI3OWM4NDYxNjg5MWU4ZDE0YjA1NTc2YjA3YzU3",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2013-01-29T00:44:19Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieterw@google.com",
        "date": "2013-01-30T03:30:02Z"
      },
      "message": "Deal with LevelDB errors",
      "tree": {
        "sha": "a1d1546c823d593008866a3790c0c71cbe4c10de",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a1d1546c823d593008866a3790c0c71cbe4c10de"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/421218d3040279c84616891e8d14b05576b07c57",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/421218d3040279c84616891e8d14b05576b07c57",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/421218d3040279c84616891e8d14b05576b07c57",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/421218d3040279c84616891e8d14b05576b07c57/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": null,
    "parents": [
      {
        "sha": "7851033dd687e826df82c1ec841480710468ce8c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7851033dd687e826df82c1ec841480710468ce8c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7851033dd687e826df82c1ec841480710468ce8c"
      }
    ],
    "stats": {
      "total": 113,
      "additions": 74,
      "deletions": 39
    },
    "files": [
      {
        "sha": "2f37dad56c4d4bac08911f593fc796791acb9d7d",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/421218d3040279c84616891e8d14b05576b07c57/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/421218d3040279c84616891e8d14b05576b07c57/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=421218d3040279c84616891e8d14b05576b07c57",
        "patch": "@@ -187,9 +187,9 @@ bool AppInit(int argc, char* argv[])\n         fRet = AppInit2();\n     }\n     catch (std::exception& e) {\n-        PrintException(&e, \"AppInit()\");\n+        PrintExceptionContinue(&e, \"AppInit()\");\n     } catch (...) {\n-        PrintException(NULL, \"AppInit()\");\n+        PrintExceptionContinue(NULL, \"AppInit()\");\n     }\n     if (!fRet)\n         Shutdown(NULL);"
      },
      {
        "sha": "b41764f51fe11c69aa28e3ca0743993a2de3a7ac",
        "filename": "src/leveldb.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 2,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/421218d3040279c84616891e8d14b05576b07c57/src/leveldb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/421218d3040279c84616891e8d14b05576b07c57/src/leveldb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb.cpp?ref=421218d3040279c84616891e8d14b05576b07c57",
        "patch": "@@ -12,6 +12,18 @@\n \n #include <boost/filesystem.hpp>\n \n+void HandleError(const leveldb::Status &status) throw(leveldb_error) {\n+    if (status.ok())\n+        return;\n+    if (status.IsCorruption())\n+        throw leveldb_error(\"Database corrupted\");\n+    if (status.IsIOError())\n+        throw leveldb_error(\"Database I/O error\");\n+    if (status.IsNotFound())\n+        throw leveldb_error(\"Database entry missing\");\n+    throw leveldb_error(\"Unknown database error\");\n+}\n+\n static leveldb::Options GetOptions(size_t nCacheSize) {\n     leveldb::Options options;\n     options.block_cache = leveldb::NewLRUCache(nCacheSize / 2);\n@@ -57,12 +69,12 @@ CLevelDB::~CLevelDB() {\n     options.env = NULL;\n }\n \n-bool CLevelDB::WriteBatch(CLevelDBBatch &batch, bool fSync) {\n+bool CLevelDB::WriteBatch(CLevelDBBatch &batch, bool fSync) throw(leveldb_error) {\n     leveldb::Status status = pdb->Write(fSync ? syncoptions : writeoptions, &batch.batch);\n     if (!status.ok()) {\n         printf(\"LevelDB write failure: %s\\n\", status.ToString().c_str());\n+        HandleError(status);\n         return false;\n     }\n     return true;\n }\n-"
      },
      {
        "sha": "79262edbb5295e2ed2891a8f3a8d2779e8fc3e6a",
        "filename": "src/leveldb.h",
        "status": "modified",
        "additions": 16,
        "deletions": 7,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/421218d3040279c84616891e8d14b05576b07c57/src/leveldb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/421218d3040279c84616891e8d14b05576b07c57/src/leveldb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb.h?ref=421218d3040279c84616891e8d14b05576b07c57",
        "patch": "@@ -11,6 +11,14 @@\n \n #include <boost/filesystem/path.hpp>\n \n+class leveldb_error : public std::runtime_error\n+{\n+public:\n+    leveldb_error(const std::string &msg) : std::runtime_error(msg) {}\n+};\n+\n+void HandleError(const leveldb::Status &status) throw(leveldb_error);\n+\n // Batch of changes queued to be written to a CLevelDB\n class CLevelDBBatch\n {\n@@ -72,7 +80,7 @@ class CLevelDB\n     CLevelDB(const boost::filesystem::path &path, size_t nCacheSize, bool fMemory = false, bool fWipe = false);\n     ~CLevelDB();\n \n-    template<typename K, typename V> bool Read(const K& key, V& value) {\n+    template<typename K, typename V> bool Read(const K& key, V& value) throw(leveldb_error) {\n         CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n         ssKey.reserve(ssKey.GetSerializeSize(key));\n         ssKey << key;\n@@ -84,6 +92,7 @@ class CLevelDB\n             if (status.IsNotFound())\n                 return false;\n             printf(\"LevelDB read failure: %s\\n\", status.ToString().c_str());\n+            HandleError(status);\n         }\n         try {\n             CDataStream ssValue(strValue.data(), strValue.data() + strValue.size(), SER_DISK, CLIENT_VERSION);\n@@ -94,13 +103,13 @@ class CLevelDB\n         return true;\n     }\n \n-    template<typename K, typename V> bool Write(const K& key, const V& value, bool fSync = false) {\n+    template<typename K, typename V> bool Write(const K& key, const V& value, bool fSync = false) throw(leveldb_error) {\n         CLevelDBBatch batch;\n         batch.Write(key, value);\n         return WriteBatch(batch, fSync);\n     }\n \n-    template<typename K> bool Exists(const K& key) {\n+    template<typename K> bool Exists(const K& key) throw(leveldb_error) {\n         CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n         ssKey.reserve(ssKey.GetSerializeSize(key));\n         ssKey << key;\n@@ -112,24 +121,25 @@ class CLevelDB\n             if (status.IsNotFound())\n                 return false;\n             printf(\"LevelDB read failure: %s\\n\", status.ToString().c_str());\n+            HandleError(status);\n         }\n         return true;\n     }\n \n-    template<typename K> bool Erase(const K& key, bool fSync = false) {\n+    template<typename K> bool Erase(const K& key, bool fSync = false) throw(leveldb_error) {\n         CLevelDBBatch batch;\n         batch.Erase(key);\n         return WriteBatch(batch, fSync);\n     }\n \n-    bool WriteBatch(CLevelDBBatch &batch, bool fSync = false);\n+    bool WriteBatch(CLevelDBBatch &batch, bool fSync = false) throw(leveldb_error);\n \n     // not available for LevelDB; provide for compatibility with BDB\n     bool Flush() {\n         return true;\n     }\n \n-    bool Sync() {\n+    bool Sync() throw(leveldb_error) {\n         CLevelDBBatch batch;\n         return WriteBatch(batch, true);\n     }\n@@ -141,4 +151,3 @@ class CLevelDB\n };\n \n #endif // BITCOIN_LEVELDB_H\n- \n\\ No newline at end of file"
      },
      {
        "sha": "412f4d7a073939f26250cd78891f14394c2e46a2",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 42,
        "deletions": 28,
        "changes": 70,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/421218d3040279c84616891e8d14b05576b07c57/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/421218d3040279c84616891e8d14b05576b07c57/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=421218d3040279c84616891e8d14b05576b07c57",
        "patch": "@@ -800,7 +800,11 @@ bool CTxMemPool::accept(CValidationState &state, CTransaction &tx, bool fCheckIn\n \n bool CTransaction::AcceptToMemoryPool(CValidationState &state, bool fCheckInputs, bool fLimitFree, bool* pfMissingInputs)\n {\n-    return mempool.accept(state, *this, fCheckInputs, fLimitFree, pfMissingInputs);\n+    try {\n+        return mempool.accept(state, *this, fCheckInputs, fLimitFree, pfMissingInputs);\n+    } catch(std::runtime_error &e) {\n+        return state.Abort(_(\"System error: \") + e.what());\n+    }\n }\n \n bool CTxMemPool::addUnchecked(const uint256& hash, CTransaction &tx)\n@@ -1256,8 +1260,12 @@ bool ConnectBestBlock(CValidationState &state) {\n                     if (fRequestShutdown)\n                         break;\n                     CValidationState state;\n-                    if (!SetBestChain(state, pindexSwitch))\n-                        return false;\n+                    try {\n+                        if (!SetBestChain(state, pindexSwitch))\n+                            return false;\n+                    } catch(std::runtime_error &e) {\n+                        return state.Abort(_(\"System error: \") + e.what());\n+                    }\n                 }\n                 return true;\n             }\n@@ -1687,7 +1695,7 @@ bool CBlock::ConnectBlock(CValidationState &state, CBlockIndex* pindex, CCoinsVi\n             if (!FindUndoPos(state, pindex->nFile, pos, ::GetSerializeSize(blockundo, SER_DISK, CLIENT_VERSION) + 40))\n                 return error(\"ConnectBlock() : FindUndoPos failed\");\n             if (!blockundo.WriteToDisk(pos, pindex->pprev->GetBlockHash()))\n-                return state.Abort(_(\"Error: failed to write undo data\"));\n+                return state.Abort(_(\"Failed to write undo data\"));\n \n             // update nUndoPos in block index\n             pindex->nUndoPos = pos.nPos;\n@@ -1698,12 +1706,12 @@ bool CBlock::ConnectBlock(CValidationState &state, CBlockIndex* pindex, CCoinsVi\n \n         CDiskBlockIndex blockindex(pindex);\n         if (!pblocktree->WriteBlockIndex(blockindex))\n-            return state.Abort(_(\"Error: failed to write block index\"));\n+            return state.Abort(_(\"Failed to write block index\"));\n     }\n \n     if (fTxIndex)\n         if (!pblocktree->WriteTxIndex(vPos))\n-            return state.Abort(_(\"Error: failed to write transaction index\"));\n+            return state.Abort(_(\"Failed to write transaction index\"));\n \n     // add this block to the view's block chain\n     assert(view.SetBestBlock(pindex));\n@@ -1757,7 +1765,7 @@ bool SetBestChain(CValidationState &state, CBlockIndex* pindexNew)\n     BOOST_FOREACH(CBlockIndex* pindex, vDisconnect) {\n         CBlock block;\n         if (!block.ReadFromDisk(pindex))\n-            return state.Abort(_(\"Error: failed to read block\"));\n+            return state.Abort(_(\"Failed to read block\"));\n         int64 nStart = GetTimeMicros();\n         if (!block.DisconnectBlock(state, pindex, view))\n             return error(\"SetBestBlock() : DisconnectBlock %s failed\", BlockHashStr(pindex->GetBlockHash()).c_str());\n@@ -1777,7 +1785,7 @@ bool SetBestChain(CValidationState &state, CBlockIndex* pindexNew)\n     BOOST_FOREACH(CBlockIndex *pindex, vConnect) {\n         CBlock block;\n         if (!block.ReadFromDisk(pindex))\n-            return state.Abort(_(\"Error: failed to read block\"));\n+            return state.Abort(_(\"Failed to read block\"));\n         int64 nStart = GetTimeMicros();\n         if (!block.ConnectBlock(state, pindex, view)) {\n             if (state.IsInvalid()) {\n@@ -1815,7 +1823,7 @@ bool SetBestChain(CValidationState &state, CBlockIndex* pindexNew)\n         FlushBlockFile();\n         pblocktree->Sync();\n         if (!pcoinsTip->Flush())\n-            return state.Abort(_(\"Error: failed to write to coin database\"));\n+            return state.Abort(_(\"Failed to write to coin database\"));\n     }\n \n     // At this point, all changes have been done to the database.\n@@ -1921,7 +1929,7 @@ bool CBlock::AddToBlockIndex(CValidationState &state, const CDiskBlockPos &pos)\n     setBlockIndexValid.insert(pindexNew);\n \n     if (!pblocktree->WriteBlockIndex(CDiskBlockIndex(pindexNew)))\n-        return state.Abort(_(\"Error: failed to write block index\"));\n+        return state.Abort(_(\"Failed to write block index\"));\n \n     // New best?\n     if (!ConnectBestBlock(state))\n@@ -1936,7 +1944,7 @@ bool CBlock::AddToBlockIndex(CValidationState &state, const CDiskBlockPos &pos)\n     }\n \n     if (!pblocktree->Flush())\n-        return state.Abort(_(\"Error: failed to sync block index\"));\n+        return state.Abort(_(\"Failed to sync block index\"));\n \n     uiInterface.NotifyBlocksChanged();\n     return true;\n@@ -1990,7 +1998,7 @@ bool FindBlockPos(CValidationState &state, CDiskBlockPos &pos, unsigned int nAdd\n     }\n \n     if (!pblocktree->WriteBlockFileInfo(nLastBlockFile, infoLastBlockFile))\n-        return state.Abort(_(\"Error: failed to write file info\"));\n+        return state.Abort(_(\"Failed to write file info\"));\n     if (fUpdatedLast)\n         pblocktree->WriteLastBlockFile(nLastBlockFile);\n \n@@ -2008,15 +2016,15 @@ bool FindUndoPos(CValidationState &state, int nFile, CDiskBlockPos &pos, unsigne\n         pos.nPos = infoLastBlockFile.nUndoSize;\n         nNewSize = (infoLastBlockFile.nUndoSize += nAddSize);\n         if (!pblocktree->WriteBlockFileInfo(nLastBlockFile, infoLastBlockFile))\n-            return state.Abort(_(\"Error: failed to write block info\"));\n+            return state.Abort(_(\"Failed to write block info\"));\n     } else {\n         CBlockFileInfo info;\n         if (!pblocktree->ReadBlockFileInfo(nFile, info))\n-            return state.Abort(_(\"Error: failed to read block info\"));\n+            return state.Abort(_(\"Failed to read block info\"));\n         pos.nPos = info.nUndoSize;\n         nNewSize = (info.nUndoSize += nAddSize);\n         if (!pblocktree->WriteBlockFileInfo(nFile, info))\n-            return state.Abort(_(\"Error: failed to write block info\"));\n+            return state.Abort(_(\"Failed to write block info\"));\n     }\n \n     unsigned int nOldChunks = (pos.nPos + UNDOFILE_CHUNK_SIZE - 1) / UNDOFILE_CHUNK_SIZE;\n@@ -2154,17 +2162,21 @@ bool CBlock::AcceptBlock(CValidationState &state, CDiskBlockPos *dbp)\n     }\n \n     // Write block to history file\n-    unsigned int nBlockSize = ::GetSerializeSize(*this, SER_DISK, CLIENT_VERSION);\n-    CDiskBlockPos blockPos;\n-    if (dbp != NULL)\n-        blockPos = *dbp;\n-    if (!FindBlockPos(state, blockPos, nBlockSize+8, nHeight, nTime, dbp != NULL))\n-        return error(\"AcceptBlock() : FindBlockPos failed\");\n-    if (dbp == NULL)\n-        if (!WriteToDisk(blockPos))\n-            return state.Abort(_(\"Error: failed to write block\"));\n-    if (!AddToBlockIndex(state, blockPos))\n-        return error(\"AcceptBlock() : AddToBlockIndex failed\");\n+    try {\n+        unsigned int nBlockSize = ::GetSerializeSize(*this, SER_DISK, CLIENT_VERSION);\n+        CDiskBlockPos blockPos;\n+        if (dbp != NULL)\n+            blockPos = *dbp;\n+        if (!FindBlockPos(state, blockPos, nBlockSize+8, nHeight, nTime, dbp != NULL))\n+            return error(\"AcceptBlock() : FindBlockPos failed\");\n+        if (dbp == NULL)\n+            if (!WriteToDisk(blockPos))\n+                return state.Abort(_(\"Failed to write block\"));\n+        if (!AddToBlockIndex(state, blockPos))\n+            return error(\"AcceptBlock() : AddToBlockIndex failed\");\n+    } catch(std::runtime_error &e) {\n+        return state.Abort(_(\"System error: \") + e.what());\n+    }\n \n     // Relay inventory, but don't relay old inventory during initial block download\n     int nBlockEstimate = Checkpoints::GetTotalBlocksEstimate();\n@@ -2432,7 +2444,7 @@ bool AbortNode(const std::string &strMessage) {\n     fRequestShutdown = true;\n     strMiscWarning = strMessage;\n     printf(\"*** %s\\n\", strMessage.c_str());\n-    uiInterface.ThreadSafeMessageBox(strMessage, \"\", CClientUIInterface::MSG_ERROR);\n+    uiInterface.ThreadSafeMessageBox(strMessage, \"\", CClientUIInterface::MSG_ERROR | CClientUIInterface::MODAL);\n     StartShutdown();\n     return false;\n }\n@@ -2801,7 +2813,7 @@ bool LoadExternalBlockFile(FILE* fileIn, CDiskBlockPos *dbp)\n     int64 nStart = GetTimeMillis();\n \n     int nLoaded = 0;\n-    {\n+    try {\n         CBufferedFile blkdat(fileIn, 2*MAX_BLOCK_SIZE, MAX_BLOCK_SIZE+8, SER_DISK, CLIENT_VERSION);\n         uint64 nStartByte = 0;\n         if (dbp) {\n@@ -2858,6 +2870,8 @@ bool LoadExternalBlockFile(FILE* fileIn, CDiskBlockPos *dbp)\n             }\n         }\n         fclose(fileIn);\n+    } catch(std::runtime_error &e) {\n+        AbortNode(_(\"Error: system error: \") + e.what());\n     }\n     if (nLoaded > 0)\n         printf(\"Loaded %i blocks from external file in %\"PRI64d\"ms\\n\", nLoaded, GetTimeMillis() - nStart);"
      }
    ]
  }
]