[
  {
    "sha": "092e9ad7d95762202e35d6568d0238423f28cd64",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowOTJlOWFkN2Q5NTc2MjIwMmUzNWQ2NTY4ZDAyMzg0MjNmMjhjZDY0",
    "commit": {
      "author": {
        "name": "Peter Todd",
        "email": "pete@petertodd.org",
        "date": "2015-12-02T10:26:53Z"
      },
      "committer": {
        "name": "Peter Todd",
        "email": "pete@petertodd.org",
        "date": "2015-12-02T10:26:53Z"
      },
      "message": "Remove old replace-by-fee tests\n\nMade redundant by tests in qa/rpc-tests/replace-by-fee.py",
      "tree": {
        "sha": "906dd9c4a86c23c6251b9f4c30f51305c37dd3bd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/906dd9c4a86c23c6251b9f4c30f51305c37dd3bd"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/092e9ad7d95762202e35d6568d0238423f28cd64",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGrBAABCACVBQJWXsemXhSAAAAAABUAQGJsb2NraGFzaEBiaXRjb2luLm9yZzAw\nMDAwMDAwMDAwMDAwMDAwN2VhYTA4YTdhN2IzOThkNzU4YTMyYzEyMmVlMWU1ODUz\nNTE3YjcwOTk2NTQwODYvFIAAAAAAFQARcGthLWFkZHJlc3NAZ251cGcub3JncGV0\nZUBwZXRlcnRvZC5vcmcACgkQwIXyHOf0udyQxwf/ev7NLbtlJBbffj6lVPtfpkKK\nCJ+e2PmbTh1RdOc9fj8k1vtr33ktEt/NrK0ySIFpkPefIyziXHmGeVRDzuGhfySU\niP6T4gIB337fy6D1JECesZ/j9xs00YnkhLodER2YAboQrlBwWegyDoTgdVxkR58I\nOnJuQQDwWWQvd0THNFS1Ds54jT2dHvG4+SjscxgW6On4U67hXPHG+RYPbp5JF39B\n/2rVO8ZtFkNZREWiDD9AD/OBV3MzTFSlHU0WtbyrQAdwvsG0/VjMWqP2U4+j4l3J\nmzfY35TchSW58xBmSlnL5Eo52GGYg4OwL5zzxzJNp5BsdYyCcNtDPNvvnugP1w==\n=TpOI\n-----END PGP SIGNATURE-----",
        "payload": "tree 906dd9c4a86c23c6251b9f4c30f51305c37dd3bd\nparent 1b0241fcec3e00d13658090e26cfa1f05133116e\nauthor Peter Todd <pete@petertodd.org> 1449052013 +0800\ncommitter Peter Todd <pete@petertodd.org> 1449052013 +0800\n\nRemove old replace-by-fee tests\n\nMade redundant by tests in qa/rpc-tests/replace-by-fee.py\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/092e9ad7d95762202e35d6568d0238423f28cd64",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/092e9ad7d95762202e35d6568d0238423f28cd64",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/092e9ad7d95762202e35d6568d0238423f28cd64/comments",
    "author": {
      "login": "petertodd",
      "id": 7042,
      "node_id": "MDQ6VXNlcjcwNDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7042?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/petertodd",
      "html_url": "https://github.com/petertodd",
      "followers_url": "https://api.github.com/users/petertodd/followers",
      "following_url": "https://api.github.com/users/petertodd/following{/other_user}",
      "gists_url": "https://api.github.com/users/petertodd/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/petertodd/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/petertodd/subscriptions",
      "organizations_url": "https://api.github.com/users/petertodd/orgs",
      "repos_url": "https://api.github.com/users/petertodd/repos",
      "events_url": "https://api.github.com/users/petertodd/events{/privacy}",
      "received_events_url": "https://api.github.com/users/petertodd/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "petertodd",
      "id": 7042,
      "node_id": "MDQ6VXNlcjcwNDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7042?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/petertodd",
      "html_url": "https://github.com/petertodd",
      "followers_url": "https://api.github.com/users/petertodd/followers",
      "following_url": "https://api.github.com/users/petertodd/following{/other_user}",
      "gists_url": "https://api.github.com/users/petertodd/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/petertodd/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/petertodd/subscriptions",
      "organizations_url": "https://api.github.com/users/petertodd/orgs",
      "repos_url": "https://api.github.com/users/petertodd/repos",
      "events_url": "https://api.github.com/users/petertodd/events{/privacy}",
      "received_events_url": "https://api.github.com/users/petertodd/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1b0241fcec3e00d13658090e26cfa1f05133116e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1b0241fcec3e00d13658090e26cfa1f05133116e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1b0241fcec3e00d13658090e26cfa1f05133116e"
      }
    ],
    "stats": {
      "total": 374,
      "additions": 0,
      "deletions": 374
    },
    "files": [
      {
        "sha": "b2c4f4657aebb1a2bffcc5e7a7d1c3bcdefdd56f",
        "filename": "qa/replace-by-fee/.gitignore",
        "status": "removed",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1b0241fcec3e00d13658090e26cfa1f05133116e/qa/replace-by-fee/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1b0241fcec3e00d13658090e26cfa1f05133116e/qa/replace-by-fee/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/replace-by-fee/.gitignore?ref=1b0241fcec3e00d13658090e26cfa1f05133116e",
        "patch": "@@ -1 +0,0 @@\n-python-bitcoinlib"
      },
      {
        "sha": "baad86de9a47564132aa68f805982bd0eb49c3ad",
        "filename": "qa/replace-by-fee/README.md",
        "status": "removed",
        "additions": 0,
        "deletions": 13,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1b0241fcec3e00d13658090e26cfa1f05133116e/qa/replace-by-fee/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1b0241fcec3e00d13658090e26cfa1f05133116e/qa/replace-by-fee/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/replace-by-fee/README.md?ref=1b0241fcec3e00d13658090e26cfa1f05133116e",
        "patch": "@@ -1,13 +0,0 @@\n-Replace-by-fee regression tests\n-===============================\n-\n-First get version v0.5.0 of the python-bitcoinlib library. In this directory\n-run:\n-\n-    git clone -n https://github.com/petertodd/python-bitcoinlib\n-    (cd python-bitcoinlib && git checkout 8270bfd9c6ac37907d75db3d8b9152d61c7255cd)\n-\n-Then run the tests themselves with a bitcoind available running in regtest\n-mode:\n-\n-    ./rbf-tests.py"
      },
      {
        "sha": "1ee6c838752568ff7909ff2923381ca73127377a",
        "filename": "qa/replace-by-fee/rbf-tests.py",
        "status": "removed",
        "additions": 0,
        "deletions": 360,
        "changes": 360,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1b0241fcec3e00d13658090e26cfa1f05133116e/qa/replace-by-fee/rbf-tests.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1b0241fcec3e00d13658090e26cfa1f05133116e/qa/replace-by-fee/rbf-tests.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/replace-by-fee/rbf-tests.py?ref=1b0241fcec3e00d13658090e26cfa1f05133116e",
        "patch": "@@ -1,360 +0,0 @@\n-#!/usr/bin/env python3\n-# Copyright (c) 2015 The Bitcoin Core developers\n-# Distributed under the MIT software license, see the accompanying\n-# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#\n-# Test replace-by-fee\n-#\n-\n-import os\n-import sys\n-\n-# Add python-bitcoinlib to module search path, prior to any system-wide\n-# python-bitcoinlib.\n-sys.path.insert(0, os.path.join(os.path.dirname(os.path.abspath(__file__)), \"python-bitcoinlib\"))\n-\n-import unittest\n-\n-import bitcoin\n-bitcoin.SelectParams('regtest')\n-\n-import bitcoin.rpc\n-\n-from bitcoin.core import *\n-from bitcoin.core.script import *\n-from bitcoin.wallet import *\n-\n-MAX_REPLACEMENT_LIMIT = 100\n-\n-class Test_ReplaceByFee(unittest.TestCase):\n-    proxy = None\n-\n-    @classmethod\n-    def setUpClass(cls):\n-        if cls.proxy is None:\n-            cls.proxy = bitcoin.rpc.Proxy()\n-\n-    @classmethod\n-    def mine_mempool(cls):\n-        \"\"\"Mine until mempool is empty\"\"\"\n-        mempool_size = 1\n-        while mempool_size:\n-            cls.proxy.call('generate', 1)\n-            new_mempool_size = len(cls.proxy.getrawmempool())\n-\n-            # It's possible to get stuck in a loop here if the mempool has\n-            # transactions that can't be mined.\n-            assert(new_mempool_size != mempool_size)\n-            mempool_size = new_mempool_size\n-\n-    @classmethod\n-    def tearDownClass(cls):\n-        # Make sure mining works\n-        cls.mine_mempool()\n-\n-    def make_txout(self, amount, confirmed=True, scriptPubKey=CScript([1])):\n-        \"\"\"Create a txout with a given amount and scriptPubKey\n-\n-        Mines coins as needed.\n-\n-        confirmed - txouts created will be confirmed in the blockchain;\n-                    unconfirmed otherwise.\n-        \"\"\"\n-        fee = 1*COIN\n-        while self.proxy.getbalance() < amount + fee:\n-            self.proxy.call('generate', 100)\n-\n-        addr = P2SHBitcoinAddress.from_redeemScript(CScript([]))\n-        txid = self.proxy.sendtoaddress(addr, amount + fee)\n-\n-        tx1 = self.proxy.getrawtransaction(txid)\n-\n-        i = None\n-        for i, txout in enumerate(tx1.vout):\n-            if txout.scriptPubKey == addr.to_scriptPubKey():\n-                break\n-        assert i is not None\n-\n-        tx2 = CTransaction([CTxIn(COutPoint(txid, i), CScript([1, CScript([])]), nSequence=0)],\n-                           [CTxOut(amount, scriptPubKey)])\n-\n-        tx2_txid = self.proxy.sendrawtransaction(tx2, True)\n-\n-        # If requested, ensure txouts are confirmed.\n-        if confirmed:\n-            self.mine_mempool()\n-\n-        return COutPoint(tx2_txid, 0)\n-\n-    def test_simple_doublespend(self):\n-        \"\"\"Simple doublespend\"\"\"\n-        tx0_outpoint = self.make_txout(1.1*COIN)\n-\n-        tx1a = CTransaction([CTxIn(tx0_outpoint, nSequence=0)],\n-                            [CTxOut(1*COIN, CScript([b'a']))])\n-        tx1a_txid = self.proxy.sendrawtransaction(tx1a, True)\n-\n-        # Should fail because we haven't changed the fee\n-        tx1b = CTransaction([CTxIn(tx0_outpoint, nSequence=0)],\n-                            [CTxOut(1*COIN, CScript([b'b']))])\n-\n-        try:\n-            tx1b_txid = self.proxy.sendrawtransaction(tx1b, True)\n-        except bitcoin.rpc.JSONRPCException as exp:\n-            self.assertEqual(exp.error['code'], -26) # insufficient fee\n-        else:\n-            self.fail()\n-\n-        # Extra 0.1 BTC fee\n-        tx1b = CTransaction([CTxIn(tx0_outpoint, nSequence=0)],\n-                            [CTxOut(0.9*COIN, CScript([b'b']))])\n-        tx1b_txid = self.proxy.sendrawtransaction(tx1b, True)\n-\n-        # tx1a is in fact replaced\n-        with self.assertRaises(IndexError):\n-            self.proxy.getrawtransaction(tx1a_txid)\n-\n-        self.assertEqual(tx1b, self.proxy.getrawtransaction(tx1b_txid))\n-\n-    def test_doublespend_chain(self):\n-        \"\"\"Doublespend of a long chain\"\"\"\n-\n-        initial_nValue = 50*COIN\n-        tx0_outpoint = self.make_txout(initial_nValue)\n-\n-        prevout = tx0_outpoint\n-        remaining_value = initial_nValue\n-        chain_txids = []\n-        while remaining_value > 10*COIN:\n-            remaining_value -= 1*COIN\n-            tx = CTransaction([CTxIn(prevout, nSequence=0)],\n-                              [CTxOut(remaining_value, CScript([1]))])\n-            txid = self.proxy.sendrawtransaction(tx, True)\n-            chain_txids.append(txid)\n-            prevout = COutPoint(txid, 0)\n-\n-        # Whether the double-spend is allowed is evaluated by including all\n-        # child fees - 40 BTC - so this attempt is rejected.\n-        dbl_tx = CTransaction([CTxIn(tx0_outpoint, nSequence=0)],\n-                              [CTxOut(initial_nValue - 30*COIN, CScript([1]))])\n-\n-        try:\n-            self.proxy.sendrawtransaction(dbl_tx, True)\n-        except bitcoin.rpc.JSONRPCException as exp:\n-            self.assertEqual(exp.error['code'], -26) # insufficient fee\n-        else:\n-            self.fail()\n-\n-        # Accepted with sufficient fee\n-        dbl_tx = CTransaction([CTxIn(tx0_outpoint, nSequence=0)],\n-                              [CTxOut(1*COIN, CScript([1]))])\n-        self.proxy.sendrawtransaction(dbl_tx, True)\n-\n-        for doublespent_txid in chain_txids:\n-            with self.assertRaises(IndexError):\n-                self.proxy.getrawtransaction(doublespent_txid)\n-\n-    def test_doublespend_tree(self):\n-        \"\"\"Doublespend of a big tree of transactions\"\"\"\n-\n-        initial_nValue = 50*COIN\n-        tx0_outpoint = self.make_txout(initial_nValue)\n-\n-        def branch(prevout, initial_value, max_txs, *, tree_width=5, fee=0.0001*COIN, _total_txs=None):\n-            if _total_txs is None:\n-                _total_txs = [0]\n-            if _total_txs[0] >= max_txs:\n-                return\n-\n-            txout_value = (initial_value - fee) // tree_width\n-            if txout_value < fee:\n-                return\n-\n-            vout = [CTxOut(txout_value, CScript([i+1]))\n-                    for i in range(tree_width)]\n-            tx = CTransaction([CTxIn(prevout, nSequence=0)],\n-                              vout)\n-\n-            self.assertTrue(len(tx.serialize()) < 100000)\n-            txid = self.proxy.sendrawtransaction(tx, True)\n-            yield tx\n-            _total_txs[0] += 1\n-\n-            for i, txout in enumerate(tx.vout):\n-                yield from branch(COutPoint(txid, i), txout_value,\n-                                  max_txs,\n-                                  tree_width=tree_width, fee=fee,\n-                                  _total_txs=_total_txs)\n-\n-        fee = 0.0001*COIN\n-        n = MAX_REPLACEMENT_LIMIT\n-        tree_txs = list(branch(tx0_outpoint, initial_nValue, n, fee=fee))\n-        self.assertEqual(len(tree_txs), n)\n-\n-        # Attempt double-spend, will fail because too little fee paid\n-        dbl_tx = CTransaction([CTxIn(tx0_outpoint, nSequence=0)],\n-                              [CTxOut(initial_nValue - fee*n, CScript([1]))])\n-        try:\n-            self.proxy.sendrawtransaction(dbl_tx, True)\n-        except bitcoin.rpc.JSONRPCException as exp:\n-            self.assertEqual(exp.error['code'], -26) # insufficient fee\n-        else:\n-            self.fail()\n-\n-        # 1 BTC fee is enough\n-        dbl_tx = CTransaction([CTxIn(tx0_outpoint, nSequence=0)],\n-                              [CTxOut(initial_nValue - fee*n - 1*COIN, CScript([1]))])\n-        self.proxy.sendrawtransaction(dbl_tx, True)\n-\n-        for tx in tree_txs:\n-            with self.assertRaises(IndexError):\n-                self.proxy.getrawtransaction(tx.GetHash())\n-\n-        # Try again, but with more total transactions than the \"max txs\n-        # double-spent at once\" anti-DoS limit.\n-        for n in (MAX_REPLACEMENT_LIMIT, MAX_REPLACEMENT_LIMIT*2):\n-            fee = 0.0001*COIN\n-            tx0_outpoint = self.make_txout(initial_nValue)\n-            tree_txs = list(branch(tx0_outpoint, initial_nValue, n, fee=fee))\n-            self.assertEqual(len(tree_txs), n)\n-\n-            dbl_tx = CTransaction([CTxIn(tx0_outpoint, nSequence=0)],\n-                                  [CTxOut(initial_nValue - fee*n, CScript([1]))])\n-            try:\n-                self.proxy.sendrawtransaction(dbl_tx, True)\n-            except bitcoin.rpc.JSONRPCException as exp:\n-                self.assertEqual(exp.error['code'], -26)\n-            else:\n-                self.fail()\n-\n-            for tx in tree_txs:\n-                self.proxy.getrawtransaction(tx.GetHash())\n-\n-    def test_replacement_feeperkb(self):\n-        \"\"\"Replacement requires fee-per-KB to be higher\"\"\"\n-        tx0_outpoint = self.make_txout(1.1*COIN)\n-\n-        tx1a = CTransaction([CTxIn(tx0_outpoint, nSequence=0)],\n-                            [CTxOut(1*COIN, CScript([b'a']))])\n-        tx1a_txid = self.proxy.sendrawtransaction(tx1a, True)\n-\n-        # Higher fee, but the fee per KB is much lower, so the replacement is\n-        # rejected.\n-        tx1b = CTransaction([CTxIn(tx0_outpoint, nSequence=0)],\n-                            [CTxOut(0.001*COIN,\n-                                    CScript([b'a'*999000]))])\n-\n-        try:\n-            tx1b_txid = self.proxy.sendrawtransaction(tx1b, True)\n-        except bitcoin.rpc.JSONRPCException as exp:\n-            self.assertEqual(exp.error['code'], -26) # insufficient fee\n-        else:\n-            self.fail()\n-\n-    def test_spends_of_conflicting_outputs(self):\n-        \"\"\"Replacements that spend conflicting tx outputs are rejected\"\"\"\n-        utxo1 = self.make_txout(1.2*COIN)\n-        utxo2 = self.make_txout(3.0*COIN)\n-\n-        tx1a = CTransaction([CTxIn(utxo1, nSequence=0)],\n-                            [CTxOut(1.1*COIN, CScript([b'a']))])\n-        tx1a_txid = self.proxy.sendrawtransaction(tx1a, True)\n-\n-        # Direct spend an output of the transaction we're replacing.\n-        tx2 = CTransaction([CTxIn(utxo1, nSequence=0), CTxIn(utxo2, nSequence=0),\n-                            CTxIn(COutPoint(tx1a_txid, 0), nSequence=0)],\n-                           tx1a.vout)\n-\n-        try:\n-            tx2_txid = self.proxy.sendrawtransaction(tx2, True)\n-        except bitcoin.rpc.JSONRPCException as exp:\n-            self.assertEqual(exp.error['code'], -26)\n-        else:\n-            self.fail()\n-\n-        # Spend tx1a's output to test the indirect case.\n-        tx1b = CTransaction([CTxIn(COutPoint(tx1a_txid, 0), nSequence=0)],\n-                            [CTxOut(1.0*COIN, CScript([b'a']))])\n-        tx1b_txid = self.proxy.sendrawtransaction(tx1b, True)\n-\n-        tx2 = CTransaction([CTxIn(utxo1, nSequence=0), CTxIn(utxo2, nSequence=0),\n-                            CTxIn(COutPoint(tx1b_txid, 0))],\n-                           tx1a.vout)\n-\n-        try:\n-            tx2_txid = self.proxy.sendrawtransaction(tx2, True)\n-        except bitcoin.rpc.JSONRPCException as exp:\n-            self.assertEqual(exp.error['code'], -26)\n-        else:\n-            self.fail()\n-\n-    def test_new_unconfirmed_inputs(self):\n-        \"\"\"Replacements that add new unconfirmed inputs are rejected\"\"\"\n-        confirmed_utxo = self.make_txout(1.1*COIN)\n-        unconfirmed_utxo = self.make_txout(0.1*COIN, False)\n-\n-        tx1 = CTransaction([CTxIn(confirmed_utxo)],\n-                           [CTxOut(1.0*COIN, CScript([b'a']))])\n-        tx1_txid = self.proxy.sendrawtransaction(tx1, True)\n-\n-        tx2 = CTransaction([CTxIn(confirmed_utxo), CTxIn(unconfirmed_utxo)],\n-                           tx1.vout)\n-\n-        try:\n-            tx2_txid = self.proxy.sendrawtransaction(tx2, True)\n-        except bitcoin.rpc.JSONRPCException as exp:\n-            self.assertEqual(exp.error['code'], -26)\n-        else:\n-            self.fail()\n-\n-    def test_too_many_replacements(self):\n-        \"\"\"Replacements that evict too many transactions are rejected\"\"\"\n-        # Try directly replacing more than MAX_REPLACEMENT_LIMIT\n-        # transactions\n-\n-        # Start by creating a single transaction with many outputs\n-        initial_nValue = 10*COIN\n-        utxo = self.make_txout(initial_nValue)\n-        fee = 0.0001*COIN\n-        split_value = int((initial_nValue-fee)/(MAX_REPLACEMENT_LIMIT+1))\n-        actual_fee = initial_nValue - split_value*(MAX_REPLACEMENT_LIMIT+1)\n-\n-        outputs = []\n-        for i in range(MAX_REPLACEMENT_LIMIT+1):\n-            outputs.append(CTxOut(split_value, CScript([1])))\n-\n-        splitting_tx = CTransaction([CTxIn(utxo, nSequence=0)], outputs)\n-        txid = self.proxy.sendrawtransaction(splitting_tx, True)\n-\n-        # Now spend each of those outputs individually\n-        for i in range(MAX_REPLACEMENT_LIMIT+1):\n-            tx_i = CTransaction([CTxIn(COutPoint(txid, i), nSequence=0)],\n-                                [CTxOut(split_value-fee, CScript([b'a']))])\n-            self.proxy.sendrawtransaction(tx_i, True)\n-\n-        # Now create doublespend of the whole lot, should fail\n-        # Need a big enough fee to cover all spending transactions and have\n-        # a higher fee rate\n-        double_spend_value = (split_value-100*fee)*(MAX_REPLACEMENT_LIMIT+1)\n-        inputs = []\n-        for i in range(MAX_REPLACEMENT_LIMIT+1):\n-            inputs.append(CTxIn(COutPoint(txid, i), nSequence=0))\n-        double_tx = CTransaction(inputs, [CTxOut(double_spend_value, CScript([b'a']))])\n-\n-        try:\n-            self.proxy.sendrawtransaction(double_tx, True)\n-        except bitcoin.rpc.JSONRPCException as exp:\n-            self.assertEqual(exp.error['code'], -26)\n-            self.assertEqual(\"too many potential replacements\" in exp.error['message'], True)\n-        else:\n-            self.fail()\n-\n-        # If we remove an input, it should pass\n-        double_tx = CTransaction(inputs[0:-1],\n-                                 [CTxOut(double_spend_value, CScript([b'a']))])\n-\n-        self.proxy.sendrawtransaction(double_tx, True)\n-\n-if __name__ == '__main__':\n-    unittest.main()"
      }
    ]
  }
]