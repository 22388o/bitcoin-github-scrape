[
  {
    "sha": "3f8f78f135d9e52f586e2a1a8af9899612eff5e3",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozZjhmNzhmMTM1ZDllNTJmNTg2ZTJhMWE4YWY5ODk5NjEyZWZmNWUz",
    "commit": {
      "author": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2020-09-08T15:09:57Z"
      },
      "committer": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2020-09-08T15:09:57Z"
      },
      "message": "sync: Replace LockAssertion with AssertLockHeldUnverified\n\nAssertLockHeldUnverified does the same thing LockAssertion except it:\n\n- Correctly reports file and line number where assertion fails instead of\n  location in sync.h.\n\n- Has a simpler syntax that doesn't require declaring an unused variable name.\n\n- Should be harder to confuse with AssertLockHeld. Name should indicate it's a\n  weaker assertion not to be preferred when stronger compile time checks are\n  available.\n\nThis also adds doxygen comments describing AssertLockHeld,\nAssertLockHeldUnverified, and AssertLockNotHeld macros.",
      "tree": {
        "sha": "2c19ef44d497d5b53aa3bcc50b1d83f446cbc563",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2c19ef44d497d5b53aa3bcc50b1d83f446cbc563"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3f8f78f135d9e52f586e2a1a8af9899612eff5e3",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3f8f78f135d9e52f586e2a1a8af9899612eff5e3",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/3f8f78f135d9e52f586e2a1a8af9899612eff5e3",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3f8f78f135d9e52f586e2a1a8af9899612eff5e3/comments",
    "author": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a0a422c34cfd6514d0cc445bd784d3ee1a2d1749",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a0a422c34cfd6514d0cc445bd784d3ee1a2d1749",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a0a422c34cfd6514d0cc445bd784d3ee1a2d1749"
      }
    ],
    "stats": {
      "total": 64,
      "additions": 40,
      "deletions": 24
    },
    "files": [
      {
        "sha": "be7b865cd5bc52a35622131b8c914a3f0cf1b214",
        "filename": "doc/developer-notes.md",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3f8f78f135d9e52f586e2a1a8af9899612eff5e3/doc/developer-notes.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3f8f78f135d9e52f586e2a1a8af9899612eff5e3/doc/developer-notes.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/developer-notes.md?ref=3f8f78f135d9e52f586e2a1a8af9899612eff5e3",
        "patch": "@@ -793,7 +793,7 @@ bool ChainstateManager::ProcessNewBlock(...)\n }\n ```\n \n-- When Clang Thread Safety Analysis is unable to determine if a mutex is locked, use `LockAssertion` class instances:\n+- When Clang Thread Safety Analysis is unable to determine if a mutex is locked, use `AssertLockHeldUnverified`:\n \n ```C++\n // net_processing.h\n@@ -805,7 +805,7 @@ void RelayTransaction(...)\n     AssertLockHeld(::cs_main);\n \n     connman.ForEachNode([&txid, &wtxid](CNode* pnode) {\n-        LockAssertion lock(::cs_main);\n+        AssertLockHeldUnverified(::cs_main);\n         ...\n     });\n }"
      },
      {
        "sha": "d7422edde4b0cbe382db85f7e15b5fc271f3eac5",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3f8f78f135d9e52f586e2a1a8af9899612eff5e3/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3f8f78f135d9e52f586e2a1a8af9899612eff5e3/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=3f8f78f135d9e52f586e2a1a8af9899612eff5e3",
        "patch": "@@ -663,7 +663,7 @@ static void MaybeSetPeerAsAnnouncingHeaderAndIDs(NodeId nodeid, CConnman& connma\n             }\n         }\n         connman.ForNode(nodeid, [&connman](CNode* pfrom){\n-            LockAssertion lock(::cs_main);\n+            AssertLockHeldUnverified(::cs_main);\n             uint64_t nCMPCTBLOCKVersion = (pfrom->GetLocalServices() & NODE_WITNESS) ? 2 : 1;\n             if (lNodesAnnouncingHeaderAndIDs.size() >= 3) {\n                 // As per BIP152, we only get 3 of our peers to announce\n@@ -1371,7 +1371,7 @@ void PeerLogicValidation::NewPoWValidBlock(const CBlockIndex *pindex, const std:\n     }\n \n     m_connman.ForEachNode([this, &pcmpctblock, pindex, &msgMaker, fWitnessEnabled, &hashBlock](CNode* pnode) {\n-        LockAssertion lock(::cs_main);\n+        AssertLockHeldUnverified(::cs_main);\n \n         // TODO: Avoid the repeated-serialization here\n         if (pnode->nVersion < INVALID_CB_NO_BAN_VERSION || pnode->fDisconnect)\n@@ -1506,7 +1506,7 @@ void RelayTransaction(const uint256& txid, const uint256& wtxid, const CConnman&\n {\n     connman.ForEachNode([&txid, &wtxid](CNode* pnode)\n     {\n-        LockAssertion lock(::cs_main);\n+        AssertLockHeldUnverified(::cs_main);\n \n         CNodeState &state = *State(pnode->GetId());\n         if (state.m_wtxid_relay) {\n@@ -3999,7 +3999,7 @@ void PeerLogicValidation::EvictExtraOutboundPeers(int64_t time_in_seconds)\n         int64_t oldest_block_announcement = std::numeric_limits<int64_t>::max();\n \n         m_connman.ForEachNode([&](CNode* pnode) {\n-            LockAssertion lock(::cs_main);\n+            AssertLockHeldUnverified(::cs_main);\n \n             // Ignore non-outbound peers, or nodes marked for disconnect already\n             if (!pnode->IsOutboundOrBlockRelayConn() || pnode->fDisconnect) return;\n@@ -4016,7 +4016,7 @@ void PeerLogicValidation::EvictExtraOutboundPeers(int64_t time_in_seconds)\n         });\n         if (worst_peer != -1) {\n             bool disconnected = m_connman.ForNode(worst_peer, [&](CNode *pnode) {\n-                LockAssertion lock(::cs_main);\n+                AssertLockHeldUnverified(::cs_main);\n \n                 // Only disconnect a peer that has been connected to us for\n                 // some reasonable fraction of our check-frequency, to give"
      },
      {
        "sha": "fd5a3bc5d1ab8aa9f13ceb11d8c66d26036c315b",
        "filename": "src/sync.h",
        "status": "modified",
        "additions": 33,
        "deletions": 17,
        "changes": 50,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3f8f78f135d9e52f586e2a1a8af9899612eff5e3/src/sync.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3f8f78f135d9e52f586e2a1a8af9899612eff5e3/src/sync.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/sync.h?ref=3f8f78f135d9e52f586e2a1a8af9899612eff5e3",
        "patch": "@@ -53,7 +53,7 @@ void LeaveCritical();\n void CheckLastCritical(void* cs, std::string& lockname, const char* guardname, const char* file, int line);\n std::string LocksHeld();\n template <typename MutexType>\n-void AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+void AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs);\n template <typename MutexType>\n void AssertLockNotHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) EXCLUSIVE_LOCKS_REQUIRED(!cs);\n void DeleteLock(void* cs);\n@@ -70,13 +70,43 @@ inline void EnterCritical(const char* pszName, const char* pszFile, int nLine, v\n inline void LeaveCritical() {}\n inline void CheckLastCritical(void* cs, std::string& lockname, const char* guardname, const char* file, int line) {}\n template <typename MutexType>\n-inline void AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) EXCLUSIVE_LOCKS_REQUIRED(cs) {}\n+inline void AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) {}\n template <typename MutexType>\n void AssertLockNotHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) EXCLUSIVE_LOCKS_REQUIRED(!cs) {}\n inline void DeleteLock(void* cs) {}\n inline bool LockStackEmpty() { return true; }\n #endif\n-#define AssertLockHeld(cs) AssertLockHeldInternal(#cs, __FILE__, __LINE__, &cs)\n+\n+/**\n+ * Assert that a mutex is locked. This assert is only allowed by compile-time\n+ * thread safey analysis in places where the compiler can verify the mutex is\n+ * locked, so it mostly provides redundancy and should not trigger in practice.\n+ * In places where the compile-time analysis cannot verify the mutex is held,\n+ * it will issue warnings or errors, and AssertLockHeldUnverified can be used\n+ * instead.\n+ *\n+ * @note Compile and run-time checks here may be disabled in some builds, or\n+ * produce non-fatal warnings instead of errors (see developer notes).\n+ */\n+#define AssertLockHeld(mutex) [&]() EXCLUSIVE_LOCKS_REQUIRED(mutex) { AssertLockHeldInternal(#mutex, __FILE__, __LINE__, &mutex); }()\n+\n+/**\n+ * Assert that a mutex is locked. This assert behaves exactly the same as\n+ * AssertLockHeld at run-time, but it has a different annotation that informs\n+ * compile-time thread safety analysis that the mutex is locked, instead of\n+ * requiring the analysis to verify the mutex is locked. This is useful to be\n+ * able to fall back to a run-time check for thread safety when compile-time\n+ * verification is not possible.\n+ *\n+ * @note: Checks may be disabled in some builds, see note in AssertLockHeld.\n+ */\n+#define AssertLockHeldUnverified(mutex) [&]() ASSERT_EXCLUSIVE_LOCK(mutex) { AssertLockHeldInternal(#mutex, __FILE__, __LINE__, &mutex); }()\n+\n+/**\n+ * Assert that a mutex is not locked.\n+ *\n+ * @note: Checks may be disabled in some builds, see note in AssertLockHeld.\n+ */\n #define AssertLockNotHeld(cs) AssertLockNotHeldInternal(#cs, __FILE__, __LINE__, &cs)\n \n /**\n@@ -352,18 +382,4 @@ class CSemaphoreGrant\n     }\n };\n \n-// Utility class for indicating to compiler thread analysis that a mutex is\n-// locked (when it couldn't be determined otherwise).\n-struct SCOPED_LOCKABLE LockAssertion\n-{\n-    template <typename Mutex>\n-    explicit LockAssertion(Mutex& mutex) EXCLUSIVE_LOCK_FUNCTION(mutex)\n-    {\n-#ifdef DEBUG_LOCKORDER\n-        AssertLockHeld(mutex);\n-#endif\n-    }\n-    ~LockAssertion() UNLOCK_FUNCTION() {}\n-};\n-\n #endif // BITCOIN_SYNC_H"
      }
    ]
  }
]