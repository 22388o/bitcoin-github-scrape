eklitzke,2018-03-11T08:07:08Z,"Can you explain what makes this safer? The types inside the existing cast are already unsigned, and AFAIK `size_t` is at least as large as `unsigned int` so I don't see how this affects overflow semantics.",https://github.com/bitcoin/bitcoin/pull/12611#issuecomment-372097098,372097098,
practicalswift,2018-03-12T19:07:48Z,"Consider the case:\n\n```\nunsigned int lenR = 4294967295; // std::numeric_limits<unsigned int>::max()\nunsigned int lenS = 0;\n```\n\nOn my system the following then holds true:\n\n```\n(size_t)lenR + (size_t)lenS + 7 == 4294967302\n(size_t)(lenR + lenS + 7) == 6\n```\n\nThe latter case is the result of an unsigned integer overflow since `4294967295 + 7` cannot be represented as an ",https://github.com/bitcoin/bitcoin/pull/12611#issuecomment-372428170,372428170,
eklitzke,2018-03-13T07:06:59Z,"I see, and now that you point it out it makes sense. This PR is probably not the place for it, but I'm curious what you think about making these kinds of semantics better defined (e.g. by using `-fwrapv`, or related flags).",https://github.com/bitcoin/bitcoin/pull/12611#issuecomment-372567279,372567279,
practicalswift,2018-03-14T11:30:43Z,"@eklitzke Is that an utACK? :-)\n\nRegarding `-ftrapv` for catching signed arithmetic overflows â€“ see #12686.",https://github.com/bitcoin/bitcoin/pull/12611#issuecomment-372989971,372989971,
instagibbs,2018-03-14T15:50:59Z,utACK https://github.com/bitcoin/bitcoin/pull/12611/commits/332ecf9b497dda7d4faaea50768b104dd2666bf5,https://github.com/bitcoin/bitcoin/pull/12611#issuecomment-373071441,373071441,
eklitzke,2018-03-15T13:20:36Z,utACK 332ecf9b497dda7d4faaea50768b104dd2666bf5,https://github.com/bitcoin/bitcoin/pull/12611#issuecomment-373373088,373373088,
practicalswift,2018-05-02T12:23:54Z,@sipa @laanwj @theuni Would you mind reviewing? :-),https://github.com/bitcoin/bitcoin/pull/12611#issuecomment-385959833,385959833,
theuni,2018-05-02T22:50:34Z,"> (Luckily both lenR and lenS are guaranteed to be in the closed range [0, 255] as the code is currently written.)\n\nThis code is basically one constraint after another, each enabling the safety of the next check. The very first constraints (sig size checks) pretty much rule out conversion issues further down. So IMO it's not so much ""luckily"" that way, so much as it is necessarily that way.\n",https://github.com/bitcoin/bitcoin/pull/12611#issuecomment-386145464,386145464,
sipa,2018-05-02T23:37:18Z,I have no opinion.,https://github.com/bitcoin/bitcoin/pull/12611#issuecomment-386153399,386153399,
promag,2018-05-02T23:59:07Z,Just change `lenR`and `lenS` to `unsigner char`?,https://github.com/bitcoin/bitcoin/pull/12611#issuecomment-386156772,386156772,
practicalswift,2018-05-03T09:47:37Z,"@theuni Do you mean like this?\n\n```diff\ndiff --git a/src/script/interpreter.cpp b/src/script/interpreter.cpp\nindex 2cdff7e..afcb6d5 100644\n--- a/src/script/interpreter.cpp\n+++ b/src/script/interpreter.cpp\n@@ -121,24 +121,26 @@ bool static IsValidSignatureEncoding(const std::vector<unsigned char> &sig) {\n     if (sig.size() < 9) return false;\n     if (sig.size() > 73) return false",https://github.com/bitcoin/bitcoin/pull/12611#issuecomment-386243225,386243225,
practicalswift,2018-06-29T06:01:16Z,Ping @theuni :-),https://github.com/bitcoin/bitcoin/pull/12611#issuecomment-401256174,401256174,
MarcoFalke,2018-06-29T09:14:29Z,"There hasn't been any activity in the last month and half of the reviewers consider the current code already 100% safe and easier to read. Could be closed, maybe?",https://github.com/bitcoin/bitcoin/pull/12611#issuecomment-401297945,401297945,
practicalswift,2018-06-29T09:24:55Z,"@MarcoFalke In a comment above @theuni wrote ""The intent would be much more clear if the sig.size() were cast and stored as a uint8_t"". I agree with that and that's why I asked for a clarification before updating the PR and asking for a re-review.",https://github.com/bitcoin/bitcoin/pull/12611#issuecomment-401300640,401300640,
theuni,2018-06-29T17:06:34Z,"> The intent would be much more clear if the sig.size() were cast and stored as a uint8_t, then used for the rest of the function for comparison rather than size(). At least then the ranges would be 100% obvious. **I'm not actually advocating for that change, though.**\n\nThis code is safe as-is. While your proposed changes looks fine too, I just don't see any benefit in risking the change.\n",https://github.com/bitcoin/bitcoin/pull/12611#issuecomment-401415983,401415983,
practicalswift,2018-06-29T18:19:12Z,"@theuni Thanks! Now closing :-)\n",https://github.com/bitcoin/bitcoin/pull/12611#issuecomment-401434193,401434193,
