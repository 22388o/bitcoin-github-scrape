[
  {
    "sha": "1f45e2164a7674f716b425a6658c41ca7c30265b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxZjQ1ZTIxNjRhNzY3NGY3MTZiNDI1YTY2NThjNDFjYTdjMzAyNjVi",
    "commit": {
      "author": {
        "name": "practicalswift",
        "email": "practicalswift@users.noreply.github.com",
        "date": "2018-03-09T14:03:40Z"
      },
      "committer": {
        "name": "practicalswift",
        "email": "practicalswift@users.noreply.github.com",
        "date": "2018-03-09T14:03:40Z"
      },
      "message": "scripted-diff: Convert 11 enums into scoped enums (C++11)\n\n-BEGIN VERIFY SCRIPT-\n\nsed -i 's/enum DBErrors/enum class DBErrors/g' src/wallet/walletdb.h\ngit grep -l DB_ | xargs sed -i 's/DB_\\(LOAD_OK\\|CORRUPT\\|NONCRITICAL_ERROR\\|TOO_NEW\\|LOAD_FAIL\\|NEED_REWRITE\\)/DBErrors::\\1/g'\nsed -i 's/^    DBErrors::/    /g' src/wallet/walletdb.h\n\nsed -i 's/enum VerifyResult/enum class VerifyResult/g' src/wallet/db.h\nsed -i 's/\\(VERIFY_OK\\|RECOVER_OK\\|RECOVER_FAIL\\)/VerifyResult::\\1/g' src/wallet/db.cpp\n\nsed -i 's/enum ThresholdState/enum class ThresholdState/g' src/versionbits.h\ngit grep -l THRESHOLD_ | xargs sed -i 's/THRESHOLD_\\(DEFINED\\|STARTED\\|LOCKED_IN\\|ACTIVE\\|FAILED\\)/ThresholdState::\\1/g'\nsed -i 's/^    ThresholdState::/    /g' src/versionbits.h\n\nsed -i 's/enum SigVersion/enum class SigVersion/g' src/script/interpreter.h\ngit grep -l SIGVERSION_ | xargs sed -i 's/SIGVERSION_\\(BASE\\|WITNESS_V0\\)/SigVersion::\\1/g'\nsed -i 's/^    SigVersion::/    /g' src/script/interpreter.h\n\nsed -i 's/enum RetFormat {/enum class RetFormat {/g' src/rest.cpp\nsed -i 's/RF_\\(UNDEF\\|BINARY\\|HEX\\|JSON\\)/RetFormat::\\1/g' src/rest.cpp\nsed -i 's/^    RetFormat::/    /g' src/rest.cpp\n\nsed -i 's/enum HelpMessageMode {/enum class HelpMessageMode {/g' src/init.h\ngit grep -l HMM_ | xargs sed -i 's/HMM_BITCOIN/HelpMessageMode::BITCOIN/g'\nsed -i 's/^    HelpMessageMode::/    /g' src/init.h\n\nsed -i 's/enum FeeEstimateHorizon/enum class FeeEstimateHorizon/g' src/policy/fees.h\n\nsed -i 's/enum RBFTransactionState/enum class RBFTransactionState/g' src/policy/rbf.h\ngit grep -l RBF_ | xargs sed -i 's/RBF_TRANSACTIONSTATE_\\(UNKNOWN\\|REPLACEABLE_BIP125\\|FINAL\\)/RBFTransactionState::\\1/g'\nsed -i 's/^    RBFTransactionState::/    /g' src/policy/rbf.h\n\nsed -i 's/enum BlockSource {/enum class BlockSource {/g' src/qt/clientmodel.h\ngit grep -l BLOCK_SOURCE_ | xargs sed -i 's/BLOCK_SOURCE_\\(NONE\\|REINDEX\\|DISK\\|NETWORK\\)/BlockSource::\\1/g'\nsed -i 's/^    BlockSource::/    /g' src/qt/clientmodel.h\n\nsed -i 's/enum FlushStateMode {/enum class FlushStateMode {/g' src/validation.cpp\nsed -i 's/FLUSH_STATE_\\(NONE\\|IF_NEEDED\\|PERIODIC\\|ALWAYS\\)/FlushStateMode::\\1/g' src/validation.cpp\nsed -i 's/^    FlushStateMode::/    /g' src/validation.cpp\n\nsed -i 's/enum WitnessMode {/enum class WitnessMode {/g' src/test/script_tests.cpp\nsed -i 's/WITNESS_\\(NONE\\|PKH\\|SH\\)/WitnessMode::\\1/g' src/test/script_tests.cpp\nsed -i 's/^    WitnessMode::/    /g' src/test/script_tests.cpp\n\n-END VERIFY SCRIPT-",
      "tree": {
        "sha": "a02b36001ccf6256f979e7f335f0130a16fe8d50",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a02b36001ccf6256f979e7f335f0130a16fe8d50"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1f45e2164a7674f716b425a6658c41ca7c30265b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1f45e2164a7674f716b425a6658c41ca7c30265b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1f45e2164a7674f716b425a6658c41ca7c30265b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1f45e2164a7674f716b425a6658c41ca7c30265b/comments",
    "author": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "29fad97c320c892ab6a480c81e2078ec22ab354b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/29fad97c320c892ab6a480c81e2078ec22ab354b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/29fad97c320c892ab6a480c81e2078ec22ab354b"
      }
    ],
    "stats": {
      "total": 590,
      "additions": 295,
      "deletions": 295
    },
    "files": [
      {
        "sha": "705fa368a5072721f32a57d4aa3f21492bdc99dc",
        "filename": "src/bench/verify_script.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1f45e2164a7674f716b425a6658c41ca7c30265b/src/bench/verify_script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1f45e2164a7674f716b425a6658c41ca7c30265b/src/bench/verify_script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/verify_script.cpp?ref=1f45e2164a7674f716b425a6658c41ca7c30265b",
        "patch": "@@ -75,7 +75,7 @@ static void VerifyScriptBench(benchmark::State& state)\n     CMutableTransaction txSpend = BuildSpendingTransaction(scriptSig, txCredit);\n     CScriptWitness& witness = txSpend.vin[0].scriptWitness;\n     witness.stack.emplace_back();\n-    key.Sign(SignatureHash(witScriptPubkey, txSpend, 0, SIGHASH_ALL, txCredit.vout[0].nValue, SIGVERSION_WITNESS_V0), witness.stack.back(), 0);\n+    key.Sign(SignatureHash(witScriptPubkey, txSpend, 0, SIGHASH_ALL, txCredit.vout[0].nValue, SigVersion::WITNESS_V0), witness.stack.back(), 0);\n     witness.stack.back().push_back(static_cast<unsigned char>(SIGHASH_ALL));\n     witness.stack.push_back(ToByteVector(pubkey));\n "
      },
      {
        "sha": "db5e6106845bdc66da8fe43d3f3bd2dd6d4bd615",
        "filename": "src/bitcoind.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1f45e2164a7674f716b425a6658c41ca7c30265b/src/bitcoind.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1f45e2164a7674f716b425a6658c41ca7c30265b/src/bitcoind.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoind.cpp?ref=1f45e2164a7674f716b425a6658c41ca7c30265b",
        "patch": "@@ -79,7 +79,7 @@ bool AppInit(int argc, char* argv[])\n             strUsage += \"\\n\" + _(\"Usage:\") + \"\\n\" +\n                   \"  bitcoind [options]                     \" + strprintf(_(\"Start %s Daemon\"), _(PACKAGE_NAME)) + \"\\n\";\n \n-            strUsage += \"\\n\" + HelpMessage(HMM_BITCOIND);\n+            strUsage += \"\\n\" + HelpMessage(HelpMessageMode::BITCOIND);\n         }\n \n         fprintf(stdout, \"%s\", strUsage.c_str());"
      },
      {
        "sha": "0bf0a0b4b5bb9268db131b90898fbec1b6d5dd94",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1f45e2164a7674f716b425a6658c41ca7c30265b/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1f45e2164a7674f716b425a6658c41ca7c30265b/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=1f45e2164a7674f716b425a6658c41ca7c30265b",
        "patch": "@@ -338,7 +338,7 @@ std::string HelpMessage(HelpMessageMode mode)\n     if (showDebug)\n         strUsage += HelpMessageOpt(\"-blocksonly\", strprintf(_(\"Whether to operate in a blocks only mode (default: %u)\"), DEFAULT_BLOCKSONLY));\n     strUsage += HelpMessageOpt(\"-conf=<file>\", strprintf(_(\"Specify configuration file. Relative paths will be prefixed by datadir location. (default: %s)\"), BITCOIN_CONF_FILENAME));\n-    if (mode == HMM_BITCOIND)\n+    if (mode == HelpMessageMode::BITCOIND)\n     {\n #if HAVE_DECL_DAEMON\n         strUsage += HelpMessageOpt(\"-daemon\", _(\"Run in the background as a daemon and accept commands\"));"
      },
      {
        "sha": "6f75a43e62d6d2f23e181dfffec2d97d900caeaf",
        "filename": "src/init.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1f45e2164a7674f716b425a6658c41ca7c30265b/src/init.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1f45e2164a7674f716b425a6658c41ca7c30265b/src/init.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.h?ref=1f45e2164a7674f716b425a6658c41ca7c30265b",
        "patch": "@@ -57,9 +57,9 @@ bool AppInitLockDataDirectory();\n bool AppInitMain();\n \n /** The help message mode determines what help message to show */\n-enum HelpMessageMode {\n-    HMM_BITCOIND,\n-    HMM_BITCOIN_QT\n+enum class HelpMessageMode {\n+    BITCOIND,\n+    BITCOIN_QT\n };\n \n /** Help for options shared between UI and daemon (for -help) */"
      },
      {
        "sha": "7f80fc92c2e22415088a1d06ea9279057c3bf19d",
        "filename": "src/policy/fees.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1f45e2164a7674f716b425a6658c41ca7c30265b/src/policy/fees.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1f45e2164a7674f716b425a6658c41ca7c30265b/src/policy/fees.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/fees.h?ref=1f45e2164a7674f716b425a6658c41ca7c30265b",
        "patch": "@@ -68,7 +68,7 @@ class TxConfirmStats;\n \n /* Identifier for each of the 3 different TxConfirmStats which will track\n  * history over different time horizons. */\n-enum FeeEstimateHorizon {\n+enum class FeeEstimateHorizon {\n     SHORT_HALFLIFE = 0,\n     MED_HALFLIFE = 1,\n     LONG_HALFLIFE = 2"
      },
      {
        "sha": "f8b8b1e4ad0d3de5935f1e505061dc126fea3252",
        "filename": "src/policy/policy.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1f45e2164a7674f716b425a6658c41ca7c30265b/src/policy/policy.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1f45e2164a7674f716b425a6658c41ca7c30265b/src/policy/policy.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/policy.cpp?ref=1f45e2164a7674f716b425a6658c41ca7c30265b",
        "patch": "@@ -179,7 +179,7 @@ bool AreInputsStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)\n         {\n             std::vector<std::vector<unsigned char> > stack;\n             // convert the scriptSig into a stack, so we can inspect the redeemScript\n-            if (!EvalScript(stack, tx.vin[i].scriptSig, SCRIPT_VERIFY_NONE, BaseSignatureChecker(), SIGVERSION_BASE))\n+            if (!EvalScript(stack, tx.vin[i].scriptSig, SCRIPT_VERIFY_NONE, BaseSignatureChecker(), SigVersion::BASE))\n                 return false;\n             if (stack.empty())\n                 return false;\n@@ -215,7 +215,7 @@ bool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)\n             // If the scriptPubKey is P2SH, we try to extract the redeemScript casually by converting the scriptSig\n             // into a stack. We do not check IsPushOnly nor compare the hash as these will be done later anyway.\n             // If the check fails at this stage, we know that this txid must be a bad one.\n-            if (!EvalScript(stack, tx.vin[i].scriptSig, SCRIPT_VERIFY_NONE, BaseSignatureChecker(), SIGVERSION_BASE))\n+            if (!EvalScript(stack, tx.vin[i].scriptSig, SCRIPT_VERIFY_NONE, BaseSignatureChecker(), SigVersion::BASE))\n                 return false;\n             if (stack.empty())\n                 return false;"
      },
      {
        "sha": "81b2a7fadc5a8ad944a8a9bdeb52dcd6119cefc0",
        "filename": "src/policy/rbf.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1f45e2164a7674f716b425a6658c41ca7c30265b/src/policy/rbf.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1f45e2164a7674f716b425a6658c41ca7c30265b/src/policy/rbf.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/rbf.cpp?ref=1f45e2164a7674f716b425a6658c41ca7c30265b",
        "patch": "@@ -22,13 +22,13 @@ RBFTransactionState IsRBFOptIn(const CTransaction &tx, CTxMemPool &pool)\n \n     // First check the transaction itself.\n     if (SignalsOptInRBF(tx)) {\n-        return RBF_TRANSACTIONSTATE_REPLACEABLE_BIP125;\n+        return RBFTransactionState::REPLACEABLE_BIP125;\n     }\n \n     // If this transaction is not in our mempool, then we can't be sure\n     // we will know about all its inputs.\n     if (!pool.exists(tx.GetHash())) {\n-        return RBF_TRANSACTIONSTATE_UNKNOWN;\n+        return RBFTransactionState::UNKNOWN;\n     }\n \n     // If all the inputs have nSequence >= maxint-1, it still might be\n@@ -40,8 +40,8 @@ RBFTransactionState IsRBFOptIn(const CTransaction &tx, CTxMemPool &pool)\n \n     for (CTxMemPool::txiter it : setAncestors) {\n         if (SignalsOptInRBF(it->GetTx())) {\n-            return RBF_TRANSACTIONSTATE_REPLACEABLE_BIP125;\n+            return RBFTransactionState::REPLACEABLE_BIP125;\n         }\n     }\n-    return RBF_TRANSACTIONSTATE_FINAL;\n+    return RBFTransactionState::FINAL;\n }"
      },
      {
        "sha": "b10532addf3ed2c0ac96d5c0f6b446bb3c29baaa",
        "filename": "src/policy/rbf.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1f45e2164a7674f716b425a6658c41ca7c30265b/src/policy/rbf.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1f45e2164a7674f716b425a6658c41ca7c30265b/src/policy/rbf.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/rbf.h?ref=1f45e2164a7674f716b425a6658c41ca7c30265b",
        "patch": "@@ -9,10 +9,10 @@\n \n static const uint32_t MAX_BIP125_RBF_SEQUENCE = 0xfffffffd;\n \n-enum RBFTransactionState {\n-    RBF_TRANSACTIONSTATE_UNKNOWN,\n-    RBF_TRANSACTIONSTATE_REPLACEABLE_BIP125,\n-    RBF_TRANSACTIONSTATE_FINAL\n+enum class RBFTransactionState {\n+    UNKNOWN,\n+    REPLACEABLE_BIP125,\n+    FINAL\n };\n \n // Check whether the sequence numbers on this transaction are signaling"
      },
      {
        "sha": "2f6a377a68df9babd8834f6a012efdfc39a83a8e",
        "filename": "src/qt/bitcoingui.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1f45e2164a7674f716b425a6658c41ca7c30265b/src/qt/bitcoingui.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1f45e2164a7674f716b425a6658c41ca7c30265b/src/qt/bitcoingui.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoingui.cpp?ref=1f45e2164a7674f716b425a6658c41ca7c30265b",
        "patch": "@@ -780,25 +780,25 @@ void BitcoinGUI::setNumBlocks(int count, const QDateTime& blockDate, double nVer\n     // Acquire current block source\n     enum BlockSource blockSource = clientModel->getBlockSource();\n     switch (blockSource) {\n-        case BLOCK_SOURCE_NETWORK:\n+        case BlockSource::NETWORK:\n             if (header) {\n                 updateHeadersSyncProgressLabel();\n                 return;\n             }\n             progressBarLabel->setText(tr(\"Synchronizing with network...\"));\n             updateHeadersSyncProgressLabel();\n             break;\n-        case BLOCK_SOURCE_DISK:\n+        case BlockSource::DISK:\n             if (header) {\n                 progressBarLabel->setText(tr(\"Indexing blocks on disk...\"));\n             } else {\n                 progressBarLabel->setText(tr(\"Processing blocks on disk...\"));\n             }\n             break;\n-        case BLOCK_SOURCE_REINDEX:\n+        case BlockSource::REINDEX:\n             progressBarLabel->setText(tr(\"Reindexing blocks on disk...\"));\n             break;\n-        case BLOCK_SOURCE_NONE:\n+        case BlockSource::NONE:\n             if (header) {\n                 return;\n             }"
      },
      {
        "sha": "40661d9ec313f1b07c5e1761681281968c86fbcb",
        "filename": "src/qt/clientmodel.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1f45e2164a7674f716b425a6658c41ca7c30265b/src/qt/clientmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1f45e2164a7674f716b425a6658c41ca7c30265b/src/qt/clientmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/clientmodel.cpp?ref=1f45e2164a7674f716b425a6658c41ca7c30265b",
        "patch": "@@ -177,13 +177,13 @@ bool ClientModel::inInitialBlockDownload() const\n enum BlockSource ClientModel::getBlockSource() const\n {\n     if (fReindex)\n-        return BLOCK_SOURCE_REINDEX;\n+        return BlockSource::REINDEX;\n     else if (fImporting)\n-        return BLOCK_SOURCE_DISK;\n+        return BlockSource::DISK;\n     else if (getNumConnections() > 0)\n-        return BLOCK_SOURCE_NETWORK;\n+        return BlockSource::NETWORK;\n \n-    return BLOCK_SOURCE_NONE;\n+    return BlockSource::NONE;\n }\n \n void ClientModel::setNetworkActive(bool active)"
      },
      {
        "sha": "1118bc31b347d2b4f5ed89f754bfce26542424d3",
        "filename": "src/qt/clientmodel.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1f45e2164a7674f716b425a6658c41ca7c30265b/src/qt/clientmodel.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1f45e2164a7674f716b425a6658c41ca7c30265b/src/qt/clientmodel.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/clientmodel.h?ref=1f45e2164a7674f716b425a6658c41ca7c30265b",
        "patch": "@@ -20,11 +20,11 @@ QT_BEGIN_NAMESPACE\n class QTimer;\n QT_END_NAMESPACE\n \n-enum BlockSource {\n-    BLOCK_SOURCE_NONE,\n-    BLOCK_SOURCE_REINDEX,\n-    BLOCK_SOURCE_DISK,\n-    BLOCK_SOURCE_NETWORK\n+enum class BlockSource {\n+    NONE,\n+    REINDEX,\n+    DISK,\n+    NETWORK\n };\n \n enum NumConnections {"
      },
      {
        "sha": "c19e6aae78ee44aa9786df5a7a1a7e087cb5413d",
        "filename": "src/qt/utilitydialog.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1f45e2164a7674f716b425a6658c41ca7c30265b/src/qt/utilitydialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1f45e2164a7674f716b425a6658c41ca7c30265b/src/qt/utilitydialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/utilitydialog.cpp?ref=1f45e2164a7674f716b425a6658c41ca7c30265b",
        "patch": "@@ -77,7 +77,7 @@ HelpMessageDialog::HelpMessageDialog(QWidget *parent, bool about) :\n         cursor.insertText(header);\n         cursor.insertBlock();\n \n-        std::string strUsage = HelpMessage(HMM_BITCOIN_QT);\n+        std::string strUsage = HelpMessage(HelpMessageMode::BITCOIN_QT);\n         const bool showDebug = gArgs.GetBoolArg(\"-help-debug\", false);\n         strUsage += HelpMessageGroup(tr(\"UI Options:\").toStdString());\n         if (showDebug) {"
      },
      {
        "sha": "fdd097c8aca556da030ef6be5be0e9e03c2c3c19",
        "filename": "src/rest.cpp",
        "status": "modified",
        "additions": 27,
        "deletions": 27,
        "changes": 54,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1f45e2164a7674f716b425a6658c41ca7c30265b/src/rest.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1f45e2164a7674f716b425a6658c41ca7c30265b/src/rest.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rest.cpp?ref=1f45e2164a7674f716b425a6658c41ca7c30265b",
        "patch": "@@ -24,21 +24,21 @@\n \n static const size_t MAX_GETUTXOS_OUTPOINTS = 15; //allow a max of 15 outpoints to be queried at once\n \n-enum RetFormat {\n-    RF_UNDEF,\n-    RF_BINARY,\n-    RF_HEX,\n-    RF_JSON,\n+enum class RetFormat {\n+    UNDEF,\n+    BINARY,\n+    HEX,\n+    JSON,\n };\n \n static const struct {\n     enum RetFormat rf;\n     const char* name;\n } rf_names[] = {\n-      {RF_UNDEF, \"\"},\n-      {RF_BINARY, \"bin\"},\n-      {RF_HEX, \"hex\"},\n-      {RF_JSON, \"json\"},\n+      {RetFormat::UNDEF, \"\"},\n+      {RetFormat::BINARY, \"bin\"},\n+      {RetFormat::HEX, \"hex\"},\n+      {RetFormat::JSON, \"json\"},\n };\n \n struct CCoin {\n@@ -163,20 +163,20 @@ static bool rest_headers(HTTPRequest* req,\n     }\n \n     switch (rf) {\n-    case RF_BINARY: {\n+    case RetFormat::BINARY: {\n         std::string binaryHeader = ssHeader.str();\n         req->WriteHeader(\"Content-Type\", \"application/octet-stream\");\n         req->WriteReply(HTTP_OK, binaryHeader);\n         return true;\n     }\n \n-    case RF_HEX: {\n+    case RetFormat::HEX: {\n         std::string strHex = HexStr(ssHeader.begin(), ssHeader.end()) + \"\\n\";\n         req->WriteHeader(\"Content-Type\", \"text/plain\");\n         req->WriteReply(HTTP_OK, strHex);\n         return true;\n     }\n-    case RF_JSON: {\n+    case RetFormat::JSON: {\n         UniValue jsonHeaders(UniValue::VARR);\n         {\n             LOCK(cs_main);\n@@ -227,21 +227,21 @@ static bool rest_block(HTTPRequest* req,\n     ssBlock << block;\n \n     switch (rf) {\n-    case RF_BINARY: {\n+    case RetFormat::BINARY: {\n         std::string binaryBlock = ssBlock.str();\n         req->WriteHeader(\"Content-Type\", \"application/octet-stream\");\n         req->WriteReply(HTTP_OK, binaryBlock);\n         return true;\n     }\n \n-    case RF_HEX: {\n+    case RetFormat::HEX: {\n         std::string strHex = HexStr(ssBlock.begin(), ssBlock.end()) + \"\\n\";\n         req->WriteHeader(\"Content-Type\", \"text/plain\");\n         req->WriteReply(HTTP_OK, strHex);\n         return true;\n     }\n \n-    case RF_JSON: {\n+    case RetFormat::JSON: {\n         UniValue objBlock;\n         {\n             LOCK(cs_main);\n@@ -280,7 +280,7 @@ static bool rest_chaininfo(HTTPRequest* req, const std::string& strURIPart)\n     const RetFormat rf = ParseDataFormat(param, strURIPart);\n \n     switch (rf) {\n-    case RF_JSON: {\n+    case RetFormat::JSON: {\n         JSONRPCRequest jsonRequest;\n         jsonRequest.params = UniValue(UniValue::VARR);\n         UniValue chainInfoObject = getblockchaininfo(jsonRequest);\n@@ -303,7 +303,7 @@ static bool rest_mempool_info(HTTPRequest* req, const std::string& strURIPart)\n     const RetFormat rf = ParseDataFormat(param, strURIPart);\n \n     switch (rf) {\n-    case RF_JSON: {\n+    case RetFormat::JSON: {\n         UniValue mempoolInfoObject = mempoolInfoToJSON();\n \n         std::string strJSON = mempoolInfoObject.write() + \"\\n\";\n@@ -325,7 +325,7 @@ static bool rest_mempool_contents(HTTPRequest* req, const std::string& strURIPar\n     const RetFormat rf = ParseDataFormat(param, strURIPart);\n \n     switch (rf) {\n-    case RF_JSON: {\n+    case RetFormat::JSON: {\n         UniValue mempoolObject = mempoolToJSON(true);\n \n         std::string strJSON = mempoolObject.write() + \"\\n\";\n@@ -359,21 +359,21 @@ static bool rest_tx(HTTPRequest* req, const std::string& strURIPart)\n     ssTx << tx;\n \n     switch (rf) {\n-    case RF_BINARY: {\n+    case RetFormat::BINARY: {\n         std::string binaryTx = ssTx.str();\n         req->WriteHeader(\"Content-Type\", \"application/octet-stream\");\n         req->WriteReply(HTTP_OK, binaryTx);\n         return true;\n     }\n \n-    case RF_HEX: {\n+    case RetFormat::HEX: {\n         std::string strHex = HexStr(ssTx.begin(), ssTx.end()) + \"\\n\";\n         req->WriteHeader(\"Content-Type\", \"text/plain\");\n         req->WriteReply(HTTP_OK, strHex);\n         return true;\n     }\n \n-    case RF_JSON: {\n+    case RetFormat::JSON: {\n         UniValue objTx(UniValue::VOBJ);\n         TxToUniv(*tx, hashBlock, objTx);\n         std::string strJSON = objTx.write() + \"\\n\";\n@@ -440,13 +440,13 @@ static bool rest_getutxos(HTTPRequest* req, const std::string& strURIPart)\n     }\n \n     switch (rf) {\n-    case RF_HEX: {\n+    case RetFormat::HEX: {\n         // convert hex to bin, continue then with bin part\n         std::vector<unsigned char> strRequestV = ParseHex(strRequestMutable);\n         strRequestMutable.assign(strRequestV.begin(), strRequestV.end());\n     }\n \n-    case RF_BINARY: {\n+    case RetFormat::BINARY: {\n         try {\n             //deserialize only if user sent a request\n             if (strRequestMutable.size() > 0)\n@@ -466,7 +466,7 @@ static bool rest_getutxos(HTTPRequest* req, const std::string& strURIPart)\n         break;\n     }\n \n-    case RF_JSON: {\n+    case RetFormat::JSON: {\n         if (!fInputParsed)\n             return RESTERR(req, HTTP_BAD_REQUEST, \"Error: empty request\");\n         break;\n@@ -513,7 +513,7 @@ static bool rest_getutxos(HTTPRequest* req, const std::string& strURIPart)\n     }\n \n     switch (rf) {\n-    case RF_BINARY: {\n+    case RetFormat::BINARY: {\n         // serialize data\n         // use exact same output as mentioned in Bip64\n         CDataStream ssGetUTXOResponse(SER_NETWORK, PROTOCOL_VERSION);\n@@ -525,7 +525,7 @@ static bool rest_getutxos(HTTPRequest* req, const std::string& strURIPart)\n         return true;\n     }\n \n-    case RF_HEX: {\n+    case RetFormat::HEX: {\n         CDataStream ssGetUTXOResponse(SER_NETWORK, PROTOCOL_VERSION);\n         ssGetUTXOResponse << chainActive.Height() << chainActive.Tip()->GetBlockHash() << bitmap << outs;\n         std::string strHex = HexStr(ssGetUTXOResponse.begin(), ssGetUTXOResponse.end()) + \"\\n\";\n@@ -535,7 +535,7 @@ static bool rest_getutxos(HTTPRequest* req, const std::string& strURIPart)\n         return true;\n     }\n \n-    case RF_JSON: {\n+    case RetFormat::JSON: {\n         UniValue objGetUTXOResponse(UniValue::VOBJ);\n \n         // pack in some essentials"
      },
      {
        "sha": "21a7e05d3d729c4727ec63effd1cc04ac6a7636f",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1f45e2164a7674f716b425a6658c41ca7c30265b/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1f45e2164a7674f716b425a6658c41ca7c30265b/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=1f45e2164a7674f716b425a6658c41ca7c30265b",
        "patch": "@@ -1121,20 +1121,20 @@ static UniValue BIP9SoftForkDesc(const Consensus::Params& consensusParams, Conse\n     UniValue rv(UniValue::VOBJ);\n     const ThresholdState thresholdState = VersionBitsTipState(consensusParams, id);\n     switch (thresholdState) {\n-    case THRESHOLD_DEFINED: rv.pushKV(\"status\", \"defined\"); break;\n-    case THRESHOLD_STARTED: rv.pushKV(\"status\", \"started\"); break;\n-    case THRESHOLD_LOCKED_IN: rv.pushKV(\"status\", \"locked_in\"); break;\n-    case THRESHOLD_ACTIVE: rv.pushKV(\"status\", \"active\"); break;\n-    case THRESHOLD_FAILED: rv.pushKV(\"status\", \"failed\"); break;\n+    case ThresholdState::DEFINED: rv.pushKV(\"status\", \"defined\"); break;\n+    case ThresholdState::STARTED: rv.pushKV(\"status\", \"started\"); break;\n+    case ThresholdState::LOCKED_IN: rv.pushKV(\"status\", \"locked_in\"); break;\n+    case ThresholdState::ACTIVE: rv.pushKV(\"status\", \"active\"); break;\n+    case ThresholdState::FAILED: rv.pushKV(\"status\", \"failed\"); break;\n     }\n-    if (THRESHOLD_STARTED == thresholdState)\n+    if (ThresholdState::STARTED == thresholdState)\n     {\n         rv.pushKV(\"bit\", consensusParams.vDeployments[id].bit);\n     }\n     rv.pushKV(\"startTime\", consensusParams.vDeployments[id].nStartTime);\n     rv.pushKV(\"timeout\", consensusParams.vDeployments[id].nTimeout);\n     rv.pushKV(\"since\", VersionBitsTipStateSinceHeight(consensusParams, id));\n-    if (THRESHOLD_STARTED == thresholdState)\n+    if (ThresholdState::STARTED == thresholdState)\n     {\n         UniValue statsUV(UniValue::VOBJ);\n         BIP9Stats statsStruct = VersionBitsTipStatistics(consensusParams, id);"
      },
      {
        "sha": "dba21d6e4fac4c01e45b5f8f8dca924d08443fe8",
        "filename": "src/rpc/mining.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1f45e2164a7674f716b425a6658c41ca7c30265b/src/rpc/mining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1f45e2164a7674f716b425a6658c41ca7c30265b/src/rpc/mining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/mining.cpp?ref=1f45e2164a7674f716b425a6658c41ca7c30265b",
        "patch": "@@ -533,7 +533,7 @@ UniValue getblocktemplate(const JSONRPCRequest& request)\n     pblock->nNonce = 0;\n \n     // NOTE: If at some point we support pre-segwit miners post-segwit-activation, this needs to take segwit support into consideration\n-    const bool fPreSegWit = (THRESHOLD_ACTIVE != VersionBitsState(pindexPrev, consensusParams, Consensus::DEPLOYMENT_SEGWIT, versionbitscache));\n+    const bool fPreSegWit = (ThresholdState::ACTIVE != VersionBitsState(pindexPrev, consensusParams, Consensus::DEPLOYMENT_SEGWIT, versionbitscache));\n \n     UniValue aCaps(UniValue::VARR); aCaps.push_back(\"proposal\");\n \n@@ -594,15 +594,15 @@ UniValue getblocktemplate(const JSONRPCRequest& request)\n         Consensus::DeploymentPos pos = Consensus::DeploymentPos(j);\n         ThresholdState state = VersionBitsState(pindexPrev, consensusParams, pos, versionbitscache);\n         switch (state) {\n-            case THRESHOLD_DEFINED:\n-            case THRESHOLD_FAILED:\n+            case ThresholdState::DEFINED:\n+            case ThresholdState::FAILED:\n                 // Not exposed to GBT at all\n                 break;\n-            case THRESHOLD_LOCKED_IN:\n+            case ThresholdState::LOCKED_IN:\n                 // Ensure bit is set in block version\n                 pblock->nVersion |= VersionBitsMask(consensusParams, pos);\n                 // FALL THROUGH to get vbavailable set...\n-            case THRESHOLD_STARTED:\n+            case ThresholdState::STARTED:\n             {\n                 const struct VBDeploymentInfo& vbinfo = VersionBitsDeploymentInfo[pos];\n                 vbavailable.pushKV(gbt_vb_name(pos), consensusParams.vDeployments[pos].bit);\n@@ -614,7 +614,7 @@ UniValue getblocktemplate(const JSONRPCRequest& request)\n                 }\n                 break;\n             }\n-            case THRESHOLD_ACTIVE:\n+            case ThresholdState::ACTIVE:\n             {\n                 // Add to rules only\n                 const struct VBDeploymentInfo& vbinfo = VersionBitsDeploymentInfo[pos];"
      },
      {
        "sha": "4ab935903ba55fa4b723c07243a9ea288d47abd2",
        "filename": "src/script/interpreter.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1f45e2164a7674f716b425a6658c41ca7c30265b/src/script/interpreter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1f45e2164a7674f716b425a6658c41ca7c30265b/src/script/interpreter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.cpp?ref=1f45e2164a7674f716b425a6658c41ca7c30265b",
        "patch": "@@ -219,7 +219,7 @@ bool static CheckPubKeyEncoding(const valtype &vchPubKey, unsigned int flags, co\n         return set_error(serror, SCRIPT_ERR_PUBKEYTYPE);\n     }\n     // Only compressed keys are accepted in segwit\n-    if ((flags & SCRIPT_VERIFY_WITNESS_PUBKEYTYPE) != 0 && sigversion == SIGVERSION_WITNESS_V0 && !IsCompressedPubKey(vchPubKey)) {\n+    if ((flags & SCRIPT_VERIFY_WITNESS_PUBKEYTYPE) != 0 && sigversion == SigVersion::WITNESS_V0 && !IsCompressedPubKey(vchPubKey)) {\n         return set_error(serror, SCRIPT_ERR_WITNESS_PUBKEYTYPE);\n     }\n     return true;\n@@ -443,7 +443,7 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n                         if (stack.size() < 1)\n                             return set_error(serror, SCRIPT_ERR_UNBALANCED_CONDITIONAL);\n                         valtype& vch = stacktop(-1);\n-                        if (sigversion == SIGVERSION_WITNESS_V0 && (flags & SCRIPT_VERIFY_MINIMALIF)) {\n+                        if (sigversion == SigVersion::WITNESS_V0 && (flags & SCRIPT_VERIFY_MINIMALIF)) {\n                             if (vch.size() > 1)\n                                 return set_error(serror, SCRIPT_ERR_MINIMALIF);\n                             if (vch.size() == 1 && vch[0] != 1)\n@@ -890,7 +890,7 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n                     CScript scriptCode(pbegincodehash, pend);\n \n                     // Drop the signature in pre-segwit scripts but not segwit scripts\n-                    if (sigversion == SIGVERSION_BASE) {\n+                    if (sigversion == SigVersion::BASE) {\n                         scriptCode.FindAndDelete(CScript(vchSig));\n                     }\n \n@@ -954,7 +954,7 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n                     for (int k = 0; k < nSigsCount; k++)\n                     {\n                         valtype& vchSig = stacktop(-isig-k);\n-                        if (sigversion == SIGVERSION_BASE) {\n+                        if (sigversion == SigVersion::BASE) {\n                             scriptCode.FindAndDelete(CScript(vchSig));\n                         }\n                     }\n@@ -1182,7 +1182,7 @@ uint256 SignatureHash(const CScript& scriptCode, const CTransaction& txTo, unsig\n {\n     assert(nIn < txTo.vin.size());\n \n-    if (sigversion == SIGVERSION_WITNESS_V0) {\n+    if (sigversion == SigVersion::WITNESS_V0) {\n         uint256 hashPrevouts;\n         uint256 hashSequence;\n         uint256 hashOutputs;\n@@ -1396,7 +1396,7 @@ static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion,\n             return set_error(serror, SCRIPT_ERR_PUSH_SIZE);\n     }\n \n-    if (!EvalScript(stack, scriptPubKey, flags, checker, SIGVERSION_WITNESS_V0, serror)) {\n+    if (!EvalScript(stack, scriptPubKey, flags, checker, SigVersion::WITNESS_V0, serror)) {\n         return false;\n     }\n \n@@ -1423,12 +1423,12 @@ bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const C\n     }\n \n     std::vector<std::vector<unsigned char> > stack, stackCopy;\n-    if (!EvalScript(stack, scriptSig, flags, checker, SIGVERSION_BASE, serror))\n+    if (!EvalScript(stack, scriptSig, flags, checker, SigVersion::BASE, serror))\n         // serror is set\n         return false;\n     if (flags & SCRIPT_VERIFY_P2SH)\n         stackCopy = stack;\n-    if (!EvalScript(stack, scriptPubKey, flags, checker, SIGVERSION_BASE, serror))\n+    if (!EvalScript(stack, scriptPubKey, flags, checker, SigVersion::BASE, serror))\n         // serror is set\n         return false;\n     if (stack.empty())\n@@ -1474,7 +1474,7 @@ bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const C\n         CScript pubKey2(pubKeySerialized.begin(), pubKeySerialized.end());\n         popstack(stack);\n \n-        if (!EvalScript(stack, pubKey2, flags, checker, SIGVERSION_BASE, serror))\n+        if (!EvalScript(stack, pubKey2, flags, checker, SigVersion::BASE, serror))\n             // serror is set\n             return false;\n         if (stack.empty())"
      },
      {
        "sha": "bb7750d78346d1ae354333997c740ed45e6409be",
        "filename": "src/script/interpreter.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1f45e2164a7674f716b425a6658c41ca7c30265b/src/script/interpreter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1f45e2164a7674f716b425a6658c41ca7c30265b/src/script/interpreter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.h?ref=1f45e2164a7674f716b425a6658c41ca7c30265b",
        "patch": "@@ -123,10 +123,10 @@ struct PrecomputedTransactionData\n     explicit PrecomputedTransactionData(const CTransaction& tx);\n };\n \n-enum SigVersion\n+enum class SigVersion\n {\n-    SIGVERSION_BASE = 0,\n-    SIGVERSION_WITNESS_V0 = 1,\n+    BASE = 0,\n+    WITNESS_V0 = 1,\n };\n \n uint256 SignatureHash(const CScript &scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType, const CAmount& amount, SigVersion sigversion, const PrecomputedTransactionData* cache = nullptr);"
      },
      {
        "sha": "05bc5e9bd692852bd2798c7400794934ee5142e6",
        "filename": "src/script/ismine.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1f45e2164a7674f716b425a6658c41ca7c30265b/src/script/ismine.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1f45e2164a7674f716b425a6658c41ca7c30265b/src/script/ismine.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/ismine.cpp?ref=1f45e2164a7674f716b425a6658c41ca7c30265b",
        "patch": "@@ -61,7 +61,7 @@ isminetype IsMine(const CKeyStore &keystore, const CScript& scriptPubKey, bool&\n         break;\n     case TX_PUBKEY:\n         keyID = CPubKey(vSolutions[0]).GetID();\n-        if (sigversion != SIGVERSION_BASE && vSolutions[0].size() != 33) {\n+        if (sigversion != SigVersion::BASE && vSolutions[0].size() != 33) {\n             isInvalid = true;\n             return ISMINE_NO;\n         }\n@@ -76,14 +76,14 @@ isminetype IsMine(const CKeyStore &keystore, const CScript& scriptPubKey, bool&\n             // This also applies to the P2WSH case.\n             break;\n         }\n-        isminetype ret = ::IsMine(keystore, GetScriptForDestination(CKeyID(uint160(vSolutions[0]))), isInvalid, SIGVERSION_WITNESS_V0);\n+        isminetype ret = ::IsMine(keystore, GetScriptForDestination(CKeyID(uint160(vSolutions[0]))), isInvalid, SigVersion::WITNESS_V0);\n         if (ret == ISMINE_SPENDABLE || ret == ISMINE_WATCH_SOLVABLE || (ret == ISMINE_NO && isInvalid))\n             return ret;\n         break;\n     }\n     case TX_PUBKEYHASH:\n         keyID = CKeyID(uint160(vSolutions[0]));\n-        if (sigversion != SIGVERSION_BASE) {\n+        if (sigversion != SigVersion::BASE) {\n             CPubKey pubkey;\n             if (keystore.GetPubKey(keyID, pubkey) && !pubkey.IsCompressed()) {\n                 isInvalid = true;\n@@ -114,7 +114,7 @@ isminetype IsMine(const CKeyStore &keystore, const CScript& scriptPubKey, bool&\n         CScriptID scriptID = CScriptID(hash);\n         CScript subscript;\n         if (keystore.GetCScript(scriptID, subscript)) {\n-            isminetype ret = IsMine(keystore, subscript, isInvalid, SIGVERSION_WITNESS_V0);\n+            isminetype ret = IsMine(keystore, subscript, isInvalid, SigVersion::WITNESS_V0);\n             if (ret == ISMINE_SPENDABLE || ret == ISMINE_WATCH_SOLVABLE || (ret == ISMINE_NO && isInvalid))\n                 return ret;\n         }\n@@ -129,7 +129,7 @@ isminetype IsMine(const CKeyStore &keystore, const CScript& scriptPubKey, bool&\n         // them) enable spend-out-from-under-you attacks, especially\n         // in shared-wallet situations.\n         std::vector<valtype> keys(vSolutions.begin()+1, vSolutions.begin()+vSolutions.size()-1);\n-        if (sigversion != SIGVERSION_BASE) {\n+        if (sigversion != SigVersion::BASE) {\n             for (size_t i = 0; i < keys.size(); i++) {\n                 if (keys[i].size() != 33) {\n                     isInvalid = true;"
      },
      {
        "sha": "f93a66e35aa8fd3a8210a9fe3fcf79721697bf3c",
        "filename": "src/script/ismine.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1f45e2164a7674f716b425a6658c41ca7c30265b/src/script/ismine.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1f45e2164a7674f716b425a6658c41ca7c30265b/src/script/ismine.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/ismine.h?ref=1f45e2164a7674f716b425a6658c41ca7c30265b",
        "patch": "@@ -31,11 +31,11 @@ typedef uint8_t isminefilter;\n /* isInvalid becomes true when the script is found invalid by consensus or policy. This will terminate the recursion\n  * and return ISMINE_NO immediately, as an invalid script should never be considered as \"mine\". This is needed as\n  * different SIGVERSION may have different network rules. Currently the only use of isInvalid is indicate uncompressed\n- * keys in SIGVERSION_WITNESS_V0 script, but could also be used in similar cases in the future\n+ * keys in SigVersion::WITNESS_V0 script, but could also be used in similar cases in the future\n  */\n-isminetype IsMine(const CKeyStore& keystore, const CScript& scriptPubKey, bool& isInvalid, SigVersion = SIGVERSION_BASE);\n-isminetype IsMine(const CKeyStore& keystore, const CScript& scriptPubKey, SigVersion = SIGVERSION_BASE);\n-isminetype IsMine(const CKeyStore& keystore, const CTxDestination& dest, bool& isInvalid, SigVersion = SIGVERSION_BASE);\n-isminetype IsMine(const CKeyStore& keystore, const CTxDestination& dest, SigVersion = SIGVERSION_BASE);\n+isminetype IsMine(const CKeyStore& keystore, const CScript& scriptPubKey, bool& isInvalid, SigVersion = SigVersion::BASE);\n+isminetype IsMine(const CKeyStore& keystore, const CScript& scriptPubKey, SigVersion = SigVersion::BASE);\n+isminetype IsMine(const CKeyStore& keystore, const CTxDestination& dest, bool& isInvalid, SigVersion = SigVersion::BASE);\n+isminetype IsMine(const CKeyStore& keystore, const CTxDestination& dest, SigVersion = SigVersion::BASE);\n \n #endif // BITCOIN_SCRIPT_ISMINE_H"
      },
      {
        "sha": "5c73ba0d2a42221f716e7858eddc5f5025d9d41d",
        "filename": "src/script/sign.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1f45e2164a7674f716b425a6658c41ca7c30265b/src/script/sign.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1f45e2164a7674f716b425a6658c41ca7c30265b/src/script/sign.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.cpp?ref=1f45e2164a7674f716b425a6658c41ca7c30265b",
        "patch": "@@ -24,7 +24,7 @@ bool TransactionSignatureCreator::CreateSig(std::vector<unsigned char>& vchSig,\n         return false;\n \n     // Signing with uncompressed keys is disabled in witness scripts\n-    if (sigversion == SIGVERSION_WITNESS_V0 && !key.IsCompressed())\n+    if (sigversion == SigVersion::WITNESS_V0 && !key.IsCompressed())\n         return false;\n \n     uint256 hash = SignatureHash(scriptCode, *txTo, nIn, nHashType, amount, sigversion);\n@@ -142,7 +142,7 @@ bool ProduceSignature(const BaseSignatureCreator& creator, const CScript& fromPu\n {\n     std::vector<valtype> result;\n     txnouttype whichType;\n-    bool solved = SignStep(creator, fromPubKey, result, whichType, SIGVERSION_BASE);\n+    bool solved = SignStep(creator, fromPubKey, result, whichType, SigVersion::BASE);\n     bool P2SH = false;\n     CScript subscript;\n     sigdata.scriptWitness.stack.clear();\n@@ -153,7 +153,7 @@ bool ProduceSignature(const BaseSignatureCreator& creator, const CScript& fromPu\n         // the final scriptSig is the signatures from that\n         // and then the serialized subscript:\n         subscript = CScript(result[0].begin(), result[0].end());\n-        solved = solved && SignStep(creator, subscript, result, whichType, SIGVERSION_BASE) && whichType != TX_SCRIPTHASH;\n+        solved = solved && SignStep(creator, subscript, result, whichType, SigVersion::BASE) && whichType != TX_SCRIPTHASH;\n         P2SH = true;\n     }\n \n@@ -162,15 +162,15 @@ bool ProduceSignature(const BaseSignatureCreator& creator, const CScript& fromPu\n         CScript witnessscript;\n         witnessscript << OP_DUP << OP_HASH160 << ToByteVector(result[0]) << OP_EQUALVERIFY << OP_CHECKSIG;\n         txnouttype subType;\n-        solved = solved && SignStep(creator, witnessscript, result, subType, SIGVERSION_WITNESS_V0);\n+        solved = solved && SignStep(creator, witnessscript, result, subType, SigVersion::WITNESS_V0);\n         sigdata.scriptWitness.stack = result;\n         result.clear();\n     }\n     else if (solved && whichType == TX_WITNESS_V0_SCRIPTHASH)\n     {\n         CScript witnessscript(result[0].begin(), result[0].end());\n         txnouttype subType;\n-        solved = solved && SignStep(creator, witnessscript, result, subType, SIGVERSION_WITNESS_V0) && subType != TX_SCRIPTHASH && subType != TX_WITNESS_V0_SCRIPTHASH && subType != TX_WITNESS_V0_KEYHASH;\n+        solved = solved && SignStep(creator, witnessscript, result, subType, SigVersion::WITNESS_V0) && subType != TX_SCRIPTHASH && subType != TX_WITNESS_V0_SCRIPTHASH && subType != TX_WITNESS_V0_KEYHASH;\n         result.push_back(std::vector<unsigned char>(witnessscript.begin(), witnessscript.end()));\n         sigdata.scriptWitness.stack = result;\n         result.clear();\n@@ -289,7 +289,7 @@ struct Stacks\n     Stacks() {}\n     explicit Stacks(const std::vector<valtype>& scriptSigStack_) : script(scriptSigStack_), witness() {}\n     explicit Stacks(const SignatureData& data) : witness(data.scriptWitness.stack) {\n-        EvalScript(script, data.scriptSig, SCRIPT_VERIFY_STRICTENC, BaseSignatureChecker(), SIGVERSION_BASE);\n+        EvalScript(script, data.scriptSig, SCRIPT_VERIFY_STRICTENC, BaseSignatureChecker(), SigVersion::BASE);\n     }\n \n     SignatureData Output() const {\n@@ -365,7 +365,7 @@ static Stacks CombineSignatures(const CScript& scriptPubKey, const BaseSignature\n             sigs2.witness.pop_back();\n             sigs2.script = sigs2.witness;\n             sigs2.witness.clear();\n-            Stacks result = CombineSignatures(pubKey2, checker, txType2, vSolutions2, sigs1, sigs2, SIGVERSION_WITNESS_V0);\n+            Stacks result = CombineSignatures(pubKey2, checker, txType2, vSolutions2, sigs1, sigs2, SigVersion::WITNESS_V0);\n             result.witness = result.script;\n             result.script.clear();\n             result.witness.push_back(valtype(pubKey2.begin(), pubKey2.end()));\n@@ -383,7 +383,7 @@ SignatureData CombineSignatures(const CScript& scriptPubKey, const BaseSignature\n     std::vector<std::vector<unsigned char> > vSolutions;\n     Solver(scriptPubKey, txType, vSolutions);\n \n-    return CombineSignatures(scriptPubKey, checker, txType, vSolutions, Stacks(scriptSig1), Stacks(scriptSig2), SIGVERSION_BASE).Output();\n+    return CombineSignatures(scriptPubKey, checker, txType, vSolutions, Stacks(scriptSig1), Stacks(scriptSig2), SigVersion::BASE).Output();\n }\n \n namespace {"
      },
      {
        "sha": "abb46fe533b776ce61232cd040f2d87a370810b9",
        "filename": "src/test/data/tx_invalid.json",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1f45e2164a7674f716b425a6658c41ca7c30265b/src/test/data/tx_invalid.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1f45e2164a7674f716b425a6658c41ca7c30265b/src/test/data/tx_invalid.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/data/tx_invalid.json?ref=1f45e2164a7674f716b425a6658c41ca7c30265b",
        "patch": "@@ -321,7 +321,7 @@\n [\"where the pubkey is obtained through key recovery with sig and the wrong sighash.\"],\n [\"This is to show that FindAndDelete is applied only to non-segwit scripts\"],\n [\"To show that the tests are 'correctly wrong', they should pass by modifying OP_CHECKSIG under interpreter.cpp\"],\n-[\"by replacing (sigversion == SIGVERSION_BASE) with (sigversion != SIGVERSION_BASE)\"],\n+[\"by replacing (sigversion == SigVersion::BASE) with (sigversion != SigVersion::BASE)\"],\n [\"Non-segwit: wrong sighash (without FindAndDelete) = 1ba1fe3bc90c5d1265460e684ce6774e324f0fabdf67619eda729e64e8b6bc08\"],\n [[[\"f18783ace138abac5d3a7a5cf08e88fe6912f267ef936452e0c27d090621c169\", 7000, \"HASH160 0x14 0x0c746489e2d83cdbb5b90b432773342ba809c134 EQUAL\", 200000]],\n \"010000000169c12106097dc2e0526493ef67f21269fe888ef05c7a3a5dacab38e1ac8387f1581b0000b64830450220487fb382c4974de3f7d834c1b617fe15860828c7f96454490edd6d891556dcc9022100baf95feb48f845d5bfc9882eb6aeefa1bc3790e39f59eaa46ff7f15ae626c53e012103b12a1ec8428fc74166926318c15e17408fea82dbb157575e16a8c365f546248f4aad4830450220487fb382c4974de3f7d834c1b617fe15860828c7f96454490edd6d891556dcc9022100baf95feb48f845d5bfc9882eb6aeefa1bc3790e39f59eaa46ff7f15ae626c53e01ffffffff0101000000000000000000000000\", \"P2SH,WITNESS\"],\n@@ -332,7 +332,7 @@\n [\"Script is 2 CHECKMULTISIGVERIFY <sig1> <sig2> DROP\"],\n [\"52af4830450220487fb382c4974de3f7d834c1b617fe15860828c7f96454490edd6d891556dcc9022100baf95feb48f845d5bfc9882eb6aeefa1bc3790e39f59eaa46ff7f15ae626c53e0148304502205286f726690b2e9b0207f0345711e63fa7012045b9eb0f19c2458ce1db90cf43022100e89f17f86abc5b149eba4115d4f128bcf45d77fb3ecdd34f594091340c0395960175\"],\n [\"Signature is 0 <sig1> <sig2> 2 <key1> <key2>\"],\n-[\"Should pass by replacing (sigversion == SIGVERSION_BASE) with (sigversion != SIGVERSION_BASE) under OP_CHECKMULTISIG\"],\n+[\"Should pass by replacing (sigversion == SigVersion::BASE) with (sigversion != SigVersion::BASE) under OP_CHECKMULTISIG\"],\n [\"Non-segwit: wrong sighash (without FindAndDelete) = 4bc6a53e8e16ef508c19e38bba08831daba85228b0211f323d4cb0999cf2a5e8\"],\n [[[\"9628667ad48219a169b41b020800162287d2c0f713c04157e95c484a8dcb7592\", 7000, \"HASH160 0x14 0x5748407f5ca5cdca53ba30b79040260770c9ee1b EQUAL\", 200000]],\n \"01000000019275cb8d4a485ce95741c013f7c0d28722160008021bb469a11982d47a662896581b0000fd6f01004830450220487fb382c4974de3f7d834c1b617fe15860828c7f96454490edd6d891556dcc9022100baf95feb48f845d5bfc9882eb6aeefa1bc3790e39f59eaa46ff7f15ae626c53e0148304502205286f726690b2e9b0207f0345711e63fa7012045b9eb0f19c2458ce1db90cf43022100e89f17f86abc5b149eba4115d4f128bcf45d77fb3ecdd34f594091340c039596015221023fd5dd42b44769c5653cbc5947ff30ab8871f240ad0c0e7432aefe84b5b4ff3421039d52178dbde360b83f19cf348deb04fa8360e1bf5634577be8e50fafc2b0e4ef4c9552af4830450220487fb382c4974de3f7d834c1b617fe15860828c7f96454490edd6d891556dcc9022100baf95feb48f845d5bfc9882eb6aeefa1bc3790e39f59eaa46ff7f15ae626c53e0148304502205286f726690b2e9b0207f0345711e63fa7012045b9eb0f19c2458ce1db90cf43022100e89f17f86abc5b149eba4115d4f128bcf45d77fb3ecdd34f594091340c0395960175ffffffff0101000000000000000000000000\", \"P2SH,WITNESS\"],"
      },
      {
        "sha": "b593f9633ce945cac1087265fc98384010405fd8",
        "filename": "src/test/multisig_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1f45e2164a7674f716b425a6658c41ca7c30265b/src/test/multisig_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1f45e2164a7674f716b425a6658c41ca7c30265b/src/test/multisig_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/multisig_tests.cpp?ref=1f45e2164a7674f716b425a6658c41ca7c30265b",
        "patch": "@@ -21,7 +21,7 @@ BOOST_FIXTURE_TEST_SUITE(multisig_tests, BasicTestingSetup)\n CScript\n sign_multisig(CScript scriptPubKey, std::vector<CKey> keys, CTransaction transaction, int whichIn)\n {\n-    uint256 hash = SignatureHash(scriptPubKey, transaction, whichIn, SIGHASH_ALL, 0, SIGVERSION_BASE);\n+    uint256 hash = SignatureHash(scriptPubKey, transaction, whichIn, SIGHASH_ALL, 0, SigVersion::BASE);\n \n     CScript result;\n     result << OP_0; // CHECKMULTISIG bug workaround"
      },
      {
        "sha": "46a2d13745019556e48e6d7729aec4f4730c4979",
        "filename": "src/test/script_tests.cpp",
        "status": "modified",
        "additions": 67,
        "deletions": 67,
        "changes": 134,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1f45e2164a7674f716b425a6658c41ca7c30265b/src/test/script_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1f45e2164a7674f716b425a6658c41ca7c30265b/src/test/script_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_tests.cpp?ref=1f45e2164a7674f716b425a6658c41ca7c30265b",
        "patch": "@@ -267,10 +267,10 @@ struct KeyData\n     }\n };\n \n-enum WitnessMode {\n-    WITNESS_NONE,\n-    WITNESS_PKH,\n-    WITNESS_SH\n+enum class WitnessMode {\n+    NONE,\n+    PKH,\n+    SH\n };\n \n class TestBuilder\n@@ -308,15 +308,15 @@ class TestBuilder\n     }\n \n public:\n-    TestBuilder(const CScript& script_, const std::string& comment_, int flags_, bool P2SH = false, WitnessMode wm = WITNESS_NONE, int witnessversion = 0, CAmount nValue_ = 0) : script(script_), havePush(false), comment(comment_), flags(flags_), scriptError(SCRIPT_ERR_OK), nValue(nValue_)\n+    TestBuilder(const CScript& script_, const std::string& comment_, int flags_, bool P2SH = false, WitnessMode wm = WitnessMode::NONE, int witnessversion = 0, CAmount nValue_ = 0) : script(script_), havePush(false), comment(comment_), flags(flags_), scriptError(SCRIPT_ERR_OK), nValue(nValue_)\n     {\n         CScript scriptPubKey = script;\n-        if (wm == WITNESS_PKH) {\n+        if (wm == WitnessMode::PKH) {\n             uint160 hash;\n             CHash160().Write(&script[1], script.size() - 1).Finalize(hash.begin());\n             script = CScript() << OP_DUP << OP_HASH160 << ToByteVector(hash) << OP_EQUALVERIFY << OP_CHECKSIG;\n             scriptPubKey = CScript() << witnessversion << ToByteVector(hash);\n-        } else if (wm == WITNESS_SH) {\n+        } else if (wm == WitnessMode::SH) {\n             witscript = scriptPubKey;\n             uint256 hash;\n             CSHA256().Write(&witscript[0], witscript.size()).Finalize(hash.begin());\n@@ -361,7 +361,7 @@ class TestBuilder\n         return *this;\n     }\n \n-    TestBuilder& PushSig(const CKey& key, int nHashType = SIGHASH_ALL, unsigned int lenR = 32, unsigned int lenS = 32, SigVersion sigversion = SIGVERSION_BASE, CAmount amount = 0)\n+    TestBuilder& PushSig(const CKey& key, int nHashType = SIGHASH_ALL, unsigned int lenR = 32, unsigned int lenS = 32, SigVersion sigversion = SigVersion::BASE, CAmount amount = 0)\n     {\n         uint256 hash = SignatureHash(script, spendTx, 0, nHashType, amount, sigversion);\n         std::vector<unsigned char> vchSig, r, s;\n@@ -379,7 +379,7 @@ class TestBuilder\n         return *this;\n     }\n \n-    TestBuilder& PushWitSig(const CKey& key, CAmount amount = -1, int nHashType = SIGHASH_ALL, unsigned int lenR = 32, unsigned int lenS = 32, SigVersion sigversion = SIGVERSION_WITNESS_V0)\n+    TestBuilder& PushWitSig(const CKey& key, CAmount amount = -1, int nHashType = SIGHASH_ALL, unsigned int lenR = 32, unsigned int lenS = 32, SigVersion sigversion = SigVersion::WITNESS_V0)\n     {\n         if (amount == -1)\n             amount = nValue;\n@@ -747,57 +747,57 @@ BOOST_AUTO_TEST_CASE(script_build)\n                                ).PushSig(keys.key0).PushRedeem());\n \n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0) << OP_CHECKSIG,\n-                                \"Basic P2WSH\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_SH,\n+                                \"Basic P2WSH\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WitnessMode::SH,\n                                 0, 1).PushWitSig(keys.key0).PushWitRedeem());\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0),\n-                                \"Basic P2WPKH\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_PKH,\n+                                \"Basic P2WPKH\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WitnessMode::PKH,\n                                 0, 1).PushWitSig(keys.key0).Push(keys.pubkey0).AsWit());\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0) << OP_CHECKSIG,\n-                                \"Basic P2SH(P2WSH)\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WITNESS_SH,\n+                                \"Basic P2SH(P2WSH)\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WitnessMode::SH,\n                                 0, 1).PushWitSig(keys.key0).PushWitRedeem().PushRedeem());\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0),\n-                                \"Basic P2SH(P2WPKH)\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WITNESS_PKH,\n+                                \"Basic P2SH(P2WPKH)\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WitnessMode::PKH,\n                                 0, 1).PushWitSig(keys.key0).Push(keys.pubkey0).AsWit().PushRedeem());\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1) << OP_CHECKSIG,\n-                                \"Basic P2WSH with the wrong key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_SH\n+                                \"Basic P2WSH with the wrong key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WitnessMode::SH\n                                ).PushWitSig(keys.key0).PushWitRedeem().ScriptError(SCRIPT_ERR_EVAL_FALSE));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1),\n-                                \"Basic P2WPKH with the wrong key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_PKH\n+                                \"Basic P2WPKH with the wrong key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WitnessMode::PKH\n                                ).PushWitSig(keys.key0).Push(keys.pubkey1).AsWit().ScriptError(SCRIPT_ERR_EVAL_FALSE));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1) << OP_CHECKSIG,\n-                                \"Basic P2SH(P2WSH) with the wrong key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WITNESS_SH\n+                                \"Basic P2SH(P2WSH) with the wrong key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WitnessMode::SH\n                                ).PushWitSig(keys.key0).PushWitRedeem().PushRedeem().ScriptError(SCRIPT_ERR_EVAL_FALSE));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1),\n-                                \"Basic P2SH(P2WPKH) with the wrong key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WITNESS_PKH\n+                                \"Basic P2SH(P2WPKH) with the wrong key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WitnessMode::PKH\n                                ).PushWitSig(keys.key0).Push(keys.pubkey1).AsWit().PushRedeem().ScriptError(SCRIPT_ERR_EVAL_FALSE));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1) << OP_CHECKSIG,\n-                                \"Basic P2WSH with the wrong key but no WITNESS\", SCRIPT_VERIFY_P2SH, false, WITNESS_SH\n+                                \"Basic P2WSH with the wrong key but no WITNESS\", SCRIPT_VERIFY_P2SH, false, WitnessMode::SH\n                                ).PushWitSig(keys.key0).PushWitRedeem());\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1),\n-                                \"Basic P2WPKH with the wrong key but no WITNESS\", SCRIPT_VERIFY_P2SH, false, WITNESS_PKH\n+                                \"Basic P2WPKH with the wrong key but no WITNESS\", SCRIPT_VERIFY_P2SH, false, WitnessMode::PKH\n                                ).PushWitSig(keys.key0).Push(keys.pubkey1).AsWit());\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1) << OP_CHECKSIG,\n-                                \"Basic P2SH(P2WSH) with the wrong key but no WITNESS\", SCRIPT_VERIFY_P2SH, true, WITNESS_SH\n+                                \"Basic P2SH(P2WSH) with the wrong key but no WITNESS\", SCRIPT_VERIFY_P2SH, true, WitnessMode::SH\n                                ).PushWitSig(keys.key0).PushWitRedeem().PushRedeem());\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1),\n-                                \"Basic P2SH(P2WPKH) with the wrong key but no WITNESS\", SCRIPT_VERIFY_P2SH, true, WITNESS_PKH\n+                                \"Basic P2SH(P2WPKH) with the wrong key but no WITNESS\", SCRIPT_VERIFY_P2SH, true, WitnessMode::PKH\n                                ).PushWitSig(keys.key0).Push(keys.pubkey1).AsWit().PushRedeem());\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0) << OP_CHECKSIG,\n-                                \"Basic P2WSH with wrong value\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_SH,\n+                                \"Basic P2WSH with wrong value\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WitnessMode::SH,\n                                 0, 0).PushWitSig(keys.key0, 1).PushWitRedeem().ScriptError(SCRIPT_ERR_EVAL_FALSE));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0),\n-                                \"Basic P2WPKH with wrong value\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_PKH,\n+                                \"Basic P2WPKH with wrong value\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WitnessMode::PKH,\n                                 0, 0).PushWitSig(keys.key0, 1).Push(keys.pubkey0).AsWit().ScriptError(SCRIPT_ERR_EVAL_FALSE));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0) << OP_CHECKSIG,\n-                                \"Basic P2SH(P2WSH) with wrong value\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WITNESS_SH,\n+                                \"Basic P2SH(P2WSH) with wrong value\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WitnessMode::SH,\n                                 0, 0).PushWitSig(keys.key0, 1).PushWitRedeem().PushRedeem().ScriptError(SCRIPT_ERR_EVAL_FALSE));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0),\n-                                \"Basic P2SH(P2WPKH) with wrong value\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WITNESS_PKH,\n+                                \"Basic P2SH(P2WPKH) with wrong value\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WitnessMode::PKH,\n                                 0, 0).PushWitSig(keys.key0, 1).Push(keys.pubkey0).AsWit().PushRedeem().ScriptError(SCRIPT_ERR_EVAL_FALSE));\n \n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0),\n                                 \"P2WPKH with future witness version\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH |\n-                                SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM, false, WITNESS_PKH, 1\n+                                SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM, false, WitnessMode::PKH, 1\n                                ).PushWitSig(keys.key0).Push(keys.pubkey0).AsWit().ScriptError(SCRIPT_ERR_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM));\n     {\n         CScript witscript = CScript() << ToByteVector(keys.pubkey0);\n@@ -810,118 +810,118 @@ BOOST_AUTO_TEST_CASE(script_build)\n                                    ).PushWitSig(keys.key0).Push(keys.pubkey0).AsWit().ScriptError(SCRIPT_ERR_WITNESS_PROGRAM_WRONG_LENGTH));\n     }\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0) << OP_CHECKSIG,\n-                                \"P2WSH with empty witness\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_SH\n+                                \"P2WSH with empty witness\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WitnessMode::SH\n                                ).ScriptError(SCRIPT_ERR_WITNESS_PROGRAM_WITNESS_EMPTY));\n     {\n         CScript witscript = CScript() << ToByteVector(keys.pubkey0) << OP_CHECKSIG;\n         tests.push_back(TestBuilder(witscript,\n-                                    \"P2WSH with witness program mismatch\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_SH\n+                                    \"P2WSH with witness program mismatch\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WitnessMode::SH\n                                    ).PushWitSig(keys.key0).Push(witscript).DamagePush(0).AsWit().ScriptError(SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH));\n     }\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0),\n-                                \"P2WPKH with witness program mismatch\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_PKH\n+                                \"P2WPKH with witness program mismatch\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WitnessMode::PKH\n                                ).PushWitSig(keys.key0).Push(keys.pubkey0).AsWit().Push(\"0\").AsWit().ScriptError(SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0),\n-                                \"P2WPKH with non-empty scriptSig\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_PKH\n+                                \"P2WPKH with non-empty scriptSig\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WitnessMode::PKH\n                                ).PushWitSig(keys.key0).Push(keys.pubkey0).AsWit().Num(11).ScriptError(SCRIPT_ERR_WITNESS_MALLEATED));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1),\n-                                \"P2SH(P2WPKH) with superfluous push in scriptSig\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WITNESS_PKH\n+                                \"P2SH(P2WPKH) with superfluous push in scriptSig\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WitnessMode::PKH\n                                ).PushWitSig(keys.key0).Push(keys.pubkey1).AsWit().Num(11).PushRedeem().ScriptError(SCRIPT_ERR_WITNESS_MALLEATED_P2SH));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0) << OP_CHECKSIG,\n                                 \"P2PK with witness\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH\n                                ).PushSig(keys.key0).Push(\"0\").AsWit().ScriptError(SCRIPT_ERR_WITNESS_UNEXPECTED));\n \n     // Compressed keys should pass SCRIPT_VERIFY_WITNESS_PUBKEYTYPE\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0C) << OP_CHECKSIG,\n-                                \"Basic P2WSH with compressed key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WITNESS_SH,\n+                                \"Basic P2WSH with compressed key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WitnessMode::SH,\n                                 0, 1).PushWitSig(keys.key0C).PushWitRedeem());\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0C),\n-                                \"Basic P2WPKH with compressed key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WITNESS_PKH,\n+                                \"Basic P2WPKH with compressed key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WitnessMode::PKH,\n                                 0, 1).PushWitSig(keys.key0C).Push(keys.pubkey0C).AsWit());\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0C) << OP_CHECKSIG,\n-                                \"Basic P2SH(P2WSH) with compressed key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WITNESS_SH,\n+                                \"Basic P2SH(P2WSH) with compressed key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WitnessMode::SH,\n                                 0, 1).PushWitSig(keys.key0C).PushWitRedeem().PushRedeem());\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0C),\n-                                \"Basic P2SH(P2WPKH) with compressed key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WITNESS_PKH,\n+                                \"Basic P2SH(P2WPKH) with compressed key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WitnessMode::PKH,\n                                 0, 1).PushWitSig(keys.key0C).Push(keys.pubkey0C).AsWit().PushRedeem());\n \n     // Testing uncompressed key in witness with SCRIPT_VERIFY_WITNESS_PUBKEYTYPE\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0) << OP_CHECKSIG,\n-                                \"Basic P2WSH\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WITNESS_SH,\n+                                \"Basic P2WSH\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WitnessMode::SH,\n                                 0, 1).PushWitSig(keys.key0).PushWitRedeem().ScriptError(SCRIPT_ERR_WITNESS_PUBKEYTYPE));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0),\n-                                \"Basic P2WPKH\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WITNESS_PKH,\n+                                \"Basic P2WPKH\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WitnessMode::PKH,\n                                 0, 1).PushWitSig(keys.key0).Push(keys.pubkey0).AsWit().ScriptError(SCRIPT_ERR_WITNESS_PUBKEYTYPE));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0) << OP_CHECKSIG,\n-                                \"Basic P2SH(P2WSH)\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WITNESS_SH,\n+                                \"Basic P2SH(P2WSH)\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WitnessMode::SH,\n                                 0, 1).PushWitSig(keys.key0).PushWitRedeem().PushRedeem().ScriptError(SCRIPT_ERR_WITNESS_PUBKEYTYPE));\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0),\n-                                \"Basic P2SH(P2WPKH)\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WITNESS_PKH,\n+                                \"Basic P2SH(P2WPKH)\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WitnessMode::PKH,\n                                 0, 1).PushWitSig(keys.key0).Push(keys.pubkey0).AsWit().PushRedeem().ScriptError(SCRIPT_ERR_WITNESS_PUBKEYTYPE));\n \n     // P2WSH 1-of-2 multisig with compressed keys\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2WSH CHECKMULTISIG with compressed keys\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WITNESS_SH,\n+                                \"P2WSH CHECKMULTISIG with compressed keys\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key0C).PushWitRedeem());\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2SH(P2WSH) CHECKMULTISIG with compressed keys\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WITNESS_SH,\n+                                \"P2SH(P2WSH) CHECKMULTISIG with compressed keys\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key0C).PushWitRedeem().PushRedeem());\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2WSH CHECKMULTISIG with compressed keys\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WITNESS_SH,\n+                                \"P2WSH CHECKMULTISIG with compressed keys\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key1C).PushWitRedeem());\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2SH(P2WSH) CHECKMULTISIG with compressed keys\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WITNESS_SH,\n+                                \"P2SH(P2WSH) CHECKMULTISIG with compressed keys\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key1C).PushWitRedeem().PushRedeem());\n \n     // P2WSH 1-of-2 multisig with first key uncompressed\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2WSH CHECKMULTISIG with first key uncompressed and signing with the first key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_SH,\n+                                \"P2WSH CHECKMULTISIG with first key uncompressed and signing with the first key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key0).PushWitRedeem());\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2SH(P2WSH) CHECKMULTISIG first key uncompressed and signing with the first key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WITNESS_SH,\n+                                \"P2SH(P2WSH) CHECKMULTISIG first key uncompressed and signing with the first key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key0).PushWitRedeem().PushRedeem());\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2WSH CHECKMULTISIG with first key uncompressed and signing with the first key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WITNESS_SH,\n+                                \"P2WSH CHECKMULTISIG with first key uncompressed and signing with the first key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key0).PushWitRedeem().ScriptError(SCRIPT_ERR_WITNESS_PUBKEYTYPE));\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2SH(P2WSH) CHECKMULTISIG with first key uncompressed and signing with the first key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WITNESS_SH,\n+                                \"P2SH(P2WSH) CHECKMULTISIG with first key uncompressed and signing with the first key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key0).PushWitRedeem().PushRedeem().ScriptError(SCRIPT_ERR_WITNESS_PUBKEYTYPE));\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2WSH CHECKMULTISIG with first key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_SH,\n+                                \"P2WSH CHECKMULTISIG with first key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key1C).PushWitRedeem());\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2SH(P2WSH) CHECKMULTISIG with first key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WITNESS_SH,\n+                                \"P2SH(P2WSH) CHECKMULTISIG with first key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key1C).PushWitRedeem().PushRedeem());\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2WSH CHECKMULTISIG with first key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WITNESS_SH,\n+                                \"P2WSH CHECKMULTISIG with first key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key1C).PushWitRedeem().ScriptError(SCRIPT_ERR_WITNESS_PUBKEYTYPE));\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2SH(P2WSH) CHECKMULTISIG with first key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WITNESS_SH,\n+                                \"P2SH(P2WSH) CHECKMULTISIG with first key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key1C).PushWitRedeem().PushRedeem().ScriptError(SCRIPT_ERR_WITNESS_PUBKEYTYPE));\n     // P2WSH 1-of-2 multisig with second key uncompressed\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2WSH CHECKMULTISIG with second key uncompressed and signing with the first key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_SH,\n+                                \"P2WSH CHECKMULTISIG with second key uncompressed and signing with the first key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key0C).PushWitRedeem());\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2SH(P2WSH) CHECKMULTISIG second key uncompressed and signing with the first key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WITNESS_SH,\n+                                \"P2SH(P2WSH) CHECKMULTISIG second key uncompressed and signing with the first key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key0C).PushWitRedeem().PushRedeem());\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2WSH CHECKMULTISIG with second key uncompressed and signing with the first key should pass as the uncompressed key is not used\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WITNESS_SH,\n+                                \"P2WSH CHECKMULTISIG with second key uncompressed and signing with the first key should pass as the uncompressed key is not used\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key0C).PushWitRedeem());\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2SH(P2WSH) CHECKMULTISIG with second key uncompressed and signing with the first key should pass as the uncompressed key is not used\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WITNESS_SH,\n+                                \"P2SH(P2WSH) CHECKMULTISIG with second key uncompressed and signing with the first key should pass as the uncompressed key is not used\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key0C).PushWitRedeem().PushRedeem());\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2WSH CHECKMULTISIG with second key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_SH,\n+                                \"P2WSH CHECKMULTISIG with second key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key1).PushWitRedeem());\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2SH(P2WSH) CHECKMULTISIG with second key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WITNESS_SH,\n+                                \"P2SH(P2WSH) CHECKMULTISIG with second key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key1).PushWitRedeem().PushRedeem());\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2WSH CHECKMULTISIG with second key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WITNESS_SH,\n+                                \"P2WSH CHECKMULTISIG with second key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key1).PushWitRedeem().ScriptError(SCRIPT_ERR_WITNESS_PUBKEYTYPE));\n     tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n-                                \"P2SH(P2WSH) CHECKMULTISIG with second key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WITNESS_SH,\n+                                \"P2SH(P2WSH) CHECKMULTISIG with second key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WitnessMode::SH,\n                                 0, 1).Push(CScript()).AsWit().PushWitSig(keys.key1).PushWitRedeem().PushRedeem().ScriptError(SCRIPT_ERR_WITNESS_PUBKEYTYPE));\n \n     std::set<std::string> tests_set;\n@@ -1009,29 +1009,29 @@ BOOST_AUTO_TEST_CASE(script_PushData)\n \n     ScriptError err;\n     std::vector<std::vector<unsigned char> > directStack;\n-    BOOST_CHECK(EvalScript(directStack, CScript(&direct[0], &direct[sizeof(direct)]), SCRIPT_VERIFY_P2SH, BaseSignatureChecker(), SIGVERSION_BASE, &err));\n+    BOOST_CHECK(EvalScript(directStack, CScript(&direct[0], &direct[sizeof(direct)]), SCRIPT_VERIFY_P2SH, BaseSignatureChecker(), SigVersion::BASE, &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n \n     std::vector<std::vector<unsigned char> > pushdata1Stack;\n-    BOOST_CHECK(EvalScript(pushdata1Stack, CScript(&pushdata1[0], &pushdata1[sizeof(pushdata1)]), SCRIPT_VERIFY_P2SH, BaseSignatureChecker(), SIGVERSION_BASE, &err));\n+    BOOST_CHECK(EvalScript(pushdata1Stack, CScript(&pushdata1[0], &pushdata1[sizeof(pushdata1)]), SCRIPT_VERIFY_P2SH, BaseSignatureChecker(), SigVersion::BASE, &err));\n     BOOST_CHECK(pushdata1Stack == directStack);\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n \n     std::vector<std::vector<unsigned char> > pushdata2Stack;\n-    BOOST_CHECK(EvalScript(pushdata2Stack, CScript(&pushdata2[0], &pushdata2[sizeof(pushdata2)]), SCRIPT_VERIFY_P2SH, BaseSignatureChecker(), SIGVERSION_BASE, &err));\n+    BOOST_CHECK(EvalScript(pushdata2Stack, CScript(&pushdata2[0], &pushdata2[sizeof(pushdata2)]), SCRIPT_VERIFY_P2SH, BaseSignatureChecker(), SigVersion::BASE, &err));\n     BOOST_CHECK(pushdata2Stack == directStack);\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n \n     std::vector<std::vector<unsigned char> > pushdata4Stack;\n-    BOOST_CHECK(EvalScript(pushdata4Stack, CScript(&pushdata4[0], &pushdata4[sizeof(pushdata4)]), SCRIPT_VERIFY_P2SH, BaseSignatureChecker(), SIGVERSION_BASE, &err));\n+    BOOST_CHECK(EvalScript(pushdata4Stack, CScript(&pushdata4[0], &pushdata4[sizeof(pushdata4)]), SCRIPT_VERIFY_P2SH, BaseSignatureChecker(), SigVersion::BASE, &err));\n     BOOST_CHECK(pushdata4Stack == directStack);\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n }\n \n CScript\n sign_multisig(CScript scriptPubKey, std::vector<CKey> keys, CTransaction transaction)\n {\n-    uint256 hash = SignatureHash(scriptPubKey, transaction, 0, SIGHASH_ALL, 0, SIGVERSION_BASE);\n+    uint256 hash = SignatureHash(scriptPubKey, transaction, 0, SIGHASH_ALL, 0, SigVersion::BASE);\n \n     CScript result;\n     //\n@@ -1227,15 +1227,15 @@ BOOST_AUTO_TEST_CASE(script_combineSigs)\n \n     // A couple of partially-signed versions:\n     std::vector<unsigned char> sig1;\n-    uint256 hash1 = SignatureHash(scriptPubKey, txTo, 0, SIGHASH_ALL, 0, SIGVERSION_BASE);\n+    uint256 hash1 = SignatureHash(scriptPubKey, txTo, 0, SIGHASH_ALL, 0, SigVersion::BASE);\n     BOOST_CHECK(keys[0].Sign(hash1, sig1));\n     sig1.push_back(SIGHASH_ALL);\n     std::vector<unsigned char> sig2;\n-    uint256 hash2 = SignatureHash(scriptPubKey, txTo, 0, SIGHASH_NONE, 0, SIGVERSION_BASE);\n+    uint256 hash2 = SignatureHash(scriptPubKey, txTo, 0, SIGHASH_NONE, 0, SigVersion::BASE);\n     BOOST_CHECK(keys[1].Sign(hash2, sig2));\n     sig2.push_back(SIGHASH_NONE);\n     std::vector<unsigned char> sig3;\n-    uint256 hash3 = SignatureHash(scriptPubKey, txTo, 0, SIGHASH_SINGLE, 0, SIGVERSION_BASE);\n+    uint256 hash3 = SignatureHash(scriptPubKey, txTo, 0, SIGHASH_SINGLE, 0, SigVersion::BASE);\n     BOOST_CHECK(keys[2].Sign(hash3, sig3));\n     sig3.push_back(SIGHASH_SINGLE);\n "
      },
      {
        "sha": "a2bd8998b1a192051b19db7b5abfc05dacf31590",
        "filename": "src/test/sighash_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1f45e2164a7674f716b425a6658c41ca7c30265b/src/test/sighash_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1f45e2164a7674f716b425a6658c41ca7c30265b/src/test/sighash_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/sighash_tests.cpp?ref=1f45e2164a7674f716b425a6658c41ca7c30265b",
        "patch": "@@ -138,7 +138,7 @@ BOOST_AUTO_TEST_CASE(sighash_test)\n \n         uint256 sh, sho;\n         sho = SignatureHashOld(scriptCode, txTo, nIn, nHashType);\n-        sh = SignatureHash(scriptCode, txTo, nIn, nHashType, 0, SIGVERSION_BASE);\n+        sh = SignatureHash(scriptCode, txTo, nIn, nHashType, 0, SigVersion::BASE);\n         #if defined(PRINT_SIGHASH_JSON)\n         CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n         ss << txTo;\n@@ -204,7 +204,7 @@ BOOST_AUTO_TEST_CASE(sighash_from_data)\n           continue;\n         }\n \n-        sh = SignatureHash(scriptCode, *tx, nIn, nHashType, 0, SIGVERSION_BASE);\n+        sh = SignatureHash(scriptCode, *tx, nIn, nHashType, 0, SigVersion::BASE);\n         BOOST_CHECK_MESSAGE(sh.GetHex() == sigHashHex, strTest);\n     }\n }"
      },
      {
        "sha": "b222392ee5176557f2302d2d252cc3b49dde77ea",
        "filename": "src/test/transaction_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1f45e2164a7674f716b425a6658c41ca7c30265b/src/test/transaction_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1f45e2164a7674f716b425a6658c41ca7c30265b/src/test/transaction_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/transaction_tests.cpp?ref=1f45e2164a7674f716b425a6658c41ca7c30265b",
        "patch": "@@ -407,7 +407,7 @@ static CScript PushAll(const std::vector<valtype>& values)\n void ReplaceRedeemScript(CScript& script, const CScript& redeemScript)\n {\n     std::vector<valtype> stack;\n-    EvalScript(stack, script, SCRIPT_VERIFY_STRICTENC, BaseSignatureChecker(), SIGVERSION_BASE);\n+    EvalScript(stack, script, SCRIPT_VERIFY_STRICTENC, BaseSignatureChecker(), SigVersion::BASE);\n     assert(stack.size() > 0);\n     stack.back() = std::vector<unsigned char>(redeemScript.begin(), redeemScript.end());\n     script = PushAll(stack);"
      },
      {
        "sha": "8a6ca9e51b2ad72c5896a7f1020c3ac478e89dab",
        "filename": "src/test/txvalidationcache_tests.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1f45e2164a7674f716b425a6658c41ca7c30265b/src/test/txvalidationcache_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1f45e2164a7674f716b425a6658c41ca7c30265b/src/test/txvalidationcache_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/txvalidationcache_tests.cpp?ref=1f45e2164a7674f716b425a6658c41ca7c30265b",
        "patch": "@@ -56,7 +56,7 @@ BOOST_FIXTURE_TEST_CASE(tx_mempool_block_doublespend, TestChain100Setup)\n \n         // Sign:\n         std::vector<unsigned char> vchSig;\n-        uint256 hash = SignatureHash(scriptPubKey, spends[i], 0, SIGHASH_ALL, 0, SIGVERSION_BASE);\n+        uint256 hash = SignatureHash(scriptPubKey, spends[i], 0, SIGHASH_ALL, 0, SigVersion::BASE);\n         BOOST_CHECK(coinbaseKey.Sign(hash, vchSig));\n         vchSig.push_back((unsigned char)SIGHASH_ALL);\n         spends[i].vin[0].scriptSig << vchSig;\n@@ -182,7 +182,7 @@ BOOST_FIXTURE_TEST_CASE(checkinputs_test, TestChain100Setup)\n     // Sign, with a non-DER signature\n     {\n         std::vector<unsigned char> vchSig;\n-        uint256 hash = SignatureHash(p2pk_scriptPubKey, spend_tx, 0, SIGHASH_ALL, 0, SIGVERSION_BASE);\n+        uint256 hash = SignatureHash(p2pk_scriptPubKey, spend_tx, 0, SIGHASH_ALL, 0, SigVersion::BASE);\n         BOOST_CHECK(coinbaseKey.Sign(hash, vchSig));\n         vchSig.push_back((unsigned char) 0); // padding byte makes this non-DER\n         vchSig.push_back((unsigned char)SIGHASH_ALL);\n@@ -256,7 +256,7 @@ BOOST_FIXTURE_TEST_CASE(checkinputs_test, TestChain100Setup)\n \n         // Sign\n         std::vector<unsigned char> vchSig;\n-        uint256 hash = SignatureHash(spend_tx.vout[2].scriptPubKey, invalid_with_cltv_tx, 0, SIGHASH_ALL, 0, SIGVERSION_BASE);\n+        uint256 hash = SignatureHash(spend_tx.vout[2].scriptPubKey, invalid_with_cltv_tx, 0, SIGHASH_ALL, 0, SigVersion::BASE);\n         BOOST_CHECK(coinbaseKey.Sign(hash, vchSig));\n         vchSig.push_back((unsigned char)SIGHASH_ALL);\n         invalid_with_cltv_tx.vin[0].scriptSig = CScript() << vchSig << 101;\n@@ -284,7 +284,7 @@ BOOST_FIXTURE_TEST_CASE(checkinputs_test, TestChain100Setup)\n \n         // Sign\n         std::vector<unsigned char> vchSig;\n-        uint256 hash = SignatureHash(spend_tx.vout[3].scriptPubKey, invalid_with_csv_tx, 0, SIGHASH_ALL, 0, SIGVERSION_BASE);\n+        uint256 hash = SignatureHash(spend_tx.vout[3].scriptPubKey, invalid_with_csv_tx, 0, SIGHASH_ALL, 0, SigVersion::BASE);\n         BOOST_CHECK(coinbaseKey.Sign(hash, vchSig));\n         vchSig.push_back((unsigned char)SIGHASH_ALL);\n         invalid_with_csv_tx.vin[0].scriptSig = CScript() << vchSig << 101;"
      },
      {
        "sha": "92ef58e517ded6090474524fa649d048ace5b2ea",
        "filename": "src/test/versionbits_tests.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1f45e2164a7674f716b425a6658c41ca7c30265b/src/test/versionbits_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1f45e2164a7674f716b425a6658c41ca7c30265b/src/test/versionbits_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/versionbits_tests.cpp?ref=1f45e2164a7674f716b425a6658c41ca7c30265b",
        "patch": "@@ -101,8 +101,8 @@ class VersionBitsTester\n     VersionBitsTester& TestDefined() {\n         for (int i = 0; i < CHECKERS; i++) {\n             if (InsecureRandBits(i) == 0) {\n-                BOOST_CHECK_MESSAGE(checker[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == THRESHOLD_DEFINED, strprintf(\"Test %i for DEFINED\", num));\n-                BOOST_CHECK_MESSAGE(checker_always[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == THRESHOLD_ACTIVE, strprintf(\"Test %i for ACTIVE (always active)\", num));\n+                BOOST_CHECK_MESSAGE(checker[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == ThresholdState::DEFINED, strprintf(\"Test %i for DEFINED\", num));\n+                BOOST_CHECK_MESSAGE(checker_always[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == ThresholdState::ACTIVE, strprintf(\"Test %i for ACTIVE (always active)\", num));\n             }\n         }\n         num++;\n@@ -112,8 +112,8 @@ class VersionBitsTester\n     VersionBitsTester& TestStarted() {\n         for (int i = 0; i < CHECKERS; i++) {\n             if (InsecureRandBits(i) == 0) {\n-                BOOST_CHECK_MESSAGE(checker[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == THRESHOLD_STARTED, strprintf(\"Test %i for STARTED\", num));\n-                BOOST_CHECK_MESSAGE(checker_always[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == THRESHOLD_ACTIVE, strprintf(\"Test %i for ACTIVE (always active)\", num));\n+                BOOST_CHECK_MESSAGE(checker[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == ThresholdState::STARTED, strprintf(\"Test %i for STARTED\", num));\n+                BOOST_CHECK_MESSAGE(checker_always[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == ThresholdState::ACTIVE, strprintf(\"Test %i for ACTIVE (always active)\", num));\n             }\n         }\n         num++;\n@@ -123,8 +123,8 @@ class VersionBitsTester\n     VersionBitsTester& TestLockedIn() {\n         for (int i = 0; i < CHECKERS; i++) {\n             if (InsecureRandBits(i) == 0) {\n-                BOOST_CHECK_MESSAGE(checker[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == THRESHOLD_LOCKED_IN, strprintf(\"Test %i for LOCKED_IN\", num));\n-                BOOST_CHECK_MESSAGE(checker_always[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == THRESHOLD_ACTIVE, strprintf(\"Test %i for ACTIVE (always active)\", num));\n+                BOOST_CHECK_MESSAGE(checker[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == ThresholdState::LOCKED_IN, strprintf(\"Test %i for LOCKED_IN\", num));\n+                BOOST_CHECK_MESSAGE(checker_always[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == ThresholdState::ACTIVE, strprintf(\"Test %i for ACTIVE (always active)\", num));\n             }\n         }\n         num++;\n@@ -134,8 +134,8 @@ class VersionBitsTester\n     VersionBitsTester& TestActive() {\n         for (int i = 0; i < CHECKERS; i++) {\n             if (InsecureRandBits(i) == 0) {\n-                BOOST_CHECK_MESSAGE(checker[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == THRESHOLD_ACTIVE, strprintf(\"Test %i for ACTIVE\", num));\n-                BOOST_CHECK_MESSAGE(checker_always[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == THRESHOLD_ACTIVE, strprintf(\"Test %i for ACTIVE (always active)\", num));\n+                BOOST_CHECK_MESSAGE(checker[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == ThresholdState::ACTIVE, strprintf(\"Test %i for ACTIVE\", num));\n+                BOOST_CHECK_MESSAGE(checker_always[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == ThresholdState::ACTIVE, strprintf(\"Test %i for ACTIVE (always active)\", num));\n             }\n         }\n         num++;\n@@ -145,8 +145,8 @@ class VersionBitsTester\n     VersionBitsTester& TestFailed() {\n         for (int i = 0; i < CHECKERS; i++) {\n             if (InsecureRandBits(i) == 0) {\n-                BOOST_CHECK_MESSAGE(checker[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == THRESHOLD_FAILED, strprintf(\"Test %i for FAILED\", num));\n-                BOOST_CHECK_MESSAGE(checker_always[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == THRESHOLD_ACTIVE, strprintf(\"Test %i for ACTIVE (always active)\", num));\n+                BOOST_CHECK_MESSAGE(checker[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == ThresholdState::FAILED, strprintf(\"Test %i for FAILED\", num));\n+                BOOST_CHECK_MESSAGE(checker_always[i].GetStateFor(vpblock.empty() ? nullptr : vpblock.back()) == ThresholdState::ACTIVE, strprintf(\"Test %i for ACTIVE (always active)\", num));\n             }\n         }\n         num++;"
      },
      {
        "sha": "28a14ed3caba65f096968b76a02d4e4cd776f281",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 29,
        "deletions": 29,
        "changes": 58,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1f45e2164a7674f716b425a6658c41ca7c30265b/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1f45e2164a7674f716b425a6658c41ca7c30265b/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=1f45e2164a7674f716b425a6658c41ca7c30265b",
        "patch": "@@ -280,11 +280,11 @@ std::unique_ptr<CCoinsViewDB> pcoinsdbview;\n std::unique_ptr<CCoinsViewCache> pcoinsTip;\n std::unique_ptr<CBlockTreeDB> pblocktree;\n \n-enum FlushStateMode {\n-    FLUSH_STATE_NONE,\n-    FLUSH_STATE_IF_NEEDED,\n-    FLUSH_STATE_PERIODIC,\n-    FLUSH_STATE_ALWAYS\n+enum class FlushStateMode {\n+    NONE,\n+    IF_NEEDED,\n+    PERIODIC,\n+    ALWAYS\n };\n \n // See definition for documentation\n@@ -983,7 +983,7 @@ static bool AcceptToMemoryPoolWithTime(const CChainParams& chainparams, CTxMemPo\n     }\n     // After we've (potentially) uncached entries, ensure our coins cache is still within its size limits\n     CValidationState stateDummy;\n-    FlushStateToDisk(chainparams, stateDummy, FLUSH_STATE_PERIODIC);\n+    FlushStateToDisk(chainparams, stateDummy, FlushStateMode::PERIODIC);\n     return res;\n }\n \n@@ -1685,7 +1685,7 @@ int32_t ComputeBlockVersion(const CBlockIndex* pindexPrev, const Consensus::Para\n \n     for (int i = 0; i < (int)Consensus::MAX_VERSION_BITS_DEPLOYMENTS; i++) {\n         ThresholdState state = VersionBitsState(pindexPrev, params, static_cast<Consensus::DeploymentPos>(i), versionbitscache);\n-        if (state == THRESHOLD_LOCKED_IN || state == THRESHOLD_STARTED) {\n+        if (state == ThresholdState::LOCKED_IN || state == ThresholdState::STARTED) {\n             nVersion |= VersionBitsMask(params, static_cast<Consensus::DeploymentPos>(i));\n         }\n     }\n@@ -1741,7 +1741,7 @@ static unsigned int GetBlockScriptFlags(const CBlockIndex* pindex, const Consens\n     }\n \n     // Start enforcing BIP68 (sequence locks) and BIP112 (CHECKSEQUENCEVERIFY) using versionbits logic.\n-    if (VersionBitsState(pindex->pprev, consensusparams, Consensus::DEPLOYMENT_CSV, versionbitscache) == THRESHOLD_ACTIVE) {\n+    if (VersionBitsState(pindex->pprev, consensusparams, Consensus::DEPLOYMENT_CSV, versionbitscache) == ThresholdState::ACTIVE) {\n         flags |= SCRIPT_VERIFY_CHECKSEQUENCEVERIFY;\n     }\n \n@@ -1927,7 +1927,7 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n \n     // Start enforcing BIP68 (sequence locks) and BIP112 (CHECKSEQUENCEVERIFY) using versionbits logic.\n     int nLockTimeFlags = 0;\n-    if (VersionBitsState(pindex->pprev, chainparams.GetConsensus(), Consensus::DEPLOYMENT_CSV, versionbitscache) == THRESHOLD_ACTIVE) {\n+    if (VersionBitsState(pindex->pprev, chainparams.GetConsensus(), Consensus::DEPLOYMENT_CSV, versionbitscache) == ThresholdState::ACTIVE) {\n         nLockTimeFlags |= LOCKTIME_VERIFY_SEQUENCE;\n     }\n \n@@ -2097,15 +2097,15 @@ bool static FlushStateToDisk(const CChainParams& chainparams, CValidationState &\n         int64_t cacheSize = pcoinsTip->DynamicMemoryUsage();\n         int64_t nTotalSpace = nCoinCacheUsage + std::max<int64_t>(nMempoolSizeMax - nMempoolUsage, 0);\n         // The cache is large and we're within 10% and 10 MiB of the limit, but we have time now (not in the middle of a block processing).\n-        bool fCacheLarge = mode == FLUSH_STATE_PERIODIC && cacheSize > std::max((9 * nTotalSpace) / 10, nTotalSpace - MAX_BLOCK_COINSDB_USAGE * 1024 * 1024);\n+        bool fCacheLarge = mode == FlushStateMode::PERIODIC && cacheSize > std::max((9 * nTotalSpace) / 10, nTotalSpace - MAX_BLOCK_COINSDB_USAGE * 1024 * 1024);\n         // The cache is over the limit, we have to write now.\n-        bool fCacheCritical = mode == FLUSH_STATE_IF_NEEDED && cacheSize > nTotalSpace;\n+        bool fCacheCritical = mode == FlushStateMode::IF_NEEDED && cacheSize > nTotalSpace;\n         // It's been a while since we wrote the block index to disk. Do this frequently, so we don't need to redownload after a crash.\n-        bool fPeriodicWrite = mode == FLUSH_STATE_PERIODIC && nNow > nLastWrite + (int64_t)DATABASE_WRITE_INTERVAL * 1000000;\n+        bool fPeriodicWrite = mode == FlushStateMode::PERIODIC && nNow > nLastWrite + (int64_t)DATABASE_WRITE_INTERVAL * 1000000;\n         // It's been very long since we flushed the cache. Do this infrequently, to optimize cache usage.\n-        bool fPeriodicFlush = mode == FLUSH_STATE_PERIODIC && nNow > nLastFlush + (int64_t)DATABASE_FLUSH_INTERVAL * 1000000;\n+        bool fPeriodicFlush = mode == FlushStateMode::PERIODIC && nNow > nLastFlush + (int64_t)DATABASE_FLUSH_INTERVAL * 1000000;\n         // Combine all conditions that result in a full cache flush.\n-        fDoFullFlush = (mode == FLUSH_STATE_ALWAYS) || fCacheLarge || fCacheCritical || fPeriodicFlush || fFlushForPrune;\n+        fDoFullFlush = (mode == FlushStateMode::ALWAYS) || fCacheLarge || fCacheCritical || fPeriodicFlush || fFlushForPrune;\n         // Write blocks and block index to disk.\n         if (fDoFullFlush || fPeriodicWrite) {\n             // Depend on nMinDiskSpace to ensure we can write block index\n@@ -2151,7 +2151,7 @@ bool static FlushStateToDisk(const CChainParams& chainparams, CValidationState &\n             nLastFlush = nNow;\n         }\n     }\n-    if (fDoFullFlush || ((mode == FLUSH_STATE_ALWAYS || mode == FLUSH_STATE_PERIODIC) && nNow > nLastSetChain + (int64_t)DATABASE_WRITE_INTERVAL * 1000000)) {\n+    if (fDoFullFlush || ((mode == FlushStateMode::ALWAYS || mode == FlushStateMode::PERIODIC) && nNow > nLastSetChain + (int64_t)DATABASE_WRITE_INTERVAL * 1000000)) {\n         // Update best block in wallet (so we can detect restored wallets).\n         GetMainSignals().SetBestChain(chainActive.GetLocator());\n         nLastSetChain = nNow;\n@@ -2165,14 +2165,14 @@ bool static FlushStateToDisk(const CChainParams& chainparams, CValidationState &\n void FlushStateToDisk() {\n     CValidationState state;\n     const CChainParams& chainparams = Params();\n-    FlushStateToDisk(chainparams, state, FLUSH_STATE_ALWAYS);\n+    FlushStateToDisk(chainparams, state, FlushStateMode::ALWAYS);\n }\n \n void PruneAndFlush() {\n     CValidationState state;\n     fCheckForPruning = true;\n     const CChainParams& chainparams = Params();\n-    FlushStateToDisk(chainparams, state, FLUSH_STATE_NONE);\n+    FlushStateToDisk(chainparams, state, FlushStateMode::NONE);\n }\n \n static void DoWarning(const std::string& strWarning)\n@@ -2200,9 +2200,9 @@ void static UpdateTip(const CBlockIndex *pindexNew, const CChainParams& chainPar\n         for (int bit = 0; bit < VERSIONBITS_NUM_BITS; bit++) {\n             WarningBitsConditionChecker checker(bit);\n             ThresholdState state = checker.GetStateFor(pindex, chainParams.GetConsensus(), warningcache[bit]);\n-            if (state == THRESHOLD_ACTIVE || state == THRESHOLD_LOCKED_IN) {\n+            if (state == ThresholdState::ACTIVE || state == ThresholdState::LOCKED_IN) {\n                 const std::string strWarning = strprintf(_(\"Warning: unknown new rules activated (versionbit %i)\"), bit);\n-                if (state == THRESHOLD_ACTIVE) {\n+                if (state == ThresholdState::ACTIVE) {\n                     DoWarning(strWarning);\n                 } else {\n                     warningMessages.push_back(strWarning);\n@@ -2268,7 +2268,7 @@ bool CChainState::DisconnectTip(CValidationState& state, const CChainParams& cha\n     }\n     LogPrint(BCLog::BENCH, \"- Disconnect block: %.2fms\\n\", (GetTimeMicros() - nStart) * MILLI);\n     // Write the chain state to disk, if necessary.\n-    if (!FlushStateToDisk(chainparams, state, FLUSH_STATE_IF_NEEDED))\n+    if (!FlushStateToDisk(chainparams, state, FlushStateMode::IF_NEEDED))\n         return false;\n \n     if (disconnectpool) {\n@@ -2406,7 +2406,7 @@ bool CChainState::ConnectTip(CValidationState& state, const CChainParams& chainp\n     int64_t nTime4 = GetTimeMicros(); nTimeFlush += nTime4 - nTime3;\n     LogPrint(BCLog::BENCH, \"  - Flush: %.2fms [%.2fs (%.2fms/blk)]\\n\", (nTime4 - nTime3) * MILLI, nTimeFlush * MICRO, nTimeFlush * MILLI / nBlocksTotal);\n     // Write the chain state to disk, if necessary.\n-    if (!FlushStateToDisk(chainparams, state, FLUSH_STATE_IF_NEEDED))\n+    if (!FlushStateToDisk(chainparams, state, FlushStateMode::IF_NEEDED))\n         return false;\n     int64_t nTime5 = GetTimeMicros(); nTimeChainState += nTime5 - nTime4;\n     LogPrint(BCLog::BENCH, \"  - Writing chainstate: %.2fms [%.2fs (%.2fms/blk)]\\n\", (nTime5 - nTime4) * MILLI, nTimeChainState * MICRO, nTimeChainState * MILLI / nBlocksTotal);\n@@ -2683,7 +2683,7 @@ bool CChainState::ActivateBestChain(CValidationState &state, const CChainParams&\n     CheckBlockIndex(chainparams.GetConsensus());\n \n     // Write changes periodically to disk, after relay.\n-    if (!FlushStateToDisk(chainparams, state, FLUSH_STATE_PERIODIC)) {\n+    if (!FlushStateToDisk(chainparams, state, FlushStateMode::PERIODIC)) {\n         return false;\n     }\n \n@@ -3071,7 +3071,7 @@ bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::P\n bool IsWitnessEnabled(const CBlockIndex* pindexPrev, const Consensus::Params& params)\n {\n     LOCK(cs_main);\n-    return (VersionBitsState(pindexPrev, params, Consensus::DEPLOYMENT_SEGWIT, versionbitscache) == THRESHOLD_ACTIVE);\n+    return (VersionBitsState(pindexPrev, params, Consensus::DEPLOYMENT_SEGWIT, versionbitscache) == ThresholdState::ACTIVE);\n }\n \n // Compute at which vout of the block's coinbase transaction the witness\n@@ -3190,7 +3190,7 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n \n     // Start enforcing BIP113 (Median Time Past) using versionbits logic.\n     int nLockTimeFlags = 0;\n-    if (VersionBitsState(pindexPrev, consensusParams, Consensus::DEPLOYMENT_CSV, versionbitscache) == THRESHOLD_ACTIVE) {\n+    if (VersionBitsState(pindexPrev, consensusParams, Consensus::DEPLOYMENT_CSV, versionbitscache) == ThresholdState::ACTIVE) {\n         nLockTimeFlags |= LOCKTIME_MEDIAN_TIME_PAST;\n     }\n \n@@ -3224,7 +3224,7 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n     //   {0xaa, 0x21, 0xa9, 0xed}, and the following 32 bytes are SHA256^2(witness root, witness nonce). In case there are\n     //   multiple, the last one is used.\n     bool fHaveWitness = false;\n-    if (VersionBitsState(pindexPrev, consensusParams, Consensus::DEPLOYMENT_SEGWIT, versionbitscache) == THRESHOLD_ACTIVE) {\n+    if (VersionBitsState(pindexPrev, consensusParams, Consensus::DEPLOYMENT_SEGWIT, versionbitscache) == ThresholdState::ACTIVE) {\n         int commitpos = GetWitnessCommitmentIndex(block);\n         if (commitpos != -1) {\n             bool malleated = false;\n@@ -3439,7 +3439,7 @@ bool CChainState::AcceptBlock(const std::shared_ptr<const CBlock>& pblock, CVali\n     }\n \n     if (fCheckForPruning)\n-        FlushStateToDisk(chainparams, state, FLUSH_STATE_NONE); // we just allocated more disk space for block files\n+        FlushStateToDisk(chainparams, state, FlushStateMode::NONE); // we just allocated more disk space for block files\n \n     CheckBlockIndex(chainparams.GetConsensus());\n \n@@ -3592,7 +3592,7 @@ void PruneBlockFilesManual(int nManualPruneHeight)\n {\n     CValidationState state;\n     const CChainParams& chainparams = Params();\n-    FlushStateToDisk(chainparams, state, FLUSH_STATE_NONE, nManualPruneHeight);\n+    FlushStateToDisk(chainparams, state, FlushStateMode::NONE, nManualPruneHeight);\n }\n \n /**\n@@ -4085,7 +4085,7 @@ bool CChainState::RewindBlockIndex(const CChainParams& params)\n             return error(\"RewindBlockIndex: unable to disconnect block at height %i\", pindex->nHeight);\n         }\n         // Occasionally flush state to disk.\n-        if (!FlushStateToDisk(params, state, FLUSH_STATE_PERIODIC))\n+        if (!FlushStateToDisk(params, state, FlushStateMode::PERIODIC))\n             return false;\n     }\n \n@@ -4151,7 +4151,7 @@ bool RewindBlockIndex(const CChainParams& params) {\n         // and skip it here, we're about to -reindex-chainstate anyway, so\n         // it'll get called a bunch real soon.\n         CValidationState state;\n-        if (!FlushStateToDisk(params, state, FLUSH_STATE_ALWAYS)) {\n+        if (!FlushStateToDisk(params, state, FlushStateMode::ALWAYS)) {\n             return false;\n         }\n     }"
      },
      {
        "sha": "e3ec078173408b1e835fc605a00126606f78d6d0",
        "filename": "src/versionbits.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 14,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1f45e2164a7674f716b425a6658c41ca7c30265b/src/versionbits.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1f45e2164a7674f716b425a6658c41ca7c30265b/src/versionbits.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/versionbits.cpp?ref=1f45e2164a7674f716b425a6658c41ca7c30265b",
        "patch": "@@ -29,7 +29,7 @@ ThresholdState AbstractThresholdConditionChecker::GetStateFor(const CBlockIndex*\n \n     // Check if this deployment is always active.\n     if (nTimeStart == Consensus::BIP9Deployment::ALWAYS_ACTIVE) {\n-        return THRESHOLD_ACTIVE;\n+        return ThresholdState::ACTIVE;\n     }\n \n     // A block's state is always the same as that of the first of its period, so it is computed based on a pindexPrev whose height equals a multiple of nPeriod - 1.\n@@ -42,12 +42,12 @@ ThresholdState AbstractThresholdConditionChecker::GetStateFor(const CBlockIndex*\n     while (cache.count(pindexPrev) == 0) {\n         if (pindexPrev == nullptr) {\n             // The genesis block is by definition defined.\n-            cache[pindexPrev] = THRESHOLD_DEFINED;\n+            cache[pindexPrev] = ThresholdState::DEFINED;\n             break;\n         }\n         if (pindexPrev->GetMedianTimePast() < nTimeStart) {\n             // Optimization: don't recompute down further, as we know every earlier block will be before the start time\n-            cache[pindexPrev] = THRESHOLD_DEFINED;\n+            cache[pindexPrev] = ThresholdState::DEFINED;\n             break;\n         }\n         vToCompute.push_back(pindexPrev);\n@@ -65,17 +65,17 @@ ThresholdState AbstractThresholdConditionChecker::GetStateFor(const CBlockIndex*\n         vToCompute.pop_back();\n \n         switch (state) {\n-            case THRESHOLD_DEFINED: {\n+            case ThresholdState::DEFINED: {\n                 if (pindexPrev->GetMedianTimePast() >= nTimeTimeout) {\n-                    stateNext = THRESHOLD_FAILED;\n+                    stateNext = ThresholdState::FAILED;\n                 } else if (pindexPrev->GetMedianTimePast() >= nTimeStart) {\n-                    stateNext = THRESHOLD_STARTED;\n+                    stateNext = ThresholdState::STARTED;\n                 }\n                 break;\n             }\n-            case THRESHOLD_STARTED: {\n+            case ThresholdState::STARTED: {\n                 if (pindexPrev->GetMedianTimePast() >= nTimeTimeout) {\n-                    stateNext = THRESHOLD_FAILED;\n+                    stateNext = ThresholdState::FAILED;\n                     break;\n                 }\n                 // We need to count\n@@ -88,17 +88,17 @@ ThresholdState AbstractThresholdConditionChecker::GetStateFor(const CBlockIndex*\n                     pindexCount = pindexCount->pprev;\n                 }\n                 if (count >= nThreshold) {\n-                    stateNext = THRESHOLD_LOCKED_IN;\n+                    stateNext = ThresholdState::LOCKED_IN;\n                 }\n                 break;\n             }\n-            case THRESHOLD_LOCKED_IN: {\n+            case ThresholdState::LOCKED_IN: {\n                 // Always progresses into ACTIVE.\n-                stateNext = THRESHOLD_ACTIVE;\n+                stateNext = ThresholdState::ACTIVE;\n                 break;\n             }\n-            case THRESHOLD_FAILED:\n-            case THRESHOLD_ACTIVE: {\n+            case ThresholdState::FAILED:\n+            case ThresholdState::ACTIVE: {\n                 // Nothing happens, these are terminal states.\n                 break;\n             }\n@@ -149,7 +149,7 @@ int AbstractThresholdConditionChecker::GetStateSinceHeightFor(const CBlockIndex*\n     const ThresholdState initialState = GetStateFor(pindexPrev, params, cache);\n \n     // BIP 9 about state DEFINED: \"The genesis block is by definition in this state for each deployment.\"\n-    if (initialState == THRESHOLD_DEFINED) {\n+    if (initialState == ThresholdState::DEFINED) {\n         return 0;\n     }\n "
      },
      {
        "sha": "65cf308c7942edab01583e66e8e24929a7346911",
        "filename": "src/versionbits.h",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1f45e2164a7674f716b425a6658c41ca7c30265b/src/versionbits.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1f45e2164a7674f716b425a6658c41ca7c30265b/src/versionbits.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/versionbits.h?ref=1f45e2164a7674f716b425a6658c41ca7c30265b",
        "patch": "@@ -17,12 +17,12 @@ static const int32_t VERSIONBITS_TOP_MASK = 0xE0000000UL;\n /** Total bits available for versionbits */\n static const int32_t VERSIONBITS_NUM_BITS = 29;\n \n-enum ThresholdState {\n-    THRESHOLD_DEFINED,\n-    THRESHOLD_STARTED,\n-    THRESHOLD_LOCKED_IN,\n-    THRESHOLD_ACTIVE,\n-    THRESHOLD_FAILED,\n+enum class ThresholdState {\n+    DEFINED,\n+    STARTED,\n+    LOCKED_IN,\n+    ACTIVE,\n+    FAILED,\n };\n \n // A map that gives the state for blocks whose height is a multiple of Period()."
      },
      {
        "sha": "553cae4d026cf32bb5f48a92b74d78b3dc2eb6a7",
        "filename": "src/wallet/db.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1f45e2164a7674f716b425a6658c41ca7c30265b/src/wallet/db.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1f45e2164a7674f716b425a6658c41ca7c30265b/src/wallet/db.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/db.cpp?ref=1f45e2164a7674f716b425a6658c41ca7c30265b",
        "patch": "@@ -235,13 +235,13 @@ CDBEnv::VerifyResult CDBEnv::Verify(const std::string& strFile, recoverFunc_type\n     Db db(dbenv.get(), 0);\n     int result = db.verify(strFile.c_str(), nullptr, nullptr, 0);\n     if (result == 0)\n-        return VERIFY_OK;\n+        return VerifyResult::VERIFY_OK;\n     else if (recoverFunc == nullptr)\n-        return RECOVER_FAIL;\n+        return VerifyResult::RECOVER_FAIL;\n \n     // Try to recover:\n     bool fRecovered = (*recoverFunc)(fs::path(strPath) / strFile, out_backup_filename);\n-    return (fRecovered ? RECOVER_OK : RECOVER_FAIL);\n+    return (fRecovered ? VerifyResult::RECOVER_OK : VerifyResult::RECOVER_FAIL);\n }\n \n bool CDB::Recover(const fs::path& file_path, void *callbackDataIn, bool (*recoverKVcallback)(void* callbackData, CDataStream ssKey, CDataStream ssValue), std::string& newFilename)\n@@ -347,15 +347,15 @@ bool CDB::VerifyDatabaseFile(const fs::path& file_path, std::string& warningStr,\n     {\n         std::string backup_filename;\n         CDBEnv::VerifyResult r = env->Verify(walletFile, recoverFunc, backup_filename);\n-        if (r == CDBEnv::RECOVER_OK)\n+        if (r == CDBEnv::VerifyResult::RECOVER_OK)\n         {\n             warningStr = strprintf(_(\"Warning: Wallet file corrupt, data salvaged!\"\n                                      \" Original %s saved as %s in %s; if\"\n                                      \" your balance or transactions are incorrect you should\"\n                                      \" restore from a backup.\"),\n                                    walletFile, backup_filename, walletDir);\n         }\n-        if (r == CDBEnv::RECOVER_FAIL)\n+        if (r == CDBEnv::VerifyResult::RECOVER_FAIL)\n         {\n             errorStr = strprintf(_(\"%s corrupt, salvage failed\"), walletFile);\n             return false;"
      },
      {
        "sha": "65bb8cc2532f65186c1d9efbda58c7d389552eb4",
        "filename": "src/wallet/db.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1f45e2164a7674f716b425a6658c41ca7c30265b/src/wallet/db.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1f45e2164a7674f716b425a6658c41ca7c30265b/src/wallet/db.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/db.h?ref=1f45e2164a7674f716b425a6658c41ca7c30265b",
        "patch": "@@ -53,7 +53,7 @@ class CDBEnv\n      * This must be called BEFORE strFile is opened.\n      * Returns true if strFile is OK.\n      */\n-    enum VerifyResult { VERIFY_OK,\n+    enum class VerifyResult { VERIFY_OK,\n                         RECOVER_OK,\n                         RECOVER_FAIL };\n     typedef bool (*recoverFunc_type)(const fs::path& file_path, std::string& out_backup_filename);"
      },
      {
        "sha": "0db1fc21dc8f635aa906799b47cdb713e78476c9",
        "filename": "src/wallet/rpcdump.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1f45e2164a7674f716b425a6658c41ca7c30265b/src/wallet/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1f45e2164a7674f716b425a6658c41ca7c30265b/src/wallet/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcdump.cpp?ref=1f45e2164a7674f716b425a6658c41ca7c30265b",
        "patch": "@@ -409,7 +409,7 @@ UniValue removeprunedfunds(const JSONRPCRequest& request)\n     vHash.push_back(hash);\n     std::vector<uint256> vHashOut;\n \n-    if (pwallet->ZapSelectTx(vHash, vHashOut) != DB_LOAD_OK) {\n+    if (pwallet->ZapSelectTx(vHash, vHashOut) != DBErrors::LOAD_OK) {\n         throw JSONRPCError(RPC_WALLET_ERROR, \"Could not properly delete the transaction.\");\n     }\n "
      },
      {
        "sha": "e7fdc242945019afdc94c8f8ffc221c39fd75fd3",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1f45e2164a7674f716b425a6658c41ca7c30265b/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1f45e2164a7674f716b425a6658c41ca7c30265b/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=1f45e2164a7674f716b425a6658c41ca7c30265b",
        "patch": "@@ -113,9 +113,9 @@ void WalletTxToJSON(const CWalletTx& wtx, UniValue& entry)\n     if (confirms <= 0) {\n         LOCK(mempool.cs);\n         RBFTransactionState rbfState = IsRBFOptIn(*wtx.tx, mempool);\n-        if (rbfState == RBF_TRANSACTIONSTATE_UNKNOWN)\n+        if (rbfState == RBFTransactionState::UNKNOWN)\n             rbfStatus = \"unknown\";\n-        else if (rbfState == RBF_TRANSACTIONSTATE_REPLACEABLE_BIP125)\n+        else if (rbfState == RBFTransactionState::REPLACEABLE_BIP125)\n             rbfStatus = \"yes\";\n     }\n     entry.pushKV(\"bip125-replaceable\", rbfStatus);"
      },
      {
        "sha": "8cb87c1956aa7d71e59a69f4652e7cd4e9956349",
        "filename": "src/wallet/test/accounting_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1f45e2164a7674f716b425a6658c41ca7c30265b/src/wallet/test/accounting_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1f45e2164a7674f716b425a6658c41ca7c30265b/src/wallet/test/accounting_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/accounting_tests.cpp?ref=1f45e2164a7674f716b425a6658c41ca7c30265b",
        "patch": "@@ -18,7 +18,7 @@ GetResults(CWallet& wallet, std::map<CAmount, CAccountingEntry>& results)\n     std::list<CAccountingEntry> aes;\n \n     results.clear();\n-    BOOST_CHECK(wallet.ReorderTransactions() == DB_LOAD_OK);\n+    BOOST_CHECK(wallet.ReorderTransactions() == DBErrors::LOAD_OK);\n     wallet.ListAccountCreditDebit(\"\", aes);\n     for (CAccountingEntry& ae : aes)\n     {"
      },
      {
        "sha": "613bb46880d99ebaf6e75cb5bd03d0996b03b3e1",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 20,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1f45e2164a7674f716b425a6658c41ca7c30265b/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1f45e2164a7674f716b425a6658c41ca7c30265b/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=1f45e2164a7674f716b425a6658c41ca7c30265b",
        "patch": "@@ -737,11 +737,11 @@ DBErrors CWallet::ReorderTransactions()\n             if (pwtx)\n             {\n                 if (!walletdb.WriteTx(*pwtx))\n-                    return DB_LOAD_FAIL;\n+                    return DBErrors::LOAD_FAIL;\n             }\n             else\n                 if (!walletdb.WriteAccountingEntry(pacentry->nEntryNo, *pacentry))\n-                    return DB_LOAD_FAIL;\n+                    return DBErrors::LOAD_FAIL;\n         }\n         else\n         {\n@@ -761,16 +761,16 @@ DBErrors CWallet::ReorderTransactions()\n             if (pwtx)\n             {\n                 if (!walletdb.WriteTx(*pwtx))\n-                    return DB_LOAD_FAIL;\n+                    return DBErrors::LOAD_FAIL;\n             }\n             else\n                 if (!walletdb.WriteAccountingEntry(pacentry->nEntryNo, *pacentry))\n-                    return DB_LOAD_FAIL;\n+                    return DBErrors::LOAD_FAIL;\n         }\n     }\n     walletdb.WriteOrderPosNext(nOrderPosNext);\n \n-    return DB_LOAD_OK;\n+    return DBErrors::LOAD_OK;\n }\n \n int64_t CWallet::IncOrderPosNext(CWalletDB *pwalletdb)\n@@ -3134,7 +3134,7 @@ DBErrors CWallet::LoadWallet(bool& fFirstRunRet)\n \n     fFirstRunRet = false;\n     DBErrors nLoadWalletRet = CWalletDB(*dbw,\"cr+\").LoadWallet(this);\n-    if (nLoadWalletRet == DB_NEED_REWRITE)\n+    if (nLoadWalletRet == DBErrors::NEED_REWRITE)\n     {\n         if (dbw->Rewrite(\"\\x04pool\"))\n         {\n@@ -3150,12 +3150,12 @@ DBErrors CWallet::LoadWallet(bool& fFirstRunRet)\n     // This wallet is in its first run if all of these are empty\n     fFirstRunRet = mapKeys.empty() && mapCryptedKeys.empty() && mapWatchKeys.empty() && setWatchOnly.empty() && mapScripts.empty();\n \n-    if (nLoadWalletRet != DB_LOAD_OK)\n+    if (nLoadWalletRet != DBErrors::LOAD_OK)\n         return nLoadWalletRet;\n \n     uiInterface.LoadWallet(this);\n \n-    return DB_LOAD_OK;\n+    return DBErrors::LOAD_OK;\n }\n \n DBErrors CWallet::ZapSelectTx(std::vector<uint256>& vHashIn, std::vector<uint256>& vHashOut)\n@@ -3165,7 +3165,7 @@ DBErrors CWallet::ZapSelectTx(std::vector<uint256>& vHashIn, std::vector<uint256\n     for (uint256 hash : vHashOut)\n         mapWallet.erase(hash);\n \n-    if (nZapSelectTxRet == DB_NEED_REWRITE)\n+    if (nZapSelectTxRet == DBErrors::NEED_REWRITE)\n     {\n         if (dbw->Rewrite(\"\\x04pool\"))\n         {\n@@ -3178,19 +3178,19 @@ DBErrors CWallet::ZapSelectTx(std::vector<uint256>& vHashIn, std::vector<uint256\n         }\n     }\n \n-    if (nZapSelectTxRet != DB_LOAD_OK)\n+    if (nZapSelectTxRet != DBErrors::LOAD_OK)\n         return nZapSelectTxRet;\n \n     MarkDirty();\n \n-    return DB_LOAD_OK;\n+    return DBErrors::LOAD_OK;\n \n }\n \n DBErrors CWallet::ZapWalletTx(std::vector<CWalletTx>& vWtx)\n {\n     DBErrors nZapWalletTxRet = CWalletDB(*dbw,\"cr+\").ZapWalletTx(vWtx);\n-    if (nZapWalletTxRet == DB_NEED_REWRITE)\n+    if (nZapWalletTxRet == DBErrors::NEED_REWRITE)\n     {\n         if (dbw->Rewrite(\"\\x04pool\"))\n         {\n@@ -3204,10 +3204,10 @@ DBErrors CWallet::ZapWalletTx(std::vector<CWalletTx>& vWtx)\n         }\n     }\n \n-    if (nZapWalletTxRet != DB_LOAD_OK)\n+    if (nZapWalletTxRet != DBErrors::LOAD_OK)\n         return nZapWalletTxRet;\n \n-    return DB_LOAD_OK;\n+    return DBErrors::LOAD_OK;\n }\n \n \n@@ -3919,7 +3919,7 @@ CWallet* CWallet::CreateWalletFromFile(const std::string& name, const fs::path&\n \n         std::unique_ptr<CWallet> tempWallet = MakeUnique<CWallet>(name, CWalletDBWrapper::Create(path));\n         DBErrors nZapWalletRet = tempWallet->ZapWalletTx(vWtx);\n-        if (nZapWalletRet != DB_LOAD_OK) {\n+        if (nZapWalletRet != DBErrors::LOAD_OK) {\n             InitError(strprintf(_(\"Error loading %s: Wallet corrupted\"), walletFile));\n             return nullptr;\n         }\n@@ -3931,23 +3931,23 @@ CWallet* CWallet::CreateWalletFromFile(const std::string& name, const fs::path&\n     bool fFirstRun = true;\n     CWallet *walletInstance = new CWallet(name, CWalletDBWrapper::Create(path));\n     DBErrors nLoadWalletRet = walletInstance->LoadWallet(fFirstRun);\n-    if (nLoadWalletRet != DB_LOAD_OK)\n+    if (nLoadWalletRet != DBErrors::LOAD_OK)\n     {\n-        if (nLoadWalletRet == DB_CORRUPT) {\n+        if (nLoadWalletRet == DBErrors::CORRUPT) {\n             InitError(strprintf(_(\"Error loading %s: Wallet corrupted\"), walletFile));\n             return nullptr;\n         }\n-        else if (nLoadWalletRet == DB_NONCRITICAL_ERROR)\n+        else if (nLoadWalletRet == DBErrors::NONCRITICAL_ERROR)\n         {\n             InitWarning(strprintf(_(\"Error reading %s! All keys read correctly, but transaction data\"\n                                          \" or address book entries might be missing or incorrect.\"),\n                 walletFile));\n         }\n-        else if (nLoadWalletRet == DB_TOO_NEW) {\n+        else if (nLoadWalletRet == DBErrors::TOO_NEW) {\n             InitError(strprintf(_(\"Error loading %s: Wallet requires newer version of %s\"), walletFile, _(PACKAGE_NAME)));\n             return nullptr;\n         }\n-        else if (nLoadWalletRet == DB_NEED_REWRITE)\n+        else if (nLoadWalletRet == DBErrors::NEED_REWRITE)\n         {\n             InitError(strprintf(_(\"Wallet needed to be rewritten: restart %s to complete\"), _(PACKAGE_NAME)));\n             return nullptr;"
      },
      {
        "sha": "4925d96d946b5e84729eb8f5b2141045bae827f0",
        "filename": "src/wallet/walletdb.cpp",
        "status": "modified",
        "additions": 21,
        "deletions": 21,
        "changes": 42,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1f45e2164a7674f716b425a6658c41ca7c30265b/src/wallet/walletdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1f45e2164a7674f716b425a6658c41ca7c30265b/src/wallet/walletdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/walletdb.cpp?ref=1f45e2164a7674f716b425a6658c41ca7c30265b",
        "patch": "@@ -522,15 +522,15 @@ DBErrors CWalletDB::LoadWallet(CWallet* pwallet)\n {\n     CWalletScanState wss;\n     bool fNoncriticalErrors = false;\n-    DBErrors result = DB_LOAD_OK;\n+    DBErrors result = DBErrors::LOAD_OK;\n \n     LOCK(pwallet->cs_wallet);\n     try {\n         int nMinVersion = 0;\n         if (batch.Read((std::string)\"minversion\", nMinVersion))\n         {\n             if (nMinVersion > CLIENT_VERSION)\n-                return DB_TOO_NEW;\n+                return DBErrors::TOO_NEW;\n             pwallet->LoadMinVersion(nMinVersion);\n         }\n \n@@ -539,7 +539,7 @@ DBErrors CWalletDB::LoadWallet(CWallet* pwallet)\n         if (!pcursor)\n         {\n             LogPrintf(\"Error getting wallet database cursor\\n\");\n-            return DB_CORRUPT;\n+            return DBErrors::CORRUPT;\n         }\n \n         while (true)\n@@ -553,7 +553,7 @@ DBErrors CWalletDB::LoadWallet(CWallet* pwallet)\n             else if (ret != 0)\n             {\n                 LogPrintf(\"Error reading next record from wallet database\\n\");\n-                return DB_CORRUPT;\n+                return DBErrors::CORRUPT;\n             }\n \n             // Try to be tolerant of single corrupt records:\n@@ -563,7 +563,7 @@ DBErrors CWalletDB::LoadWallet(CWallet* pwallet)\n                 // losing keys is considered a catastrophic error, anything else\n                 // we assume the user can live with:\n                 if (IsKeyType(strType) || strType == \"defaultkey\")\n-                    result = DB_CORRUPT;\n+                    result = DBErrors::CORRUPT;\n                 else\n                 {\n                     // Leave other errors alone, if we try to fix them we might make things worse.\n@@ -582,15 +582,15 @@ DBErrors CWalletDB::LoadWallet(CWallet* pwallet)\n         throw;\n     }\n     catch (...) {\n-        result = DB_CORRUPT;\n+        result = DBErrors::CORRUPT;\n     }\n \n-    if (fNoncriticalErrors && result == DB_LOAD_OK)\n-        result = DB_NONCRITICAL_ERROR;\n+    if (fNoncriticalErrors && result == DBErrors::LOAD_OK)\n+        result = DBErrors::NONCRITICAL_ERROR;\n \n     // Any wallet corruption at all: skip any rewriting or\n     // upgrading, we don't want to make it worse.\n-    if (result != DB_LOAD_OK)\n+    if (result != DBErrors::LOAD_OK)\n         return result;\n \n     LogPrintf(\"nFileVersion = %d\\n\", wss.nFileVersion);\n@@ -607,7 +607,7 @@ DBErrors CWalletDB::LoadWallet(CWallet* pwallet)\n \n     // Rewrite encrypted wallets of versions 0.4.0 and 0.5.0rc:\n     if (wss.fIsEncrypted && (wss.nFileVersion == 40000 || wss.nFileVersion == 50000))\n-        return DB_NEED_REWRITE;\n+        return DBErrors::NEED_REWRITE;\n \n     if (wss.nFileVersion < CLIENT_VERSION) // Update\n         WriteVersion(CLIENT_VERSION);\n@@ -626,22 +626,22 @@ DBErrors CWalletDB::LoadWallet(CWallet* pwallet)\n \n DBErrors CWalletDB::FindWalletTx(std::vector<uint256>& vTxHash, std::vector<CWalletTx>& vWtx)\n {\n-    DBErrors result = DB_LOAD_OK;\n+    DBErrors result = DBErrors::LOAD_OK;\n \n     try {\n         int nMinVersion = 0;\n         if (batch.Read((std::string)\"minversion\", nMinVersion))\n         {\n             if (nMinVersion > CLIENT_VERSION)\n-                return DB_TOO_NEW;\n+                return DBErrors::TOO_NEW;\n         }\n \n         // Get cursor\n         Dbc* pcursor = batch.GetCursor();\n         if (!pcursor)\n         {\n             LogPrintf(\"Error getting wallet database cursor\\n\");\n-            return DB_CORRUPT;\n+            return DBErrors::CORRUPT;\n         }\n \n         while (true)\n@@ -655,7 +655,7 @@ DBErrors CWalletDB::FindWalletTx(std::vector<uint256>& vTxHash, std::vector<CWal\n             else if (ret != 0)\n             {\n                 LogPrintf(\"Error reading next record from wallet database\\n\");\n-                return DB_CORRUPT;\n+                return DBErrors::CORRUPT;\n             }\n \n             std::string strType;\n@@ -677,7 +677,7 @@ DBErrors CWalletDB::FindWalletTx(std::vector<uint256>& vTxHash, std::vector<CWal\n         throw;\n     }\n     catch (...) {\n-        result = DB_CORRUPT;\n+        result = DBErrors::CORRUPT;\n     }\n \n     return result;\n@@ -689,7 +689,7 @@ DBErrors CWalletDB::ZapSelectTx(std::vector<uint256>& vTxHashIn, std::vector<uin\n     std::vector<uint256> vTxHash;\n     std::vector<CWalletTx> vWtx;\n     DBErrors err = FindWalletTx(vTxHash, vWtx);\n-    if (err != DB_LOAD_OK) {\n+    if (err != DBErrors::LOAD_OK) {\n         return err;\n     }\n \n@@ -716,26 +716,26 @@ DBErrors CWalletDB::ZapSelectTx(std::vector<uint256>& vTxHashIn, std::vector<uin\n     }\n \n     if (delerror) {\n-        return DB_CORRUPT;\n+        return DBErrors::CORRUPT;\n     }\n-    return DB_LOAD_OK;\n+    return DBErrors::LOAD_OK;\n }\n \n DBErrors CWalletDB::ZapWalletTx(std::vector<CWalletTx>& vWtx)\n {\n     // build list of wallet TXs\n     std::vector<uint256> vTxHash;\n     DBErrors err = FindWalletTx(vTxHash, vWtx);\n-    if (err != DB_LOAD_OK)\n+    if (err != DBErrors::LOAD_OK)\n         return err;\n \n     // erase each wallet TX\n     for (uint256& hash : vTxHash) {\n         if (!EraseTx(hash))\n-            return DB_CORRUPT;\n+            return DBErrors::CORRUPT;\n     }\n \n-    return DB_LOAD_OK;\n+    return DBErrors::LOAD_OK;\n }\n \n void MaybeCompactWalletDB()"
      },
      {
        "sha": "606b7dace721ead8015ba7671d5373a0ac0df78a",
        "filename": "src/wallet/walletdb.h",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1f45e2164a7674f716b425a6658c41ca7c30265b/src/wallet/walletdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1f45e2164a7674f716b425a6658c41ca7c30265b/src/wallet/walletdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/walletdb.h?ref=1f45e2164a7674f716b425a6658c41ca7c30265b",
        "patch": "@@ -46,14 +46,14 @@ class uint160;\n class uint256;\n \n /** Error statuses for the wallet database */\n-enum DBErrors\n+enum class DBErrors\n {\n-    DB_LOAD_OK,\n-    DB_CORRUPT,\n-    DB_NONCRITICAL_ERROR,\n-    DB_TOO_NEW,\n-    DB_LOAD_FAIL,\n-    DB_NEED_REWRITE\n+    LOAD_OK,\n+    CORRUPT,\n+    NONCRITICAL_ERROR,\n+    TOO_NEW,\n+    LOAD_FAIL,\n+    NEED_REWRITE\n };\n \n /* simple HD chain data model */"
      }
    ]
  }
]