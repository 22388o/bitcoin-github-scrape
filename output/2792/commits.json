[
  {
    "sha": "f121db58e4b0baeb0834ab670cff3df8a7495457",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmMTIxZGI1OGU0YjBiYWViMDgzNGFiNjcwY2ZmM2RmOGE3NDk1NDU3",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2013-06-25T01:03:03Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2013-06-25T08:33:29Z"
      },
      "message": "Move core implementations to core.cpp",
      "tree": {
        "sha": "6061a8b9c3418bdc80e52353be0979a45d831395",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6061a8b9c3418bdc80e52353be0979a45d831395"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f121db58e4b0baeb0834ab670cff3df8a7495457",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f121db58e4b0baeb0834ab670cff3df8a7495457",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f121db58e4b0baeb0834ab670cff3df8a7495457",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f121db58e4b0baeb0834ab670cff3df8a7495457/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "79f6925facba6546987137f2c54948cad4dc69df",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/79f6925facba6546987137f2c54948cad4dc69df",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/79f6925facba6546987137f2c54948cad4dc69df"
      }
    ],
    "stats": {
      "total": 596,
      "additions": 316,
      "deletions": 280
    },
    "files": [
      {
        "sha": "afba0959cfe39cc298a623293c590374ec2430ba",
        "filename": "src/core.cpp",
        "status": "modified",
        "additions": 294,
        "deletions": 0,
        "changes": 294,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f121db58e4b0baeb0834ab670cff3df8a7495457/src/core.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f121db58e4b0baeb0834ab670cff3df8a7495457/src/core.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core.cpp?ref=f121db58e4b0baeb0834ab670cff3df8a7495457",
        "patch": "@@ -4,4 +4,298 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include \"core.h\"\n+#include \"util.h\"\n \n+std::string COutPoint::ToString() const\n+{\n+    return strprintf(\"COutPoint(%s, %u)\", hash.ToString().substr(0,10).c_str(), n);\n+}\n+\n+void COutPoint::print() const\n+{\n+    printf(\"%s\\n\", ToString().c_str());\n+}\n+\n+CTxIn::CTxIn(COutPoint prevoutIn, CScript scriptSigIn, unsigned int nSequenceIn)\n+{\n+    prevout = prevoutIn;\n+    scriptSig = scriptSigIn;\n+    nSequence = nSequenceIn;\n+}\n+\n+CTxIn::CTxIn(uint256 hashPrevTx, unsigned int nOut, CScript scriptSigIn, unsigned int nSequenceIn)\n+{\n+    prevout = COutPoint(hashPrevTx, nOut);\n+    scriptSig = scriptSigIn;\n+    nSequence = nSequenceIn;\n+}\n+\n+std::string CTxIn::ToString() const\n+{\n+    std::string str;\n+    str += \"CTxIn(\";\n+    str += prevout.ToString();\n+    if (prevout.IsNull())\n+        str += strprintf(\", coinbase %s\", HexStr(scriptSig).c_str());\n+    else\n+        str += strprintf(\", scriptSig=%s\", scriptSig.ToString().substr(0,24).c_str());\n+    if (nSequence != std::numeric_limits<unsigned int>::max())\n+        str += strprintf(\", nSequence=%u\", nSequence);\n+    str += \")\";\n+    return str;\n+}\n+\n+void CTxIn::print() const\n+{\n+    printf(\"%s\\n\", ToString().c_str());\n+}\n+\n+CTxOut::CTxOut(int64 nValueIn, CScript scriptPubKeyIn)\n+{\n+    nValue = nValueIn;\n+    scriptPubKey = scriptPubKeyIn;\n+}\n+\n+uint256 CTxOut::GetHash() const\n+{\n+    return SerializeHash(*this);\n+}\n+\n+std::string CTxOut::ToString() const\n+{\n+    if (scriptPubKey.size() < 6)\n+        return \"CTxOut(error)\";\n+    return strprintf(\"CTxOut(nValue=%\"PRI64d\".%08\"PRI64d\", scriptPubKey=%s)\", nValue / COIN, nValue % COIN, scriptPubKey.ToString().substr(0,30).c_str());\n+}\n+\n+void CTxOut::print() const\n+{\n+    printf(\"%s\\n\", ToString().c_str());\n+}\n+\n+uint256 CTransaction::GetHash() const\n+{\n+    return SerializeHash(*this);\n+}\n+\n+bool CTransaction::IsNewerThan(const CTransaction& old) const\n+{\n+    if (vin.size() != old.vin.size())\n+        return false;\n+    for (unsigned int i = 0; i < vin.size(); i++)\n+        if (vin[i].prevout != old.vin[i].prevout)\n+            return false;\n+\n+    bool fNewer = false;\n+    unsigned int nLowest = std::numeric_limits<unsigned int>::max();\n+    for (unsigned int i = 0; i < vin.size(); i++)\n+    {\n+        if (vin[i].nSequence != old.vin[i].nSequence)\n+        {\n+            if (vin[i].nSequence <= nLowest)\n+            {\n+                fNewer = false;\n+                nLowest = vin[i].nSequence;\n+            }\n+            if (old.vin[i].nSequence < nLowest)\n+            {\n+                fNewer = true;\n+                nLowest = old.vin[i].nSequence;\n+            }\n+        }\n+    }\n+    return fNewer;\n+}\n+\n+std::string CTransaction::ToString() const\n+{\n+    std::string str;\n+    str += strprintf(\"CTransaction(hash=%s, ver=%d, vin.size=%\"PRIszu\", vout.size=%\"PRIszu\", nLockTime=%u)\\n\",\n+        GetHash().ToString().substr(0,10).c_str(),\n+        nVersion,\n+        vin.size(),\n+        vout.size(),\n+        nLockTime);\n+    for (unsigned int i = 0; i < vin.size(); i++)\n+        str += \"    \" + vin[i].ToString() + \"\\n\";\n+    for (unsigned int i = 0; i < vout.size(); i++)\n+        str += \"    \" + vout[i].ToString() + \"\\n\";\n+    return str;\n+}\n+\n+void CTransaction::print() const\n+{\n+    printf(\"%s\", ToString().c_str());\n+}\n+\n+// Amount compression:\n+// * If the amount is 0, output 0\n+// * first, divide the amount (in base units) by the largest power of 10 possible; call the exponent e (e is max 9)\n+// * if e<9, the last digit of the resulting number cannot be 0; store it as d, and drop it (divide by 10)\n+//   * call the result n\n+//   * output 1 + 10*(9*n + d - 1) + e\n+// * if e==9, we only know the resulting number is not zero, so output 1 + 10*(n - 1) + 9\n+// (this is decodable, as d is in [1-9] and e is in [0-9])\n+\n+uint64 CTxOutCompressor::CompressAmount(uint64 n)\n+{\n+    if (n == 0)\n+        return 0;\n+    int e = 0;\n+    while (((n % 10) == 0) && e < 9) {\n+        n /= 10;\n+        e++;\n+    }\n+    if (e < 9) {\n+        int d = (n % 10);\n+        assert(d >= 1 && d <= 9);\n+        n /= 10;\n+        return 1 + (n*9 + d - 1)*10 + e;\n+    } else {\n+        return 1 + (n - 1)*10 + 9;\n+    }\n+}\n+\n+uint64 CTxOutCompressor::DecompressAmount(uint64 x)\n+{\n+    // x = 0  OR  x = 1+10*(9*n + d - 1) + e  OR  x = 1+10*(n - 1) + 9\n+    if (x == 0)\n+        return 0;\n+    x--;\n+    // x = 10*(9*n + d - 1) + e\n+    int e = x % 10;\n+    x /= 10;\n+    uint64 n = 0;\n+    if (e < 9) {\n+        // x = 9*n + d - 1\n+        int d = (x % 9) + 1;\n+        x /= 9;\n+        // x = n\n+        n = x*10 + d;\n+    } else {\n+        n = x+1;\n+    }\n+    while (e) {\n+        n *= 10;\n+        e--;\n+    }\n+    return n;\n+}\n+\n+// calculate number of bytes for the bitmask, and its number of non-zero bytes\n+// each bit in the bitmask represents the availability of one output, but the\n+// availabilities of the first two outputs are encoded separately\n+void CCoins::CalcMaskSize(unsigned int &nBytes, unsigned int &nNonzeroBytes) const {\n+    unsigned int nLastUsedByte = 0;\n+    for (unsigned int b = 0; 2+b*8 < vout.size(); b++) {\n+        bool fZero = true;\n+        for (unsigned int i = 0; i < 8 && 2+b*8+i < vout.size(); i++) {\n+            if (!vout[2+b*8+i].IsNull()) {\n+                fZero = false;\n+                continue;\n+            }\n+        }\n+        if (!fZero) {\n+            nLastUsedByte = b + 1;\n+            nNonzeroBytes++;\n+        }\n+    }\n+    nBytes += nLastUsedByte;\n+}\n+\n+bool CCoins::Spend(const COutPoint &out, CTxInUndo &undo) {\n+    if (out.n >= vout.size())\n+        return false;\n+    if (vout[out.n].IsNull())\n+        return false;\n+    undo = CTxInUndo(vout[out.n]);\n+    vout[out.n].SetNull();\n+    Cleanup();\n+    if (vout.size() == 0) {\n+        undo.nHeight = nHeight;\n+        undo.fCoinBase = fCoinBase;\n+        undo.nVersion = this->nVersion;\n+    }\n+    return true;\n+}\n+\n+bool CCoins::Spend(int nPos) {\n+    CTxInUndo undo;\n+    COutPoint out(0, nPos);\n+    return Spend(out, undo);\n+}\n+\n+uint256 CBlockHeader::GetHash() const\n+{\n+    return Hash(BEGIN(nVersion), END(nNonce));\n+}\n+\n+uint256 CBlock::BuildMerkleTree() const\n+{\n+    vMerkleTree.clear();\n+    BOOST_FOREACH(const CTransaction& tx, vtx)\n+        vMerkleTree.push_back(tx.GetHash());\n+    int j = 0;\n+    for (int nSize = vtx.size(); nSize > 1; nSize = (nSize + 1) / 2)\n+    {\n+        for (int i = 0; i < nSize; i += 2)\n+        {\n+            int i2 = std::min(i+1, nSize-1);\n+            vMerkleTree.push_back(Hash(BEGIN(vMerkleTree[j+i]),  END(vMerkleTree[j+i]),\n+                                       BEGIN(vMerkleTree[j+i2]), END(vMerkleTree[j+i2])));\n+        }\n+        j += nSize;\n+    }\n+    return (vMerkleTree.empty() ? 0 : vMerkleTree.back());\n+}\n+\n+std::vector<uint256> CBlock::GetMerkleBranch(int nIndex) const\n+{\n+    if (vMerkleTree.empty())\n+        BuildMerkleTree();\n+    std::vector<uint256> vMerkleBranch;\n+    int j = 0;\n+    for (int nSize = vtx.size(); nSize > 1; nSize = (nSize + 1) / 2)\n+    {\n+        int i = std::min(nIndex^1, nSize-1);\n+        vMerkleBranch.push_back(vMerkleTree[j+i]);\n+        nIndex >>= 1;\n+        j += nSize;\n+    }\n+    return vMerkleBranch;\n+}\n+\n+uint256 CBlock::CheckMerkleBranch(uint256 hash, const std::vector<uint256>& vMerkleBranch, int nIndex)\n+{\n+    if (nIndex == -1)\n+        return 0;\n+    BOOST_FOREACH(const uint256& otherside, vMerkleBranch)\n+    {\n+        if (nIndex & 1)\n+            hash = Hash(BEGIN(otherside), END(otherside), BEGIN(hash), END(hash));\n+        else\n+            hash = Hash(BEGIN(hash), END(hash), BEGIN(otherside), END(otherside));\n+        nIndex >>= 1;\n+    }\n+    return hash;\n+}\n+\n+void CBlock::print() const\n+{\n+    printf(\"CBlock(hash=%s, ver=%d, hashPrevBlock=%s, hashMerkleRoot=%s, nTime=%u, nBits=%08x, nNonce=%u, vtx=%\"PRIszu\")\\n\",\n+        GetHash().ToString().c_str(),\n+        nVersion,\n+        hashPrevBlock.ToString().c_str(),\n+        hashMerkleRoot.ToString().c_str(),\n+        nTime, nBits, nNonce,\n+        vtx.size());\n+    for (unsigned int i = 0; i < vtx.size(); i++)\n+    {\n+        printf(\"  \");\n+        vtx[i].print();\n+    }\n+    printf(\"  vMerkleTree: \");\n+    for (unsigned int i = 0; i < vMerkleTree.size(); i++)\n+        printf(\"%s \", vMerkleTree[i].ToString().c_str());\n+    printf(\"\\n\");\n+}"
      },
      {
        "sha": "1b9d4dd765b4e87d76e0c8d6de91c94e0ca0d9b7",
        "filename": "src/core.h",
        "status": "modified",
        "additions": 22,
        "deletions": 227,
        "changes": 249,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f121db58e4b0baeb0834ab670cff3df8a7495457/src/core.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f121db58e4b0baeb0834ab670cff3df8a7495457/src/core.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core.h?ref=f121db58e4b0baeb0834ab670cff3df8a7495457",
        "patch": "@@ -7,7 +7,6 @@\n \n #include \"uint256.h\"\n #include \"serialize.h\"\n-#include \"util.h\"\n #include \"script.h\"\n \n #include <stdio.h>\n@@ -42,15 +41,8 @@ class COutPoint\n         return !(a == b);\n     }\n \n-    std::string ToString() const\n-    {\n-        return strprintf(\"COutPoint(%s, %u)\", hash.ToString().substr(0,10).c_str(), n);\n-    }\n-\n-    void print() const\n-    {\n-        printf(\"%s\\n\", ToString().c_str());\n-    }\n+    std::string ToString() const;\n+    void print() const;\n };\n \n /** An inpoint - a combination of a transaction and an index n into its vin */\n@@ -82,19 +74,8 @@ class CTxIn\n         nSequence = std::numeric_limits<unsigned int>::max();\n     }\n \n-    explicit CTxIn(COutPoint prevoutIn, CScript scriptSigIn=CScript(), unsigned int nSequenceIn=std::numeric_limits<unsigned int>::max())\n-    {\n-        prevout = prevoutIn;\n-        scriptSig = scriptSigIn;\n-        nSequence = nSequenceIn;\n-    }\n-\n-    CTxIn(uint256 hashPrevTx, unsigned int nOut, CScript scriptSigIn=CScript(), unsigned int nSequenceIn=std::numeric_limits<unsigned int>::max())\n-    {\n-        prevout = COutPoint(hashPrevTx, nOut);\n-        scriptSig = scriptSigIn;\n-        nSequence = nSequenceIn;\n-    }\n+    explicit CTxIn(COutPoint prevoutIn, CScript scriptSigIn=CScript(), unsigned int nSequenceIn=std::numeric_limits<unsigned int>::max());\n+    CTxIn(uint256 hashPrevTx, unsigned int nOut, CScript scriptSigIn=CScript(), unsigned int nSequenceIn=std::numeric_limits<unsigned int>::max());\n \n     IMPLEMENT_SERIALIZE\n     (\n@@ -120,25 +101,8 @@ class CTxIn\n         return !(a == b);\n     }\n \n-    std::string ToString() const\n-    {\n-        std::string str;\n-        str += \"CTxIn(\";\n-        str += prevout.ToString();\n-        if (prevout.IsNull())\n-            str += strprintf(\", coinbase %s\", HexStr(scriptSig).c_str());\n-        else\n-            str += strprintf(\", scriptSig=%s\", scriptSig.ToString().substr(0,24).c_str());\n-        if (nSequence != std::numeric_limits<unsigned int>::max())\n-            str += strprintf(\", nSequence=%u\", nSequence);\n-        str += \")\";\n-        return str;\n-    }\n-\n-    void print() const\n-    {\n-        printf(\"%s\\n\", ToString().c_str());\n-    }\n+    std::string ToString() const;\n+    void print() const;\n };\n \n \n@@ -158,11 +122,7 @@ class CTxOut\n         SetNull();\n     }\n \n-    CTxOut(int64 nValueIn, CScript scriptPubKeyIn)\n-    {\n-        nValue = nValueIn;\n-        scriptPubKey = scriptPubKeyIn;\n-    }\n+    CTxOut(int64 nValueIn, CScript scriptPubKeyIn);\n \n     IMPLEMENT_SERIALIZE\n     (\n@@ -181,10 +141,7 @@ class CTxOut\n         return (nValue == -1);\n     }\n \n-    uint256 GetHash() const\n-    {\n-        return SerializeHash(*this);\n-    }\n+    uint256 GetHash() const;\n \n     bool IsDust(int64 nMinRelayTxFee) const\n     {\n@@ -210,17 +167,8 @@ class CTxOut\n         return !(a == b);\n     }\n \n-    std::string ToString() const\n-    {\n-        if (scriptPubKey.size() < 6)\n-            return \"CTxOut(error)\";\n-        return strprintf(\"CTxOut(nValue=%\"PRI64d\".%08\"PRI64d\", scriptPubKey=%s)\", nValue / COIN, nValue % COIN, scriptPubKey.ToString().substr(0,30).c_str());\n-    }\n-\n-    void print() const\n-    {\n-        printf(\"%s\\n\", ToString().c_str());\n-    }\n+    std::string ToString() const;\n+    void print() const;\n };\n \n \n@@ -265,39 +213,8 @@ class CTransaction\n         return (vin.empty() && vout.empty());\n     }\n \n-    uint256 GetHash() const\n-    {\n-        return SerializeHash(*this);\n-    }\n-\n-    bool IsNewerThan(const CTransaction& old) const\n-    {\n-        if (vin.size() != old.vin.size())\n-            return false;\n-        for (unsigned int i = 0; i < vin.size(); i++)\n-            if (vin[i].prevout != old.vin[i].prevout)\n-                return false;\n-\n-        bool fNewer = false;\n-        unsigned int nLowest = std::numeric_limits<unsigned int>::max();\n-        for (unsigned int i = 0; i < vin.size(); i++)\n-        {\n-            if (vin[i].nSequence != old.vin[i].nSequence)\n-            {\n-                if (vin[i].nSequence <= nLowest)\n-                {\n-                    fNewer = false;\n-                    nLowest = vin[i].nSequence;\n-                }\n-                if (old.vin[i].nSequence < nLowest)\n-                {\n-                    fNewer = true;\n-                    nLowest = old.vin[i].nSequence;\n-                }\n-            }\n-        }\n-        return fNewer;\n-    }\n+    uint256 GetHash() const;\n+    bool IsNewerThan(const CTransaction& old) const;\n \n     bool IsCoinBase() const\n     {\n@@ -318,26 +235,8 @@ class CTransaction\n     }\n \n \n-    std::string ToString() const\n-    {\n-        std::string str;\n-        str += strprintf(\"CTransaction(hash=%s, ver=%d, vin.size=%\"PRIszu\", vout.size=%\"PRIszu\", nLockTime=%u)\\n\",\n-            GetHash().ToString().substr(0,10).c_str(),\n-            nVersion,\n-            vin.size(),\n-            vout.size(),\n-            nLockTime);\n-        for (unsigned int i = 0; i < vin.size(); i++)\n-            str += \"    \" + vin[i].ToString() + \"\\n\";\n-        for (unsigned int i = 0; i < vout.size(); i++)\n-            str += \"    \" + vout[i].ToString() + \"\\n\";\n-        return str;\n-    }\n-\n-    void print() const\n-    {\n-        printf(\"%s\", ToString().c_str());\n-    }\n+    std::string ToString() const;\n+    void print() const;\n };\n \n /** wrapper for CTxOut that provides a more compact serialization */\n@@ -521,26 +420,7 @@ class CCoins\n         return !(a == b);\n     }\n \n-    // calculate number of bytes for the bitmask, and its number of non-zero bytes\n-    // each bit in the bitmask represents the availability of one output, but the\n-    // availabilities of the first two outputs are encoded separately\n-    void CalcMaskSize(unsigned int &nBytes, unsigned int &nNonzeroBytes) const {\n-        unsigned int nLastUsedByte = 0;\n-        for (unsigned int b = 0; 2+b*8 < vout.size(); b++) {\n-            bool fZero = true;\n-            for (unsigned int i = 0; i < 8 && 2+b*8+i < vout.size(); i++) {\n-                if (!vout[2+b*8+i].IsNull()) {\n-                    fZero = false;\n-                    continue;\n-                }\n-            }\n-            if (!fZero) {\n-                nLastUsedByte = b + 1;\n-                nNonzeroBytes++;\n-            }\n-        }\n-        nBytes += nLastUsedByte;\n-    }\n+    void CalcMaskSize(unsigned int &nBytes, unsigned int &nNonzeroBytes) const;\n \n     bool IsCoinBase() const {\n         return fCoinBase;\n@@ -633,28 +513,10 @@ class CCoins\n     }\n \n     // mark an outpoint spent, and construct undo information\n-    bool Spend(const COutPoint &out, CTxInUndo &undo) {\n-        if (out.n >= vout.size())\n-            return false;\n-        if (vout[out.n].IsNull())\n-            return false;\n-        undo = CTxInUndo(vout[out.n]);\n-        vout[out.n].SetNull();\n-        Cleanup();\n-        if (vout.size() == 0) {\n-            undo.nHeight = nHeight;\n-            undo.fCoinBase = fCoinBase;\n-            undo.nVersion = this->nVersion;\n-        }\n-        return true;\n-    }\n+    bool Spend(const COutPoint &out, CTxInUndo &undo);\n \n     // mark a vout spent\n-    bool Spend(int nPos) {\n-        CTxInUndo undo;\n-        COutPoint out(0, nPos);\n-        return Spend(out, undo);\n-    }\n+    bool Spend(int nPos);\n \n     // check whether a particular output is still available\n     bool IsAvailable(unsigned int nPos) const {\n@@ -722,10 +584,7 @@ class CBlockHeader\n         return (nBits == 0);\n     }\n \n-    uint256 GetHash() const\n-    {\n-        return Hash(BEGIN(nVersion), END(nNonce));\n-    }\n+    uint256 GetHash() const;\n \n     int64 GetBlockTime() const\n     {\n@@ -779,81 +638,17 @@ class CBlock : public CBlockHeader\n         return block;\n     }\n \n-    uint256 BuildMerkleTree() const\n-    {\n-        vMerkleTree.clear();\n-        BOOST_FOREACH(const CTransaction& tx, vtx)\n-            vMerkleTree.push_back(tx.GetHash());\n-        int j = 0;\n-        for (int nSize = vtx.size(); nSize > 1; nSize = (nSize + 1) / 2)\n-        {\n-            for (int i = 0; i < nSize; i += 2)\n-            {\n-                int i2 = std::min(i+1, nSize-1);\n-                vMerkleTree.push_back(Hash(BEGIN(vMerkleTree[j+i]),  END(vMerkleTree[j+i]),\n-                                           BEGIN(vMerkleTree[j+i2]), END(vMerkleTree[j+i2])));\n-            }\n-            j += nSize;\n-        }\n-        return (vMerkleTree.empty() ? 0 : vMerkleTree.back());\n-    }\n+    uint256 BuildMerkleTree() const;\n \n     const uint256 &GetTxHash(unsigned int nIndex) const {\n         assert(vMerkleTree.size() > 0); // BuildMerkleTree must have been called first\n         assert(nIndex < vtx.size());\n         return vMerkleTree[nIndex];\n     }\n \n-    std::vector<uint256> GetMerkleBranch(int nIndex) const\n-    {\n-        if (vMerkleTree.empty())\n-            BuildMerkleTree();\n-        std::vector<uint256> vMerkleBranch;\n-        int j = 0;\n-        for (int nSize = vtx.size(); nSize > 1; nSize = (nSize + 1) / 2)\n-        {\n-            int i = std::min(nIndex^1, nSize-1);\n-            vMerkleBranch.push_back(vMerkleTree[j+i]);\n-            nIndex >>= 1;\n-            j += nSize;\n-        }\n-        return vMerkleBranch;\n-    }\n-\n-    static uint256 CheckMerkleBranch(uint256 hash, const std::vector<uint256>& vMerkleBranch, int nIndex)\n-    {\n-        if (nIndex == -1)\n-            return 0;\n-        BOOST_FOREACH(const uint256& otherside, vMerkleBranch)\n-        {\n-            if (nIndex & 1)\n-                hash = Hash(BEGIN(otherside), END(otherside), BEGIN(hash), END(hash));\n-            else\n-                hash = Hash(BEGIN(hash), END(hash), BEGIN(otherside), END(otherside));\n-            nIndex >>= 1;\n-        }\n-        return hash;\n-    }\n-\n-    void print() const\n-    {\n-        printf(\"CBlock(hash=%s, ver=%d, hashPrevBlock=%s, hashMerkleRoot=%s, nTime=%u, nBits=%08x, nNonce=%u, vtx=%\"PRIszu\")\\n\",\n-            GetHash().ToString().c_str(),\n-            nVersion,\n-            hashPrevBlock.ToString().c_str(),\n-            hashMerkleRoot.ToString().c_str(),\n-            nTime, nBits, nNonce,\n-            vtx.size());\n-        for (unsigned int i = 0; i < vtx.size(); i++)\n-        {\n-            printf(\"  \");\n-            vtx[i].print();\n-        }\n-        printf(\"  vMerkleTree: \");\n-        for (unsigned int i = 0; i < vMerkleTree.size(); i++)\n-            printf(\"%s \", vMerkleTree[i].ToString().c_str());\n-        printf(\"\\n\");\n-    }\n+    std::vector<uint256> GetMerkleBranch(int nIndex) const;\n+    static uint256 CheckMerkleBranch(uint256 hash, const std::vector<uint256>& vMerkleBranch, int nIndex);\n+    void print() const;\n };\n \n #endif"
      },
      {
        "sha": "cadefe6deede4c26c5344fb62e1b487eb58bbc3d",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 53,
        "changes": 53,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f121db58e4b0baeb0834ab670cff3df8a7495457/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f121db58e4b0baeb0834ab670cff3df8a7495457/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=f121db58e4b0baeb0834ab670cff3df8a7495457",
        "patch": "@@ -4737,59 +4737,6 @@ void GenerateBitcoins(bool fGenerate, CWallet* pwallet)\n         minerThreads->create_thread(boost::bind(&BitcoinMiner, pwallet));\n }\n \n-// Amount compression:\n-// * If the amount is 0, output 0\n-// * first, divide the amount (in base units) by the largest power of 10 possible; call the exponent e (e is max 9)\n-// * if e<9, the last digit of the resulting number cannot be 0; store it as d, and drop it (divide by 10)\n-//   * call the result n\n-//   * output 1 + 10*(9*n + d - 1) + e\n-// * if e==9, we only know the resulting number is not zero, so output 1 + 10*(n - 1) + 9\n-// (this is decodable, as d is in [1-9] and e is in [0-9])\n-\n-uint64 CTxOutCompressor::CompressAmount(uint64 n)\n-{\n-    if (n == 0)\n-        return 0;\n-    int e = 0;\n-    while (((n % 10) == 0) && e < 9) {\n-        n /= 10;\n-        e++;\n-    }\n-    if (e < 9) {\n-        int d = (n % 10);\n-        assert(d >= 1 && d <= 9);\n-        n /= 10;\n-        return 1 + (n*9 + d - 1)*10 + e;\n-    } else {\n-        return 1 + (n - 1)*10 + 9;\n-    }\n-}\n-\n-uint64 CTxOutCompressor::DecompressAmount(uint64 x)\n-{\n-    // x = 0  OR  x = 1+10*(9*n + d - 1) + e  OR  x = 1+10*(n - 1) + 9\n-    if (x == 0)\n-        return 0;\n-    x--;\n-    // x = 10*(9*n + d - 1) + e\n-    int e = x % 10;\n-    x /= 10;\n-    uint64 n = 0;\n-    if (e < 9) {\n-        // x = 9*n + d - 1\n-        int d = (x % 9) + 1;\n-        x /= 9;\n-        // x = n\n-        n = x*10 + d;\n-    } else {\n-        n = x+1;\n-    }\n-    while (e) {\n-        n *= 10;\n-        e--;\n-    }\n-    return n;\n-}\n \n \n class CMainCleanup"
      }
    ]
  }
]