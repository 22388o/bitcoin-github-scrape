[
  {
    "sha": "1966c325a4e5e9de7c89f98869663272d33fab94",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxOTY2YzMyNWE0ZTVlOWRlN2M4OWY5ODg2OTY2MzI3MmQzM2ZhYjk0",
    "commit": {
      "author": {
        "name": "Brandon Dahler",
        "email": "brandon.dahler@gmail.com",
        "date": "2013-03-03T23:07:56Z"
      },
      "committer": {
        "name": "Brandon Dahler",
        "email": "brandon.dahler@gmail.com",
        "date": "2013-04-07T05:23:09Z"
      },
      "message": "Add bandwidth manager to allow capping of outbound bandwidth, allow resetting of statistics based on a cron-like expression.",
      "tree": {
        "sha": "97ea48b8a35b2399267522e745807882755cd5d2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/97ea48b8a35b2399267522e745807882755cd5d2"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1966c325a4e5e9de7c89f98869663272d33fab94",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1966c325a4e5e9de7c89f98869663272d33fab94",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1966c325a4e5e9de7c89f98869663272d33fab94",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1966c325a4e5e9de7c89f98869663272d33fab94/comments",
    "author": {
      "login": "brandondahler",
      "id": 1155895,
      "node_id": "MDQ6VXNlcjExNTU4OTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1155895?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/brandondahler",
      "html_url": "https://github.com/brandondahler",
      "followers_url": "https://api.github.com/users/brandondahler/followers",
      "following_url": "https://api.github.com/users/brandondahler/following{/other_user}",
      "gists_url": "https://api.github.com/users/brandondahler/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/brandondahler/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/brandondahler/subscriptions",
      "organizations_url": "https://api.github.com/users/brandondahler/orgs",
      "repos_url": "https://api.github.com/users/brandondahler/repos",
      "events_url": "https://api.github.com/users/brandondahler/events{/privacy}",
      "received_events_url": "https://api.github.com/users/brandondahler/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "brandondahler",
      "id": 1155895,
      "node_id": "MDQ6VXNlcjExNTU4OTU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1155895?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/brandondahler",
      "html_url": "https://github.com/brandondahler",
      "followers_url": "https://api.github.com/users/brandondahler/followers",
      "following_url": "https://api.github.com/users/brandondahler/following{/other_user}",
      "gists_url": "https://api.github.com/users/brandondahler/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/brandondahler/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/brandondahler/subscriptions",
      "organizations_url": "https://api.github.com/users/brandondahler/orgs",
      "repos_url": "https://api.github.com/users/brandondahler/repos",
      "events_url": "https://api.github.com/users/brandondahler/events{/privacy}",
      "received_events_url": "https://api.github.com/users/brandondahler/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "dfd71bb4509d12c26e630bc671a542ad5bab4945",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dfd71bb4509d12c26e630bc671a542ad5bab4945",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/dfd71bb4509d12c26e630bc671a542ad5bab4945"
      }
    ],
    "stats": {
      "total": 1344,
      "additions": 1269,
      "deletions": 75
    },
    "files": [
      {
        "sha": "443dbbd8587802728161a03fbe4c7e3c8408670b",
        "filename": "src/bandwidthman.cpp",
        "status": "added",
        "additions": 765,
        "deletions": 0,
        "changes": 765,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1966c325a4e5e9de7c89f98869663272d33fab94/src/bandwidthman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1966c325a4e5e9de7c89f98869663272d33fab94/src/bandwidthman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bandwidthman.cpp?ref=1966c325a4e5e9de7c89f98869663272d33fab94",
        "patch": "@@ -0,0 +1,765 @@\n+#include \"bandwidthman.h\"\n+\n+#include \"db.h\"\n+#include \"net.h\"\n+\n+#include <sstream>\n+\n+using namespace std;\n+\n+const time_t nZero = 0;\n+\n+CBandwidthMan::CBandwidthMan()\n+{\n+}\n+\n+void CBandwidthMan::LoadConfiguration()\n+{\n+    if (mapArgs.count(\"-bandwidthresettimes\"))\n+    {\n+        try\n+        {\n+            ParseResetTimes(mapArgs[\"-bandwidthresettimes\"]);\n+            PrintResetTimes();\n+        } catch (const char* ex) {\n+            printf(\"%s.\\n\", ex);\n+        }\n+    }\n+\n+    if (mapArgs.count(\"-bandwidthsentmax\"))\n+    {\n+        nMaxTotalSentBytes = ParseBandwidthValue(mapArgs[\"-bandwidthsentmax\"]);\n+    } else {\n+        nMaxTotalSentBytes = (uint64) -1;\n+    }\n+\n+    for (map<string, string>::iterator it = mapArgs.begin(); it != mapArgs.end(); ++it)\n+    {\n+        if (it->first.substr(0, 18) == \"-bandwidthsentmax_\")\n+            mapMaxCommandSentBytes[it->first.substr(18)] = ParseBandwidthValue(it->second);\n+    }\n+     \n+    \n+}\n+\n+CBandwidthMan::SchedulingTestData CBandwidthMan::TestScheduling(string strCronLine, struct tm tmTestTime)\n+{\n+    SchedulingTestData stdTestData;\n+\n+    LOCK(cs);\n+\n+    // Save current data to be resored later\n+    ResetInformation riOldResetTimes = riResetTimes;\n+    time_t nOldTrackingStartTime = nTrackingStartTime;\n+    time_t nOldTrackingResetTime = nTrackingResetTime;\n+\n+    // Test using passed in values\n+    ParseResetTimes(strCronLine);\n+    RecalculateStartResetTimes(&tmTestTime);\n+\n+    // Save test data\n+    stdTestData.riResetTimes = riResetTimes;\n+    stdTestData.nTrackingStartTime = nTrackingStartTime;\n+    stdTestData.nTrackingResetTime = nTrackingResetTime;\n+\n+    // Reset data to old values\n+    riResetTimes = riOldResetTimes;\n+    nTrackingStartTime = nOldTrackingStartTime;\n+    nTrackingResetTime = nOldTrackingResetTime;\n+\n+    \n+    return stdTestData;\n+}\n+\n+// Determine if we should be allowed to send command.\n+//   Returns true if allowed to be sent, data asummed to be send if allowed by the function.\n+bool CBandwidthMan::AllowSendCommand(string strCommand, int nSize)\n+{\n+    if (time(NULL) > nTrackingResetTime)\n+        ResetTrackingStatistics();\n+\n+///// Temp\n+    int64 nStart = GetTimeMillis();\n+\n+    CBandwidthDB bdb;\n+    bdb.Write(bandwidthman);\n+\n+    printf(\"Flushed bandwidth info to bandwidth.dat  %\"PRI64d\"ms\\n\",\n+           GetTimeMillis() - nStart);\n+///// End temp\n+    \n+    if (nTotalSentBytes >= nMaxTotalSentBytes)\n+        return false;\n+\n+    if (mapMaxCommandSentBytes.count(strCommand) && mapCommandSentBytes[strCommand] + nSize >= mapMaxCommandSentBytes[strCommand])\n+        return false;\n+\n+    cout << strCommand << \" was \" << mapCommandSentBytes[strCommand] << \" and now is \" << mapCommandSentBytes[strCommand] + nSize << endl;\n+    nTotalSentBytes += nSize;\n+    mapCommandSentBytes[strCommand] += nSize;\n+    return true;\n+}\n+\n+\n+void CBandwidthMan::ParseResetTimes(string strResetTimes)\n+{\n+    const char nStartValues[]  = { 0,  0,  1,  1, 0};\n+    const char nModValues[]    = {60, 24, 31, 12, 7};\n+    const char nOffsetValues[] = { 0,  0,  0, -1, 0};\n+\n+    // minutes      hours       dayOfMonth  Month   dayOfWeek\n+    // 0            0           1           *       *           // Resets each month\n+    // *            *           *           *       *           // Resets each minutes\n+    // */5          *           *           *       *           // Resets every 5 minutes\n+    istringstream isResetTimes(strResetTimes);\n+\n+    for (int x = 0; x < 5; ++x)\n+    {\n+        string strResetTimesElement;\n+        isResetTimes >> strResetTimesElement;\n+\n+        set<char>* psetCurrentUnit;\n+        switch (x)\n+        {\n+            case 0:\n+                psetCurrentUnit = &riResetTimes.setMinutes;\n+                break;\n+            case 1:\n+                psetCurrentUnit = &riResetTimes.setHours;\n+                break;\n+            case 2:\n+                psetCurrentUnit = &riResetTimes.setDaysOfMonth;\n+                break;\n+           case 3:\n+                psetCurrentUnit = &riResetTimes.setMonths;\n+                break;\n+           case 4:\n+                psetCurrentUnit = &riResetTimes.setDaysOfWeek;\n+                break;\n+        }\n+\n+        int nFrom = -1;\n+        int nTo = -1;\n+        int nSkip = 0;\n+        \n+        for (size_t y = 0; y < strResetTimesElement.length(); ++y)\n+        {\n+            if (strResetTimesElement[y] == '*')\n+            {\n+                if (y != 0)\n+                    throw \"Unable to parse reset times string1\";\n+\n+                nFrom = nStartValues[x];\n+                nTo = nStartValues[x] + nModValues[x] - 1;\n+                nSkip = 1;\n+\n+            } else if (strResetTimesElement[y] >= '0' && strResetTimesElement[y] <= '9') {\n+                int nParsedNumber = 0;\n+\n+                do\n+                {\n+                    nParsedNumber *= 10;\n+                    nParsedNumber += (int) (strResetTimesElement[y] - '0');\n+\n+                    ++y;\n+                } while (y < strResetTimesElement.length() && strResetTimesElement[y] >= '0' && strResetTimesElement[y] <= '9');\n+                \n+                --y;\n+                nParsedNumber %= nModValues[x];\n+\n+                if (nFrom < 0)\n+                    nFrom = nParsedNumber;\n+                else\n+                    nTo = nParsedNumber;\n+                \n+                nSkip = 1;\n+\n+            } else if (strResetTimesElement[y] == '/') {\n+                printf(\"%d: / found.\\n\", x);\n+                if (y == strResetTimesElement.length() - 1 || strResetTimesElement[y+1] < '0' || strResetTimesElement[y+1] > '9')\n+                    throw \"Unable to parse reset times string3\";\n+                \n+                nSkip = 0;\n+                ++y;\n+\n+                do\n+                {\n+                    nSkip *= 10;\n+                    nSkip += (int) (strResetTimesElement[y] - '0');\n+\n+                    ++y;\n+                } while (y < strResetTimesElement.length() && strResetTimesElement[y] >= '0' && strResetTimesElement[y] <= '9');\n+\n+                if (nSkip >= nStartValues[x] + nModValues[x])\n+                {\n+                    nSkip -= nStartValues[x];\n+                    nSkip %= nModValues[x];\n+                    nSkip += nStartValues[x];\n+                }\n+                printf(\"From %d, To %d, Skip %d\\n\", nFrom, nTo, nSkip);\n+\n+                if (y != strResetTimesElement.length() && strResetTimesElement[y] != ',')\n+                    throw \"Unable to parse reset times string4\";\n+\n+            } else if (strResetTimesElement[y] == '-') {\n+                if (nTo > 0 || y == strResetTimesElement.length() - 1)\n+                    throw \"Unable to parse reset times string5\";\n+            } else if (strResetTimesElement[y] == ',') {\n+                if (y == strResetTimesElement.length() - 1)\n+                    throw \"Unable to parse reset times string9\";\n+\n+                AddResetTimesRange(nFrom, nTo, nSkip, psetCurrentUnit, nStartValues[x], nModValues[x], nOffsetValues[x]);\n+\n+                nFrom = -1;\n+                nTo = -1;\n+                nSkip = 0;\n+            }\n+        }\n+        \n+        AddResetTimesRange(nFrom, nTo, nSkip, psetCurrentUnit, nStartValues[x], nModValues[x], nOffsetValues[x]);\n+    }\n+}\n+\n+void CBandwidthMan::PrintResetTimes() const\n+{\n+    const set<char>* psetCurrentUnit[] = {&riResetTimes.setMinutes, &riResetTimes.setHours, &riResetTimes.setDaysOfMonth, &riResetTimes.setMonths, &riResetTimes.setDaysOfWeek};\n+    for (unsigned int x = 0; x < sizeof(psetCurrentUnit); ++x)\n+    {\n+\n+        printf(\"Unit %d values:\\n\\t\", x);\n+        for (set<char>::const_iterator it = psetCurrentUnit[x]->begin(); it != psetCurrentUnit[x]->end(); ++it)\n+            printf(\"%hhd, \", *it);\n+    \n+        printf(\"\\n\\n\");\n+    }\n+}\n+\n+void CBandwidthMan::PrintCurrentBandwidth() const\n+{\n+    printf(\"Bandwidth Caps (size=%d):\\n\", mapMaxCommandSentBytes.size());\n+\n+    for (map<string, uint64>::const_iterator it = mapMaxCommandSentBytes.begin(); it != mapMaxCommandSentBytes.end(); ++it)\n+        printf(\"\\t%s - %lld\\n\", it->first.c_str(), it->second);\n+\n+    printf(\"\\tTotal - %lld\\n\", nMaxTotalSentBytes);\n+\n+\n+    printf(\"Bandwidth map (size=%d):\\n\", mapCommandSentBytes.size());\n+\n+    for (map<string, uint64>::const_iterator it = mapCommandSentBytes.begin(); it != mapCommandSentBytes.end(); ++it)\n+        printf(\"\\t%s - %lld\\n\", it->first.c_str(), it->second);\n+    \n+    printf(\"\\tTotal - %lld\\n\" , nTotalSentBytes);\n+    printf(\"\\n\");\n+}\n+\n+\n+\n+void CBandwidthMan::ResetTrackingStatistics()\n+{\n+    // Clear sent bytes map\n+    mapCommandSentBytes.clear();\n+    nTotalSentBytes = 0;\n+    \n+\n+    // Get current time to use in future calculations\n+    time_t nCurrentTime = time(NULL);\n+    struct tm tmCurrentTime;\n+    gmtime_r(&nCurrentTime, &tmCurrentTime);\n+    RecalculateStartResetTimes(&tmCurrentTime);\n+}\n+\n+void CBandwidthMan::RecalculateStartResetTimes(struct tm* ptmCurrentTime)\n+{\n+\n+    // Calculate previous reset time, this will be the new nTrackingStartTime\n+    {\n+        struct tm tmNewTrackingStartTime;\n+        gmtime_r(&nZero, &tmNewTrackingStartTime);\n+       \n+        // Set year to current year\n+        tmNewTrackingStartTime.tm_year = ptmCurrentTime->tm_year;\n+\n+        // Set month, adjust year if needed\n+        SetPreviousMonth(tmNewTrackingStartTime, ptmCurrentTime->tm_mon);\n+\n+        // Set day, adjust month and/or year if needed\n+        SetPreviousDay(tmNewTrackingStartTime, ptmCurrentTime, ptmCurrentTime->tm_mday);\n+\n+        // Set hour, adjust day, month, and/or year if needed\n+        SetPreviousHour(tmNewTrackingStartTime, ptmCurrentTime, ptmCurrentTime->tm_hour);\n+\n+        // Set minute, adjust hour, day, month, and/or year if needed\n+        SetPreviousMinute(tmNewTrackingStartTime, ptmCurrentTime, ptmCurrentTime->tm_min);\n+\n+        nTrackingStartTime = timegm(&tmNewTrackingStartTime);\n+    }\n+\n+\n+    // Calculate next reset time, this will be the new nTrackingResetTime\n+    {\n+        struct tm tmNewTrackingResetTime;\n+        gmtime_r(&nZero, &tmNewTrackingResetTime);\n+\n+        // Set minute, adjust hour, day, month, and/or year if needed\n+        SetNextMinute(tmNewTrackingResetTime, ptmCurrentTime->tm_min);\n+\n+        // Set hour, adjust day, month, and/or year if needed\n+        SetNextHour(tmNewTrackingResetTime, ptmCurrentTime, ptmCurrentTime->tm_hour);\n+        \n+        // Set day, adjust month and/or year if needed\n+        SetNextDay(tmNewTrackingResetTime, ptmCurrentTime, ptmCurrentTime->tm_mon, ptmCurrentTime->tm_year, ptmCurrentTime->tm_mday);\n+\n+        // Set month, adjust year if needed\n+        SetNextMonth(tmNewTrackingResetTime, ptmCurrentTime, ptmCurrentTime->tm_year, ptmCurrentTime->tm_mon);\n+\n+        // Set year to current yea\n+        SetNextYear(tmNewTrackingResetTime, ptmCurrentTime);\n+    \n+        nTrackingResetTime = timegm(&tmNewTrackingResetTime);\n+    }\n+}\n+\n+\n+char CBandwidthMan::LastDayOfMonth(int nYearSince1900, char nMonth)\n+{\n+    const char nDaysInMonth[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n+    int nYear = nYearSince1900 + 1900;\n+\n+    // Select the last valid day of the month\n+    char nLastDay = nDaysInMonth[(int) nMonth];\n+\n+    // Handle leap day\n+    if (nMonth == 1 && (nYear % 400 == 0 || (nYear % 100 != 0 && nYear % 4 == 0)))\n+        ++nLastDay;\n+\n+    return nLastDay;\n+}\n+\n+bool CBandwidthMan::DayIsFiltered(int nYearSince1900, char nMonth, char nDay)\n+{\n+    char nDayOfWeek;\n+    int nYear = nYearSince1900 + 1900;\n+\n+    // Use Zeller's algorithm to calculate day of week\n+    {\n+        // Shift year and month as required for algorithm\n+        if (nMonth < 2)\n+        {\n+            // Shift January and February by 13, subtract the year by one\n+            nMonth += 13;\n+            nYear -= 1;\n+        } else {\n+            // Shift other months by 1\n+            nMonth += 1;\n+        }\n+        \n+        char nYearLo = nYear % 100;\n+        int nYearHi = nYear / 100;\n+\n+        // Calculate via Zeller's algorithm\n+        nDayOfWeek = ( nDay + (((nMonth + 1) * 13) / 5) + nYearLo + (nYearLo / 4) + (nYearHi / 4) + (5 * nYearHi)) % 7;\n+\n+        // Shift day of week to start on Sunday instead of Saturday\n+        nDayOfWeek = (nDayOfWeek + 6) % 7;\n+    }\n+\n+    return (riResetTimes.setDaysOfWeek.find(nDayOfWeek) == riResetTimes.setDaysOfWeek.end());\n+}\n+\n+void CBandwidthMan::SetPreviousMonth(struct tm& tmNewTrackingStartTime, char nStartMonth)\n+{\n+    // Get the month after the current month\n+    set<char>::iterator itStartMonth = riResetTimes.setMonths.upper_bound(nStartMonth);\n+    \n+    // Loop iterator if at beginning, go to previous year and loop month to end\n+    if (itStartMonth == riResetTimes.setMonths.begin())\n+    {\n+        --tmNewTrackingStartTime.tm_year;\n+        itStartMonth = riResetTimes.setMonths.end();\n+    }\n+\n+    // Move to the current month (if valid) or the closest previous valid month\n+    --itStartMonth;\n+\n+    tmNewTrackingStartTime.tm_mon = *itStartMonth;\n+}\n+\n+void CBandwidthMan::SetPreviousDay(struct tm& tmNewTrackingStartTime, const struct tm* ptmCurrentTime, char nStartDay)\n+{\n+    set<char>::iterator itStartDay;\n+\n+    if (tmNewTrackingStartTime.tm_mon == ptmCurrentTime->tm_mon && tmNewTrackingStartTime.tm_year == ptmCurrentTime->tm_year)\n+    {\n+        // Get the day after the current day\n+        itStartDay = riResetTimes.setDaysOfMonth.upper_bound(nStartDay);\n+        \n+        // If iterator is not at beginning, use the current day or the previous valid\n+        if (itStartDay != riResetTimes.setDaysOfMonth.begin())\n+        {\n+            // Move to current day (if valid) or the closest previous valid day\n+            --itStartDay;\n+        } else {\n+            // Loop to the previous valid month, use last valid day (via fallthrough to next if statement below)\n+            SetPreviousMonth(tmNewTrackingStartTime, tmNewTrackingStartTime.tm_mon - 1);\n+        }\n+    }\n+\n+    // Make separate if, instead of else, to allow fallthrough from previous if statement\n+    if (tmNewTrackingStartTime.tm_mon != ptmCurrentTime->tm_mon || tmNewTrackingStartTime.tm_year != ptmCurrentTime->tm_year)\n+    {\n+        // Get the first valid day after the last day of the month\n+        itStartDay = riResetTimes.setDaysOfMonth.upper_bound(LastDayOfMonth(tmNewTrackingStartTime.tm_year, tmNewTrackingStartTime.tm_mon));\n+\n+        // Should never be at beginning of the set\n+        assert(itStartDay != riResetTimes.setDaysOfMonth.begin());\n+\n+        --itStartDay;\n+        \n+    }\n+\n+\n+    while (DayIsFiltered(tmNewTrackingStartTime.tm_year, tmNewTrackingStartTime.tm_mon, *itStartDay))\n+    {\n+        if (itStartDay == riResetTimes.setDaysOfMonth.begin())\n+        {\n+            SetPreviousMonth(tmNewTrackingStartTime, tmNewTrackingStartTime.tm_mon - 1);\n+            itStartDay = riResetTimes.setDaysOfMonth.upper_bound(LastDayOfMonth(tmNewTrackingStartTime.tm_year, tmNewTrackingStartTime.tm_mon));\n+        }\n+        \n+        // Move to the current day (if valid) or the closest previous valid day\n+        --itStartDay;\n+    } \n+\n+    tmNewTrackingStartTime.tm_mday = *itStartDay;\n+}\n+\n+void CBandwidthMan::SetPreviousHour(struct tm& tmNewTrackingStartTime, const struct tm* ptmCurrentTime, char nStartHour)\n+{\n+    set<char>::iterator itStartHour;\n+    \n+    if (tmNewTrackingStartTime.tm_mday == ptmCurrentTime->tm_mday && tmNewTrackingStartTime.tm_mon == ptmCurrentTime->tm_mon && tmNewTrackingStartTime.tm_year == ptmCurrentTime->tm_year)\n+    {\n+        // Get the hour after the current gour\n+        itStartHour = riResetTimes.setHours.upper_bound(nStartHour);\n+\n+        // If iterator is not at beginning, use the current hour or the previous valid\n+        if (itStartHour != riResetTimes.setHours.begin())\n+        {\n+            // Move to current hour (if valid) or the closest previous valid hour\n+            --itStartHour;\n+        } else {\n+            // Loop to the previous valid day, use last valid hour (via fallthrough to next if statement below)\n+            SetPreviousDay(tmNewTrackingStartTime, ptmCurrentTime, tmNewTrackingStartTime.tm_mday - 1);\n+        }\n+    }\n+\n+    // Make separate if, instead of else, to allow fallthrough from previous if statement\n+    if (tmNewTrackingStartTime.tm_mday != ptmCurrentTime->tm_mday || tmNewTrackingStartTime.tm_mon != ptmCurrentTime->tm_mon || tmNewTrackingStartTime.tm_year != ptmCurrentTime->tm_year)\n+    {\n+        // Get the last hour\n+        itStartHour = --(riResetTimes.setHours.end());\n+    }\n+\n+    tmNewTrackingStartTime.tm_hour = *itStartHour;\n+}\n+\n+void CBandwidthMan::SetPreviousMinute(struct tm& tmNewTrackingStartTime, const struct tm* ptmCurrentTime, char nStartMinute)\n+{\n+    set<char>::iterator itStartMinute;\n+\n+    if (tmNewTrackingStartTime.tm_hour == ptmCurrentTime->tm_hour && tmNewTrackingStartTime.tm_mday == ptmCurrentTime->tm_mday && tmNewTrackingStartTime.tm_mon == ptmCurrentTime->tm_mon && tmNewTrackingStartTime.tm_year == ptmCurrentTime->tm_year)\n+    {\n+        // Get the day after the current day\n+        itStartMinute = riResetTimes.setMinutes.upper_bound(nStartMinute);\n+\n+        // If iterator is not at beginning, use the current minute or the previous valid\n+        if (itStartMinute != riResetTimes.setMinutes.begin())\n+        {\n+            // Move to current minute (if valid) or the closest prevoius valid\n+            --itStartMinute;\n+        } else {\n+            // Loop to the previous valid hour, use last valid minute (via fallthrough to next if statement below)\n+            SetPreviousHour(tmNewTrackingStartTime, ptmCurrentTime, tmNewTrackingStartTime.tm_hour - 1);\n+        }\n+    }\n+\n+    // Make separate if, instead of else, to allow fallthrough from previous if statement\n+    if (tmNewTrackingStartTime.tm_hour != ptmCurrentTime->tm_hour || tmNewTrackingStartTime.tm_mday != ptmCurrentTime->tm_mday || tmNewTrackingStartTime.tm_mon != ptmCurrentTime->tm_mon || tmNewTrackingStartTime.tm_year != ptmCurrentTime->tm_year)\n+    {\n+        // Get the last minute\n+        itStartMinute = --(riResetTimes.setMinutes.end());\n+    }\n+\n+    tmNewTrackingStartTime.tm_min = *itStartMinute;\n+}\n+\n+\n+\n+void CBandwidthMan::SetNextYear(struct tm& tmNewTrackingResetTime, const struct tm* ptmCurrentTime)\n+{\n+    int nStartYear;\n+\n+    if (tmNewTrackingResetTime.tm_mon > ptmCurrentTime->tm_mon || (tmNewTrackingResetTime.tm_mon == ptmCurrentTime->tm_mon && (tmNewTrackingResetTime.tm_mday > ptmCurrentTime->tm_mday || tmNewTrackingResetTime.tm_hour > ptmCurrentTime->tm_hour || tmNewTrackingResetTime.tm_min > ptmCurrentTime->tm_min)))\n+    {\n+        nStartYear = ptmCurrentTime->tm_year;\n+    } else {\n+        nStartYear = ptmCurrentTime->tm_year + 1;\n+\n+        // If our original guess wasn't right, try again with the new month\n+        SetNextMonth(tmNewTrackingResetTime, ptmCurrentTime, nStartYear, 0);\n+    }\n+\n+    bool fIsValid = false;\n+\n+    do\n+    {\n+        if (tmNewTrackingResetTime.tm_mon == -1)\n+        {\n+            ++nStartYear;\n+            SetNextMonth(tmNewTrackingResetTime, ptmCurrentTime, nStartYear, 0);\n+        } else {\n+            fIsValid = true;\n+        }\n+    } while (fIsValid == false);\n+\n+    tmNewTrackingResetTime.tm_year = nStartYear;\n+}\n+\n+void CBandwidthMan::SetNextMonth(struct tm& tmNewTrackingResetTime, const struct tm* ptmCurrentTime, int nTestYear, char nStartMonth)\n+{\n+    set<char>::iterator itStartMonth;\n+    \n+    // Allow getting the same day if we have changed days and not looped or if we have changed minutes or days\n+    if (tmNewTrackingResetTime.tm_mday > ptmCurrentTime->tm_mday || (tmNewTrackingResetTime.tm_mday == ptmCurrentTime->tm_mday && (tmNewTrackingResetTime.tm_hour > ptmCurrentTime->tm_hour || tmNewTrackingResetTime.tm_min > ptmCurrentTime->tm_min)) || nTestYear != ptmCurrentTime->tm_year)\n+    {\n+        // Get the current day or next valid day\n+        itStartMonth = riResetTimes.setMonths.lower_bound(nStartMonth);\n+    } else {\n+        // Get the next valid day\n+        itStartMonth = riResetTimes.setMonths.upper_bound(nStartMonth); \n+    }\n+\n+    if (itStartMonth == riResetTimes.setMonths.end())\n+        itStartMonth = riResetTimes.setMonths.begin();\n+\n+    // If our original guess wasn't right, try again with the new month\n+    if ((*itStartMonth != ptmCurrentTime->tm_mon || nTestYear != ptmCurrentTime->tm_year) && (tmNewTrackingResetTime.tm_mday == -1 || DayIsFiltered(tmNewTrackingResetTime.tm_mday, *itStartMonth, nTestYear)))\n+        SetNextDay(tmNewTrackingResetTime, ptmCurrentTime, *itStartMonth, nTestYear, 1);\n+    \n+    bool fIsValid = false;\n+    size_t nCount = 0;\n+\n+    do\n+    {\n+        // If we failed to get a day last time or the day was invalid for this month\n+        if (tmNewTrackingResetTime.tm_mday == -1 || tmNewTrackingResetTime.tm_mday > LastDayOfMonth(nTestYear, *itStartMonth))\n+        {\n+            ++itStartMonth;\n+            if (itStartMonth == riResetTimes.setMonths.end())\n+                itStartMonth = riResetTimes.setMonths.begin();\n+\n+            ++nCount;\n+            \n+            if (nCount == riResetTimes.setMonths.size())\n+            {\n+                itStartMonth = riResetTimes.setMonths.end();\n+                break;\n+            }\n+\n+            SetNextDay(tmNewTrackingResetTime, ptmCurrentTime, *itStartMonth, nTestYear, 1);\n+        } else {\n+            fIsValid = true;\n+        }\n+    } while (!fIsValid);\n+   \n+\n+    if (itStartMonth != riResetTimes.setMonths.end())\n+        tmNewTrackingResetTime.tm_mon = *itStartMonth;\n+    else\n+        tmNewTrackingResetTime.tm_mon = -1;\n+}\n+\n+void CBandwidthMan::SetNextDay(struct tm& tmNewTrackingResetTime, const struct tm* ptmCurrentTime, char nTestMonth, int nTestYear, char nStartDay)\n+{\n+    set<char>::iterator itStartDay;\n+\n+    // Allow getting the same day if we have changed hours and not looped or if we have changed minutes, months, or years\n+    if (tmNewTrackingResetTime.tm_hour > ptmCurrentTime->tm_hour || (tmNewTrackingResetTime.tm_hour == ptmCurrentTime->tm_hour && tmNewTrackingResetTime.tm_min > ptmCurrentTime->tm_min) || nTestYear != ptmCurrentTime->tm_year || nTestMonth != ptmCurrentTime->tm_mon)\n+    {\n+        // Get the current day or next valid day\n+        itStartDay = riResetTimes.setDaysOfMonth.lower_bound(nStartDay);\n+    } else {\n+        // Get the next valid day after the current day\n+        itStartDay = riResetTimes.setDaysOfMonth.upper_bound(nStartDay);\n+    }\n+\n+    if (itStartDay == riResetTimes.setDaysOfMonth.end())\n+        itStartDay = riResetTimes.setDaysOfMonth.begin();\n+\n+\n+    size_t nCount = 0;\n+\n+    while (DayIsFiltered(nTestYear, nTestMonth, *itStartDay))\n+    {\n+        ++itStartDay;\n+        ++nCount;\n+        \n+        if (itStartDay != riResetTimes.setDaysOfMonth.end() && *itStartDay > LastDayOfMonth(nTestYear, nTestMonth))\n+        {\n+            do\n+            {\n+                ++itStartDay;\n+                ++nCount;\n+            } while (itStartDay != riResetTimes.setDaysOfMonth.end());\n+        }\n+\n+        // Loop back to beginning\n+        if (itStartDay == riResetTimes.setDaysOfMonth.end())\n+            itStartDay = riResetTimes.setDaysOfMonth.begin();\n+\n+        if (nCount >= riResetTimes.setDaysOfMonth.size())\n+        {\n+            itStartDay = riResetTimes.setDaysOfMonth.end();\n+            break;\n+        }\n+    }\n+\n+    if (itStartDay != riResetTimes.setDaysOfMonth.end())\n+        tmNewTrackingResetTime.tm_mday = *itStartDay;\n+    else\n+        tmNewTrackingResetTime.tm_mday = -1;\n+}\n+\n+void CBandwidthMan::SetNextHour(struct tm& tmNewTrackingResetTime, const struct tm* ptmCurrentTime, char nStartHour)\n+{\n+    set<char>::iterator itStartHour;\n+    \n+    // Allow getting the same hour if we have changed minutes and not looped\n+    if (tmNewTrackingResetTime.tm_min > ptmCurrentTime->tm_min)\n+    {\n+        // Get the current hour or next valid hour\n+        itStartHour = riResetTimes.setHours.lower_bound(nStartHour);\n+    } else {\n+        // Get the next valid hour after the current hour\n+        itStartHour = riResetTimes.setHours.upper_bound(nStartHour);\n+\n+    }\n+\n+    // If the iterator at end, loop the start hour to the beginning\n+    if (itStartHour == riResetTimes.setHours.end())\n+        itStartHour = riResetTimes.setHours.begin();\n+\n+    tmNewTrackingResetTime.tm_hour = *itStartHour;\n+}\n+\n+void CBandwidthMan::SetNextMinute(struct tm& tmNewTrackingResetTime, char nStartMinute)\n+{\n+    set<char>::iterator itStartMinute;\n+\n+    // Get the minute after the current minute\n+    itStartMinute = riResetTimes.setMinutes.upper_bound(nStartMinute);\n+\n+    // If iterator is at end, use the first valid minute\n+    if (itStartMinute == riResetTimes.setMinutes.end())\n+        itStartMinute = riResetTimes.setMinutes.begin();\n+\n+    tmNewTrackingResetTime.tm_min = *itStartMinute;\n+}\n+\n+\n+\n+\n+\n+\n+\n+/*      Private static functions     */\n+\n+void CBandwidthMan::AddResetTimesRange(int nFrom, int nTo, int nSkip, set<char>* psetCurrentUnit, int nStartValue, int nModValue, int nOffsetValue)\n+{\n+\n+    if (nSkip == 0)\n+    {\n+        if (nSkip == 0)\n+            throw \"Unable to parse reset times string6\";\n+    }\n+\n+    if (nTo < 0)\n+        nTo = nFrom;\n+\n+    if (nTo >= nStartValue + nModValue)\n+    {\n+        nTo -= nStartValue;\n+        nTo %= nModValue;\n+        nTo += nStartValue;\n+    }\n+\n+    // Loop as long as we are not in an infinite loop\n+    set<char> setAddedValues;\n+    while (setAddedValues.find(nFrom) == setAddedValues.end())\n+    {\n+        psetCurrentUnit->insert(nFrom + nOffsetValue);\n+        setAddedValues.insert(nFrom);\n+\n+        // Stop when nFrom reaches nTo\n+        if (nFrom == nTo)\n+            break;\n+\n+        // Advance nFrom and wrap as needed\n+        nFrom += nSkip;\n+        if (nFrom >= nStartValue + nModValue)\n+        {\n+            nFrom -= nStartValue;\n+            nFrom %= nModValue;\n+            nFrom += nStartValue;\n+        }\n+    }\n+}\n+\n+uint64 CBandwidthMan::ParseBandwidthValue(string strBandwidthValue)\n+{\n+    uint64 nBandwidthValue = 0;\n+\n+    for (size_t x = 0; x < strBandwidthValue.length(); ++x)\n+    {\n+        bool fRequireLast = false;\n+        if (strBandwidthValue[x] >= '0' && strBandwidthValue[x] <= '9')\n+        {\n+            nBandwidthValue *= 10;\n+            nBandwidthValue += (int) (strBandwidthValue[x] - '0');\n+        } else if (strBandwidthValue[x] == 'b' || strBandwidthValue[x] == 'B') {\n+            fRequireLast = true;\n+        } else if (strBandwidthValue[x] == 'k' || strBandwidthValue[x] == 'K') {\n+            nBandwidthValue *= (uint64) 1024;\n+            fRequireLast = true;\n+        } else if (strBandwidthValue[x] == 'm' || strBandwidthValue[x] == 'M') {\n+            nBandwidthValue *= (uint64) 1024 * 1024;\n+            fRequireLast = true;\n+        } else if (strBandwidthValue[x] == 'g' || strBandwidthValue[x] == 'G') {\n+            nBandwidthValue *= (uint64) 1024 * 1024 * 1024;\n+            fRequireLast = true;\n+        } else if (strBandwidthValue[x] == 't' || strBandwidthValue[x] == 'T') {\n+            nBandwidthValue *= (uint64) 1024 * 1024 * 1024 * 1024;\n+            fRequireLast = true;\n+        } else if (strBandwidthValue[x] == 'p' || strBandwidthValue[x] == 'P') {\n+            nBandwidthValue *= (uint64) 1024 * 1024 * 1024 * 1024 * 1024;\n+            fRequireLast = true;\n+        } else if (strBandwidthValue[x] == ' ') {\n+        } else {\n+            return (uint64) -1;\n+        }\n+\n+        if (fRequireLast)\n+        {\n+            // Allow 'b' behind any of the non-'b' multipliers\n+            if (x == (strBandwidthValue.length() - 2) && (strBandwidthValue[x] != 'b' && strBandwidthValue[x] != 'B') && \n+                                                         (strBandwidthValue[x + 1] == 'b' || strBandwidthValue[x + 1] =='B'))\n+                continue;\n+\n+            // If it's not the last value, fail\n+            if (x != (strBandwidthValue.length() - 1))\n+                return (uint64) -1;\n+        }\n+    }\n+    return nBandwidthValue;\n+}"
      },
      {
        "sha": "f65ce4676ead3655849cf8f0b0bfd332e6c2cf87",
        "filename": "src/bandwidthman.h",
        "status": "added",
        "additions": 113,
        "deletions": 0,
        "changes": 113,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1966c325a4e5e9de7c89f98869663272d33fab94/src/bandwidthman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1966c325a4e5e9de7c89f98869663272d33fab94/src/bandwidthman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bandwidthman.h?ref=1966c325a4e5e9de7c89f98869663272d33fab94",
        "patch": "@@ -0,0 +1,113 @@\n+#ifndef BITCOIN_BANDWIDTHMAN_H\n+#define BITCOIN_BANDWIDTHMAN_H\n+\n+#include <map>\n+#include <set>\n+#include <string>\n+#include <time.h>\n+\n+#include \"util.h\"\n+#include \"sync.h\"\n+\n+class CBandwidthMan\n+{\n+private:\n+    struct ResetInformation\n+    {\n+        std::set<char> setMinutes;\n+        std::set<char> setHours;\n+        std::set<char> setDaysOfMonth;\n+        std::set<char> setMonths;\n+        std::set<char> setDaysOfWeek;\n+    };\n+\n+    // critical section to protect the inner data structures\n+    mutable CCriticalSection cs;\n+\n+    ResetInformation riResetTimes;\n+\n+    std::map<std::string, uint64> mapMaxCommandSentBytes;\n+    uint64 nMaxTotalSentBytes;\n+\n+    // map to track bandwidth usage of each command\n+    std::map<std::string, uint64> mapCommandSentBytes;\n+\n+    // uint64 to track total bandwidth usage\n+    uint64 nTotalSentBytes;\n+\n+    // start time of usage tracking\n+    time_t nTrackingStartTime;\n+\n+    // next reset time for usage tracking\n+    time_t nTrackingResetTime;\n+\n+    void ParseResetTimes(std::string strResetTimes);\n+    \n+    void PrintResetTimes() const;\n+    void PrintCurrentBandwidth() const;\n+    \n+    void ResetTrackingStatistics();\n+    void RecalculateStartResetTimes(struct tm* ptmCurrentTime);\n+\n+    bool DayIsFiltered(int nYearSince1900, char nMonth, char nDay);\n+    char LastDayOfMonth(int nYearSince1900, char nMonth);\n+\n+    void SetPreviousMonth(struct tm& tmNewTrackingStartTime, char nStartMonth);\n+    void SetPreviousDay(struct tm& tmNewTrackingStartTime, const struct tm* ptmCurrentTime, char nStartDay);\n+    void SetPreviousHour(struct tm& tmNewTrackingStartTime, const struct tm* ptmCurrentTime, char nStartHour);\n+    void SetPreviousMinute(struct tm& tmNewTrackingStartTime, const struct tm* ptmCurrentTime, char nStartMinute);\n+\n+\n+    void SetNextYear(struct tm& tmNewTrackingResetTime, const struct tm* ptmCurrentTime);\n+    void SetNextMonth(struct tm& tmNewTrackingResetTime, const struct tm* ptmCurrentTime, int nTestYear, char nStartMonth);\n+    void SetNextDay(struct tm& tmNewTrackingResetTime, const struct tm* ptmCurrentTime, char nTestMonth, int nTestYear, char nStartDay);\n+    void SetNextHour(struct tm& tmNewTrackingResetTime, const struct tm* ptmCurrentTime, char nStartHour);\n+    void SetNextMinute(struct tm& tmNewTrackingResetTime, char nStartMinute);\n+\n+\n+    static void AddResetTimesRange(int nFrom, int nTo, int nSkip, std::set<char>* psetCurrentUnit, int nStartValue, int nModValue, int nOffsetValue);\n+    static uint64 ParseBandwidthValue(std::string strBandwidthValue);\n+\n+public:\n+\n+    CBandwidthMan();\n+\n+    void LoadConfiguration();\n+    \n+    struct SchedulingTestData\n+    {\n+       ResetInformation riResetTimes;\n+       time_t nTrackingStartTime;\n+       time_t nTrackingResetTime;\n+    };\n+\n+    // Function to test scheduling functionality\n+    SchedulingTestData TestScheduling(std::string strCronLine, struct tm tmTestTime);\n+\n+    // Determine if we should be allowed to send command.\n+    //   Returns true if allowed to be sent, data asummed to be send if allowed by the function.\n+    bool AllowSendCommand(std::string strCommand, int nSize);\n+\n+    IMPLEMENT_SERIALIZE\n+    (({\n+        // serialized format:\n+        // * version byte (currently 0)\n+        // * current statistics start time\n+        // * current statistics reset time\n+        // * total sent bytes\n+        // * mapCommandSentBytes\n+        //\n+        {\n+            LOCK(cs);\n+            unsigned char nVersion = 0;\n+            READWRITE(nVersion);\n+            READWRITE(nTrackingStartTime);\n+            READWRITE(nTrackingResetTime);\n+            READWRITE(nTotalSentBytes);\n+            READWRITE(mapCommandSentBytes);\n+        }\n+    });)\n+    \n+};\n+\n+#endif"
      },
      {
        "sha": "9cc4dfdef9382695766aa13e5ca4e70527dda989",
        "filename": "src/db.cpp",
        "status": "modified",
        "additions": 36,
        "deletions": 40,
        "changes": 76,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1966c325a4e5e9de7c89f98869663272d33fab94/src/db.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1966c325a4e5e9de7c89f98869663272d33fab94/src/db.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/db.cpp?ref=1966c325a4e5e9de7c89f98869663272d33fab94",
        "patch": "@@ -469,67 +469,62 @@ void CDBEnv::Flush(bool fShutdown)\n \n \n \n-\n-\n-\n-\n-\n //\n-// CAddrDB\n+// CDatDB\n //\n-\n-\n-CAddrDB::CAddrDB()\n+CDatDB::CDatDB(const char* pszFilename) : strFilename(pszFilename)\n {\n-    pathAddr = GetDataDir() / \"peers.dat\";\n+    pathDataDir = GetDataDir();\n+    pathDat = pathDataDir / strFilename;\n }\n \n-bool CAddrDB::Write(const CAddrMan& addr)\n-{\n+bool CDatDB::Write(CDataStream& ssWriteStream)\n+{   \n     // Generate random temporary filename\n     unsigned short randv = 0;\n     RAND_bytes((unsigned char *)&randv, sizeof(randv));\n-    std::string tmpfn = strprintf(\"peers.dat.%04x\", randv);\n+    std::string tmpfn = strprintf(\"%s.%04x\", strFilename.c_str(), randv);\n \n-    // serialize addresses, checksum data up to that point, then append csum\n-    CDataStream ssPeers(SER_DISK, CLIENT_VERSION);\n-    ssPeers << FLATDATA(pchMessageStart);\n-    ssPeers << addr;\n-    uint256 hash = Hash(ssPeers.begin(), ssPeers.end());\n-    ssPeers << hash;\n+    // Prepend message start\n+    CFlatData& cfdMessageStart = FLATDATA(pchMessageStart);\n+    ssWriteStream.insert(ssWriteStream.begin(), cfdMessageStart.begin(), cfdMessageStart.end());\n+\n+    // Calculate checksum and append it to file\n+    uint256 hash = Hash(ssWriteStream.begin(), ssWriteStream.end());\n+    ssWriteStream << hash;\n \n     // open temp output file, and associate with CAutoFile\n-    boost::filesystem::path pathTmp = GetDataDir() / tmpfn;\n+    boost::filesystem::path pathTmp = pathDataDir / tmpfn;\n     FILE *file = fopen(pathTmp.string().c_str(), \"wb\");\n     CAutoFile fileout = CAutoFile(file, SER_DISK, CLIENT_VERSION);\n     if (!fileout)\n-        return error(\"CAddrman::Write() : open failed\");\n+        return error(\"CDatDB::Write() : open failed\");\n \n     // Write and commit header, data\n     try {\n-        fileout << ssPeers;\n+        fileout << ssWriteStream;\n     }\n     catch (std::exception &e) {\n-        return error(\"CAddrman::Write() : I/O error\");\n+        return error(\"CDatDB::Write() : I/O error\");\n     }\n     FileCommit(fileout);\n     fileout.fclose();\n \n     // replace existing peers.dat, if any, with new peers.dat.XXXX\n-    if (!RenameOver(pathTmp, pathAddr))\n-        return error(\"CAddrman::Write() : Rename-into-place failed\");\n+    if (!RenameOver(pathTmp, pathDat))\n+        return error(\"CDatDB::Write() : Rename-into-place failed\");\n \n-    return true;\n+    return true;  \n }\n \n-bool CAddrDB::Read(CAddrMan& addr)\n+bool CDatDB::Read(CDataStream& ssReadStream)\n {\n     // open input file, and associate with CAutoFile\n-    FILE *file = fopen(pathAddr.string().c_str(), \"rb\");\n+    FILE *file = fopen(pathDat.string().c_str(), \"rb\");\n     CAutoFile filein = CAutoFile(file, SER_DISK, CLIENT_VERSION);\n     if (!filein)\n-        return error(\"CAddrman::Read() : open failed\");\n-\n+        return error(\"CDatDB::Read() : open failed\");\n+    \n     // use file size to size memory buffer\n     int fileSize = GetFilesize(filein);\n     int dataSize = fileSize - sizeof(uint256);\n@@ -543,33 +538,34 @@ bool CAddrDB::Read(CAddrMan& addr)\n         filein >> hashIn;\n     }\n     catch (std::exception &e) {\n-        return error(\"CAddrman::Read() 2 : I/O error or stream data corrupted\");\n+        return error(\"CDatDB::Read() 2 : I/O error or stream data corrupted\");\n     }\n     filein.fclose();\n \n-    CDataStream ssPeers(vchData, SER_DISK, CLIENT_VERSION);\n-\n     // verify stored checksum matches input data\n-    uint256 hashTmp = Hash(ssPeers.begin(), ssPeers.end());\n+    CDataStream ssData(vchData, SER_DISK, CLIENT_VERSION);\n+    uint256 hashTmp = Hash(ssData.begin(), ssData.end());\n     if (hashIn != hashTmp)\n-        return error(\"CAddrman::Read() : checksum mismatch; data corrupted\");\n+        return error(\"CDatDB::Read() : checksum mismatch; data corrupted\");\n \n     unsigned char pchMsgTmp[4];\n+\n     try {\n         // de-serialize file header (pchMessageStart magic number) and\n-        ssPeers >> FLATDATA(pchMsgTmp);\n+        ssData >> FLATDATA(pchMsgTmp);\n \n         // verify the network matches ours\n         if (memcmp(pchMsgTmp, pchMessageStart, sizeof(pchMsgTmp)))\n-            return error(\"CAddrman::Read() : invalid network magic number\");\n+            return error(\"CDatDB::Read() : invalid network magic number\");\n+\n+        ssReadStream += ssData;\n \n-        // de-serialize address data into one CAddrMan object\n-        ssPeers >> addr;\n     }\n     catch (std::exception &e) {\n-        return error(\"CAddrman::Read() : I/O error or stream data corrupted\");\n+        return error(\"CDatDB::Read() : I/O error or stream data corrupted\");\n     }\n \n     return true;\n }\n \n+"
      },
      {
        "sha": "83c1fd38896ccbeb0b6a993c20378dd5f85b899b",
        "filename": "src/db.h",
        "status": "modified",
        "additions": 72,
        "deletions": 6,
        "changes": 78,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1966c325a4e5e9de7c89f98869663272d33fab94/src/db.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1966c325a4e5e9de7c89f98869663272d33fab94/src/db.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/db.h?ref=1966c325a4e5e9de7c89f98869663272d33fab94",
        "patch": "@@ -15,6 +15,7 @@\n \n class CAddress;\n class CAddrMan;\n+class CBandwidthMan;\n class CBlockLocator;\n class CDiskBlockIndex;\n class CMasterKey;\n@@ -310,18 +311,83 @@ class CDB\n \n \n \n+/** Abstract class to allow building of .dat databases */\n+class CDatDB\n+{\n+private:\n+    boost::filesystem::path pathDataDir;\n+    boost::filesystem::path pathDat;\n+    \n+    std::string strFilename;\n+protected:\n+    CDatDB(const char* pszFilename);\n+\n+    virtual bool Write(CDataStream& ssWriteStream);\n+    virtual bool Read(CDataStream& ssReadStream);\n+};\n+\n+/** Basic template wrapper for CDatDB, to be used by types that have serialization operator overloads */\n+template <typename T>\n+class CSerialDatDB : public CDatDB\n+{\n+public:\n+    CSerialDatDB(const char* pszFilename);\n+    bool Write(const T& writeData);\n+    bool Read(T& readData);\n+};\n+\n+\n+template <typename T>\n+CSerialDatDB<T>::CSerialDatDB(const char* pszFilename) : CDatDB(pszFilename)\n+{\n+\n+}\n+\n+template <typename T>\n+bool CSerialDatDB<T>::Write(const T& writeData)\n+{\n+    // Create new write stream\n+    CDataStream ssWriteStream(SER_DISK, CLIENT_VERSION);\n+\n+    // serialize addresses\n+    ssWriteStream << writeData;\n+\n+    return CDatDB::Write(ssWriteStream);\n+}\n+\n+template <typename T>\n+bool CSerialDatDB<T>::Read(T& readData)\n+{\n+    CDataStream ssReadStream(SER_DISK, CLIENT_VERSION);\n+    if (!CDatDB::Read(ssReadStream))\n+        return false;\n+\n+    try {\n+        // de-serialize address data into one CAddrMan object\n+        ssReadStream >> readData;\n+    }\n+    catch (std::exception &e) {\n+        return error(\"CAddrman::Read() : I/O error or stream data corrupted\");\n+    }\n+\n+    return true;\n+}\n+\n \n \n \n /** Access to the (IP) address database (peers.dat) */\n-class CAddrDB\n+class CAddrDB : public CSerialDatDB<CAddrMan>\n+{\n+public:\n+    CAddrDB() : CSerialDatDB<CAddrMan>(\"peers.dat\") {};\n+};\n+\n+/** Access to the bandwidth database */\n+class CBandwidthDB : public CSerialDatDB<CBandwidthMan>\n {\n-private:\n-    boost::filesystem::path pathAddr;\n public:\n-    CAddrDB();\n-    bool Write(const CAddrMan& addr);\n-    bool Read(CAddrMan& addr);\n+    CBandwidthDB() : CSerialDatDB<CBandwidthMan>(\"bandwidth.dat\") {};\n };\n \n #endif // BITCOIN_DB_H"
      },
      {
        "sha": "be832c5e39a5caf022ffea4f9975da559564f632",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 2,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1966c325a4e5e9de7c89f98869663272d33fab94/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1966c325a4e5e9de7c89f98869663272d33fab94/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=1966c325a4e5e9de7c89f98869663272d33fab94",
        "patch": "@@ -1010,7 +1010,20 @@ bool AppInit2()\n     printf(\"Loaded %i addresses from peers.dat  %\"PRI64d\"ms\\n\",\n            addrman.size(), GetTimeMillis() - nStart);\n \n-    // ********************************************************* Step 11: start node\n+    // ********************************************************* Step 11: load bandwidth manager\n+    bandwidthman.LoadConfiguration();\n+    nStart = GetTimeMillis();\n+    \n+    {\n+        CBandwidthDB bdb;\n+        if (!bdb.Read(bandwidthman))\n+            printf(\"Invalid or missing bandwidth.dat; recreating\\n\");\n+    }\n+    \n+    printf(\"Loaded bandwidth info from bandwidth.dat  %\"PRI64d\"ms\\n\",\n+           GetTimeMillis() - nStart);\n+\n+    // ********************************************************* Step 12: start node\n \n     if (!CheckDiskSpace())\n         return false;\n@@ -1030,7 +1043,7 @@ bool AppInit2()\n     if (fServer)\n         NewThread(ThreadRPCServer, NULL);\n \n-    // ********************************************************* Step 12: finished\n+    // ********************************************************* Step 13: finished\n \n     uiInterface.InitMessage(_(\"Done loading\"));\n "
      },
      {
        "sha": "cd85e4d857f64b906cb2d31aa53524bfab358218",
        "filename": "src/makefile.linux-mingw",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1966c325a4e5e9de7c89f98869663272d33fab94/src/makefile.linux-mingw",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1966c325a4e5e9de7c89f98869663272d33fab94/src/makefile.linux-mingw",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.linux-mingw?ref=1966c325a4e5e9de7c89f98869663272d33fab94",
        "patch": "@@ -92,7 +92,8 @@ OBJS= \\\n     obj/hash.o \\\n     obj/bloom.o \\\n     obj/leveldb.o \\\n-    obj/txdb.o\n+    obj/txdb.o \\\n+    obj/bandwidthman.o\n \n all: bitcoind.exe\n "
      },
      {
        "sha": "b2cc6b1033994804bb7678eba412d275cc0430d8",
        "filename": "src/makefile.mingw",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1966c325a4e5e9de7c89f98869663272d33fab94/src/makefile.mingw",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1966c325a4e5e9de7c89f98869663272d33fab94/src/makefile.mingw",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.mingw?ref=1966c325a4e5e9de7c89f98869663272d33fab94",
        "patch": "@@ -100,7 +100,8 @@ OBJS= \\\n     obj/bloom.o \\\n     obj/noui.o \\\n     obj/leveldb.o \\\n-    obj/txdb.o\n+    obj/txdb.o \\\n+    obj/bandwidthman.o\n \n \n all: bitcoind.exe"
      },
      {
        "sha": "1e4fc10c4130b96de98e452e3a45dcbff76f62ca",
        "filename": "src/makefile.osx",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1966c325a4e5e9de7c89f98869663272d33fab94/src/makefile.osx",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1966c325a4e5e9de7c89f98869663272d33fab94/src/makefile.osx",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.osx?ref=1966c325a4e5e9de7c89f98869663272d33fab94",
        "patch": "@@ -101,7 +101,8 @@ OBJS= \\\n     obj/bloom.o \\\n     obj/noui.o \\\n     obj/leveldb.o \\\n-    obj/txdb.o\n+    obj/txdb.o \\\n+    obj/bandwidthman.o\n \n ifndef USE_UPNP\n \toverride USE_UPNP = -"
      },
      {
        "sha": "a806988ec07be47b7cbce30f9e9fb11ae68b5bba",
        "filename": "src/makefile.unix",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1966c325a4e5e9de7c89f98869663272d33fab94/src/makefile.unix",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1966c325a4e5e9de7c89f98869663272d33fab94/src/makefile.unix",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.unix?ref=1966c325a4e5e9de7c89f98869663272d33fab94",
        "patch": "@@ -132,7 +132,8 @@ OBJS= \\\n     obj/bloom.o \\\n     obj/noui.o \\\n     obj/leveldb.o \\\n-    obj/txdb.o\n+    obj/txdb.o \\\n+    obj/bandwidthman.o\n \n \n all: bitcoind"
      },
      {
        "sha": "3d1e245b2710ca228775a73c2c58470d005b7f66",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1966c325a4e5e9de7c89f98869663272d33fab94/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1966c325a4e5e9de7c89f98869663272d33fab94/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=1966c325a4e5e9de7c89f98869663272d33fab94",
        "patch": "@@ -58,6 +58,7 @@ uint64 nLocalHostNonce = 0;\n array<int, THREAD_MAX> vnThreadsRunning;\n static std::vector<SOCKET> vhListenSocket;\n CAddrMan addrman;\n+CBandwidthMan bandwidthman;\n \n vector<CNode*> vNodes;\n CCriticalSection cs_vNodes;"
      },
      {
        "sha": "31f4e2e1e2eb451fa307d518077066ad7c77a1ca",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 45,
        "deletions": 23,
        "changes": 68,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1966c325a4e5e9de7c89f98869663272d33fab94/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1966c325a4e5e9de7c89f98869663272d33fab94/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=1966c325a4e5e9de7c89f98869663272d33fab94",
        "patch": "@@ -20,6 +20,7 @@\n #include \"addrman.h\"\n #include \"hash.h\"\n #include \"bloom.h\"\n+#include \"bandwidthman.h\"\n \n class CNode;\n class CBlockIndex;\n@@ -94,6 +95,7 @@ extern uint64 nLocalServices;\n extern uint64 nLocalHostNonce;\n extern boost::array<int, THREAD_MAX> vnThreadsRunning;\n extern CAddrMan addrman;\n+extern CBandwidthMan bandwidthman;\n \n extern std::vector<CNode*> vNodes;\n extern CCriticalSection cs_vNodes;\n@@ -349,17 +351,26 @@ class CNode\n     }\n \n     // TODO: Document the precondition of this function.  Is cs_vSend locked?\n-    void EndMessage() UNLOCK_FUNCTION(cs_vSend)\n+    bool EndMessage(const char* pszCommand) UNLOCK_FUNCTION(cs_vSend)\n     {\n         if (mapArgs.count(\"-dropmessagestest\") && GetRand(atoi(mapArgs[\"-dropmessagestest\"])) == 0)\n         {\n             printf(\"dropmessages DROPPING SEND MESSAGE\\n\");\n             AbortMessage();\n-            return;\n+            // Return true, simulating a send transmission error.\n+            return true;\n         }\n \n         if (nHeaderStart < 0)\n-            return;\n+            return true;\n+\n+        // If not allowed to send, abort message and return false.\n+        if (!bandwidthman.AllowSendCommand(pszCommand, vSend.size()))\n+        {\n+            printf(\"bandwidthman DROPPING SEND MESSAGE\\n\");\n+            AbortMessage();\n+            return false;\n+        }\n \n         // Set the size\n         unsigned int nSize = vSend.size() - nMessageStart;\n@@ -379,167 +390,178 @@ class CNode\n         nHeaderStart = -1;\n         nMessageStart = -1;\n         LEAVE_CRITICAL_SECTION(cs_vSend);\n+        return true;\n     }\n \n     void PushVersion();\n \n \n-    void PushMessage(const char* pszCommand)\n+    bool PushMessage(const char* pszCommand)\n     {\n         try\n         {\n             BeginMessage(pszCommand);\n-            EndMessage();\n+            return EndMessage(pszCommand);\n         }\n         catch (...)\n         {\n             AbortMessage();\n             throw;\n         }\n+        return false;\n     }\n \n     template<typename T1>\n-    void PushMessage(const char* pszCommand, const T1& a1)\n+    bool PushMessage(const char* pszCommand, const T1& a1)\n     {\n         try\n         {\n             BeginMessage(pszCommand);\n             vSend << a1;\n-            EndMessage();\n+            return EndMessage(pszCommand);\n         }\n         catch (...)\n         {\n             AbortMessage();\n             throw;\n         }\n+        return false;\n     }\n \n     template<typename T1, typename T2>\n-    void PushMessage(const char* pszCommand, const T1& a1, const T2& a2)\n+    bool PushMessage(const char* pszCommand, const T1& a1, const T2& a2)\n     {\n         try\n         {\n             BeginMessage(pszCommand);\n             vSend << a1 << a2;\n-            EndMessage();\n+            return EndMessage(pszCommand);\n         }\n         catch (...)\n         {\n             AbortMessage();\n             throw;\n         }\n+        return false;\n     }\n \n     template<typename T1, typename T2, typename T3>\n-    void PushMessage(const char* pszCommand, const T1& a1, const T2& a2, const T3& a3)\n+    bool PushMessage(const char* pszCommand, const T1& a1, const T2& a2, const T3& a3)\n     {\n         try\n         {\n             BeginMessage(pszCommand);\n             vSend << a1 << a2 << a3;\n-            EndMessage();\n+            return EndMessage(pszCommand);\n         }\n         catch (...)\n         {\n             AbortMessage();\n             throw;\n         }\n+        return false;\n     }\n \n     template<typename T1, typename T2, typename T3, typename T4>\n-    void PushMessage(const char* pszCommand, const T1& a1, const T2& a2, const T3& a3, const T4& a4)\n+    bool PushMessage(const char* pszCommand, const T1& a1, const T2& a2, const T3& a3, const T4& a4)\n     {\n         try\n         {\n             BeginMessage(pszCommand);\n             vSend << a1 << a2 << a3 << a4;\n-            EndMessage();\n+            return EndMessage(pszCommand);\n         }\n         catch (...)\n         {\n             AbortMessage();\n             throw;\n         }\n+        return false;\n     }\n \n     template<typename T1, typename T2, typename T3, typename T4, typename T5>\n-    void PushMessage(const char* pszCommand, const T1& a1, const T2& a2, const T3& a3, const T4& a4, const T5& a5)\n+    bool PushMessage(const char* pszCommand, const T1& a1, const T2& a2, const T3& a3, const T4& a4, const T5& a5)\n     {\n         try\n         {\n             BeginMessage(pszCommand);\n             vSend << a1 << a2 << a3 << a4 << a5;\n-            EndMessage();\n+            return EndMessage(pszCommand);\n         }\n         catch (...)\n         {\n             AbortMessage();\n             throw;\n         }\n+        return false;\n     }\n \n     template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>\n-    void PushMessage(const char* pszCommand, const T1& a1, const T2& a2, const T3& a3, const T4& a4, const T5& a5, const T6& a6)\n+    bool PushMessage(const char* pszCommand, const T1& a1, const T2& a2, const T3& a3, const T4& a4, const T5& a5, const T6& a6)\n     {\n         try\n         {\n             BeginMessage(pszCommand);\n             vSend << a1 << a2 << a3 << a4 << a5 << a6;\n-            EndMessage();\n+            return EndMessage(pszCommand);\n         }\n         catch (...)\n         {\n             AbortMessage();\n             throw;\n         }\n+        return false;\n     }\n \n     template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>\n-    void PushMessage(const char* pszCommand, const T1& a1, const T2& a2, const T3& a3, const T4& a4, const T5& a5, const T6& a6, const T7& a7)\n+    bool PushMessage(const char* pszCommand, const T1& a1, const T2& a2, const T3& a3, const T4& a4, const T5& a5, const T6& a6, const T7& a7)\n     {\n         try\n         {\n             BeginMessage(pszCommand);\n             vSend << a1 << a2 << a3 << a4 << a5 << a6 << a7;\n-            EndMessage();\n+            return EndMessage(pszCommand);\n         }\n         catch (...)\n         {\n             AbortMessage();\n             throw;\n         }\n+        return false;\n     }\n \n     template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8>\n-    void PushMessage(const char* pszCommand, const T1& a1, const T2& a2, const T3& a3, const T4& a4, const T5& a5, const T6& a6, const T7& a7, const T8& a8)\n+    bool PushMessage(const char* pszCommand, const T1& a1, const T2& a2, const T3& a3, const T4& a4, const T5& a5, const T6& a6, const T7& a7, const T8& a8)\n     {\n         try\n         {\n             BeginMessage(pszCommand);\n             vSend << a1 << a2 << a3 << a4 << a5 << a6 << a7 << a8;\n-            EndMessage();\n+            return EndMessage(pszCommand);\n         }\n         catch (...)\n         {\n             AbortMessage();\n             throw;\n         }\n+        return false;\n     }\n \n     template<typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9>\n-    void PushMessage(const char* pszCommand, const T1& a1, const T2& a2, const T3& a3, const T4& a4, const T5& a5, const T6& a6, const T7& a7, const T8& a8, const T9& a9)\n+    bool PushMessage(const char* pszCommand, const T1& a1, const T2& a2, const T3& a3, const T4& a4, const T5& a5, const T6& a6, const T7& a7, const T8& a8, const T9& a9)\n     {\n         try\n         {\n             BeginMessage(pszCommand);\n             vSend << a1 << a2 << a3 << a4 << a5 << a6 << a7 << a8 << a9;\n-            EndMessage();\n+            return EndMessage(pszCommand);\n         }\n         catch (...)\n         {\n             AbortMessage();\n             throw;\n         }\n+        return false;\n     }\n \n     void PushGetBlocks(CBlockIndex* pindexBegin, uint256 hashEnd);"
      },
      {
        "sha": "bf60fd6c09aea34242c2864abbae23f8f49ae7a3",
        "filename": "src/test/bandwidthman_tests.cpp",
        "status": "added",
        "additions": 214,
        "deletions": 0,
        "changes": 214,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1966c325a4e5e9de7c89f98869663272d33fab94/src/test/bandwidthman_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1966c325a4e5e9de7c89f98869663272d33fab94/src/test/bandwidthman_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/bandwidthman_tests.cpp?ref=1966c325a4e5e9de7c89f98869663272d33fab94",
        "patch": "@@ -0,0 +1,214 @@\n+#include <iostream>\n+#include <boost/test/unit_test.hpp>\n+\n+#include \"bandwidthman.h\"\n+\n+using namespace std;\n+\n+const time_t nZero = 0;\n+\n+void SetTime(struct tm& ptmTime, int nSecond, int nMinute, int nHour, int nDay, int nMonth, int nYear);\n+\n+BOOST_AUTO_TEST_SUITE(bandwidthman_tests)\n+\n+BOOST_AUTO_TEST_CASE(bandwidthman_trackingtimes_boundaries)\n+{\n+    CBandwidthMan bmTestManager;\n+    CBandwidthMan::SchedulingTestData testData;\n+    struct tm tmTestTime;\n+    struct tm tmExpectedStart;\n+    struct tm tmExpectedReset;\n+\n+    gmtime_r(&nZero, &tmTestTime);\n+    gmtime_r(&nZero, &tmExpectedStart);\n+    gmtime_r(&nZero, &tmExpectedReset);\n+\n+    // Reset every minute, current time is on the minute\n+    SetTime(tmTestTime,         0, 59, 23, 31, 12, 1999);\n+    SetTime(tmExpectedStart,    0, 59, 23, 31, 12, 1999);\n+    SetTime(tmExpectedReset,    0,  0,  0,  1,  1, 2000);\n+\n+    testData = bmTestManager.TestScheduling(\"* * * * *\", tmTestTime);\n+\n+    BOOST_CHECK_EQUAL(testData.nTrackingStartTime, timegm(&tmExpectedStart));\n+    BOOST_CHECK_EQUAL(testData.nTrackingResetTime, timegm(&tmExpectedReset));\n+    \n+    // Reset every minute, current time is off the minute\n+    SetTime(tmTestTime,         30, 59, 23, 31, 12, 1999);\n+    SetTime(tmExpectedStart,     0, 59, 23, 31, 12, 1999);\n+    SetTime(tmExpectedReset,     0,  0,  0,  1,  1, 2000);\n+\n+    testData = bmTestManager.TestScheduling(\"* * * * *\", tmTestTime);\n+\n+    BOOST_CHECK_EQUAL(testData.nTrackingStartTime, timegm(&tmExpectedStart));\n+    BOOST_CHECK_EQUAL(testData.nTrackingResetTime, timegm(&tmExpectedReset));\n+\n+\n+\n+    // Reset every hour on the 30th minute, current time is on the hour's 30th minute\n+    SetTime(tmTestTime,         0, 29, 23, 31, 12, 1999);\n+    SetTime(tmExpectedStart,    0, 29, 23, 31, 12, 1999);\n+    SetTime(tmExpectedReset,    0, 29,  0,  1,  1, 2000);\n+\n+    testData = bmTestManager.TestScheduling(\"29 * * * *\", tmTestTime);\n+\n+    BOOST_CHECK_EQUAL(testData.nTrackingStartTime, timegm(&tmExpectedStart));\n+    BOOST_CHECK_EQUAL(testData.nTrackingResetTime, timegm(&tmExpectedReset));\n+\n+    // Reset every hour on the 30th minute, current time is off the hour's 30th minute\n+    SetTime(tmTestTime,         0,  0,  0,  1,  1, 2000);\n+    SetTime(tmExpectedStart,    0, 29, 23, 31, 12, 1999);\n+    SetTime(tmExpectedReset,    0, 29,  0,  1,  1, 2000);\n+\n+    testData = bmTestManager.TestScheduling(\"29 * * * *\", tmTestTime);\n+\n+    BOOST_CHECK_EQUAL(testData.nTrackingStartTime, timegm(&tmExpectedStart));\n+    BOOST_CHECK_EQUAL(testData.nTrackingResetTime, timegm(&tmExpectedReset));\n+\n+\n+\n+    // Reset every day on the 12 hours, current time is on the day's 12 hour\n+    SetTime(tmTestTime,         0, 0, 11, 31, 12, 1999);\n+    SetTime(tmExpectedStart,    0, 0, 11, 31, 12, 1999);\n+    SetTime(tmExpectedReset,    0, 0, 11,  1,  1, 2000);\n+\n+    testData = bmTestManager.TestScheduling(\"0 11 * * *\", tmTestTime);\n+\n+    BOOST_CHECK_EQUAL(testData.nTrackingStartTime, timegm(&tmExpectedStart));\n+    BOOST_CHECK_EQUAL(testData.nTrackingResetTime, timegm(&tmExpectedReset));\n+\n+    // Reset every day on the 12 hour, current time is off the day's 12 hour\n+    SetTime(tmTestTime,         0, 0,  0,  1,  1, 2000);\n+    SetTime(tmExpectedStart,    0, 0, 11, 31, 12, 1999);\n+    SetTime(tmExpectedReset,    0, 0, 11,  1,  1, 2000);\n+\n+    testData = bmTestManager.TestScheduling(\"0 11 * * *\", tmTestTime);\n+\n+    BOOST_CHECK_EQUAL(testData.nTrackingStartTime, timegm(&tmExpectedStart));\n+    BOOST_CHECK_EQUAL(testData.nTrackingResetTime, timegm(&tmExpectedReset));\n+\n+\n+\n+    // Reset every week on sunday, current time is on the week's sunday\n+    SetTime(tmTestTime,         0, 0, 0, 26, 12, 1999);\n+    SetTime(tmExpectedStart,    0, 0, 0, 26, 12, 1999);\n+    SetTime(tmExpectedReset,    0, 0, 0,  2,  1, 2000);\n+\n+    testData = bmTestManager.TestScheduling(\"0 0 * * 0\", tmTestTime);\n+\n+    BOOST_CHECK_EQUAL(testData.nTrackingStartTime, timegm(&tmExpectedStart));\n+    BOOST_CHECK_EQUAL(testData.nTrackingResetTime, timegm(&tmExpectedReset));\n+\n+    // Reset every week on sunday, current time is off the week's sunday\n+    SetTime(tmTestTime,         0, 0, 0,  1,  1, 2000);\n+    SetTime(tmExpectedStart,    0, 0, 0, 26, 12, 1999);\n+    SetTime(tmExpectedReset,    0, 0, 0,  2,  1, 2000);\n+\n+    testData = bmTestManager.TestScheduling(\"0 0 * * 0\", tmTestTime);\n+    \n+    BOOST_CHECK_EQUAL(testData.nTrackingStartTime, timegm(&tmExpectedStart));\n+    BOOST_CHECK_EQUAL(testData.nTrackingResetTime, timegm(&tmExpectedReset));\n+\n+\n+\n+    // Reset every month on the 15th day, current time is on the month's 15th day\n+    SetTime(tmTestTime,         0, 0, 0, 15, 12, 1999);\n+    SetTime(tmExpectedStart,    0, 0, 0, 15, 12, 1999);\n+    SetTime(tmExpectedReset,    0, 0, 0, 15,  1, 2000);\n+\n+    testData = bmTestManager.TestScheduling(\"0 0 15 * *\", tmTestTime);\n+\n+    BOOST_CHECK_EQUAL(testData.nTrackingStartTime, timegm(&tmExpectedStart));\n+    BOOST_CHECK_EQUAL(testData.nTrackingResetTime, timegm(&tmExpectedReset));\n+\n+    // Reset every month on the 15th day, current time is off the month's 15th day\n+    SetTime(tmTestTime,         0, 0, 0,  1,  1, 2000);\n+    SetTime(tmExpectedStart,    0, 0, 0, 15, 12, 1999);\n+    SetTime(tmExpectedReset,    0, 0, 0, 15,  1, 2000);\n+\n+    testData = bmTestManager.TestScheduling(\"0 0 15 * *\", tmTestTime);\n+\n+    BOOST_CHECK_EQUAL(testData.nTrackingStartTime, timegm(&tmExpectedStart));\n+    BOOST_CHECK_EQUAL(testData.nTrackingResetTime, timegm(&tmExpectedReset));\n+\n+\n+\n+    // Reset every year on the 6th month, current time is on the year's 6th month\n+    SetTime(tmTestTime,         0, 0, 0, 1, 6, 1999);\n+    SetTime(tmExpectedStart,    0, 0, 0, 1, 6, 1999);\n+    SetTime(tmExpectedReset,    0, 0, 0, 1, 6, 2000);\n+\n+    testData = bmTestManager.TestScheduling(\"0 0 1 6 *\", tmTestTime);\n+\n+    BOOST_CHECK_EQUAL(testData.nTrackingStartTime, timegm(&tmExpectedStart));\n+    BOOST_CHECK_EQUAL(testData.nTrackingResetTime, timegm(&tmExpectedReset));\n+\n+    // Reset every year on the 6th month, current time is off the year's 6th month\n+    SetTime(tmTestTime,         0, 0, 0,  1, 1, 2000);\n+    SetTime(tmExpectedStart,    0, 0, 0,  1, 6, 1999);\n+    SetTime(tmExpectedReset,    0, 0, 0,  1, 6, 2000);\n+\n+    testData = bmTestManager.TestScheduling(\"0 0 1 6 *\", tmTestTime);\n+\n+    BOOST_CHECK_EQUAL(testData.nTrackingStartTime, timegm(&tmExpectedStart));\n+    BOOST_CHECK_EQUAL(testData.nTrackingResetTime, timegm(&tmExpectedReset));\n+\n+\n+\n+    // Reset every year that the first day is a sunday, current time requires long reset fallforward\n+    SetTime(tmTestTime,         1, 0, 0, 1, 1, 1995);\n+    SetTime(tmExpectedStart,    0, 0, 0, 1, 1, 1995);\n+    SetTime(tmExpectedReset,    0, 0, 0, 1, 1, 2006);\n+\n+    testData = bmTestManager.TestScheduling(\"0 0 1 1 0\", tmTestTime);\n+\n+    BOOST_CHECK_EQUAL(testData.nTrackingStartTime, timegm(&tmExpectedStart));\n+    BOOST_CHECK_EQUAL(testData.nTrackingResetTime, timegm(&tmExpectedReset));\n+\n+    // Reset every year that the first day is a sunday, current time requires long start fallback\n+    SetTime(tmTestTime,         59, 59, 23, 31, 12, 2005);\n+    SetTime(tmExpectedStart,     0,  0,  0,  1,  1, 1995);\n+    SetTime(tmExpectedReset,     0,  0,  0,  1,  1, 2006);\n+\n+    testData = bmTestManager.TestScheduling(\"0 0 1 1 0\", tmTestTime);\n+\n+    BOOST_CHECK_EQUAL(testData.nTrackingStartTime, timegm(&tmExpectedStart));\n+    BOOST_CHECK_EQUAL(testData.nTrackingResetTime, timegm(&tmExpectedReset));\n+\n+\n+\n+    // Reset every leap-day, current time is leap day\n+    SetTime(tmTestTime,         0, 0, 0, 29, 2, 2000);\n+    SetTime(tmExpectedStart,    0, 0, 0, 29, 2, 2000);\n+    SetTime(tmExpectedReset,    0, 0, 0, 29, 2, 2004);\n+\n+    testData = bmTestManager.TestScheduling(\"0 0 29 2 *\", tmTestTime);\n+\n+    BOOST_CHECK_EQUAL(testData.nTrackingStartTime, timegm(&tmExpectedStart));\n+    BOOST_CHECK_EQUAL(testData.nTrackingResetTime, timegm(&tmExpectedReset));\n+\n+    // Reset every leap-day, current time is not leap-day\n+    SetTime(tmTestTime,         0, 0, 0, 29, 2, 1900);\n+    SetTime(tmExpectedStart,    0, 0, 0, 29, 2, 1896);\n+    SetTime(tmExpectedReset,    0, 0, 0, 29, 2, 1904);\n+\n+    testData = bmTestManager.TestScheduling(\"0 0 29 2 *\", tmTestTime);\n+\n+    BOOST_CHECK_EQUAL(testData.nTrackingStartTime, timegm(&tmExpectedStart));\n+    BOOST_CHECK_EQUAL(testData.nTrackingResetTime, timegm(&tmExpectedReset));\n+\n+}\n+\n+BOOST_AUTO_TEST_SUITE_END()\n+\n+void SetTime(struct tm& tmTime, int nSecond, int nMinute, int nHour, int nDay, int nMonth, int nYear)\n+{\n+    tmTime.tm_sec = nSecond;\n+    tmTime.tm_min = nMinute;\n+    tmTime.tm_hour = nHour;\n+    tmTime.tm_mday = nDay;\n+    tmTime.tm_mon = nMonth - 1;\n+    tmTime.tm_year = nYear - 1900;\n+}\n+\n+"
      }
    ]
  }
]