[
  {
    "sha": "81c54dec20891f2627a49b2e3e785fdaf2a1e664",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4MWM1NGRlYzIwODkxZjI2MjdhNDliMmUzZTc4NWZkYWYyYTFlNjY0",
    "commit": {
      "author": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2020-09-09T21:51:19Z"
      },
      "committer": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2020-12-14T08:32:57Z"
      },
      "message": "rpc: update getblocktemplate with signet rule, include signet_challenge",
      "tree": {
        "sha": "6343f2c5b2d0e0d4ec29e80ef36860f510709c27",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6343f2c5b2d0e0d4ec29e80ef36860f510709c27"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/81c54dec20891f2627a49b2e3e785fdaf2a1e664",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/81c54dec20891f2627a49b2e3e785fdaf2a1e664",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/81c54dec20891f2627a49b2e3e785fdaf2a1e664",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/81c54dec20891f2627a49b2e3e785fdaf2a1e664/comments",
    "author": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "25bc840e038f5cc3a1d70d6fbaf1dc2eb2c6e460",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/25bc840e038f5cc3a1d70d6fbaf1dc2eb2c6e460",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/25bc840e038f5cc3a1d70d6fbaf1dc2eb2c6e460"
      }
    ],
    "stats": {
      "total": 18,
      "additions": 17,
      "deletions": 1
    },
    "files": [
      {
        "sha": "eb2376329c325647aa0e7271ec811245b5ab6f55",
        "filename": "src/rpc/mining.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 1,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/81c54dec20891f2627a49b2e3e785fdaf2a1e664/src/rpc/mining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/81c54dec20891f2627a49b2e3e785fdaf2a1e664/src/rpc/mining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/mining.cpp?ref=81c54dec20891f2627a49b2e3e785fdaf2a1e664",
        "patch": "@@ -714,6 +714,13 @@ static RPCHelpMan getblocktemplate()\n         // TODO: Maybe recheck connections/IBD and (if something wrong) send an expires-immediately template to stop miners?\n     }\n \n+    const Consensus::Params& consensusParams = Params().GetConsensus();\n+\n+    // GBT must be called with 'signet' set in the rules for signet chains\n+    if (consensusParams.signet_blocks && setClientRules.count(\"signet\") != 1) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"getblocktemplate must be called with the signet rule set (call with {\\\"rules\\\": [\\\"segwit\\\", \\\"signet\\\"]})\");\n+    }\n+\n     // GBT must be called with 'segwit' set in the rules\n     if (setClientRules.count(\"segwit\") != 1) {\n         throw JSONRPCError(RPC_INVALID_PARAMETER, \"getblocktemplate must be called with the segwit rule set (call with {\\\"rules\\\": [\\\"segwit\\\"]})\");\n@@ -745,7 +752,6 @@ static RPCHelpMan getblocktemplate()\n     }\n     CHECK_NONFATAL(pindexPrev);\n     CBlock* pblock = &pblocktemplate->block; // pointer for convenience\n-    const Consensus::Params& consensusParams = Params().GetConsensus();\n \n     // Update nTime\n     UpdateTime(pblock, consensusParams, pindexPrev);\n@@ -809,6 +815,12 @@ static RPCHelpMan getblocktemplate()\n     UniValue aRules(UniValue::VARR);\n     aRules.push_back(\"csv\");\n     if (!fPreSegWit) aRules.push_back(\"!segwit\");\n+    if (consensusParams.signet_blocks) {\n+        // indicate to miner that they must understand signet rules\n+        // when attempting to mine with this template\n+        aRules.push_back(\"!signet\");\n+    }\n+\n     UniValue vbavailable(UniValue::VOBJ);\n     for (int j = 0; j < (int)Consensus::MAX_VERSION_BITS_DEPLOYMENTS; ++j) {\n         Consensus::DeploymentPos pos = Consensus::DeploymentPos(j);\n@@ -889,6 +901,10 @@ static RPCHelpMan getblocktemplate()\n     result.pushKV(\"bits\", strprintf(\"%08x\", pblock->nBits));\n     result.pushKV(\"height\", (int64_t)(pindexPrev->nHeight+1));\n \n+    if (consensusParams.signet_blocks) {\n+        result.pushKV(\"signet_challenge\", HexStr(consensusParams.signet_challenge));\n+    }\n+\n     if (!pblocktemplate->vchCoinbaseCommitment.empty()) {\n         result.pushKV(\"default_witness_commitment\", HexStr(pblocktemplate->vchCoinbaseCommitment));\n     }"
      }
    ]
  },
  {
    "sha": "95d5d5e6257825bb385cee318d5681597f7f7646",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5NWQ1ZDVlNjI1NzgyNWJiMzg1Y2VlMzE4ZDU2ODE1OTdmN2Y3NjQ2",
    "commit": {
      "author": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2020-09-09T22:06:34Z"
      },
      "committer": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2020-12-14T08:32:57Z"
      },
      "message": "rpc: allow getblocktemplate for test chains when unconnected or in IBD",
      "tree": {
        "sha": "b5223236a85cc0088ba764e037e4571198dd1836",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b5223236a85cc0088ba764e037e4571198dd1836"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/95d5d5e6257825bb385cee318d5681597f7f7646",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/95d5d5e6257825bb385cee318d5681597f7f7646",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/95d5d5e6257825bb385cee318d5681597f7f7646",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/95d5d5e6257825bb385cee318d5681597f7f7646/comments",
    "author": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "81c54dec20891f2627a49b2e3e785fdaf2a1e664",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/81c54dec20891f2627a49b2e3e785fdaf2a1e664",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/81c54dec20891f2627a49b2e3e785fdaf2a1e664"
      }
    ],
    "stats": {
      "total": 12,
      "additions": 8,
      "deletions": 4
    },
    "files": [
      {
        "sha": "3d71bdebe9786a71d71afcb4ddc4d752df5e7517",
        "filename": "src/rpc/mining.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 4,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/95d5d5e6257825bb385cee318d5681597f7f7646/src/rpc/mining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/95d5d5e6257825bb385cee318d5681597f7f7646/src/rpc/mining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/mining.cpp?ref=95d5d5e6257825bb385cee318d5681597f7f7646",
        "patch": "@@ -658,11 +658,15 @@ static RPCHelpMan getblocktemplate()\n     if(!node.connman)\n         throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Peer-to-peer functionality missing or disabled\");\n \n-    if (node.connman->GetNodeCount(CConnman::CONNECTIONS_ALL) == 0)\n-        throw JSONRPCError(RPC_CLIENT_NOT_CONNECTED, PACKAGE_NAME \" is not connected!\");\n+    if (!Params().IsTestChain()) {\n+        if (node.connman->GetNodeCount(CConnman::CONNECTIONS_ALL) == 0) {\n+            throw JSONRPCError(RPC_CLIENT_NOT_CONNECTED, PACKAGE_NAME \" is not connected!\");\n+        }\n \n-    if (::ChainstateActive().IsInitialBlockDownload())\n-        throw JSONRPCError(RPC_CLIENT_IN_INITIAL_DOWNLOAD, PACKAGE_NAME \" is in initial sync and waiting for blocks...\");\n+        if (::ChainstateActive().IsInitialBlockDownload()) {\n+            throw JSONRPCError(RPC_CLIENT_IN_INITIAL_DOWNLOAD, PACKAGE_NAME \" is in initial sync and waiting for blocks...\");\n+        }\n+    }\n \n     static unsigned int nTransactionsUpdatedLast;\n     const CTxMemPool& mempool = EnsureMemPool(request.context);"
      }
    ]
  },
  {
    "sha": "13762bcc9618138dd28b53c2031defdc9d762d26",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxMzc2MmJjYzk2MTgxMzhkZDI4YjUzYzIwMzFkZWZkYzlkNzYyZDI2",
    "commit": {
      "author": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2020-09-09T22:09:07Z"
      },
      "committer": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2021-01-12T08:34:25Z"
      },
      "message": "Add bitcoin-util command line utility",
      "tree": {
        "sha": "58e51911fd2579f677a50962876a80383d011baf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/58e51911fd2579f677a50962876a80383d011baf"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/13762bcc9618138dd28b53c2031defdc9d762d26",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/13762bcc9618138dd28b53c2031defdc9d762d26",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/13762bcc9618138dd28b53c2031defdc9d762d26",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/13762bcc9618138dd28b53c2031defdc9d762d26/comments",
    "author": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "95d5d5e6257825bb385cee318d5681597f7f7646",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/95d5d5e6257825bb385cee318d5681597f7f7646",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/95d5d5e6257825bb385cee318d5681597f7f7646"
      }
    ],
    "stats": {
      "total": 292,
      "additions": 290,
      "deletions": 2
    },
    "files": [
      {
        "sha": "0bcf91b440cefeb0da25f5af060e5719207750ea",
        "filename": ".gitignore",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/13762bcc9618138dd28b53c2031defdc9d762d26/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/13762bcc9618138dd28b53c2031defdc9d762d26/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.gitignore?ref=13762bcc9618138dd28b53c2031defdc9d762d26",
        "patch": "@@ -8,6 +8,7 @@ src/bitcoin-cli\n src/bitcoin-gui\n src/bitcoin-node\n src/bitcoin-tx\n+src/bitcoin-util\n src/bitcoin-wallet\n src/test/fuzz/*\n !src/test/fuzz/*.*"
      },
      {
        "sha": "5289239222430a48a6e4c6473a060ddf2d99b610",
        "filename": "Makefile.am",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/13762bcc9618138dd28b53c2031defdc9d762d26/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/13762bcc9618138dd28b53c2031defdc9d762d26/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/Makefile.am?ref=13762bcc9618138dd28b53c2031defdc9d762d26",
        "patch": "@@ -24,6 +24,7 @@ BITCOIND_BIN=$(top_builddir)/src/$(BITCOIN_DAEMON_NAME)$(EXEEXT)\n BITCOIN_QT_BIN=$(top_builddir)/src/qt/$(BITCOIN_GUI_NAME)$(EXEEXT)\n BITCOIN_CLI_BIN=$(top_builddir)/src/$(BITCOIN_CLI_NAME)$(EXEEXT)\n BITCOIN_TX_BIN=$(top_builddir)/src/$(BITCOIN_TX_NAME)$(EXEEXT)\n+BITCOIN_UTIL_BIN=$(top_builddir)/src/$(BITCOIN_UTIL_NAME)$(EXEEXT)\n BITCOIN_WALLET_BIN=$(top_builddir)/src/$(BITCOIN_WALLET_TOOL_NAME)$(EXEEXT)\n BITCOIN_NODE_BIN=$(top_builddir)/src/$(BITCOIN_MP_NODE_NAME)$(EXEEXT)\n BITCOIN_GUI_BIN=$(top_builddir)/src/$(BITCOIN_MP_GUI_NAME)$(EXEEXT)\n@@ -78,6 +79,7 @@ $(BITCOIN_WIN_INSTALLER): all-recursive\n \tSTRIPPROG=\"$(STRIP)\" $(INSTALL_STRIP_PROGRAM) $(BITCOIN_CLI_BIN) $(top_builddir)/release\n \tSTRIPPROG=\"$(STRIP)\" $(INSTALL_STRIP_PROGRAM) $(BITCOIN_TX_BIN) $(top_builddir)/release\n \tSTRIPPROG=\"$(STRIP)\" $(INSTALL_STRIP_PROGRAM) $(BITCOIN_WALLET_BIN) $(top_builddir)/release\n+\tSTRIPPROG=\"$(STRIP)\" $(INSTALL_STRIP_PROGRAM) $(BITCOIN_UTIL_BIN) $(top_builddir)/release\n \t@test -f $(MAKENSIS) && echo 'OutFile \"$@\"' | cat $(top_builddir)/share/setup.nsi - | $(MAKENSIS) -V2 - || \\\n \t  echo error: could not build $@\n \t@echo built $@\n@@ -171,6 +173,9 @@ $(BITCOIN_CLI_BIN): FORCE\n $(BITCOIN_TX_BIN): FORCE\n \t$(MAKE) -C src $(@F)\n \n+$(BITCOIN_UTIL_BIN): FORCE\n+\t$(MAKE) -C src $(@F)\n+\n $(BITCOIN_WALLET_BIN): FORCE\n \t$(MAKE) -C src $(@F)\n "
      },
      {
        "sha": "9f966fe05da6dcd6f04cb551258cbdf68eef904d",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 15,
        "deletions": 2,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/13762bcc9618138dd28b53c2031defdc9d762d26/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/13762bcc9618138dd28b53c2031defdc9d762d26/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=13762bcc9618138dd28b53c2031defdc9d762d26",
        "patch": "@@ -23,6 +23,7 @@ BITCOIN_DAEMON_NAME=bitcoind\n BITCOIN_GUI_NAME=bitcoin-qt\n BITCOIN_CLI_NAME=bitcoin-cli\n BITCOIN_TX_NAME=bitcoin-tx\n+BITCOIN_UTIL_NAME=bitcoin-util\n BITCOIN_WALLET_TOOL_NAME=bitcoin-wallet\n dnl Multi Process\n BITCOIN_MP_NODE_NAME=bitcoin-node\n@@ -553,7 +554,7 @@ CPPFLAGS=\"$CPPFLAGS -DHAVE_BUILD_INFO -D__STDC_FORMAT_MACROS\"\n \n AC_ARG_WITH([utils],\n   [AS_HELP_STRING([--with-utils],\n-  [build bitcoin-cli bitcoin-tx bitcoin-wallet (default=yes)])],\n+  [build bitcoin-cli bitcoin-tx bitcoin-util bitcoin-wallet (default=yes)])],\n   [build_bitcoin_utils=$withval],\n   [build_bitcoin_utils=yes])\n \n@@ -575,6 +576,12 @@ AC_ARG_ENABLE([util-wallet],\n   [build_bitcoin_wallet=$enableval],\n   [build_bitcoin_wallet=$build_bitcoin_utils])\n \n+AC_ARG_ENABLE([util-util],\n+  [AS_HELP_STRING([--enable-util-util],\n+  [build bitcoin-util])],\n+  [build_bitcoin_util=$enableval],\n+  [build_bitcoin_util=$build_bitcoin_utils])\n+\n AC_ARG_WITH([libs],\n   [AS_HELP_STRING([--with-libs],\n   [build libraries (default=yes)])],\n@@ -1185,6 +1192,7 @@ if test \"x$enable_fuzz\" = \"xyes\"; then\n   build_bitcoin_utils=no\n   build_bitcoin_cli=no\n   build_bitcoin_tx=no\n+  build_bitcoin_util=no\n   build_bitcoin_wallet=no\n   build_bitcoind=no\n   build_bitcoin_libs=no\n@@ -1401,7 +1409,7 @@ fi\n dnl univalue check\n \n need_bundled_univalue=yes\n-if test x$build_bitcoin_wallet$build_bitcoin_cli$build_bitcoin_tx$build_bitcoind$bitcoin_enable_qt$use_tests$use_bench = xnonononononono; then\n+if test x$build_bitcoin_wallet$build_bitcoin_cli$build_bitcoin_tx$build_bitcoin_util$build_bitcoind$bitcoin_enable_qt$use_tests$use_bench = xnononononononono; then\n   need_bundled_univalue=no\n else\n   if test x$system_univalue != xno; then\n@@ -1484,6 +1492,10 @@ AC_MSG_CHECKING([whether to build bitcoin-wallet])\n AM_CONDITIONAL([BUILD_BITCOIN_WALLET], [test x$build_bitcoin_wallet = xyes])\n AC_MSG_RESULT($build_bitcoin_wallet)\n \n+AC_MSG_CHECKING([whether to build bitcoin-util])\n+AM_CONDITIONAL([BUILD_BITCOIN_UTIL], [test x$build_bitcoin_util = xyes])\n+AC_MSG_RESULT($build_bitcoin_util)\n+\n AC_MSG_CHECKING([whether to build libraries])\n AM_CONDITIONAL([BUILD_BITCOIN_LIBS], [test x$build_bitcoin_libs = xyes])\n if test x$build_bitcoin_libs = xyes; then\n@@ -1659,6 +1671,7 @@ AC_SUBST(BITCOIN_DAEMON_NAME)\n AC_SUBST(BITCOIN_GUI_NAME)\n AC_SUBST(BITCOIN_CLI_NAME)\n AC_SUBST(BITCOIN_TX_NAME)\n+AC_SUBST(BITCOIN_UTIL_NAME)\n AC_SUBST(BITCOIN_WALLET_TOOL_NAME)\n AC_SUBST(BITCOIN_MP_NODE_NAME)\n AC_SUBST(BITCOIN_MP_GUI_NAME)"
      },
      {
        "sha": "f37db7bde777a41a95444a6c6b7f5b52fb1b9fe0",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 27,
        "deletions": 0,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/13762bcc9618138dd28b53c2031defdc9d762d26/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/13762bcc9618138dd28b53c2031defdc9d762d26/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=13762bcc9618138dd28b53c2031defdc9d762d26",
        "patch": "@@ -92,15 +92,21 @@ endif\n if BUILD_BITCOIN_CLI\n   bin_PROGRAMS += bitcoin-cli\n endif\n+\n if BUILD_BITCOIN_TX\n   bin_PROGRAMS += bitcoin-tx\n endif\n+\n if ENABLE_WALLET\n if BUILD_BITCOIN_WALLET\n   bin_PROGRAMS += bitcoin-wallet\n endif\n endif\n \n+if BUILD_BITCOIN_UTIL\n+  bin_PROGRAMS += bitcoin-util\n+endif\n+\n .PHONY: FORCE check-symbols check-security\n # bitcoin core #\n BITCOIN_CORE_H = \\\n@@ -660,6 +666,27 @@ bitcoin_wallet_SOURCES += bitcoin-wallet-res.rc\n endif\n #\n \n+# bitcoin-util binary #\n+bitcoin_util_SOURCES = bitcoin-util.cpp\n+bitcoin_util_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n+bitcoin_util_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n+bitcoin_util_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n+\n+if TARGET_WINDOWS\n+bitcoin_util_SOURCES += bitcoin-util-res.rc\n+endif\n+\n+bitcoin_util_LDADD = \\\n+  $(LIBBITCOIN_COMMON) \\\n+  $(LIBBITCOIN_UTIL) \\\n+  $(LIBUNIVALUE) \\\n+  $(LIBBITCOIN_CONSENSUS) \\\n+  $(LIBBITCOIN_CRYPTO) \\\n+  $(LIBSECP256K1)\n+\n+bitcoin_util_LDADD += $(BOOST_LIBS)\n+#\n+\n # bitcoinconsensus library #\n if BUILD_BITCOIN_LIBS\n include_HEADERS = script/bitcoinconsensus.h"
      },
      {
        "sha": "3f0fa8ab6d61481b27d5a3160cfd9f214328cb5b",
        "filename": "src/bitcoin-util-res.rc",
        "status": "added",
        "additions": 35,
        "deletions": 0,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/13762bcc9618138dd28b53c2031defdc9d762d26/src/bitcoin-util-res.rc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/13762bcc9618138dd28b53c2031defdc9d762d26/src/bitcoin-util-res.rc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-util-res.rc?ref=13762bcc9618138dd28b53c2031defdc9d762d26",
        "patch": "@@ -0,0 +1,35 @@\n+#include <windows.h>             // needed for VERSIONINFO\n+#include \"clientversion.h\"       // holds the needed client version information\n+\n+#define VER_PRODUCTVERSION     CLIENT_VERSION_MAJOR,CLIENT_VERSION_MINOR,CLIENT_VERSION_BUILD\n+#define VER_PRODUCTVERSION_STR STRINGIZE(CLIENT_VERSION_MAJOR) \".\" STRINGIZE(CLIENT_VERSION_MINOR) \".\" STRINGIZE(CLIENT_VERSION_BUILD)\n+#define VER_FILEVERSION        VER_PRODUCTVERSION\n+#define VER_FILEVERSION_STR    VER_PRODUCTVERSION_STR\n+\n+VS_VERSION_INFO VERSIONINFO\n+FILEVERSION     VER_FILEVERSION\n+PRODUCTVERSION  VER_PRODUCTVERSION\n+FILEOS          VOS_NT_WINDOWS32\n+FILETYPE        VFT_APP\n+BEGIN\n+    BLOCK \"StringFileInfo\"\n+    BEGIN\n+        BLOCK \"040904E4\" // U.S. English - multilingual (hex)\n+        BEGIN\n+            VALUE \"CompanyName\",        \"Bitcoin\"\n+            VALUE \"FileDescription\",    \"bitcoin-util (CLI Bitcoin utility)\"\n+            VALUE \"FileVersion\",        VER_FILEVERSION_STR\n+            VALUE \"InternalName\",       \"bitcoin-util\"\n+            VALUE \"LegalCopyright\",     COPYRIGHT_STR\n+            VALUE \"LegalTrademarks1\",   \"Distributed under the MIT software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\"\n+            VALUE \"OriginalFilename\",   \"bitcoin-util.exe\"\n+            VALUE \"ProductName\",        \"bitcoin-util\"\n+            VALUE \"ProductVersion\",     VER_PRODUCTVERSION_STR\n+        END\n+    END\n+\n+    BLOCK \"VarFileInfo\"\n+    BEGIN\n+        VALUE \"Translation\", 0x0, 1252 // language neutral - multilingual (decimal)\n+    END\n+END"
      },
      {
        "sha": "f7e670f4e0c231412656aa8be8997fd160458014",
        "filename": "src/bitcoin-util.cpp",
        "status": "added",
        "additions": 207,
        "deletions": 0,
        "changes": 207,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/13762bcc9618138dd28b53c2031defdc9d762d26/src/bitcoin-util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/13762bcc9618138dd28b53c2031defdc9d762d26/src/bitcoin-util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-util.cpp?ref=13762bcc9618138dd28b53c2031defdc9d762d26",
        "patch": "@@ -0,0 +1,207 @@\n+// Copyright (c) 2009-2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <arith_uint256.h>\n+#include <clientversion.h>\n+#include <coins.h>\n+#include <consensus/consensus.h>\n+#include <core_io.h>\n+#include <key_io.h>\n+#include <policy/rbf.h>\n+#include <primitives/transaction.h>\n+#include <script/script.h>\n+#include <script/sign.h>\n+#include <script/signingprovider.h>\n+#include <univalue.h>\n+#include <util/moneystr.h>\n+#include <util/rbf.h>\n+#include <util/strencodings.h>\n+#include <util/string.h>\n+#include <util/system.h>\n+#include <util/translation.h>\n+\n+#include <functional>\n+#include <memory>\n+#include <stdio.h>\n+#include <thread>\n+\n+#include <boost/algorithm/string.hpp>\n+\n+static const int CONTINUE_EXECUTION=-1;\n+\n+const std::function<std::string(const char*)> G_TRANSLATION_FUN = nullptr;\n+\n+static void SetupBitcoinUtilArgs(ArgsManager &argsman)\n+{\n+    SetupHelpOptions(argsman);\n+\n+    SetupChainParamsBaseOptions(argsman);\n+}\n+\n+// This function returns either one of EXIT_ codes when it's expected to stop the process or\n+// CONTINUE_EXECUTION when it's expected to continue further.\n+static int AppInitUtil(int argc, char* argv[])\n+{\n+    SetupBitcoinUtilArgs(gArgs);\n+    std::string error;\n+    if (!gArgs.ParseParameters(argc, argv, error)) {\n+        tfm::format(std::cerr, \"Error parsing command line arguments: %s\\n\", error);\n+        return EXIT_FAILURE;\n+    }\n+\n+    // Check for chain settings (Params() calls are only valid after this clause)\n+    try {\n+        SelectParams(gArgs.GetChainName());\n+    } catch (const std::exception& e) {\n+        tfm::format(std::cerr, \"Error: %s\\n\", e.what());\n+        return EXIT_FAILURE;\n+    }\n+\n+    if (argc < 2 || HelpRequested(gArgs)) {\n+        // First part of help message is specific to this utility\n+        std::string strUsage = PACKAGE_NAME \" bitcoin-util utility version \" + FormatFullVersion() + \"\\n\\n\" +\n+            \"Usage:  bitcoin-util [options] [commands]  Do stuff\\n\" +\n+            \"\\n\";\n+        strUsage += gArgs.GetHelpMessage();\n+\n+        tfm::format(std::cout, \"%s\", strUsage);\n+\n+        if (argc < 2) {\n+            tfm::format(std::cerr, \"Error: too few parameters\\n\");\n+            return EXIT_FAILURE;\n+        }\n+        return EXIT_SUCCESS;\n+    }\n+    return CONTINUE_EXECUTION;\n+}\n+\n+static void grind_task(uint32_t nBits, CBlockHeader& header_orig, uint32_t offset, uint32_t step, std::atomic<bool>& found)\n+{\n+    arith_uint256 target;\n+    bool neg, over;\n+    target.SetCompact(nBits, &neg, &over);\n+    if (target == 0 || neg || over) return;\n+    CBlockHeader header = header_orig; // working copy\n+    header.nNonce = offset;\n+\n+    uint32_t finish = std::numeric_limits<uint32_t>::max() - step;\n+    finish = finish - (finish % step) + offset;\n+\n+    while (!found && header.nNonce < finish) {\n+        const uint32_t next = (finish - header.nNonce < 5000*step) ? finish : header.nNonce + 5000*step;\n+        do {\n+            if (UintToArith256(header.GetHash()) <= target) {\n+                if (!found.exchange(true)) {\n+                    header_orig.nNonce = header.nNonce;\n+                }\n+                return;\n+            }\n+            header.nNonce += step;\n+        } while(header.nNonce != next);\n+    }\n+}\n+\n+static int Grind(int argc, char* argv[], std::string& strPrint)\n+{\n+    if (argc != 1) {\n+        strPrint = \"Must specify block header to grind\";\n+        return 1;\n+    }\n+\n+    CBlockHeader header;\n+    if (!DecodeHexBlockHeader(header, argv[0])) {\n+        strPrint = \"Could not decode block header\";\n+        return 1;\n+    }\n+\n+    uint32_t nBits = header.nBits;\n+    std::atomic<bool> found{false};\n+\n+    std::vector<std::thread> threads;\n+    int n_tasks = std::max(1u, std::thread::hardware_concurrency());\n+    for (int i = 0; i < n_tasks; ++i) {\n+        threads.emplace_back( grind_task, nBits, std::ref(header), i, n_tasks, std::ref(found) );\n+    }\n+    for (auto& t : threads) {\n+        t.join();\n+    }\n+    if (!found) {\n+        strPrint = \"Could not satisfy difficulty target\";\n+        return 1;\n+    }\n+\n+    CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n+    ss << header;\n+    strPrint = HexStr(ss);\n+    return 0;\n+}\n+\n+static int CommandLineUtil(int argc, char* argv[])\n+{\n+    if (argc <= 1) return 1;\n+\n+    std::string strPrint;\n+    int nRet = 0;\n+\n+    try {\n+        while (argc > 1 && IsSwitchChar(argv[1][0]) && (argv[1][1] != 0)) {\n+            --argc;\n+            ++argv;\n+        }\n+\n+        char* command = argv[1];\n+        if (strcmp(command, \"grind\") == 0) {\n+            nRet = Grind(argc-2, argv+2, strPrint);\n+        } else {\n+            strPrint = strprintf(\"Unknown command %s\", command);\n+            nRet = 1;\n+        }\n+    }\n+    catch (const std::exception& e) {\n+        strPrint = std::string(\"error: \") + e.what();\n+        nRet = EXIT_FAILURE;\n+    }\n+    catch (...) {\n+        PrintExceptionContinue(nullptr, \"CommandLineUtil()\");\n+        throw;\n+    }\n+\n+    if (strPrint != \"\") {\n+        tfm::format(nRet == 0 ? std::cout : std::cerr, \"%s\\n\", strPrint);\n+    }\n+    return nRet;\n+}\n+\n+int main(int argc, char* argv[])\n+{\n+    SetupEnvironment();\n+\n+    try {\n+        int ret = AppInitUtil(argc, argv);\n+        if (ret != CONTINUE_EXECUTION)\n+            return ret;\n+    }\n+    catch (const std::exception& e) {\n+        PrintExceptionContinue(&e, \"AppInitUtil()\");\n+        return EXIT_FAILURE;\n+    } catch (...) {\n+        PrintExceptionContinue(nullptr, \"AppInitUtil()\");\n+        return EXIT_FAILURE;\n+    }\n+\n+    int ret = EXIT_FAILURE;\n+    try {\n+        ret = CommandLineUtil(argc, argv);\n+    }\n+    catch (const std::exception& e) {\n+        PrintExceptionContinue(&e, \"CommandLineUtil()\");\n+    } catch (...) {\n+        PrintExceptionContinue(nullptr, \"CommandLineUtil()\");\n+    }\n+    return ret;\n+}"
      }
    ]
  },
  {
    "sha": "ff7dbdc08a11e999e7718b6ac7645ecceef81188",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmZjdkYmRjMDhhMTFlOTk5ZTc3MThiNmFjNzY0NWVjY2VlZjgxMTg4",
    "commit": {
      "author": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2020-09-09T22:37:55Z"
      },
      "committer": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2021-01-12T08:34:29Z"
      },
      "message": "contrib/signet: Add script for generating a signet chain",
      "tree": {
        "sha": "4ff4acd8207fcdbc4983da2efa463324f1a0af86",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4ff4acd8207fcdbc4983da2efa463324f1a0af86"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ff7dbdc08a11e999e7718b6ac7645ecceef81188",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ff7dbdc08a11e999e7718b6ac7645ecceef81188",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ff7dbdc08a11e999e7718b6ac7645ecceef81188",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ff7dbdc08a11e999e7718b6ac7645ecceef81188/comments",
    "author": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "13762bcc9618138dd28b53c2031defdc9d762d26",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/13762bcc9618138dd28b53c2031defdc9d762d26",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/13762bcc9618138dd28b53c2031defdc9d762d26"
      }
    ],
    "stats": {
      "total": 639,
      "additions": 639,
      "deletions": 0
    },
    "files": [
      {
        "sha": "a3fba49d0e1ac7917460924a0b94d0bc24786367",
        "filename": "contrib/signet/miner",
        "status": "added",
        "additions": 639,
        "deletions": 0,
        "changes": 639,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ff7dbdc08a11e999e7718b6ac7645ecceef81188/contrib/signet/miner",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ff7dbdc08a11e999e7718b6ac7645ecceef81188/contrib/signet/miner",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/signet/miner?ref=ff7dbdc08a11e999e7718b6ac7645ecceef81188",
        "patch": "@@ -0,0 +1,639 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2020 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+import argparse\n+import base64\n+import json\n+import logging\n+import math\n+import os.path\n+import re\n+import struct\n+import sys\n+import time\n+import subprocess\n+\n+from binascii import unhexlify\n+from io import BytesIO\n+\n+PATH_BASE_CONTRIB_SIGNET = os.path.abspath(os.path.dirname(os.path.realpath(__file__)))\n+PATH_BASE_TEST_FUNCTIONAL = os.path.abspath(os.path.join(PATH_BASE_CONTRIB_SIGNET, \"..\", \"..\", \"test\", \"functional\"))\n+sys.path.insert(0, PATH_BASE_TEST_FUNCTIONAL)\n+\n+from test_framework.blocktools import WITNESS_COMMITMENT_HEADER, script_BIP34_coinbase_height # noqa: E402\n+from test_framework.messages import CBlock, CBlockHeader, COutPoint, CTransaction, CTxIn, CTxInWitness, CTxOut, FromHex, ToHex, deser_string, hash256, ser_compact_size, ser_string, ser_uint256, uint256_from_str # noqa: E402\n+from test_framework.script import CScriptOp # noqa: E402\n+\n+logging.basicConfig(\n+    format='%(asctime)s %(levelname)s %(message)s',\n+    level=logging.INFO,\n+    datefmt='%Y-%m-%d %H:%M:%S')\n+\n+SIGNET_HEADER = b\"\\xec\\xc7\\xda\\xa2\"\n+PSBT_SIGNET_BLOCK = b\"\\xfc\\x06signetb\"    # proprietary PSBT global field holding the block being signed\n+RE_MULTIMINER = re.compile(\"^(\\d+)(-(\\d+))?/(\\d+)$\")\n+\n+# #### some helpers that could go into test_framework\n+\n+# like FromHex, but without the hex part\n+def FromBinary(cls, stream):\n+    \"\"\"deserialize a binary stream (or bytes object) into an object\"\"\"\n+    # handle bytes object by turning it into a stream\n+    was_bytes = isinstance(stream, bytes)\n+    if was_bytes:\n+        stream = BytesIO(stream)\n+    obj = cls()\n+    obj.deserialize(stream)\n+    if was_bytes:\n+        assert len(stream.read()) == 0\n+    return obj\n+\n+class PSBTMap:\n+    \"\"\"Class for serializing and deserializing PSBT maps\"\"\"\n+\n+    def __init__(self, map=None):\n+        self.map = map if map is not None else {}\n+\n+    def deserialize(self, f):\n+        m = {}\n+        while True:\n+            k = deser_string(f)\n+            if len(k) == 0:\n+                break\n+            v = deser_string(f)\n+            if len(k) == 1:\n+                k = k[0]\n+            assert k not in m\n+            m[k] = v\n+        self.map = m\n+\n+    def serialize(self):\n+        m = b\"\"\n+        for k,v in self.map.items():\n+            if isinstance(k, int) and 0 <= k and k <= 255:\n+                k = bytes([k])\n+            m += ser_compact_size(len(k)) + k\n+            m += ser_compact_size(len(v)) + v\n+        m += b\"\\x00\"\n+        return m\n+\n+class PSBT:\n+    \"\"\"Class for serializing and deserializing PSBTs\"\"\"\n+\n+    def __init__(self):\n+        self.g = PSBTMap()\n+        self.i = []\n+        self.o = []\n+        self.tx = None\n+\n+    def deserialize(self, f):\n+        assert f.read(5) == b\"psbt\\xff\"\n+        self.g = FromBinary(PSBTMap, f)\n+        assert 0 in self.g.map\n+        self.tx = FromBinary(CTransaction, self.g.map[0])\n+        self.i = [FromBinary(PSBTMap, f) for _ in self.tx.vin]\n+        self.o = [FromBinary(PSBTMap, f) for _ in self.tx.vout]\n+        return self\n+\n+    def serialize(self):\n+        assert isinstance(self.g, PSBTMap)\n+        assert isinstance(self.i, list) and all(isinstance(x, PSBTMap) for x in self.i)\n+        assert isinstance(self.o, list) and all(isinstance(x, PSBTMap) for x in self.o)\n+        assert 0 in self.g.map\n+        tx = FromBinary(CTransaction, self.g.map[0])\n+        assert len(tx.vin) == len(self.i)\n+        assert len(tx.vout) == len(self.o)\n+\n+        psbt = [x.serialize() for x in [self.g] + self.i + self.o]\n+        return b\"psbt\\xff\" + b\"\".join(psbt)\n+\n+    def to_base64(self):\n+        return base64.b64encode(self.serialize()).decode(\"utf8\")\n+\n+    @classmethod\n+    def from_base64(cls, b64psbt):\n+        return FromBinary(cls, base64.b64decode(b64psbt))\n+\n+# #####\n+\n+def create_coinbase(height, value, spk):\n+    cb = CTransaction()\n+    cb.vin = [CTxIn(COutPoint(0, 0xffffffff), script_BIP34_coinbase_height(height), 0xffffffff)]\n+    cb.vout = [CTxOut(value, spk)]\n+    return cb\n+\n+def get_witness_script(witness_root, witness_nonce):\n+    commitment = uint256_from_str(hash256(ser_uint256(witness_root) + ser_uint256(witness_nonce)))\n+    return b\"\\x6a\" + CScriptOp.encode_op_pushdata(WITNESS_COMMITMENT_HEADER + ser_uint256(commitment))\n+\n+def signet_txs(block, challenge):\n+    # assumes signet solution has not been added yet so does not need\n+    # to be removed\n+\n+    txs = block.vtx[:]\n+    txs[0] = CTransaction(txs[0])\n+    txs[0].vout[-1].scriptPubKey += CScriptOp.encode_op_pushdata(SIGNET_HEADER)\n+    hashes = []\n+    for tx in txs:\n+        tx.rehash()\n+        hashes.append(ser_uint256(tx.sha256))\n+    mroot = block.get_merkle_root(hashes)\n+\n+    sd = b\"\"\n+    sd += struct.pack(\"<i\", block.nVersion)\n+    sd += ser_uint256(block.hashPrevBlock)\n+    sd += ser_uint256(mroot)\n+    sd += struct.pack(\"<I\", block.nTime)\n+\n+    to_spend = CTransaction()\n+    to_spend.nVersion = 0\n+    to_spend.nLockTime = 0\n+    to_spend.vin = [CTxIn(COutPoint(0, 0xFFFFFFFF), b\"\\x00\" + CScriptOp.encode_op_pushdata(sd), 0)]\n+    to_spend.vout = [CTxOut(0, challenge)]\n+    to_spend.rehash()\n+\n+    spend = CTransaction()\n+    spend.nVersion = 0\n+    spend.nLockTime = 0\n+    spend.vin = [CTxIn(COutPoint(to_spend.sha256, 0), b\"\", 0)]\n+    spend.vout = [CTxOut(0, b\"\\x6a\")]\n+\n+    return spend, to_spend\n+\n+def do_createpsbt(block, signme, spendme):\n+    psbt = PSBT()\n+    psbt.g = PSBTMap( {0: signme.serialize(),\n+                       PSBT_SIGNET_BLOCK: block.serialize()\n+                     } )\n+    psbt.i = [ PSBTMap( {0: spendme.serialize(),\n+                         3: bytes([1,0,0,0])})\n+             ]\n+    psbt.o = [ PSBTMap() ]\n+    return psbt.to_base64()\n+\n+def do_decode_psbt(b64psbt):\n+    psbt = PSBT.from_base64(b64psbt)\n+\n+    assert len(psbt.tx.vin) == 1\n+    assert len(psbt.tx.vout) == 1\n+    assert PSBT_SIGNET_BLOCK in psbt.g.map\n+\n+    scriptSig = psbt.i[0].map.get(7, b\"\")\n+    scriptWitness = psbt.i[0].map.get(8, b\"\\x00\")\n+\n+    return FromBinary(CBlock, psbt.g.map[PSBT_SIGNET_BLOCK]), ser_string(scriptSig) + scriptWitness\n+\n+def finish_block(block, signet_solution, grind_cmd):\n+    block.vtx[0].vout[-1].scriptPubKey += CScriptOp.encode_op_pushdata(SIGNET_HEADER + signet_solution)\n+    block.vtx[0].rehash()\n+    block.hashMerkleRoot = block.calc_merkle_root()\n+    if grind_cmd is None:\n+        block.solve()\n+    else:\n+        headhex = CBlockHeader.serialize(block).hex()\n+        cmd = grind_cmd.split(\" \") + [headhex]\n+        newheadhex = subprocess.run(cmd, stdout=subprocess.PIPE, input=b\"\", check=True).stdout.strip()\n+        newhead = FromHex(CBlockHeader(), newheadhex.decode('utf8'))\n+        block.nNonce = newhead.nNonce\n+        block.rehash()\n+    return block\n+\n+def generate_psbt(tmpl, reward_spk, *, blocktime=None):\n+    signet_spk = tmpl[\"signet_challenge\"]\n+    signet_spk_bin = unhexlify(signet_spk)\n+\n+    cbtx = create_coinbase(height=tmpl[\"height\"], value=tmpl[\"coinbasevalue\"], spk=reward_spk)\n+    cbtx.vin[0].nSequence = 2**32-2\n+    cbtx.rehash()\n+\n+    block = CBlock()\n+    block.nVersion = tmpl[\"version\"]\n+    block.hashPrevBlock = int(tmpl[\"previousblockhash\"], 16)\n+    block.nTime = tmpl[\"curtime\"] if blocktime is None else blocktime\n+    if block.nTime < tmpl[\"mintime\"]:\n+        block.nTime = tmpl[\"mintime\"]\n+    block.nBits = int(tmpl[\"bits\"], 16)\n+    block.nNonce = 0\n+    block.vtx = [cbtx] + [FromHex(CTransaction(), t[\"data\"]) for t in tmpl[\"transactions\"]]\n+\n+    witnonce = 0\n+    witroot = block.calc_witness_merkle_root()\n+    cbwit = CTxInWitness()\n+    cbwit.scriptWitness.stack = [ser_uint256(witnonce)]\n+    block.vtx[0].wit.vtxinwit = [cbwit]\n+    block.vtx[0].vout.append(CTxOut(0, get_witness_script(witroot, witnonce)))\n+\n+    signme, spendme = signet_txs(block, signet_spk_bin)\n+\n+    return do_createpsbt(block, signme, spendme)\n+\n+def get_reward_address(args, height):\n+    if args.address is not None:\n+        return args.address\n+\n+    if '*' not in args.descriptor:\n+        addr = json.loads(args.bcli(\"deriveaddresses\", args.descriptor))[0]\n+        args.address = addr\n+        return addr\n+\n+    remove = [k for k in args.derived_addresses.keys() if k+20 <= height]\n+    for k in remove:\n+        del args.derived_addresses[k]\n+\n+    addr = args.derived_addresses.get(height, None)\n+    if addr is None:\n+        addrs = json.loads(args.bcli(\"deriveaddresses\", args.descriptor, \"[%d,%d]\" % (height, height+20)))\n+        addr = addrs[0]\n+        for k, a in enumerate(addrs):\n+            args.derived_addresses[height+k] = a\n+\n+    return addr\n+\n+def get_reward_addr_spk(args, height):\n+    assert args.address is not None or args.descriptor is not None\n+\n+    if hasattr(args, \"reward_spk\"):\n+        return args.address, args.reward_spk\n+\n+    reward_addr = get_reward_address(args, height)\n+    reward_spk = unhexlify(json.loads(args.bcli(\"getaddressinfo\", reward_addr))[\"scriptPubKey\"])\n+    if args.address is not None:\n+        # will always be the same, so cache\n+        args.reward_spk = reward_spk\n+\n+    return reward_addr, reward_spk\n+\n+def do_genpsbt(args):\n+    tmpl = json.load(sys.stdin)\n+    _, reward_spk = get_reward_addr_spk(args, tmpl[\"height\"])\n+    psbt = generate_psbt(tmpl, reward_spk)\n+    print(psbt)\n+\n+def do_solvepsbt(args):\n+    block, signet_solution = do_decode_psbt(sys.stdin.read())\n+    block = finish_block(block, signet_solution, args.grind_cmd)\n+    print(ToHex(block))\n+\n+def nbits_to_target(nbits):\n+    shift = (nbits >> 24) & 0xff\n+    return (nbits & 0x00ffffff) * 2**(8*(shift - 3))\n+\n+def target_to_nbits(target):\n+    tstr = \"{0:x}\".format(target)\n+    if len(tstr) < 6:\n+        tstr = (\"000000\"+tstr)[-6:]\n+    if len(tstr) % 2 != 0:\n+        tstr = \"0\" + tstr\n+    if int(tstr[0],16) >= 0x8:\n+        # avoid \"negative\"\n+        tstr = \"00\" + tstr\n+    fix = int(tstr[:6], 16)\n+    sz = len(tstr)//2\n+    if tstr[6:] != \"0\"*(sz*2-6):\n+        fix += 1\n+\n+    return int(\"%02x%06x\" % (sz,fix), 16)\n+\n+def seconds_to_hms(s):\n+    if s == 0:\n+        return \"0s\"\n+    neg = (s < 0)\n+    if neg:\n+        s = -s\n+    out = \"\"\n+    if s % 60 > 0:\n+        out = \"%ds\" % (s % 60)\n+    s //= 60\n+    if s % 60 > 0:\n+        out = \"%dm%s\" % (s % 60, out)\n+    s //= 60\n+    if s > 0:\n+        out = \"%dh%s\" % (s, out)\n+    if neg:\n+        out = \"-\" + out\n+    return out\n+\n+def next_block_delta(last_nbits, last_hash, ultimate_target, do_poisson):\n+    # strategy:\n+    #  1) work out how far off our desired target we are\n+    #  2) cap it to a factor of 4 since that's the best we can do in a single retarget period\n+    #  3) use that to work out the desired average interval in this retarget period\n+    #  4) if doing poisson, use the last hash to pick a uniformly random number in [0,1), and work out a random multiplier to vary the average by\n+    #  5) cap the resulting interval between 1 second and 1 hour to avoid extremes\n+\n+    INTERVAL = 600.0*2016/2015 # 10 minutes, adjusted for the off-by-one bug\n+\n+    current_target = nbits_to_target(last_nbits)\n+    retarget_factor = ultimate_target / current_target\n+    retarget_factor = max(0.25, min(retarget_factor, 4.0))\n+\n+    avg_interval = INTERVAL * retarget_factor\n+\n+    if do_poisson:\n+        det_rand = int(last_hash[-8:], 16) * 2**-32\n+        this_interval_variance = -math.log1p(-det_rand)\n+    else:\n+        this_interval_variance = 1\n+\n+    this_interval = avg_interval * this_interval_variance\n+    this_interval = max(1, min(this_interval, 3600))\n+\n+    return this_interval\n+\n+def next_block_is_mine(last_hash, my_blocks):\n+    det_rand = int(last_hash[-16:-8], 16)\n+    return my_blocks[0] <= (det_rand % my_blocks[2]) < my_blocks[1]\n+\n+def do_generate(args):\n+    if args.max_blocks is not None:\n+        if args.ongoing:\n+            logging.error(\"Cannot specify both --ongoing and --max-blocks\")\n+            return 1\n+        if args.max_blocks < 1:\n+            logging.error(\"N must be a positive integer\")\n+            return 1\n+        max_blocks = args.max_blocks\n+    elif args.ongoing:\n+        max_blocks = None\n+    else:\n+        max_blocks = 1\n+\n+    if args.set_block_time is not None and max_blocks != 1:\n+        logging.error(\"Cannot specify --ongoing or --max-blocks > 1 when using --set-block-time\")\n+        return 1\n+    if args.set_block_time is not None and args.set_block_time < 0:\n+        args.set_block_time = time.time()\n+        logging.info(\"Treating negative block time as current time (%d)\" % (args.set_block_time))\n+\n+    if args.min_nbits:\n+        if args.nbits is not None:\n+            logging.error(\"Cannot specify --nbits and --min-nbits\")\n+            return 1\n+        args.nbits = \"1e0377ae\"\n+        logging.info(\"Using nbits=%s\" % (args.nbits))\n+\n+    if args.set_block_time is None:\n+        if args.nbits is None or len(args.nbits) != 8:\n+            logging.error(\"Must specify --nbits (use calibrate command to determine value)\")\n+            return 1\n+\n+    if args.multiminer is None:\n+       my_blocks = (0,1,1)\n+    else:\n+        if not args.ongoing:\n+            logging.error(\"Cannot specify --multiminer without --ongoing\")\n+            return 1\n+        m = RE_MULTIMINER.match(args.multiminer)\n+        if m is None:\n+            logging.error(\"--multiminer argument must be k/m or j-k/m\")\n+            return 1\n+        start,_,stop,total = m.groups()\n+        if stop is None:\n+            stop = start\n+        start, stop, total = map(int, (start, stop, total))\n+        if stop < start or start <= 0 or total < stop or total == 0:\n+            logging.error(\"Inconsistent values for --multiminer\")\n+            return 1\n+        my_blocks = (start-1, stop, total)\n+\n+    ultimate_target = nbits_to_target(int(args.nbits,16))\n+\n+    mined_blocks = 0\n+    bestheader = {\"hash\": None}\n+    lastheader = None\n+    while max_blocks is None or mined_blocks < max_blocks:\n+\n+        # current status?\n+        bci = json.loads(args.bcli(\"getblockchaininfo\"))\n+\n+        if bestheader[\"hash\"] != bci[\"bestblockhash\"]:\n+            bestheader = json.loads(args.bcli(\"getblockheader\", bci[\"bestblockhash\"]))\n+\n+        if lastheader is None:\n+            lastheader = bestheader[\"hash\"]\n+        elif bestheader[\"hash\"] != lastheader:\n+            next_delta = next_block_delta(int(bestheader[\"bits\"], 16), bestheader[\"hash\"], ultimate_target, args.poisson)\n+            next_delta += bestheader[\"time\"] - time.time()\n+            next_is_mine = next_block_is_mine(bestheader[\"hash\"], my_blocks)\n+            logging.info(\"Received new block at height %d; next in %s (%s)\", bestheader[\"height\"], seconds_to_hms(next_delta), (\"mine\" if next_is_mine else \"backup\"))\n+            lastheader = bestheader[\"hash\"]\n+\n+        # when is the next block due to be mined?\n+        now = time.time()\n+        if args.set_block_time is not None:\n+            logging.debug(\"Setting start time to %d\", args.set_block_time)\n+            mine_time = args.set_block_time\n+            action_time = now\n+            is_mine = True\n+        elif bestheader[\"height\"] == 0:\n+            logging.error(\"When mining first block in a new signet, must specify --set-block-time\")\n+            return 1\n+        else:\n+\n+            time_delta = next_block_delta(int(bestheader[\"bits\"], 16), bci[\"bestblockhash\"], ultimate_target, args.poisson)\n+            mine_time = bestheader[\"time\"] + time_delta\n+\n+            is_mine = next_block_is_mine(bci[\"bestblockhash\"], my_blocks)\n+\n+            action_time = mine_time\n+            if not is_mine:\n+                action_time += args.backup_delay\n+\n+            if args.standby_delay > 0:\n+                action_time += args.standby_delay\n+            elif mined_blocks == 0:\n+                # for non-standby, always mine immediately on startup,\n+                # even if the next block shouldn't be ours\n+                action_time = now\n+\n+        # don't want fractional times so round down\n+        mine_time = int(mine_time)\n+        action_time = int(action_time)\n+\n+        # can't mine a block 2h in the future; 1h55m for some safety\n+        action_time = max(action_time, mine_time - 6900)\n+\n+        # ready to go? otherwise sleep and check for new block\n+        if now < action_time:\n+            sleep_for = min(action_time - now, 60)\n+            if mine_time < now:\n+                # someone else might have mined the block,\n+                # so check frequently, so we don't end up late\n+                # mining the next block if it's ours\n+                sleep_for = min(20, sleep_for)\n+            minestr = \"mine\" if is_mine else \"backup\"\n+            logging.debug(\"Sleeping for %s, next block due in %s (%s)\" % (seconds_to_hms(sleep_for), seconds_to_hms(mine_time - now), minestr))\n+            time.sleep(sleep_for)\n+            continue\n+\n+        # gbt\n+        tmpl = json.loads(args.bcli(\"getblocktemplate\", '{\"rules\":[\"signet\",\"segwit\"]}'))\n+        if tmpl[\"previousblockhash\"] != bci[\"bestblockhash\"]:\n+            logging.warning(\"GBT based off unexpected block (%s not %s), retrying\", tmpl[\"previousblockhash\"], bci[\"bestblockhash\"])\n+            time.sleep(1)\n+            continue\n+\n+        logging.debug(\"GBT template: %s\", tmpl)\n+\n+        if tmpl[\"mintime\"] > mine_time:\n+            logging.info(\"Updating block time from %d to %d\", mine_time, tmpl[\"mintime\"])\n+            mine_time = tmpl[\"mintime\"]\n+            if mine_time > now:\n+                logging.error(\"GBT mintime is in the future: %d is %d seconds later than %d\", mine_time, (mine_time-now), now)\n+                return 1\n+\n+        # address for reward\n+        reward_addr, reward_spk = get_reward_addr_spk(args, tmpl[\"height\"])\n+\n+        # mine block\n+        logging.debug(\"Mining block delta=%s start=%s mine=%s\", seconds_to_hms(mine_time-bestheader[\"time\"]), mine_time, is_mine)\n+        mined_blocks += 1\n+        psbt = generate_psbt(tmpl, reward_spk, blocktime=mine_time)\n+        psbt_signed = json.loads(args.bcli(\"-stdin\", \"walletprocesspsbt\", input=psbt.encode('utf8')))\n+        if not psbt_signed.get(\"complete\",False):\n+            logging.debug(\"Generated PSBT: %s\" % (psbt,))\n+            sys.stderr.write(\"PSBT signing failed\")\n+            return 1\n+        block, signet_solution = do_decode_psbt(psbt_signed[\"psbt\"])\n+        block = finish_block(block, signet_solution, args.grind_cmd)\n+\n+        # submit block\n+        r = args.bcli(\"-stdin\", \"submitblock\", input=ToHex(block).encode('utf8'))\n+\n+        # report\n+        bstr = \"block\" if is_mine else \"backup block\"\n+\n+        next_delta = next_block_delta(block.nBits, block.hash, ultimate_target, args.poisson)\n+        next_delta += block.nTime - time.time()\n+        next_is_mine = next_block_is_mine(block.hash, my_blocks)\n+\n+        logging.debug(\"Block hash %s payout to %s\", block.hash, reward_addr)\n+        logging.info(\"Mined %s at height %d; next in %s (%s)\", bstr, tmpl[\"height\"], seconds_to_hms(next_delta), (\"mine\" if next_is_mine else \"backup\"))\n+        if r != \"\":\n+            logging.warning(\"submitblock returned %s for height %d hash %s\", r, tmpl[\"height\"], block.hash)\n+        lastheader = block.hash\n+\n+def do_calibrate(args):\n+    if args.nbits is not None and args.seconds is not None:\n+        sys.stderr.write(\"Can only specify one of --nbits or --seconds\\n\")\n+        return 1\n+    if args.nbits is not None and len(args.nbits) != 8:\n+        sys.stderr.write(\"Must specify 8 hex digits for --nbits\")\n+        return 1\n+\n+    TRIALS = 600 # gets variance down pretty low\n+    TRIAL_BITS = 0x1e3ea75f # takes about 5m to do 600 trials\n+    #TRIAL_BITS = 0x1e7ea75f # XXX\n+\n+    header = CBlockHeader()\n+    header.nBits = TRIAL_BITS\n+    targ = nbits_to_target(header.nBits)\n+\n+    start = time.time()\n+    count = 0\n+    #CHECKS=[]\n+    for i in range(TRIALS):\n+        header.nTime = i\n+        header.nNonce = 0\n+        headhex = header.serialize().hex()\n+        cmd = args.grind_cmd.split(\" \") + [headhex]\n+        newheadhex = subprocess.run(cmd, stdout=subprocess.PIPE, input=b\"\", check=True).stdout.strip()\n+        #newhead = FromHex(CBlockHeader(), newheadhex.decode('utf8'))\n+        #count += newhead.nNonce\n+        #if (i+1) % 100 == 0:\n+        #   CHECKS.append((i+1, count, time.time()-start))\n+\n+    #print(\"checks =\", [c*1.0 / (b*targ*2**-256) for _,b,c in CHECKS])\n+\n+    avg = (time.time() - start) * 1.0 / TRIALS\n+    #exp_count = 2**256 / targ * TRIALS\n+    #print(\"avg =\", avg, \"count =\", count, \"exp_count =\", exp_count)\n+\n+    if args.nbits is not None:\n+        want_targ = nbits_to_target(int(args.nbits,16))\n+        want_time = avg*targ/want_targ\n+    else:\n+        want_time = args.seconds if args.seconds is not None else 25\n+        want_targ = int(targ*(avg/want_time))\n+\n+    print(\"nbits=%08x for %ds average mining time\" % (target_to_nbits(want_targ), want_time))\n+    return 0\n+\n+def bitcoin_cli(basecmd, args, **kwargs):\n+    cmd = basecmd + [\"-signet\"] + args\n+    logging.debug(\"Calling bitcoin-cli: %r\", cmd)\n+    out = subprocess.run(cmd, stdout=subprocess.PIPE, **kwargs, check=True).stdout\n+    if isinstance(out, bytes):\n+        out = out.decode('utf8')\n+    return out.strip()\n+\n+def main():\n+    parser = argparse.ArgumentParser()\n+    parser.add_argument(\"--cli\", default=\"bitcoin-cli\", type=str, help=\"bitcoin-cli command\")\n+    parser.add_argument(\"--debug\", action=\"store_true\", help=\"Print debugging info\")\n+    parser.add_argument(\"--quiet\", action=\"store_true\", help=\"Only print warnings/errors\")\n+\n+    cmds = parser.add_subparsers(help=\"sub-commands\")\n+    genpsbt = cmds.add_parser(\"genpsbt\", help=\"Generate a block PSBT for signing\")\n+    genpsbt.set_defaults(fn=do_genpsbt)\n+\n+    solvepsbt = cmds.add_parser(\"solvepsbt\", help=\"Solve a signed block PSBT\")\n+    solvepsbt.set_defaults(fn=do_solvepsbt)\n+\n+    generate = cmds.add_parser(\"generate\", help=\"Mine blocks\")\n+    generate.set_defaults(fn=do_generate)\n+    generate.add_argument(\"--ongoing\", action=\"store_true\", help=\"Keep mining blocks\")\n+    generate.add_argument(\"--max-blocks\", default=None, type=int, help=\"Max blocks to mine (default=1)\")\n+    generate.add_argument(\"--set-block-time\", default=None, type=int, help=\"Set block time (unix timestamp)\")\n+    generate.add_argument(\"--nbits\", default=None, type=str, help=\"Target nBits (specify difficulty)\")\n+    generate.add_argument(\"--min-nbits\", action=\"store_true\", help=\"Target minimum nBits (use min difficulty)\")\n+    generate.add_argument(\"--poisson\", action=\"store_true\", help=\"Simulate randomised block times\")\n+    #generate.add_argument(\"--signcmd\", default=None, type=str, help=\"Alternative signing command\")\n+    generate.add_argument(\"--multiminer\", default=None, type=str, help=\"Specify which set of blocks to mine (eg: 1-40/100 for the first 40%%, 2/3 for the second 3rd)\")\n+    generate.add_argument(\"--backup-delay\", default=300, type=int, help=\"Seconds to delay before mining blocks reserved for other miners (default=300)\")\n+    generate.add_argument(\"--standby-delay\", default=0, type=int, help=\"Seconds to delay before mining blocks (default=0)\")\n+\n+    calibrate = cmds.add_parser(\"calibrate\", help=\"Calibrate difficulty\")\n+    calibrate.set_defaults(fn=do_calibrate)\n+    calibrate.add_argument(\"--nbits\", type=str, default=None)\n+    calibrate.add_argument(\"--seconds\", type=int, default=None)\n+\n+    for sp in [genpsbt, generate]:\n+        sp.add_argument(\"--address\", default=None, type=str, help=\"Address for block reward payment\")\n+        sp.add_argument(\"--descriptor\", default=None, type=str, help=\"Descriptor for block reward payment\")\n+\n+    for sp in [solvepsbt, generate, calibrate]:\n+        sp.add_argument(\"--grind-cmd\", default=None, type=str, help=\"Command to grind a block header for proof-of-work\")\n+\n+    args = parser.parse_args(sys.argv[1:])\n+\n+    args.bcli = lambda *a, input=b\"\", **kwargs: bitcoin_cli(args.cli.split(\" \"), list(a), input=input, **kwargs)\n+\n+    if hasattr(args, \"address\") and hasattr(args, \"descriptor\"):\n+        if args.address is None and args.descriptor is None:\n+            sys.stderr.write(\"Must specify --address or --descriptor\\n\")\n+            return 1\n+        elif args.address is not None and args.descriptor is not None:\n+            sys.stderr.write(\"Only specify one of --address or --descriptor\\n\")\n+            return 1\n+        args.derived_addresses = {}\n+\n+    if args.debug:\n+        logging.getLogger().setLevel(logging.DEBUG)\n+    elif args.quiet:\n+        logging.getLogger().setLevel(logging.WARNING)\n+    else:\n+        logging.getLogger().setLevel(logging.INFO)\n+\n+    if hasattr(args, \"fn\"):\n+        return args.fn(args)\n+    else:\n+        logging.error(\"Must specify command\")\n+        return 1\n+\n+if __name__ == \"__main__\":\n+    main()\n+\n+"
      }
    ]
  },
  {
    "sha": "595a34dbea01954cb0372b0210d2fd64357a1762",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1OTVhMzRkYmVhMDE5NTRjYjAzNzJiMDIxMGQyZmQ2NDM1N2ExNzYy",
    "commit": {
      "author": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2020-11-10T05:39:07Z"
      },
      "committer": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2021-01-12T08:34:29Z"
      },
      "message": "contrib/signet: Document miner script in README.md",
      "tree": {
        "sha": "254dc766e60423e6a090ebf0b97dabfaff0328bf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/254dc766e60423e6a090ebf0b97dabfaff0328bf"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/595a34dbea01954cb0372b0210d2fd64357a1762",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/595a34dbea01954cb0372b0210d2fd64357a1762",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/595a34dbea01954cb0372b0210d2fd64357a1762",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/595a34dbea01954cb0372b0210d2fd64357a1762/comments",
    "author": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ff7dbdc08a11e999e7718b6ac7645ecceef81188",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ff7dbdc08a11e999e7718b6ac7645ecceef81188",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ff7dbdc08a11e999e7718b6ac7645ecceef81188"
      }
    ],
    "stats": {
      "total": 61,
      "additions": 61,
      "deletions": 0
    },
    "files": [
      {
        "sha": "71dc2f96382e0038b1a0ff0a7cf5a9d460a858c1",
        "filename": "contrib/signet/README.md",
        "status": "modified",
        "additions": 61,
        "deletions": 0,
        "changes": 61,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/595a34dbea01954cb0372b0210d2fd64357a1762/contrib/signet/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/595a34dbea01954cb0372b0210d2fd64357a1762/contrib/signet/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/signet/README.md?ref=595a34dbea01954cb0372b0210d2fd64357a1762",
        "patch": "@@ -17,3 +17,64 @@ Syntax: `getcoins.py [-h|--help] [-c|--cmd=<bitcoin-cli path>] [-f|--faucet=<fau\n If using the default network, invoking the script with no arguments should be sufficient under normal\n circumstances, but if multiple people are behind the same IP address, the faucet will by default only\n accept one claim per day. See `--password` above.\n+\n+miner\n+=====\n+\n+To mine the first block in your custom chain, you can run:\n+\n+    cd src/\n+    CLI=\"./bitcoin-cli -conf=mysignet.conf\"\n+    MINER=\"..contrib/signet/miner\"\n+    GRIND=\"./bitcoin-util grind\"\n+    ADDR=$($CLI -signet getnewaddress)\n+    $MINER --cli=\"$CLI\" generate --grind-cmd=\"$GRIND\" --address=\"$ADDR\" --set-block-time=-1\n+\n+This will mine a block with the current timestamp. If you want to backdate the chain, you can give a different timestamp to --set-block-time.\n+\n+You will then need to pick a difficulty target. Since signet chains are primarily protected by a signature rather than proof of work, there is no need to spend as much energy as possible mining, however you may wish to choose to spend more time than the absolute minimum. The calibrate subcommand can be used to pick a target, eg:\n+\n+    $MINER calibrate --grind-cmd=\"$GRIND\"\n+    nbits=1e00f403 for 25s average mining time\n+\n+It defaults to estimating an nbits value resulting in 25s average time to find a block, but the --seconds parameter can be used to pick a different target, or the --nbits parameter can be used to estimate how long it will take for a given difficulty.\n+\n+Using the --ongoing parameter will then cause the signet miner to create blocks indefinitely. It will pick the time between blocks so that difficulty is adjusted to match the provided --nbits value.\n+\n+    $MINER --cli=\"$CLI\" generate --grind-cmd=\"$GRIND\" --address=\"$ADDR\" --nbits=1e00f403 --ongoing\n+\n+Other options\n+-------------\n+\n+The --debug and --quiet options are available to control how noisy the signet miner's output is. Note that the --debug, --quiet and --cli parameters must all appear before the subcommand (generate, calibrate, etc) if used.\n+\n+Instead of specifying --ongoing, you can specify --max-blocks=N to mine N blocks and stop.\n+\n+Instead of using a single address, a ranged descriptor may be provided instead (via the --descriptor parameter), with the reward for the block at height H being sent to the H'th address generated from the descriptor.\n+\n+Instead of calculating a specific nbits value, --min-nbits can be specified instead, in which case the mininmum signet difficulty will be targeted.\n+\n+By default, the signet miner mines blocks at fixed intervals with minimal variation. If you want blocks to appear more randomly, as they do in mainnet, specify the --poisson option.\n+\n+Using the --multiminer parameter allows mining to be distributed amongst multiple miners. For example, if you have 3 miners and want to share blocks between them, specify --multiminer=1/3 on one, --multiminer=2/3 on another, and --multiminer=3/3 on the last one. If you want one to do 10% of blocks and two others to do 45% each, --multiminer=1-10/100 on the first, and --multiminer=11-55 and --multiminer=56-100 on the others. Note that which miner mines which block is determined by the previous block hash, so occasional runs of one miner doing many blocks in a row is to be expected.\n+\n+When --multiminer is used, if a miner is down and does not mine a block within five minutes of when it is due, the other miners will automatically act as redundant backups ensuring the chain does not halt. The --backup-delay parameter can be used to change how long a given miner waits, allowing one to be the primary backup (after five minutes) and another to be the secondary backup (after six minutes, eg).\n+\n+The --standby-delay parameter can be used to make a backup miner that only mines if a block doesn't arrive on time. This can be combined with --multiminer if desired. Setting --standby-delay also prevents the first block from being mined immediately.\n+\n+Advanced usage\n+--------------\n+\n+The process generate follows internally is to get a block template, convert that into a PSBT, sign the PSBT, move the signature from the signed PSBT into the block template's coinbase, grind proof of work for the block, and then submit the block to the network.\n+\n+These steps can instead be done explicitly:\n+\n+    $CLI -signet getblocktemplate '{\"rules\": [\"signet\",\"segwit\"]}' |\n+      $MINER --cli=\"$CLI\" genpsbt --address=\"$ADDR\" |\n+      $CLI -signet -stdin walletprocesspsbt |\n+      jq -r .psbt |\n+      $MINER --cli=\"$CLI\" solvepsbt --grind-cmd=\"$GRIND\" |\n+      $CLI -signet -stdin submitblock\n+\n+This is intended to allow you to replace part of the pipeline for further experimentation, if desired.\n+"
      }
    ]
  }
]