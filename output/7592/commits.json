[
  {
    "sha": "8fc81e098362130218f256cd6b60e81227d39db9",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4ZmM4MWUwOTgzNjIxMzAyMThmMjU2Y2Q2YjYwZTgxMjI3ZDM5ZGI5",
    "commit": {
      "author": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2016-02-24T17:34:37Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2016-02-24T18:40:29Z"
      },
      "message": "mempool: Reduce ERROR logging for mempool rejects\n\nContinues \"Make logging for validation optional\" from #6519.\n\nThe idea there was to remove all ERROR logging of rejected transaction,\nand move it to one message in the class 'mempoolrej' which logs the\nstate message (and debug info). The superfluous ERRORs in the log\n\"terrify\" users, see for example issue #5794.\n\nUnfortunately a lot of new logging was introduced in #6871 (RBF) and\n #7287 (misc refactoring). This pull updates that new code.",
      "tree": {
        "sha": "653703fc6ee136b0d0dccf124d5bd5540e3e4f63",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/653703fc6ee136b0d0dccf124d5bd5540e3e4f63"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8fc81e098362130218f256cd6b60e81227d39db9",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8fc81e098362130218f256cd6b60e81227d39db9",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8fc81e098362130218f256cd6b60e81227d39db9",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8fc81e098362130218f256cd6b60e81227d39db9/comments",
    "author": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "317462123f8e41fd7dd967ab907e59ddffb19898",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/317462123f8e41fd7dd967ab907e59ddffb19898",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/317462123f8e41fd7dd967ab907e59ddffb19898"
      }
    ],
    "stats": {
      "total": 57,
      "additions": 30,
      "deletions": 27
    },
    "files": [
      {
        "sha": "f3dc3f2919c46706e2b6c933f3aeb2a070f7376e",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 30,
        "deletions": 27,
        "changes": 57,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8fc81e098362130218f256cd6b60e81227d39db9/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8fc81e098362130218f256cd6b60e81227d39db9/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=8fc81e098362130218f256cd6b60e81227d39db9",
        "patch": "@@ -947,7 +947,7 @@ bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState& state, const C\n         *pfMissingInputs = false;\n \n     if (!CheckTransaction(tx, state))\n-        return error(\"%s: CheckTransaction: %s, %s\", __func__, hash.ToString(), FormatStateMessage(state));\n+        return false; // state filled in by CheckTransaction\n \n     // Coinbase is only valid in a block, not as a loose transaction\n     if (tx.IsCoinBase())\n@@ -1160,10 +1160,11 @@ bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState& state, const C\n             const uint256 &hashAncestor = ancestorIt->GetTx().GetHash();\n             if (setConflicts.count(hashAncestor))\n             {\n-                return state.DoS(10, error(\"AcceptToMemoryPool: %s spends conflicting transaction %s\",\n+                return state.DoS(10, false,\n+                                 REJECT_INVALID, \"bad-txns-spends-conflicting-tx\", false,\n+                                 strprintf(\"%s spends conflicting transaction %s\",\n                                            hash.ToString(),\n-                                           hashAncestor.ToString()),\n-                                 REJECT_INVALID, \"bad-txns-spends-conflicting-tx\");\n+                                           hashAncestor.ToString()));\n             }\n         }\n \n@@ -1200,11 +1201,11 @@ bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState& state, const C\n                 // that we don't spend too much time walking descendants.\n                 // This should be rare.\n                 if (mi->IsDirty()) {\n-                    return state.DoS(0,\n-                            error(\"AcceptToMemoryPool: rejecting replacement %s; cannot replace tx %s with untracked descendants\",\n+                    return state.DoS(0, false,\n+                            REJECT_NONSTANDARD, \"too many potential replacements\", false,\n+                            strprintf(\"too many potential replacements: rejecting replacement %s; cannot replace tx %s with untracked descendants\",\n                                 hash.ToString(),\n-                                mi->GetTx().GetHash().ToString()),\n-                            REJECT_NONSTANDARD, \"too many potential replacements\");\n+                                mi->GetTx().GetHash().ToString()));\n                 }\n \n                 // Don't allow the replacement to reduce the feerate of the\n@@ -1226,12 +1227,12 @@ bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState& state, const C\n                 CFeeRate oldFeeRate(mi->GetModifiedFee(), mi->GetTxSize());\n                 if (newFeeRate <= oldFeeRate)\n                 {\n-                    return state.DoS(0,\n-                            error(\"AcceptToMemoryPool: rejecting replacement %s; new feerate %s <= old feerate %s\",\n+                    return state.DoS(0, false,\n+                            REJECT_INSUFFICIENTFEE, \"insufficient fee\", false,\n+                            strprintf(\"rejecting replacement %s; new feerate %s <= old feerate %s\",\n                                   hash.ToString(),\n                                   newFeeRate.ToString(),\n-                                  oldFeeRate.ToString()),\n-                            REJECT_INSUFFICIENTFEE, \"insufficient fee\");\n+                                  oldFeeRate.ToString()));\n                 }\n \n                 BOOST_FOREACH(const CTxIn &txin, mi->GetTx().vin)\n@@ -1255,12 +1256,12 @@ bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState& state, const C\n                     nConflictingSize += it->GetTxSize();\n                 }\n             } else {\n-                return state.DoS(0,\n-                        error(\"AcceptToMemoryPool: rejecting replacement %s; too many potential replacements (%d > %d)\\n\",\n+                return state.DoS(0, false,\n+                        REJECT_NONSTANDARD, \"too many potential replacements\", false,\n+                        strprintf(\"rejecting replacement %s; too many potential replacements (%d > %d)\\n\",\n                             hash.ToString(),\n                             nConflictingCount,\n-                            maxDescendantsToVisit),\n-                        REJECT_NONSTANDARD, \"too many potential replacements\");\n+                            maxDescendantsToVisit));\n             }\n \n             for (unsigned int j = 0; j < tx.vin.size(); j++)\n@@ -1275,9 +1276,10 @@ bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState& state, const C\n                     // it's cheaper to just check if the new input refers to a\n                     // tx that's in the mempool.\n                     if (pool.mapTx.find(tx.vin[j].prevout.hash) != pool.mapTx.end())\n-                        return state.DoS(0, error(\"AcceptToMemoryPool: replacement %s adds unconfirmed input, idx %d\",\n-                                                  hash.ToString(), j),\n-                                         REJECT_NONSTANDARD, \"replacement-adds-unconfirmed\");\n+                        return state.DoS(0, false,\n+                                         REJECT_NONSTANDARD, \"replacement-adds-unconfirmed\", false,\n+                                         strprintf(\"replacement %s adds unconfirmed input, idx %d\",\n+                                                  hash.ToString(), j));\n                 }\n             }\n \n@@ -1286,29 +1288,30 @@ bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState& state, const C\n             // transactions would not be paid for.\n             if (nModifiedFees < nConflictingFees)\n             {\n-                return state.DoS(0, error(\"AcceptToMemoryPool: rejecting replacement %s, less fees than conflicting txs; %s < %s\",\n-                                          hash.ToString(), FormatMoney(nModifiedFees), FormatMoney(nConflictingFees)),\n-                                 REJECT_INSUFFICIENTFEE, \"insufficient fee\");\n+                return state.DoS(0, false,\n+                                 REJECT_INSUFFICIENTFEE, \"insufficient fee\", false,\n+                                 strprintf(\"rejecting replacement %s, less fees than conflicting txs; %s < %s\",\n+                                          hash.ToString(), FormatMoney(nModifiedFees), FormatMoney(nConflictingFees)));\n             }\n \n             // Finally in addition to paying more fees than the conflicts the\n             // new transaction must pay for its own bandwidth.\n             CAmount nDeltaFees = nModifiedFees - nConflictingFees;\n             if (nDeltaFees < ::minRelayTxFee.GetFee(nSize))\n             {\n-                return state.DoS(0,\n-                        error(\"AcceptToMemoryPool: rejecting replacement %s, not enough additional fees to relay; %s < %s\",\n+                return state.DoS(0, false,\n+                        REJECT_INSUFFICIENTFEE, \"insufficient fee\", false,\n+                        strprintf(\"rejecting replacement %s, not enough additional fees to relay; %s < %s\",\n                               hash.ToString(),\n                               FormatMoney(nDeltaFees),\n-                              FormatMoney(::minRelayTxFee.GetFee(nSize))),\n-                        REJECT_INSUFFICIENTFEE, \"insufficient fee\");\n+                              FormatMoney(::minRelayTxFee.GetFee(nSize))));\n             }\n         }\n \n         // Check against previous transactions\n         // This is done last to help prevent CPU exhaustion denial-of-service attacks.\n         if (!CheckInputs(tx, state, view, true, STANDARD_SCRIPT_VERIFY_FLAGS, true))\n-            return error(\"%s: CheckInputs: %s, %s\", __func__, hash.ToString(), FormatStateMessage(state));\n+            return false; // state filled in by CheckInputs\n \n         // Check again against just the consensus-critical mandatory script\n         // verification flags, in case of bugs in the standard flags that cause"
      }
    ]
  }
]