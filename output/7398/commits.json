[
  {
    "sha": "99ec7ff60c9edf6f12944f9d84a0b9f3dcad1607",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5OWVjN2ZmNjBjOWVkZjZmMTI5NDRmOWQ4NGEwYjlmM2RjYWQxNjA3",
    "commit": {
      "author": {
        "name": "JJ Geewax",
        "email": "jjg@google.com",
        "date": "2016-01-22T19:40:52Z"
      },
      "committer": {
        "name": "JJ Geewax",
        "email": "jjg@google.com",
        "date": "2016-01-22T20:27:02Z"
      },
      "message": "Improvements to seed generation",
      "tree": {
        "sha": "02f25cf8656866ca67d2ac3b16ab09c8964f298b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/02f25cf8656866ca67d2ac3b16ab09c8964f298b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/99ec7ff60c9edf6f12944f9d84a0b9f3dcad1607",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/99ec7ff60c9edf6f12944f9d84a0b9f3dcad1607",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/99ec7ff60c9edf6f12944f9d84a0b9f3dcad1607",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/99ec7ff60c9edf6f12944f9d84a0b9f3dcad1607/comments",
    "author": {
      "login": "jgeewax",
      "id": 112928,
      "node_id": "MDQ6VXNlcjExMjkyOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/112928?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jgeewax",
      "html_url": "https://github.com/jgeewax",
      "followers_url": "https://api.github.com/users/jgeewax/followers",
      "following_url": "https://api.github.com/users/jgeewax/following{/other_user}",
      "gists_url": "https://api.github.com/users/jgeewax/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jgeewax/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jgeewax/subscriptions",
      "organizations_url": "https://api.github.com/users/jgeewax/orgs",
      "repos_url": "https://api.github.com/users/jgeewax/repos",
      "events_url": "https://api.github.com/users/jgeewax/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jgeewax/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jgeewax",
      "id": 112928,
      "node_id": "MDQ6VXNlcjExMjkyOA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/112928?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jgeewax",
      "html_url": "https://github.com/jgeewax",
      "followers_url": "https://api.github.com/users/jgeewax/followers",
      "following_url": "https://api.github.com/users/jgeewax/following{/other_user}",
      "gists_url": "https://api.github.com/users/jgeewax/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jgeewax/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jgeewax/subscriptions",
      "organizations_url": "https://api.github.com/users/jgeewax/orgs",
      "repos_url": "https://api.github.com/users/jgeewax/repos",
      "events_url": "https://api.github.com/users/jgeewax/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jgeewax/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fc0899400082496bf2b3e061105e1e6a13399889",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fc0899400082496bf2b3e061105e1e6a13399889",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fc0899400082496bf2b3e061105e1e6a13399889"
      }
    ],
    "stats": {
      "total": 403,
      "additions": 252,
      "deletions": 151
    },
    "files": [
      {
        "sha": "f08bf1d97913310cefcf17e62cb9dc9356adcb1e",
        "filename": "contrib/seeds/README.md",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99ec7ff60c9edf6f12944f9d84a0b9f3dcad1607/contrib/seeds/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99ec7ff60c9edf6f12944f9d84a0b9f3dcad1607/contrib/seeds/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/seeds/README.md?ref=99ec7ff60c9edf6f12944f9d84a0b9f3dcad1607",
        "patch": "@@ -1,8 +1,10 @@\n-### Seeds ###\n+### Seeds\n \n Utility to generate the seeds.txt list that is compiled into the client\n (see [src/chainparamsseeds.h](/src/chainparamsseeds.h) and other utilities in [contrib/seeds](/contrib/seeds)).\n \n The 512 seeds compiled into the 0.10 release were created from sipa's DNS seed data, like this:\n \n-\tcurl -s http://bitcoin.sipa.be/seeds.txt | makeseeds.py\n+```sh\n+$ curl -s http://bitcoin.sipa.be/seeds.txt | makeseeds.py\n+```"
      },
      {
        "sha": "c851646f74ea0f7ffab5cc23dccb3d9f296113c1",
        "filename": "contrib/seeds/makeseeds.py",
        "status": "modified",
        "additions": 231,
        "deletions": 149,
        "changes": 380,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99ec7ff60c9edf6f12944f9d84a0b9f3dcad1607/contrib/seeds/makeseeds.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99ec7ff60c9edf6f12944f9d84a0b9f3dcad1607/contrib/seeds/makeseeds.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/seeds/makeseeds.py?ref=99ec7ff60c9edf6f12944f9d84a0b9f3dcad1607",
        "patch": "@@ -3,167 +3,249 @@\n # Generate seeds.txt from Pieter's DNS seeder\n #\n \n-NSEEDS=512\n+import collections\n+import dns.resolver\n+import logging\n+import re\n+import socket\n+import struct\n+import sys\n+from itertools import islice\n+from UserDict import UserDict\n \n-MAX_SEEDS_PER_ASN=2\n \n+MAX_ENTRIES = 512\n+MAX_ENTRIES_PER_ASN = 2\n MIN_BLOCKS = 337600\n \n+PATTERN_IPV4 = re.compile(\n+        r\"^((\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})):(\\d+)$\")\n+PATTERN_IPV6 = re.compile(r\"^\\[([0-9a-z:]+)\\]:(\\d+)$\")\n+PATTERN_ONION = re.compile(\n+        r\"^([abcdefghijklmnopqrstuvwxyz234567]{16}\\.onion):(\\d+)$\")\n+PATTERN_AGENT = re.compile(\n+        r\"^(\\/Satoshi:0\\.8\\.6\\/|\"\n+        r\"\\/Satoshi:0\\.9\\.(2|3|4|5)\\/|\"\n+        r\"\\/Satoshi:0\\.10\\.\\d{1,2}\\/|\"\n+        r\"\\/Satoshi:0\\.11\\.\\d{1,2}\\/)$\")\n+\n+\n # These are hosts that have been observed to be behaving strangely (e.g.\n # aggressively connecting to every node).\n-SUSPICIOUS_HOSTS = set([\n-    \"130.211.129.106\", \"178.63.107.226\",\n-    \"83.81.130.26\", \"88.198.17.7\", \"148.251.238.178\", \"176.9.46.6\",\n-    \"54.173.72.127\", \"54.174.10.182\", \"54.183.64.54\", \"54.194.231.211\",\n-    \"54.66.214.167\", \"54.66.220.137\", \"54.67.33.14\", \"54.77.251.214\",\n-    \"54.94.195.96\", \"54.94.200.247\"\n-])\n+with open('suspicious_hosts.txt') as f:\n+    SUSPICIOUS_HOSTS = set(f.readlines())\n \n-import re\n-import sys\n-import dns.resolver\n-import collections\n \n-PATTERN_IPV4 = re.compile(r\"^((\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})):(\\d+)$\")\n-PATTERN_IPV6 = re.compile(r\"^\\[([0-9a-z:]+)\\]:(\\d+)$\")\n-PATTERN_ONION = re.compile(r\"^([abcdefghijklmnopqrstuvwxyz234567]{16}\\.onion):(\\d+)$\")\n-PATTERN_AGENT = re.compile(r\"^(\\/Satoshi:0\\.8\\.6\\/|\\/Satoshi:0\\.9\\.(2|3|4|5)\\/|\\/Satoshi:0\\.10\\.\\d{1,2}\\/|\\/Satoshi:0\\.11\\.\\d{1,2}\\/)$\")\n-\n-def parseline(line):\n-    sline = line.split()\n-    if len(sline) < 11:\n-       return None\n-    m = PATTERN_IPV4.match(sline[0])\n-    sortkey = None\n-    ip = None\n-    if m is None:\n-        m = PATTERN_IPV6.match(sline[0])\n-        if m is None:\n-            m = PATTERN_ONION.match(sline[0])\n-            if m is None:\n-                return None\n-            else:\n-                net = 'onion'\n-                ipstr = sortkey = m.group(1)\n-                port = int(m.group(2))\n-        else:\n-            net = 'ipv6'\n-            if m.group(1) in ['::']: # Not interested in localhost\n-                return None\n-            ipstr = m.group(1)\n-            sortkey = ipstr # XXX parse IPv6 into number, could use name_to_ipv6 from generate-seeds\n-            port = int(m.group(2))\n-    else:\n-        # Do IPv4 sanity check\n-        ip = 0\n-        for i in range(0,4):\n-            if int(m.group(i+2)) < 0 or int(m.group(i+2)) > 255:\n-                return None\n-            ip = ip + (int(m.group(i+2)) << (8*(3-i)))\n-        if ip == 0:\n+class Address(object):\n+\n+    PATTERNS = {'ipv4': PATTERN_IPV4,\n+                'ipv6': PATTERN_IPV6,\n+                'onion': PATTERN_ONION}\n+\n+    INET_FORMATS = {'ipv4': (socket.AF_INET, '!L'),\n+                    'ipv6': (socket.AF_INET6, '!QQ')}\n+\n+    def __init__(self, host, port, address_type, sortable_host):\n+        self.host = host\n+        self.port = port\n+        self.address_type = address_type\n+        self.sortable_host = sortable_host\n+\n+    @property\n+    def asn(self):\n+        if hasattr(self, '_asn'):\n+            return self._asn\n+\n+    def get_asn(self):\n+        \"\"\"Discover the ASN (Autonomous System Number) for this entry.\n+\n+        This also caches the value to avoid future DNS requests.\"\"\"\n+        if self.address_type == 'onion':\n             return None\n-        net = 'ipv4'\n-        sortkey = ip\n-        ipstr = m.group(1)\n-        port = int(m.group(6))\n-    # Skip bad results.\n-    if sline[1] == 0:\n+\n+        if self.address_type == 'ipv4':\n+            reversed_ip = '.'.join(reversed(self.host.split('.')))\n+            domain = reversed_ip + '.origin.asn.cymru.com'\n+            try:\n+                answer = dns.resolver.query(domain, 'TXT').response.answer[0][0]\n+                self._asn = int(answer.strings[0].split('|')[0])\n+            except:\n+                return None\n+\n+            return self._asn\n+\n         return None\n-    # Extract uptime %.\n-    uptime30 = float(sline[7][:-1])\n-    # Extract Unix timestamp of last success.\n-    lastsuccess = int(sline[2])\n-    # Extract protocol version.\n-    version = int(sline[10])\n-    # Extract user agent.\n-    agent = sline[11][1:-1]\n-    # Extract service flags.\n-    service = int(sline[9], 16)\n-    # Extract blocks.\n-    blocks = int(sline[8])\n-    # Construct result.\n-    return {\n-        'net': net,\n-        'ip': ipstr,\n-        'port': port,\n-        'ipnum': ip,\n-        'uptime': uptime30,\n-        'lastsuccess': lastsuccess,\n-        'version': version,\n-        'agent': agent,\n-        'service': service,\n-        'blocks': blocks,\n-        'sortkey': sortkey,\n-    }\n-\n-def filtermultiport(ips):\n-    '''Filter out hosts with more nodes per IP'''\n-    hist = collections.defaultdict(list)\n-    for ip in ips:\n-        hist[ip['sortkey']].append(ip)\n-    return [value[0] for (key,value) in hist.items() if len(value)==1]\n-\n-# Based on Greg Maxwell's seed_filter.py\n-def filterbyasn(ips, max_per_asn, max_total):\n-    # Sift out ips by type\n-    ips_ipv4 = [ip for ip in ips if ip['net'] == 'ipv4']\n-    ips_ipv6 = [ip for ip in ips if ip['net'] == 'ipv6']\n-    ips_onion = [ip for ip in ips if ip['net'] == 'onion']\n-\n-    # Filter IPv4 by ASN\n-    result = []\n-    asn_count = {}\n-    for ip in ips_ipv4:\n-        if len(result) == max_total:\n-            break\n-        try:\n-            asn = int([x.to_text() for x in dns.resolver.query('.'.join(reversed(ip['ip'].split('.'))) + '.origin.asn.cymru.com', 'TXT').response.answer][0].split('\\\"')[1].split(' ')[0])\n-            if asn not in asn_count:\n-                asn_count[asn] = 0\n-            if asn_count[asn] == max_per_asn:\n-                continue\n-            asn_count[asn] += 1\n-            result.append(ip)\n-        except:\n-            sys.stderr.write('ERR: Could not resolve ASN for \"' + ip['ip'] + '\"\\n')\n-\n-    # TODO: filter IPv6 by ASN\n-\n-    # Add back non-IPv4\n-    result.extend(ips_ipv6)\n-    result.extend(ips_onion)\n-    return result\n+\n+    @classmethod\n+    def get_address_type(cls, address_string):\n+        \"\"\"Returns ipv4, ipv6, onion, or None for a given address.\"\"\"\n+        for address_type, pattern in cls.PATTERNS.items():\n+            if pattern.match(address_string):\n+                return address_type\n+        return None\n+\n+    @classmethod\n+    def from_combined_string(cls, address_string):\n+        \"\"\"Given an address, return a parsed Address object.\"\"\"\n+\n+        address_type = cls.get_address_type(address_string)\n+        if not address_type:\n+            raise ValueError('Invalid address (\"%s\")' % address_string)\n+\n+        host, port = address_string.rsplit(':', 1)\n+        if address_type == 'ipv6':\n+            host = host[1:-1]\n+\n+        if not host or not port:\n+            raise ValueError('Invalid address (\"%s\")' % address_string)\n+\n+        sortable_host = host\n+\n+        if address_type in cls.INET_FORMATS:\n+            type_id, struct_format = cls.INET_FORMATS[address_type]\n+            try:\n+                packed_ip = socket.inet_pton(type_id, host)\n+                sortable_host = struct.unpack(struct_format, packed_ip)[0]\n+            except:\n+                raise ValueError('Invalid %s host (\"%s\")' %\n+                                 (address_type, host))\n+\n+        return cls(host, int(port), address_type, sortable_host)\n+\n+    def __repr__(self):\n+        return str({\"host\": self.host, \"port\": self.port, \"asn\": self.asn,\n+                    \"address_type\": self.address_type,\n+                    \"sortable_host\": self.sortable_host})\n+\n+    def __str__(self):\n+        pattern = u'%s:%i'\n+        if self.address_type == 'ipv6':\n+            pattern = u'[%s];%i'\n+        return pattern % (self.host, self.port)\n+\n+    __unicode__ = __str__\n+\n+\n+class Entry(UserDict):\n+    \"\"\"Represents a single line in the seeds.txt file.\"\"\"\n+\n+    _percent = lambda _: float(_[:-1])\n+    SCHEMA = [\n+            ('address', Address.from_combined_string),\n+            ('good', bool),\n+            ('lastSuccess', int),\n+            ('uptime2h', _percent),\n+            ('uptime8h', _percent),\n+            ('uptime1d', _percent),\n+            ('uptime7d', _percent),\n+            ('uptime30d', _percent),\n+            ('blocks', int),\n+            ('services', lambda _: int(_, 16)),\n+            ('version', int),\n+            ('agent', lambda _: _[1:-1])]\n+\n+    @classmethod\n+    def from_raw_line(cls, line):\n+        \"\"\"Given a line from the seeds.txt file, return an Entry.\n+\n+        If the line is invalid, return None.\n+        \"\"\"\n+        if not line or line.startswith('#'):\n+            return None\n+\n+        pieces = line.split()\n+        if len(pieces) < 11:\n+            logging.warning('Not enough fields (only %d): %s' %\n+                            (len(pieces), line))\n+            return None\n+\n+        entry = cls()\n+        for (key, cast), value in zip(cls.SCHEMA, pieces):\n+            try:\n+                entry[key] = cast(value)\n+            except:\n+                logging.error('Invalid value for %s (\"%s\")' % (key, value))\n+                return None\n+        return entry\n+\n+    @property\n+    def address(self):\n+        return self['address']\n+\n+    def is_valid(self):\n+        \"\"\"Decides whether a given entry is valid.\"\"\"\n+        # Skip over any hosts that are telling us they're not good.\n+        if not self['good']: return False\n+\n+        # Skip over any suspicious hosts.\n+        if self['address'].host in SUSPICIOUS_HOSTS: return False\n+\n+        # Skip over hosts that don't have enough blocks.\n+        if self['blocks'] < MIN_BLOCKS: return False\n+\n+        # Skip over hosts that don't have service bit 1.\n+        if not self['services'] & 1: return False\n+\n+        # Skip over hosts that don't have 50% 30d uptime.\n+        if self['uptime30d'] < 50: return False\n+\n+        # Skip over hosts with unknown agents.\n+        if not PATTERN_AGENT.match(self['agent']): return False\n+\n+        return True\n+\n+    @property\n+    def sort_key(self):\n+        \"\"\"Returns a sortable tuple, in thie case using uptime and success.\"\"\"\n+        return (self['uptime30d'], self['lastSuccess'])\n+\n+    def __hash__(self):\n+        return self.address.sortable_host\n+\n+    def __eq__(self, other):\n+        \"\"\"For purposes of uniqueness, entries are equal based on address.\"\"\"\n+        return self.address.sortable_host == other.address.sortable_host\n+\n+\n+def get_entries_limited_by_asn(entries, max_per_asn=MAX_ENTRIES_PER_ASN):\n+    \"\"\"Return entries limited to a certain number per ASN.\"\"\"\n+    asn_counter = {}\n+    for entry in entries:\n+        asn = entry.address.get_asn()\n+        if not asn:\n+            yield entry\n+            continue\n+\n+        count = asn_counter.get(asn, 0) + 1\n+        if count > max_per_asn:\n+            continue\n+\n+        # Update the counter\n+        asn_counter[asn] = count\n+        yield entry\n+\n \n def main():\n-    lines = sys.stdin.readlines()\n-    ips = [parseline(line) for line in lines]\n-\n-    # Skip entries with valid address.\n-    ips = [ip for ip in ips if ip is not None]\n-    # Skip entries from suspicious hosts.\n-    ips = [ip for ip in ips if ip['ip'] not in SUSPICIOUS_HOSTS]\n-    # Enforce minimal number of blocks.\n-    ips = [ip for ip in ips if ip['blocks'] >= MIN_BLOCKS]\n-    # Require service bit 1.\n-    ips = [ip for ip in ips if (ip['service'] & 1) == 1]\n-    # Require at least 50% 30-day uptime.\n-    ips = [ip for ip in ips if ip['uptime'] > 50]\n-    # Require a known and recent user agent.\n-    ips = [ip for ip in ips if PATTERN_AGENT.match(ip['agent'])]\n-    # Sort by availability (and use last success as tie breaker)\n-    ips.sort(key=lambda x: (x['uptime'], x['lastsuccess'], x['ip']), reverse=True)\n-    # Filter out hosts with multiple bitcoin ports, these are likely abusive\n-    ips = filtermultiport(ips)\n-    # Look up ASNs and limit results, both per ASN and globally.\n-    ips = filterbyasn(ips, MAX_SEEDS_PER_ASN, NSEEDS)\n-    # Sort the results by IP address (for deterministic output).\n-    ips.sort(key=lambda x: (x['net'], x['sortkey']))\n-\n-    for ip in ips:\n-        if ip['net'] == 'ipv6':\n-            print '[%s]:%i' % (ip['ip'], ip['port'])\n-        else:\n-            print '%s:%i' % (ip['ip'], ip['port'])\n+    # Use stdin as the input.\n+    lines = sys.stdin\n+\n+    # Parse all the lines and ignore None values.\n+    entries = filter(None, map(Entry.from_raw_line, lines))\n+\n+    # Only include entries we consider to be valid.\n+    entries = filter(lambda e: e.is_valid(), entries)\n+\n+    # Sort the entries using their sort key (uptime, last success)\n+    entries = sorted(entries, key=lambda e: e.sort_key,\n+                     reverse=True)\n+\n+    # Limit the number of entries per ASN.\n+    entries = get_entries_limited_by_asn(entries)\n+\n+    # Iterate through and print out a limited number of entries.\n+    for entry in islice(entries, MAX_ENTRIES):\n+        print entry.address\n+\n \n if __name__ == '__main__':\n     main()"
      },
      {
        "sha": "78315d2e1dc2532756aa9d7ce810ff6aaf1da0bf",
        "filename": "contrib/seeds/suspicious_hosts.txt",
        "status": "added",
        "additions": 17,
        "deletions": 0,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99ec7ff60c9edf6f12944f9d84a0b9f3dcad1607/contrib/seeds/suspicious_hosts.txt",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99ec7ff60c9edf6f12944f9d84a0b9f3dcad1607/contrib/seeds/suspicious_hosts.txt",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/seeds/suspicious_hosts.txt?ref=99ec7ff60c9edf6f12944f9d84a0b9f3dcad1607",
        "patch": "@@ -0,0 +1,17 @@\n+130.211.129.106\n+178.63.107.226\n+83.81.130.26\n+88.198.17.7\n+148.251.238.178\n+176.9.46.6\n+54.173.72.127\n+54.174.10.182\n+54.183.64.54\n+54.194.231.211\n+54.66.214.167\n+54.66.220.137\n+54.67.33.14\n+54.77.251.214\n+54.94.195.96\n+54.94.200.247\n+"
      }
    ]
  }
]