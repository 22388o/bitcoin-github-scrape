kazcw,2016-05-08T15:08:14Z,"`thread` is the only owner of the `m_data` shared pointer, but `this_thread` is given a raw pointer to the same object. If the `thread` is destroyed while the thread is still running, it will destroy the `thread_data` object the thread's still using via `this_thread`'s pointer.\n",https://github.com/bitcoin/bitcoin/pull/8023#issuecomment-217725758,217725758,
kazcw,2016-05-08T15:44:39Z,Boost's `thread_group.remove_thread` doesn't destroy the thread object.\n,https://github.com/bitcoin/bitcoin/pull/8023#issuecomment-217727730,217727730,
theuni,2016-05-08T17:17:52Z,"@kazcw Thanks for the great review! It's much appreciated. This surely needs lots more tests, and there are still some rough edges.\n\nI'll be away for a few days, if others agree this is a good plan, I'll work on cleanup and test coverage when I get back.\n",https://github.com/bitcoin/bitcoin/pull/8023#issuecomment-217734412,217734412,
kazcw,2016-05-08T18:44:50Z,"Concept ACK on moving away from boost for threading.\n\nSince most threads are in the same `thread_group`, we'd have to switch over almost everything at once, right? Shouldn't be too hard with a drop-in replacement though...\n",https://github.com/bitcoin/bitcoin/pull/8023#issuecomment-217738836,217738836,
kazcw,2016-05-08T19:24:55Z,"The relationship between `int_lock` and `thread_data` does seem a bit funky, especially around the `m_wake_mutex` lock. What about switching the ownership: `unique_lock` in `thread_data`, reference to it in the `int_lock`? `int_lock` could become a generic utility class that takes two lock references and dispatch to both of them in tandem. `condition_variable` would need to `set_cond` after taking",https://github.com/bitcoin/bitcoin/pull/8023#issuecomment-217740912,217740912,
theuni,2016-05-08T20:28:28Z,"@kazcw The problem with that is that you still have to access the private condvar pointer after grabbing the double-lock, or use a getter that provides unguarded access, so the lock isn't actually providing any protection other than the understanding that the caller will use it to change the pointer (If I'm understanding you correctly). I tried that approach, and it led to the creation of an RAII ",https://github.com/bitcoin/bitcoin/pull/8023#issuecomment-217744227,217744227,
kazcw,2016-05-09T01:29:00Z,"I see. Yeah, I don't see any way for `thread_data` to expose a data-race-safe API that doesn't require some funky business. The current approach would work fine.\n",https://github.com/bitcoin/bitcoin/pull/8023#issuecomment-217759125,217759125,
TheBlueMatt,2016-05-11T23:08:07Z,"I appreciate all the work thats gone into this, and I think it should be merged eventually, but as our agreed-upon timeline has been that only new code should use C++11 features until after 0.13, I have to say NACK.\n",https://github.com/bitcoin/bitcoin/pull/8023#issuecomment-218616508,218616508,
laanwj,2016-05-20T14:13:58Z,"Re: C++11 changes - changing utility classes to use C++11 is fine as long as the code using it  is not or hardly impacted (e.g. the change to make tinyformat use C++11 variadic templates). But here we have to change all use/call sites as well (unless we do a terrible hack to disguise as boost) so yes, need to postpone this a bit.\n\nBut Concept ACK. Makes sense for 0.14 along with more compatibili",https://github.com/bitcoin/bitcoin/pull/8023#issuecomment-220616970,220616970,
kazcw,2016-05-08T16:45:47Z,The loop spins after timeout. Should this test be `if (ret)`?\n,https://github.com/bitcoin/bitcoin/pull/8023#discussion_r62434688,62434688,src/interruptible/condition_variable.h
theuni,2016-05-08T17:15:06Z,yep!\n,https://github.com/bitcoin/bitcoin/pull/8023#discussion_r62435221,62435221,src/interruptible/condition_variable.h
kazcw,2016-05-08T18:33:54Z,This needs to be at least `memory_order_acquire` so it happens before the notify. Locking the mutex is only an acquire operation and won't act as a suitable fence.\n,https://github.com/bitcoin/bitcoin/pull/8023#discussion_r62436328,62436328,src/interruptible/thread_data.h
theuni,2016-05-08T20:18:49Z,"Yep, thanks. This and the load should've both been marked for TODO, as I don't understand their interaction with the notify well enough. The orderings seem like pure voodoo :)\n",https://github.com/bitcoin/bitcoin/pull/8023#discussion_r62437695,62437695,src/interruptible/thread_data.h
kazcw,2016-05-09T01:21:02Z,"Yeah, it's wild stuff. I don't really understand it either.\n\nThe synchronization effects of `notify` on non-`condition_variable` values aren't specified, so I think we have to be conservative. One approach would be a release fence after the store and an acquire load operation. There may be marginally better-performing options on the store side, but this has the benefit that acquire/release pairs",https://github.com/bitcoin/bitcoin/pull/8023#discussion_r62442773,62442773,src/interruptible/thread_data.h
kazcw,2016-05-11T22:34:33Z,I've been thinking about this... I think it was actually fine as is. The store and the notify don't need to be ordered relative to each other because the release of the lock at the exit of the scope is synchronized-with the acquire of the lock that `wait` must perform before returning.\n,https://github.com/bitcoin/bitcoin/pull/8023#discussion_r62938901,62938901,src/interruptible/thread_data.h
