[
  {
    "sha": "0027672c8075d063f376c8c84e1cce77d572d353",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowMDI3NjcyYzgwNzVkMDYzZjM3NmM4Yzg0ZTFjY2U3N2Q1NzJkMzUz",
    "commit": {
      "author": {
        "name": "Johnson Lau",
        "email": "jl2012@xbt.hk",
        "date": "2016-09-23T05:06:45Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2016-10-13T18:01:45Z"
      },
      "message": "Make non-minimal OP_IF/NOTIF argument non-standard for P2WSH\n\nGithub-Pull: #8526\nRebased-From: c72c5b1e3bd42e84465677e94aa83316ff3d9a14",
      "tree": {
        "sha": "4b6daa82632013d74d4bf0e5a3d2b22497fa1cf2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4b6daa82632013d74d4bf0e5a3d2b22497fa1cf2"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0027672c8075d063f376c8c84e1cce77d572d353",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0027672c8075d063f376c8c84e1cce77d572d353",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0027672c8075d063f376c8c84e1cce77d572d353",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0027672c8075d063f376c8c84e1cce77d572d353/comments",
    "author": {
      "login": "jl2012",
      "id": 8403418,
      "node_id": "MDQ6VXNlcjg0MDM0MTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8403418?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jl2012",
      "html_url": "https://github.com/jl2012",
      "followers_url": "https://api.github.com/users/jl2012/followers",
      "following_url": "https://api.github.com/users/jl2012/following{/other_user}",
      "gists_url": "https://api.github.com/users/jl2012/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jl2012/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jl2012/subscriptions",
      "organizations_url": "https://api.github.com/users/jl2012/orgs",
      "repos_url": "https://api.github.com/users/jl2012/repos",
      "events_url": "https://api.github.com/users/jl2012/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jl2012/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "633c4a1f3690152bdda4b0ac7bcfde22c237183e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/633c4a1f3690152bdda4b0ac7bcfde22c237183e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/633c4a1f3690152bdda4b0ac7bcfde22c237183e"
      }
    ],
    "stats": {
      "total": 103,
      "additions": 101,
      "deletions": 2
    },
    "files": [
      {
        "sha": "458ec4a0cb4aa7a14742a62da750756f2b9d27c9",
        "filename": "src/policy/policy.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0027672c8075d063f376c8c84e1cce77d572d353/src/policy/policy.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0027672c8075d063f376c8c84e1cce77d572d353/src/policy/policy.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/policy.h?ref=0027672c8075d063f376c8c84e1cce77d572d353",
        "patch": "@@ -42,6 +42,7 @@ static const unsigned int STANDARD_SCRIPT_VERIFY_FLAGS = MANDATORY_SCRIPT_VERIFY\n                                                          SCRIPT_VERIFY_NULLDUMMY |\n                                                          SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS |\n                                                          SCRIPT_VERIFY_CLEANSTACK |\n+                                                         SCRIPT_VERIFY_MINIMALIF |\n                                                          SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY |\n                                                          SCRIPT_VERIFY_CHECKSEQUENCEVERIFY |\n                                                          SCRIPT_VERIFY_LOW_S |"
      },
      {
        "sha": "fd356fed0ab438a6cdd41add3701ff90c90bd1b9",
        "filename": "src/script/interpreter.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0027672c8075d063f376c8c84e1cce77d572d353/src/script/interpreter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0027672c8075d063f376c8c84e1cce77d572d353/src/script/interpreter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.cpp?ref=0027672c8075d063f376c8c84e1cce77d572d353",
        "patch": "@@ -428,6 +428,12 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                         if (stack.size() < 1)\n                             return set_error(serror, SCRIPT_ERR_UNBALANCED_CONDITIONAL);\n                         valtype& vch = stacktop(-1);\n+                        if (sigversion == SIGVERSION_WITNESS_V0 && (flags & SCRIPT_VERIFY_MINIMALIF)) {\n+                            if (vch.size() > 1)\n+                                return set_error(serror, SCRIPT_ERR_MINIMALIF);\n+                            if (vch.size() == 1 && vch[0] != 1)\n+                                return set_error(serror, SCRIPT_ERR_MINIMALIF);\n+                        }\n                         fValue = CastToBool(vch);\n                         if (opcode == OP_NOTIF)\n                             fValue = !fValue;"
      },
      {
        "sha": "2ce4b23e54f62071d93333c1b98b28f0b61d54c1",
        "filename": "src/script/interpreter.h",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0027672c8075d063f376c8c84e1cce77d572d353/src/script/interpreter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0027672c8075d063f376c8c84e1cce77d572d353/src/script/interpreter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.h?ref=0027672c8075d063f376c8c84e1cce77d572d353",
        "patch": "@@ -94,6 +94,10 @@ enum\n     // Making v1-v16 witness program non-standard\n     //\n     SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM = (1U << 12),\n+\n+    // Segwit script only: Require the argument of OP_IF/NOTIF to be exactly 0x01 or empty vector\n+    //\n+    SCRIPT_VERIFY_MINIMALIF = (1U << 13),\n };\n \n bool CheckSignatureEncoding(const std::vector<unsigned char> &vchSig, unsigned int flags, ScriptError* serror);"
      },
      {
        "sha": "9969c232fc3408cc97e81ae170e65ef8c5ce6344",
        "filename": "src/script/script_error.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0027672c8075d063f376c8c84e1cce77d572d353/src/script/script_error.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0027672c8075d063f376c8c84e1cce77d572d353/src/script/script_error.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script_error.cpp?ref=0027672c8075d063f376c8c84e1cce77d572d353",
        "patch": "@@ -63,6 +63,8 @@ const char* ScriptErrorString(const ScriptError serror)\n             return \"Non-canonical signature: S value is unnecessarily high\";\n         case SCRIPT_ERR_SIG_NULLDUMMY:\n             return \"Dummy CHECKMULTISIG argument must be zero\";\n+        case SCRIPT_ERR_MINIMALIF:\n+            return \"OP_IF/NOTIF argument must be minimal\";\n         case SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS:\n             return \"NOPx reserved for soft-fork upgrades\";\n         case SCRIPT_ERR_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM:"
      },
      {
        "sha": "6d34d37925bcfd7cf883d152b1b8a6fa96183ff9",
        "filename": "src/script/script_error.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0027672c8075d063f376c8c84e1cce77d572d353/src/script/script_error.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0027672c8075d063f376c8c84e1cce77d572d353/src/script/script_error.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script_error.h?ref=0027672c8075d063f376c8c84e1cce77d572d353",
        "patch": "@@ -39,7 +39,7 @@ typedef enum ScriptError_t\n     SCRIPT_ERR_NEGATIVE_LOCKTIME,\n     SCRIPT_ERR_UNSATISFIED_LOCKTIME,\n \n-    /* BIP62 */\n+    /* Malleability */\n     SCRIPT_ERR_SIG_HASHTYPE,\n     SCRIPT_ERR_SIG_DER,\n     SCRIPT_ERR_MINIMALDATA,\n@@ -48,6 +48,7 @@ typedef enum ScriptError_t\n     SCRIPT_ERR_SIG_NULLDUMMY,\n     SCRIPT_ERR_PUBKEYTYPE,\n     SCRIPT_ERR_CLEANSTACK,\n+    SCRIPT_ERR_MINIMALIF,\n \n     /* softfork safeness */\n     SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS,"
      },
      {
        "sha": "d456a8beffd674e528d5ef2abdaf46dbfa5e6f1f",
        "filename": "src/test/data/script_tests.json",
        "status": "modified",
        "additions": 84,
        "deletions": 1,
        "changes": 85,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0027672c8075d063f376c8c84e1cce77d572d353/src/test/data/script_tests.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0027672c8075d063f376c8c84e1cce77d572d353/src/test/data/script_tests.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/data/script_tests.json?ref=0027672c8075d063f376c8c84e1cce77d572d353",
        "patch": "@@ -2125,5 +2125,88 @@\n [\"0\", \"CHECKSEQUENCEVERIFY\", \"CHECKSEQUENCEVERIFY\", \"UNSATISFIED_LOCKTIME\", \"CSV fails if stack top bit 1 << 31 is set and the tx version < 2\"],\n [\"4294967296\", \"CHECKSEQUENCEVERIFY\", \"CHECKSEQUENCEVERIFY\", \"UNSATISFIED_LOCKTIME\",\n   \"CSV fails if stack top bit 1 << 31 is not set, and tx version < 2\"],\n-[\"The End\"]\n+\n+[\"MINIMALIF tests\"],\n+[\"MINIMALIF is not applied to non-segwit scripts\"],\n+[\"1\", \"IF 1 ENDIF\", \"P2SH,WITNESS,MINIMALIF\", \"OK\"],\n+[\"2\", \"IF 1 ENDIF\", \"P2SH,WITNESS,MINIMALIF\", \"OK\"],\n+[\"0x02 0x0100\", \"IF 1 ENDIF\", \"P2SH,WITNESS,MINIMALIF\", \"OK\"],\n+[\"0\", \"IF 1 ENDIF\", \"P2SH,WITNESS,MINIMALIF\", \"EVAL_FALSE\"],\n+[\"0x01 0x00\", \"IF 1 ENDIF\", \"P2SH,WITNESS,MINIMALIF\", \"EVAL_FALSE\"],\n+[\"1\", \"NOTIF 1 ENDIF\", \"P2SH,WITNESS,MINIMALIF\", \"EVAL_FALSE\"],\n+[\"2\", \"NOTIF 1 ENDIF\", \"P2SH,WITNESS,MINIMALIF\", \"EVAL_FALSE\"],\n+[\"0x02 0x0100\", \"NOTIF 1 ENDIF\", \"P2SH,WITNESS,MINIMALIF\", \"EVAL_FALSE\"],\n+[\"0\", \"NOTIF 1 ENDIF\", \"P2SH,WITNESS,MINIMALIF\", \"OK\"],\n+[\"0x01 0x00\", \"NOTIF 1 ENDIF\", \"P2SH,WITNESS,MINIMALIF\", \"OK\"],\n+[\"Normal P2SH IF 1 ENDIF\"],\n+[\"1 0x03 0x635168\", \"HASH160 0x14 0xe7309652a8e3f600f06f5d8d52d6df03d2176cc3 EQUAL\", \"P2SH,WITNESS,MINIMALIF\", \"OK\"],\n+[\"2 0x03 0x635168\", \"HASH160 0x14 0xe7309652a8e3f600f06f5d8d52d6df03d2176cc3 EQUAL\", \"P2SH,WITNESS,MINIMALIF\", \"OK\"],\n+[\"0x02 0x0100 0x03 0x635168\", \"HASH160 0x14 0xe7309652a8e3f600f06f5d8d52d6df03d2176cc3 EQUAL\", \"P2SH,WITNESS,MINIMALIF\", \"OK\"],\n+[\"0 0x03 0x635168\", \"HASH160 0x14 0xe7309652a8e3f600f06f5d8d52d6df03d2176cc3 EQUAL\", \"P2SH,WITNESS,MINIMALIF\", \"EVAL_FALSE\"],\n+[\"0x01 0x00 0x03 0x635168\", \"HASH160 0x14 0xe7309652a8e3f600f06f5d8d52d6df03d2176cc3 EQUAL\", \"P2SH,WITNESS,MINIMALIF\", \"EVAL_FALSE\"],\n+[\"0x03 0x635168\", \"HASH160 0x14 0xe7309652a8e3f600f06f5d8d52d6df03d2176cc3 EQUAL\", \"P2SH,WITNESS,MINIMALIF\", \"UNBALANCED_CONDITIONAL\"],\n+[\"Normal P2SH NOTIF 1 ENDIF\"],\n+[\"1 0x03 0x645168\", \"HASH160 0x14 0x0c3f8fe3d6ca266e76311ecda544c67d15fdd5b0 EQUAL\", \"P2SH,WITNESS,MINIMALIF\", \"EVAL_FALSE\"],\n+[\"2 0x03 0x645168\", \"HASH160 0x14 0x0c3f8fe3d6ca266e76311ecda544c67d15fdd5b0 EQUAL\", \"P2SH,WITNESS,MINIMALIF\", \"EVAL_FALSE\"],\n+[\"0x02 0x0100 0x03 0x645168\", \"HASH160 0x14 0x0c3f8fe3d6ca266e76311ecda544c67d15fdd5b0 EQUAL\", \"P2SH,WITNESS,MINIMALIF\", \"EVAL_FALSE\"],\n+[\"0 0x03 0x645168\", \"HASH160 0x14 0x0c3f8fe3d6ca266e76311ecda544c67d15fdd5b0 EQUAL\", \"P2SH,WITNESS,MINIMALIF\", \"OK\"],\n+[\"0x01 0x00 0x03 0x645168\", \"HASH160 0x14 0x0c3f8fe3d6ca266e76311ecda544c67d15fdd5b0 EQUAL\", \"P2SH,WITNESS,MINIMALIF\", \"OK\"],\n+[\"0x03 0x645168\", \"HASH160 0x14 0x0c3f8fe3d6ca266e76311ecda544c67d15fdd5b0 EQUAL\", \"P2SH,WITNESS,MINIMALIF\", \"UNBALANCED_CONDITIONAL\"],\n+[\"P2WSH IF 1 ENDIF\"],\n+[[\"01\", \"635168\", 0.00000001], \"\", \"0 0x20 0xc7eaf06d5ae01a58e376e126eb1e6fab2036076922b96b2711ffbec1e590665d\", \"P2SH,WITNESS\", \"OK\"],\n+[[\"02\", \"635168\", 0.00000001], \"\", \"0 0x20 0xc7eaf06d5ae01a58e376e126eb1e6fab2036076922b96b2711ffbec1e590665d\", \"P2SH,WITNESS\", \"OK\"],\n+[[\"0100\", \"635168\", 0.00000001], \"\", \"0 0x20 0xc7eaf06d5ae01a58e376e126eb1e6fab2036076922b96b2711ffbec1e590665d\", \"P2SH,WITNESS\", \"OK\"],\n+[[\"\", \"635168\", 0.00000001], \"\", \"0 0x20 0xc7eaf06d5ae01a58e376e126eb1e6fab2036076922b96b2711ffbec1e590665d\", \"P2SH,WITNESS\", \"EVAL_FALSE\"],\n+[[\"00\", \"635168\", 0.00000001], \"\", \"0 0x20 0xc7eaf06d5ae01a58e376e126eb1e6fab2036076922b96b2711ffbec1e590665d\", \"P2SH,WITNESS\", \"EVAL_FALSE\"],\n+[[\"01\", \"635168\", 0.00000001], \"\", \"0 0x20 0xc7eaf06d5ae01a58e376e126eb1e6fab2036076922b96b2711ffbec1e590665d\", \"P2SH,WITNESS,MINIMALIF\", \"OK\"],\n+[[\"02\", \"635168\", 0.00000001], \"\", \"0 0x20 0xc7eaf06d5ae01a58e376e126eb1e6fab2036076922b96b2711ffbec1e590665d\", \"P2SH,WITNESS,MINIMALIF\", \"MINIMALIF\"],\n+[[\"0100\", \"635168\", 0.00000001], \"\", \"0 0x20 0xc7eaf06d5ae01a58e376e126eb1e6fab2036076922b96b2711ffbec1e590665d\", \"P2SH,WITNESS,MINIMALIF\", \"MINIMALIF\"],\n+[[\"\", \"635168\", 0.00000001], \"\", \"0 0x20 0xc7eaf06d5ae01a58e376e126eb1e6fab2036076922b96b2711ffbec1e590665d\", \"P2SH,WITNESS,MINIMALIF\", \"EVAL_FALSE\"],\n+[[\"00\", \"635168\", 0.00000001], \"\", \"0 0x20 0xc7eaf06d5ae01a58e376e126eb1e6fab2036076922b96b2711ffbec1e590665d\", \"P2SH,WITNESS,MINIMALIF\", \"MINIMALIF\"],\n+[[\"635168\", 0.00000001], \"\", \"0 0x20 0xc7eaf06d5ae01a58e376e126eb1e6fab2036076922b96b2711ffbec1e590665d\", \"P2SH,WITNESS\", \"UNBALANCED_CONDITIONAL\"],\n+[[\"635168\", 0.00000001], \"\", \"0 0x20 0xc7eaf06d5ae01a58e376e126eb1e6fab2036076922b96b2711ffbec1e590665d\", \"P2SH,WITNESS,MINIMALIF\", \"UNBALANCED_CONDITIONAL\"],\n+[\"P2WSH NOTIF 1 ENDIF\"],\n+[[\"01\", \"645168\", 0.00000001], \"\", \"0 0x20 0xf913eacf2e38a5d6fc3a8311d72ae704cb83866350a984dd3e5eb76d2a8c28e8\", \"P2SH,WITNESS\", \"EVAL_FALSE\"],\n+[[\"02\", \"645168\", 0.00000001], \"\", \"0 0x20 0xf913eacf2e38a5d6fc3a8311d72ae704cb83866350a984dd3e5eb76d2a8c28e8\", \"P2SH,WITNESS\", \"EVAL_FALSE\"],\n+[[\"0100\", \"645168\", 0.00000001], \"\", \"0 0x20 0xf913eacf2e38a5d6fc3a8311d72ae704cb83866350a984dd3e5eb76d2a8c28e8\", \"P2SH,WITNESS\", \"EVAL_FALSE\"],\n+[[\"\", \"645168\", 0.00000001], \"\", \"0 0x20 0xf913eacf2e38a5d6fc3a8311d72ae704cb83866350a984dd3e5eb76d2a8c28e8\", \"P2SH,WITNESS\", \"OK\"],\n+[[\"00\", \"645168\", 0.00000001], \"\", \"0 0x20 0xf913eacf2e38a5d6fc3a8311d72ae704cb83866350a984dd3e5eb76d2a8c28e8\", \"P2SH,WITNESS\", \"OK\"],\n+[[\"01\", \"645168\", 0.00000001], \"\", \"0 0x20 0xf913eacf2e38a5d6fc3a8311d72ae704cb83866350a984dd3e5eb76d2a8c28e8\", \"P2SH,WITNESS,MINIMALIF\", \"EVAL_FALSE\"],\n+[[\"02\", \"645168\", 0.00000001], \"\", \"0 0x20 0xf913eacf2e38a5d6fc3a8311d72ae704cb83866350a984dd3e5eb76d2a8c28e8\", \"P2SH,WITNESS,MINIMALIF\", \"MINIMALIF\"],\n+[[\"0100\", \"645168\", 0.00000001], \"\", \"0 0x20 0xf913eacf2e38a5d6fc3a8311d72ae704cb83866350a984dd3e5eb76d2a8c28e8\", \"P2SH,WITNESS,MINIMALIF\", \"MINIMALIF\"],\n+[[\"\", \"645168\", 0.00000001], \"\", \"0 0x20 0xf913eacf2e38a5d6fc3a8311d72ae704cb83866350a984dd3e5eb76d2a8c28e8\", \"P2SH,WITNESS,MINIMALIF\", \"OK\"],\n+[[\"00\", \"645168\", 0.00000001], \"\", \"0 0x20 0xf913eacf2e38a5d6fc3a8311d72ae704cb83866350a984dd3e5eb76d2a8c28e8\", \"P2SH,WITNESS,MINIMALIF\", \"MINIMALIF\"],\n+[[\"645168\", 0.00000001], \"\", \"0 0x20 0xf913eacf2e38a5d6fc3a8311d72ae704cb83866350a984dd3e5eb76d2a8c28e8\", \"P2SH,WITNESS\", \"UNBALANCED_CONDITIONAL\"],\n+[[\"645168\", 0.00000001], \"\", \"0 0x20 0xf913eacf2e38a5d6fc3a8311d72ae704cb83866350a984dd3e5eb76d2a8c28e8\", \"P2SH,WITNESS,MINIMALIF\", \"UNBALANCED_CONDITIONAL\"],\n+\n+\n+\n+[\"P2SH-P2WSH IF 1 ENDIF\"],\n+[[\"01\", \"635168\", 0.00000001], \"0x22 0x0020c7eaf06d5ae01a58e376e126eb1e6fab2036076922b96b2711ffbec1e590665d\", \"HASH160 0x14 0x9b27ee6d9010c21bf837b334d043be5d150e7ba7 EQUAL\", \"P2SH,WITNESS\", \"OK\"],\n+[[\"02\", \"635168\", 0.00000001], \"0x22 0x0020c7eaf06d5ae01a58e376e126eb1e6fab2036076922b96b2711ffbec1e590665d\", \"HASH160 0x14 0x9b27ee6d9010c21bf837b334d043be5d150e7ba7 EQUAL\", \"P2SH,WITNESS\", \"OK\"],\n+[[\"0100\", \"635168\", 0.00000001], \"0x22 0x0020c7eaf06d5ae01a58e376e126eb1e6fab2036076922b96b2711ffbec1e590665d\", \"HASH160 0x14 0x9b27ee6d9010c21bf837b334d043be5d150e7ba7 EQUAL\", \"P2SH,WITNESS\", \"OK\"],\n+[[\"\", \"635168\", 0.00000001], \"0x22 0x0020c7eaf06d5ae01a58e376e126eb1e6fab2036076922b96b2711ffbec1e590665d\", \"HASH160 0x14 0x9b27ee6d9010c21bf837b334d043be5d150e7ba7 EQUAL\", \"P2SH,WITNESS\", \"EVAL_FALSE\"],\n+[[\"00\", \"635168\", 0.00000001], \"0x22 0x0020c7eaf06d5ae01a58e376e126eb1e6fab2036076922b96b2711ffbec1e590665d\", \"HASH160 0x14 0x9b27ee6d9010c21bf837b334d043be5d150e7ba7 EQUAL\", \"P2SH,WITNESS\", \"EVAL_FALSE\"],\n+[[\"01\", \"635168\", 0.00000001], \"0x22 0x0020c7eaf06d5ae01a58e376e126eb1e6fab2036076922b96b2711ffbec1e590665d\", \"HASH160 0x14 0x9b27ee6d9010c21bf837b334d043be5d150e7ba7 EQUAL\", \"P2SH,WITNESS,MINIMALIF\", \"OK\"],\n+[[\"02\", \"635168\", 0.00000001], \"0x22 0x0020c7eaf06d5ae01a58e376e126eb1e6fab2036076922b96b2711ffbec1e590665d\", \"HASH160 0x14 0x9b27ee6d9010c21bf837b334d043be5d150e7ba7 EQUAL\", \"P2SH,WITNESS,MINIMALIF\", \"MINIMALIF\"],\n+[[\"0100\", \"635168\", 0.00000001], \"0x22 0x0020c7eaf06d5ae01a58e376e126eb1e6fab2036076922b96b2711ffbec1e590665d\", \"HASH160 0x14 0x9b27ee6d9010c21bf837b334d043be5d150e7ba7 EQUAL\", \"P2SH,WITNESS,MINIMALIF\", \"MINIMALIF\"],\n+[[\"\", \"635168\", 0.00000001], \"0x22 0x0020c7eaf06d5ae01a58e376e126eb1e6fab2036076922b96b2711ffbec1e590665d\", \"HASH160 0x14 0x9b27ee6d9010c21bf837b334d043be5d150e7ba7 EQUAL\", \"P2SH,WITNESS,MINIMALIF\", \"EVAL_FALSE\"],\n+[[\"00\", \"635168\", 0.00000001], \"0x22 0x0020c7eaf06d5ae01a58e376e126eb1e6fab2036076922b96b2711ffbec1e590665d\", \"HASH160 0x14 0x9b27ee6d9010c21bf837b334d043be5d150e7ba7 EQUAL\", \"P2SH,WITNESS,MINIMALIF\", \"MINIMALIF\"],\n+[[\"635168\", 0.00000001], \"0x22 0x0020c7eaf06d5ae01a58e376e126eb1e6fab2036076922b96b2711ffbec1e590665d\", \"HASH160 0x14 0x9b27ee6d9010c21bf837b334d043be5d150e7ba7 EQUAL\", \"P2SH,WITNESS\", \"UNBALANCED_CONDITIONAL\"],\n+[[\"635168\", 0.00000001], \"0x22 0x0020c7eaf06d5ae01a58e376e126eb1e6fab2036076922b96b2711ffbec1e590665d\", \"HASH160 0x14 0x9b27ee6d9010c21bf837b334d043be5d150e7ba7 EQUAL\", \"P2SH,WITNESS,MINIMALIF\", \"UNBALANCED_CONDITIONAL\"],\n+[\"P2SH-P2WSH NOTIF 1 ENDIF\"],\n+[[\"01\", \"645168\", 0.00000001], \"0x22 0x0020f913eacf2e38a5d6fc3a8311d72ae704cb83866350a984dd3e5eb76d2a8c28e8\", \"HASH160 0x14 0xdbb7d1c0a56b7a9c423300c8cca6e6e065baf1dc EQUAL\", \"P2SH,WITNESS\", \"EVAL_FALSE\"],\n+[[\"02\", \"645168\", 0.00000001], \"0x22 0x0020f913eacf2e38a5d6fc3a8311d72ae704cb83866350a984dd3e5eb76d2a8c28e8\", \"HASH160 0x14 0xdbb7d1c0a56b7a9c423300c8cca6e6e065baf1dc EQUAL\", \"P2SH,WITNESS\", \"EVAL_FALSE\"],\n+[[\"0100\", \"645168\", 0.00000001], \"0x22 0x0020f913eacf2e38a5d6fc3a8311d72ae704cb83866350a984dd3e5eb76d2a8c28e8\", \"HASH160 0x14 0xdbb7d1c0a56b7a9c423300c8cca6e6e065baf1dc EQUAL\", \"P2SH,WITNESS\", \"EVAL_FALSE\"],\n+[[\"\", \"645168\", 0.00000001], \"0x22 0x0020f913eacf2e38a5d6fc3a8311d72ae704cb83866350a984dd3e5eb76d2a8c28e8\", \"HASH160 0x14 0xdbb7d1c0a56b7a9c423300c8cca6e6e065baf1dc EQUAL\", \"P2SH,WITNESS\", \"OK\"],\n+[[\"00\", \"645168\", 0.00000001], \"0x22 0x0020f913eacf2e38a5d6fc3a8311d72ae704cb83866350a984dd3e5eb76d2a8c28e8\", \"HASH160 0x14 0xdbb7d1c0a56b7a9c423300c8cca6e6e065baf1dc EQUAL\", \"P2SH,WITNESS\", \"OK\"],\n+[[\"01\", \"645168\", 0.00000001], \"0x22 0x0020f913eacf2e38a5d6fc3a8311d72ae704cb83866350a984dd3e5eb76d2a8c28e8\", \"HASH160 0x14 0xdbb7d1c0a56b7a9c423300c8cca6e6e065baf1dc EQUAL\", \"P2SH,WITNESS,MINIMALIF\", \"EVAL_FALSE\"],\n+[[\"02\", \"645168\", 0.00000001], \"0x22 0x0020f913eacf2e38a5d6fc3a8311d72ae704cb83866350a984dd3e5eb76d2a8c28e8\", \"HASH160 0x14 0xdbb7d1c0a56b7a9c423300c8cca6e6e065baf1dc EQUAL\", \"P2SH,WITNESS,MINIMALIF\", \"MINIMALIF\"],\n+[[\"0100\", \"645168\", 0.00000001], \"0x22 0x0020f913eacf2e38a5d6fc3a8311d72ae704cb83866350a984dd3e5eb76d2a8c28e8\", \"HASH160 0x14 0xdbb7d1c0a56b7a9c423300c8cca6e6e065baf1dc EQUAL\", \"P2SH,WITNESS,MINIMALIF\", \"MINIMALIF\"],\n+[[\"\", \"645168\", 0.00000001], \"0x22 0x0020f913eacf2e38a5d6fc3a8311d72ae704cb83866350a984dd3e5eb76d2a8c28e8\", \"HASH160 0x14 0xdbb7d1c0a56b7a9c423300c8cca6e6e065baf1dc EQUAL\", \"P2SH,WITNESS,MINIMALIF\", \"OK\"],\n+[[\"00\", \"645168\", 0.00000001], \"0x22 0x0020f913eacf2e38a5d6fc3a8311d72ae704cb83866350a984dd3e5eb76d2a8c28e8\", \"HASH160 0x14 0xdbb7d1c0a56b7a9c423300c8cca6e6e065baf1dc EQUAL\", \"P2SH,WITNESS,MINIMALIF\", \"MINIMALIF\"],\n+[[\"645168\", 0.00000001], \"0x22 0x0020f913eacf2e38a5d6fc3a8311d72ae704cb83866350a984dd3e5eb76d2a8c28e8\", \"HASH160 0x14 0xdbb7d1c0a56b7a9c423300c8cca6e6e065baf1dc EQUAL\", \"P2SH,WITNESS\", \"UNBALANCED_CONDITIONAL\"],\n+[[\"645168\", 0.00000001], \"0x22 0x0020f913eacf2e38a5d6fc3a8311d72ae704cb83866350a984dd3e5eb76d2a8c28e8\", \"HASH160 0x14 0xdbb7d1c0a56b7a9c423300c8cca6e6e065baf1dc EQUAL\", \"P2SH,WITNESS,MINIMALIF\", \"UNBALANCED_CONDITIONAL\"],\n+\n+ [\"The End\"]\n ]"
      },
      {
        "sha": "36c591d616f922e28ce7a1d64ceb767443b6b830",
        "filename": "src/test/script_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0027672c8075d063f376c8c84e1cce77d572d353/src/test/script_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0027672c8075d063f376c8c84e1cce77d572d353/src/test/script_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_tests.cpp?ref=0027672c8075d063f376c8c84e1cce77d572d353",
        "patch": "@@ -89,6 +89,7 @@ static ScriptErrorDesc script_errors[]={\n     {SCRIPT_ERR_SIG_NULLDUMMY, \"SIG_NULLDUMMY\"},\n     {SCRIPT_ERR_PUBKEYTYPE, \"PUBKEYTYPE\"},\n     {SCRIPT_ERR_CLEANSTACK, \"CLEANSTACK\"},\n+    {SCRIPT_ERR_MINIMALIF, \"MINIMALIF\"},\n     {SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS, \"DISCOURAGE_UPGRADABLE_NOPS\"},\n     {SCRIPT_ERR_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM, \"DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM\"},\n     {SCRIPT_ERR_WITNESS_PROGRAM_WRONG_LENGTH, \"WITNESS_PROGRAM_WRONG_LENGTH\"},"
      },
      {
        "sha": "165dfd9a3e06b1e67d4e0ce498081e3733388ffa",
        "filename": "src/test/transaction_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0027672c8075d063f376c8c84e1cce77d572d353/src/test/transaction_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0027672c8075d063f376c8c84e1cce77d572d353/src/test/transaction_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/transaction_tests.cpp?ref=0027672c8075d063f376c8c84e1cce77d572d353",
        "patch": "@@ -50,6 +50,7 @@ static std::map<string, unsigned int> mapFlagNames = boost::assign::map_list_of\n     (string(\"NULLDUMMY\"), (unsigned int)SCRIPT_VERIFY_NULLDUMMY)\n     (string(\"DISCOURAGE_UPGRADABLE_NOPS\"), (unsigned int)SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS)\n     (string(\"CLEANSTACK\"), (unsigned int)SCRIPT_VERIFY_CLEANSTACK)\n+    (string(\"MINIMALIF\"), (unsigned int)SCRIPT_VERIFY_MINIMALIF)\n     (string(\"CHECKLOCKTIMEVERIFY\"), (unsigned int)SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY)\n     (string(\"CHECKSEQUENCEVERIFY\"), (unsigned int)SCRIPT_VERIFY_CHECKSEQUENCEVERIFY)\n     (string(\"WITNESS\"), (unsigned int)SCRIPT_VERIFY_WITNESS)"
      }
    ]
  },
  {
    "sha": "3e80ab7f2a338d1bb3d9321c13a18f1324130617",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozZTgwYWI3ZjJhMzM4ZDFiYjNkOTMyMWMxM2ExOGYxMzI0MTMwNjE3",
    "commit": {
      "author": {
        "name": "Johnson Lau",
        "email": "jl2012@users.noreply.github.com",
        "date": "2016-09-22T07:06:54Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2016-10-13T18:01:46Z"
      },
      "message": "Add policy: null signature for failed CHECK(MULTI)SIG\n\nGithub-Pull: #8634\nRebased-From: e41bd449ab2b8d01260795383af2c40b659d8587",
      "tree": {
        "sha": "25cb8185aae70ad6738aff11c573ab4353acea1f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/25cb8185aae70ad6738aff11c573ab4353acea1f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3e80ab7f2a338d1bb3d9321c13a18f1324130617",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3e80ab7f2a338d1bb3d9321c13a18f1324130617",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/3e80ab7f2a338d1bb3d9321c13a18f1324130617",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3e80ab7f2a338d1bb3d9321c13a18f1324130617/comments",
    "author": {
      "login": "jl2012",
      "id": 8403418,
      "node_id": "MDQ6VXNlcjg0MDM0MTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8403418?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jl2012",
      "html_url": "https://github.com/jl2012",
      "followers_url": "https://api.github.com/users/jl2012/followers",
      "following_url": "https://api.github.com/users/jl2012/following{/other_user}",
      "gists_url": "https://api.github.com/users/jl2012/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jl2012/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jl2012/subscriptions",
      "organizations_url": "https://api.github.com/users/jl2012/orgs",
      "repos_url": "https://api.github.com/users/jl2012/repos",
      "events_url": "https://api.github.com/users/jl2012/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jl2012/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "0027672c8075d063f376c8c84e1cce77d572d353",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0027672c8075d063f376c8c84e1cce77d572d353",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0027672c8075d063f376c8c84e1cce77d572d353"
      }
    ],
    "stats": {
      "total": 57,
      "additions": 55,
      "deletions": 2
    },
    "files": [
      {
        "sha": "9d6ff1233b6aaef5582a8cbed9c8bdec72c4592d",
        "filename": "src/policy/policy.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3e80ab7f2a338d1bb3d9321c13a18f1324130617/src/policy/policy.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3e80ab7f2a338d1bb3d9321c13a18f1324130617/src/policy/policy.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/policy.h?ref=3e80ab7f2a338d1bb3d9321c13a18f1324130617",
        "patch": "@@ -43,6 +43,7 @@ static const unsigned int STANDARD_SCRIPT_VERIFY_FLAGS = MANDATORY_SCRIPT_VERIFY\n                                                          SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS |\n                                                          SCRIPT_VERIFY_CLEANSTACK |\n                                                          SCRIPT_VERIFY_MINIMALIF |\n+                                                         SCRIPT_VERIFY_NULLFAIL |\n                                                          SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY |\n                                                          SCRIPT_VERIFY_CHECKSEQUENCEVERIFY |\n                                                          SCRIPT_VERIFY_LOW_S |"
      },
      {
        "sha": "41756ea71196d9168f9d7bde783167ddc4f077ed",
        "filename": "src/script/interpreter.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 1,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3e80ab7f2a338d1bb3d9321c13a18f1324130617/src/script/interpreter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3e80ab7f2a338d1bb3d9321c13a18f1324130617/src/script/interpreter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.cpp?ref=3e80ab7f2a338d1bb3d9321c13a18f1324130617",
        "patch": "@@ -885,6 +885,9 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                     }\n                     bool fSuccess = checker.CheckSig(vchSig, vchPubKey, scriptCode, sigversion);\n \n+                    if (!fSuccess && (flags & SCRIPT_VERIFY_NULLFAIL) && vchSig.size())\n+                        return set_error(serror, SCRIPT_ERR_SIG_NULLFAIL);\n+\n                     popstack(stack);\n                     popstack(stack);\n                     stack.push_back(fSuccess ? vchTrue : vchFalse);\n@@ -914,6 +917,9 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                     if (nOpCount > MAX_OPS_PER_SCRIPT)\n                         return set_error(serror, SCRIPT_ERR_OP_COUNT);\n                     int ikey = ++i;\n+                    // ikey2 is the position of last non-signature item in the stack. Top stack item = 1.\n+                    // With SCRIPT_VERIFY_NULLFAIL, this is used for cleanup if operation fails.\n+                    int ikey2 = nKeysCount + 2;\n                     i += nKeysCount;\n                     if ((int)stack.size() < i)\n                         return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n@@ -970,8 +976,14 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                     }\n \n                     // Clean up stack of actual arguments\n-                    while (i-- > 1)\n+                    while (i-- > 1) {\n+                        // If the operation failed, we require that all signatures must be empty vector\n+                        if (!fSuccess && (flags & SCRIPT_VERIFY_NULLFAIL) && !ikey2 && stacktop(-1).size())\n+                            return set_error(serror, SCRIPT_ERR_SIG_NULLFAIL);\n+                        if (ikey2 > 0)\n+                            ikey2--;\n                         popstack(stack);\n+                    }\n \n                     // A bug causes CHECKMULTISIG to consume one extra argument\n                     // whose contents were not checked in any way."
      },
      {
        "sha": "0adc9482ffec64f5575a5b71f1db26504f3b379b",
        "filename": "src/script/interpreter.h",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3e80ab7f2a338d1bb3d9321c13a18f1324130617/src/script/interpreter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3e80ab7f2a338d1bb3d9321c13a18f1324130617/src/script/interpreter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.h?ref=3e80ab7f2a338d1bb3d9321c13a18f1324130617",
        "patch": "@@ -98,6 +98,10 @@ enum\n     // Segwit script only: Require the argument of OP_IF/NOTIF to be exactly 0x01 or empty vector\n     //\n     SCRIPT_VERIFY_MINIMALIF = (1U << 13),\n+\n+    // Signature(s) must be empty vector if an CHECK(MULTI)SIG operation failed\n+    //\n+    SCRIPT_VERIFY_NULLFAIL = (1U << 14),\n };\n \n bool CheckSignatureEncoding(const std::vector<unsigned char> &vchSig, unsigned int flags, ScriptError* serror);"
      },
      {
        "sha": "e27b715c2cfeab3d5cea1f1b9c2b7d675f343e4b",
        "filename": "src/script/script_error.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3e80ab7f2a338d1bb3d9321c13a18f1324130617/src/script/script_error.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3e80ab7f2a338d1bb3d9321c13a18f1324130617/src/script/script_error.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script_error.cpp?ref=3e80ab7f2a338d1bb3d9321c13a18f1324130617",
        "patch": "@@ -65,6 +65,8 @@ const char* ScriptErrorString(const ScriptError serror)\n             return \"Dummy CHECKMULTISIG argument must be zero\";\n         case SCRIPT_ERR_MINIMALIF:\n             return \"OP_IF/NOTIF argument must be minimal\";\n+        case SCRIPT_ERR_SIG_NULLFAIL:\n+            return \"Signature must be zero for failed CHECK(MULTI)SIG operation\";\n         case SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS:\n             return \"NOPx reserved for soft-fork upgrades\";\n         case SCRIPT_ERR_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM:"
      },
      {
        "sha": "bccfdb99e23bb587ba1eab8c425d09fd726e9421",
        "filename": "src/script/script_error.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3e80ab7f2a338d1bb3d9321c13a18f1324130617/src/script/script_error.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3e80ab7f2a338d1bb3d9321c13a18f1324130617/src/script/script_error.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script_error.h?ref=3e80ab7f2a338d1bb3d9321c13a18f1324130617",
        "patch": "@@ -49,6 +49,7 @@ typedef enum ScriptError_t\n     SCRIPT_ERR_PUBKEYTYPE,\n     SCRIPT_ERR_CLEANSTACK,\n     SCRIPT_ERR_MINIMALIF,\n+    SCRIPT_ERR_SIG_NULLFAIL,\n \n     /* softfork safeness */\n     SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS,"
      },
      {
        "sha": "06103ea5bdd665ecac1df0a82c07bd32f9ecba95",
        "filename": "src/test/data/script_tests.json",
        "status": "modified",
        "additions": 32,
        "deletions": 1,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3e80ab7f2a338d1bb3d9321c13a18f1324130617/src/test/data/script_tests.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3e80ab7f2a338d1bb3d9321c13a18f1324130617/src/test/data/script_tests.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/data/script_tests.json?ref=3e80ab7f2a338d1bb3d9321c13a18f1324130617",
        "patch": "@@ -1491,6 +1491,27 @@\n     \"OK\",\n     \"BIP66 example 4, with DERSIG\"\n ],\n+[\n+    \"0x09 0x300602010102010101\",\n+    \"0x21 0x038282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508 CHECKSIG NOT\",\n+    \"DERSIG\",\n+    \"OK\",\n+    \"BIP66 example 4, with DERSIG, non-null DER-compliant signature\"\n+],\n+[\n+    \"0\",\n+    \"0x21 0x038282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508 CHECKSIG NOT\",\n+    \"DERSIG,NULLFAIL\",\n+    \"OK\",\n+    \"BIP66 example 4, with DERSIG and NULLFAIL\"\n+],\n+[\n+    \"0x09 0x300602010102010101\",\n+    \"0x21 0x038282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508 CHECKSIG NOT\",\n+    \"DERSIG,NULLFAIL\",\n+    \"NULLFAIL\",\n+    \"BIP66 example 4, with DERSIG and NULLFAIL, non-null DER-compliant signature\"\n+],\n [\n     \"1\",\n     \"0x21 0x038282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508 CHECKSIG\",\n@@ -2208,5 +2229,15 @@\n [[\"645168\", 0.00000001], \"0x22 0x0020f913eacf2e38a5d6fc3a8311d72ae704cb83866350a984dd3e5eb76d2a8c28e8\", \"HASH160 0x14 0xdbb7d1c0a56b7a9c423300c8cca6e6e065baf1dc EQUAL\", \"P2SH,WITNESS\", \"UNBALANCED_CONDITIONAL\"],\n [[\"645168\", 0.00000001], \"0x22 0x0020f913eacf2e38a5d6fc3a8311d72ae704cb83866350a984dd3e5eb76d2a8c28e8\", \"HASH160 0x14 0xdbb7d1c0a56b7a9c423300c8cca6e6e065baf1dc EQUAL\", \"P2SH,WITNESS,MINIMALIF\", \"UNBALANCED_CONDITIONAL\"],\n \n- [\"The End\"]\n+[\"NULLFAIL should cover all signatures and signatures only\"],\n+[\"0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\", \"0x01 0x14 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0x01 0x14 CHECKMULTISIG NOT\", \"DERSIG\", \"OK\", \"BIP66 and NULLFAIL-compliant\"],\n+[\"0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\", \"0x01 0x14 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0x01 0x14 CHECKMULTISIG NOT\", \"DERSIG,NULLFAIL\", \"OK\", \"BIP66 and NULLFAIL-compliant\"],\n+[\"1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\", \"0x01 0x14 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0x01 0x14 CHECKMULTISIG NOT\", \"DERSIG,NULLFAIL\", \"OK\", \"BIP66 and NULLFAIL-compliant, not NULLDUMMY-compliant\"],\n+[\"1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\", \"0x01 0x14 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0x01 0x14 CHECKMULTISIG NOT\", \"DERSIG,NULLFAIL,NULLDUMMY\", \"SIG_NULLDUMMY\", \"BIP66 and NULLFAIL-compliant, not NULLDUMMY-compliant\"],\n+[\"0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0x09 0x300602010102010101\", \"0x01 0x14 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0x01 0x14 CHECKMULTISIG NOT\", \"DERSIG\", \"OK\", \"BIP66-compliant but not NULLFAIL-compliant\"],\n+[\"0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0x09 0x300602010102010101\", \"0x01 0x14 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0x01 0x14 CHECKMULTISIG NOT\", \"DERSIG,NULLFAIL\", \"NULLFAIL\", \"BIP66-compliant but not NULLFAIL-compliant\"],\n+[\"0 0x09 0x300602010102010101 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\", \"0x01 0x14 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0x01 0x14 CHECKMULTISIG NOT\", \"DERSIG\", \"OK\", \"BIP66-compliant but not NULLFAIL-compliant\"],\n+[\"0 0x09 0x300602010102010101 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\", \"0x01 0x14 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0x01 0x14 CHECKMULTISIG NOT\", \"DERSIG,NULLFAIL\", \"NULLFAIL\", \"BIP66-compliant but not NULLFAIL-compliant\"],\n+\n+[\"The End\"]\n ]"
      },
      {
        "sha": "836ef734ddf9714704066d3282b79019608bb144",
        "filename": "src/test/script_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3e80ab7f2a338d1bb3d9321c13a18f1324130617/src/test/script_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3e80ab7f2a338d1bb3d9321c13a18f1324130617/src/test/script_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_tests.cpp?ref=3e80ab7f2a338d1bb3d9321c13a18f1324130617",
        "patch": "@@ -90,6 +90,7 @@ static ScriptErrorDesc script_errors[]={\n     {SCRIPT_ERR_PUBKEYTYPE, \"PUBKEYTYPE\"},\n     {SCRIPT_ERR_CLEANSTACK, \"CLEANSTACK\"},\n     {SCRIPT_ERR_MINIMALIF, \"MINIMALIF\"},\n+    {SCRIPT_ERR_SIG_NULLFAIL, \"NULLFAIL\"},\n     {SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS, \"DISCOURAGE_UPGRADABLE_NOPS\"},\n     {SCRIPT_ERR_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM, \"DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM\"},\n     {SCRIPT_ERR_WITNESS_PROGRAM_WRONG_LENGTH, \"WITNESS_PROGRAM_WRONG_LENGTH\"},"
      },
      {
        "sha": "6163d2f6306048bbba58c194a738bd6218cda06e",
        "filename": "src/test/transaction_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3e80ab7f2a338d1bb3d9321c13a18f1324130617/src/test/transaction_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3e80ab7f2a338d1bb3d9321c13a18f1324130617/src/test/transaction_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/transaction_tests.cpp?ref=3e80ab7f2a338d1bb3d9321c13a18f1324130617",
        "patch": "@@ -51,6 +51,7 @@ static std::map<string, unsigned int> mapFlagNames = boost::assign::map_list_of\n     (string(\"DISCOURAGE_UPGRADABLE_NOPS\"), (unsigned int)SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS)\n     (string(\"CLEANSTACK\"), (unsigned int)SCRIPT_VERIFY_CLEANSTACK)\n     (string(\"MINIMALIF\"), (unsigned int)SCRIPT_VERIFY_MINIMALIF)\n+    (string(\"NULLFAIL\"), (unsigned int)SCRIPT_VERIFY_NULLFAIL)\n     (string(\"CHECKLOCKTIMEVERIFY\"), (unsigned int)SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY)\n     (string(\"CHECKSEQUENCEVERIFY\"), (unsigned int)SCRIPT_VERIFY_CHECKSEQUENCEVERIFY)\n     (string(\"WITNESS\"), (unsigned int)SCRIPT_VERIFY_WITNESS)"
      }
    ]
  },
  {
    "sha": "7ae624296000e714034d86891ffcd4a565f278fa",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3YWU2MjQyOTYwMDBlNzE0MDM0ZDg2ODkxZmZjZDRhNTY1ZjI3OGZh",
    "commit": {
      "author": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2016-09-13T01:32:53Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2016-10-13T18:09:31Z"
      },
      "message": "net: fix a few cases where messages were sent rather than dropped upon disconnection\n\n75ead758 turned these into crashes in the event of a handshake failure, most\nnotably when a peer does not offer the expected services.\n\nThere are likely other cases that these assertions will find as well.\n\nGithub-Pull: #8862\nRebased-From: 905bc68d05595f41cca36b3df83accd10c00cc48",
      "tree": {
        "sha": "8e92ecfb38b794cf47f483d0376670d4c134fe8d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8e92ecfb38b794cf47f483d0376670d4c134fe8d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7ae624296000e714034d86891ffcd4a565f278fa",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7ae624296000e714034d86891ffcd4a565f278fa",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7ae624296000e714034d86891ffcd4a565f278fa",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7ae624296000e714034d86891ffcd4a565f278fa/comments",
    "author": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "3e80ab7f2a338d1bb3d9321c13a18f1324130617",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3e80ab7f2a338d1bb3d9321c13a18f1324130617",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3e80ab7f2a338d1bb3d9321c13a18f1324130617"
      }
    ],
    "stats": {
      "total": 4,
      "additions": 2,
      "deletions": 2
    },
    "files": [
      {
        "sha": "c8e290ae5156aaba9c1d7d4732e0b259d7f95eab",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7ae624296000e714034d86891ffcd4a565f278fa/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7ae624296000e714034d86891ffcd4a565f278fa/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=7ae624296000e714034d86891ffcd4a565f278fa",
        "patch": "@@ -6342,7 +6342,7 @@ bool SendMessages(CNode* pto)\n             // Ping automatically sent as a latency probe & keepalive.\n             pingSend = true;\n         }\n-        if (pingSend) {\n+        if (pingSend && !pto->fDisconnect) {\n             uint64_t nonce = 0;\n             while (nonce == 0) {\n                 GetRandBytes((unsigned char*)&nonce, sizeof(nonce));\n@@ -6423,7 +6423,7 @@ bool SendMessages(CNode* pto)\n         if (pindexBestHeader == NULL)\n             pindexBestHeader = chainActive.Tip();\n         bool fFetch = state.fPreferredDownload || (nPreferredDownload == 0 && !pto->fClient && !pto->fOneShot); // Download if this is a nice peer, or we have no nice peers and this one might do.\n-        if (!state.fSyncStarted && !pto->fClient && !fImporting && !fReindex) {\n+        if (!state.fSyncStarted && !pto->fClient && !pto->fDisconnect && !fImporting && !fReindex) {\n             // Only actively request headers from a single peer, unless we're close to today.\n             if ((nSyncStarted == 0 && fFetch) || pindexBestHeader->GetBlockTime() > GetAdjustedTime() - 24 * 60 * 60) {\n                 state.fSyncStarted = true;"
      }
    ]
  },
  {
    "sha": "7a34a4614c3ac89ef31cb4854620e381d5df72ad",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3YTM0YTQ2MTRjM2FjODllZjMxY2I0ODU0NjIwZTM4MWQ1ZGY3MmFk",
    "commit": {
      "author": {
        "name": "Johnson Lau",
        "email": "jl2012@xbt.hk",
        "date": "2016-09-30T15:08:29Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2016-10-13T18:09:31Z"
      },
      "message": "Add NULLDUMMY verify flag in bitcoinconsensus.h\n\nGithub-Pull: #8848\nRebased-From: 2fa0063c26c80c719a1c0d30e548e338689ac917",
      "tree": {
        "sha": "93fb1aaef97d15dccb4edf12aa3b432d28f90fc6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/93fb1aaef97d15dccb4edf12aa3b432d28f90fc6"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7a34a4614c3ac89ef31cb4854620e381d5df72ad",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7a34a4614c3ac89ef31cb4854620e381d5df72ad",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7a34a4614c3ac89ef31cb4854620e381d5df72ad",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7a34a4614c3ac89ef31cb4854620e381d5df72ad/comments",
    "author": {
      "login": "jl2012",
      "id": 8403418,
      "node_id": "MDQ6VXNlcjg0MDM0MTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8403418?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jl2012",
      "html_url": "https://github.com/jl2012",
      "followers_url": "https://api.github.com/users/jl2012/followers",
      "following_url": "https://api.github.com/users/jl2012/following{/other_user}",
      "gists_url": "https://api.github.com/users/jl2012/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jl2012/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jl2012/subscriptions",
      "organizations_url": "https://api.github.com/users/jl2012/orgs",
      "repos_url": "https://api.github.com/users/jl2012/repos",
      "events_url": "https://api.github.com/users/jl2012/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jl2012/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7ae624296000e714034d86891ffcd4a565f278fa",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7ae624296000e714034d86891ffcd4a565f278fa",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7ae624296000e714034d86891ffcd4a565f278fa"
      }
    ],
    "stats": {
      "total": 8,
      "additions": 7,
      "deletions": 1
    },
    "files": [
      {
        "sha": "dc363582cc8dee8c6ce0d0afadad030d08958793",
        "filename": "doc/shared-libraries.md",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7a34a4614c3ac89ef31cb4854620e381d5df72ad/doc/shared-libraries.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7a34a4614c3ac89ef31cb4854620e381d5df72ad/doc/shared-libraries.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/shared-libraries.md?ref=7a34a4614c3ac89ef31cb4854620e381d5df72ad",
        "patch": "@@ -30,12 +30,17 @@ The interface is defined in the C header `bitcoinconsensus.h` located in  `src/s\n - `bitcoinconsensus_SCRIPT_FLAGS_VERIFY_NONE`\n - `bitcoinconsensus_SCRIPT_FLAGS_VERIFY_P2SH` - Evaluate P2SH ([BIP16](https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki)) subscripts\n - `bitcoinconsensus_SCRIPT_FLAGS_VERIFY_DERSIG` - Enforce strict DER ([BIP66](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki)) compliance\n+- `bitcoinconsensus_SCRIPT_FLAGS_VERIFY_NULLDUMMY` - Enforce NULLDUMMY ([BIP147](https://github.com/bitcoin/bips/blob/master/bip-0147.mediawiki))\n+- `bitcoinconsensus_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY` - Enable CHECKLOCKTIMEVERIFY ([BIP65](https://github.com/bitcoin/bips/blob/master/bip-0065.mediawiki))\n+- `bitcoinconsensus_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY` - Enable CHECKSEQUENCEVERIFY ([BIP112](https://github.com/bitcoin/bips/blob/master/bip-0112.mediawiki))\n+- `bitcoinconsensus_SCRIPT_FLAGS_VERIFY_WITNESS` - Enable WITNESS ([BIP141](https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki))\n \n ##### Errors\n - `bitcoinconsensus_ERR_OK` - No errors with input parameters *(see the return value of `bitcoinconsensus_verify_script` for the verification status)*\n - `bitcoinconsensus_ERR_TX_INDEX` - An invalid index for `txTo`\n - `bitcoinconsensus_ERR_TX_SIZE_MISMATCH` - `txToLen` did not match with the size of `txTo`\n - `bitcoinconsensus_ERR_DESERIALIZE` - An error deserializing `txTo`\n+- `bitcoinconsensus_ERR_AMOUNT_REQUIRED` - Input amount is required if WITNESS is used\n \n ### Example Implementations\n - [NBitcoin](https://github.com/NicolasDorier/NBitcoin/blob/master/NBitcoin/Script.cs#L814) (.NET Bindings)"
      },
      {
        "sha": "1d2d5c23e471c9536c44505904bbfc9d8949ae62",
        "filename": "src/script/bitcoinconsensus.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7a34a4614c3ac89ef31cb4854620e381d5df72ad/src/script/bitcoinconsensus.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7a34a4614c3ac89ef31cb4854620e381d5df72ad/src/script/bitcoinconsensus.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/bitcoinconsensus.h?ref=7a34a4614c3ac89ef31cb4854620e381d5df72ad",
        "patch": "@@ -1,5 +1,5 @@\n // Copyright (c) 2009-2010 Satoshi Nakamoto\n-// Copyright (c) 2009-2015 The Bitcoin Core developers\n+// Copyright (c) 2009-2016 The Bitcoin Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n@@ -50,6 +50,7 @@ enum\n     bitcoinconsensus_SCRIPT_FLAGS_VERIFY_NONE                = 0,\n     bitcoinconsensus_SCRIPT_FLAGS_VERIFY_P2SH                = (1U << 0), // evaluate P2SH (BIP16) subscripts\n     bitcoinconsensus_SCRIPT_FLAGS_VERIFY_DERSIG              = (1U << 2), // enforce strict DER (BIP66) compliance\n+    bitcoinconsensus_SCRIPT_FLAGS_VERIFY_NULLDUMMY           = (1U << 4), // enforce NULLDUMMY (BIP147)\n     bitcoinconsensus_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY = (1U << 9), // enable CHECKLOCKTIMEVERIFY (BIP65)\n     bitcoinconsensus_SCRIPT_FLAGS_VERIFY_CHECKSEQUENCEVERIFY = (1U << 10), // enable CHECKSEQUENCEVERIFY (BIP112)\n     bitcoinconsensus_SCRIPT_FLAGS_VERIFY_WITNESS             = (1U << 11), // enable WITNESS (BIP141)"
      }
    ]
  },
  {
    "sha": "e47299a8f2ebc98644bb8d15a3222faac51875fd",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplNDcyOTlhOGYyZWJjOTg2NDRiYjhkMTVhMzIyMmZhYWM1MTg3NWZk",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2016-09-17T00:48:23Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2016-10-13T18:09:31Z"
      },
      "message": "[qa] Update p2p-compactblocks.py for compactblocks v2\n\nGithub-Pull: #8393\nRebased-From: 27acfc1d2ee53cc52b54befd2d4bfa24a77a2eef",
      "tree": {
        "sha": "e781746082f04a4d38de243564d5fb207c149de1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e781746082f04a4d38de243564d5fb207c149de1"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e47299a8f2ebc98644bb8d15a3222faac51875fd",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e47299a8f2ebc98644bb8d15a3222faac51875fd",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e47299a8f2ebc98644bb8d15a3222faac51875fd",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e47299a8f2ebc98644bb8d15a3222faac51875fd/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7a34a4614c3ac89ef31cb4854620e381d5df72ad",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7a34a4614c3ac89ef31cb4854620e381d5df72ad",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7a34a4614c3ac89ef31cb4854620e381d5df72ad"
      }
    ],
    "stats": {
      "total": 583,
      "additions": 389,
      "deletions": 194
    },
    "files": [
      {
        "sha": "cdcfb36e7bd301de9191d16b96b38ed07bb9427f",
        "filename": "qa/rpc-tests/p2p-compactblocks.py",
        "status": "modified",
        "additions": 389,
        "deletions": 194,
        "changes": 583,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e47299a8f2ebc98644bb8d15a3222faac51875fd/qa/rpc-tests/p2p-compactblocks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e47299a8f2ebc98644bb8d15a3222faac51875fd/qa/rpc-tests/p2p-compactblocks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/p2p-compactblocks.py?ref=e47299a8f2ebc98644bb8d15a3222faac51875fd",
        "patch": "@@ -12,14 +12,16 @@\n \n '''\n CompactBlocksTest -- test compact blocks (BIP 152)\n-'''\n \n+Version 1 compact blocks are pre-segwit (txids)\n+Version 2 compact blocks are post-segwit (wtxids)\n+'''\n \n # TestNode: A peer we use to send messages to bitcoind, and store responses.\n class TestNode(SingleNodeConnCB):\n     def __init__(self):\n         SingleNodeConnCB.__init__(self)\n-        self.last_sendcmpct = None\n+        self.last_sendcmpct = []\n         self.last_headers = None\n         self.last_inv = None\n         self.last_cmpctblock = None\n@@ -34,7 +36,7 @@ def __init__(self):\n         self.set_announced_blockhashes = set()\n \n     def on_sendcmpct(self, conn, message):\n-        self.last_sendcmpct = message\n+        self.last_sendcmpct.append(message)\n \n     def on_block(self, conn, message):\n         self.last_block = message\n@@ -108,29 +110,31 @@ class CompactBlocksTest(BitcoinTestFramework):\n     def __init__(self):\n         super().__init__()\n         self.setup_clean_chain = True\n-        self.num_nodes = 1\n+        # Node0 = pre-segwit, node1 = segwit-aware\n+        self.num_nodes = 2\n         self.utxos = []\n \n     def setup_network(self):\n         self.nodes = []\n \n-        # Turn off segwit in this test, as compact blocks don't currently work\n-        # with segwit.  (After BIP 152 is updated to support segwit, we can\n-        # test behavior with and without segwit enabled by adding a second node\n-        # to the test.)\n-        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir, [[\"-debug\", \"-logtimemicros=1\", \"-bip9params=segwit:0:0\"]])\n+        # Start up node0 to be a version 1, pre-segwit node.\n+        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir, \n+                [[\"-debug\", \"-logtimemicros=1\", \"-bip9params=segwit:0:0\"], \n+                 [\"-debug\", \"-logtimemicros\", \"-txindex\"]])\n+        connect_nodes(self.nodes[0], 1)\n \n-    def build_block_on_tip(self):\n-        height = self.nodes[0].getblockcount()\n-        tip = self.nodes[0].getbestblockhash()\n-        mtp = self.nodes[0].getblockheader(tip)['mediantime']\n+    def build_block_on_tip(self, node):\n+        height = node.getblockcount()\n+        tip = node.getbestblockhash()\n+        mtp = node.getblockheader(tip)['mediantime']\n         block = create_block(int(tip, 16), create_coinbase(height + 1), mtp + 1)\n         block.solve()\n         return block\n \n     # Create 10 more anyone-can-spend utxo's for testing.\n     def make_utxos(self):\n-        block = self.build_block_on_tip()\n+        # Doesn't matter which node we use, just use node0.\n+        block = self.build_block_on_tip(self.nodes[0])\n         self.test_node.send_and_ping(msg_block(block))\n         assert(int(self.nodes[0].getbestblockhash(), 16) == block.sha256)\n         self.nodes[0].generate(100)\n@@ -143,7 +147,7 @@ def make_utxos(self):\n             tx.vout.append(CTxOut(out_value, CScript([OP_TRUE])))\n         tx.rehash()\n \n-        block2 = self.build_block_on_tip()\n+        block2 = self.build_block_on_tip(self.nodes[0])\n         block2.vtx.append(tx)\n         block2.hashMerkleRoot = block2.calc_merkle_root()\n         block2.solve()\n@@ -152,26 +156,30 @@ def make_utxos(self):\n         self.utxos.extend([[tx.sha256, i, out_value] for i in range(10)])\n         return\n \n-    # Test \"sendcmpct\":\n-    # - No compact block announcements or getdata(MSG_CMPCT_BLOCK) unless\n-    #   sendcmpct is sent.\n-    # - If sendcmpct is sent with version > 1, the message is ignored.\n+    # Test \"sendcmpct\" (between peers preferring the same version):\n+    # - No compact block announcements unless sendcmpct is sent.\n+    # - If sendcmpct is sent with version > preferred_version, the message is ignored.\n     # - If sendcmpct is sent with boolean 0, then block announcements are not\n     #   made with compact blocks.\n     # - If sendcmpct is then sent with boolean 1, then new block announcements\n     #   are made with compact blocks.\n-    def test_sendcmpct(self):\n-        print(\"Testing SENDCMPCT p2p message... \")\n-\n-        # Make sure we get a version 0 SENDCMPCT message from our peer\n+    # If old_node is passed in, request compact blocks with version=preferred-1\n+    # and verify that it receives block announcements via compact block.\n+    def test_sendcmpct(self, node, test_node, preferred_version, old_node=None):\n+        # Make sure we get a SENDCMPCT message from our peer\n         def received_sendcmpct():\n-            return (self.test_node.last_sendcmpct is not None)\n+            return (len(test_node.last_sendcmpct) > 0)\n         got_message = wait_until(received_sendcmpct, timeout=30)\n         assert(received_sendcmpct())\n         assert(got_message)\n-        assert_equal(self.test_node.last_sendcmpct.version, 1)\n+        with mininode_lock:\n+            # Check that the first version received is the preferred one\n+            assert_equal(test_node.last_sendcmpct[0].version, preferred_version)\n+            # And that we receive versions down to 1.\n+            assert_equal(test_node.last_sendcmpct[-1].version, 1)\n+            test_node.last_sendcmpct = []\n \n-        tip = int(self.nodes[0].getbestblockhash(), 16)\n+        tip = int(node.getbestblockhash(), 16)\n \n         def check_announcement_of_new_block(node, peer, predicate):\n             peer.clear_block_announcement()\n@@ -183,56 +191,75 @@ def check_announcement_of_new_block(node, peer, predicate):\n                 assert(predicate(peer))\n \n         # We shouldn't get any block announcements via cmpctblock yet.\n-        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda p: p.last_cmpctblock is None)\n+        check_announcement_of_new_block(node, test_node, lambda p: p.last_cmpctblock is None)\n \n         # Try one more time, this time after requesting headers.\n-        self.test_node.request_headers_and_sync(locator=[tip])\n-        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda p: p.last_cmpctblock is None and p.last_inv is not None)\n+        test_node.request_headers_and_sync(locator=[tip])\n+        check_announcement_of_new_block(node, test_node, lambda p: p.last_cmpctblock is None and p.last_inv is not None)\n \n         # Test a few ways of using sendcmpct that should NOT\n         # result in compact block announcements.\n         # Before each test, sync the headers chain.\n-        self.test_node.request_headers_and_sync(locator=[tip])\n+        test_node.request_headers_and_sync(locator=[tip])\n \n         # Now try a SENDCMPCT message with too-high version\n         sendcmpct = msg_sendcmpct()\n-        sendcmpct.version = 2\n-        self.test_node.send_and_ping(sendcmpct)\n-        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda p: p.last_cmpctblock is None)\n+        sendcmpct.version = preferred_version+1\n+        sendcmpct.announce = True\n+        test_node.send_and_ping(sendcmpct)\n+        check_announcement_of_new_block(node, test_node, lambda p: p.last_cmpctblock is None)\n \n         # Headers sync before next test.\n-        self.test_node.request_headers_and_sync(locator=[tip])\n+        test_node.request_headers_and_sync(locator=[tip])\n \n         # Now try a SENDCMPCT message with valid version, but announce=False\n-        self.test_node.send_and_ping(msg_sendcmpct())\n-        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda p: p.last_cmpctblock is None)\n+        sendcmpct.version = preferred_version\n+        sendcmpct.announce = False\n+        test_node.send_and_ping(sendcmpct)\n+        check_announcement_of_new_block(node, test_node, lambda p: p.last_cmpctblock is None)\n \n         # Headers sync before next test.\n-        self.test_node.request_headers_and_sync(locator=[tip])\n+        test_node.request_headers_and_sync(locator=[tip])\n \n         # Finally, try a SENDCMPCT message with announce=True\n-        sendcmpct.version = 1\n+        sendcmpct.version = preferred_version\n         sendcmpct.announce = True\n-        self.test_node.send_and_ping(sendcmpct)\n-        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda p: p.last_cmpctblock is not None)\n+        test_node.send_and_ping(sendcmpct)\n+        check_announcement_of_new_block(node, test_node, lambda p: p.last_cmpctblock is not None)\n \n         # Try one more time (no headers sync should be needed!)\n-        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda p: p.last_cmpctblock is not None)\n+        check_announcement_of_new_block(node, test_node, lambda p: p.last_cmpctblock is not None)\n \n         # Try one more time, after turning on sendheaders\n-        self.test_node.send_and_ping(msg_sendheaders())\n-        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda p: p.last_cmpctblock is not None)\n+        test_node.send_and_ping(msg_sendheaders())\n+        check_announcement_of_new_block(node, test_node, lambda p: p.last_cmpctblock is not None)\n+\n+        # Try one more time, after sending a version-1, announce=false message.\n+        sendcmpct.version = preferred_version-1\n+        sendcmpct.announce = False\n+        test_node.send_and_ping(sendcmpct)\n+        check_announcement_of_new_block(node, test_node, lambda p: p.last_cmpctblock is not None)\n \n         # Now turn off announcements\n+        sendcmpct.version = preferred_version\n         sendcmpct.announce = False\n-        self.test_node.send_and_ping(sendcmpct)\n-        check_announcement_of_new_block(self.nodes[0], self.test_node, lambda p: p.last_cmpctblock is None and p.last_headers is not None)\n+        test_node.send_and_ping(sendcmpct)\n+        check_announcement_of_new_block(node, test_node, lambda p: p.last_cmpctblock is None and p.last_headers is not None)\n+\n+        if old_node is not None:\n+            # Verify that a peer using an older protocol version can receive\n+            # announcements from this node.\n+            sendcmpct.version = preferred_version-1\n+            sendcmpct.announce = True\n+            old_node.send_and_ping(sendcmpct)\n+            # Header sync\n+            old_node.request_headers_and_sync(locator=[tip])\n+            check_announcement_of_new_block(node, old_node, lambda p: p.last_cmpctblock is not None)\n \n     # This test actually causes bitcoind to (reasonably!) disconnect us, so do this last.\n     def test_invalid_cmpctblock_message(self):\n-        print(\"Testing invalid index in cmpctblock message...\")\n         self.nodes[0].generate(101)\n-        block = self.build_block_on_tip()\n+        block = self.build_block_on_tip(self.nodes[0])\n \n         cmpct_block = P2PHeaderAndShortIDs()\n         cmpct_block.header = CBlockHeader(block)\n@@ -245,47 +272,63 @@ def test_invalid_cmpctblock_message(self):\n \n     # Compare the generated shortids to what we expect based on BIP 152, given\n     # bitcoind's choice of nonce.\n-    def test_compactblock_construction(self):\n-        print(\"Testing compactblock headers and shortIDs are correct...\")\n-\n+    def test_compactblock_construction(self, node, test_node, version, use_witness_address):\n         # Generate a bunch of transactions.\n-        self.nodes[0].generate(101)\n+        node.generate(101)\n         num_transactions = 25\n-        address = self.nodes[0].getnewaddress()\n+        address = node.getnewaddress()\n+        if use_witness_address:\n+            # Want at least one segwit spend, so move all funds to\n+            # a witness address.\n+            address = node.addwitnessaddress(address)\n+            value_to_send = node.getbalance()\n+            node.sendtoaddress(address, satoshi_round(value_to_send-Decimal(0.1)))\n+            node.generate(1)\n+\n+        segwit_tx_generated = False\n         for i in range(num_transactions):\n-            self.nodes[0].sendtoaddress(address, 0.1)\n+            txid = node.sendtoaddress(address, 0.1)\n+            hex_tx = node.gettransaction(txid)[\"hex\"]\n+            tx = FromHex(CTransaction(), hex_tx)\n+            if not tx.wit.is_null():\n+                segwit_tx_generated = True\n+\n+        if use_witness_address:\n+            assert(segwit_tx_generated) # check that our test is not broken\n \n         # Wait until we've seen the block announcement for the resulting tip\n         tip = int(self.nodes[0].getbestblockhash(), 16)\n         assert(self.test_node.wait_for_block_announcement(tip))\n \n         # Now mine a block, and look at the resulting compact block.\n-        self.test_node.clear_block_announcement()\n-        block_hash = int(self.nodes[0].generate(1)[0], 16)\n+        test_node.clear_block_announcement()\n+        block_hash = int(node.generate(1)[0], 16)\n \n         # Store the raw block in our internal format.\n-        block = FromHex(CBlock(), self.nodes[0].getblock(\"%02x\" % block_hash, False))\n+        block = FromHex(CBlock(), node.getblock(\"%02x\" % block_hash, False))\n         [tx.calc_sha256() for tx in block.vtx]\n         block.rehash()\n \n         # Don't care which type of announcement came back for this test; just\n         # request the compact block if we didn't get one yet.\n-        wait_until(self.test_node.received_block_announcement, timeout=30)\n+        wait_until(test_node.received_block_announcement, timeout=30)\n+        assert(test_node.received_block_announcement())\n \n         with mininode_lock:\n-            if self.test_node.last_cmpctblock is None:\n-                self.test_node.clear_block_announcement()\n+            if test_node.last_cmpctblock is None:\n+                test_node.clear_block_announcement()\n                 inv = CInv(4, block_hash)  # 4 == \"CompactBlock\"\n-                self.test_node.send_message(msg_getdata([inv]))\n+                test_node.send_message(msg_getdata([inv]))\n \n-        wait_until(self.test_node.received_block_announcement, timeout=30)\n+        wait_until(test_node.received_block_announcement, timeout=30)\n+        assert(test_node.received_block_announcement())\n \n         # Now we should have the compactblock\n         header_and_shortids = None\n         with mininode_lock:\n-            assert(self.test_node.last_cmpctblock is not None)\n+            assert(test_node.last_cmpctblock is not None)\n             # Convert the on-the-wire representation to absolute indexes\n-            header_and_shortids = HeaderAndShortIDs(self.test_node.last_cmpctblock.header_and_shortids)\n+            header_and_shortids = HeaderAndShortIDs(test_node.last_cmpctblock.header_and_shortids)\n \n         # Check that we got the right block!\n         header_and_shortids.header.calc_sha256()\n@@ -298,8 +341,17 @@ def test_compactblock_construction(self):\n         # Check that all prefilled_txn entries match what's in the block.\n         for entry in header_and_shortids.prefilled_txn:\n             entry.tx.calc_sha256()\n+            # This checks the non-witness parts of the tx agree\n             assert_equal(entry.tx.sha256, block.vtx[entry.index].sha256)\n \n+            # And this checks the witness\n+            wtxid = entry.tx.calc_sha256(True)\n+            if version == 2:\n+                assert_equal(wtxid, block.vtx[entry.index].calc_sha256(True))\n+            else:\n+                # Shouldn't have received a witness\n+                assert(entry.tx.wit.is_null())\n+\n         # Check that the cmpctblock message announced all the transactions.\n         assert_equal(len(header_and_shortids.prefilled_txn) + len(header_and_shortids.shortids), len(block.vtx))\n \n@@ -314,57 +366,61 @@ def test_compactblock_construction(self):\n                 # Already checked prefilled transactions above\n                 header_and_shortids.prefilled_txn.pop(0)\n             else:\n-                shortid = calculate_shortid(k0, k1, block.vtx[index].sha256)\n+                tx_hash = block.vtx[index].sha256\n+                if version == 2:\n+                    tx_hash = block.vtx[index].calc_sha256(True)\n+                shortid = calculate_shortid(k0, k1, tx_hash)\n                 assert_equal(shortid, header_and_shortids.shortids[0])\n                 header_and_shortids.shortids.pop(0)\n             index += 1\n \n     # Test that bitcoind requests compact blocks when we announce new blocks\n     # via header or inv, and that responding to getblocktxn causes the block\n     # to be successfully reconstructed.\n-    def test_compactblock_requests(self):\n-        print(\"Testing compactblock requests... \")\n-\n+    # Post-segwit: upgraded nodes would only make this request of cb-version-2,\n+    # NODE_WITNESS peers.  Unupgraded nodes would still make this request of\n+    # any cb-version-1-supporting peer.\n+    def test_compactblock_requests(self, node, test_node):\n         # Try announcing a block with an inv or header, expect a compactblock\n         # request\n         for announce in [\"inv\", \"header\"]:\n-            block = self.build_block_on_tip()\n+            block = self.build_block_on_tip(node)\n             with mininode_lock:\n-                self.test_node.last_getdata = None\n+                test_node.last_getdata = None\n \n             if announce == \"inv\":\n-                self.test_node.send_message(msg_inv([CInv(2, block.sha256)]))\n+                test_node.send_message(msg_inv([CInv(2, block.sha256)]))\n             else:\n-                self.test_node.send_header_for_blocks([block])\n-            success = wait_until(lambda: self.test_node.last_getdata is not None, timeout=30)\n+                test_node.send_header_for_blocks([block])\n+            success = wait_until(lambda: test_node.last_getdata is not None, timeout=30)\n             assert(success)\n-            assert_equal(len(self.test_node.last_getdata.inv), 1)\n-            assert_equal(self.test_node.last_getdata.inv[0].type, 4)\n-            assert_equal(self.test_node.last_getdata.inv[0].hash, block.sha256)\n+            assert_equal(len(test_node.last_getdata.inv), 1)\n+            assert_equal(test_node.last_getdata.inv[0].type, 4)\n+            assert_equal(test_node.last_getdata.inv[0].hash, block.sha256)\n \n             # Send back a compactblock message that omits the coinbase\n             comp_block = HeaderAndShortIDs()\n             comp_block.header = CBlockHeader(block)\n             comp_block.nonce = 0\n             comp_block.shortids = [1]  # this is useless, and wrong\n-            self.test_node.send_and_ping(msg_cmpctblock(comp_block.to_p2p()))\n-            assert_equal(int(self.nodes[0].getbestblockhash(), 16), block.hashPrevBlock)\n+            test_node.send_and_ping(msg_cmpctblock(comp_block.to_p2p()))\n+            assert_equal(int(node.getbestblockhash(), 16), block.hashPrevBlock)\n             # Expect a getblocktxn message.\n             with mininode_lock:\n-                assert(self.test_node.last_getblocktxn is not None)\n-                absolute_indexes = self.test_node.last_getblocktxn.block_txn_request.to_absolute()\n+                assert(test_node.last_getblocktxn is not None)\n+                absolute_indexes = test_node.last_getblocktxn.block_txn_request.to_absolute()\n             assert_equal(absolute_indexes, [0])  # should be a coinbase request\n \n             # Send the coinbase, and verify that the tip advances.\n             msg = msg_blocktxn()\n             msg.block_transactions.blockhash = block.sha256\n             msg.block_transactions.transactions = [block.vtx[0]]\n-            self.test_node.send_and_ping(msg)\n-            assert_equal(int(self.nodes[0].getbestblockhash(), 16), block.sha256)\n+            test_node.send_and_ping(msg)\n+            assert_equal(int(node.getbestblockhash(), 16), block.sha256)\n \n     # Create a chain of transactions from given utxo, and add to a new block.\n-    def build_block_with_transactions(self, utxo, num_transactions):\n-        block = self.build_block_on_tip()\n+    def build_block_with_transactions(self, node, utxo, num_transactions):\n+        block = self.build_block_on_tip(node)\n \n         for i in range(num_transactions):\n             tx = CTransaction()\n@@ -381,118 +437,113 @@ def build_block_with_transactions(self, utxo, num_transactions):\n     # Test that we only receive getblocktxn requests for transactions that the\n     # node needs, and that responding to them causes the block to be\n     # reconstructed.\n-    def test_getblocktxn_requests(self):\n-        print(\"Testing getblocktxn requests...\")\n+    def test_getblocktxn_requests(self, node, test_node, version):\n+        with_witness = (version==2)\n+\n+        def test_getblocktxn_response(compact_block, peer, expected_result):\n+            msg = msg_cmpctblock(compact_block.to_p2p())\n+            peer.send_and_ping(msg)\n+            with mininode_lock:\n+                assert(peer.last_getblocktxn is not None)\n+                absolute_indexes = peer.last_getblocktxn.block_txn_request.to_absolute()\n+            assert_equal(absolute_indexes, expected_result)\n+\n+        def test_tip_after_message(node, peer, msg, tip):\n+            peer.send_and_ping(msg)\n+            assert_equal(int(node.getbestblockhash(), 16), tip)\n \n         # First try announcing compactblocks that won't reconstruct, and verify\n         # that we receive getblocktxn messages back.\n         utxo = self.utxos.pop(0)\n \n-        block = self.build_block_with_transactions(utxo, 5)\n+        block = self.build_block_with_transactions(node, utxo, 5)\n         self.utxos.append([block.vtx[-1].sha256, 0, block.vtx[-1].vout[0].nValue])\n-\n         comp_block = HeaderAndShortIDs()\n-        comp_block.initialize_from_block(block)\n+        comp_block.initialize_from_block(block, use_witness=with_witness)\n \n-        self.test_node.send_and_ping(msg_cmpctblock(comp_block.to_p2p()))\n-        with mininode_lock:\n-            assert(self.test_node.last_getblocktxn is not None)\n-            absolute_indexes = self.test_node.last_getblocktxn.block_txn_request.to_absolute()\n-        assert_equal(absolute_indexes, [1, 2, 3, 4, 5])\n-        msg = msg_blocktxn()\n-        msg.block_transactions = BlockTransactions(block.sha256, block.vtx[1:])\n-        self.test_node.send_and_ping(msg)\n-        assert_equal(int(self.nodes[0].getbestblockhash(), 16), block.sha256)\n+        test_getblocktxn_response(comp_block, test_node, [1, 2, 3, 4, 5])\n+\n+        msg_bt = msg_blocktxn()\n+        if with_witness:\n+            msg_bt = msg_witness_blocktxn() # serialize with witnesses\n+        msg_bt.block_transactions = BlockTransactions(block.sha256, block.vtx[1:])\n+        test_tip_after_message(node, test_node, msg_bt, block.sha256)\n \n         utxo = self.utxos.pop(0)\n-        block = self.build_block_with_transactions(utxo, 5)\n+        block = self.build_block_with_transactions(node, utxo, 5)\n         self.utxos.append([block.vtx[-1].sha256, 0, block.vtx[-1].vout[0].nValue])\n \n         # Now try interspersing the prefilled transactions\n-        comp_block.initialize_from_block(block, prefill_list=[0, 1, 5])\n-        self.test_node.send_and_ping(msg_cmpctblock(comp_block.to_p2p()))\n-        with mininode_lock:\n-            assert(self.test_node.last_getblocktxn is not None)\n-            absolute_indexes = self.test_node.last_getblocktxn.block_txn_request.to_absolute()\n-        assert_equal(absolute_indexes, [2, 3, 4])\n-        msg.block_transactions = BlockTransactions(block.sha256, block.vtx[2:5])\n-        self.test_node.send_and_ping(msg)\n-        assert_equal(int(self.nodes[0].getbestblockhash(), 16), block.sha256)\n+        comp_block.initialize_from_block(block, prefill_list=[0, 1, 5], use_witness=with_witness)\n+        test_getblocktxn_response(comp_block, test_node, [2, 3, 4])\n+        msg_bt.block_transactions = BlockTransactions(block.sha256, block.vtx[2:5])\n+        test_tip_after_message(node, test_node, msg_bt, block.sha256)\n \n         # Now try giving one transaction ahead of time.\n         utxo = self.utxos.pop(0)\n-        block = self.build_block_with_transactions(utxo, 5)\n+        block = self.build_block_with_transactions(node, utxo, 5)\n         self.utxos.append([block.vtx[-1].sha256, 0, block.vtx[-1].vout[0].nValue])\n-        self.test_node.send_and_ping(msg_tx(block.vtx[1]))\n-        assert(block.vtx[1].hash in self.nodes[0].getrawmempool())\n+        test_node.send_and_ping(msg_tx(block.vtx[1]))\n+        assert(block.vtx[1].hash in node.getrawmempool())\n \n         # Prefill 4 out of the 6 transactions, and verify that only the one\n         # that was not in the mempool is requested.\n-        comp_block.initialize_from_block(block, prefill_list=[0, 2, 3, 4])\n-        self.test_node.send_and_ping(msg_cmpctblock(comp_block.to_p2p()))\n-        with mininode_lock:\n-            assert(self.test_node.last_getblocktxn is not None)\n-            absolute_indexes = self.test_node.last_getblocktxn.block_txn_request.to_absolute()\n-        assert_equal(absolute_indexes, [5])\n+        comp_block.initialize_from_block(block, prefill_list=[0, 2, 3, 4], use_witness=with_witness)\n+        test_getblocktxn_response(comp_block, test_node, [5])\n \n-        msg.block_transactions = BlockTransactions(block.sha256, [block.vtx[5]])\n-        self.test_node.send_and_ping(msg)\n-        assert_equal(int(self.nodes[0].getbestblockhash(), 16), block.sha256)\n+        msg_bt.block_transactions = BlockTransactions(block.sha256, [block.vtx[5]])\n+        test_tip_after_message(node, test_node, msg_bt, block.sha256)\n \n         # Now provide all transactions to the node before the block is\n         # announced and verify reconstruction happens immediately.\n         utxo = self.utxos.pop(0)\n-        block = self.build_block_with_transactions(utxo, 10)\n+        block = self.build_block_with_transactions(node, utxo, 10)\n         self.utxos.append([block.vtx[-1].sha256, 0, block.vtx[-1].vout[0].nValue])\n         for tx in block.vtx[1:]:\n-            self.test_node.send_message(msg_tx(tx))\n-        self.test_node.sync_with_ping()\n+            test_node.send_message(msg_tx(tx))\n+        test_node.sync_with_ping()\n         # Make sure all transactions were accepted.\n-        mempool = self.nodes[0].getrawmempool()\n+        mempool = node.getrawmempool()\n         for tx in block.vtx[1:]:\n             assert(tx.hash in mempool)\n \n         # Clear out last request.\n         with mininode_lock:\n-            self.test_node.last_getblocktxn = None\n+            test_node.last_getblocktxn = None\n \n         # Send compact block\n-        comp_block.initialize_from_block(block, prefill_list=[0])\n-        self.test_node.send_and_ping(msg_cmpctblock(comp_block.to_p2p()))\n+        comp_block.initialize_from_block(block, prefill_list=[0], use_witness=with_witness)\n+        test_tip_after_message(node, test_node, msg_cmpctblock(comp_block.to_p2p()), block.sha256)\n         with mininode_lock:\n             # Shouldn't have gotten a request for any transaction\n-            assert(self.test_node.last_getblocktxn is None)\n-        # Tip should have updated\n-        assert_equal(int(self.nodes[0].getbestblockhash(), 16), block.sha256)\n+            assert(test_node.last_getblocktxn is None)\n \n     # Incorrectly responding to a getblocktxn shouldn't cause the block to be\n     # permanently failed.\n-    def test_incorrect_blocktxn_response(self):\n-        print(\"Testing handling of incorrect blocktxn responses...\")\n-\n+    def test_incorrect_blocktxn_response(self, node, test_node, version):\n         if (len(self.utxos) == 0):\n             self.make_utxos()\n         utxo = self.utxos.pop(0)\n \n-        block = self.build_block_with_transactions(utxo, 10)\n+        block = self.build_block_with_transactions(node, utxo, 10)\n         self.utxos.append([block.vtx[-1].sha256, 0, block.vtx[-1].vout[0].nValue])\n         # Relay the first 5 transactions from the block in advance\n         for tx in block.vtx[1:6]:\n-            self.test_node.send_message(msg_tx(tx))\n-        self.test_node.sync_with_ping()\n+            test_node.send_message(msg_tx(tx))\n+        test_node.sync_with_ping()\n         # Make sure all transactions were accepted.\n-        mempool = self.nodes[0].getrawmempool()\n+        mempool = node.getrawmempool()\n         for tx in block.vtx[1:6]:\n             assert(tx.hash in mempool)\n \n         # Send compact block\n         comp_block = HeaderAndShortIDs()\n-        comp_block.initialize_from_block(block, prefill_list=[0])\n-        self.test_node.send_and_ping(msg_cmpctblock(comp_block.to_p2p()))\n+        comp_block.initialize_from_block(block, prefill_list=[0], use_witness=(version == 2))\n+        test_node.send_and_ping(msg_cmpctblock(comp_block.to_p2p()))\n         absolute_indexes = []\n         with mininode_lock:\n-            assert(self.test_node.last_getblocktxn is not None)\n-            absolute_indexes = self.test_node.last_getblocktxn.block_txn_request.to_absolute()\n+            assert(test_node.last_getblocktxn is not None)\n+            absolute_indexes = test_node.last_getblocktxn.block_txn_request.to_absolute()\n         assert_equal(absolute_indexes, [6, 7, 8, 9, 10])\n \n         # Now give an incorrect response.\n@@ -504,100 +555,107 @@ def test_incorrect_blocktxn_response(self):\n         # verifying that the block isn't marked bad permanently. This is good\n         # enough for now.\n         msg = msg_blocktxn()\n+        if version==2:\n+            msg = msg_witness_blocktxn()\n         msg.block_transactions = BlockTransactions(block.sha256, [block.vtx[5]] + block.vtx[7:])\n-        self.test_node.send_and_ping(msg)\n+        test_node.send_and_ping(msg)\n \n         # Tip should not have updated\n-        assert_equal(int(self.nodes[0].getbestblockhash(), 16), block.hashPrevBlock)\n+        assert_equal(int(node.getbestblockhash(), 16), block.hashPrevBlock)\n \n         # We should receive a getdata request\n-        success = wait_until(lambda: self.test_node.last_getdata is not None, timeout=10)\n+        success = wait_until(lambda: test_node.last_getdata is not None, timeout=10)\n         assert(success)\n-        assert_equal(len(self.test_node.last_getdata.inv), 1)\n-        assert_equal(self.test_node.last_getdata.inv[0].type, 2)\n-        assert_equal(self.test_node.last_getdata.inv[0].hash, block.sha256)\n+        assert_equal(len(test_node.last_getdata.inv), 1)\n+        assert(test_node.last_getdata.inv[0].type == 2 or test_node.last_getdata.inv[0].type == 2|MSG_WITNESS_FLAG)\n+        assert_equal(test_node.last_getdata.inv[0].hash, block.sha256)\n \n         # Deliver the block\n-        self.test_node.send_and_ping(msg_block(block))\n-        assert_equal(int(self.nodes[0].getbestblockhash(), 16), block.sha256)\n-\n-    def test_getblocktxn_handler(self):\n-        print(\"Testing getblocktxn handler...\")\n+        if version==2:\n+            test_node.send_and_ping(msg_witness_block(block))\n+        else:\n+            test_node.send_and_ping(msg_block(block))\n+        assert_equal(int(node.getbestblockhash(), 16), block.sha256)\n \n+    def test_getblocktxn_handler(self, node, test_node, version):\n         # bitcoind won't respond for blocks whose height is more than 15 blocks\n         # deep.\n         MAX_GETBLOCKTXN_DEPTH = 15\n-        chain_height = self.nodes[0].getblockcount()\n+        chain_height = node.getblockcount()\n         current_height = chain_height\n         while (current_height >= chain_height - MAX_GETBLOCKTXN_DEPTH):\n-            block_hash = self.nodes[0].getblockhash(current_height)\n-            block = FromHex(CBlock(), self.nodes[0].getblock(block_hash, False))\n+            block_hash = node.getblockhash(current_height)\n+            block = FromHex(CBlock(), node.getblock(block_hash, False))\n \n             msg = msg_getblocktxn()\n             msg.block_txn_request = BlockTransactionsRequest(int(block_hash, 16), [])\n             num_to_request = random.randint(1, len(block.vtx))\n             msg.block_txn_request.from_absolute(sorted(random.sample(range(len(block.vtx)), num_to_request)))\n-            self.test_node.send_message(msg)\n-            success = wait_until(lambda: self.test_node.last_blocktxn is not None, timeout=10)\n+            test_node.send_message(msg)\n+            success = wait_until(lambda: test_node.last_blocktxn is not None, timeout=10)\n             assert(success)\n \n             [tx.calc_sha256() for tx in block.vtx]\n             with mininode_lock:\n-                assert_equal(self.test_node.last_blocktxn.block_transactions.blockhash, int(block_hash, 16))\n+                assert_equal(test_node.last_blocktxn.block_transactions.blockhash, int(block_hash, 16))\n                 all_indices = msg.block_txn_request.to_absolute()\n                 for index in all_indices:\n-                    tx = self.test_node.last_blocktxn.block_transactions.transactions.pop(0)\n+                    tx = test_node.last_blocktxn.block_transactions.transactions.pop(0)\n                     tx.calc_sha256()\n                     assert_equal(tx.sha256, block.vtx[index].sha256)\n-                self.test_node.last_blocktxn = None\n+                    if version == 1:\n+                        # Witnesses should have been stripped\n+                        assert(tx.wit.is_null())\n+                    else:\n+                        # Check that the witness matches\n+                        assert_equal(tx.calc_sha256(True), block.vtx[index].calc_sha256(True))\n+                test_node.last_blocktxn = None\n             current_height -= 1\n \n         # Next request should be ignored, as we're past the allowed depth.\n-        block_hash = self.nodes[0].getblockhash(current_height)\n+        block_hash = node.getblockhash(current_height)\n         msg.block_txn_request = BlockTransactionsRequest(int(block_hash, 16), [0])\n-        self.test_node.send_and_ping(msg)\n+        test_node.send_and_ping(msg)\n         with mininode_lock:\n-            assert_equal(self.test_node.last_blocktxn, None)\n-\n-    def test_compactblocks_not_at_tip(self):\n-        print(\"Testing compactblock requests/announcements not at chain tip...\")\n+            assert_equal(test_node.last_blocktxn, None)\n \n+    def test_compactblocks_not_at_tip(self, node, test_node):\n         # Test that requesting old compactblocks doesn't work.\n         MAX_CMPCTBLOCK_DEPTH = 11\n         new_blocks = []\n         for i in range(MAX_CMPCTBLOCK_DEPTH):\n-            self.test_node.clear_block_announcement()\n-            new_blocks.append(self.nodes[0].generate(1)[0])\n-            wait_until(self.test_node.received_block_announcement, timeout=30)\n+            test_node.clear_block_announcement()\n+            new_blocks.append(node.generate(1)[0])\n+            wait_until(test_node.received_block_announcement, timeout=30)\n \n-        self.test_node.clear_block_announcement()\n-        self.test_node.send_message(msg_getdata([CInv(4, int(new_blocks[0], 16))]))\n-        success = wait_until(lambda: self.test_node.last_cmpctblock is not None, timeout=30)\n+        test_node.clear_block_announcement()\n+        test_node.send_message(msg_getdata([CInv(4, int(new_blocks[0], 16))]))\n+        success = wait_until(lambda: test_node.last_cmpctblock is not None, timeout=30)\n         assert(success)\n \n-        self.test_node.clear_block_announcement()\n-        self.nodes[0].generate(1)\n-        wait_until(self.test_node.received_block_announcement, timeout=30)\n-        self.test_node.clear_block_announcement()\n-        self.test_node.send_message(msg_getdata([CInv(4, int(new_blocks[0], 16))]))\n-        success = wait_until(lambda: self.test_node.last_block is not None, timeout=30)\n+        test_node.clear_block_announcement()\n+        node.generate(1)\n+        wait_until(test_node.received_block_announcement, timeout=30)\n+        test_node.clear_block_announcement()\n+        test_node.send_message(msg_getdata([CInv(4, int(new_blocks[0], 16))]))\n+        success = wait_until(lambda: test_node.last_block is not None, timeout=30)\n         assert(success)\n         with mininode_lock:\n-            self.test_node.last_block.block.calc_sha256()\n-            assert_equal(self.test_node.last_block.block.sha256, int(new_blocks[0], 16))\n+            test_node.last_block.block.calc_sha256()\n+            assert_equal(test_node.last_block.block.sha256, int(new_blocks[0], 16))\n \n         # Generate an old compactblock, and verify that it's not accepted.\n-        cur_height = self.nodes[0].getblockcount()\n-        hashPrevBlock = int(self.nodes[0].getblockhash(cur_height-5), 16)\n-        block = self.build_block_on_tip()\n+        cur_height = node.getblockcount()\n+        hashPrevBlock = int(node.getblockhash(cur_height-5), 16)\n+        block = self.build_block_on_tip(node)\n         block.hashPrevBlock = hashPrevBlock\n         block.solve()\n \n         comp_block = HeaderAndShortIDs()\n         comp_block.initialize_from_block(block)\n-        self.test_node.send_and_ping(msg_cmpctblock(comp_block.to_p2p()))\n+        test_node.send_and_ping(msg_cmpctblock(comp_block.to_p2p()))\n \n-        tips = self.nodes[0].getchaintips()\n+        tips = node.getchaintips()\n         found = False\n         for x in tips:\n             if x[\"hash\"] == block.hash:\n@@ -611,18 +669,61 @@ def test_compactblocks_not_at_tip(self):\n         msg = msg_getblocktxn()\n         msg.block_txn_request = BlockTransactionsRequest(block.sha256, [0])\n         with mininode_lock:\n-            self.test_node.last_blocktxn = None\n-        self.test_node.send_and_ping(msg)\n+            test_node.last_blocktxn = None\n+        test_node.send_and_ping(msg)\n         with mininode_lock:\n-            assert(self.test_node.last_blocktxn is None)\n+            assert(test_node.last_blocktxn is None)\n+\n+    def activate_segwit(self, node):\n+        node.generate(144*3)\n+        assert_equal(get_bip9_status(node, \"segwit\")[\"status\"], 'active')\n+\n+    def test_end_to_end_block_relay(self, node, listeners):\n+        utxo = self.utxos.pop(0)\n+\n+        block = self.build_block_with_transactions(node, utxo, 10)\n+\n+        [l.clear_block_announcement() for l in listeners]\n+\n+        # ToHex() won't serialize with witness, but this block has no witnesses\n+        # anyway. TODO: repeat this test with witness tx's to a segwit node.\n+        node.submitblock(ToHex(block))\n+\n+        for l in listeners:\n+            wait_until(lambda: l.received_block_announcement(), timeout=30)\n+        with mininode_lock:\n+            for l in listeners:\n+                assert(l.last_cmpctblock is not None)\n+                l.last_cmpctblock.header_and_shortids.header.calc_sha256()\n+                assert_equal(l.last_cmpctblock.header_and_shortids.header.sha256, block.sha256)\n+\n+    # Helper for enabling cb announcements\n+    # Send the sendcmpct request and sync headers\n+    def request_cb_announcements(self, peer, node, version):\n+        tip = node.getbestblockhash()\n+        peer.get_headers(locator=[int(tip, 16)], hashstop=0)\n+\n+        msg = msg_sendcmpct()\n+        msg.version = version\n+        msg.announce = True\n+        peer.send_and_ping(msg)\n+\n \n     def run_test(self):\n         # Setup the p2p connections and start up the network thread.\n         self.test_node = TestNode()\n+        self.segwit_node = TestNode()\n+        self.old_node = TestNode()  # version 1 peer <--> segwit node\n \n         connections = []\n         connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], self.test_node))\n+        connections.append(NodeConn('127.0.0.1', p2p_port(1), self.nodes[1],\n+                    self.segwit_node, services=NODE_NETWORK|NODE_WITNESS))\n+        connections.append(NodeConn('127.0.0.1', p2p_port(1), self.nodes[1],\n+                    self.old_node, services=NODE_NETWORK))\n         self.test_node.add_connection(connections[0])\n+        self.segwit_node.add_connection(connections[1])\n+        self.old_node.add_connection(connections[2])\n \n         NetworkThread().start()  # Start up network handling in another thread\n \n@@ -632,13 +733,107 @@ def run_test(self):\n         # We will need UTXOs to construct transactions in later tests.\n         self.make_utxos()\n \n-        self.test_sendcmpct()\n-        self.test_compactblock_construction()\n-        self.test_compactblock_requests()\n-        self.test_getblocktxn_requests()\n-        self.test_getblocktxn_handler()\n-        self.test_compactblocks_not_at_tip()\n-        self.test_incorrect_blocktxn_response()\n+        print(\"Running tests, pre-segwit activation:\")\n+\n+        print(\"\\tTesting SENDCMPCT p2p message... \")\n+        self.test_sendcmpct(self.nodes[0], self.test_node, 1)\n+        sync_blocks(self.nodes)\n+        self.test_sendcmpct(self.nodes[1], self.segwit_node, 2, old_node=self.old_node)\n+        sync_blocks(self.nodes)\n+\n+        print(\"\\tTesting compactblock construction...\")\n+        self.test_compactblock_construction(self.nodes[0], self.test_node, 1, False)\n+        sync_blocks(self.nodes)\n+        self.test_compactblock_construction(self.nodes[1], self.segwit_node, 2, False)\n+        sync_blocks(self.nodes)\n+\n+        print(\"\\tTesting compactblock requests... \")\n+        self.test_compactblock_requests(self.nodes[0], self.test_node)\n+        sync_blocks(self.nodes)\n+        self.test_compactblock_requests(self.nodes[1], self.segwit_node)\n+        sync_blocks(self.nodes)\n+\n+        print(\"\\tTesting getblocktxn requests...\")\n+        self.test_getblocktxn_requests(self.nodes[0], self.test_node, 1)\n+        sync_blocks(self.nodes)\n+        self.test_getblocktxn_requests(self.nodes[1], self.segwit_node, 2)\n+        sync_blocks(self.nodes)\n+\n+        print(\"\\tTesting getblocktxn handler...\")\n+        self.test_getblocktxn_handler(self.nodes[0], self.test_node, 1)\n+        sync_blocks(self.nodes)\n+        self.test_getblocktxn_handler(self.nodes[1], self.segwit_node, 2)\n+        self.test_getblocktxn_handler(self.nodes[1], self.old_node, 1)\n+        sync_blocks(self.nodes)\n+\n+        print(\"\\tTesting compactblock requests/announcements not at chain tip...\")\n+        self.test_compactblocks_not_at_tip(self.nodes[0], self.test_node)\n+        sync_blocks(self.nodes)\n+        self.test_compactblocks_not_at_tip(self.nodes[1], self.segwit_node)\n+        self.test_compactblocks_not_at_tip(self.nodes[1], self.old_node)\n+        sync_blocks(self.nodes)\n+\n+        print(\"\\tTesting handling of incorrect blocktxn responses...\")\n+        self.test_incorrect_blocktxn_response(self.nodes[0], self.test_node, 1)\n+        sync_blocks(self.nodes)\n+        self.test_incorrect_blocktxn_response(self.nodes[1], self.segwit_node, 2)\n+        sync_blocks(self.nodes)\n+\n+        # End-to-end block relay tests\n+        print(\"\\tTesting end-to-end block relay...\")\n+        self.request_cb_announcements(self.test_node, self.nodes[0], 1)\n+        self.request_cb_announcements(self.old_node, self.nodes[1], 1)\n+        self.request_cb_announcements(self.segwit_node, self.nodes[1], 2)\n+        self.test_end_to_end_block_relay(self.nodes[0], [self.segwit_node, self.test_node, self.old_node])\n+        self.test_end_to_end_block_relay(self.nodes[1], [self.segwit_node, self.test_node, self.old_node])\n+\n+        # Advance to segwit activation\n+        print (\"\\nAdvancing to segwit activation\\n\")\n+        self.activate_segwit(self.nodes[1])\n+        print (\"Running tests, post-segwit activation...\")\n+\n+        print(\"\\tTesting compactblock construction...\")\n+        self.test_compactblock_construction(self.nodes[1], self.old_node, 1, True)\n+        self.test_compactblock_construction(self.nodes[1], self.segwit_node, 2, True)\n+        sync_blocks(self.nodes)\n+\n+        print(\"\\tTesting compactblock requests (unupgraded node)... \")\n+        self.test_compactblock_requests(self.nodes[0], self.test_node)\n+\n+        print(\"\\tTesting getblocktxn requests (unupgraded node)...\")\n+        self.test_getblocktxn_requests(self.nodes[0], self.test_node, 1)\n+\n+        # Need to manually sync node0 and node1, because post-segwit activation,\n+        # node1 will not download blocks from node0.\n+        print(\"\\tSyncing nodes...\")\n+        assert(self.nodes[0].getbestblockhash() != self.nodes[1].getbestblockhash())\n+        while (self.nodes[0].getblockcount() > self.nodes[1].getblockcount()):\n+            block_hash = self.nodes[0].getblockhash(self.nodes[1].getblockcount()+1)\n+            self.nodes[1].submitblock(self.nodes[0].getblock(block_hash, False))\n+        assert_equal(self.nodes[0].getbestblockhash(), self.nodes[1].getbestblockhash())\n+\n+        print(\"\\tTesting compactblock requests (segwit node)... \")\n+        self.test_compactblock_requests(self.nodes[1], self.segwit_node)\n+\n+        print(\"\\tTesting getblocktxn requests (segwit node)...\")\n+        self.test_getblocktxn_requests(self.nodes[1], self.segwit_node, 2)\n+        sync_blocks(self.nodes)\n+\n+        print(\"\\tTesting getblocktxn handler (segwit node should return witnesses)...\")\n+        self.test_getblocktxn_handler(self.nodes[1], self.segwit_node, 2)\n+        self.test_getblocktxn_handler(self.nodes[1], self.old_node, 1)\n+\n+        # Test that if we submitblock to node1, we'll get a compact block\n+        # announcement to all peers.\n+        # (Post-segwit activation, blocks won't propagate from node0 to node1\n+        # automatically, so don't bother testing a block announced to node0.)\n+        print(\"\\tTesting end-to-end block relay...\")\n+        self.request_cb_announcements(self.test_node, self.nodes[0], 1)\n+        self.request_cb_announcements(self.old_node, self.nodes[1], 1)\n+        self.request_cb_announcements(self.segwit_node, self.nodes[1], 2)\n+        self.test_end_to_end_block_relay(self.nodes[1], [self.segwit_node, self.test_node, self.old_node])\n+\n+        print(\"\\tTesting invalid index in cmpctblock message...\")\n         self.test_invalid_cmpctblock_message()\n \n "
      }
    ]
  },
  {
    "sha": "61e282b62d7d4f0bca435c6e1b836d3b2c3a0874",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2MWUyODJiNjJkN2Q0ZjBiY2E0MzVjNmUxYjgzNmQzYjJjM2EwODc0",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2016-09-15T01:00:29Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2016-10-13T18:09:31Z"
      },
      "message": "[qa] Add support for compactblocks v2 to mininode\n\nGithub-Pull: #8393\nRebased-From: 422fac649f75c907cad6ab7e2768b9032b9eae42",
      "tree": {
        "sha": "42f70d6e07afd0cb3aebec5019ac515546639e0b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/42f70d6e07afd0cb3aebec5019ac515546639e0b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/61e282b62d7d4f0bca435c6e1b836d3b2c3a0874",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/61e282b62d7d4f0bca435c6e1b836d3b2c3a0874",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/61e282b62d7d4f0bca435c6e1b836d3b2c3a0874",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/61e282b62d7d4f0bca435c6e1b836d3b2c3a0874/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e47299a8f2ebc98644bb8d15a3222faac51875fd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e47299a8f2ebc98644bb8d15a3222faac51875fd",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e47299a8f2ebc98644bb8d15a3222faac51875fd"
      }
    ],
    "stats": {
      "total": 35,
      "additions": 31,
      "deletions": 4
    },
    "files": [
      {
        "sha": "b7e47374890879ee138309d557acf8bef2139f6a",
        "filename": "qa/rpc-tests/test_framework/mininode.py",
        "status": "modified",
        "additions": 31,
        "deletions": 4,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/61e282b62d7d4f0bca435c6e1b836d3b2c3a0874/qa/rpc-tests/test_framework/mininode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/61e282b62d7d4f0bca435c6e1b836d3b2c3a0874/qa/rpc-tests/test_framework/mininode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/test_framework/mininode.py?ref=61e282b62d7d4f0bca435c6e1b836d3b2c3a0874",
        "patch": "@@ -755,6 +755,9 @@ def serialize(self, with_witness=False):\n             r += self.tx.serialize_without_witness()\n         return r\n \n+    def serialize_with_witness(self):\n+        return self.serialize(with_witness=True)\n+\n     def __repr__(self):\n         return \"PrefilledTransaction(index=%d, tx=%s)\" % (self.index, repr(self.tx))\n \n@@ -779,6 +782,7 @@ def deserialize(self, f):\n         self.prefilled_txn = deser_vector(f, PrefilledTransaction)\n         self.prefilled_txn_length = len(self.prefilled_txn)\n \n+    # When using version 2 compact blocks, we must serialize with_witness.\n     def serialize(self, with_witness=False):\n         r = b\"\"\n         r += self.header.serialize()\n@@ -787,12 +791,20 @@ def serialize(self, with_witness=False):\n         for x in self.shortids:\n             # We only want the first 6 bytes\n             r += struct.pack(\"<Q\", x)[0:6]\n-        r += ser_vector(self.prefilled_txn)\n+        if with_witness:\n+            r += ser_vector(self.prefilled_txn, \"serialize_with_witness\")\n+        else:\n+            r += ser_vector(self.prefilled_txn)\n         return r\n \n     def __repr__(self):\n         return \"P2PHeaderAndShortIDs(header=%s, nonce=%d, shortids_length=%d, shortids=%s, prefilled_txn_length=%d, prefilledtxn=%s\" % (repr(self.header), self.nonce, self.shortids_length, repr(self.shortids), self.prefilled_txn_length, repr(self.prefilled_txn))\n \n+# P2P version of the above that will use witness serialization (for compact\n+# block version 2)\n+class P2PHeaderAndShortWitnessIDs(P2PHeaderAndShortIDs):\n+    def serialize(self):\n+        return super(P2PHeaderAndShortWitnessIDs, self).serialize(with_witness=True)\n \n # Calculate the BIP 152-compact blocks shortid for a given transaction hash\n def calculate_shortid(k0, k1, tx_hash):\n@@ -808,6 +820,7 @@ def __init__(self, p2pheaders_and_shortids = None):\n         self.nonce = 0\n         self.shortids = []\n         self.prefilled_txn = []\n+        self.use_witness = False\n \n         if p2pheaders_and_shortids != None:\n             self.header = p2pheaders_and_shortids.header\n@@ -819,7 +832,10 @@ def __init__(self, p2pheaders_and_shortids = None):\n                 last_index = self.prefilled_txn[-1].index\n \n     def to_p2p(self):\n-        ret = P2PHeaderAndShortIDs()\n+        if self.use_witness:\n+            ret = P2PHeaderAndShortWitnessIDs()\n+        else:\n+            ret = P2PHeaderAndShortIDs()\n         ret.header = self.header\n         ret.nonce = self.nonce\n         ret.shortids_length = len(self.shortids)\n@@ -840,15 +856,20 @@ def get_siphash_keys(self):\n         key1 = struct.unpack(\"<Q\", hash_header_nonce_as_str[8:16])[0]\n         return [ key0, key1 ]\n \n-    def initialize_from_block(self, block, nonce=0, prefill_list = [0]):\n+    # Version 2 compact blocks use wtxid in shortids (rather than txid)\n+    def initialize_from_block(self, block, nonce=0, prefill_list = [0], use_witness = False):\n         self.header = CBlockHeader(block)\n         self.nonce = nonce\n         self.prefilled_txn = [ PrefilledTransaction(i, block.vtx[i]) for i in prefill_list ]\n         self.shortids = []\n+        self.use_witness = use_witness\n         [k0, k1] = self.get_siphash_keys()\n         for i in range(len(block.vtx)):\n             if i not in prefill_list:\n-                self.shortids.append(calculate_shortid(k0, k1, block.vtx[i].sha256))\n+                tx_hash = block.vtx[i].sha256\n+                if use_witness:\n+                    tx_hash = block.vtx[i].calc_sha256(with_witness=True)\n+                self.shortids.append(calculate_shortid(k0, k1, tx_hash))\n \n     def __repr__(self):\n         return \"HeaderAndShortIDs(header=%s, nonce=%d, shortids=%s, prefilledtxn=%s\" % (repr(self.header), self.nonce, repr(self.shortids), repr(self.prefilled_txn))\n@@ -1424,6 +1445,12 @@ def serialize(self):\n     def __repr__(self):\n         return \"msg_blocktxn(block_transactions=%s)\" % (repr(self.block_transactions))\n \n+class msg_witness_blocktxn(msg_blocktxn):\n+    def serialize(self):\n+        r = b\"\"\n+        r += self.block_transactions.serialize(with_witness=True)\n+        return r\n+\n # This is what a callback should look like for NodeConn\n # Reimplement the on_* functions to provide handling for events\n class NodeConnCB(object):"
      }
    ]
  },
  {
    "sha": "611cc5096e5777502e18ba516d7a0eec93ac9c63",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2MTFjYzUwOTZlNTc3NzUwMmUxOGJhNTE2ZDdhMGVlYzkzYWM5YzYz",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2016-09-18T02:11:00Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2016-10-13T18:09:31Z"
      },
      "message": "[qa] Fix bug in mininode witness deserialization\n\nAlso improve tx printing\n\nGithub-Pull: #8393\nRebased-From: f5b9b8f437c040205896ad0d7a6656efa08b5601",
      "tree": {
        "sha": "c08f496aa6e9c9a41fa524f8f47b9fbc4e61eede",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c08f496aa6e9c9a41fa524f8f47b9fbc4e61eede"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/611cc5096e5777502e18ba516d7a0eec93ac9c63",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/611cc5096e5777502e18ba516d7a0eec93ac9c63",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/611cc5096e5777502e18ba516d7a0eec93ac9c63",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/611cc5096e5777502e18ba516d7a0eec93ac9c63/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "61e282b62d7d4f0bca435c6e1b836d3b2c3a0874",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/61e282b62d7d4f0bca435c6e1b836d3b2c3a0874",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/61e282b62d7d4f0bca435c6e1b836d3b2c3a0874"
      }
    ],
    "stats": {
      "total": 6,
      "additions": 3,
      "deletions": 3
    },
    "files": [
      {
        "sha": "4d238c08d9c3fcd270725105bd8eabff2a28fadc",
        "filename": "qa/rpc-tests/test_framework/mininode.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/611cc5096e5777502e18ba516d7a0eec93ac9c63/qa/rpc-tests/test_framework/mininode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/611cc5096e5777502e18ba516d7a0eec93ac9c63/qa/rpc-tests/test_framework/mininode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/test_framework/mininode.py?ref=611cc5096e5777502e18ba516d7a0eec93ac9c63",
        "patch": "@@ -452,7 +452,7 @@ def deserialize(self, f):\n         else:\n             self.vout = deser_vector(f, CTxOut)\n         if flags != 0:\n-            self.wit.vtxinwit = [CTxInWitness()]*len(self.vin)\n+            self.wit.vtxinwit = [CTxInWitness() for i in range(len(self.vin))]\n             self.wit.deserialize(f)\n         self.nLockTime = struct.unpack(\"<I\", f.read(4))[0]\n         self.sha256 = None\n@@ -518,8 +518,8 @@ def is_valid(self):\n         return True\n \n     def __repr__(self):\n-        return \"CTransaction(nVersion=%i vin=%s vout=%s nLockTime=%i)\" \\\n-            % (self.nVersion, repr(self.vin), repr(self.vout), self.nLockTime)\n+        return \"CTransaction(nVersion=%i vin=%s vout=%s wit=%s nLockTime=%i)\" \\\n+            % (self.nVersion, repr(self.vin), repr(self.vout), repr(self.wit), self.nLockTime)\n \n \n class CBlockHeader(object):"
      }
    ]
  },
  {
    "sha": "fe1975a9740f30f1a1152276d7f93f3ca9fa611d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmZTE5NzVhOTc0MGYzMGYxYTExNTIyNzZkN2Y5M2YzY2E5ZmE2MTFk",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-06-25T17:17:45Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2016-10-13T18:15:17Z"
      },
      "message": "Use cmpctblock type 2 for segwit-enabled transfer\n\nContains version negotiation logic by Matt Corallo and bugfixes by\nSuhas Daftuar.\n\nGithub-Pull: #8393\nRebased-From: 6aa28abf53ef4694692474b4a3b0a8fa7559b50b",
      "tree": {
        "sha": "55c8fcc221f4451c6fc228586de61661074195cd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/55c8fcc221f4451c6fc228586de61661074195cd"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fe1975a9740f30f1a1152276d7f93f3ca9fa611d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fe1975a9740f30f1a1152276d7f93f3ca9fa611d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fe1975a9740f30f1a1152276d7f93f3ca9fa611d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fe1975a9740f30f1a1152276d7f93f3ca9fa611d/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "611cc5096e5777502e18ba516d7a0eec93ac9c63",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/611cc5096e5777502e18ba516d7a0eec93ac9c63",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/611cc5096e5777502e18ba516d7a0eec93ac9c63"
      }
    ],
    "stats": {
      "total": 94,
      "additions": 64,
      "deletions": 30
    },
    "files": [
      {
        "sha": "93d3fa372b3c074b87400cfd43cb63c0cc7a52d2",
        "filename": "src/blockencodings.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fe1975a9740f30f1a1152276d7f93f3ca9fa611d/src/blockencodings.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fe1975a9740f30f1a1152276d7f93f3ca9fa611d/src/blockencodings.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/blockencodings.cpp?ref=fe1975a9740f30f1a1152276d7f93f3ca9fa611d",
        "patch": "@@ -17,15 +17,15 @@\n \n #define MIN_TRANSACTION_BASE_SIZE (::GetSerializeSize(CTransaction(), SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS))\n \n-CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs(const CBlock& block) :\n+CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs(const CBlock& block, bool fUseWTXID) :\n         nonce(GetRand(std::numeric_limits<uint64_t>::max())),\n         shorttxids(block.vtx.size() - 1), prefilledtxn(1), header(block) {\n     FillShortTxIDSelector();\n     //TODO: Use our mempool prior to block acceptance to predictively fill more than just the coinbase\n     prefilledtxn[0] = {0, block.vtx[0]};\n     for (size_t i = 1; i < block.vtx.size(); i++) {\n         const CTransaction& tx = block.vtx[i];\n-        shorttxids[i - 1] = GetShortID(tx.GetHash());\n+        shorttxids[i - 1] = GetShortID(fUseWTXID ? tx.GetWitnessHash() : tx.GetHash());\n     }\n }\n "
      },
      {
        "sha": "2f87c6d31dedc674a8e4f1235d1630f9daad56f4",
        "filename": "src/blockencodings.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fe1975a9740f30f1a1152276d7f93f3ca9fa611d/src/blockencodings.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fe1975a9740f30f1a1152276d7f93f3ca9fa611d/src/blockencodings.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/blockencodings.h?ref=fe1975a9740f30f1a1152276d7f93f3ca9fa611d",
        "patch": "@@ -146,7 +146,7 @@ class CBlockHeaderAndShortTxIDs {\n     // Dummy for deserialization\n     CBlockHeaderAndShortTxIDs() {}\n \n-    CBlockHeaderAndShortTxIDs(const CBlock& block);\n+    CBlockHeaderAndShortTxIDs(const CBlock& block, bool fUseWTXID);\n \n     uint64_t GetShortID(const uint256& txhash) const;\n "
      },
      {
        "sha": "ea7c7fd95e441eba5a019fb92f602f7cefe6ab32",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 56,
        "deletions": 22,
        "changes": 78,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fe1975a9740f30f1a1152276d7f93f3ca9fa611d/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fe1975a9740f30f1a1152276d7f93f3ca9fa611d/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=fe1975a9740f30f1a1152276d7f93f3ca9fa611d",
        "patch": "@@ -292,10 +292,21 @@ struct CNodeState {\n     bool fPreferHeaders;\n     //! Whether this peer wants invs or cmpctblocks (when possible) for block announcements.\n     bool fPreferHeaderAndIDs;\n-    //! Whether this peer will send us cmpctblocks if we request them\n+    /**\n+      * Whether this peer will send us cmpctblocks if we request them.\n+      * This is not used to gate request logic, as we really only care about fSupportsDesiredCmpctVersion,\n+      * but is used as a flag to \"lock in\" the version of compact blocks (fWantsCmpctWitness) we send.\n+      */\n     bool fProvidesHeaderAndIDs;\n     //! Whether this peer can give us witnesses\n     bool fHaveWitness;\n+    //! Whether this peer wants witnesses in cmpctblocks/blocktxns\n+    bool fWantsCmpctWitness;\n+    /**\n+     * If we've announced NODE_WITNESS to this peer: whether the peer sends witnesses in cmpctblocks/blocktxns,\n+     * otherwise: whether this peer sends non-witnesses in cmpctblocks/blocktxns.\n+     */\n+    bool fSupportsDesiredCmpctVersion;\n \n     CNodeState() {\n         fCurrentlyConnected = false;\n@@ -316,6 +327,8 @@ struct CNodeState {\n         fPreferHeaderAndIDs = false;\n         fProvidesHeaderAndIDs = false;\n         fHaveWitness = false;\n+        fWantsCmpctWitness = false;\n+        fSupportsDesiredCmpctVersion = false;\n     }\n };\n \n@@ -475,16 +488,16 @@ void UpdateBlockAvailability(NodeId nodeid, const uint256 &hash) {\n }\n \n void MaybeSetPeerAsAnnouncingHeaderAndIDs(const CNodeState* nodestate, CNode* pfrom) {\n-    if (nLocalServices & NODE_WITNESS) {\n-        // Don't ever request compact blocks when segwit is enabled.\n+    if (!nodestate->fSupportsDesiredCmpctVersion) {\n+        // Never ask from peers who can't provide witnesses.\n         return;\n     }\n     if (nodestate->fProvidesHeaderAndIDs) {\n         BOOST_FOREACH(const NodeId nodeid, lNodesAnnouncingHeaderAndIDs)\n             if (nodeid == pfrom->GetId())\n                 return;\n         bool fAnnounceUsingCMPCTBLOCK = false;\n-        uint64_t nCMPCTBLOCKVersion = 1;\n+        uint64_t nCMPCTBLOCKVersion = (pfrom->GetLocalServices() & NODE_WITNESS) ? 2 : 1;\n         if (lNodesAnnouncingHeaderAndIDs.size() >= 3) {\n             // As per BIP152, we only get 3 of our peers to announce\n             // blocks using compact encodings.\n@@ -4832,11 +4845,12 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n                         // they wont have a useful mempool to match against a compact block,\n                         // and we don't feel like constructing the object for them, so\n                         // instead we respond with the full, non-compact block.\n+                        bool fPeerWantsWitness = State(pfrom->GetId())->fWantsCmpctWitness;\n                         if (mi->second->nHeight >= chainActive.Height() - 10) {\n-                            CBlockHeaderAndShortTxIDs cmpctblock(block);\n-                            pfrom->PushMessageWithFlag(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::CMPCTBLOCK, cmpctblock);\n+                            CBlockHeaderAndShortTxIDs cmpctblock(block, fPeerWantsWitness);\n+                            pfrom->PushMessageWithFlag(fPeerWantsWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::CMPCTBLOCK, cmpctblock);\n                         } else\n-                            pfrom->PushMessageWithFlag(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::BLOCK, block);\n+                            pfrom->PushMessageWithFlag(fPeerWantsWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::BLOCK, block);\n                     }\n \n                     // Trigger the peer node to send a getblocks request for the next batch of inventory\n@@ -5102,13 +5116,16 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             pfrom->PushMessage(NetMsgType::SENDHEADERS);\n         }\n         if (pfrom->nVersion >= SHORT_IDS_BLOCKS_VERSION) {\n-            // Tell our peer we are willing to provide version-1 cmpctblocks\n+            // Tell our peer we are willing to provide version 1 or 2 cmpctblocks\n             // However, we do not request new block announcements using\n             // cmpctblock messages.\n             // We send this to non-NODE NETWORK peers as well, because\n             // they may wish to request compact blocks from us\n             bool fAnnounceUsingCMPCTBLOCK = false;\n-            uint64_t nCMPCTBLOCKVersion = 1;\n+            uint64_t nCMPCTBLOCKVersion = 2;\n+            if (pfrom->GetLocalServices() & NODE_WITNESS)\n+                pfrom->PushMessage(NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion);\n+            nCMPCTBLOCKVersion = 1;\n             pfrom->PushMessage(NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion);\n         }\n     }\n@@ -5188,12 +5205,23 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n     else if (strCommand == NetMsgType::SENDCMPCT)\n     {\n         bool fAnnounceUsingCMPCTBLOCK = false;\n-        uint64_t nCMPCTBLOCKVersion = 1;\n+        uint64_t nCMPCTBLOCKVersion = 0;\n         vRecv >> fAnnounceUsingCMPCTBLOCK >> nCMPCTBLOCKVersion;\n-        if (nCMPCTBLOCKVersion == 1) {\n+        if (nCMPCTBLOCKVersion == 1 || ((pfrom->GetLocalServices() & NODE_WITNESS) && nCMPCTBLOCKVersion == 2)) {\n             LOCK(cs_main);\n-            State(pfrom->GetId())->fProvidesHeaderAndIDs = true;\n-            State(pfrom->GetId())->fPreferHeaderAndIDs = fAnnounceUsingCMPCTBLOCK;\n+            // fProvidesHeaderAndIDs is used to \"lock in\" version of compact blocks we send (fWantsCmpctWitness)\n+            if (!State(pfrom->GetId())->fProvidesHeaderAndIDs) {\n+                State(pfrom->GetId())->fProvidesHeaderAndIDs = true;\n+                State(pfrom->GetId())->fWantsCmpctWitness = nCMPCTBLOCKVersion == 2;\n+            }\n+            if (State(pfrom->GetId())->fWantsCmpctWitness == (nCMPCTBLOCKVersion == 2)) // ignore later version announces\n+                State(pfrom->GetId())->fPreferHeaderAndIDs = fAnnounceUsingCMPCTBLOCK;\n+            if (!State(pfrom->GetId())->fSupportsDesiredCmpctVersion) {\n+                if (pfrom->GetLocalServices() & NODE_WITNESS)\n+                    State(pfrom->GetId())->fSupportsDesiredCmpctVersion = (nCMPCTBLOCKVersion == 2);\n+                else\n+                    State(pfrom->GetId())->fSupportsDesiredCmpctVersion = (nCMPCTBLOCKVersion == 1);\n+            }\n         }\n     }\n \n@@ -5251,7 +5279,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                         nodestate->nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER &&\n                         (!IsWitnessEnabled(chainActive.Tip(), chainparams.GetConsensus()) || State(pfrom->GetId())->fHaveWitness)) {\n                         inv.type |= nFetchFlags;\n-                        if (nodestate->fProvidesHeaderAndIDs && !(nLocalServices & NODE_WITNESS))\n+                        if (nodestate->fSupportsDesiredCmpctVersion)\n                             vToFetch.push_back(CInv(MSG_CMPCT_BLOCK, inv.hash));\n                         else\n                             vToFetch.push_back(inv);\n@@ -5379,7 +5407,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             }\n             resp.txn[i] = block.vtx[req.indexes[i]];\n         }\n-        pfrom->PushMessageWithFlag(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::BLOCKTXN, resp);\n+        pfrom->PushMessageWithFlag(State(pfrom->GetId())->fWantsCmpctWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::BLOCKTXN, resp);\n     }\n \n \n@@ -5643,7 +5671,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                 // We requested this block for some reason, but our mempool will probably be useless\n                 // so we just grab the block via normal getdata\n                 std::vector<CInv> vInv(1);\n-                vInv[0] = CInv(MSG_BLOCK, cmpctblock.header.GetHash());\n+                vInv[0] = CInv(MSG_BLOCK | GetFetchFlags(pfrom, pindex->pprev, chainparams.GetConsensus()), cmpctblock.header.GetHash());\n                 pfrom->PushMessage(NetMsgType::GETDATA, vInv);\n             }\n             return true;\n@@ -5655,6 +5683,12 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n \n         CNodeState *nodestate = State(pfrom->GetId());\n \n+        if (IsWitnessEnabled(pindex->pprev, chainparams.GetConsensus()) && !nodestate->fSupportsDesiredCmpctVersion) {\n+            // Don't bother trying to process compact blocks from v1 peers\n+            // after segwit activates.\n+            return true;\n+        }\n+\n         // We want to be a bit conservative just to be extra careful about DoS\n         // possibilities in compact block processing...\n         if (pindex->nHeight <= chainActive.Height() + 2) {\n@@ -5681,7 +5715,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                 } else if (status == READ_STATUS_FAILED) {\n                     // Duplicate txindexes, the block is now in-flight, so just request it\n                     std::vector<CInv> vInv(1);\n-                    vInv[0] = CInv(MSG_BLOCK, cmpctblock.header.GetHash());\n+                    vInv[0] = CInv(MSG_BLOCK | GetFetchFlags(pfrom, pindex->pprev, chainparams.GetConsensus()), cmpctblock.header.GetHash());\n                     pfrom->PushMessage(NetMsgType::GETDATA, vInv);\n                     return true;\n                 }\n@@ -5708,7 +5742,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                 // We requested this block, but its far into the future, so our\n                 // mempool will probably be useless - request the block normally\n                 std::vector<CInv> vInv(1);\n-                vInv[0] = CInv(MSG_BLOCK, cmpctblock.header.GetHash());\n+                vInv[0] = CInv(MSG_BLOCK | GetFetchFlags(pfrom, pindex->pprev, chainparams.GetConsensus()), cmpctblock.header.GetHash());\n                 pfrom->PushMessage(NetMsgType::GETDATA, vInv);\n                 return true;\n             } else {\n@@ -5750,7 +5784,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         } else if (status == READ_STATUS_FAILED) {\n             // Might have collided, fall back to getdata now :(\n             std::vector<CInv> invs;\n-            invs.push_back(CInv(MSG_BLOCK, resp.blockhash));\n+            invs.push_back(CInv(MSG_BLOCK | GetFetchFlags(pfrom, chainActive.Tip(), chainparams.GetConsensus()), resp.blockhash));\n             pfrom->PushMessage(NetMsgType::GETDATA, invs);\n         } else {\n             CValidationState state;\n@@ -5899,7 +5933,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                             pindexLast->GetBlockHash().ToString(), pindexLast->nHeight);\n                 }\n                 if (vGetData.size() > 0) {\n-                    if (nodestate->fProvidesHeaderAndIDs && vGetData.size() == 1 && mapBlocksInFlight.size() == 1 && pindexLast->pprev->IsValid(BLOCK_VALID_CHAIN) && !(nLocalServices & NODE_WITNESS)) {\n+                    if (nodestate->fSupportsDesiredCmpctVersion && vGetData.size() == 1 && mapBlocksInFlight.size() == 1 && pindexLast->pprev->IsValid(BLOCK_VALID_CHAIN)) {\n                         // We seem to be rather well-synced, so it appears pfrom was the first to provide us\n                         // with this block! Let's get them to announce using compact blocks in the future.\n                         MaybeSetPeerAsAnnouncingHeaderAndIDs(nodestate, pfrom);\n@@ -6527,8 +6561,8 @@ bool SendMessages(CNode* pto)\n                     //TODO: Shouldn't need to reload block from disk, but requires refactor\n                     CBlock block;\n                     assert(ReadBlockFromDisk(block, pBestIndex, consensusParams));\n-                    CBlockHeaderAndShortTxIDs cmpctblock(block);\n-                    pto->PushMessageWithFlag(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::CMPCTBLOCK, cmpctblock);\n+                    CBlockHeaderAndShortTxIDs cmpctblock(block, state.fWantsCmpctWitness);\n+                    pto->PushMessageWithFlag(state.fWantsCmpctWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::CMPCTBLOCK, cmpctblock);\n                     state.pindexBestHeaderSent = pBestIndex;\n                 } else if (state.fPreferHeaders) {\n                     if (vHeaders.size() > 1) {"
      },
      {
        "sha": "153a41ba74c1f8a2999289a209eac828078a7138",
        "filename": "src/test/blockencodings_tests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fe1975a9740f30f1a1152276d7f93f3ca9fa611d/src/test/blockencodings_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fe1975a9740f30f1a1152276d7f93f3ca9fa611d/src/test/blockencodings_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/blockencodings_tests.cpp?ref=fe1975a9740f30f1a1152276d7f93f3ca9fa611d",
        "patch": "@@ -64,7 +64,7 @@ BOOST_AUTO_TEST_CASE(SimpleRoundTripTest)\n \n     // Do a simple ShortTxIDs RT\n     {\n-        CBlockHeaderAndShortTxIDs shortIDs(block);\n+        CBlockHeaderAndShortTxIDs shortIDs(block, true);\n \n         CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n         stream << shortIDs;\n@@ -116,7 +116,7 @@ class TestHeaderAndShortIDs {\n         stream >> *this;\n     }\n     TestHeaderAndShortIDs(const CBlock& block) :\n-        TestHeaderAndShortIDs(CBlockHeaderAndShortTxIDs(block)) {}\n+        TestHeaderAndShortIDs(CBlockHeaderAndShortTxIDs(block, true)) {}\n \n     uint64_t GetShortID(const uint256& txhash) const {\n         CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n@@ -267,7 +267,7 @@ BOOST_AUTO_TEST_CASE(EmptyBlockRoundTripTest)\n \n     // Test simple header round-trip with only coinbase\n     {\n-        CBlockHeaderAndShortTxIDs shortIDs(block);\n+        CBlockHeaderAndShortTxIDs shortIDs(block, false);\n \n         CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n         stream << shortIDs;"
      },
      {
        "sha": "59afb2cf5ab22d046216e21e68a2b0f7d35bd1d1",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fe1975a9740f30f1a1152276d7f93f3ca9fa611d/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fe1975a9740f30f1a1152276d7f93f3ca9fa611d/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=fe1975a9740f30f1a1152276d7f93f3ca9fa611d",
        "patch": "@@ -444,7 +444,7 @@ bool CTxMemPool::addUnchecked(const uint256& hash, const CTxMemPoolEntry &entry,\n     totalTxSize += entry.GetTxSize();\n     minerPolicyEstimator->processTransaction(entry, fCurrentEstimate);\n \n-    vTxHashes.emplace_back(hash, newit);\n+    vTxHashes.emplace_back(tx.GetWitnessHash(), newit);\n     newit->vTxHashesIdx = vTxHashes.size() - 1;\n \n     return true;"
      },
      {
        "sha": "afb328b5af36262e6c4d66038cdeac86109ce9b0",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fe1975a9740f30f1a1152276d7f93f3ca9fa611d/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fe1975a9740f30f1a1152276d7f93f3ca9fa611d/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=fe1975a9740f30f1a1152276d7f93f3ca9fa611d",
        "patch": "@@ -462,7 +462,7 @@ class CTxMemPool\n     indexed_transaction_set mapTx;\n \n     typedef indexed_transaction_set::nth_index<0>::type::iterator txiter;\n-    std::vector<std::pair<uint256, txiter> > vTxHashes; //!< All tx hashes/entries in mapTx, in random order\n+    std::vector<std::pair<uint256, txiter> > vTxHashes; //!< All tx witness hashes/entries in mapTx, in random order\n \n     struct CompareIteratorByHash {\n         bool operator()(const txiter &a, const txiter &b) const {"
      }
    ]
  },
  {
    "sha": "890ac2563872f9b71b9863ad531c639e526df5d7",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4OTBhYzI1NjM4NzJmOWI3MWI5ODYzYWQ1MzFjNjM5ZTUyNmRmNWQ3",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2016-10-03T17:33:07Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2016-10-13T18:15:17Z"
      },
      "message": "Fix overly-prescriptive p2p-segwit test for new fetch logic\n\nGithub-Pull: #8393\nRebased-From: be7555f0c03057bb5537cc42ca9d4937389f0670",
      "tree": {
        "sha": "10426b637a4417bd62777b4df6ffbd48924cfb45",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/10426b637a4417bd62777b4df6ffbd48924cfb45"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/890ac2563872f9b71b9863ad531c639e526df5d7",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/890ac2563872f9b71b9863ad531c639e526df5d7",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/890ac2563872f9b71b9863ad531c639e526df5d7",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/890ac2563872f9b71b9863ad531c639e526df5d7/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fe1975a9740f30f1a1152276d7f93f3ca9fa611d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fe1975a9740f30f1a1152276d7f93f3ca9fa611d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fe1975a9740f30f1a1152276d7f93f3ca9fa611d"
      }
    ],
    "stats": {
      "total": 10,
      "additions": 1,
      "deletions": 9
    },
    "files": [
      {
        "sha": "69bab3876778dd467b5d9b5461a416e7ebb26f2d",
        "filename": "qa/rpc-tests/p2p-segwit.py",
        "status": "modified",
        "additions": 1,
        "deletions": 9,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/890ac2563872f9b71b9863ad531c639e526df5d7/qa/rpc-tests/p2p-segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/890ac2563872f9b71b9863ad531c639e526df5d7/qa/rpc-tests/p2p-segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/p2p-segwit.py?ref=890ac2563872f9b71b9863ad531c639e526df5d7",
        "patch": "@@ -909,14 +909,6 @@ def test_witness_tx_relay_before_segwit_activation(self):\n         # But eliminating the witness should fix it\n         self.test_node.test_transaction_acceptance(tx, with_witness=False, accepted=True)\n \n-        # Verify that inv's to test_node come with getdata's for non-witness tx's\n-        # Just tweak the transaction, announce it, and verify we get a getdata\n-        # for a normal tx\n-        tx.vout[0].scriptPubKey = CScript([OP_TRUE, OP_TRUE])\n-        tx.rehash()\n-        self.test_node.announce_tx_and_wait_for_getdata(tx)\n-        assert(self.test_node.last_getdata.inv[0].type == 1)\n-\n         # Cleanup: mine the first transaction and update utxo\n         self.nodes[0].generate(1)\n         assert_equal(len(self.nodes[0].getrawmempool()),  0)\n@@ -1022,7 +1014,7 @@ def test_tx_relay_after_segwit_activation(self):\n     def test_block_relay(self, segwit_activated):\n         print(\"\\tTesting block relay\")\n \n-        blocktype = 2|MSG_WITNESS_FLAG if segwit_activated else 2\n+        blocktype = 2|MSG_WITNESS_FLAG\n \n         # test_node has set NODE_WITNESS, so all getdata requests should be for\n         # witness blocks."
      }
    ]
  },
  {
    "sha": "4bb9ce8a958f5a55d6a72330728b7fc3b5c820c0",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0YmI5Y2U4YTk1OGY1YTU1ZDZhNzIzMzA3MjhiN2ZjM2I1YzgyMGMw",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2016-10-03T17:00:14Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2016-10-13T18:35:33Z"
      },
      "message": "Use cmpctblock type 2 for segwit-enabled transfer\n\nContains version negotiation logic by Matt Corallo and bugfixes by\nSuhas Daftuar.\n\nGithub-Pull: #8393\nRebased-From: 6aa28abf53ef4694692474b4a3b0a8fa7559b50b",
      "tree": {
        "sha": "33a202125247bd5b1cf93549a418d24cc1f2e86f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/33a202125247bd5b1cf93549a418d24cc1f2e86f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4bb9ce8a958f5a55d6a72330728b7fc3b5c820c0",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4bb9ce8a958f5a55d6a72330728b7fc3b5c820c0",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4bb9ce8a958f5a55d6a72330728b7fc3b5c820c0",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4bb9ce8a958f5a55d6a72330728b7fc3b5c820c0/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "890ac2563872f9b71b9863ad531c639e526df5d7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/890ac2563872f9b71b9863ad531c639e526df5d7",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/890ac2563872f9b71b9863ad531c639e526df5d7"
      }
    ],
    "stats": {
      "total": 10,
      "additions": 5,
      "deletions": 5
    },
    "files": [
      {
        "sha": "7fd13f4ecf9c75bfcc0295e67f0ca15be226d392",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4bb9ce8a958f5a55d6a72330728b7fc3b5c820c0/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4bb9ce8a958f5a55d6a72330728b7fc3b5c820c0/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=4bb9ce8a958f5a55d6a72330728b7fc3b5c820c0",
        "patch": "@@ -497,7 +497,7 @@ void MaybeSetPeerAsAnnouncingHeaderAndIDs(const CNodeState* nodestate, CNode* pf\n             if (nodeid == pfrom->GetId())\n                 return;\n         bool fAnnounceUsingCMPCTBLOCK = false;\n-        uint64_t nCMPCTBLOCKVersion = (pfrom->GetLocalServices() & NODE_WITNESS) ? 2 : 1;\n+        uint64_t nCMPCTBLOCKVersion = (nLocalServices & NODE_WITNESS) ? 2 : 1;\n         if (lNodesAnnouncingHeaderAndIDs.size() >= 3) {\n             // As per BIP152, we only get 3 of our peers to announce\n             // blocks using compact encodings.\n@@ -4912,7 +4912,7 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n \n uint32_t GetFetchFlags(CNode* pfrom, CBlockIndex* pprev, const Consensus::Params& chainparams) {\n     uint32_t nFetchFlags = 0;\n-    if (IsWitnessEnabled(pprev, chainparams) && State(pfrom->GetId())->fHaveWitness) {\n+    if ((nLocalServices & NODE_WITNESS) && State(pfrom->GetId())->fHaveWitness) {\n         nFetchFlags |= MSG_WITNESS_FLAG;\n     }\n     return nFetchFlags;\n@@ -5123,7 +5123,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             // they may wish to request compact blocks from us\n             bool fAnnounceUsingCMPCTBLOCK = false;\n             uint64_t nCMPCTBLOCKVersion = 2;\n-            if (pfrom->GetLocalServices() & NODE_WITNESS)\n+            if (nLocalServices & NODE_WITNESS)\n                 pfrom->PushMessage(NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion);\n             nCMPCTBLOCKVersion = 1;\n             pfrom->PushMessage(NetMsgType::SENDCMPCT, fAnnounceUsingCMPCTBLOCK, nCMPCTBLOCKVersion);\n@@ -5207,7 +5207,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         bool fAnnounceUsingCMPCTBLOCK = false;\n         uint64_t nCMPCTBLOCKVersion = 0;\n         vRecv >> fAnnounceUsingCMPCTBLOCK >> nCMPCTBLOCKVersion;\n-        if (nCMPCTBLOCKVersion == 1 || ((pfrom->GetLocalServices() & NODE_WITNESS) && nCMPCTBLOCKVersion == 2)) {\n+        if (nCMPCTBLOCKVersion == 1 || ((nLocalServices & NODE_WITNESS) && nCMPCTBLOCKVersion == 2)) {\n             LOCK(cs_main);\n             // fProvidesHeaderAndIDs is used to \"lock in\" version of compact blocks we send (fWantsCmpctWitness)\n             if (!State(pfrom->GetId())->fProvidesHeaderAndIDs) {\n@@ -5217,7 +5217,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             if (State(pfrom->GetId())->fWantsCmpctWitness == (nCMPCTBLOCKVersion == 2)) // ignore later version announces\n                 State(pfrom->GetId())->fPreferHeaderAndIDs = fAnnounceUsingCMPCTBLOCK;\n             if (!State(pfrom->GetId())->fSupportsDesiredCmpctVersion) {\n-                if (pfrom->GetLocalServices() & NODE_WITNESS)\n+                if (nLocalServices & NODE_WITNESS)\n                     State(pfrom->GetId())->fSupportsDesiredCmpctVersion = (nCMPCTBLOCKVersion == 2);\n                 else\n                     State(pfrom->GetId())->fSupportsDesiredCmpctVersion = (nCMPCTBLOCKVersion == 1);"
      }
    ]
  },
  {
    "sha": "cc6f55191a75dafa669fc6ee93ed86d860eb0d4a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjYzZmNTUxOTFhNzVkYWZhNjY5ZmM2ZWU5M2VkODZkODYwZWIwZDRh",
    "commit": {
      "author": {
        "name": "Dagur Valberg Johannsson",
        "email": "dagurval@pvv.ntnu.no",
        "date": "2016-10-09T19:47:55Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2016-10-13T18:35:33Z"
      },
      "message": "[qa] Fix compact block shortids for a test case\n\nGithub-Pull: #8904\nRebased-From: 4cdece40419bcc97345357f9268e03b0aff400b5",
      "tree": {
        "sha": "b61b4bf592678dd95593f37844e97149a59468b4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b61b4bf592678dd95593f37844e97149a59468b4"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/cc6f55191a75dafa669fc6ee93ed86d860eb0d4a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cc6f55191a75dafa669fc6ee93ed86d860eb0d4a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/cc6f55191a75dafa669fc6ee93ed86d860eb0d4a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cc6f55191a75dafa669fc6ee93ed86d860eb0d4a/comments",
    "author": {
      "login": "dagurval",
      "id": 92707,
      "node_id": "MDQ6VXNlcjkyNzA3",
      "avatar_url": "https://avatars.githubusercontent.com/u/92707?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dagurval",
      "html_url": "https://github.com/dagurval",
      "followers_url": "https://api.github.com/users/dagurval/followers",
      "following_url": "https://api.github.com/users/dagurval/following{/other_user}",
      "gists_url": "https://api.github.com/users/dagurval/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dagurval/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dagurval/subscriptions",
      "organizations_url": "https://api.github.com/users/dagurval/orgs",
      "repos_url": "https://api.github.com/users/dagurval/repos",
      "events_url": "https://api.github.com/users/dagurval/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dagurval/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4bb9ce8a958f5a55d6a72330728b7fc3b5c820c0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4bb9ce8a958f5a55d6a72330728b7fc3b5c820c0",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4bb9ce8a958f5a55d6a72330728b7fc3b5c820c0"
      }
    ],
    "stats": {
      "total": 4,
      "additions": 3,
      "deletions": 1
    },
    "files": [
      {
        "sha": "e7f5a1c9c6f816be487954743b5207657c7a827e",
        "filename": "qa/rpc-tests/p2p-compactblocks.py",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cc6f55191a75dafa669fc6ee93ed86d860eb0d4a/qa/rpc-tests/p2p-compactblocks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cc6f55191a75dafa669fc6ee93ed86d860eb0d4a/qa/rpc-tests/p2p-compactblocks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/p2p-compactblocks.py?ref=cc6f55191a75dafa669fc6ee93ed86d860eb0d4a",
        "patch": "@@ -402,7 +402,9 @@ def test_compactblock_requests(self, node, test_node):\n             comp_block = HeaderAndShortIDs()\n             comp_block.header = CBlockHeader(block)\n             comp_block.nonce = 0\n-            comp_block.shortids = [1]  # this is useless, and wrong\n+            [k0, k1] = comp_block.get_siphash_keys()\n+            comp_block.shortids = [\n+                    calculate_shortid(k0, k1, block.vtx[0].sha256) ]\n             test_node.send_and_ping(msg_cmpctblock(comp_block.to_p2p()))\n             assert_equal(int(node.getbestblockhash(), 16), block.hashPrevBlock)\n             # Expect a getblocktxn message."
      }
    ]
  },
  {
    "sha": "bcf3806f4cb9dad1424c78f458b5398a927161e8",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiY2YzODA2ZjRjYjlkYWQxNDI0Yzc4ZjQ1OGI1Mzk4YTkyNzE2MWU4",
    "commit": {
      "author": {
        "name": "jonnynewbs",
        "email": "jonnynewbs@gmail.com",
        "date": "2016-09-21T14:52:53Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2016-10-13T18:35:33Z"
      },
      "message": "Update bitcoin-tx to output witness data.\n\nGithub-Pull: #8817\nRebased-From: 4408558843c6c2b7abeb4160f641dfdbf5be5eb4",
      "tree": {
        "sha": "8fc2a9afff27863b8d1d344363563dd13517e2ec",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8fc2a9afff27863b8d1d344363563dd13517e2ec"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/bcf3806f4cb9dad1424c78f458b5398a927161e8",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bcf3806f4cb9dad1424c78f458b5398a927161e8",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/bcf3806f4cb9dad1424c78f458b5398a927161e8",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bcf3806f4cb9dad1424c78f458b5398a927161e8/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "cc6f55191a75dafa669fc6ee93ed86d860eb0d4a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cc6f55191a75dafa669fc6ee93ed86d860eb0d4a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/cc6f55191a75dafa669fc6ee93ed86d860eb0d4a"
      }
    ],
    "stats": {
      "total": 22,
      "additions": 21,
      "deletions": 1
    },
    "files": [
      {
        "sha": "ea01ddc10d81a6c58f72ed93bb2742425cb932c1",
        "filename": "src/core_write.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 1,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bcf3806f4cb9dad1424c78f458b5398a927161e8/src/core_write.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bcf3806f4cb9dad1424c78f458b5398a927161e8/src/core_write.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core_write.cpp?ref=bcf3806f4cb9dad1424c78f458b5398a927161e8",
        "patch": "@@ -151,11 +151,13 @@ void ScriptPubKeyToUniv(const CScript& scriptPubKey,\n void TxToUniv(const CTransaction& tx, const uint256& hashBlock, UniValue& entry)\n {\n     entry.pushKV(\"txid\", tx.GetHash().GetHex());\n+    entry.pushKV(\"hash\", tx.GetWitnessHash().GetHex());\n     entry.pushKV(\"version\", tx.nVersion);\n     entry.pushKV(\"locktime\", (int64_t)tx.nLockTime);\n \n     UniValue vin(UniValue::VARR);\n-    BOOST_FOREACH(const CTxIn& txin, tx.vin) {\n+    for (unsigned int i = 0; i < tx.vin.size(); i++) {\n+        const CTxIn& txin = tx.vin[i];\n         UniValue in(UniValue::VOBJ);\n         if (tx.IsCoinBase())\n             in.pushKV(\"coinbase\", HexStr(txin.scriptSig.begin(), txin.scriptSig.end()));\n@@ -166,6 +168,13 @@ void TxToUniv(const CTransaction& tx, const uint256& hashBlock, UniValue& entry)\n             o.pushKV(\"asm\", ScriptToAsmStr(txin.scriptSig, true));\n             o.pushKV(\"hex\", HexStr(txin.scriptSig.begin(), txin.scriptSig.end()));\n             in.pushKV(\"scriptSig\", o);\n+            if (!tx.wit.IsNull() && i < tx.wit.vtxinwit.size() && !tx.wit.vtxinwit[i].IsNull()) {\n+                UniValue txinwitness(UniValue::VARR);\n+                for (const auto& item : tx.wit.vtxinwit[i].scriptWitness.stack) {\n+                    txinwitness.push_back(HexStr(item.begin(), item.end()));\n+                }\n+                in.pushKV(\"txinwitness\", txinwitness);\n+            }\n         }\n         in.pushKV(\"sequence\", (int64_t)txin.nSequence);\n         vin.push_back(in);"
      },
      {
        "sha": "51c25a5a98c5965df194fa22b049f6be5863d48a",
        "filename": "src/test/data/blanktx.json",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bcf3806f4cb9dad1424c78f458b5398a927161e8/src/test/data/blanktx.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bcf3806f4cb9dad1424c78f458b5398a927161e8/src/test/data/blanktx.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/data/blanktx.json?ref=bcf3806f4cb9dad1424c78f458b5398a927161e8",
        "patch": "@@ -1,5 +1,6 @@\n {\n     \"txid\": \"d21633ba23f70118185227be58a63527675641ad37967e2aa461559f577aec43\",\n+    \"hash\": \"d21633ba23f70118185227be58a63527675641ad37967e2aa461559f577aec43\",\n     \"version\": 1,\n     \"locktime\": 0,\n     \"vin\": ["
      },
      {
        "sha": "712a2c27f8faed7358a36202771fce1999d1bfee",
        "filename": "src/test/data/tt-delin1-out.json",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bcf3806f4cb9dad1424c78f458b5398a927161e8/src/test/data/tt-delin1-out.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bcf3806f4cb9dad1424c78f458b5398a927161e8/src/test/data/tt-delin1-out.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/data/tt-delin1-out.json?ref=bcf3806f4cb9dad1424c78f458b5398a927161e8",
        "patch": "@@ -1,5 +1,6 @@\n {\n     \"txid\": \"81b2035be1da1abe745c6141174a73d151009ec17b3d5ebffa2e177408c50dfd\",\n+    \"hash\": \"81b2035be1da1abe745c6141174a73d151009ec17b3d5ebffa2e177408c50dfd\",\n     \"version\": 1,\n     \"locktime\": 0,\n     \"vin\": ["
      },
      {
        "sha": "afc4e95762d4a9dcc72785e24c8602f552abc5cc",
        "filename": "src/test/data/tt-delout1-out.json",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bcf3806f4cb9dad1424c78f458b5398a927161e8/src/test/data/tt-delout1-out.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bcf3806f4cb9dad1424c78f458b5398a927161e8/src/test/data/tt-delout1-out.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/data/tt-delout1-out.json?ref=bcf3806f4cb9dad1424c78f458b5398a927161e8",
        "patch": "@@ -1,5 +1,6 @@\n {\n     \"txid\": \"c46ccd75b5050e942b2e86a3648f843f525fe6fc000bf0534ba5973063354493\",\n+    \"hash\": \"c46ccd75b5050e942b2e86a3648f843f525fe6fc000bf0534ba5973063354493\",\n     \"version\": 1,\n     \"locktime\": 0,\n     \"vin\": ["
      },
      {
        "sha": "2b9075f8acece0136da5a9bdb2b0bcc58f29fe1b",
        "filename": "src/test/data/tt-locktime317000-out.json",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bcf3806f4cb9dad1424c78f458b5398a927161e8/src/test/data/tt-locktime317000-out.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bcf3806f4cb9dad1424c78f458b5398a927161e8/src/test/data/tt-locktime317000-out.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/data/tt-locktime317000-out.json?ref=bcf3806f4cb9dad1424c78f458b5398a927161e8",
        "patch": "@@ -1,5 +1,6 @@\n {\n     \"txid\": \"aded538f642c17e15f4d3306b8be7e1a4d1ae0c4616d641ab51ea09ba65e5cb5\",\n+    \"hash\": \"aded538f642c17e15f4d3306b8be7e1a4d1ae0c4616d641ab51ea09ba65e5cb5\",\n     \"version\": 1,\n     \"locktime\": 317000,\n     \"vin\": ["
      },
      {
        "sha": "567e8026a321cd894b5d7f8d22c1155f9efa1797",
        "filename": "src/test/data/txcreate1.json",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bcf3806f4cb9dad1424c78f458b5398a927161e8/src/test/data/txcreate1.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bcf3806f4cb9dad1424c78f458b5398a927161e8/src/test/data/txcreate1.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/data/txcreate1.json?ref=bcf3806f4cb9dad1424c78f458b5398a927161e8",
        "patch": "@@ -1,5 +1,6 @@\n {\n     \"txid\": \"f70f0d6c71416ed538e37549f430ab3665fee2437a42f10238c1bd490e782231\",\n+    \"hash\": \"f70f0d6c71416ed538e37549f430ab3665fee2437a42f10238c1bd490e782231\",\n     \"version\": 1,\n     \"locktime\": 0,\n     \"vin\": ["
      },
      {
        "sha": "a70c1d302a28d06823c1908e812a55b2b801d673",
        "filename": "src/test/data/txcreate2.json",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bcf3806f4cb9dad1424c78f458b5398a927161e8/src/test/data/txcreate2.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bcf3806f4cb9dad1424c78f458b5398a927161e8/src/test/data/txcreate2.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/data/txcreate2.json?ref=bcf3806f4cb9dad1424c78f458b5398a927161e8",
        "patch": "@@ -1,5 +1,6 @@\n {\n     \"txid\": \"cf90229625e9eb10f6be8156bf6aa5ec2eca19a42b1e05c11f3029b560a32e13\",\n+    \"hash\": \"cf90229625e9eb10f6be8156bf6aa5ec2eca19a42b1e05c11f3029b560a32e13\",\n     \"version\": 1,\n     \"locktime\": 0,\n     \"vin\": ["
      },
      {
        "sha": "760518d30a983fb459a14b42f3ea1755b9563659",
        "filename": "src/test/data/txcreatedata1.json",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bcf3806f4cb9dad1424c78f458b5398a927161e8/src/test/data/txcreatedata1.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bcf3806f4cb9dad1424c78f458b5398a927161e8/src/test/data/txcreatedata1.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/data/txcreatedata1.json?ref=bcf3806f4cb9dad1424c78f458b5398a927161e8",
        "patch": "@@ -1,5 +1,6 @@\n {\n     \"txid\": \"07894b4d12fe7853dd911402db1620920d261b9627c447f931417d330c25f06e\",\n+    \"hash\": \"07894b4d12fe7853dd911402db1620920d261b9627c447f931417d330c25f06e\",\n     \"version\": 1,\n     \"locktime\": 0,\n     \"vin\": ["
      },
      {
        "sha": "56dfe4a1b055a99118762a417f36fee507315d45",
        "filename": "src/test/data/txcreatedata2.json",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bcf3806f4cb9dad1424c78f458b5398a927161e8/src/test/data/txcreatedata2.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bcf3806f4cb9dad1424c78f458b5398a927161e8/src/test/data/txcreatedata2.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/data/txcreatedata2.json?ref=bcf3806f4cb9dad1424c78f458b5398a927161e8",
        "patch": "@@ -1,5 +1,6 @@\n {\n     \"txid\": \"4ed17118f5e932ba8c75c461787d171bc02a016d8557cb5bcf34cd416c27bb8b\",\n+    \"hash\": \"4ed17118f5e932ba8c75c461787d171bc02a016d8557cb5bcf34cd416c27bb8b\",\n     \"version\": 1,\n     \"locktime\": 0,\n     \"vin\": ["
      },
      {
        "sha": "9bc0ed459360920bdda25b58c93bcde7f4beddd9",
        "filename": "src/test/data/txcreatedata_seq0.json",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bcf3806f4cb9dad1424c78f458b5398a927161e8/src/test/data/txcreatedata_seq0.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bcf3806f4cb9dad1424c78f458b5398a927161e8/src/test/data/txcreatedata_seq0.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/data/txcreatedata_seq0.json?ref=bcf3806f4cb9dad1424c78f458b5398a927161e8",
        "patch": "@@ -1,5 +1,6 @@\n {\n     \"txid\": \"71603ccb1cd76d73d76eb6cfd5f0b9df6d65d90d76860ee52cb461c4be7032e8\",\n+    \"hash\": \"71603ccb1cd76d73d76eb6cfd5f0b9df6d65d90d76860ee52cb461c4be7032e8\",\n     \"version\": 1,\n     \"locktime\": 0,\n     \"vin\": ["
      },
      {
        "sha": "d323255418d04843ed7201fc12a71ae1c5c9d5dd",
        "filename": "src/test/data/txcreatedata_seq1.json",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bcf3806f4cb9dad1424c78f458b5398a927161e8/src/test/data/txcreatedata_seq1.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bcf3806f4cb9dad1424c78f458b5398a927161e8/src/test/data/txcreatedata_seq1.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/data/txcreatedata_seq1.json?ref=bcf3806f4cb9dad1424c78f458b5398a927161e8",
        "patch": "@@ -1,5 +1,6 @@\n {\n     \"txid\": \"c4dea671b0d7b48f8ab10bc46650e8329d3c5766931f548f513847a19f5ba75b\",\n+    \"hash\": \"c4dea671b0d7b48f8ab10bc46650e8329d3c5766931f548f513847a19f5ba75b\",\n     \"version\": 1,\n     \"locktime\": 0,\n     \"vin\": ["
      },
      {
        "sha": "ff39e71b40c0d68a55a4aba988e5ef95a332ee29",
        "filename": "src/test/data/txcreatesign.json",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bcf3806f4cb9dad1424c78f458b5398a927161e8/src/test/data/txcreatesign.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bcf3806f4cb9dad1424c78f458b5398a927161e8/src/test/data/txcreatesign.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/data/txcreatesign.json?ref=bcf3806f4cb9dad1424c78f458b5398a927161e8",
        "patch": "@@ -1,5 +1,6 @@\n {\n     \"txid\": \"977e7cd286cb72cd470d539ba6cb48400f8f387d97451d45cdb8819437a303af\",\n+    \"hash\": \"977e7cd286cb72cd470d539ba6cb48400f8f387d97451d45cdb8819437a303af\",\n     \"version\": 1,\n     \"locktime\": 0,\n     \"vin\": ["
      }
    ]
  },
  {
    "sha": "df5069bb0e56476fe3c0670922d9cdb678c40c29",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkZjUwNjliYjBlNTY0NzZmZTNjMDY3MDkyMmQ5Y2RiNjc4YzQwYzI5",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2016-10-14T16:54:15Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2016-10-17T11:15:11Z"
      },
      "message": "[qa] Send segwit-encoded blocktxn messages in p2p-compactblocks\n\nGithub-Pull: #8916\nRebased-From: 032e883b937a6b70d5c367fc2ee57d7eea8cb473",
      "tree": {
        "sha": "5416516910f0a2ad867e9e10c174da39f7636f49",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5416516910f0a2ad867e9e10c174da39f7636f49"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/df5069bb0e56476fe3c0670922d9cdb678c40c29",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/df5069bb0e56476fe3c0670922d9cdb678c40c29",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/df5069bb0e56476fe3c0670922d9cdb678c40c29",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/df5069bb0e56476fe3c0670922d9cdb678c40c29/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "bcf3806f4cb9dad1424c78f458b5398a927161e8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bcf3806f4cb9dad1424c78f458b5398a927161e8",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/bcf3806f4cb9dad1424c78f458b5398a927161e8"
      }
    ],
    "stats": {
      "total": 28,
      "additions": 18,
      "deletions": 10
    },
    "files": [
      {
        "sha": "1beab609b68efc8b50afcb976f53d18c1f72ca9a",
        "filename": "qa/rpc-tests/p2p-compactblocks.py",
        "status": "modified",
        "additions": 18,
        "deletions": 10,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/df5069bb0e56476fe3c0670922d9cdb678c40c29/qa/rpc-tests/p2p-compactblocks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/df5069bb0e56476fe3c0670922d9cdb678c40c29/qa/rpc-tests/p2p-compactblocks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/p2p-compactblocks.py?ref=df5069bb0e56476fe3c0670922d9cdb678c40c29",
        "patch": "@@ -6,7 +6,7 @@\n from test_framework.mininode import *\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import *\n-from test_framework.blocktools import create_block, create_coinbase\n+from test_framework.blocktools import create_block, create_coinbase, add_witness_commitment\n from test_framework.siphash import siphash256\n from test_framework.script import CScript, OP_TRUE\n \n@@ -123,11 +123,13 @@ def setup_network(self):\n                  [\"-debug\", \"-logtimemicros\", \"-txindex\"]])\n         connect_nodes(self.nodes[0], 1)\n \n-    def build_block_on_tip(self, node):\n+    def build_block_on_tip(self, node, segwit=False):\n         height = node.getblockcount()\n         tip = node.getbestblockhash()\n         mtp = node.getblockheader(tip)['mediantime']\n         block = create_block(int(tip, 16), create_coinbase(height + 1), mtp + 1)\n+        if segwit:\n+            add_witness_commitment(block)\n         block.solve()\n         return block\n \n@@ -380,11 +382,11 @@ def test_compactblock_construction(self, node, test_node, version, use_witness_a\n     # Post-segwit: upgraded nodes would only make this request of cb-version-2,\n     # NODE_WITNESS peers.  Unupgraded nodes would still make this request of\n     # any cb-version-1-supporting peer.\n-    def test_compactblock_requests(self, node, test_node):\n+    def test_compactblock_requests(self, node, test_node, version, segwit):\n         # Try announcing a block with an inv or header, expect a compactblock\n         # request\n         for announce in [\"inv\", \"header\"]:\n-            block = self.build_block_on_tip(node)\n+            block = self.build_block_on_tip(node, segwit=segwit)\n             with mininode_lock:\n                 test_node.last_getdata = None\n \n@@ -403,8 +405,11 @@ def test_compactblock_requests(self, node, test_node):\n             comp_block.header = CBlockHeader(block)\n             comp_block.nonce = 0\n             [k0, k1] = comp_block.get_siphash_keys()\n+            coinbase_hash = block.vtx[0].sha256\n+            if version == 2:\n+                coinbase_hash = block.vtx[0].calc_sha256(True)\n             comp_block.shortids = [\n-                    calculate_shortid(k0, k1, block.vtx[0].sha256) ]\n+                    calculate_shortid(k0, k1, coinbase_hash) ]\n             test_node.send_and_ping(msg_cmpctblock(comp_block.to_p2p()))\n             assert_equal(int(node.getbestblockhash(), 16), block.hashPrevBlock)\n             # Expect a getblocktxn message.\n@@ -414,7 +419,10 @@ def test_compactblock_requests(self, node, test_node):\n             assert_equal(absolute_indexes, [0])  # should be a coinbase request\n \n             # Send the coinbase, and verify that the tip advances.\n-            msg = msg_blocktxn()\n+            if version == 2:\n+                msg = msg_witness_blocktxn()\n+            else:\n+                msg = msg_blocktxn()\n             msg.block_transactions.blockhash = block.sha256\n             msg.block_transactions.transactions = [block.vtx[0]]\n             test_node.send_and_ping(msg)\n@@ -750,9 +758,9 @@ def run_test(self):\n         sync_blocks(self.nodes)\n \n         print(\"\\tTesting compactblock requests... \")\n-        self.test_compactblock_requests(self.nodes[0], self.test_node)\n+        self.test_compactblock_requests(self.nodes[0], self.test_node, 1, False)\n         sync_blocks(self.nodes)\n-        self.test_compactblock_requests(self.nodes[1], self.segwit_node)\n+        self.test_compactblock_requests(self.nodes[1], self.segwit_node, 2, False)\n         sync_blocks(self.nodes)\n \n         print(\"\\tTesting getblocktxn requests...\")\n@@ -800,7 +808,7 @@ def run_test(self):\n         sync_blocks(self.nodes)\n \n         print(\"\\tTesting compactblock requests (unupgraded node)... \")\n-        self.test_compactblock_requests(self.nodes[0], self.test_node)\n+        self.test_compactblock_requests(self.nodes[0], self.test_node, 1, True)\n \n         print(\"\\tTesting getblocktxn requests (unupgraded node)...\")\n         self.test_getblocktxn_requests(self.nodes[0], self.test_node, 1)\n@@ -815,7 +823,7 @@ def run_test(self):\n         assert_equal(self.nodes[0].getbestblockhash(), self.nodes[1].getbestblockhash())\n \n         print(\"\\tTesting compactblock requests (segwit node)... \")\n-        self.test_compactblock_requests(self.nodes[1], self.segwit_node)\n+        self.test_compactblock_requests(self.nodes[1], self.segwit_node, 2, True)\n \n         print(\"\\tTesting getblocktxn requests (segwit node)...\")\n         self.test_getblocktxn_requests(self.nodes[1], self.segwit_node, 2)"
      }
    ]
  },
  {
    "sha": "9bb2a02f0dd8851a6dc413fd86ce0b51878b5007",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5YmIyYTAyZjBkZDg4NTFhNmRjNDEzZmQ4NmNlMGI1MTg3OGI1MDA3",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2016-10-15T21:51:05Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2016-10-17T11:15:30Z"
      },
      "message": "[qa] Build v4 blocks in p2p-compactblocktests\n\nThis fixes an issue in backporting to 0.13 as 0.13 enforces SF\nactivation by block version lockin instead of through a hard-coded\nblock height.\n\nGithub-Pull: #8916\nRebased-From: a4ad37d4ef4bcd81bc9d867b277efdebc86bc2e8",
      "tree": {
        "sha": "19253c283831341f6d87b963650700da1b91088f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/19253c283831341f6d87b963650700da1b91088f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9bb2a02f0dd8851a6dc413fd86ce0b51878b5007",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9bb2a02f0dd8851a6dc413fd86ce0b51878b5007",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9bb2a02f0dd8851a6dc413fd86ce0b51878b5007",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9bb2a02f0dd8851a6dc413fd86ce0b51878b5007/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "df5069bb0e56476fe3c0670922d9cdb678c40c29",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/df5069bb0e56476fe3c0670922d9cdb678c40c29",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/df5069bb0e56476fe3c0670922d9cdb678c40c29"
      }
    ],
    "stats": {
      "total": 1,
      "additions": 1,
      "deletions": 0
    },
    "files": [
      {
        "sha": "131654c333d4daa48687c47b32411b2efc84b05c",
        "filename": "qa/rpc-tests/p2p-compactblocks.py",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9bb2a02f0dd8851a6dc413fd86ce0b51878b5007/qa/rpc-tests/p2p-compactblocks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9bb2a02f0dd8851a6dc413fd86ce0b51878b5007/qa/rpc-tests/p2p-compactblocks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/p2p-compactblocks.py?ref=9bb2a02f0dd8851a6dc413fd86ce0b51878b5007",
        "patch": "@@ -128,6 +128,7 @@ def build_block_on_tip(self, node, segwit=False):\n         tip = node.getbestblockhash()\n         mtp = node.getblockheader(tip)['mediantime']\n         block = create_block(int(tip, 16), create_coinbase(height + 1), mtp + 1)\n+        block.nVersion = 4\n         if segwit:\n             add_witness_commitment(block)\n         block.solve()"
      }
    ]
  },
  {
    "sha": "540413d9958fd253d4bf99858db431164db275e1",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1NDA0MTNkOTk1OGZkMjUzZDRiZjk5ODU4ZGI0MzExNjRkYjI3NWUx",
    "commit": {
      "author": {
        "name": "Johnson Lau",
        "email": "jl2012@xbt.hk",
        "date": "2016-10-16T15:53:16Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2016-10-17T12:10:58Z"
      },
      "message": "Add standard limits for P2WSH with tests\n\nGithub-Pull: #8499\nRebased-From: 3ade2f64cfe43ab53e4869ffc35d5fd23201e1c1",
      "tree": {
        "sha": "f40fc4a2c3cc9084e6946ee320f2edf0bbe10a2f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f40fc4a2c3cc9084e6946ee320f2edf0bbe10a2f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/540413d9958fd253d4bf99858db431164db275e1",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/540413d9958fd253d4bf99858db431164db275e1",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/540413d9958fd253d4bf99858db431164db275e1",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/540413d9958fd253d4bf99858db431164db275e1/comments",
    "author": {
      "login": "jl2012",
      "id": 8403418,
      "node_id": "MDQ6VXNlcjg0MDM0MTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8403418?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jl2012",
      "html_url": "https://github.com/jl2012",
      "followers_url": "https://api.github.com/users/jl2012/followers",
      "following_url": "https://api.github.com/users/jl2012/following{/other_user}",
      "gists_url": "https://api.github.com/users/jl2012/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jl2012/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jl2012/subscriptions",
      "organizations_url": "https://api.github.com/users/jl2012/orgs",
      "repos_url": "https://api.github.com/users/jl2012/repos",
      "events_url": "https://api.github.com/users/jl2012/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jl2012/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9bb2a02f0dd8851a6dc413fd86ce0b51878b5007",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9bb2a02f0dd8851a6dc413fd86ce0b51878b5007",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9bb2a02f0dd8851a6dc413fd86ce0b51878b5007"
      }
    ],
    "stats": {
      "total": 183,
      "additions": 181,
      "deletions": 2
    },
    "files": [
      {
        "sha": "90f43b417a9fc8df53f40181c0ad62d90dacd43f",
        "filename": "qa/rpc-tests/p2p-segwit.py",
        "status": "modified",
        "additions": 111,
        "deletions": 0,
        "changes": 111,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/540413d9958fd253d4bf99858db431164db275e1/qa/rpc-tests/p2p-segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/540413d9958fd253d4bf99858db431164db275e1/qa/rpc-tests/p2p-segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/p2p-segwit.py?ref=540413d9958fd253d4bf99858db431164db275e1",
        "patch": "@@ -1703,6 +1703,116 @@ def test_getblocktemplate_before_lockin(self):\n         assert(block_version & (1 << VB_WITNESS_BIT) != 0)\n         self.nodes[0].setmocktime(0) # undo mocktime\n \n+    def test_non_standard_witness(self):\n+        print(\"\\tTesting detection of non-standard P2WSH witness\")\n+        pad = chr(1).encode('latin-1')\n+\n+        # Create scripts for tests\n+        scripts = []\n+        scripts.append(CScript([OP_DROP] * 100))\n+        scripts.append(CScript([OP_DROP] * 99))\n+        scripts.append(CScript([pad * 59] * 59 + [OP_DROP] * 60))\n+        scripts.append(CScript([pad * 59] * 59 + [OP_DROP] * 61))\n+\n+        p2wsh_scripts = []\n+\n+        assert(len(self.utxo))\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n+\n+        # For each script, generate a pair of P2WSH and P2SH-P2WSH output.\n+        outputvalue = (self.utxo[0].nValue - 1000) // (len(scripts) * 2)\n+        for i in scripts:\n+            p2wsh = CScript([OP_0, sha256(i)])\n+            p2sh = hash160(p2wsh)\n+            p2wsh_scripts.append(p2wsh)\n+            tx.vout.append(CTxOut(outputvalue, p2wsh))\n+            tx.vout.append(CTxOut(outputvalue, CScript([OP_HASH160, p2sh, OP_EQUAL])))\n+        tx.rehash()\n+        txid = tx.sha256\n+        self.test_node.test_transaction_acceptance(tx, with_witness=False, accepted=True)\n+\n+        self.nodes[0].generate(1)\n+        sync_blocks(self.nodes)\n+\n+        # Creating transactions for tests\n+        p2wsh_txs = []\n+        p2sh_txs = []\n+        for i in range(len(scripts)):\n+            p2wsh_tx = CTransaction()\n+            p2wsh_tx.vin.append(CTxIn(COutPoint(txid,i*2)))\n+            p2wsh_tx.vout.append(CTxOut(outputvalue - 5000, CScript([OP_0, hash160(hex_str_to_bytes(\"\"))])))\n+            p2wsh_tx.wit.vtxinwit.append(CTxInWitness())\n+            p2wsh_tx.rehash()\n+            p2wsh_txs.append(p2wsh_tx)\n+            p2sh_tx = CTransaction()\n+            p2sh_tx.vin.append(CTxIn(COutPoint(txid,i*2+1), CScript([p2wsh_scripts[i]])))\n+            p2sh_tx.vout.append(CTxOut(outputvalue - 5000, CScript([OP_0, hash160(hex_str_to_bytes(\"\"))])))\n+            p2sh_tx.wit.vtxinwit.append(CTxInWitness())\n+            p2sh_tx.rehash()\n+            p2sh_txs.append(p2sh_tx)\n+\n+        # Testing native P2WSH\n+        # Witness stack size, excluding witnessScript, over 100 is non-standard\n+        p2wsh_txs[0].wit.vtxinwit[0].scriptWitness.stack = [pad] * 101 + [scripts[0]]\n+        self.std_node.test_transaction_acceptance(p2wsh_txs[0], True, False, b'bad-witness-nonstandard')\n+        # Non-standard nodes should accept\n+        self.test_node.test_transaction_acceptance(p2wsh_txs[0], True, True)\n+\n+        # Stack element size over 80 bytes is non-standard\n+        p2wsh_txs[1].wit.vtxinwit[0].scriptWitness.stack = [pad * 81] * 100 + [scripts[1]]\n+        # It can't be used to blind a node to the transaction\n+        self.std_node.announce_tx_and_wait_for_getdata(p2wsh_txs[1])\n+        self.std_node.test_transaction_acceptance(p2wsh_txs[1], True, False, b'bad-witness-nonstandard')\n+        self.std_node.announce_tx_and_wait_for_getdata(p2wsh_txs[1])\n+        self.std_node.test_transaction_acceptance(p2wsh_txs[1], True, False, b'bad-witness-nonstandard')\n+        # Non-standard nodes should accept\n+        self.test_node.test_transaction_acceptance(p2wsh_txs[1], True, True)\n+        # Standard nodes should accept if element size is not over 80 bytes\n+        p2wsh_txs[1].wit.vtxinwit[0].scriptWitness.stack = [pad * 80] * 100 + [scripts[1]]\n+        self.std_node.announce_tx_and_wait_for_getdata(p2wsh_txs[1])\n+        self.std_node.test_transaction_acceptance(p2wsh_txs[1], True, True)\n+\n+        # witnessScript size at 3600 bytes is standard\n+        p2wsh_txs[2].wit.vtxinwit[0].scriptWitness.stack = [pad, pad, scripts[2]]\n+        self.test_node.test_transaction_acceptance(p2wsh_txs[2], True, True)\n+        self.std_node.test_transaction_acceptance(p2wsh_txs[2], True, True)\n+\n+        # witnessScript size at 3601 bytes is non-standard\n+        p2wsh_txs[3].wit.vtxinwit[0].scriptWitness.stack = [pad, pad, pad, scripts[3]]\n+        self.std_node.test_transaction_acceptance(p2wsh_txs[3], True, False, b'bad-witness-nonstandard')\n+        # Non-standard nodes should accept\n+        self.test_node.test_transaction_acceptance(p2wsh_txs[3], True, True)\n+\n+        # Repeating the same tests with P2SH-P2WSH\n+        p2sh_txs[0].wit.vtxinwit[0].scriptWitness.stack = [pad] * 101 + [scripts[0]]\n+        self.std_node.test_transaction_acceptance(p2sh_txs[0], True, False, b'bad-witness-nonstandard')\n+        self.test_node.test_transaction_acceptance(p2sh_txs[0], True, True)\n+        p2sh_txs[1].wit.vtxinwit[0].scriptWitness.stack = [pad * 81] * 100 + [scripts[1]]\n+        self.std_node.announce_tx_and_wait_for_getdata(p2sh_txs[1])\n+        self.std_node.test_transaction_acceptance(p2sh_txs[1], True, False, b'bad-witness-nonstandard')\n+        self.std_node.announce_tx_and_wait_for_getdata(p2sh_txs[1])\n+        self.std_node.test_transaction_acceptance(p2sh_txs[1], True, False, b'bad-witness-nonstandard')\n+        self.test_node.test_transaction_acceptance(p2sh_txs[1], True, True)\n+        p2sh_txs[1].wit.vtxinwit[0].scriptWitness.stack = [pad * 80] * 100 + [scripts[1]]\n+        self.std_node.announce_tx_and_wait_for_getdata(p2sh_txs[1])\n+        self.std_node.test_transaction_acceptance(p2sh_txs[1], True, True)\n+        p2sh_txs[2].wit.vtxinwit[0].scriptWitness.stack = [pad, pad, scripts[2]]\n+        self.test_node.test_transaction_acceptance(p2sh_txs[2], True, True)\n+        self.std_node.test_transaction_acceptance(p2sh_txs[2], True, True)\n+        p2sh_txs[3].wit.vtxinwit[0].scriptWitness.stack = [pad, pad, pad, scripts[3]]\n+        self.std_node.test_transaction_acceptance(p2sh_txs[3], True, False, b'bad-witness-nonstandard')\n+        self.test_node.test_transaction_acceptance(p2sh_txs[3], True, True)\n+\n+        self.nodes[0].generate(1)  # Mine and clean up the mempool of non-standard node\n+        # Valid but non-standard transactions in a block should be accepted by standard node\n+        sync_blocks(self.nodes)\n+        assert_equal(len(self.nodes[0].getrawmempool()), 0)\n+        assert_equal(len(self.nodes[1].getrawmempool()), 0)\n+\n+        self.utxo.pop(0)\n+\n+\n     def run_test(self):\n         # Setup the p2p connections and start up the network thread.\n         self.test_node = TestNode() # sets NODE_WITNESS|NODE_NETWORK\n@@ -1775,6 +1885,7 @@ def run_test(self):\n         self.test_segwit_versions()\n         self.test_premature_coinbase_witness_spend()\n         self.test_signature_version_1()\n+        self.test_non_standard_witness()\n         sync_blocks(self.nodes)\n         if self.test_upgrade:\n             self.test_upgrade_after_activation(self.nodes[2], 2)"
      },
      {
        "sha": "61d0aaf0b9b79521e961c48aad16feb1cbddc545",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 1,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/540413d9958fd253d4bf99858db431164db275e1/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/540413d9958fd253d4bf99858db431164db275e1/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=540413d9958fd253d4bf99858db431164db275e1",
        "patch": "@@ -1,5 +1,5 @@\n // Copyright (c) 2009-2010 Satoshi Nakamoto\n-// Copyright (c) 2009-2015 The Bitcoin Core developers\n+// Copyright (c) 2009-2016 The Bitcoin Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n@@ -1282,6 +1282,10 @@ bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState& state, const C\n         if (fRequireStandard && !AreInputsStandard(tx, view))\n             return state.Invalid(false, REJECT_NONSTANDARD, \"bad-txns-nonstandard-inputs\");\n \n+        // Check for non-standard witness in P2WSH\n+        if (!tx.wit.IsNull() && fRequireStandard && !IsWitnessStandard(tx, view))\n+            return state.DoS(0, false, REJECT_NONSTANDARD, \"bad-witness-nonstandard\", true);\n+\n         int64_t nSigOpsCost = GetTransactionSigOpCost(tx, view, STANDARD_SCRIPT_VERIFY_FLAGS);\n \n         CAmount nValueOut = tx.GetValueOut();"
      },
      {
        "sha": "ae42b2bd74fd8b3bbe38cefa0d4f13a82db7ae9f",
        "filename": "src/policy/policy.cpp",
        "status": "modified",
        "additions": 53,
        "deletions": 1,
        "changes": 54,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/540413d9958fd253d4bf99858db431164db275e1/src/policy/policy.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/540413d9958fd253d4bf99858db431164db275e1/src/policy/policy.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/policy.cpp?ref=540413d9958fd253d4bf99858db431164db275e1",
        "patch": "@@ -1,5 +1,5 @@\n // Copyright (c) 2009-2010 Satoshi Nakamoto\n-// Copyright (c) 2009-2015 The Bitcoin developers\n+// Copyright (c) 2009-2016 The Bitcoin developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n@@ -154,6 +154,58 @@ bool AreInputsStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)\n     return true;\n }\n \n+bool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)\n+{\n+    if (tx.IsCoinBase())\n+        return true; // Coinbases are skipped\n+\n+    for (unsigned int i = 0; i < tx.vin.size(); i++)\n+    {\n+        // We don't care if witness for this input is empty, since it must not be bloated.\n+        // If the script is invalid without witness, it would be caught sooner or later during validation.\n+        if (tx.wit.vtxinwit[i].IsNull())\n+            continue;\n+\n+        const CTxOut &prev = mapInputs.GetOutputFor(tx.vin[i]);\n+\n+        // get the scriptPubKey corresponding to this input:\n+        CScript prevScript = prev.scriptPubKey;\n+\n+        if (prevScript.IsPayToScriptHash()) {\n+            std::vector <std::vector<unsigned char> > stack;\n+            // If the scriptPubKey is P2SH, we try to extract the redeemScript casually by converting the scriptSig\n+            // into a stack. We do not check IsPushOnly nor compare the hash as these will be done later anyway.\n+            // If the check fails at this stage, we know that this txid must be a bad one.\n+            if (!EvalScript(stack, tx.vin[i].scriptSig, SCRIPT_VERIFY_NONE, BaseSignatureChecker(), SIGVERSION_BASE))\n+                return false;\n+            if (stack.empty())\n+                return false;\n+            prevScript = CScript(stack.back().begin(), stack.back().end());\n+        }\n+\n+        int witnessversion = 0;\n+        std::vector<unsigned char> witnessprogram;\n+\n+        // Non-witness program must not be associated with any witness\n+        if (!prevScript.IsWitnessProgram(witnessversion, witnessprogram))\n+            return false;\n+\n+        // Check P2WSH standard limits\n+        if (witnessversion == 0 && witnessprogram.size() == 32) {\n+            if (tx.wit.vtxinwit[i].scriptWitness.stack.back().size() > MAX_STANDARD_P2WSH_SCRIPT_SIZE)\n+                return false;\n+            size_t sizeWitnessStack = tx.wit.vtxinwit[i].scriptWitness.stack.size() - 1;\n+            if (sizeWitnessStack > MAX_STANDARD_P2WSH_STACK_ITEMS)\n+                return false;\n+            for (unsigned int j = 0; j < sizeWitnessStack; j++) {\n+                if (tx.wit.vtxinwit[i].scriptWitness.stack[j].size() > MAX_STANDARD_P2WSH_STACK_ITEM_SIZE)\n+                    return false;\n+            }\n+        }\n+    }\n+    return true;\n+}\n+\n unsigned int nBytesPerSigOp = DEFAULT_BYTES_PER_SIGOP;\n \n int64_t GetVirtualTransactionSize(int64_t nWeight, int64_t nSigOpCost)"
      },
      {
        "sha": "fb528d74868c56b770998c36799dc853b1bf38eb",
        "filename": "src/policy/policy.h",
        "status": "modified",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/540413d9958fd253d4bf99858db431164db275e1/src/policy/policy.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/540413d9958fd253d4bf99858db431164db275e1/src/policy/policy.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/policy.h?ref=540413d9958fd253d4bf99858db431164db275e1",
        "patch": "@@ -30,6 +30,12 @@ static const unsigned int MAX_STANDARD_TX_SIGOPS_COST = MAX_BLOCK_SIGOPS_COST/5;\n static const unsigned int DEFAULT_MAX_MEMPOOL_SIZE = 300;\n /** Default for -bytespersigop */\n static const unsigned int DEFAULT_BYTES_PER_SIGOP = 20;\n+/** The maximum number of witness stack items in a standard P2WSH script */\n+static const unsigned int MAX_STANDARD_P2WSH_STACK_ITEMS = 100;\n+/** The maximum size of each witness stack item in a standard P2WSH script */\n+static const unsigned int MAX_STANDARD_P2WSH_STACK_ITEM_SIZE = 80;\n+/** The maximum size of a standard witnessScript */\n+static const unsigned int MAX_STANDARD_P2WSH_SCRIPT_SIZE = 3600;\n /**\n  * Standard script verification flags that standard transactions will comply\n  * with. However scripts violating these flags may still be present in valid\n@@ -69,6 +75,12 @@ bool IsStandardTx(const CTransaction& tx, std::string& reason, const bool witnes\n      * @return True if all inputs (scriptSigs) use only standard transaction forms\n      */\n bool AreInputsStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs);\n+    /**\n+     * Check if the transaction is over standard P2WSH resources limit:\n+     * 3600bytes witnessScript size, 80bytes per witness stack element, 100 witness stack elements\n+     * These limits are adequate for multi-signature up to n-of-100 using OP_CHECKSIG, OP_ADD, and OP_EQUAL,\n+     */\n+bool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs);\n \n extern unsigned int nBytesPerSigOp;\n "
      }
    ]
  },
  {
    "sha": "821f3e67510b9ea0b5c7b79d162daf5f0f075462",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4MjFmM2U2NzUxMGI5ZWEwYjVjN2I3OWQxNjJkYWY1ZjBmMDc1NDYy",
    "commit": {
      "author": {
        "name": "Johnson Lau",
        "email": "jl2012@xbt.hk",
        "date": "2016-10-01T17:19:33Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2016-10-17T12:10:58Z"
      },
      "message": "Require compressed keys in segwit as policy and disable signing with uncompressed keys for segwit scripts\n\nGithub-Pull: #8499\nRebased-From: 4c0c25a604cec39675187507df423cff5d707ab5",
      "tree": {
        "sha": "2bf532aa805200ed14248a62457c8087c4b05a1c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2bf532aa805200ed14248a62457c8087c4b05a1c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/821f3e67510b9ea0b5c7b79d162daf5f0f075462",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/821f3e67510b9ea0b5c7b79d162daf5f0f075462",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/821f3e67510b9ea0b5c7b79d162daf5f0f075462",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/821f3e67510b9ea0b5c7b79d162daf5f0f075462/comments",
    "author": {
      "login": "jl2012",
      "id": 8403418,
      "node_id": "MDQ6VXNlcjg0MDM0MTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8403418?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jl2012",
      "html_url": "https://github.com/jl2012",
      "followers_url": "https://api.github.com/users/jl2012/followers",
      "following_url": "https://api.github.com/users/jl2012/following{/other_user}",
      "gists_url": "https://api.github.com/users/jl2012/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jl2012/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jl2012/subscriptions",
      "organizations_url": "https://api.github.com/users/jl2012/orgs",
      "repos_url": "https://api.github.com/users/jl2012/repos",
      "events_url": "https://api.github.com/users/jl2012/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jl2012/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "540413d9958fd253d4bf99858db431164db275e1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/540413d9958fd253d4bf99858db431164db275e1",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/540413d9958fd253d4bf99858db431164db275e1"
      }
    ],
    "stats": {
      "total": 85,
      "additions": 49,
      "deletions": 36
    },
    "files": [
      {
        "sha": "814e6c0b6ff94231f48b54830191e0ab819b1e65",
        "filename": "src/policy/policy.h",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/821f3e67510b9ea0b5c7b79d162daf5f0f075462/src/policy/policy.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/821f3e67510b9ea0b5c7b79d162daf5f0f075462/src/policy/policy.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/policy.h?ref=821f3e67510b9ea0b5c7b79d162daf5f0f075462",
        "patch": "@@ -1,5 +1,5 @@\n // Copyright (c) 2009-2010 Satoshi Nakamoto\n-// Copyright (c) 2009-2015 The Bitcoin developers\n+// Copyright (c) 2009-2016 The Bitcoin developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n@@ -54,7 +54,8 @@ static const unsigned int STANDARD_SCRIPT_VERIFY_FLAGS = MANDATORY_SCRIPT_VERIFY\n                                                          SCRIPT_VERIFY_CHECKSEQUENCEVERIFY |\n                                                          SCRIPT_VERIFY_LOW_S |\n                                                          SCRIPT_VERIFY_WITNESS |\n-                                                         SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM;\n+                                                         SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM |\n+                                                         SCRIPT_VERIFY_WITNESS_PUBKEYTYPE;\n \n /** For convenience, standard but not mandatory verify flags. */\n static const unsigned int STANDARD_NOT_MANDATORY_VERIFY_FLAGS = STANDARD_SCRIPT_VERIFY_FLAGS & ~MANDATORY_SCRIPT_VERIFY_FLAGS;"
      },
      {
        "sha": "836cf9ee352a04037b7c773abba6fccda5682720",
        "filename": "src/script/interpreter.cpp",
        "status": "modified",
        "additions": 22,
        "deletions": 6,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/821f3e67510b9ea0b5c7b79d162daf5f0f075462/src/script/interpreter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/821f3e67510b9ea0b5c7b79d162daf5f0f075462/src/script/interpreter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.cpp?ref=821f3e67510b9ea0b5c7b79d162daf5f0f075462",
        "patch": "@@ -79,8 +79,20 @@ bool static IsCompressedOrUncompressedPubKey(const valtype &vchPubKey) {\n             return false;\n         }\n     } else {\n-          //  Non-canonical public key: neither compressed nor uncompressed\n-          return false;\n+        //  Non-canonical public key: neither compressed nor uncompressed\n+        return false;\n+    }\n+    return true;\n+}\n+\n+bool static IsCompressedPubKey(const valtype &vchPubKey) {\n+    if (vchPubKey.size() != 33) {\n+        //  Non-canonical public key: invalid length for compressed key\n+        return false;\n+    }\n+    if (vchPubKey[0] != 0x02 && vchPubKey[0] != 0x03) {\n+        //  Non-canonical public key: invalid prefix for compressed key\n+        return false;\n     }\n     return true;\n }\n@@ -199,10 +211,14 @@ bool CheckSignatureEncoding(const vector<unsigned char> &vchSig, unsigned int fl\n     return true;\n }\n \n-bool static CheckPubKeyEncoding(const valtype &vchSig, unsigned int flags, ScriptError* serror) {\n-    if ((flags & SCRIPT_VERIFY_STRICTENC) != 0 && !IsCompressedOrUncompressedPubKey(vchSig)) {\n+bool static CheckPubKeyEncoding(const valtype &vchPubKey, unsigned int flags, const SigVersion &sigversion, ScriptError* serror) {\n+    if ((flags & SCRIPT_VERIFY_STRICTENC) != 0 && !IsCompressedOrUncompressedPubKey(vchPubKey)) {\n         return set_error(serror, SCRIPT_ERR_PUBKEYTYPE);\n     }\n+    // Only compressed keys are accepted in segwit\n+    if ((flags & SCRIPT_VERIFY_WITNESS_PUBKEYTYPE) != 0 && sigversion == SIGVERSION_WITNESS_V0 && !IsCompressedPubKey(vchPubKey)) {\n+        return set_error(serror, SCRIPT_ERR_WITNESS_PUBKEYTYPE);\n+    }\n     return true;\n }\n \n@@ -879,7 +895,7 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                         scriptCode.FindAndDelete(CScript(vchSig));\n                     }\n \n-                    if (!CheckSignatureEncoding(vchSig, flags, serror) || !CheckPubKeyEncoding(vchPubKey, flags, serror)) {\n+                    if (!CheckSignatureEncoding(vchSig, flags, serror) || !CheckPubKeyEncoding(vchPubKey, flags, sigversion, serror)) {\n                         //serror is set\n                         return false;\n                     }\n@@ -953,7 +969,7 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                         // Note how this makes the exact order of pubkey/signature evaluation\n                         // distinguishable by CHECKMULTISIG NOT if the STRICTENC flag is set.\n                         // See the script_(in)valid tests for details.\n-                        if (!CheckSignatureEncoding(vchSig, flags, serror) || !CheckPubKeyEncoding(vchPubKey, flags, serror)) {\n+                        if (!CheckSignatureEncoding(vchSig, flags, serror) || !CheckPubKeyEncoding(vchPubKey, flags, sigversion, serror)) {\n                             // serror is set\n                             return false;\n                         }"
      },
      {
        "sha": "79894c53003480de5a8b547ca00689f549422204",
        "filename": "src/script/interpreter.h",
        "status": "modified",
        "additions": 5,
        "deletions": 1,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/821f3e67510b9ea0b5c7b79d162daf5f0f075462/src/script/interpreter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/821f3e67510b9ea0b5c7b79d162daf5f0f075462/src/script/interpreter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.h?ref=821f3e67510b9ea0b5c7b79d162daf5f0f075462",
        "patch": "@@ -1,5 +1,5 @@\n // Copyright (c) 2009-2010 Satoshi Nakamoto\n-// Copyright (c) 2009-2015 The Bitcoin Core developers\n+// Copyright (c) 2009-2016 The Bitcoin Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n@@ -102,6 +102,10 @@ enum\n     // Signature(s) must be empty vector if an CHECK(MULTI)SIG operation failed\n     //\n     SCRIPT_VERIFY_NULLFAIL = (1U << 14),\n+\n+    // Public keys in segregated witness scripts must be compressed\n+    //\n+    SCRIPT_VERIFY_WITNESS_PUBKEYTYPE = (1U << 15),\n };\n \n bool CheckSignatureEncoding(const std::vector<unsigned char> &vchSig, unsigned int flags, ScriptError* serror);"
      },
      {
        "sha": "2c5359fe8afdb96b56d8649735d07f9fba4f7a26",
        "filename": "src/script/script_error.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/821f3e67510b9ea0b5c7b79d162daf5f0f075462/src/script/script_error.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/821f3e67510b9ea0b5c7b79d162daf5f0f075462/src/script/script_error.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script_error.cpp?ref=821f3e67510b9ea0b5c7b79d162daf5f0f075462",
        "patch": "@@ -85,6 +85,8 @@ const char* ScriptErrorString(const ScriptError serror)\n             return \"Witness requires only-redeemscript scriptSig\";\n         case SCRIPT_ERR_WITNESS_UNEXPECTED:\n             return \"Witness provided for non-witness script\";\n+        case SCRIPT_ERR_WITNESS_PUBKEYTYPE:\n+            return \"Using non-compressed keys in segwit\";\n         case SCRIPT_ERR_UNKNOWN_ERROR:\n         case SCRIPT_ERR_ERROR_COUNT:\n         default: break;"
      },
      {
        "sha": "430836991b2cf5bd7652e279263ae676cf9a6fa1",
        "filename": "src/script/script_error.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/821f3e67510b9ea0b5c7b79d162daf5f0f075462/src/script/script_error.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/821f3e67510b9ea0b5c7b79d162daf5f0f075462/src/script/script_error.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script_error.h?ref=821f3e67510b9ea0b5c7b79d162daf5f0f075462",
        "patch": "@@ -62,6 +62,7 @@ typedef enum ScriptError_t\n     SCRIPT_ERR_WITNESS_MALLEATED,\n     SCRIPT_ERR_WITNESS_MALLEATED_P2SH,\n     SCRIPT_ERR_WITNESS_UNEXPECTED,\n+    SCRIPT_ERR_WITNESS_PUBKEYTYPE,\n \n     SCRIPT_ERR_ERROR_COUNT\n } ScriptError;"
      },
      {
        "sha": "f552ad5bbad25a95443e5733fd6b114d625dbf6d",
        "filename": "src/script/sign.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 1,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/821f3e67510b9ea0b5c7b79d162daf5f0f075462/src/script/sign.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/821f3e67510b9ea0b5c7b79d162daf5f0f075462/src/script/sign.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.cpp?ref=821f3e67510b9ea0b5c7b79d162daf5f0f075462",
        "patch": "@@ -1,5 +1,5 @@\n // Copyright (c) 2009-2010 Satoshi Nakamoto\n-// Copyright (c) 2009-2015 The Bitcoin Core developers\n+// Copyright (c) 2009-2016 The Bitcoin Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n@@ -26,6 +26,10 @@ bool TransactionSignatureCreator::CreateSig(std::vector<unsigned char>& vchSig,\n     if (!keystore->GetKey(address, key))\n         return false;\n \n+    // Signing with uncompressed keys is disabled in witness scripts\n+    if (sigversion == SIGVERSION_WITNESS_V0 && !key.IsCompressed())\n+        return false;\n+\n     uint256 hash = SignatureHash(scriptCode, *txTo, nIn, nHashType, amount, sigversion);\n     if (!key.Sign(hash, vchSig))\n         return false;"
      },
      {
        "sha": "68a9991e7dc63c26f4fbede07b2349799a61af8c",
        "filename": "src/test/script_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/821f3e67510b9ea0b5c7b79d162daf5f0f075462/src/test/script_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/821f3e67510b9ea0b5c7b79d162daf5f0f075462/src/test/script_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_tests.cpp?ref=821f3e67510b9ea0b5c7b79d162daf5f0f075462",
        "patch": "@@ -99,6 +99,7 @@ static ScriptErrorDesc script_errors[]={\n     {SCRIPT_ERR_WITNESS_MALLEATED, \"WITNESS_MALLEATED\"},\n     {SCRIPT_ERR_WITNESS_MALLEATED_P2SH, \"WITNESS_MALLEATED_P2SH\"},\n     {SCRIPT_ERR_WITNESS_UNEXPECTED, \"WITNESS_UNEXPECTED\"},\n+    {SCRIPT_ERR_WITNESS_PUBKEYTYPE, \"WITNESS_PUBKEYTYPE\"},\n };\n \n const char *FormatScriptError(ScriptError_t err)"
      },
      {
        "sha": "34d9547f3dc6013189560ac68c8c6585ca2a1166",
        "filename": "src/test/transaction_tests.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 26,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/821f3e67510b9ea0b5c7b79d162daf5f0f075462/src/test/transaction_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/821f3e67510b9ea0b5c7b79d162daf5f0f075462/src/test/transaction_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/transaction_tests.cpp?ref=821f3e67510b9ea0b5c7b79d162daf5f0f075462",
        "patch": "@@ -1,4 +1,4 @@\n-// Copyright (c) 2011-2015 The Bitcoin Core developers\n+// Copyright (c) 2011-2016 The Bitcoin Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n@@ -55,7 +55,8 @@ static std::map<string, unsigned int> mapFlagNames = boost::assign::map_list_of\n     (string(\"CHECKLOCKTIMEVERIFY\"), (unsigned int)SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY)\n     (string(\"CHECKSEQUENCEVERIFY\"), (unsigned int)SCRIPT_VERIFY_CHECKSEQUENCEVERIFY)\n     (string(\"WITNESS\"), (unsigned int)SCRIPT_VERIFY_WITNESS)\n-    (string(\"DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM\"), (unsigned int)SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM);\n+    (string(\"DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM\"), (unsigned int)SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM)\n+    (string(\"WITNESS_PUBKEYTYPE\"), (unsigned int)SCRIPT_VERIFY_WITNESS_PUBKEYTYPE);\n \n unsigned int ParseScriptFlags(string strFlags)\n {\n@@ -429,7 +430,7 @@ BOOST_AUTO_TEST_CASE(test_big_witness_transaction) {\n     mtx.nVersion = 1;\n \n     CKey key;\n-    key.MakeNewKey(false);\n+    key.MakeNewKey(true); // Need to use compressed keys in segwit or the signing will fail\n     CBasicKeyStore keystore;\n     keystore.AddKeyPubKey(key, key.GetPubKey());\n     CKeyID hash = key.GetPubKey().GetID();\n@@ -625,30 +626,13 @@ BOOST_AUTO_TEST_CASE(test_witness)\n     CheckWithFlag(output1, input2, SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false);\n     CheckWithFlag(output1, input2, STANDARD_SCRIPT_VERIFY_FLAGS, false);\n \n-    // Witness pay-to-uncompressed-pubkey (v1).\n-    CreateCreditAndSpend(keystore, GetScriptForWitness(scriptPubkey1L), output1, input1);\n-    CreateCreditAndSpend(keystore, GetScriptForWitness(scriptPubkey2L), output2, input2);\n-    CheckWithFlag(output1, input1, 0, true);\n-    CheckWithFlag(output1, input1, SCRIPT_VERIFY_P2SH, true);\n-    CheckWithFlag(output1, input1, SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true);\n-    CheckWithFlag(output1, input1, STANDARD_SCRIPT_VERIFY_FLAGS, true);\n-    CheckWithFlag(output1, input2, 0, true);\n-    CheckWithFlag(output1, input2, SCRIPT_VERIFY_P2SH, true);\n-    CheckWithFlag(output1, input2, SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false);\n-    CheckWithFlag(output1, input2, STANDARD_SCRIPT_VERIFY_FLAGS, false);\n+    // Signing disabled for witness pay-to-uncompressed-pubkey (v1).\n+    CreateCreditAndSpend(keystore, GetScriptForWitness(scriptPubkey1L), output1, input1, false);\n+    CreateCreditAndSpend(keystore, GetScriptForWitness(scriptPubkey2L), output2, input2, false);\n \n-    // P2SH witness pay-to-uncompressed-pubkey (v1).\n-    CreateCreditAndSpend(keystore, GetScriptForDestination(CScriptID(GetScriptForWitness(scriptPubkey1L))), output1, input1);\n-    CreateCreditAndSpend(keystore, GetScriptForDestination(CScriptID(GetScriptForWitness(scriptPubkey2L))), output2, input2);\n-    ReplaceRedeemScript(input2.vin[0].scriptSig, GetScriptForWitness(scriptPubkey1L));\n-    CheckWithFlag(output1, input1, 0, true);\n-    CheckWithFlag(output1, input1, SCRIPT_VERIFY_P2SH, true);\n-    CheckWithFlag(output1, input1, SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true);\n-    CheckWithFlag(output1, input1, STANDARD_SCRIPT_VERIFY_FLAGS, true);\n-    CheckWithFlag(output1, input2, 0, true);\n-    CheckWithFlag(output1, input2, SCRIPT_VERIFY_P2SH, true);\n-    CheckWithFlag(output1, input2, SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false);\n-    CheckWithFlag(output1, input2, STANDARD_SCRIPT_VERIFY_FLAGS, false);\n+    // Signing disabled for P2SH witness pay-to-uncompressed-pubkey (v1).\n+    CreateCreditAndSpend(keystore, GetScriptForDestination(CScriptID(GetScriptForWitness(scriptPubkey1L))), output1, input1, false);\n+    CreateCreditAndSpend(keystore, GetScriptForDestination(CScriptID(GetScriptForWitness(scriptPubkey2L))), output2, input2, false);\n \n     // Normal 2-of-2 multisig\n     CreateCreditAndSpend(keystore, scriptMulti, output1, input1, false);"
      }
    ]
  },
  {
    "sha": "b4b85279a906605bd2d98498f5b65f4991ebffa4",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiNGI4NTI3OWE5MDY2MDViZDJkOTg0OThmNWI2NWY0OTkxZWJmZmE0",
    "commit": {
      "author": {
        "name": "Johnson Lau",
        "email": "jl2012@xbt.hk",
        "date": "2016-08-24T06:44:17Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2016-10-17T12:10:58Z"
      },
      "message": "Make test framework produce lowS signatures\n\nGithub-Pull: #8499\nRebased-From: 9f0397aff7afa2afa9328daea0a2053122e79d44",
      "tree": {
        "sha": "436f3e6f39b5f72115140e9342fe8f201ea674a9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/436f3e6f39b5f72115140e9342fe8f201ea674a9"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b4b85279a906605bd2d98498f5b65f4991ebffa4",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b4b85279a906605bd2d98498f5b65f4991ebffa4",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b4b85279a906605bd2d98498f5b65f4991ebffa4",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b4b85279a906605bd2d98498f5b65f4991ebffa4/comments",
    "author": {
      "login": "jl2012",
      "id": 8403418,
      "node_id": "MDQ6VXNlcjg0MDM0MTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8403418?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jl2012",
      "html_url": "https://github.com/jl2012",
      "followers_url": "https://api.github.com/users/jl2012/followers",
      "following_url": "https://api.github.com/users/jl2012/following{/other_user}",
      "gists_url": "https://api.github.com/users/jl2012/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jl2012/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jl2012/subscriptions",
      "organizations_url": "https://api.github.com/users/jl2012/orgs",
      "repos_url": "https://api.github.com/users/jl2012/repos",
      "events_url": "https://api.github.com/users/jl2012/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jl2012/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "821f3e67510b9ea0b5c7b79d162daf5f0f075462",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/821f3e67510b9ea0b5c7b79d162daf5f0f075462",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/821f3e67510b9ea0b5c7b79d162daf5f0f075462"
      }
    ],
    "stats": {
      "total": 25,
      "additions": 23,
      "deletions": 2
    },
    "files": [
      {
        "sha": "c63a15c1e0c92bd4a63d2b47bff4499e341cab3a",
        "filename": "qa/rpc-tests/test_framework/key.py",
        "status": "modified",
        "additions": 23,
        "deletions": 2,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b4b85279a906605bd2d98498f5b65f4991ebffa4/qa/rpc-tests/test_framework/key.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b4b85279a906605bd2d98498f5b65f4991ebffa4/qa/rpc-tests/test_framework/key.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/test_framework/key.py?ref=b4b85279a906605bd2d98498f5b65f4991ebffa4",
        "patch": "@@ -75,6 +75,9 @@\n # this specifies the curve used with ECDSA.\n NID_secp256k1 = 714 # from openssl/obj_mac.h\n \n+SECP256K1_ORDER = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\n+SECP256K1_ORDER_HALF = SECP256K1_ORDER // 2\n+\n # Thx to Sam Devlin for the ctypes magic 64-bit fix.\n def _check_result(val, func, args):\n     if val == 0:\n@@ -147,7 +150,7 @@ def get_ecdh_key(self, other_pubkey, kdf=lambda k: hashlib.sha256(k).digest()):\n         r = self.get_raw_ecdh_key(other_pubkey)\n         return kdf(r)\n \n-    def sign(self, hash):\n+    def sign(self, hash, low_s = True):\n         # FIXME: need unit tests for below cases\n         if not isinstance(hash, bytes):\n             raise TypeError('Hash must be bytes instance; got %r' % hash.__class__)\n@@ -159,7 +162,25 @@ def sign(self, hash):\n         mb_sig = ctypes.create_string_buffer(sig_size0.value)\n         result = ssl.ECDSA_sign(0, hash, len(hash), mb_sig, ctypes.byref(sig_size0), self.k)\n         assert 1 == result\n-        return mb_sig.raw[:sig_size0.value]\n+        assert mb_sig.raw[0] == 0x30\n+        assert mb_sig.raw[1] == sig_size0.value - 2\n+        total_size = mb_sig.raw[1]\n+        assert mb_sig.raw[2] == 2\n+        r_size = mb_sig.raw[3]\n+        assert mb_sig.raw[4 + r_size] == 2\n+        s_size = mb_sig.raw[5 + r_size]\n+        s_value = int.from_bytes(mb_sig.raw[6+r_size:6+r_size+s_size], byteorder='big')\n+        if (not low_s) or s_value <= SECP256K1_ORDER_HALF:\n+            return mb_sig.raw[:sig_size0.value]\n+        else:\n+            low_s_value = SECP256K1_ORDER - s_value\n+            low_s_bytes = (low_s_value).to_bytes(33, byteorder='big')\n+            while len(low_s_bytes) > 1 and low_s_bytes[0] == 0 and low_s_bytes[1] < 0x80:\n+                low_s_bytes = low_s_bytes[1:]\n+            new_s_size = len(low_s_bytes)\n+            new_total_size_byte = (total_size + new_s_size - s_size).to_bytes(1,byteorder='big')\n+            new_s_size_byte = (new_s_size).to_bytes(1,byteorder='big')\n+            return b'\\x30' + new_total_size_byte + mb_sig.raw[2:5+r_size] + new_s_size_byte + low_s_bytes\n \n     def verify(self, hash, sig):\n         \"\"\"Verify a DER signature\"\"\""
      }
    ]
  },
  {
    "sha": "908fced29600514d5fff544e429fa40ebbc58733",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5MDhmY2VkMjk2MDA1MTRkNWZmZjU0NGU0MjlmYTQwZWJiYzU4NzMz",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2016-10-06T17:15:33Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2016-10-17T12:10:58Z"
      },
      "message": "[qa] Add tests for uncompressed pubkeys in segwit\n\nGithub-Pull: #8499\nRebased-From: b811124202152424109b8e95ebe7ac25ff2e83c0",
      "tree": {
        "sha": "010d22ef25438df4bc799f73710867842f512ff9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/010d22ef25438df4bc799f73710867842f512ff9"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/908fced29600514d5fff544e429fa40ebbc58733",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/908fced29600514d5fff544e429fa40ebbc58733",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/908fced29600514d5fff544e429fa40ebbc58733",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/908fced29600514d5fff544e429fa40ebbc58733/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b4b85279a906605bd2d98498f5b65f4991ebffa4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b4b85279a906605bd2d98498f5b65f4991ebffa4",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b4b85279a906605bd2d98498f5b65f4991ebffa4"
      }
    ],
    "stats": {
      "total": 125,
      "additions": 117,
      "deletions": 8
    },
    "files": [
      {
        "sha": "864579dc47741d659d459ffe899923ba7ace45c8",
        "filename": "qa/rpc-tests/p2p-segwit.py",
        "status": "modified",
        "additions": 117,
        "deletions": 8,
        "changes": 125,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/908fced29600514d5fff544e429fa40ebbc58733/qa/rpc-tests/p2p-segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/908fced29600514d5fff544e429fa40ebbc58733/qa/rpc-tests/p2p-segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/p2p-segwit.py?ref=908fced29600514d5fff544e429fa40ebbc58733",
        "patch": "@@ -166,6 +166,17 @@ def __init__(self, sha256, n, nValue):\n         self.n = n\n         self.nValue = nValue\n \n+# Helper for getting the script associated with a P2PKH\n+def GetP2PKHScript(pubkeyhash):\n+    return CScript([CScriptOp(OP_DUP), CScriptOp(OP_HASH160), pubkeyhash, CScriptOp(OP_EQUALVERIFY), CScriptOp(OP_CHECKSIG)])\n+\n+# Add signature for a P2PK witness program.\n+def sign_P2PK_witness_input(script, txTo, inIdx, hashtype, value, key):\n+    tx_hash = SegwitVersion1SignatureHash(script, txTo, inIdx, hashtype, value)\n+    signature = key.sign(tx_hash) + chr(hashtype).encode('latin-1')\n+    txTo.wit.vtxinwit[inIdx].scriptWitness.stack = [signature, script]\n+    txTo.rehash()\n+\n \n class SegWitTest(BitcoinTestFramework):\n     def setup_chain(self):\n@@ -1320,13 +1331,6 @@ def test_signature_version_1(self):\n         sync_blocks(self.nodes)\n         self.utxo.pop(0)\n \n-        # Add signature for a P2PK witness program.\n-        def sign_P2PK_witness_input(script, txTo, inIdx, hashtype, value, key):\n-            tx_hash = SegwitVersion1SignatureHash(script, txTo, inIdx, hashtype, value)\n-            signature = key.sign(tx_hash) + chr(hashtype).encode('latin-1')\n-            txTo.wit.vtxinwit[inIdx].scriptWitness.stack = [signature, script]\n-            txTo.rehash()\n-\n         # Test each hashtype\n         prev_utxo = UTXO(tx.sha256, 0, tx.vout[0].nValue)\n         for sigflag in [ 0, SIGHASH_ANYONECANPAY ]:\n@@ -1440,7 +1444,7 @@ def sign_P2PK_witness_input(script, txTo, inIdx, hashtype, value, key):\n         tx2.vin.append(CTxIn(COutPoint(tx.sha256, 0), b\"\"))\n         tx2.vout.append(CTxOut(tx.vout[0].nValue, CScript([OP_TRUE])))\n \n-        script = CScript([CScriptOp(OP_DUP), CScriptOp(OP_HASH160), pubkeyhash, CScriptOp(OP_EQUALVERIFY), CScriptOp(OP_CHECKSIG)])\n+        script = GetP2PKHScript(pubkeyhash)\n         sig_hash = SegwitVersion1SignatureHash(script, tx2, 0, SIGHASH_ALL, tx.vout[0].nValue)\n         signature = key.sign(sig_hash) + b'\\x01' # 0x1 is SIGHASH_ALL\n \n@@ -1703,6 +1707,110 @@ def test_getblocktemplate_before_lockin(self):\n         assert(block_version & (1 << VB_WITNESS_BIT) != 0)\n         self.nodes[0].setmocktime(0) # undo mocktime\n \n+    # Uncompressed pubkeys are no longer supported in default relay policy,\n+    # but (for now) are still valid in blocks.\n+    def test_uncompressed_pubkey(self):\n+        print(\"\\tTesting uncompressed pubkeys\")\n+        # Segwit transactions using uncompressed pubkeys are not accepted\n+        # under default policy, but should still pass consensus.\n+        key = CECKey()\n+        key.set_secretbytes(b\"9\")\n+        key.set_compressed(False)\n+        pubkey = CPubKey(key.get_pubkey())\n+        assert_equal(len(pubkey), 65) # This should be an uncompressed pubkey\n+\n+        assert(len(self.utxo) > 0)\n+        utxo = self.utxo.pop(0)\n+\n+        # Test 1: P2WPKH\n+        # First create a P2WPKH output that uses an uncompressed pubkey\n+        pubkeyhash = hash160(pubkey)\n+        scriptPKH = CScript([OP_0, pubkeyhash])\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(utxo.sha256, utxo.n), b\"\"))\n+        tx.vout.append(CTxOut(utxo.nValue-1000, scriptPKH))\n+        tx.rehash()\n+\n+        # Confirm it in a block.\n+        block = self.build_next_block()\n+        self.update_witness_block_with_transactions(block, [tx])\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+        # Now try to spend it. Send it to a P2WSH output, which we'll\n+        # use in the next test.\n+        witness_program = CScript([pubkey, CScriptOp(OP_CHECKSIG)])\n+        witness_hash = sha256(witness_program)\n+        scriptWSH = CScript([OP_0, witness_hash])\n+\n+        tx2 = CTransaction()\n+        tx2.vin.append(CTxIn(COutPoint(tx.sha256, 0), b\"\"))\n+        tx2.vout.append(CTxOut(tx.vout[0].nValue-1000, scriptWSH))\n+        script = GetP2PKHScript(pubkeyhash)\n+        sig_hash = SegwitVersion1SignatureHash(script, tx2, 0, SIGHASH_ALL, tx.vout[0].nValue)\n+        signature = key.sign(sig_hash) + b'\\x01' # 0x1 is SIGHASH_ALL\n+        tx2.wit.vtxinwit.append(CTxInWitness())\n+        tx2.wit.vtxinwit[0].scriptWitness.stack = [ signature, pubkey ]\n+        tx2.rehash()\n+\n+        # Should fail policy test.\n+        self.test_node.test_transaction_acceptance(tx2, True, False, b'non-mandatory-script-verify-flag (Using non-compressed keys in segwit)')\n+        # But passes consensus.\n+        block = self.build_next_block()\n+        self.update_witness_block_with_transactions(block, [tx2])\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+        # Test 2: P2WSH\n+        # Try to spend the P2WSH output created in last test.\n+        # Send it to a P2SH(P2WSH) output, which we'll use in the next test.\n+        p2sh_witness_hash = hash160(scriptWSH)\n+        scriptP2SH = CScript([OP_HASH160, p2sh_witness_hash, OP_EQUAL])\n+        scriptSig = CScript([scriptWSH])\n+\n+        tx3 = CTransaction()\n+        tx3.vin.append(CTxIn(COutPoint(tx2.sha256, 0), b\"\"))\n+        tx3.vout.append(CTxOut(tx2.vout[0].nValue-1000, scriptP2SH))\n+        tx3.wit.vtxinwit.append(CTxInWitness())\n+        sign_P2PK_witness_input(witness_program, tx3, 0, SIGHASH_ALL, tx2.vout[0].nValue, key)\n+\n+        # Should fail policy test.\n+        self.test_node.test_transaction_acceptance(tx3, True, False, b'non-mandatory-script-verify-flag (Using non-compressed keys in segwit)')\n+        # But passes consensus.\n+        block = self.build_next_block()\n+        self.update_witness_block_with_transactions(block, [tx3])\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+        # Test 3: P2SH(P2WSH)\n+        # Try to spend the P2SH output created in the last test.\n+        # Send it to a P2PKH output, which we'll use in the next test.\n+        scriptPubKey = GetP2PKHScript(pubkeyhash)\n+        tx4 = CTransaction()\n+        tx4.vin.append(CTxIn(COutPoint(tx3.sha256, 0), scriptSig))\n+        tx4.vout.append(CTxOut(tx3.vout[0].nValue-1000, scriptPubKey))\n+        tx4.wit.vtxinwit.append(CTxInWitness())\n+        sign_P2PK_witness_input(witness_program, tx4, 0, SIGHASH_ALL, tx3.vout[0].nValue, key)\n+\n+        # Should fail policy test.\n+        self.test_node.test_transaction_acceptance(tx4, True, False, b'non-mandatory-script-verify-flag (Using non-compressed keys in segwit)')\n+        block = self.build_next_block()\n+        self.update_witness_block_with_transactions(block, [tx4])\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+        # Test 4: Uncompressed pubkeys should still be valid in non-segwit\n+        # transactions.\n+        tx5 = CTransaction()\n+        tx5.vin.append(CTxIn(COutPoint(tx4.sha256, 0), b\"\"))\n+        tx5.vout.append(CTxOut(tx4.vout[0].nValue-1000, CScript([OP_TRUE])))\n+        (sig_hash, err) = SignatureHash(scriptPubKey, tx5, 0, SIGHASH_ALL)\n+        signature = key.sign(sig_hash) + b'\\x01' # 0x1 is SIGHASH_ALL\n+        tx5.vin[0].scriptSig = CScript([signature, pubkey])\n+        tx5.rehash()\n+        # Should pass policy and consensus.\n+        self.test_node.test_transaction_acceptance(tx5, True, True)\n+        block = self.build_next_block()\n+        self.update_witness_block_with_transactions(block, [tx5])\n+        self.test_node.test_witness_block(block, accepted=True)\n+        self.utxo.append(UTXO(tx5.sha256, 0, tx5.vout[0].nValue))\n+\n     def test_non_standard_witness(self):\n         print(\"\\tTesting detection of non-standard P2WSH witness\")\n         pad = chr(1).encode('latin-1')\n@@ -1884,6 +1992,7 @@ def run_test(self):\n         self.test_standardness_v0(segwit_activated=True)\n         self.test_segwit_versions()\n         self.test_premature_coinbase_witness_spend()\n+        self.test_uncompressed_pubkey()\n         self.test_signature_version_1()\n         self.test_non_standard_witness()\n         sync_blocks(self.nodes)"
      }
    ]
  },
  {
    "sha": "4ec21e8a64f53f0fb4cef5ff26b6b3551dba70e6",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0ZWMyMWU4YTY0ZjUzZjBmYjRjZWY1ZmYyNmI2YjM1NTFkYmE3MGU2",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-10-16T16:32:36Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2016-10-17T12:10:59Z"
      },
      "message": "Fix ismine and addwitnessaddress: no uncompressed keys in segwit\n\nGithub-Pull: #8499\nRebased-From: 248f3a76a825a332e5495c5947ad283a9e5e938f",
      "tree": {
        "sha": "adff5e19c177c63de5d1394e95eab61fd3f00402",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/adff5e19c177c63de5d1394e95eab61fd3f00402"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4ec21e8a64f53f0fb4cef5ff26b6b3551dba70e6",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4ec21e8a64f53f0fb4cef5ff26b6b3551dba70e6",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4ec21e8a64f53f0fb4cef5ff26b6b3551dba70e6",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4ec21e8a64f53f0fb4cef5ff26b6b3551dba70e6/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "908fced29600514d5fff544e429fa40ebbc58733",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/908fced29600514d5fff544e429fa40ebbc58733",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/908fced29600514d5fff544e429fa40ebbc58733"
      }
    ],
    "stats": {
      "total": 90,
      "additions": 75,
      "deletions": 15
    },
    "files": [
      {
        "sha": "7467d23b2d3a20f4a655db73d0504c124f26a6a5",
        "filename": "src/script/ismine.cpp",
        "status": "modified",
        "additions": 54,
        "deletions": 8,
        "changes": 62,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4ec21e8a64f53f0fb4cef5ff26b6b3551dba70e6/src/script/ismine.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4ec21e8a64f53f0fb4cef5ff26b6b3551dba70e6/src/script/ismine.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/ismine.cpp?ref=4ec21e8a64f53f0fb4cef5ff26b6b3551dba70e6",
        "patch": "@@ -29,13 +29,25 @@ unsigned int HaveKeys(const vector<valtype>& pubkeys, const CKeyStore& keystore)\n     return nResult;\n }\n \n-isminetype IsMine(const CKeyStore &keystore, const CTxDestination& dest)\n+isminetype IsMine(const CKeyStore& keystore, const CScript& scriptPubKey, SigVersion sigversion)\n+{\n+    bool isInvalid = false;\n+    return IsMine(keystore, scriptPubKey, isInvalid, sigversion);\n+}\n+\n+isminetype IsMine(const CKeyStore& keystore, const CTxDestination& dest, SigVersion sigversion)\n+{\n+    bool isInvalid = false;\n+    return IsMine(keystore, dest, isInvalid, sigversion);\n+}\n+\n+isminetype IsMine(const CKeyStore &keystore, const CTxDestination& dest, bool& isInvalid, SigVersion sigversion)\n {\n     CScript script = GetScriptForDestination(dest);\n-    return IsMine(keystore, script);\n+    return IsMine(keystore, script, isInvalid, sigversion);\n }\n \n-isminetype IsMine(const CKeyStore &keystore, const CScript& scriptPubKey)\n+isminetype IsMine(const CKeyStore &keystore, const CScript& scriptPubKey, bool& isInvalid, SigVersion sigversion)\n {\n     vector<valtype> vSolutions;\n     txnouttype whichType;\n@@ -53,12 +65,35 @@ isminetype IsMine(const CKeyStore &keystore, const CScript& scriptPubKey)\n         break;\n     case TX_PUBKEY:\n         keyID = CPubKey(vSolutions[0]).GetID();\n+        if (sigversion != SIGVERSION_BASE && vSolutions[0].size() != 33) {\n+            isInvalid = true;\n+            return ISMINE_NO;\n+        }\n         if (keystore.HaveKey(keyID))\n             return ISMINE_SPENDABLE;\n         break;\n-    case TX_PUBKEYHASH:\n     case TX_WITNESS_V0_KEYHASH:\n+    {\n+        if (!keystore.HaveCScript(CScriptID(CScript() << OP_0 << vSolutions[0]))) {\n+            // We do not support bare witness outputs unless the P2SH version of it would be\n+            // acceptable as well. This protects against matching before segwit activates.\n+            // This also applies to the P2WSH case.\n+            break;\n+        }\n+        isminetype ret = ::IsMine(keystore, GetScriptForDestination(CKeyID(uint160(vSolutions[0]))), isInvalid, SIGVERSION_WITNESS_V0);\n+        if (ret == ISMINE_SPENDABLE || ret == ISMINE_WATCH_SOLVABLE || (ret == ISMINE_NO && isInvalid))\n+            return ret;\n+        break;\n+    }\n+    case TX_PUBKEYHASH:\n         keyID = CKeyID(uint160(vSolutions[0]));\n+        if (sigversion != SIGVERSION_BASE) {\n+            CPubKey pubkey;\n+            if (keystore.GetPubKey(keyID, pubkey) && !pubkey.IsCompressed()) {\n+                isInvalid = true;\n+                return ISMINE_NO;\n+            }\n+        }\n         if (keystore.HaveKey(keyID))\n             return ISMINE_SPENDABLE;\n         break;\n@@ -67,21 +102,24 @@ isminetype IsMine(const CKeyStore &keystore, const CScript& scriptPubKey)\n         CScriptID scriptID = CScriptID(uint160(vSolutions[0]));\n         CScript subscript;\n         if (keystore.GetCScript(scriptID, subscript)) {\n-            isminetype ret = IsMine(keystore, subscript);\n-            if (ret == ISMINE_SPENDABLE)\n+            isminetype ret = IsMine(keystore, subscript, isInvalid);\n+            if (ret == ISMINE_SPENDABLE || ret == ISMINE_WATCH_SOLVABLE || (ret == ISMINE_NO && isInvalid))\n                 return ret;\n         }\n         break;\n     }\n     case TX_WITNESS_V0_SCRIPTHASH:\n     {\n+        if (!keystore.HaveCScript(CScriptID(CScript() << OP_0 << vSolutions[0]))) {\n+            break;\n+        }\n         uint160 hash;\n         CRIPEMD160().Write(&vSolutions[0][0], vSolutions[0].size()).Finalize(hash.begin());\n         CScriptID scriptID = CScriptID(hash);\n         CScript subscript;\n         if (keystore.GetCScript(scriptID, subscript)) {\n-            isminetype ret = IsMine(keystore, subscript);\n-            if (ret == ISMINE_SPENDABLE)\n+            isminetype ret = IsMine(keystore, subscript, isInvalid, SIGVERSION_WITNESS_V0);\n+            if (ret == ISMINE_SPENDABLE || ret == ISMINE_WATCH_SOLVABLE || (ret == ISMINE_NO && isInvalid))\n                 return ret;\n         }\n         break;\n@@ -95,6 +133,14 @@ isminetype IsMine(const CKeyStore &keystore, const CScript& scriptPubKey)\n         // them) enable spend-out-from-under-you attacks, especially\n         // in shared-wallet situations.\n         vector<valtype> keys(vSolutions.begin()+1, vSolutions.begin()+vSolutions.size()-1);\n+        if (sigversion != SIGVERSION_BASE) {\n+            for (size_t i = 0; i < keys.size(); i++) {\n+                if (keys[i].size() != 33) {\n+                    isInvalid = true;\n+                    return ISMINE_NO;\n+                }\n+            }\n+        }\n         if (HaveKeys(keys, keystore) == keys.size())\n             return ISMINE_SPENDABLE;\n         break;"
      },
      {
        "sha": "ec7a620e330cb57faa81cfec09beff9c2b8b1153",
        "filename": "src/script/ismine.h",
        "status": "modified",
        "additions": 9,
        "deletions": 2,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4ec21e8a64f53f0fb4cef5ff26b6b3551dba70e6/src/script/ismine.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4ec21e8a64f53f0fb4cef5ff26b6b3551dba70e6/src/script/ismine.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/ismine.h?ref=4ec21e8a64f53f0fb4cef5ff26b6b3551dba70e6",
        "patch": "@@ -28,7 +28,14 @@ enum isminetype\n /** used for bitflags of isminetype */\n typedef uint8_t isminefilter;\n \n-isminetype IsMine(const CKeyStore& keystore, const CScript& scriptPubKey);\n-isminetype IsMine(const CKeyStore& keystore, const CTxDestination& dest);\n+/* isInvalid becomes true when the script is found invalid by consensus or policy. This will terminate the recursion\n+ * and return a ISMINE_NO immediately, as an invalid script should never be considered as \"mine\". This is needed as\n+ * different SIGVERSION may have different network rules. Currently the only use of isInvalid is indicate uncompressed\n+ * keys in SIGVERSION_WITNESS_V0 script, but could also be used in similar cases in the future\n+ */\n+isminetype IsMine(const CKeyStore& keystore, const CScript& scriptPubKey, bool& isInvalid, SigVersion = SIGVERSION_BASE);\n+isminetype IsMine(const CKeyStore& keystore, const CScript& scriptPubKey, SigVersion = SIGVERSION_BASE);\n+isminetype IsMine(const CKeyStore& keystore, const CTxDestination& dest, bool& isInvalid, SigVersion = SIGVERSION_BASE);\n+isminetype IsMine(const CKeyStore& keystore, const CTxDestination& dest, SigVersion = SIGVERSION_BASE);\n \n #endif // BITCOIN_SCRIPT_ISMINE_H"
      },
      {
        "sha": "2ad379e46bc2d4309b11a26fb79775ea934b4191",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 5,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4ec21e8a64f53f0fb4cef5ff26b6b3551dba70e6/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4ec21e8a64f53f0fb4cef5ff26b6b3551dba70e6/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=4ec21e8a64f53f0fb4cef5ff26b6b3551dba70e6",
        "patch": "@@ -1,5 +1,5 @@\n // Copyright (c) 2010 Satoshi Nakamoto\n-// Copyright (c) 2009-2015 The Bitcoin Core developers\n+// Copyright (c) 2009-2016 The Bitcoin Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n@@ -1020,9 +1020,12 @@ class Witnessifier : public boost::static_visitor<bool>\n \n     bool operator()(const CKeyID &keyID) {\n         CPubKey pubkey;\n-        if (pwalletMain && pwalletMain->GetPubKey(keyID, pubkey)) {\n-            CScript basescript;\n-            basescript << ToByteVector(pubkey) << OP_CHECKSIG;\n+        if (pwalletMain) {\n+            CScript basescript = GetScriptForDestination(keyID);\n+            isminetype typ;\n+            typ = IsMine(*pwalletMain, basescript, SIGVERSION_WITNESS_V0);\n+            if (typ != ISMINE_SPENDABLE && typ != ISMINE_WATCH_SOLVABLE)\n+                return false;\n             CScript witscript = GetScriptForWitness(basescript);\n             pwalletMain->AddCScript(witscript);\n             result = CScriptID(witscript);\n@@ -1040,6 +1043,10 @@ class Witnessifier : public boost::static_visitor<bool>\n                 result = scriptID;\n                 return true;\n             }\n+            isminetype typ;\n+            typ = IsMine(*pwalletMain, subscript, SIGVERSION_WITNESS_V0);\n+            if (typ != ISMINE_SPENDABLE && typ != ISMINE_WATCH_SOLVABLE)\n+                return false;\n             CScript witscript = GetScriptForWitness(subscript);\n             pwalletMain->AddCScript(witscript);\n             result = CScriptID(witscript);\n@@ -1085,7 +1092,7 @@ UniValue addwitnessaddress(const UniValue& params, bool fHelp)\n     CTxDestination dest = address.Get();\n     bool ret = boost::apply_visitor(w, dest);\n     if (!ret) {\n-        throw JSONRPCError(RPC_WALLET_ERROR, \"Public key or redeemscript not known to wallet\");\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Public key or redeemscript not known to wallet, or the key is uncompressed\");\n     }\n \n     pwalletMain->SetAddressBook(w.result, \"\", \"receive\");"
      }
    ]
  },
  {
    "sha": "fef7b468415e77e1876225988a177eed70418eb1",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmZWY3YjQ2ODQxNWU3N2UxODc2MjI1OTg4YTE3N2VlZDcwNDE4ZWIx",
    "commit": {
      "author": {
        "name": "Johnson Lau",
        "email": "jl2012@xbt.hk",
        "date": "2016-10-14T18:29:39Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2016-10-17T12:16:08Z"
      },
      "message": "test segwit uncompressed key fixes\n\nGithub-Pull: #8499\nRebased-From: 9260085377e89e666d0cb95b462261d7e3a9c82f",
      "tree": {
        "sha": "0f6d6e309ebce796772d68f4b6d6d1c28548c187",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0f6d6e309ebce796772d68f4b6d6d1c28548c187"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fef7b468415e77e1876225988a177eed70418eb1",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fef7b468415e77e1876225988a177eed70418eb1",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fef7b468415e77e1876225988a177eed70418eb1",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fef7b468415e77e1876225988a177eed70418eb1/comments",
    "author": {
      "login": "jl2012",
      "id": 8403418,
      "node_id": "MDQ6VXNlcjg0MDM0MTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8403418?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jl2012",
      "html_url": "https://github.com/jl2012",
      "followers_url": "https://api.github.com/users/jl2012/followers",
      "following_url": "https://api.github.com/users/jl2012/following{/other_user}",
      "gists_url": "https://api.github.com/users/jl2012/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jl2012/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jl2012/subscriptions",
      "organizations_url": "https://api.github.com/users/jl2012/orgs",
      "repos_url": "https://api.github.com/users/jl2012/repos",
      "events_url": "https://api.github.com/users/jl2012/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jl2012/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4ec21e8a64f53f0fb4cef5ff26b6b3551dba70e6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4ec21e8a64f53f0fb4cef5ff26b6b3551dba70e6",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4ec21e8a64f53f0fb4cef5ff26b6b3551dba70e6"
      }
    ],
    "stats": {
      "total": 897,
      "additions": 893,
      "deletions": 4
    },
    "files": [
      {
        "sha": "493ad2e67c84dbb962a9657655d13603479536f9",
        "filename": "qa/rpc-tests/segwit.py",
        "status": "modified",
        "additions": 359,
        "deletions": 3,
        "changes": 362,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fef7b468415e77e1876225988a177eed70418eb1/qa/rpc-tests/segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fef7b468415e77e1876225988a177eed70418eb1/qa/rpc-tests/segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/segwit.py?ref=fef7b468415e77e1876225988a177eed70418eb1",
        "patch": "@@ -9,9 +9,10 @@\n \n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import *\n-from test_framework.mininode import sha256, ripemd160\n-import os\n-import shutil\n+from test_framework.mininode import sha256, ripemd160, CTransaction, CTxIn, COutPoint, CTxOut\n+from test_framework.address import script_to_p2sh, key_to_p2pkh\n+from test_framework.script import CScript, OP_HASH160, OP_CHECKSIG, OP_0, hash160, OP_EQUAL, OP_DUP, OP_EQUALVERIFY, OP_1, OP_2, OP_CHECKMULTISIG\n+from io import BytesIO\n \n NODE_0 = 0\n NODE_1 = 1\n@@ -243,5 +244,360 @@ def run_test(self):\n             # This is an acceptable outcome\n             pass\n \n+        print(\"Verify behaviour of importaddress, addwitnessaddress and listunspent\")\n+\n+        # Some public keys to be used later\n+        pubkeys = [\n+            \"0363D44AABD0F1699138239DF2F042C3282C0671CC7A76826A55C8203D90E39242\", # cPiM8Ub4heR9NBYmgVzJQiUH1if44GSBGiqaeJySuL2BKxubvgwb\n+            \"02D3E626B3E616FC8662B489C123349FECBFC611E778E5BE739B257EAE4721E5BF\", # cPpAdHaD6VoYbW78kveN2bsvb45Q7G5PhaPApVUGwvF8VQ9brD97\n+            \"04A47F2CBCEFFA7B9BCDA184E7D5668D3DA6F9079AD41E422FA5FD7B2D458F2538A62F5BD8EC85C2477F39650BD391EA6250207065B2A81DA8B009FC891E898F0E\", # 91zqCU5B9sdWxzMt1ca3VzbtVm2YM6Hi5Rxn4UDtxEaN9C9nzXV\n+            \"02A47F2CBCEFFA7B9BCDA184E7D5668D3DA6F9079AD41E422FA5FD7B2D458F2538\", # cPQFjcVRpAUBG8BA9hzr2yEzHwKoMgLkJZBBtK9vJnvGJgMjzTbd\n+            \"036722F784214129FEB9E8129D626324F3F6716555B603FFE8300BBCB882151228\", # cQGtcm34xiLjB1v7bkRa4V3aAc9tS2UTuBZ1UnZGeSeNy627fN66\n+            \"0266A8396EE936BF6D99D17920DB21C6C7B1AB14C639D5CD72B300297E416FD2EC\", # cTW5mR5M45vHxXkeChZdtSPozrFwFgmEvTNnanCW6wrqwaCZ1X7K\n+            \"0450A38BD7F0AC212FEBA77354A9B036A32E0F7C81FC4E0C5ADCA7C549C4505D2522458C2D9AE3CEFD684E039194B72C8A10F9CB9D4764AB26FCC2718D421D3B84\", # 92h2XPssjBpsJN5CqSP7v9a7cf2kgDunBC6PDFwJHMACM1rrVBJ\n+        ]\n+\n+        # Import a compressed key and an uncompressed key, generate some multisig addresses\n+        self.nodes[0].importprivkey(\"92e6XLo5jVAVwrQKPNTs93oQco8f8sDNBcpv73Dsrs397fQtFQn\")\n+        uncompressed_spendable_address = [\"mvozP4UwyGD2mGZU4D2eMvMLPB9WkMmMQu\"]\n+        self.nodes[0].importprivkey(\"cNC8eQ5dg3mFAVePDX4ddmPYpPbw41r9bm2jd1nLJT77e6RrzTRR\")\n+        compressed_spendable_address = [\"mmWQubrDomqpgSYekvsU7HWEVjLFHAakLe\"]\n+        assert ((self.nodes[0].validateaddress(uncompressed_spendable_address[0])['iscompressed'] == False))\n+        assert ((self.nodes[0].validateaddress(compressed_spendable_address[0])['iscompressed'] == True))\n+\n+        self.nodes[0].importpubkey(pubkeys[0])\n+        compressed_solvable_address = [key_to_p2pkh(pubkeys[0])]\n+        self.nodes[0].importpubkey(pubkeys[1])\n+        compressed_solvable_address.append(key_to_p2pkh(pubkeys[1]))\n+        self.nodes[0].importpubkey(pubkeys[2])\n+        uncompressed_solvable_address = [key_to_p2pkh(pubkeys[2])]\n+\n+        spendable_anytime = []                      # These outputs should be seen anytime after importprivkey and addmultisigaddress\n+        spendable_after_importaddress = []          # These outputs should be seen after importaddress\n+        solvable_after_importaddress = []           # These outputs should be seen after importaddress but not spendable\n+        unsolvable_after_importaddress = []         # These outputs should be unsolvable after importaddress\n+        solvable_anytime = []                       # These outputs should be solvable after importpubkey\n+        unseen_anytime = []                         # These outputs should never be seen\n+\n+        uncompressed_spendable_address.append(self.nodes[0].addmultisigaddress(2, [uncompressed_spendable_address[0], compressed_spendable_address[0]]))\n+        uncompressed_spendable_address.append(self.nodes[0].addmultisigaddress(2, [uncompressed_spendable_address[0], uncompressed_spendable_address[0]]))\n+        compressed_spendable_address.append(self.nodes[0].addmultisigaddress(2, [compressed_spendable_address[0], compressed_spendable_address[0]]))\n+        uncompressed_solvable_address.append(self.nodes[0].addmultisigaddress(2, [compressed_spendable_address[0], uncompressed_solvable_address[0]]))\n+        compressed_solvable_address.append(self.nodes[0].addmultisigaddress(2, [compressed_spendable_address[0], compressed_solvable_address[0]]))\n+        compressed_solvable_address.append(self.nodes[0].addmultisigaddress(2, [compressed_solvable_address[0], compressed_solvable_address[1]]))\n+        unknown_address = [\"mtKKyoHabkk6e4ppT7NaM7THqPUt7AzPrT\", \"2NDP3jLWAFT8NDAiUa9qiE6oBt2awmMq7Dx\"]\n+\n+        # Test multisig_without_privkey\n+        # We have 2 public keys without private keys, use addmultisigaddress to add to wallet.\n+        # Money sent to P2SH of multisig of this should only be seen after importaddress with the BASE58 P2SH address.\n+\n+        multisig_without_privkey_address = self.nodes[0].addmultisigaddress(2, [pubkeys[3], pubkeys[4]])\n+        script = CScript([OP_2, hex_str_to_bytes(pubkeys[3]), hex_str_to_bytes(pubkeys[4]), OP_2, OP_CHECKMULTISIG])\n+        solvable_after_importaddress.append(CScript([OP_HASH160, hash160(script), OP_EQUAL]))\n+\n+        for i in compressed_spendable_address:\n+            v = self.nodes[0].validateaddress(i)\n+            if (v['isscript']):\n+                [bare, p2sh, p2wsh, p2sh_p2wsh] = self.p2sh_address_to_script(v)\n+                # bare and p2sh multisig with compressed keys should always be spendable\n+                spendable_anytime.extend([bare, p2sh])\n+                # P2WSH and P2SH(P2WSH) multisig with compressed keys are spendable after direct importaddress\n+                spendable_after_importaddress.extend([p2wsh, p2sh_p2wsh])\n+            else:\n+                [p2wpkh, p2sh_p2wpkh, p2pk, p2pkh, p2sh_p2pk, p2sh_p2pkh, p2wsh_p2pk, p2wsh_p2pkh, p2sh_p2wsh_p2pk, p2sh_p2wsh_p2pkh] = self.p2pkh_address_to_script(v)\n+                # normal P2PKH and P2PK with compressed keys should always be spendable\n+                spendable_anytime.extend([p2pkh, p2pk])\n+                # P2SH_P2PK, P2SH_P2PKH, and witness with compressed keys are spendable after direct importaddress\n+                spendable_after_importaddress.extend([p2wpkh, p2sh_p2wpkh, p2sh_p2pk, p2sh_p2pkh, p2wsh_p2pk, p2wsh_p2pkh, p2sh_p2wsh_p2pk, p2sh_p2wsh_p2pkh])\n+\n+        for i in uncompressed_spendable_address:\n+            v = self.nodes[0].validateaddress(i)\n+            if (v['isscript']):\n+                [bare, p2sh, p2wsh, p2sh_p2wsh] = self.p2sh_address_to_script(v)\n+                # bare and p2sh multisig with uncompressed keys should always be spendable\n+                spendable_anytime.extend([bare, p2sh])\n+                # P2WSH and P2SH(P2WSH) multisig with uncompressed keys are never seen\n+                unseen_anytime.extend([p2wsh, p2sh_p2wsh])\n+            else:\n+                [p2wpkh, p2sh_p2wpkh, p2pk, p2pkh, p2sh_p2pk, p2sh_p2pkh, p2wsh_p2pk, p2wsh_p2pkh, p2sh_p2wsh_p2pk, p2sh_p2wsh_p2pkh] = self.p2pkh_address_to_script(v)\n+                # normal P2PKH and P2PK with uncompressed keys should always be spendable\n+                spendable_anytime.extend([p2pkh, p2pk])\n+                # P2SH_P2PK and P2SH_P2PKH are spendable after direct importaddress\n+                spendable_after_importaddress.extend([p2sh_p2pk, p2sh_p2pkh])\n+                # witness with uncompressed keys are never seen\n+                unseen_anytime.extend([p2wpkh, p2sh_p2wpkh, p2wsh_p2pk, p2wsh_p2pkh, p2sh_p2wsh_p2pk, p2sh_p2wsh_p2pkh])\n+\n+        for i in compressed_solvable_address:\n+            v = self.nodes[0].validateaddress(i)\n+            if (v['isscript']):\n+                # Multisig without private is not seen after addmultisigaddress, but seen after importaddress\n+                [bare, p2sh, p2wsh, p2sh_p2wsh] = self.p2sh_address_to_script(v)\n+                solvable_after_importaddress.extend([bare, p2sh, p2wsh, p2sh_p2wsh])\n+            else:\n+                [p2wpkh, p2sh_p2wpkh, p2pk, p2pkh, p2sh_p2pk, p2sh_p2pkh, p2wsh_p2pk, p2wsh_p2pkh, p2sh_p2wsh_p2pk, p2sh_p2wsh_p2pkh] = self.p2pkh_address_to_script(v)\n+                # normal P2PKH and P2PK with compressed keys should always be seen\n+                solvable_anytime.extend([p2pkh, p2pk])\n+                # P2SH_P2PK, P2SH_P2PKH, and witness with compressed keys are seen after direct importaddress\n+                solvable_after_importaddress.extend([p2wpkh, p2sh_p2wpkh, p2sh_p2pk, p2sh_p2pkh, p2wsh_p2pk, p2wsh_p2pkh, p2sh_p2wsh_p2pk, p2sh_p2wsh_p2pkh])\n+\n+        for i in uncompressed_solvable_address:\n+            v = self.nodes[0].validateaddress(i)\n+            if (v['isscript']):\n+                [bare, p2sh, p2wsh, p2sh_p2wsh] = self.p2sh_address_to_script(v)\n+                # Base uncompressed multisig without private is not seen after addmultisigaddress, but seen after importaddress\n+                solvable_after_importaddress.extend([bare, p2sh])\n+                # P2WSH and P2SH(P2WSH) multisig with uncompressed keys are never seen\n+                unseen_anytime.extend([p2wsh, p2sh_p2wsh])\n+            else:\n+                [p2wpkh, p2sh_p2wpkh, p2pk, p2pkh, p2sh_p2pk, p2sh_p2pkh, p2wsh_p2pk, p2wsh_p2pkh, p2sh_p2wsh_p2pk, p2sh_p2wsh_p2pkh] = self.p2pkh_address_to_script(v)\n+                # normal P2PKH and P2PK with uncompressed keys should always be seen\n+                solvable_anytime.extend([p2pkh, p2pk])\n+                # P2SH_P2PK, P2SH_P2PKH with uncompressed keys are seen after direct importaddress\n+                solvable_after_importaddress.extend([p2sh_p2pk, p2sh_p2pkh])\n+                # witness with uncompressed keys are never seen\n+                unseen_anytime.extend([p2wpkh, p2sh_p2wpkh, p2wsh_p2pk, p2wsh_p2pkh, p2sh_p2wsh_p2pk, p2sh_p2wsh_p2pkh])\n+\n+        op1 = CScript([OP_1])\n+        op0 = CScript([OP_0])\n+        # 2N7MGY19ti4KDMSzRfPAssP6Pxyuxoi6jLe is the P2SH(P2PKH) version of mjoE3sSrb8ByYEvgnC3Aox86u1CHnfJA4V\n+        unsolvable_address = [\"mjoE3sSrb8ByYEvgnC3Aox86u1CHnfJA4V\", \"2N7MGY19ti4KDMSzRfPAssP6Pxyuxoi6jLe\", script_to_p2sh(op1), script_to_p2sh(op0)]\n+        unsolvable_address_key = hex_str_to_bytes(\"02341AEC7587A51CDE5279E0630A531AEA2615A9F80B17E8D9376327BAEAA59E3D\")\n+        unsolvablep2pkh = CScript([OP_DUP, OP_HASH160, hash160(unsolvable_address_key), OP_EQUALVERIFY, OP_CHECKSIG])\n+        unsolvablep2wshp2pkh = CScript([OP_0, sha256(unsolvablep2pkh)])\n+        p2shop0 = CScript([OP_HASH160, hash160(op0), OP_EQUAL])\n+        p2wshop1 = CScript([OP_0, sha256(op1)])\n+        unsolvable_after_importaddress.append(unsolvablep2pkh)\n+        unsolvable_after_importaddress.append(unsolvablep2wshp2pkh)\n+        unsolvable_after_importaddress.append(op1) # OP_1 will be imported as script\n+        unsolvable_after_importaddress.append(p2wshop1)\n+        unseen_anytime.append(op0) # OP_0 will be imported as P2SH address with no script provided\n+        unsolvable_after_importaddress.append(p2shop0)\n+\n+        spendable_txid = []\n+        solvable_txid = []\n+        spendable_txid.append(self.mine_and_test_listunspent(spendable_anytime, 2))\n+        solvable_txid.append(self.mine_and_test_listunspent(solvable_anytime, 1))\n+        self.mine_and_test_listunspent(spendable_after_importaddress + solvable_after_importaddress + unseen_anytime + unsolvable_after_importaddress, 0)\n+\n+        importlist = []\n+        for i in compressed_spendable_address + uncompressed_spendable_address + compressed_solvable_address + uncompressed_solvable_address:\n+            v = self.nodes[0].validateaddress(i)\n+            if (v['isscript']):\n+                bare = hex_str_to_bytes(v['hex'])\n+                importlist.append(bytes_to_hex_str(bare))\n+                importlist.append(bytes_to_hex_str(CScript([OP_0, sha256(bare)])))\n+            else:\n+                pubkey = hex_str_to_bytes(v['pubkey'])\n+                p2pk = CScript([pubkey, OP_CHECKSIG])\n+                p2pkh = CScript([OP_DUP, OP_HASH160, hash160(pubkey), OP_EQUALVERIFY, OP_CHECKSIG])\n+                importlist.append(bytes_to_hex_str(p2pk))\n+                importlist.append(bytes_to_hex_str(p2pkh))\n+                importlist.append(bytes_to_hex_str(CScript([OP_0, hash160(pubkey)])))\n+                importlist.append(bytes_to_hex_str(CScript([OP_0, sha256(p2pk)])))\n+                importlist.append(bytes_to_hex_str(CScript([OP_0, sha256(p2pkh)])))\n+\n+        importlist.append(bytes_to_hex_str(unsolvablep2pkh))\n+        importlist.append(bytes_to_hex_str(unsolvablep2wshp2pkh))\n+        importlist.append(bytes_to_hex_str(op1))\n+        importlist.append(bytes_to_hex_str(p2wshop1))\n+\n+        for i in importlist:\n+            try:\n+                self.nodes[0].importaddress(i,\"\",False,True)\n+            except JSONRPCException as exp:\n+                assert_equal(exp.error[\"message\"], \"The wallet already contains the private key for this address or script\")\n+\n+        self.nodes[0].importaddress(script_to_p2sh(op0)) # import OP_0 as address only\n+        self.nodes[0].importaddress(multisig_without_privkey_address) # Test multisig_without_privkey\n+\n+        spendable_txid.append(self.mine_and_test_listunspent(spendable_anytime + spendable_after_importaddress, 2))\n+        solvable_txid.append(self.mine_and_test_listunspent(solvable_anytime + solvable_after_importaddress, 1))\n+        self.mine_and_test_listunspent(unsolvable_after_importaddress, 1)\n+        self.mine_and_test_listunspent(unseen_anytime, 0)\n+\n+        # addwitnessaddress should refuse to return a witness address if an uncompressed key is used or the address is\n+        # not in the wallet\n+        # note that no witness address should be returned by unsolvable addresses\n+        # the multisig_without_privkey_address will fail because its keys were not added with importpubkey\n+        for i in uncompressed_spendable_address + uncompressed_solvable_address + unknown_address + unsolvable_address + [multisig_without_privkey_address]:\n+            try:\n+                self.nodes[0].addwitnessaddress(i)\n+            except JSONRPCException as exp:\n+                assert_equal(exp.error[\"message\"], \"Public key or redeemscript not known to wallet, or the key is uncompressed\")\n+            else:\n+                assert(False)\n+\n+        for i in compressed_spendable_address + compressed_solvable_address:\n+            witaddress = self.nodes[0].addwitnessaddress(i)\n+            # addwitnessaddress should return the same address if it is a known P2SH-witness address\n+            assert_equal(witaddress, self.nodes[0].addwitnessaddress(witaddress))\n+\n+        spendable_txid.append(self.mine_and_test_listunspent(spendable_anytime + spendable_after_importaddress, 2))\n+        solvable_txid.append(self.mine_and_test_listunspent(solvable_anytime + solvable_after_importaddress, 1))\n+        self.mine_and_test_listunspent(unsolvable_after_importaddress, 1)\n+        self.mine_and_test_listunspent(unseen_anytime, 0)\n+\n+        # Repeat some tests. This time we don't add witness scripts with importaddress\n+        # Import a compressed key and an uncompressed key, generate some multisig addresses\n+        self.nodes[0].importprivkey(\"927pw6RW8ZekycnXqBQ2JS5nPyo1yRfGNN8oq74HeddWSpafDJH\")\n+        uncompressed_spendable_address = [\"mguN2vNSCEUh6rJaXoAVwY3YZwZvEmf5xi\"]\n+        self.nodes[0].importprivkey(\"cMcrXaaUC48ZKpcyydfFo8PxHAjpsYLhdsp6nmtB3E2ER9UUHWnw\")\n+        compressed_spendable_address = [\"n1UNmpmbVUJ9ytXYXiurmGPQ3TRrXqPWKL\"]\n+\n+        self.nodes[0].importpubkey(pubkeys[5])\n+        compressed_solvable_address = [key_to_p2pkh(pubkeys[5])]\n+        self.nodes[0].importpubkey(pubkeys[6])\n+        uncompressed_solvable_address = [key_to_p2pkh(pubkeys[6])]\n+\n+        spendable_after_addwitnessaddress = []      # These outputs should be seen after importaddress\n+        solvable_after_addwitnessaddress=[]         # These outputs should be seen after importaddress but not spendable\n+        unseen_anytime = []                         # These outputs should never be seen\n+\n+        uncompressed_spendable_address.append(self.nodes[0].addmultisigaddress(2, [uncompressed_spendable_address[0], compressed_spendable_address[0]]))\n+        uncompressed_spendable_address.append(self.nodes[0].addmultisigaddress(2, [uncompressed_spendable_address[0], uncompressed_spendable_address[0]]))\n+        compressed_spendable_address.append(self.nodes[0].addmultisigaddress(2, [compressed_spendable_address[0], compressed_spendable_address[0]]))\n+        uncompressed_solvable_address.append(self.nodes[0].addmultisigaddress(2, [compressed_solvable_address[0], uncompressed_solvable_address[0]]))\n+        compressed_solvable_address.append(self.nodes[0].addmultisigaddress(2, [compressed_spendable_address[0], compressed_solvable_address[0]]))\n+\n+        premature_witaddress = []\n+\n+        for i in compressed_spendable_address:\n+            v = self.nodes[0].validateaddress(i)\n+            if (v['isscript']):\n+                [bare, p2sh, p2wsh, p2sh_p2wsh] = self.p2sh_address_to_script(v)\n+                # P2WSH and P2SH(P2WSH) multisig with compressed keys are spendable after addwitnessaddress\n+                spendable_after_addwitnessaddress.extend([p2wsh, p2sh_p2wsh])\n+                premature_witaddress.append(script_to_p2sh(p2wsh))\n+            else:\n+                [p2wpkh, p2sh_p2wpkh, p2pk, p2pkh, p2sh_p2pk, p2sh_p2pkh, p2wsh_p2pk, p2wsh_p2pkh, p2sh_p2wsh_p2pk, p2sh_p2wsh_p2pkh] = self.p2pkh_address_to_script(v)\n+                # P2WPKH, P2SH_P2WPKH are spendable after addwitnessaddress\n+                spendable_after_addwitnessaddress.extend([p2wpkh, p2sh_p2wpkh])\n+                premature_witaddress.append(script_to_p2sh(p2wpkh))\n+\n+        for i in uncompressed_spendable_address + uncompressed_solvable_address:\n+            v = self.nodes[0].validateaddress(i)\n+            if (v['isscript']):\n+                [bare, p2sh, p2wsh, p2sh_p2wsh] = self.p2sh_address_to_script(v)\n+                # P2WSH and P2SH(P2WSH) multisig with uncompressed keys are never seen\n+                unseen_anytime.extend([p2wsh, p2sh_p2wsh])\n+            else:\n+                [p2wpkh, p2sh_p2wpkh, p2pk, p2pkh, p2sh_p2pk, p2sh_p2pkh, p2wsh_p2pk, p2wsh_p2pkh, p2sh_p2wsh_p2pk, p2sh_p2wsh_p2pkh] = self.p2pkh_address_to_script(v)\n+                # P2WPKH, P2SH_P2WPKH with uncompressed keys are never seen\n+                unseen_anytime.extend([p2wpkh, p2sh_p2wpkh])\n+\n+        for i in compressed_solvable_address:\n+            v = self.nodes[0].validateaddress(i)\n+            if (v['isscript']):\n+                # P2WSH multisig without private key are seen after addwitnessaddress\n+                [bare, p2sh, p2wsh, p2sh_p2wsh] = self.p2sh_address_to_script(v)\n+                solvable_after_addwitnessaddress.extend([p2wsh, p2sh_p2wsh])\n+                premature_witaddress.append(script_to_p2sh(p2wsh))\n+            else:\n+                [p2wpkh, p2sh_p2wpkh, p2pk, p2pkh, p2sh_p2pk, p2sh_p2pkh, p2wsh_p2pk, p2wsh_p2pkh, p2sh_p2wsh_p2pk, p2sh_p2wsh_p2pkh] = self.p2pkh_address_to_script(v)\n+                # P2SH_P2PK, P2SH_P2PKH with compressed keys are seen after addwitnessaddress\n+                solvable_after_addwitnessaddress.extend([p2wpkh, p2sh_p2wpkh])\n+                premature_witaddress.append(script_to_p2sh(p2wpkh))\n+\n+        self.mine_and_test_listunspent(spendable_after_addwitnessaddress + solvable_after_addwitnessaddress + unseen_anytime, 0)\n+\n+        # addwitnessaddress should refuse to return a witness address if an uncompressed key is used\n+        # note that a multisig address returned by addmultisigaddress is not solvable until it is added with importaddress\n+        # premature_witaddress are not accepted until the script is added with addwitnessaddress first\n+        for i in uncompressed_spendable_address + uncompressed_solvable_address + premature_witaddress + [compressed_solvable_address[1]]:\n+            try:\n+                self.nodes[0].addwitnessaddress(i)\n+            except JSONRPCException as exp:\n+                assert_equal(exp.error[\"message\"], \"Public key or redeemscript not known to wallet, or the key is uncompressed\")\n+            else:\n+                assert(False)\n+\n+        # after importaddress it should pass addwitnessaddress\n+        v = self.nodes[0].validateaddress(compressed_solvable_address[1])\n+        self.nodes[0].importaddress(v['hex'],\"\",False,True)\n+        for i in compressed_spendable_address + compressed_solvable_address + premature_witaddress:\n+            witaddress = self.nodes[0].addwitnessaddress(i)\n+            assert_equal(witaddress, self.nodes[0].addwitnessaddress(witaddress))\n+\n+        spendable_txid.append(self.mine_and_test_listunspent(spendable_after_addwitnessaddress, 2))\n+        solvable_txid.append(self.mine_and_test_listunspent(solvable_after_addwitnessaddress, 1))\n+        self.mine_and_test_listunspent(unseen_anytime, 0)\n+\n+        # Check that spendable outputs are really spendable\n+        self.create_and_mine_tx_from_txids(spendable_txid)\n+\n+        # import all the private keys so solvable addresses become spendable\n+        self.nodes[0].importprivkey(\"cPiM8Ub4heR9NBYmgVzJQiUH1if44GSBGiqaeJySuL2BKxubvgwb\")\n+        self.nodes[0].importprivkey(\"cPpAdHaD6VoYbW78kveN2bsvb45Q7G5PhaPApVUGwvF8VQ9brD97\")\n+        self.nodes[0].importprivkey(\"91zqCU5B9sdWxzMt1ca3VzbtVm2YM6Hi5Rxn4UDtxEaN9C9nzXV\")\n+        self.nodes[0].importprivkey(\"cPQFjcVRpAUBG8BA9hzr2yEzHwKoMgLkJZBBtK9vJnvGJgMjzTbd\")\n+        self.nodes[0].importprivkey(\"cQGtcm34xiLjB1v7bkRa4V3aAc9tS2UTuBZ1UnZGeSeNy627fN66\")\n+        self.nodes[0].importprivkey(\"cTW5mR5M45vHxXkeChZdtSPozrFwFgmEvTNnanCW6wrqwaCZ1X7K\")\n+        self.create_and_mine_tx_from_txids(solvable_txid)\n+\n+    def mine_and_test_listunspent(self, script_list, ismine):\n+        utxo = find_unspent(self.nodes[0], 50)\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(int('0x'+utxo['txid'],0), utxo['vout'])))\n+        for i in script_list:\n+            tx.vout.append(CTxOut(10000000, i))\n+        tx.rehash()\n+        signresults = self.nodes[0].signrawtransaction(bytes_to_hex_str(tx.serialize_without_witness()))['hex']\n+        txid = self.nodes[0].sendrawtransaction(signresults, True)\n+        self.nodes[0].generate(1)\n+        sync_blocks(self.nodes)\n+        watchcount = 0\n+        spendcount = 0\n+        for i in self.nodes[0].listunspent():\n+            if (i['txid'] == txid):\n+                watchcount += 1\n+                if (i['spendable'] == True):\n+                    spendcount += 1\n+        if (ismine == 2):\n+            assert_equal(spendcount, len(script_list))\n+        elif (ismine == 1):\n+            assert_equal(watchcount, len(script_list))\n+            assert_equal(spendcount, 0)\n+        else:\n+            assert_equal(watchcount, 0)\n+        return txid\n+\n+    def p2sh_address_to_script(self,v):\n+        bare = CScript(hex_str_to_bytes(v['hex']))\n+        p2sh = CScript(hex_str_to_bytes(v['scriptPubKey']))\n+        p2wsh = CScript([OP_0, sha256(bare)])\n+        p2sh_p2wsh = CScript([OP_HASH160, hash160(p2wsh), OP_EQUAL])\n+        return([bare, p2sh, p2wsh, p2sh_p2wsh])\n+\n+    def p2pkh_address_to_script(self,v):\n+        pubkey = hex_str_to_bytes(v['pubkey'])\n+        p2wpkh = CScript([OP_0, hash160(pubkey)])\n+        p2sh_p2wpkh = CScript([OP_HASH160, hash160(p2wpkh), OP_EQUAL])\n+        p2pk = CScript([pubkey, OP_CHECKSIG])\n+        p2pkh = CScript(hex_str_to_bytes(v['scriptPubKey']))\n+        p2sh_p2pk = CScript([OP_HASH160, hash160(p2pk), OP_EQUAL])\n+        p2sh_p2pkh = CScript([OP_HASH160, hash160(p2pkh), OP_EQUAL])\n+        p2wsh_p2pk = CScript([OP_0, sha256(p2pk)])\n+        p2wsh_p2pkh = CScript([OP_0, sha256(p2pkh)])\n+        p2sh_p2wsh_p2pk = CScript([OP_HASH160, hash160(p2wsh_p2pk), OP_EQUAL])\n+        p2sh_p2wsh_p2pkh = CScript([OP_HASH160, hash160(p2wsh_p2pkh), OP_EQUAL])\n+        return [p2wpkh, p2sh_p2wpkh, p2pk, p2pkh, p2sh_p2pk, p2sh_p2pkh, p2wsh_p2pk, p2wsh_p2pkh, p2sh_p2wsh_p2pk, p2sh_p2wsh_p2pkh]\n+\n+    def create_and_mine_tx_from_txids(self, txids, success = True):\n+        tx = CTransaction()\n+        for i in txids:\n+            txtmp = CTransaction()\n+            txraw = self.nodes[0].getrawtransaction(i)\n+            f = BytesIO(hex_str_to_bytes(txraw))\n+            txtmp.deserialize(f)\n+            for j in range(len(txtmp.vout)):\n+                tx.vin.append(CTxIn(COutPoint(int('0x'+i,0), j)))\n+        tx.vout.append(CTxOut(0, CScript()))\n+        tx.rehash()\n+        signresults = self.nodes[0].signrawtransaction(bytes_to_hex_str(tx.serialize_without_witness()))['hex']\n+        self.nodes[0].sendrawtransaction(signresults, True)\n+        self.nodes[0].generate(1)\n+        sync_blocks(self.nodes)\n+\n+\n if __name__ == '__main__':\n     SegWitTest().main()"
      },
      {
        "sha": "50b999be6110d91df1730cc11961d14d5c87ccd9",
        "filename": "qa/rpc-tests/test_framework/address.py",
        "status": "added",
        "additions": 74,
        "deletions": 0,
        "changes": 74,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fef7b468415e77e1876225988a177eed70418eb1/qa/rpc-tests/test_framework/address.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fef7b468415e77e1876225988a177eed70418eb1/qa/rpc-tests/test_framework/address.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/test_framework/address.py?ref=fef7b468415e77e1876225988a177eed70418eb1",
        "patch": "@@ -0,0 +1,74 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2016 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#\n+# address.py\n+#\n+# This file encodes and decodes BASE58 P2PKH and P2SH addresses\n+#\n+\n+from .script import hash256, hash160, sha256, CScript, OP_0\n+from .util import bytes_to_hex_str, hex_str_to_bytes\n+\n+chars = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n+\n+def byte_to_base58(b, version):\n+    result = ''\n+    str = bytes_to_hex_str(b)\n+    str = bytes_to_hex_str(chr(version).encode('latin-1')) + str\n+    checksum = bytes_to_hex_str(hash256(hex_str_to_bytes(str)))\n+    str += checksum[:8]\n+    value = int('0x'+str,0)\n+    while value > 0:\n+        result = chars[value % 58] + result\n+        value //= 58\n+    while (str[:2] == '00'):\n+        result = chars[0] + result\n+        str = str[2:]\n+    return result\n+\n+# TODO: def base58_decode\n+\n+def keyhash_to_p2pkh(hash, main = False):\n+    assert (len(hash) == 20)\n+    version = 0 if main else 111\n+    return byte_to_base58(hash, version)\n+\n+def scripthash_to_p2sh(hash, main = False):\n+    assert (len(hash) == 20)\n+    version = 5 if main else 196\n+    return byte_to_base58(hash, version)\n+\n+def key_to_p2pkh(key, main = False):\n+    key = check_key(key)\n+    return keyhash_to_p2pkh(hash160(key), main)\n+\n+def script_to_p2sh(script, main = False):\n+    script = check_script(script)\n+    return scripthash_to_p2sh(hash160(script), main)\n+\n+def key_to_p2sh_p2wpkh(key, main = False):\n+    key = check_key(key)\n+    p2shscript = CScript([OP_0, hash160(key)])\n+    return script_to_p2sh(p2shscript, main)\n+\n+def script_to_p2sh_p2wsh(script, main = False):\n+    script = check_script(script)\n+    p2shscript = CScript([OP_0, sha256(script)])\n+    return script_to_p2sh(p2shscript, main)\n+\n+def check_key(key):\n+    if (type(key) is str):\n+        key = hex_str_to_bytes(key) # Assuming this is hex string\n+    if (type(key) is bytes and (len(key) == 33 or len(key) == 65)):\n+        return key\n+    assert(False)\n+\n+def check_script(script):\n+    if (type(script) is str):\n+        script = hex_str_to_bytes(script) # Assuming this is hex string\n+    if (type(script) is bytes or type(script) is CScript):\n+        return script\n+    assert(False)"
      },
      {
        "sha": "5c054ed3e8fb06939a31061e6d2fe7d09222c9a2",
        "filename": "src/test/data/script_tests.json",
        "status": "modified",
        "additions": 367,
        "deletions": 1,
        "changes": 368,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fef7b468415e77e1876225988a177eed70418eb1/src/test/data/script_tests.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fef7b468415e77e1876225988a177eed70418eb1/src/test/data/script_tests.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/data/script_tests.json?ref=fef7b468415e77e1876225988a177eed70418eb1",
        "patch": "@@ -1855,6 +1855,8 @@\n     \"OK\",\n     \"P2SH with CLEANSTACK\"\n ],\n+\n+[\"Testing with uncompressed keys in witness v0 without WITNESS_PUBKEYTYPE\"],\n [\n     [\n         \"304402200d461c140cfdfcf36b94961db57ae8c18d1cb80e9d95a9e47ac22470c1bf125502201c8dc1cbfef6a3ef90acbbb992ca22fe9466ee6f9d4898eda277a7ac3ab4b25101\",\n@@ -2139,7 +2141,371 @@\n     \"P2PK with witness\"\n ],\n \n-[\"CHECKSEQUENCEVERIFY tests\"], \n+[\"Testing with compressed keys in witness v0 with WITNESS_PUBKEYTYPE\"],\n+[\n+    [\n+        \"304402204256146fcf8e73b0fd817ffa2a4e408ff0418ff987dd08a4f485b62546f6c43c02203f3c8c3e2febc051e1222867f5f9d0eaf039d6792911c10940aa3cc74123378e01\",\n+        \"210279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798ac\",\n+        0.00000001\n+    ],\n+    \"\",\n+    \"0 0x20 0x1863143c14c5166804bd19203356da136c985678cd4d27a1b8c6329604903262\",\n+    \"P2SH,WITNESS,WITNESS_PUBKEYTYPE\",\n+    \"OK\",\n+    \"Basic P2WSH with compressed key\"\n+],\n+[\n+    [\n+        \"304402204edf27486f11432466b744df533e1acac727e0c83e5f912eb289a3df5bf8035f022075809fdd876ede40ad21667eba8b7e96394938f9c9c50f11b6a1280cce2cea8601\",\n+        \"0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798\",\n+        0.00000001\n+    ],\n+    \"\",\n+    \"0 0x14 0x751e76e8199196d454941c45d1b3a323f1433bd6\",\n+    \"P2SH,WITNESS,WITNESS_PUBKEYTYPE\",\n+    \"OK\",\n+    \"Basic P2WPKH with compressed key\"\n+],\n+[\n+    [\n+        \"304402203a549090cc46bce1e5e95c4922ea2c12747988e0207b04c42f81cdbe87bb1539022050f57a245b875fd5119c419aaf050bcdf41384f0765f04b809e5bced1fe7093d01\",\n+        \"210279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798ac\",\n+        0.00000001\n+    ],\n+    \"0x22 0x00201863143c14c5166804bd19203356da136c985678cd4d27a1b8c6329604903262\",\n+    \"HASH160 0x14 0xe4300531190587e3880d4c3004f5355d88ff928d EQUAL\",\n+    \"P2SH,WITNESS,WITNESS_PUBKEYTYPE\",\n+    \"OK\",\n+    \"Basic P2SH(P2WSH) with compressed key\"\n+],\n+[\n+    [\n+        \"304402201bc0d53046827f4a35a3166e33e3b3366c4085540dc383b95d21ed2ab11e368a0220333e78c6231214f5f8e59621e15d7eeab0d4e4d0796437e00bfbd2680c5f9c1701\",\n+        \"0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798\",\n+        0.00000001\n+    ],\n+    \"0x16 0x0014751e76e8199196d454941c45d1b3a323f1433bd6\",\n+    \"HASH160 0x14 0xbcfeb728b584253d5f3f70bcb780e9ef218a68f4 EQUAL\",\n+    \"P2SH,WITNESS,WITNESS_PUBKEYTYPE\",\n+    \"OK\",\n+    \"Basic P2SH(P2WPKH) with compressed key\"\n+],\n+\n+[\"Testing with uncompressed keys in witness v0 with WITNESS_PUBKEYTYPE\"],\n+[\n+    [\n+        \"304402200d461c140cfdfcf36b94961db57ae8c18d1cb80e9d95a9e47ac22470c1bf125502201c8dc1cbfef6a3ef90acbbb992ca22fe9466ee6f9d4898eda277a7ac3ab4b25101\",\n+        \"410479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8ac\",\n+        0.00000001\n+    ],\n+    \"\",\n+    \"0 0x20 0xb95237b48faaa69eb078e1170be3b5cbb3fddf16d0a991e14ad274f7b33a4f64\",\n+    \"P2SH,WITNESS,WITNESS_PUBKEYTYPE\",\n+    \"WITNESS_PUBKEYTYPE\",\n+    \"Basic P2WSH\"\n+],\n+[\n+    [\n+        \"304402201e7216e5ccb3b61d46946ec6cc7e8c4e0117d13ac2fd4b152197e4805191c74202203e9903e33e84d9ee1dd13fb057afb7ccfb47006c23f6a067185efbc9dd780fc501\",\n+        \"0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8\",\n+        0.00000001\n+    ],\n+    \"\",\n+    \"0 0x14 0x91b24bf9f5288532960ac687abb035127b1d28a5\",\n+    \"P2SH,WITNESS,WITNESS_PUBKEYTYPE\",\n+    \"WITNESS_PUBKEYTYPE\",\n+    \"Basic P2WPKH\"\n+],\n+[\n+    [\n+        \"3044022066e02c19a513049d49349cf5311a1b012b7c4fae023795a18ab1d91c23496c22022025e216342c8e07ce8ef51e8daee88f84306a9de66236cab230bb63067ded1ad301\",\n+        \"410479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8ac\",\n+        0.00000001\n+    ],\n+    \"0x22 0x0020b95237b48faaa69eb078e1170be3b5cbb3fddf16d0a991e14ad274f7b33a4f64\",\n+    \"HASH160 0x14 0xf386c2ba255cc56d20cfa6ea8b062f8b59945518 EQUAL\",\n+    \"P2SH,WITNESS,WITNESS_PUBKEYTYPE\",\n+    \"WITNESS_PUBKEYTYPE\",\n+    \"Basic P2SH(P2WSH)\"\n+],\n+[\n+    [\n+        \"304402200929d11561cd958460371200f82e9cae64c727a495715a31828e27a7ad57b36d0220361732ced04a6f97351ecca21a56d0b8cd4932c1da1f8f569a2b68e5e48aed7801\",\n+        \"0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8\",\n+        0.00000001\n+    ],\n+    \"0x16 0x001491b24bf9f5288532960ac687abb035127b1d28a5\",\n+    \"HASH160 0x14 0x17743beb429c55c942d2ec703b98c4d57c2df5c6 EQUAL\",\n+    \"P2SH,WITNESS,WITNESS_PUBKEYTYPE\",\n+    \"WITNESS_PUBKEYTYPE\",\n+    \"Basic P2SH(P2WPKH)\"\n+],\n+\n+[\"Testing P2WSH multisig with compressed keys\"],\n+[\n+    [\n+        \"\",\n+        \"304402207eb8a59b5c65fc3f6aeef77066556ed5c541948a53a3ba7f7c375b8eed76ee7502201e036a7a9a98ff919ff94dc905d67a1ec006f79ef7cff0708485c8bb79dce38e01\",\n+        \"5121038282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508210279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f8179852ae\",\n+        0.00000001\n+    ],\n+    \"\",\n+    \"0 0x20 0x06c24420938f0fa3c1cb2707d867154220dca365cdbfa0dd2a83854730221460\",\n+    \"P2SH,WITNESS,WITNESS_PUBKEYTYPE\",\n+    \"OK\",\n+    \"P2WSH CHECKMULTISIG with compressed keys\"\n+],\n+[\n+    [\n+        \"\",\n+        \"3044022033706aed33b8155d5486df3b9bca8cdd3bd4bdb5436dce46d72cdaba51d22b4002203626e94fe53a178af46624f17315c6931f20a30b103f5e044e1eda0c3fe185c601\",\n+        \"5121038282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508210279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f8179852ae\",\n+        0.00000001\n+    ],\n+    \"0x22 0x002006c24420938f0fa3c1cb2707d867154220dca365cdbfa0dd2a83854730221460\",\n+    \"HASH160 0x14 0x26282aad7c29369d15fed062a778b6100d31a340 EQUAL\",\n+    \"P2SH,WITNESS,WITNESS_PUBKEYTYPE\",\n+    \"OK\",\n+    \"P2SH(P2WSH) CHECKMULTISIG with compressed keys\"\n+],\n+[\n+    [\n+        \"\",\n+        \"304402204048b7371ab1c544362efb89af0c80154747d665aa4fcfb2edfd2d161e57b42e02207e043748e96637080ffc3acbd4dcc6fee1e58d30f6d1269535f32188e5ddae7301\",\n+        \"5121038282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508210279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f8179852ae\",\n+        0.00000001\n+    ],\n+    \"\",\n+    \"0 0x20 0x06c24420938f0fa3c1cb2707d867154220dca365cdbfa0dd2a83854730221460\",\n+    \"P2SH,WITNESS,WITNESS_PUBKEYTYPE\",\n+    \"OK\",\n+    \"P2WSH CHECKMULTISIG with compressed keys\"\n+],\n+[\n+    [\n+        \"\",\n+        \"3044022073902ef0b8a554c36c44cc03c1b64df96ce2914ebcf946f5bb36078fd5245cdf02205b148f1ba127065fb8c83a5a9576f2dcd111739788ed4bb3ee08b2bd3860c91c01\",\n+        \"5121038282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508210279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f8179852ae\",\n+        0.00000001\n+    ],\n+    \"0x22 0x002006c24420938f0fa3c1cb2707d867154220dca365cdbfa0dd2a83854730221460\",\n+    \"HASH160 0x14 0x26282aad7c29369d15fed062a778b6100d31a340 EQUAL\",\n+    \"P2SH,WITNESS,WITNESS_PUBKEYTYPE\",\n+    \"OK\",\n+    \"P2SH(P2WSH) CHECKMULTISIG with compressed keys\"\n+],\n+\n+[\"Testing P2WSH multisig with compressed and uncompressed keys (first key being the key closer to the top of stack)\"],\n+[\n+    [\n+        \"\",\n+        \"304402202d092ededd1f060609dbf8cb76950634ff42b3e62cf4adb69ab92397b07d742302204ff886f8d0817491a96d1daccdcc820f6feb122ee6230143303100db37dfa79f01\",\n+        \"5121038282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508410479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b852ae\",\n+        0.00000001\n+    ],\n+    \"\",\n+    \"0 0x20 0x08a6665ebfd43b02323423e764e185d98d1587f903b81507dbb69bfc41005efa\",\n+    \"P2SH,WITNESS\",\n+    \"OK\",\n+    \"P2WSH CHECKMULTISIG with first key uncompressed and signing with the first key\"\n+],\n+[\n+    [\n+        \"\",\n+        \"304402202dd7e91243f2235481ffb626c3b7baf2c859ae3a5a77fb750ef97b99a8125dc002204960de3d3c3ab9496e218ec57e5240e0e10a6f9546316fe240c216d45116d29301\",\n+        \"5121038282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508410479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b852ae\",\n+        0.00000001\n+    ],\n+    \"0x22 0x002008a6665ebfd43b02323423e764e185d98d1587f903b81507dbb69bfc41005efa\",\n+    \"HASH160 0x14 0x6f5ecd4b83b77f3c438f5214eff96454934fc5d1 EQUAL\",\n+    \"P2SH,WITNESS\",\n+    \"OK\",\n+    \"P2SH(P2WSH) CHECKMULTISIG first key uncompressed and signing with the first key\"\n+],\n+[\n+    [\n+        \"\",\n+        \"304402202d092ededd1f060609dbf8cb76950634ff42b3e62cf4adb69ab92397b07d742302204ff886f8d0817491a96d1daccdcc820f6feb122ee6230143303100db37dfa79f01\",\n+        \"5121038282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508410479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b852ae\",\n+        0.00000001\n+    ],\n+    \"\",\n+    \"0 0x20 0x08a6665ebfd43b02323423e764e185d98d1587f903b81507dbb69bfc41005efa\",\n+    \"P2SH,WITNESS,WITNESS_PUBKEYTYPE\",\n+    \"WITNESS_PUBKEYTYPE\",\n+    \"P2WSH CHECKMULTISIG with first key uncompressed and signing with the first key\"\n+],\n+[\n+    [\n+        \"\",\n+        \"304402202dd7e91243f2235481ffb626c3b7baf2c859ae3a5a77fb750ef97b99a8125dc002204960de3d3c3ab9496e218ec57e5240e0e10a6f9546316fe240c216d45116d29301\",\n+        \"5121038282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508410479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b852ae\",\n+        0.00000001\n+    ],\n+    \"0x22 0x002008a6665ebfd43b02323423e764e185d98d1587f903b81507dbb69bfc41005efa\",\n+    \"HASH160 0x14 0x6f5ecd4b83b77f3c438f5214eff96454934fc5d1 EQUAL\",\n+    \"P2SH,WITNESS,WITNESS_PUBKEYTYPE\",\n+    \"WITNESS_PUBKEYTYPE\",\n+    \"P2SH(P2WSH) CHECKMULTISIG with first key uncompressed and signing with the first key\"\n+],\n+[\n+    [\n+        \"\",\n+        \"304402201e9e6f7deef5b2f21d8223c5189b7d5e82d237c10e97165dd08f547c4e5ce6ed02206796372eb1cc6acb52e13ee2d7f45807780bf96b132cb6697f69434be74b1af901\",\n+        \"5121038282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508410479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b852ae\",\n+        0.00000001\n+    ],\n+    \"\",\n+    \"0 0x20 0x08a6665ebfd43b02323423e764e185d98d1587f903b81507dbb69bfc41005efa\",\n+    \"P2SH,WITNESS\",\n+    \"OK\",\n+    \"P2WSH CHECKMULTISIG with first key uncompressed and signing with the second key\"\n+],\n+[\n+    [\n+        \"\",\n+        \"3044022045e667f3f0f3147b95597a24babe9afecea1f649fd23637dfa7ed7e9f3ac18440220295748e81005231135289fe3a88338dabba55afa1bdb4478691337009d82b68d01\",\n+        \"5121038282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508410479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b852ae\",\n+        0.00000001\n+    ],\n+    \"0x22 0x002008a6665ebfd43b02323423e764e185d98d1587f903b81507dbb69bfc41005efa\",\n+    \"HASH160 0x14 0x6f5ecd4b83b77f3c438f5214eff96454934fc5d1 EQUAL\",\n+    \"P2SH,WITNESS\",\n+    \"OK\",\n+    \"P2SH(P2WSH) CHECKMULTISIG with first key uncompressed and signing with the second key\"\n+],\n+[\n+    [\n+        \"\",\n+        \"304402201e9e6f7deef5b2f21d8223c5189b7d5e82d237c10e97165dd08f547c4e5ce6ed02206796372eb1cc6acb52e13ee2d7f45807780bf96b132cb6697f69434be74b1af901\",\n+        \"5121038282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508410479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b852ae\",\n+        0.00000001\n+    ],\n+    \"\",\n+    \"0 0x20 0x08a6665ebfd43b02323423e764e185d98d1587f903b81507dbb69bfc41005efa\",\n+    \"P2SH,WITNESS,WITNESS_PUBKEYTYPE\",\n+    \"WITNESS_PUBKEYTYPE\",\n+    \"P2WSH CHECKMULTISIG with first key uncompressed and signing with the second key\"\n+],\n+[\n+    [\n+        \"\",\n+        \"3044022045e667f3f0f3147b95597a24babe9afecea1f649fd23637dfa7ed7e9f3ac18440220295748e81005231135289fe3a88338dabba55afa1bdb4478691337009d82b68d01\",\n+        \"5121038282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508410479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b852ae\",\n+        0.00000001\n+    ],\n+    \"0x22 0x002008a6665ebfd43b02323423e764e185d98d1587f903b81507dbb69bfc41005efa\",\n+    \"HASH160 0x14 0x6f5ecd4b83b77f3c438f5214eff96454934fc5d1 EQUAL\",\n+    \"P2SH,WITNESS,WITNESS_PUBKEYTYPE\",\n+    \"WITNESS_PUBKEYTYPE\",\n+    \"P2SH(P2WSH) CHECKMULTISIG with first key uncompressed and signing with the second key\"\n+],\n+[\n+    [\n+        \"\",\n+        \"3044022046f5367a261fd8f8d7de6eb390491344f8ec2501638fb9a1095a0599a21d3f4c02205c1b3b51d20091c5f1020841bbca87b44ebe25405c64e4acf758f2eae8665f8401\",\n+        \"5141048282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f5150811f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf210279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f8179852ae\",\n+        0.00000001\n+    ],\n+    \"\",\n+    \"0 0x20 0x230828ed48871f0f362ce9432aa52f620f442cc8d9ce7a8b5e798365595a38bb\",\n+    \"P2SH,WITNESS\",\n+    \"OK\",\n+    \"P2WSH CHECKMULTISIG with second key uncompressed and signing with the first key\"\n+],\n+[\n+    [\n+        \"\",\n+        \"3044022053e210e4fb1881e6092fd75c3efc5163105599e246ded661c0ee2b5682cc2d6c02203a26b7ada8682a095b84c6d1b881637000b47d761fc837c4cee33555296d63f101\",\n+        \"5141048282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f5150811f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf210279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f8179852ae\",\n+        0.00000001\n+    ],\n+    \"0x22 0x0020230828ed48871f0f362ce9432aa52f620f442cc8d9ce7a8b5e798365595a38bb\",\n+    \"HASH160 0x14 0x3478e7019ce61a68148f87549579b704cbe4c393 EQUAL\",\n+    \"P2SH,WITNESS\",\n+    \"OK\",\n+    \"P2SH(P2WSH) CHECKMULTISIG second key uncompressed and signing with the first key\"\n+],\n+[\n+    [\n+        \"\",\n+        \"3044022046f5367a261fd8f8d7de6eb390491344f8ec2501638fb9a1095a0599a21d3f4c02205c1b3b51d20091c5f1020841bbca87b44ebe25405c64e4acf758f2eae8665f8401\",\n+        \"5141048282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f5150811f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf210279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f8179852ae\",\n+        0.00000001\n+    ],\n+    \"\",\n+    \"0 0x20 0x230828ed48871f0f362ce9432aa52f620f442cc8d9ce7a8b5e798365595a38bb\",\n+    \"P2SH,WITNESS,WITNESS_PUBKEYTYPE\",\n+    \"OK\",\n+    \"P2WSH CHECKMULTISIG with second key uncompressed and signing with the first key should pass as the uncompressed key is not used\"\n+],\n+[\n+    [\n+        \"\",\n+        \"3044022053e210e4fb1881e6092fd75c3efc5163105599e246ded661c0ee2b5682cc2d6c02203a26b7ada8682a095b84c6d1b881637000b47d761fc837c4cee33555296d63f101\",\n+        \"5141048282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f5150811f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf210279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f8179852ae\",\n+        0.00000001\n+    ],\n+    \"0x22 0x0020230828ed48871f0f362ce9432aa52f620f442cc8d9ce7a8b5e798365595a38bb\",\n+    \"HASH160 0x14 0x3478e7019ce61a68148f87549579b704cbe4c393 EQUAL\",\n+    \"P2SH,WITNESS,WITNESS_PUBKEYTYPE\",\n+    \"OK\",\n+    \"P2SH(P2WSH) CHECKMULTISIG with second key uncompressed and signing with the first key should pass as the uncompressed key is not used\"\n+],\n+[\n+    [\n+        \"\",\n+        \"304402206c6d9f5daf85b54af2a93ec38b15ab27f205dbf5c735365ff12451e43613d1f40220736a44be63423ed5ebf53491618b7cc3d8a5093861908da853739c73717938b701\",\n+        \"5141048282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f5150811f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf210279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f8179852ae\",\n+        0.00000001\n+    ],\n+    \"\",\n+    \"0 0x20 0x230828ed48871f0f362ce9432aa52f620f442cc8d9ce7a8b5e798365595a38bb\",\n+    \"P2SH,WITNESS\",\n+    \"OK\",\n+    \"P2WSH CHECKMULTISIG with second key uncompressed and signing with the second key\"\n+],\n+[\n+    [\n+        \"\",\n+        \"30440220687871bc6144012d75baf585bb26ce13997f7d8c626f4d8825b069c3b2d064470220108936fe1c57327764782253e99090b09c203ec400ed35ce9e026ce2ecf842a001\",\n+        \"5141048282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f5150811f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf210279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f8179852ae\",\n+        0.00000001\n+    ],\n+    \"0x22 0x0020230828ed48871f0f362ce9432aa52f620f442cc8d9ce7a8b5e798365595a38bb\",\n+    \"HASH160 0x14 0x3478e7019ce61a68148f87549579b704cbe4c393 EQUAL\",\n+    \"P2SH,WITNESS\",\n+    \"OK\",\n+    \"P2SH(P2WSH) CHECKMULTISIG with second key uncompressed and signing with the second key\"\n+],\n+[\n+    [\n+        \"\",\n+        \"304402206c6d9f5daf85b54af2a93ec38b15ab27f205dbf5c735365ff12451e43613d1f40220736a44be63423ed5ebf53491618b7cc3d8a5093861908da853739c73717938b701\",\n+        \"5141048282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f5150811f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf210279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f8179852ae\",\n+        0.00000001\n+    ],\n+    \"\",\n+    \"0 0x20 0x230828ed48871f0f362ce9432aa52f620f442cc8d9ce7a8b5e798365595a38bb\",\n+    \"P2SH,WITNESS,WITNESS_PUBKEYTYPE\",\n+    \"WITNESS_PUBKEYTYPE\",\n+    \"P2WSH CHECKMULTISIG with second key uncompressed and signing with the second key\"\n+],\n+[\n+    [\n+        \"\",\n+        \"30440220687871bc6144012d75baf585bb26ce13997f7d8c626f4d8825b069c3b2d064470220108936fe1c57327764782253e99090b09c203ec400ed35ce9e026ce2ecf842a001\",\n+        \"5141048282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f5150811f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf210279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f8179852ae\",\n+        0.00000001\n+    ],\n+    \"0x22 0x0020230828ed48871f0f362ce9432aa52f620f442cc8d9ce7a8b5e798365595a38bb\",\n+    \"HASH160 0x14 0x3478e7019ce61a68148f87549579b704cbe4c393 EQUAL\",\n+    \"P2SH,WITNESS,WITNESS_PUBKEYTYPE\",\n+    \"WITNESS_PUBKEYTYPE\",\n+    \"P2SH(P2WSH) CHECKMULTISIG with second key uncompressed and signing with the second key\"\n+],\n+\n+[\"CHECKSEQUENCEVERIFY tests\"],\n [\"\", \"CHECKSEQUENCEVERIFY\", \"CHECKSEQUENCEVERIFY\", \"INVALID_STACK_OPERATION\", \"CSV automatically fails on a empty stack\"],\n [\"-1\", \"CHECKSEQUENCEVERIFY\", \"CHECKSEQUENCEVERIFY\", \"NEGATIVE_LOCKTIME\", \"CSV automatically fails if stack top is negative\"],\n [\"0x0100\", \"CHECKSEQUENCEVERIFY\", \"CHECKSEQUENCEVERIFY,MINIMALDATA\", \"UNKNOWN_ERROR\", \"CSV fails if stack top is not minimally encoded\"],"
      },
      {
        "sha": "532921a722428f3122ce8583898a733cc0eb49a3",
        "filename": "src/test/script_tests.cpp",
        "status": "modified",
        "additions": 93,
        "deletions": 0,
        "changes": 93,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fef7b468415e77e1876225988a177eed70418eb1/src/test/script_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fef7b468415e77e1876225988a177eed70418eb1/src/test/script_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_tests.cpp?ref=fef7b468415e77e1876225988a177eed70418eb1",
        "patch": "@@ -826,6 +826,99 @@ BOOST_AUTO_TEST_CASE(script_build)\n                                 \"P2PK with witness\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH\n                                ).PushSig(keys.key0).Push(\"0\").AsWit().ScriptError(SCRIPT_ERR_WITNESS_UNEXPECTED));\n \n+    // Compressed keys should pass SCRIPT_VERIFY_WITNESS_PUBKEYTYPE\n+    tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0C) << OP_CHECKSIG,\n+                                \"Basic P2WSH with compressed key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WITNESS_SH,\n+                                0, 1).PushWitSig(keys.key0C).PushWitRedeem());\n+    tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0C),\n+                                \"Basic P2WPKH with compressed key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WITNESS_PKH,\n+                                0, 1).PushWitSig(keys.key0C).Push(keys.pubkey0C).AsWit());\n+    tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0C) << OP_CHECKSIG,\n+                                \"Basic P2SH(P2WSH) with compressed key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WITNESS_SH,\n+                                0, 1).PushWitSig(keys.key0C).PushWitRedeem().PushRedeem());\n+    tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0C),\n+                                \"Basic P2SH(P2WPKH) with compressed key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WITNESS_PKH,\n+                                0, 1).PushWitSig(keys.key0C).Push(keys.pubkey0C).AsWit().PushRedeem());\n+\n+    // Testing uncompressed key in witness with SCRIPT_VERIFY_WITNESS_PUBKEYTYPE\n+    tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0) << OP_CHECKSIG,\n+                                \"Basic P2WSH\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WITNESS_SH,\n+                                0, 1).PushWitSig(keys.key0).PushWitRedeem().ScriptError(SCRIPT_ERR_WITNESS_PUBKEYTYPE));\n+    tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0),\n+                                \"Basic P2WPKH\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WITNESS_PKH,\n+                                0, 1).PushWitSig(keys.key0).Push(keys.pubkey0).AsWit().ScriptError(SCRIPT_ERR_WITNESS_PUBKEYTYPE));\n+    tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0) << OP_CHECKSIG,\n+                                \"Basic P2SH(P2WSH)\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WITNESS_SH,\n+                                0, 1).PushWitSig(keys.key0).PushWitRedeem().PushRedeem().ScriptError(SCRIPT_ERR_WITNESS_PUBKEYTYPE));\n+    tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0),\n+                                \"Basic P2SH(P2WPKH)\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WITNESS_PKH,\n+                                0, 1).PushWitSig(keys.key0).Push(keys.pubkey0).AsWit().PushRedeem().ScriptError(SCRIPT_ERR_WITNESS_PUBKEYTYPE));\n+\n+    // P2WSH 1-of-2 multisig with compressed keys\n+    tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n+                                \"P2WSH CHECKMULTISIG with compressed keys\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WITNESS_SH,\n+                                0, 1).Push(CScript()).AsWit().PushWitSig(keys.key0C).PushWitRedeem());\n+    tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n+                                \"P2SH(P2WSH) CHECKMULTISIG with compressed keys\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WITNESS_SH,\n+                                0, 1).Push(CScript()).AsWit().PushWitSig(keys.key0C).PushWitRedeem().PushRedeem());\n+    tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n+                                \"P2WSH CHECKMULTISIG with compressed keys\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WITNESS_SH,\n+                                0, 1).Push(CScript()).AsWit().PushWitSig(keys.key1C).PushWitRedeem());\n+    tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n+                                \"P2SH(P2WSH) CHECKMULTISIG with compressed keys\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WITNESS_SH,\n+                                0, 1).Push(CScript()).AsWit().PushWitSig(keys.key1C).PushWitRedeem().PushRedeem());\n+\n+    // P2WSH 1-of-2 multisig with first key uncompressed\n+    tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0) << OP_2 << OP_CHECKMULTISIG,\n+                                \"P2WSH CHECKMULTISIG with first key uncompressed and signing with the first key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_SH,\n+                                0, 1).Push(CScript()).AsWit().PushWitSig(keys.key0).PushWitRedeem());\n+    tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0) << OP_2 << OP_CHECKMULTISIG,\n+                                \"P2SH(P2WSH) CHECKMULTISIG first key uncompressed and signing with the first key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WITNESS_SH,\n+                                0, 1).Push(CScript()).AsWit().PushWitSig(keys.key0).PushWitRedeem().PushRedeem());\n+    tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0) << OP_2 << OP_CHECKMULTISIG,\n+                                \"P2WSH CHECKMULTISIG with first key uncompressed and signing with the first key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WITNESS_SH,\n+                                0, 1).Push(CScript()).AsWit().PushWitSig(keys.key0).PushWitRedeem().ScriptError(SCRIPT_ERR_WITNESS_PUBKEYTYPE));\n+    tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0) << OP_2 << OP_CHECKMULTISIG,\n+                                \"P2SH(P2WSH) CHECKMULTISIG with first key uncompressed and signing with the first key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WITNESS_SH,\n+                                0, 1).Push(CScript()).AsWit().PushWitSig(keys.key0).PushWitRedeem().PushRedeem().ScriptError(SCRIPT_ERR_WITNESS_PUBKEYTYPE));\n+    tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0) << OP_2 << OP_CHECKMULTISIG,\n+                                \"P2WSH CHECKMULTISIG with first key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_SH,\n+                                0, 1).Push(CScript()).AsWit().PushWitSig(keys.key1C).PushWitRedeem());\n+    tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0) << OP_2 << OP_CHECKMULTISIG,\n+                                \"P2SH(P2WSH) CHECKMULTISIG with first key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WITNESS_SH,\n+                                0, 1).Push(CScript()).AsWit().PushWitSig(keys.key1C).PushWitRedeem().PushRedeem());\n+    tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0) << OP_2 << OP_CHECKMULTISIG,\n+                                \"P2WSH CHECKMULTISIG with first key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WITNESS_SH,\n+                                0, 1).Push(CScript()).AsWit().PushWitSig(keys.key1C).PushWitRedeem().ScriptError(SCRIPT_ERR_WITNESS_PUBKEYTYPE));\n+    tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1C) << ToByteVector(keys.pubkey0) << OP_2 << OP_CHECKMULTISIG,\n+                                \"P2SH(P2WSH) CHECKMULTISIG with first key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WITNESS_SH,\n+                                0, 1).Push(CScript()).AsWit().PushWitSig(keys.key1C).PushWitRedeem().PushRedeem().ScriptError(SCRIPT_ERR_WITNESS_PUBKEYTYPE));\n+    // P2WSH 1-of-2 multisig with second key uncompressed\n+    tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n+                                \"P2WSH CHECKMULTISIG with second key uncompressed and signing with the first key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_SH,\n+                                0, 1).Push(CScript()).AsWit().PushWitSig(keys.key0C).PushWitRedeem());\n+    tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n+                                \"P2SH(P2WSH) CHECKMULTISIG second key uncompressed and signing with the first key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WITNESS_SH,\n+                                0, 1).Push(CScript()).AsWit().PushWitSig(keys.key0C).PushWitRedeem().PushRedeem());\n+    tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n+                                \"P2WSH CHECKMULTISIG with second key uncompressed and signing with the first key should pass as the uncompressed key is not used\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WITNESS_SH,\n+                                0, 1).Push(CScript()).AsWit().PushWitSig(keys.key0C).PushWitRedeem());\n+    tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n+                                \"P2SH(P2WSH) CHECKMULTISIG with second key uncompressed and signing with the first key should pass as the uncompressed key is not used\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WITNESS_SH,\n+                                0, 1).Push(CScript()).AsWit().PushWitSig(keys.key0C).PushWitRedeem().PushRedeem());\n+    tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n+                                \"P2WSH CHECKMULTISIG with second key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_SH,\n+                                0, 1).Push(CScript()).AsWit().PushWitSig(keys.key1).PushWitRedeem());\n+    tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n+                                \"P2SH(P2WSH) CHECKMULTISIG with second key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WITNESS_SH,\n+                                0, 1).Push(CScript()).AsWit().PushWitSig(keys.key1).PushWitRedeem().PushRedeem());\n+    tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n+                                \"P2WSH CHECKMULTISIG with second key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, false, WITNESS_SH,\n+                                0, 1).Push(CScript()).AsWit().PushWitSig(keys.key1).PushWitRedeem().ScriptError(SCRIPT_ERR_WITNESS_PUBKEYTYPE));\n+    tests.push_back(TestBuilder(CScript() << OP_1 << ToByteVector(keys.pubkey1) << ToByteVector(keys.pubkey0C) << OP_2 << OP_CHECKMULTISIG,\n+                                \"P2SH(P2WSH) CHECKMULTISIG with second key uncompressed and signing with the second key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS_PUBKEYTYPE, true, WITNESS_SH,\n+                                0, 1).Push(CScript()).AsWit().PushWitSig(keys.key1).PushWitRedeem().PushRedeem().ScriptError(SCRIPT_ERR_WITNESS_PUBKEYTYPE));\n+\n     std::set<std::string> tests_set;\n \n     {"
      }
    ]
  },
  {
    "sha": "9777fe12722ddab7b1b17df11077d448c7a25006",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5Nzc3ZmUxMjcyMmRkYWI3YjFiMTdkZjExMDc3ZDQ0OGM3YTI1MDA2",
    "commit": {
      "author": {
        "name": "Johnson Lau",
        "email": "jl2012@xbt.hk",
        "date": "2016-10-16T19:18:36Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2016-10-17T12:16:08Z"
      },
      "message": "remove redundant tests in p2p-segwit.py\n\nGithub-Pull: #8499\nRebased-From: 67d6ee1e3679504f46473fe0818970565ff3b137",
      "tree": {
        "sha": "14987e8104ac3d2426b1d16094ee5ef5dc0dd561",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/14987e8104ac3d2426b1d16094ee5ef5dc0dd561"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9777fe12722ddab7b1b17df11077d448c7a25006",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9777fe12722ddab7b1b17df11077d448c7a25006",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9777fe12722ddab7b1b17df11077d448c7a25006",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9777fe12722ddab7b1b17df11077d448c7a25006/comments",
    "author": {
      "login": "jl2012",
      "id": 8403418,
      "node_id": "MDQ6VXNlcjg0MDM0MTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8403418?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jl2012",
      "html_url": "https://github.com/jl2012",
      "followers_url": "https://api.github.com/users/jl2012/followers",
      "following_url": "https://api.github.com/users/jl2012/following{/other_user}",
      "gists_url": "https://api.github.com/users/jl2012/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jl2012/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jl2012/subscriptions",
      "organizations_url": "https://api.github.com/users/jl2012/orgs",
      "repos_url": "https://api.github.com/users/jl2012/repos",
      "events_url": "https://api.github.com/users/jl2012/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jl2012/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fef7b468415e77e1876225988a177eed70418eb1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fef7b468415e77e1876225988a177eed70418eb1",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fef7b468415e77e1876225988a177eed70418eb1"
      }
    ],
    "stats": {
      "total": 9,
      "additions": 0,
      "deletions": 9
    },
    "files": [
      {
        "sha": "7218ae83d887c06a9d669b82a06da75d159d9c69",
        "filename": "qa/rpc-tests/p2p-segwit.py",
        "status": "modified",
        "additions": 0,
        "deletions": 9,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9777fe12722ddab7b1b17df11077d448c7a25006/qa/rpc-tests/p2p-segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9777fe12722ddab7b1b17df11077d448c7a25006/qa/rpc-tests/p2p-segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/p2p-segwit.py?ref=9777fe12722ddab7b1b17df11077d448c7a25006",
        "patch": "@@ -1869,16 +1869,11 @@ def test_non_standard_witness(self):\n \n         # Stack element size over 80 bytes is non-standard\n         p2wsh_txs[1].wit.vtxinwit[0].scriptWitness.stack = [pad * 81] * 100 + [scripts[1]]\n-        # It can't be used to blind a node to the transaction\n-        self.std_node.announce_tx_and_wait_for_getdata(p2wsh_txs[1])\n-        self.std_node.test_transaction_acceptance(p2wsh_txs[1], True, False, b'bad-witness-nonstandard')\n-        self.std_node.announce_tx_and_wait_for_getdata(p2wsh_txs[1])\n         self.std_node.test_transaction_acceptance(p2wsh_txs[1], True, False, b'bad-witness-nonstandard')\n         # Non-standard nodes should accept\n         self.test_node.test_transaction_acceptance(p2wsh_txs[1], True, True)\n         # Standard nodes should accept if element size is not over 80 bytes\n         p2wsh_txs[1].wit.vtxinwit[0].scriptWitness.stack = [pad * 80] * 100 + [scripts[1]]\n-        self.std_node.announce_tx_and_wait_for_getdata(p2wsh_txs[1])\n         self.std_node.test_transaction_acceptance(p2wsh_txs[1], True, True)\n \n         # witnessScript size at 3600 bytes is standard\n@@ -1897,13 +1892,9 @@ def test_non_standard_witness(self):\n         self.std_node.test_transaction_acceptance(p2sh_txs[0], True, False, b'bad-witness-nonstandard')\n         self.test_node.test_transaction_acceptance(p2sh_txs[0], True, True)\n         p2sh_txs[1].wit.vtxinwit[0].scriptWitness.stack = [pad * 81] * 100 + [scripts[1]]\n-        self.std_node.announce_tx_and_wait_for_getdata(p2sh_txs[1])\n-        self.std_node.test_transaction_acceptance(p2sh_txs[1], True, False, b'bad-witness-nonstandard')\n-        self.std_node.announce_tx_and_wait_for_getdata(p2sh_txs[1])\n         self.std_node.test_transaction_acceptance(p2sh_txs[1], True, False, b'bad-witness-nonstandard')\n         self.test_node.test_transaction_acceptance(p2sh_txs[1], True, True)\n         p2sh_txs[1].wit.vtxinwit[0].scriptWitness.stack = [pad * 80] * 100 + [scripts[1]]\n-        self.std_node.announce_tx_and_wait_for_getdata(p2sh_txs[1])\n         self.std_node.test_transaction_acceptance(p2sh_txs[1], True, True)\n         p2sh_txs[2].wit.vtxinwit[0].scriptWitness.stack = [pad, pad, scripts[2]]\n         self.test_node.test_transaction_acceptance(p2sh_txs[2], True, True)"
      }
    ]
  }
]