[
  {
    "sha": "51ce901aa3ca8326bc3fa96e6cc95453c695d4d6",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1MWNlOTAxYWEzY2E4MzI2YmMzZmE5NmU2Y2M5NTQ1M2M2OTVkNGQ2",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-11-07T10:38:35Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-11-24T14:15:40Z"
      },
      "message": "Improve chainstate/blockindex disk writing policy\n\nThere are 3 pieces of data that are maintained on disk. The actual block\nand undo data, the block index (which can refer to positions on disk),\nand the chainstate (which refers to the best block hash).\n\nEarlier, there was no guarantee that blocks were written to disk before\nblock index entries referring to them were written. This commit introduces\ndirty flags for block index data, and delays writing entries until the actual\nblock data is flushed.\n\nWith this stricter ordering in writes, it is now safe to not always flush\nafter every block, so there is no need for the IsInitialBlockDownload()\ncheck there - instead we just write whenever enough time has passed or\nthe cache size grows too large. Also updating the wallet's best known block\nis delayed until this is done, otherwise the wallet may end up referring to an\nunknown block.\n\nIn addition, only do a write inside the block processing loop if necessary\n(because of cache size exceeded). Otherwise, move the writing to a point\nafter processing is done, after relaying.",
      "tree": {
        "sha": "96bb50b6b9ff19cd4c3ad64de004008707201234",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/96bb50b6b9ff19cd4c3ad64de004008707201234"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/51ce901aa3ca8326bc3fa96e6cc95453c695d4d6",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/51ce901aa3ca8326bc3fa96e6cc95453c695d4d6",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/51ce901aa3ca8326bc3fa96e6cc95453c695d4d6",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/51ce901aa3ca8326bc3fa96e6cc95453c695d4d6/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f24bcce2ac3e049142ff077c0de5e40a52e59b5e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f24bcce2ac3e049142ff077c0de5e40a52e59b5e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f24bcce2ac3e049142ff077c0de5e40a52e59b5e"
      }
    ],
    "stats": {
      "total": 123,
      "additions": 68,
      "deletions": 55
    },
    "files": [
      {
        "sha": "6d5ac5ab4776959108c596b6875b36d86efc20ff",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 8,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/51ce901aa3ca8326bc3fa96e6cc95453c695d4d6/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/51ce901aa3ca8326bc3fa96e6cc95453c695d4d6/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=51ce901aa3ca8326bc3fa96e6cc95453c695d4d6",
        "patch": "@@ -150,14 +150,9 @@ void Shutdown()\n \n     {\n         LOCK(cs_main);\n-#ifdef ENABLE_WALLET\n-        if (pwalletMain)\n-            pwalletMain->SetBestChain(chainActive.GetLocator());\n-#endif\n-        if (pblocktree)\n-            pblocktree->Flush();\n-        if (pcoinsTip)\n-            pcoinsTip->Flush();\n+        if (pcoinsTip != NULL) {\n+            FlushStateToDisk();\n+        }\n         delete pcoinsTip;\n         pcoinsTip = NULL;\n         delete pcoinsdbview;"
      },
      {
        "sha": "5dd27c7aa899cdec85e4debb2056a09633777feb",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 60,
        "deletions": 46,
        "changes": 106,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/51ce901aa3ca8326bc3fa96e6cc95453c695d4d6/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/51ce901aa3ca8326bc3fa96e6cc95453c695d4d6/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=51ce901aa3ca8326bc3fa96e6cc95453c695d4d6",
        "patch": "@@ -130,6 +130,12 @@ namespace {\n \n     // Number of preferrable block download peers.\n     int nPreferredDownload = 0;\n+\n+    // Dirty block index entries.\n+    set<CBlockIndex*> setDirtyBlockIndex;\n+\n+    // Dirty block file entries.\n+    set<int> setDirtyFileInfo;\n } // anon namespace\n \n //////////////////////////////////////////////////////////////////////////////\n@@ -1137,11 +1143,6 @@ bool WriteBlockToDisk(CBlock& block, CDiskBlockPos& pos)\n     pos.nPos = (unsigned int)fileOutPos;\n     fileout << block;\n \n-    // Flush stdio buffers and commit to disk before returning\n-    fflush(fileout.Get());\n-    if (!IsInitialBlockDownload())\n-        FileCommit(fileout.Get());\n-\n     return true;\n }\n \n@@ -1335,7 +1336,7 @@ void static InvalidBlockFound(CBlockIndex *pindex, const CValidationState &state\n     }\n     if (!state.CorruptionPossible()) {\n         pindex->nStatus |= BLOCK_FAILED_VALID;\n-        pblocktree->WriteBlockIndex(CDiskBlockIndex(pindex));\n+        setDirtyBlockIndex.insert(pindex);\n         setBlockIndexCandidates.erase(pindex);\n         InvalidChainFound(pindex);\n     }\n@@ -1732,10 +1733,7 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin\n         }\n \n         pindex->RaiseValidity(BLOCK_VALID_SCRIPTS);\n-\n-        CDiskBlockIndex blockindex(pindex);\n-        if (!pblocktree->WriteBlockIndex(blockindex))\n-            return state.Abort(\"Failed to write block index\");\n+        setDirtyBlockIndex.insert(pindex);\n     }\n \n     if (fTxIndex)\n@@ -1759,26 +1757,61 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin\n     return true;\n }\n \n-// Update the on-disk chain state.\n-bool static WriteChainState(CValidationState &state, bool forceWrite=false) {\n+/**\n+ * Update the on-disk chain state.\n+ * The caches and indexes are flushed if either they're too large, forceWrite is set, or\n+ * fast is not set and it's been a while since the last write.\n+ */\n+bool static FlushStateToDisk(CValidationState &state, bool fast = false, bool forceWrite = false) {\n+    LOCK(cs_main);\n     static int64_t nLastWrite = 0;\n-    if (forceWrite || pcoinsTip->GetCacheSize() > nCoinCacheSize || (!IsInitialBlockDownload() && GetTimeMicros() > nLastWrite + 600*1000000)) {\n+    if (forceWrite || pcoinsTip->GetCacheSize() > nCoinCacheSize ||\n+        (!fast && GetTimeMicros() > nLastWrite + DATABASE_WRITE_INTERVAL * 1000000)) {\n         // Typical CCoins structures on disk are around 100 bytes in size.\n         // Pushing a new one to the database can cause it to be written\n         // twice (once in the log, and once in the tables). This is already\n         // an overestimation, as most will delete an existing entry or\n         // overwrite one. Still, use a conservative safety factor of 2.\n         if (!CheckDiskSpace(100 * 2 * 2 * pcoinsTip->GetCacheSize()))\n             return state.Error(\"out of disk space\");\n+        // First make sure all block and undo data is flushed to disk.\n         FlushBlockFile();\n+        // Then update all block file information (which may refer to block and undo files).\n+        bool fileschanged = false;\n+        for (set<int>::iterator it = setDirtyFileInfo.begin(); it != setDirtyFileInfo.end(); ) {\n+            if (!pblocktree->WriteBlockFileInfo(*it, vinfoBlockFile[*it])) {\n+                return state.Abort(\"Failed to write to block index\");\n+            }\n+            fileschanged = true;\n+            setDirtyFileInfo.erase(it++);\n+        }\n+        if (fileschanged && !pblocktree->WriteLastBlockFile(nLastBlockFile)) {\n+            return state.Abort(\"Failed to write to block index\");\n+        }\n+        for (set<CBlockIndex*>::iterator it = setDirtyBlockIndex.begin(); it != setDirtyBlockIndex.end(); ) {\n+             if (!pblocktree->WriteBlockIndex(CDiskBlockIndex(*it))) {\n+                 return state.Abort(\"Failed to write to block index\");\n+             }\n+             setDirtyBlockIndex.erase(it++);\n+        }\n         pblocktree->Sync();\n+        // Finally flush the chainstate (which may refer to block index entries).\n         if (!pcoinsTip->Flush())\n             return state.Abort(\"Failed to write to coin database\");\n+        // Update best block in wallet (so we can detect restored wallets).\n+        if (forceWrite || !fast) {\n+            g_signals.SetBestChain(chainActive.GetLocator());\n+        }\n         nLastWrite = GetTimeMicros();\n     }\n     return true;\n }\n \n+void FlushStateToDisk() {\n+    CValidationState state;\n+    FlushStateToDisk(state, false, true);\n+}\n+\n // Update chainActive and related internal data structures.\n void static UpdateTip(CBlockIndex *pindexNew) {\n     chainActive.SetTip(pindexNew);\n@@ -1837,7 +1870,7 @@ bool static DisconnectTip(CValidationState &state) {\n     }\n     LogPrint(\"bench\", \"- Disconnect block: %.2fms\\n\", (GetTimeMicros() - nStart) * 0.001);\n     // Write the chain state to disk, if necessary.\n-    if (!WriteChainState(state))\n+    if (!FlushStateToDisk(state, true))\n         return false;\n     // Resurrect mempool transactions from the disconnected block.\n     BOOST_FOREACH(const CTransaction &tx, block.vtx) {\n@@ -1900,7 +1933,7 @@ bool static ConnectTip(CValidationState &state, CBlockIndex *pindexNew, CBlock *\n     int64_t nTime4 = GetTimeMicros(); nTimeFlush += nTime4 - nTime3;\n     LogPrint(\"bench\", \"  - Flush: %.2fms [%.2fs]\\n\", (nTime4 - nTime3) * 0.001, nTimeFlush * 0.000001);\n     // Write the chain state to disk, if necessary.\n-    if (!WriteChainState(state))\n+    if (!FlushStateToDisk(state, true))\n         return false;\n     int64_t nTime5 = GetTimeMicros(); nTimeChainState += nTime5 - nTime4;\n     LogPrint(\"bench\", \"  - Writing chainstate: %.2fms [%.2fs]\\n\", (nTime5 - nTime4) * 0.001, nTimeChainState * 0.000001);\n@@ -1919,10 +1952,6 @@ bool static ConnectTip(CValidationState &state, CBlockIndex *pindexNew, CBlock *\n     BOOST_FOREACH(const CTransaction &tx, pblock->vtx) {\n         SyncWithWallets(tx, pblock);\n     }\n-    // Update best block in wallet (so we can detect restored wallets)\n-    // Emit this signal after the SyncWithWallets signals as the wallet relies on that everything up to this point has been synced\n-    if ((chainActive.Height() % 20160) == 0 || ((chainActive.Height() % 144) == 0 && !IsInitialBlockDownload()))\n-        g_signals.SetBestChain(chainActive.GetLocator());\n \n     int64_t nTime6 = GetTimeMicros(); nTimePostConnect += nTime6 - nTime5; nTimeTotal += nTime6 - nTime1;\n     LogPrint(\"bench\", \"  - Connect postprocess: %.2fms [%.2fs]\\n\", (nTime6 - nTime5) * 0.001, nTimePostConnect * 0.000001);\n@@ -2043,9 +2072,6 @@ static bool ActivateBestChainStep(CValidationState &state, CBlockIndex *pindexMo\n     else\n         CheckForkWarningConditions();\n \n-    if (!pblocktree->Flush())\n-        return state.Abort(\"Failed to sync block index\");\n-\n     return true;\n }\n \n@@ -2086,11 +2112,16 @@ bool ActivateBestChain(CValidationState &state, CBlock *pblock) {\n                     if (chainActive.Height() > (pnode->nStartingHeight != -1 ? pnode->nStartingHeight - 2000 : nBlockEstimate))\n                         pnode->PushInventory(CInv(MSG_BLOCK, hashNewTip));\n             }\n-\n+            // Notify external listeners about the new tip.\n             uiInterface.NotifyBlockTip(hashNewTip);\n         }\n     } while(pindexMostWork != chainActive.Tip());\n \n+    // Write changes periodically to disk, after relay.\n+    if (!FlushStateToDisk(state)) {\n+        return false;\n+    }\n+\n     return true;\n }\n \n@@ -2123,8 +2154,7 @@ CBlockIndex* AddToBlockIndex(const CBlockHeader& block)\n     if (pindexBestHeader == NULL || pindexBestHeader->nChainWork < pindexNew->nChainWork)\n         pindexBestHeader = pindexNew;\n \n-    // Ok if it fails, we'll download the header again next time.\n-    pblocktree->WriteBlockIndex(CDiskBlockIndex(pindexNew));\n+    setDirtyBlockIndex.insert(pindexNew);\n \n     return pindexNew;\n }\n@@ -2143,6 +2173,7 @@ bool ReceivedBlockTransactions(const CBlock &block, CValidationState& state, CBl\n          LOCK(cs_nBlockSequenceId);\n          pindexNew->nSequenceId = nBlockSequenceId++;\n     }\n+    setDirtyBlockIndex.insert(pindexNew);\n \n     if (pindexNew->pprev == NULL || pindexNew->pprev->nChainTx) {\n         // If pindexNew is the genesis block or all parents are BLOCK_VALID_TRANSACTIONS.\n@@ -2162,24 +2193,18 @@ bool ReceivedBlockTransactions(const CBlock &block, CValidationState& state, CBl\n                 range.first++;\n                 mapBlocksUnlinked.erase(it);\n             }\n-            if (!pblocktree->WriteBlockIndex(CDiskBlockIndex(pindex)))\n-                return state.Abort(\"Failed to write block index\");\n         }\n     } else {\n         if (pindexNew->pprev && pindexNew->pprev->IsValid(BLOCK_VALID_TREE)) {\n             mapBlocksUnlinked.insert(std::make_pair(pindexNew->pprev, pindexNew));\n         }\n-        if (!pblocktree->WriteBlockIndex(CDiskBlockIndex(pindexNew)))\n-            return state.Abort(\"Failed to write block index\");\n     }\n \n     return true;\n }\n \n bool FindBlockPos(CValidationState &state, CDiskBlockPos &pos, unsigned int nAddSize, unsigned int nHeight, uint64_t nTime, bool fKnown = false)\n {\n-    bool fUpdatedLast = false;\n-\n     LOCK(cs_LastBlockFile);\n \n     unsigned int nFile = fKnown ? pos.nFile : nLastBlockFile;\n@@ -2195,7 +2220,6 @@ bool FindBlockPos(CValidationState &state, CDiskBlockPos &pos, unsigned int nAdd\n             if (vinfoBlockFile.size() <= nFile) {\n                 vinfoBlockFile.resize(nFile + 1);\n             }\n-            fUpdatedLast = true;\n         }\n         pos.nFile = nFile;\n         pos.nPos = vinfoBlockFile[nFile].nSize;\n@@ -2222,11 +2246,7 @@ bool FindBlockPos(CValidationState &state, CDiskBlockPos &pos, unsigned int nAdd\n         }\n     }\n \n-    if (!pblocktree->WriteBlockFileInfo(nLastBlockFile, vinfoBlockFile[nFile]))\n-        return state.Abort(\"Failed to write file info\");\n-    if (fUpdatedLast)\n-        pblocktree->WriteLastBlockFile(nLastBlockFile);\n-\n+    setDirtyFileInfo.insert(nFile);\n     return true;\n }\n \n@@ -2239,9 +2259,7 @@ bool FindUndoPos(CValidationState &state, int nFile, CDiskBlockPos &pos, unsigne\n     unsigned int nNewSize;\n     pos.nPos = vinfoBlockFile[nFile].nUndoSize;\n     nNewSize = vinfoBlockFile[nFile].nUndoSize += nAddSize;\n-    if (!pblocktree->WriteBlockFileInfo(nLastBlockFile, vinfoBlockFile[nLastBlockFile])) {\n-        return state.Abort(\"Failed to write block info\");\n-    }\n+    setDirtyFileInfo.insert(nFile);\n \n     unsigned int nOldChunks = (pos.nPos + UNDOFILE_CHUNK_SIZE - 1) / UNDOFILE_CHUNK_SIZE;\n     unsigned int nNewChunks = (nNewSize + UNDOFILE_CHUNK_SIZE - 1) / UNDOFILE_CHUNK_SIZE;\n@@ -2462,6 +2480,7 @@ bool AcceptBlock(CBlock& block, CValidationState& state, CBlockIndex** ppindex,\n     if ((!CheckBlock(block, state)) || !ContextualCheckBlock(block, state, pindex->pprev)) {\n         if (state.IsInvalid() && !state.CorruptionPossible()) {\n             pindex->nStatus |= BLOCK_FAILED_VALID;\n+            setDirtyBlockIndex.insert(pindex);\n         }\n         return false;\n     }\n@@ -3070,7 +3089,7 @@ bool InitBlockIndex() {\n             if (!ActivateBestChain(state, &block))\n                 return error(\"LoadBlockIndex() : genesis block cannot be activated\");\n             // Force a chainstate write so that when we VerifyDB in a moment, it doesnt check stale data\n-            return WriteChainState(state, true);\n+            return FlushStateToDisk(state, false, true);\n         } catch(std::runtime_error &e) {\n             return error(\"LoadBlockIndex() : failed to initialize block database: %s\", e.what());\n         }\n@@ -4641,11 +4660,6 @@ bool CBlockUndo::WriteToDisk(CDiskBlockPos &pos, const uint256 &hashBlock)\n     hasher << *this;\n     fileout << hasher.GetHash();\n \n-    // Flush stdio buffers and commit to disk before returning\n-    fflush(fileout.Get());\n-    if (!IsInitialBlockDownload())\n-        FileCommit(fileout.Get());\n-\n     return true;\n }\n "
      },
      {
        "sha": "c0d64125281f35cb0458a5026e0966074562094a",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/51ce901aa3ca8326bc3fa96e6cc95453c695d4d6/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/51ce901aa3ca8326bc3fa96e6cc95453c695d4d6/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=51ce901aa3ca8326bc3fa96e6cc95453c695d4d6",
        "patch": "@@ -94,6 +94,8 @@ static const unsigned int MAX_HEADERS_RESULTS = 2000;\n  *  degree of disordering of blocks on disk (which make reindexing and in the future perhaps pruning\n  *  harder). We'll probably want to make this a per-peer adaptive value at some point. */\n static const unsigned int BLOCK_DOWNLOAD_WINDOW = 1024;\n+/** Time to wait (in seconds) between writing blockchain state to disk. */\n+static const unsigned int DATABASE_WRITE_INTERVAL = 3600;\n \n /** \"reject\" message codes **/\n static const unsigned char REJECT_MALFORMED = 0x01;\n@@ -201,6 +203,8 @@ bool AbortNode(const std::string &msg, const std::string &userMessage=\"\");\n bool GetNodeStateStats(NodeId nodeid, CNodeStateStats &stats);\n /** Increase a node's misbehavior score. */\n void Misbehaving(NodeId nodeid, int howmuch);\n+/** Flush all state, indexes and buffers to disk. */\n+void FlushStateToDisk();\n \n \n /** (try to) add transaction to memory pool **/"
      },
      {
        "sha": "e8b0f62a830fbfbe68b954b26642a1e7df520f9e",
        "filename": "src/rpcblockchain.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/51ce901aa3ca8326bc3fa96e6cc95453c695d4d6/src/rpcblockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/51ce901aa3ca8326bc3fa96e6cc95453c695d4d6/src/rpcblockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcblockchain.cpp?ref=51ce901aa3ca8326bc3fa96e6cc95453c695d4d6",
        "patch": "@@ -319,7 +319,7 @@ Value gettxoutsetinfo(const Array& params, bool fHelp)\n     Object ret;\n \n     CCoinsStats stats;\n-    pcoinsTip->Flush();\n+    FlushStateToDisk();\n     if (pcoinsTip->GetStats(stats)) {\n         ret.push_back(Pair(\"height\", (int64_t)stats.nHeight));\n         ret.push_back(Pair(\"bestblock\", stats.hashBlock.GetHex()));"
      }
    ]
  },
  {
    "sha": "a20695001604a8aa9b7baaf52db8642b0b82b0d9",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphMjA2OTUwMDE2MDRhOGFhOWI3YmFhZjUyZGI4NjQyYjBiODJiMGQ5",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-11-14T17:19:26Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-11-24T14:15:41Z"
      },
      "message": "Introduce separate flushing modes",
      "tree": {
        "sha": "0c3c65bece93dc5a2cf9498c3cb664c3829fe48f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0c3c65bece93dc5a2cf9498c3cb664c3829fe48f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a20695001604a8aa9b7baaf52db8642b0b82b0d9",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a20695001604a8aa9b7baaf52db8642b0b82b0d9",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a20695001604a8aa9b7baaf52db8642b0b82b0d9",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a20695001604a8aa9b7baaf52db8642b0b82b0d9/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "51ce901aa3ca8326bc3fa96e6cc95453c695d4d6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/51ce901aa3ca8326bc3fa96e6cc95453c695d4d6",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/51ce901aa3ca8326bc3fa96e6cc95453c695d4d6"
      }
    ],
    "stats": {
      "total": 25,
      "additions": 16,
      "deletions": 9
    },
    "files": [
      {
        "sha": "13c568e5e33807a91a8071be0fbea03217a58544",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 9,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a20695001604a8aa9b7baaf52db8642b0b82b0d9/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a20695001604a8aa9b7baaf52db8642b0b82b0d9/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=a20695001604a8aa9b7baaf52db8642b0b82b0d9",
        "patch": "@@ -1757,16 +1757,23 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin\n     return true;\n }\n \n+enum FlushStateMode {\n+    FLUSH_STATE_IF_NEEDED,\n+    FLUSH_STATE_PERIODIC,\n+    FLUSH_STATE_ALWAYS\n+};\n+\n /**\n  * Update the on-disk chain state.\n  * The caches and indexes are flushed if either they're too large, forceWrite is set, or\n  * fast is not set and it's been a while since the last write.\n  */\n-bool static FlushStateToDisk(CValidationState &state, bool fast = false, bool forceWrite = false) {\n+bool static FlushStateToDisk(CValidationState &state, FlushStateMode mode) {\n     LOCK(cs_main);\n     static int64_t nLastWrite = 0;\n-    if (forceWrite || pcoinsTip->GetCacheSize() > nCoinCacheSize ||\n-        (!fast && GetTimeMicros() > nLastWrite + DATABASE_WRITE_INTERVAL * 1000000)) {\n+    if ((mode == FLUSH_STATE_ALWAYS) ||\n+        ((mode == FLUSH_STATE_PERIODIC || mode == FLUSH_STATE_IF_NEEDED) && pcoinsTip->GetCacheSize() > nCoinCacheSize) ||\n+        (mode == FLUSH_STATE_PERIODIC && GetTimeMicros() > nLastWrite + DATABASE_WRITE_INTERVAL * 1000000)) {\n         // Typical CCoins structures on disk are around 100 bytes in size.\n         // Pushing a new one to the database can cause it to be written\n         // twice (once in the log, and once in the tables). This is already\n@@ -1799,7 +1806,7 @@ bool static FlushStateToDisk(CValidationState &state, bool fast = false, bool fo\n         if (!pcoinsTip->Flush())\n             return state.Abort(\"Failed to write to coin database\");\n         // Update best block in wallet (so we can detect restored wallets).\n-        if (forceWrite || !fast) {\n+        if (mode != FLUSH_STATE_IF_NEEDED) {\n             g_signals.SetBestChain(chainActive.GetLocator());\n         }\n         nLastWrite = GetTimeMicros();\n@@ -1809,7 +1816,7 @@ bool static FlushStateToDisk(CValidationState &state, bool fast = false, bool fo\n \n void FlushStateToDisk() {\n     CValidationState state;\n-    FlushStateToDisk(state, false, true);\n+    FlushStateToDisk(state, FLUSH_STATE_ALWAYS);\n }\n \n // Update chainActive and related internal data structures.\n@@ -1870,7 +1877,7 @@ bool static DisconnectTip(CValidationState &state) {\n     }\n     LogPrint(\"bench\", \"- Disconnect block: %.2fms\\n\", (GetTimeMicros() - nStart) * 0.001);\n     // Write the chain state to disk, if necessary.\n-    if (!FlushStateToDisk(state, true))\n+    if (!FlushStateToDisk(state, FLUSH_STATE_IF_NEEDED))\n         return false;\n     // Resurrect mempool transactions from the disconnected block.\n     BOOST_FOREACH(const CTransaction &tx, block.vtx) {\n@@ -1933,7 +1940,7 @@ bool static ConnectTip(CValidationState &state, CBlockIndex *pindexNew, CBlock *\n     int64_t nTime4 = GetTimeMicros(); nTimeFlush += nTime4 - nTime3;\n     LogPrint(\"bench\", \"  - Flush: %.2fms [%.2fs]\\n\", (nTime4 - nTime3) * 0.001, nTimeFlush * 0.000001);\n     // Write the chain state to disk, if necessary.\n-    if (!FlushStateToDisk(state, true))\n+    if (!FlushStateToDisk(state, FLUSH_STATE_IF_NEEDED))\n         return false;\n     int64_t nTime5 = GetTimeMicros(); nTimeChainState += nTime5 - nTime4;\n     LogPrint(\"bench\", \"  - Writing chainstate: %.2fms [%.2fs]\\n\", (nTime5 - nTime4) * 0.001, nTimeChainState * 0.000001);\n@@ -2118,7 +2125,7 @@ bool ActivateBestChain(CValidationState &state, CBlock *pblock) {\n     } while(pindexMostWork != chainActive.Tip());\n \n     // Write changes periodically to disk, after relay.\n-    if (!FlushStateToDisk(state)) {\n+    if (!FlushStateToDisk(state, FLUSH_STATE_PERIODIC)) {\n         return false;\n     }\n \n@@ -3089,7 +3096,7 @@ bool InitBlockIndex() {\n             if (!ActivateBestChain(state, &block))\n                 return error(\"LoadBlockIndex() : genesis block cannot be activated\");\n             // Force a chainstate write so that when we VerifyDB in a moment, it doesnt check stale data\n-            return FlushStateToDisk(state, false, true);\n+            return FlushStateToDisk(state, FLUSH_STATE_ALWAYS);\n         } catch(std::runtime_error &e) {\n             return error(\"LoadBlockIndex() : failed to initialize block database: %s\", e.what());\n         }"
      }
    ]
  }
]