[
  {
    "sha": "8be0866883ff4efec9182194e900a05742e1b322",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4YmUwODY2ODgzZmY0ZWZlYzkxODIxOTRlOTAwYTA1NzQyZTFiMzIy",
    "commit": {
      "author": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2017-02-14T20:00:34Z"
      },
      "committer": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2017-02-16T14:05:55Z"
      },
      "message": "[qa] Simplify import-rescan.py\n\nGet rid of partial functions so the test can be more easily extended to add\nmore variants of imports with options that affect rescanning (e.g. different\nkey timestamps).\n\nAlso change the second half of the test to send /to/ the imported addresses,\ninstead of /from/ the imported addresses. The goal of this part of the test was\nto confirm that the wallet would pick up new transactions after an import\nregardless of whether or not a rescan happened during the import. But because\nthe wallet can only do this reliably for incoming transactions and not outgoing\ntransactions (which require the wallet to look up transaction inputs) the test\npreviously was less meaningful than it should have been.",
      "tree": {
        "sha": "a29c555b05eccd3c9e386d558724740e93eb8cb0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a29c555b05eccd3c9e386d558724740e93eb8cb0"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8be0866883ff4efec9182194e900a05742e1b322",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8be0866883ff4efec9182194e900a05742e1b322",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8be0866883ff4efec9182194e900a05742e1b322",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8be0866883ff4efec9182194e900a05742e1b322/comments",
    "author": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "afae75fd3dad48b7a5db72732141d421c6864b9b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/afae75fd3dad48b7a5db72732141d421c6864b9b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/afae75fd3dad48b7a5db72732141d421c6864b9b"
      }
    ],
    "stats": {
      "total": 224,
      "additions": 112,
      "deletions": 112
    },
    "files": [
      {
        "sha": "7734ad5e47e85b5366ff7de2c280f12b97be7e49",
        "filename": "qa/rpc-tests/import-rescan.py",
        "status": "modified",
        "additions": 112,
        "deletions": 112,
        "changes": 224,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8be0866883ff4efec9182194e900a05742e1b322/qa/rpc-tests/import-rescan.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8be0866883ff4efec9182194e900a05742e1b322/qa/rpc-tests/import-rescan.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/import-rescan.py?ref=8be0866883ff4efec9182194e900a05742e1b322",
        "patch": "@@ -2,6 +2,22 @@\n # Copyright (c) 2014-2016 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test rescan behavior of importaddress, importpubkey, importprivkey, and\n+importmulti RPCs with different types of keys and rescan options.\n+\n+Test uses three connected nodes.\n+\n+In the first part of the test, node 0 creates an address for each type of\n+import RPC call and sends BTC to it. Then nodes 1 and 2 import the addresses,\n+and the test makes listtransactions and getbalance calls to confirm that the\n+importing node either did or did not execute rescans picking up the send\n+transactions.\n+\n+In the second part of the test, node 0 sends more BTC to each address, and the\n+test makes more listtransactions and getbalance calls to confirm that the\n+importing nodes pick up the new transactions regardless of whether rescans\n+happened previously.\n+\"\"\"\n \n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (start_nodes, connect_nodes, sync_blocks, assert_equal)\n@@ -10,53 +26,72 @@\n import collections\n import enum\n import itertools\n-import functools\n \n Call = enum.Enum(\"Call\", \"single multi\")\n Data = enum.Enum(\"Data\", \"address pub priv\")\n-ImportNode = collections.namedtuple(\"ImportNode\", \"rescan\")\n-\n-\n-def call_import_rpc(call, data, address, scriptPubKey, pubkey, key, label, node, rescan):\n-    \"\"\"Helper that calls a wallet import RPC on a bitcoin node.\"\"\"\n-    watchonly = data != Data.priv\n-    if call == Call.single:\n-        if data == Data.address:\n-            response = node.importaddress(address, label, rescan)\n-        elif data == Data.pub:\n-            response = node.importpubkey(pubkey, label, rescan)\n-        elif data == Data.priv:\n-            response = node.importprivkey(key, label, rescan)\n-        assert_equal(response, None)\n-    elif call == Call.multi:\n-        response = node.importmulti([{\n-            \"scriptPubKey\": {\n-                \"address\": address\n-            },\n-            \"timestamp\": \"now\",\n-            \"pubkeys\": [pubkey] if data == Data.pub else [],\n-            \"keys\": [key] if data == Data.priv else [],\n-            \"label\": label,\n-            \"watchonly\": watchonly\n-        }], {\"rescan\": rescan})\n-        assert_equal(response, [{\"success\": True}])\n-    return watchonly\n-\n-\n-# List of RPCs that import a wallet key or address in various ways.\n-IMPORT_RPCS = [functools.partial(call_import_rpc, call, data) for call, data in itertools.product(Call, Data)]\n-\n-# List of bitcoind nodes that will import keys.\n-IMPORT_NODES = [\n-    ImportNode(rescan=True),\n-    ImportNode(rescan=False),\n-]\n+Rescan = enum.Enum(\"Rescan\", \"no yes\")\n+\n+\n+class Variant(collections.namedtuple(\"Variant\", \"call data rescan\")):\n+    \"\"\"Helper for importing one key and verifying scanned transactions.\"\"\"\n+\n+    def do_import(self):\n+        \"\"\"Call one key import RPC.\"\"\"\n+\n+        if self.call == Call.single:\n+            if self.data == Data.address:\n+                response = self.node.importaddress(self.address[\"address\"], self.label, self.rescan == Rescan.yes)\n+            elif self.data == Data.pub:\n+                response = self.node.importpubkey(self.address[\"pubkey\"], self.label, self.rescan == Rescan.yes)\n+            elif self.data == Data.priv:\n+                response = self.node.importprivkey(self.key, self.label, self.rescan == Rescan.yes)\n+            assert_equal(response, None)\n+        elif self.call == Call.multi:\n+            response = self.node.importmulti([{\n+                \"scriptPubKey\": {\n+                    \"address\": self.address[\"address\"]\n+                },\n+                \"timestamp\": \"now\",\n+                \"pubkeys\": [self.address[\"pubkey\"]] if self.data == Data.pub else [],\n+                \"keys\": [self.key] if self.data == Data.priv else [],\n+                \"label\": self.label,\n+                \"watchonly\": self.data != Data.priv\n+            }], {\"rescan\": self.rescan == Rescan.yes})\n+            assert_equal(response, [{\"success\": True}])\n+\n+    def check(self, txid=None, amount=None):\n+        \"\"\"Verify that getbalance/listtransactions return expected values.\"\"\"\n+\n+        balance = self.node.getbalance(self.label, 0, True)\n+        assert_equal(balance, self.expected_balance)\n+\n+        txs = self.node.listtransactions(self.label, 10000, 0, True)\n+        assert_equal(len(txs), self.expected_txs)\n+\n+        if txid is not None:\n+            tx, = [tx for tx in txs if tx[\"txid\"] == txid]\n+            assert_equal(tx[\"account\"], self.label)\n+            assert_equal(tx[\"address\"], self.address[\"address\"])\n+            assert_equal(tx[\"amount\"], amount)\n+            assert_equal(tx[\"category\"], \"receive\")\n+            assert_equal(tx[\"label\"], self.label)\n+            assert_equal(tx[\"txid\"], txid)\n+            assert_equal(tx[\"confirmations\"], 1)\n+            assert_equal(\"trusted\" not in tx, True)\n+            if self.data != Data.priv:\n+                assert_equal(tx[\"involvesWatchonly\"], True)\n+            else:\n+                assert_equal(\"involvesWatchonly\" not in tx, True)\n+\n+\n+# List of Variants for each way a key or address could be imported.\n+IMPORT_VARIANTS = [Variant(*variants) for variants in itertools.product(Call, Data, Rescan)]\n \n \n class ImportRescanTest(BitcoinTestFramework):\n     def __init__(self):\n         super().__init__()\n-        self.num_nodes = 1 + len(IMPORT_NODES)\n+        self.num_nodes = 3\n \n     def setup_network(self):\n         extra_args = [[\"-debug=1\"] for _ in range(self.num_nodes)]\n@@ -67,89 +102,54 @@ def setup_network(self):\n     def run_test(self):\n         # Create one transaction on node 0 with a unique amount and label for\n         # each possible type of wallet import RPC.\n-        import_rpc_variants = []\n-        for i, import_rpc in enumerate(IMPORT_RPCS):\n-            label = \"label{}\".format(i)\n-            addr = self.nodes[0].validateaddress(self.nodes[0].getnewaddress(label))\n-            key = self.nodes[0].dumpprivkey(addr[\"address\"])\n-            amount = 24.9375 - i * .0625\n-            txid = self.nodes[0].sendtoaddress(addr[\"address\"], amount)\n-            import_rpc = functools.partial(import_rpc, addr[\"address\"], addr[\"scriptPubKey\"], addr[\"pubkey\"], key,\n-                                           label)\n-            import_rpc_variants.append((import_rpc, label, amount, txid, addr))\n-\n+        for i, variant in enumerate(IMPORT_VARIANTS):\n+            variant.label = \"label {} {}\".format(i, variant)\n+            variant.address = self.nodes[0].validateaddress(self.nodes[0].getnewaddress(variant.label))\n+            variant.key = self.nodes[0].dumpprivkey(variant.address[\"address\"])\n+            variant.initial_amount = 25 - (i + 1) / 4.0\n+            variant.initial_txid = self.nodes[0].sendtoaddress(variant.address[\"address\"], variant.initial_amount)\n+\n+        # Generate a block containing the initial transactions.\n         self.nodes[0].generate(1)\n         assert_equal(self.nodes[0].getrawmempool(), [])\n         sync_blocks(self.nodes)\n \n-        # For each importing node and variation of wallet import RPC, invoke\n-        # the RPC and check the results from getbalance and listtransactions.\n-        for node, import_node in zip(self.nodes[1:], IMPORT_NODES):\n-            for import_rpc, label, amount, txid, addr in import_rpc_variants:\n-                watchonly = import_rpc(node, import_node.rescan)\n-\n-                balance = node.getbalance(label, 0, True)\n-                if import_node.rescan:\n-                    assert_equal(balance, amount)\n-                else:\n-                    assert_equal(balance, 0)\n-\n-                txs = node.listtransactions(label, 10000, 0, True)\n-                if import_node.rescan:\n-                    assert_equal(len(txs), 1)\n-                    assert_equal(txs[0][\"account\"], label)\n-                    assert_equal(txs[0][\"address\"], addr[\"address\"])\n-                    assert_equal(txs[0][\"amount\"], amount)\n-                    assert_equal(txs[0][\"category\"], \"receive\")\n-                    assert_equal(txs[0][\"label\"], label)\n-                    assert_equal(txs[0][\"txid\"], txid)\n-                    assert_equal(txs[0][\"confirmations\"], 1)\n-                    assert_equal(\"trusted\" not in txs[0], True)\n-                    if watchonly:\n-                        assert_equal(txs[0][\"involvesWatchonly\"], True)\n-                    else:\n-                        assert_equal(\"involvesWatchonly\" not in txs[0], True)\n-                else:\n-                    assert_equal(len(txs), 0)\n-\n-        # Create spends for all the imported addresses.\n-        spend_txids = []\n+        # For each variation of wallet key import, invoke the import RPC and\n+        # check the results from getbalance and listtransactions. Import to\n+        # node 1 if rescanning is expected, and to node 2 if rescanning is not\n+        # expected. Node 2 is reserved for imports that do not cause rescans,\n+        # so later import calls don't inadvertently cause the wallet to pick up\n+        # transactions from earlier import calls where a rescan was not\n+        # expected (this would make it complicated to figure out expected\n+        # balances in the second part of the test.)\n+        for variant in IMPORT_VARIANTS:\n+            variant.node = self.nodes[1 if variant.rescan == Rescan.yes else 2]\n+            variant.do_import()\n+            if variant.rescan == Rescan.yes:\n+                variant.expected_balance = variant.initial_amount\n+                variant.expected_txs = 1\n+                variant.check(variant.initial_txid, variant.initial_amount)\n+            else:\n+                variant.expected_balance = 0\n+                variant.expected_txs = 0\n+                variant.check()\n+\n+        # Create new transactions sending to each address.\n         fee = self.nodes[0].getnetworkinfo()[\"relayfee\"]\n-        for import_rpc, label, amount, txid, addr in import_rpc_variants:\n-            raw_tx = self.nodes[0].getrawtransaction(txid)\n-            decoded_tx = self.nodes[0].decoderawtransaction(raw_tx)\n-            input_vout = next(out[\"n\"] for out in decoded_tx[\"vout\"]\n-                              if out[\"scriptPubKey\"][\"addresses\"] == [addr[\"address\"]])\n-            inputs = [{\"txid\": txid, \"vout\": input_vout}]\n-            outputs = {self.nodes[0].getnewaddress(): Decimal(amount) - fee}\n-            raw_spend_tx = self.nodes[0].createrawtransaction(inputs, outputs)\n-            signed_spend_tx = self.nodes[0].signrawtransaction(raw_spend_tx)\n-            spend_txid = self.nodes[0].sendrawtransaction(signed_spend_tx[\"hex\"])\n-            spend_txids.append(spend_txid)\n+        for i, variant in enumerate(IMPORT_VARIANTS):\n+            variant.sent_amount = 25 - (2 * i + 1) / 8.0\n+            variant.sent_txid = self.nodes[0].sendtoaddress(variant.address[\"address\"], variant.sent_amount)\n \n+        # Generate a block containing the new transactions.\n         self.nodes[0].generate(1)\n         assert_equal(self.nodes[0].getrawmempool(), [])\n         sync_blocks(self.nodes)\n \n-        # Check the results from getbalance and listtransactions after the spends.\n-        for node, import_node in zip(self.nodes[1:], IMPORT_NODES):\n-            txs = node.listtransactions(\"*\", 10000, 0, True)\n-            for (import_rpc, label, amount, txid, addr), spend_txid in zip(import_rpc_variants, spend_txids):\n-                balance = node.getbalance(label, 0, True)\n-                spend_tx = [tx for tx in txs if tx[\"txid\"] == spend_txid]\n-                if import_node.rescan:\n-                    assert_equal(balance, amount)\n-                    assert_equal(len(spend_tx), 1)\n-                    assert_equal(spend_tx[0][\"account\"], \"\")\n-                    assert_equal(spend_tx[0][\"amount\"] + spend_tx[0][\"fee\"], -amount)\n-                    assert_equal(spend_tx[0][\"category\"], \"send\")\n-                    assert_equal(\"label\" not in spend_tx[0], True)\n-                    assert_equal(spend_tx[0][\"confirmations\"], 1)\n-                    assert_equal(\"trusted\" not in spend_tx[0], True)\n-                    assert_equal(\"involvesWatchonly\" not in txs[0], True)\n-                else:\n-                    assert_equal(balance, 0)\n-                    assert_equal(spend_tx, [])\n+        # Check the latest results from getbalance and listtransactions.\n+        for variant in IMPORT_VARIANTS:\n+            variant.expected_balance += variant.sent_amount\n+            variant.expected_txs += 1\n+            variant.check(variant.sent_txid, variant.sent_amount)\n \n \n if __name__ == \"__main__\":"
      }
    ]
  },
  {
    "sha": "c28583d0629bc6e12ea5d8c660c9b3586be5ad71",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjMjg1ODNkMDYyOWJjNmUxMmVhNWQ4YzY2MGM5YjM1ODZiZTVhZDcx",
    "commit": {
      "author": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2017-02-14T22:39:26Z"
      },
      "committer": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2017-02-16T14:05:55Z"
      },
      "message": "[qa] Extend import-rescan.py to test specific key timestamps",
      "tree": {
        "sha": "4926d531316e4a934f81ce21416a195a4df8d349",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4926d531316e4a934f81ce21416a195a4df8d349"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c28583d0629bc6e12ea5d8c660c9b3586be5ad71",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c28583d0629bc6e12ea5d8c660c9b3586be5ad71",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c28583d0629bc6e12ea5d8c660c9b3586be5ad71",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c28583d0629bc6e12ea5d8c660c9b3586be5ad71/comments",
    "author": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8be0866883ff4efec9182194e900a05742e1b322",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8be0866883ff4efec9182194e900a05742e1b322",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8be0866883ff4efec9182194e900a05742e1b322"
      }
    ],
    "stats": {
      "total": 26,
      "additions": 15,
      "deletions": 11
    },
    "files": [
      {
        "sha": "7ca606828f3f52829ca359a484e4b9f9739a5aa2",
        "filename": "qa/rpc-tests/import-rescan.py",
        "status": "modified",
        "additions": 15,
        "deletions": 11,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c28583d0629bc6e12ea5d8c660c9b3586be5ad71/qa/rpc-tests/import-rescan.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c28583d0629bc6e12ea5d8c660c9b3586be5ad71/qa/rpc-tests/import-rescan.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/import-rescan.py?ref=c28583d0629bc6e12ea5d8c660c9b3586be5ad71",
        "patch": "@@ -20,7 +20,7 @@\n \"\"\"\n \n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import (start_nodes, connect_nodes, sync_blocks, assert_equal)\n+from test_framework.util import (start_nodes, connect_nodes, sync_blocks, assert_equal, set_node_times)\n from decimal import Decimal\n \n import collections\n@@ -29,13 +29,13 @@\n \n Call = enum.Enum(\"Call\", \"single multi\")\n Data = enum.Enum(\"Data\", \"address pub priv\")\n-Rescan = enum.Enum(\"Rescan\", \"no yes\")\n+Rescan = enum.Enum(\"Rescan\", \"no yes late_timestamp\")\n \n \n class Variant(collections.namedtuple(\"Variant\", \"call data rescan\")):\n     \"\"\"Helper for importing one key and verifying scanned transactions.\"\"\"\n \n-    def do_import(self):\n+    def do_import(self, timestamp):\n         \"\"\"Call one key import RPC.\"\"\"\n \n         if self.call == Call.single:\n@@ -51,15 +51,15 @@ def do_import(self):\n                 \"scriptPubKey\": {\n                     \"address\": self.address[\"address\"]\n                 },\n-                \"timestamp\": \"now\",\n+                \"timestamp\": timestamp + (1 if self.rescan == Rescan.late_timestamp else 0),\n                 \"pubkeys\": [self.address[\"pubkey\"]] if self.data == Data.pub else [],\n                 \"keys\": [self.key] if self.data == Data.priv else [],\n                 \"label\": self.label,\n                 \"watchonly\": self.data != Data.priv\n-            }], {\"rescan\": self.rescan == Rescan.yes})\n+            }], {\"rescan\": self.rescan in (Rescan.yes, Rescan.late_timestamp)})\n             assert_equal(response, [{\"success\": True}])\n \n-    def check(self, txid=None, amount=None):\n+    def check(self, txid=None, amount=None, confirmations=None):\n         \"\"\"Verify that getbalance/listtransactions return expected values.\"\"\"\n \n         balance = self.node.getbalance(self.label, 0, True)\n@@ -76,7 +76,7 @@ def check(self, txid=None, amount=None):\n             assert_equal(tx[\"category\"], \"receive\")\n             assert_equal(tx[\"label\"], self.label)\n             assert_equal(tx[\"txid\"], txid)\n-            assert_equal(tx[\"confirmations\"], 1)\n+            assert_equal(tx[\"confirmations\"], confirmations)\n             assert_equal(\"trusted\" not in tx, True)\n             if self.data != Data.priv:\n                 assert_equal(tx[\"involvesWatchonly\"], True)\n@@ -109,9 +109,13 @@ def run_test(self):\n             variant.initial_amount = 25 - (i + 1) / 4.0\n             variant.initial_txid = self.nodes[0].sendtoaddress(variant.address[\"address\"], variant.initial_amount)\n \n-        # Generate a block containing the initial transactions.\n+        # Generate a block containing the initial transactions, then another\n+        # block further in the future (past the rescan window).\n         self.nodes[0].generate(1)\n         assert_equal(self.nodes[0].getrawmempool(), [])\n+        timestamp = self.nodes[0].getblockheader(self.nodes[0].getbestblockhash())[\"time\"]\n+        set_node_times(self.nodes, timestamp + 1)\n+        self.nodes[0].generate(1)\n         sync_blocks(self.nodes)\n \n         # For each variation of wallet key import, invoke the import RPC and\n@@ -124,11 +128,11 @@ def run_test(self):\n         # balances in the second part of the test.)\n         for variant in IMPORT_VARIANTS:\n             variant.node = self.nodes[1 if variant.rescan == Rescan.yes else 2]\n-            variant.do_import()\n+            variant.do_import(timestamp)\n             if variant.rescan == Rescan.yes:\n                 variant.expected_balance = variant.initial_amount\n                 variant.expected_txs = 1\n-                variant.check(variant.initial_txid, variant.initial_amount)\n+                variant.check(variant.initial_txid, variant.initial_amount, 2)\n             else:\n                 variant.expected_balance = 0\n                 variant.expected_txs = 0\n@@ -149,7 +153,7 @@ def run_test(self):\n         for variant in IMPORT_VARIANTS:\n             variant.expected_balance += variant.sent_amount\n             variant.expected_txs += 1\n-            variant.check(variant.sent_txid, variant.sent_amount)\n+            variant.check(variant.sent_txid, variant.sent_amount, 1)\n \n \n if __name__ == \"__main__\":"
      }
    ]
  },
  {
    "sha": "38d3e9ee5900dffb02207211ad5da8f0751e4605",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozOGQzZTllZTU5MDBkZmZiMDIyMDcyMTFhZDVkYThmMDc1MWU0NjA1",
    "commit": {
      "author": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2017-02-15T16:28:50Z"
      },
      "committer": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2017-02-16T14:05:55Z"
      },
      "message": "[qa] Extend import-rescan.py to test imports on pruned nodes.",
      "tree": {
        "sha": "7b83d3c55885ff95d0bd6e30349537987a23eb58",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7b83d3c55885ff95d0bd6e30349537987a23eb58"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/38d3e9ee5900dffb02207211ad5da8f0751e4605",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/38d3e9ee5900dffb02207211ad5da8f0751e4605",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/38d3e9ee5900dffb02207211ad5da8f0751e4605",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/38d3e9ee5900dffb02207211ad5da8f0751e4605/comments",
    "author": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c28583d0629bc6e12ea5d8c660c9b3586be5ad71",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c28583d0629bc6e12ea5d8c660c9b3586be5ad71",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c28583d0629bc6e12ea5d8c660c9b3586be5ad71"
      }
    ],
    "stats": {
      "total": 64,
      "additions": 43,
      "deletions": 21
    },
    "files": [
      {
        "sha": "bd03491f11b1605d37f907692ea5c49bc3f68413",
        "filename": "qa/rpc-tests/import-rescan.py",
        "status": "modified",
        "additions": 43,
        "deletions": 21,
        "changes": 64,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/38d3e9ee5900dffb02207211ad5da8f0751e4605/qa/rpc-tests/import-rescan.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/38d3e9ee5900dffb02207211ad5da8f0751e4605/qa/rpc-tests/import-rescan.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/import-rescan.py?ref=38d3e9ee5900dffb02207211ad5da8f0751e4605",
        "patch": "@@ -5,10 +5,8 @@\n \"\"\"Test rescan behavior of importaddress, importpubkey, importprivkey, and\n importmulti RPCs with different types of keys and rescan options.\n \n-Test uses three connected nodes.\n-\n In the first part of the test, node 0 creates an address for each type of\n-import RPC call and sends BTC to it. Then nodes 1 and 2 import the addresses,\n+import RPC call and sends BTC to it. Then other nodes import the addresses,\n and the test makes listtransactions and getbalance calls to confirm that the\n importing node either did or did not execute rescans picking up the send\n transactions.\n@@ -19,6 +17,7 @@\n happened previously.\n \"\"\"\n \n+from test_framework.authproxy import JSONRPCException\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (start_nodes, connect_nodes, sync_blocks, assert_equal, set_node_times)\n from decimal import Decimal\n@@ -32,20 +31,24 @@\n Rescan = enum.Enum(\"Rescan\", \"no yes late_timestamp\")\n \n \n-class Variant(collections.namedtuple(\"Variant\", \"call data rescan\")):\n+class Variant(collections.namedtuple(\"Variant\", \"call data rescan prune\")):\n     \"\"\"Helper for importing one key and verifying scanned transactions.\"\"\"\n \n     def do_import(self, timestamp):\n         \"\"\"Call one key import RPC.\"\"\"\n \n         if self.call == Call.single:\n             if self.data == Data.address:\n-                response = self.node.importaddress(self.address[\"address\"], self.label, self.rescan == Rescan.yes)\n+                response, error = try_rpc(self.node.importaddress, self.address[\"address\"], self.label,\n+                                          self.rescan == Rescan.yes)\n             elif self.data == Data.pub:\n-                response = self.node.importpubkey(self.address[\"pubkey\"], self.label, self.rescan == Rescan.yes)\n+                response, error = try_rpc(self.node.importpubkey, self.address[\"pubkey\"], self.label,\n+                                          self.rescan == Rescan.yes)\n             elif self.data == Data.priv:\n-                response = self.node.importprivkey(self.key, self.label, self.rescan == Rescan.yes)\n+                response, error = try_rpc(self.node.importprivkey, self.key, self.label, self.rescan == Rescan.yes)\n             assert_equal(response, None)\n+            assert_equal(error, {'message': 'Rescan is disabled in pruned mode',\n+                                 'code': -4} if self.expect_disabled else None)\n         elif self.call == Call.multi:\n             response = self.node.importmulti([{\n                 \"scriptPubKey\": {\n@@ -85,16 +88,29 @@ def check(self, txid=None, amount=None, confirmations=None):\n \n \n # List of Variants for each way a key or address could be imported.\n-IMPORT_VARIANTS = [Variant(*variants) for variants in itertools.product(Call, Data, Rescan)]\n+IMPORT_VARIANTS = [Variant(*variants) for variants in itertools.product(Call, Data, Rescan, (False, True))]\n+\n+# List of nodes to import keys to. Half the nodes will have pruning disabled,\n+# half will have it enabled. Different nodes will be used for imports that are\n+# expected to cause rescans, and imports that are not expected to cause\n+# rescans, in order to prevent rescans during later imports picking up\n+# transactions associated with earlier imports. This makes it easier to keep\n+# track of expected balances and transactions.\n+ImportNode = collections.namedtuple(\"ImportNode\", \"prune rescan\")\n+IMPORT_NODES = [ImportNode(*fields) for fields in itertools.product((False, True), repeat=2)]\n \n \n class ImportRescanTest(BitcoinTestFramework):\n     def __init__(self):\n         super().__init__()\n-        self.num_nodes = 3\n+        self.num_nodes = 1 + len(IMPORT_NODES)\n \n     def setup_network(self):\n         extra_args = [[\"-debug=1\"] for _ in range(self.num_nodes)]\n+        for i, import_node in enumerate(IMPORT_NODES, 1):\n+            if import_node.prune:\n+                extra_args[i] += [\"-prune=1\"]\n+\n         self.nodes = start_nodes(self.num_nodes, self.options.tmpdir, extra_args)\n         for i in range(1, self.num_nodes):\n             connect_nodes(self.nodes[i], 0)\n@@ -119,17 +135,13 @@ def run_test(self):\n         sync_blocks(self.nodes)\n \n         # For each variation of wallet key import, invoke the import RPC and\n-        # check the results from getbalance and listtransactions. Import to\n-        # node 1 if rescanning is expected, and to node 2 if rescanning is not\n-        # expected. Node 2 is reserved for imports that do not cause rescans,\n-        # so later import calls don't inadvertently cause the wallet to pick up\n-        # transactions from earlier import calls where a rescan was not\n-        # expected (this would make it complicated to figure out expected\n-        # balances in the second part of the test.)\n+        # check the results from getbalance and listtransactions.\n         for variant in IMPORT_VARIANTS:\n-            variant.node = self.nodes[1 if variant.rescan == Rescan.yes else 2]\n+            variant.expect_disabled = variant.rescan == Rescan.yes and variant.prune and variant.call == Call.single\n+            expect_rescan = variant.rescan == Rescan.yes and not variant.expect_disabled\n+            variant.node = self.nodes[1 + IMPORT_NODES.index(ImportNode(variant.prune, expect_rescan))]\n             variant.do_import(timestamp)\n-            if variant.rescan == Rescan.yes:\n+            if expect_rescan:\n                 variant.expected_balance = variant.initial_amount\n                 variant.expected_txs = 1\n                 variant.check(variant.initial_txid, variant.initial_amount, 2)\n@@ -151,9 +163,19 @@ def run_test(self):\n \n         # Check the latest results from getbalance and listtransactions.\n         for variant in IMPORT_VARIANTS:\n-            variant.expected_balance += variant.sent_amount\n-            variant.expected_txs += 1\n-            variant.check(variant.sent_txid, variant.sent_amount, 1)\n+            if not variant.expect_disabled:\n+                variant.expected_balance += variant.sent_amount\n+                variant.expected_txs += 1\n+                variant.check(variant.sent_txid, variant.sent_amount, 1)\n+            else:\n+                variant.check()\n+\n+\n+def try_rpc(func, *args, **kwargs):\n+    try:\n+        return func(*args, **kwargs), None\n+    except JSONRPCException as e:\n+        return None, e.error\n \n \n if __name__ == \"__main__\":"
      }
    ]
  },
  {
    "sha": "e662af358305b9fa4da772ec37c8356a9fc92ab6",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplNjYyYWYzNTgzMDViOWZhNGRhNzcyZWMzN2M4MzU2YTlmYzkyYWI2",
    "commit": {
      "author": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2017-02-14T22:39:26Z"
      },
      "committer": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2017-02-16T14:05:55Z"
      },
      "message": "Use 2 hour grace period for key timestamps in importmulti rescans\n\nGregory Maxwell <greg@xiph.org> pointed out the lack of grace period in\nhttps://github.com/bitcoin/bitcoin/pull/9490#issue-199407998.\n\nThe importwallet RPC which uses key timestamps in a similar way already has a 2\nhour grace period.",
      "tree": {
        "sha": "3af65e84fbad7dafc5ea8b7a31d4698434f55d58",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3af65e84fbad7dafc5ea8b7a31d4698434f55d58"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e662af358305b9fa4da772ec37c8356a9fc92ab6",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e662af358305b9fa4da772ec37c8356a9fc92ab6",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e662af358305b9fa4da772ec37c8356a9fc92ab6",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e662af358305b9fa4da772ec37c8356a9fc92ab6/comments",
    "author": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "38d3e9ee5900dffb02207211ad5da8f0751e4605",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/38d3e9ee5900dffb02207211ad5da8f0751e4605",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/38d3e9ee5900dffb02207211ad5da8f0751e4605"
      }
    ],
    "stats": {
      "total": 12,
      "additions": 8,
      "deletions": 4
    },
    "files": [
      {
        "sha": "54cc6d2642adff69688326786b403048b102fb38",
        "filename": "qa/rpc-tests/import-rescan.py",
        "status": "modified",
        "additions": 5,
        "deletions": 2,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e662af358305b9fa4da772ec37c8356a9fc92ab6/qa/rpc-tests/import-rescan.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e662af358305b9fa4da772ec37c8356a9fc92ab6/qa/rpc-tests/import-rescan.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/import-rescan.py?ref=e662af358305b9fa4da772ec37c8356a9fc92ab6",
        "patch": "@@ -54,7 +54,7 @@ def do_import(self, timestamp):\n                 \"scriptPubKey\": {\n                     \"address\": self.address[\"address\"]\n                 },\n-                \"timestamp\": timestamp + (1 if self.rescan == Rescan.late_timestamp else 0),\n+                \"timestamp\": timestamp + RESCAN_WINDOW + (1 if self.rescan == Rescan.late_timestamp else 0),\n                 \"pubkeys\": [self.address[\"pubkey\"]] if self.data == Data.pub else [],\n                 \"keys\": [self.key] if self.data == Data.priv else [],\n                 \"label\": self.label,\n@@ -99,6 +99,9 @@ def check(self, txid=None, amount=None, confirmations=None):\n ImportNode = collections.namedtuple(\"ImportNode\", \"prune rescan\")\n IMPORT_NODES = [ImportNode(*fields) for fields in itertools.product((False, True), repeat=2)]\n \n+# Rescans start at the earliest block up to 2 hours before the key timestamp.\n+RESCAN_WINDOW = 2 * 60 * 60\n+\n \n class ImportRescanTest(BitcoinTestFramework):\n     def __init__(self):\n@@ -130,7 +133,7 @@ def run_test(self):\n         self.nodes[0].generate(1)\n         assert_equal(self.nodes[0].getrawmempool(), [])\n         timestamp = self.nodes[0].getblockheader(self.nodes[0].getbestblockhash())[\"time\"]\n-        set_node_times(self.nodes, timestamp + 1)\n+        set_node_times(self.nodes, timestamp + RESCAN_WINDOW + 1)\n         self.nodes[0].generate(1)\n         sync_blocks(self.nodes)\n "
      },
      {
        "sha": "30f2414675a3894f217ccca936f572b0b8664d50",
        "filename": "src/wallet/rpcdump.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e662af358305b9fa4da772ec37c8356a9fc92ab6/src/wallet/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e662af358305b9fa4da772ec37c8356a9fc92ab6/src/wallet/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcdump.cpp?ref=e662af358305b9fa4da772ec37c8356a9fc92ab6",
        "patch": "@@ -988,7 +988,8 @@ UniValue importmulti(const JSONRPCRequest& mainRequest)\n             \"                                                              or the string \\\"now\\\" to substitute the current synced blockchain time. The timestamp of the oldest\\n\"\n             \"                                                              key will determine how far back blockchain rescans need to begin for missing wallet transactions.\\n\"\n             \"                                                              \\\"now\\\" can be specified to bypass scanning, for keys which are known to never have been used, and\\n\"\n-            \"                                                              0 can be specified to scan the entire blockchain.\\n\"\n+            \"                                                              0 can be specified to scan the entire blockchain. Blocks up to 2 hours before the earliest key\\n\"\n+            \"                                                              creation time of all keys being imported by the importmulti call will be scanned.\\n\"\n             \"      \\\"redeemscript\\\": \\\"<script>\\\"                            , (string, optional) Allowed only if the scriptPubKey is a P2SH address or a P2SH scriptPubKey\\n\"\n             \"      \\\"pubkeys\\\": [\\\"<pubKey>\\\", ... ]                         , (array, optional) Array of strings giving pubkeys that must occur in the output or redeemscript\\n\"\n             \"      \\\"keys\\\": [\\\"<key>\\\", ... ]                               , (array, optional) Array of strings giving private keys whose corresponding public keys must occur in the output or redeemscript\\n\"\n@@ -1072,7 +1073,7 @@ UniValue importmulti(const JSONRPCRequest& mainRequest)\n     }\n \n     if (fRescan && fRunScan && requests.size() && nLowestTimestamp <= chainActive.Tip()->GetBlockTimeMax()) {\n-        CBlockIndex* pindex = nLowestTimestamp > minimumTimestamp ? chainActive.FindEarliestAtLeast(nLowestTimestamp) : chainActive.Genesis();\n+        CBlockIndex* pindex = nLowestTimestamp > minimumTimestamp ? chainActive.FindEarliestAtLeast(std::max<int64_t>(nLowestTimestamp - 7200, 0)) : chainActive.Genesis();\n \n         if (pindex) {\n             pwalletMain->ScanForWalletTransactions(pindex, true);"
      }
    ]
  }
]