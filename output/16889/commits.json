[
  {
    "sha": "e65e61c812df90a56e3ce4a8e76c4b746766f387",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplNjVlNjFjODEyZGY5MGE1NmUzY2U0YThlNzZjNGI3NDY3NjZmMzg3",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2019-08-28T22:12:51Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2019-10-16T15:56:57Z"
      },
      "message": "Add some general std::vector utility functions\n\nAdded are:\n\n* Vector(arg1,arg2,arg3,...) constructs a vector with the specified\n  arguments as elements. The vector's type is derived from the\n  arguments. If some of the arguments are rvalue references, they\n  will be moved into place rather than copied (which can't be achieved\n  using list initialization).\n\n* Cat(vector1,vector2) returns a concatenation of the two vectors,\n  efficiently moving elements when relevant.\n\nVector generalizes (and replaces) the Singleton function in\nsrc/descriptor.cpp, and Cat replaces the Cat function in bech32.cpp",
      "tree": {
        "sha": "787fa4b641ed0d640f96cf430092961e9d7b1b20",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/787fa4b641ed0d640f96cf430092961e9d7b1b20"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e65e61c812df90a56e3ce4a8e76c4b746766f387",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e65e61c812df90a56e3ce4a8e76c4b746766f387",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e65e61c812df90a56e3ce4a8e76c4b746766f387",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e65e61c812df90a56e3ce4a8e76c4b746766f387/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c34b88620dc8435b83e6744895f2ecd3c9ec8de7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c34b88620dc8435b83e6744895f2ecd3c9ec8de7",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c34b88620dc8435b83e6744895f2ecd3c9ec8de7"
      }
    ],
    "stats": {
      "total": 105,
      "additions": 73,
      "deletions": 32
    },
    "files": [
      {
        "sha": "d50524a8ae7be2a40deb667c8dd6c897b42ea78f",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e65e61c812df90a56e3ce4a8e76c4b746766f387/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e65e61c812df90a56e3ce4a8e76c4b746766f387/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=e65e61c812df90a56e3ce4a8e76c4b746766f387",
        "patch": "@@ -220,6 +220,7 @@ BITCOIN_CORE_H = \\\n   util/translation.h \\\n   util/url.h \\\n   util/validation.h \\\n+  util/vector.h \\\n   validation.h \\\n   validationinterface.h \\\n   versionbits.h \\"
      },
      {
        "sha": "1e0471f11018ba7223893e68e63f1be0b79a680d",
        "filename": "src/bech32.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 7,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e65e61c812df90a56e3ce4a8e76c4b746766f387/src/bech32.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e65e61c812df90a56e3ce4a8e76c4b746766f387/src/bech32.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bech32.cpp?ref=e65e61c812df90a56e3ce4a8e76c4b746766f387",
        "patch": "@@ -3,6 +3,7 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include <bech32.h>\n+#include <util/vector.h>\n \n #include <assert.h>\n \n@@ -26,13 +27,6 @@ const int8_t CHARSET_REV[128] = {\n      1,  0,  3, 16, 11, 28, 12, 14,  6,  4,  2, -1, -1, -1, -1, -1\n };\n \n-/** Concatenate two byte arrays. */\n-data Cat(data x, const data& y)\n-{\n-    x.insert(x.end(), y.begin(), y.end());\n-    return x;\n-}\n-\n /** This function will compute what 6 5-bit values to XOR into the last 6 input values, in order to\n  *  make the checksum 0. These 6 values are packed together in a single 30-bit integer. The higher\n  *  bits correspond to earlier values. */"
      },
      {
        "sha": "5cc43898a71c3cb278eb1b22e941bbae5e1cf960",
        "filename": "src/outputtype.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e65e61c812df90a56e3ce4a8e76c4b746766f387/src/outputtype.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e65e61c812df90a56e3ce4a8e76c4b746766f387/src/outputtype.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/outputtype.cpp?ref=e65e61c812df90a56e3ce4a8e76c4b746766f387",
        "patch": "@@ -10,6 +10,7 @@\n #include <script/sign.h>\n #include <script/signingprovider.h>\n #include <script/standard.h>\n+#include <util/vector.h>\n \n #include <assert.h>\n #include <string>\n@@ -65,12 +66,13 @@ CTxDestination GetDestinationForKey(const CPubKey& key, OutputType type)\n std::vector<CTxDestination> GetAllDestinationsForKey(const CPubKey& key)\n {\n     PKHash keyid(key);\n+    CTxDestination p2pkh{keyid};\n     if (key.IsCompressed()) {\n         CTxDestination segwit = WitnessV0KeyHash(keyid);\n         CTxDestination p2sh = ScriptHash(GetScriptForDestination(segwit));\n-        return std::vector<CTxDestination>{std::move(keyid), std::move(p2sh), std::move(segwit)};\n+        return Vector(std::move(p2pkh), std::move(p2sh), std::move(segwit));\n     } else {\n-        return std::vector<CTxDestination>{std::move(keyid)};\n+        return Vector(std::move(p2pkh));\n     }\n }\n "
      },
      {
        "sha": "536807e1d82c2284a1bfd8e482ff8ff83d8180fa",
        "filename": "src/script/descriptor.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 22,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e65e61c812df90a56e3ce4a8e76c4b746766f387/src/script/descriptor.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e65e61c812df90a56e3ce4a8e76c4b746766f387/src/script/descriptor.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/descriptor.cpp?ref=e65e61c812df90a56e3ce4a8e76c4b746766f387",
        "patch": "@@ -14,6 +14,7 @@\n #include <util/spanparsing.h>\n #include <util/system.h>\n #include <util/strencodings.h>\n+#include <util/vector.h>\n \n #include <memory>\n #include <string>\n@@ -501,22 +502,13 @@ class DescriptorImpl : public Descriptor\n     }\n };\n \n-/** Construct a vector with one element, which is moved into it. */\n-template<typename T>\n-std::vector<T> Singleton(T elem)\n-{\n-    std::vector<T> ret;\n-    ret.emplace_back(std::move(elem));\n-    return ret;\n-}\n-\n /** A parsed addr(A) descriptor. */\n class AddressDescriptor final : public DescriptorImpl\n {\n     const CTxDestination m_destination;\n protected:\n     std::string ToStringExtra() const override { return EncodeDestination(m_destination); }\n-    std::vector<CScript> MakeScripts(const std::vector<CPubKey>&, const CScript*, FlatSigningProvider&) const override { return Singleton(GetScriptForDestination(m_destination)); }\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>&, const CScript*, FlatSigningProvider&) const override { return Vector(GetScriptForDestination(m_destination)); }\n public:\n     AddressDescriptor(CTxDestination destination) : DescriptorImpl({}, {}, \"addr\"), m_destination(std::move(destination)) {}\n     bool IsSolvable() const final { return false; }\n@@ -528,7 +520,7 @@ class RawDescriptor final : public DescriptorImpl\n     const CScript m_script;\n protected:\n     std::string ToStringExtra() const override { return HexStr(m_script.begin(), m_script.end()); }\n-    std::vector<CScript> MakeScripts(const std::vector<CPubKey>&, const CScript*, FlatSigningProvider&) const override { return Singleton(m_script); }\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>&, const CScript*, FlatSigningProvider&) const override { return Vector(m_script); }\n public:\n     RawDescriptor(CScript script) : DescriptorImpl({}, {}, \"raw\"), m_script(std::move(script)) {}\n     bool IsSolvable() const final { return false; }\n@@ -538,9 +530,9 @@ class RawDescriptor final : public DescriptorImpl\n class PKDescriptor final : public DescriptorImpl\n {\n protected:\n-    std::vector<CScript> MakeScripts(const std::vector<CPubKey>& keys, const CScript*, FlatSigningProvider&) const override { return Singleton(GetScriptForRawPubKey(keys[0])); }\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>& keys, const CScript*, FlatSigningProvider&) const override { return Vector(GetScriptForRawPubKey(keys[0])); }\n public:\n-    PKDescriptor(std::unique_ptr<PubkeyProvider> prov) : DescriptorImpl(Singleton(std::move(prov)), {}, \"pk\") {}\n+    PKDescriptor(std::unique_ptr<PubkeyProvider> prov) : DescriptorImpl(Vector(std::move(prov)), {}, \"pk\") {}\n };\n \n /** A parsed pkh(P) descriptor. */\n@@ -551,10 +543,10 @@ class PKHDescriptor final : public DescriptorImpl\n     {\n         CKeyID id = keys[0].GetID();\n         out.pubkeys.emplace(id, keys[0]);\n-        return Singleton(GetScriptForDestination(PKHash(id)));\n+        return Vector(GetScriptForDestination(PKHash(id)));\n     }\n public:\n-    PKHDescriptor(std::unique_ptr<PubkeyProvider> prov) : DescriptorImpl(Singleton(std::move(prov)), {}, \"pkh\") {}\n+    PKHDescriptor(std::unique_ptr<PubkeyProvider> prov) : DescriptorImpl(Vector(std::move(prov)), {}, \"pkh\") {}\n };\n \n /** A parsed wpkh(P) descriptor. */\n@@ -565,10 +557,10 @@ class WPKHDescriptor final : public DescriptorImpl\n     {\n         CKeyID id = keys[0].GetID();\n         out.pubkeys.emplace(id, keys[0]);\n-        return Singleton(GetScriptForDestination(WitnessV0KeyHash(id)));\n+        return Vector(GetScriptForDestination(WitnessV0KeyHash(id)));\n     }\n public:\n-    WPKHDescriptor(std::unique_ptr<PubkeyProvider> prov) : DescriptorImpl(Singleton(std::move(prov)), {}, \"wpkh\") {}\n+    WPKHDescriptor(std::unique_ptr<PubkeyProvider> prov) : DescriptorImpl(Vector(std::move(prov)), {}, \"wpkh\") {}\n };\n \n /** A parsed combo(P) descriptor. */\n@@ -591,7 +583,7 @@ class ComboDescriptor final : public DescriptorImpl\n         return ret;\n     }\n public:\n-    ComboDescriptor(std::unique_ptr<PubkeyProvider> prov) : DescriptorImpl(Singleton(std::move(prov)), {}, \"combo\") {}\n+    ComboDescriptor(std::unique_ptr<PubkeyProvider> prov) : DescriptorImpl(Vector(std::move(prov)), {}, \"combo\") {}\n };\n \n /** A parsed multi(...) or sortedmulti(...) descriptor */\n@@ -605,9 +597,9 @@ class MultisigDescriptor final : public DescriptorImpl\n         if (m_sorted) {\n             std::vector<CPubKey> sorted_keys(keys);\n             std::sort(sorted_keys.begin(), sorted_keys.end());\n-            return Singleton(GetScriptForMultisig(m_threshold, sorted_keys));\n+            return Vector(GetScriptForMultisig(m_threshold, sorted_keys));\n         }\n-        return Singleton(GetScriptForMultisig(m_threshold, keys));\n+        return Vector(GetScriptForMultisig(m_threshold, keys));\n     }\n public:\n     MultisigDescriptor(int threshold, std::vector<std::unique_ptr<PubkeyProvider>> providers, bool sorted = false) : DescriptorImpl(std::move(providers), {}, sorted ? \"sortedmulti\" : \"multi\"), m_threshold(threshold), m_sorted(sorted) {}\n@@ -617,7 +609,7 @@ class MultisigDescriptor final : public DescriptorImpl\n class SHDescriptor final : public DescriptorImpl\n {\n protected:\n-    std::vector<CScript> MakeScripts(const std::vector<CPubKey>&, const CScript* script, FlatSigningProvider&) const override { return Singleton(GetScriptForDestination(ScriptHash(*script))); }\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>&, const CScript* script, FlatSigningProvider&) const override { return Vector(GetScriptForDestination(ScriptHash(*script))); }\n public:\n     SHDescriptor(std::unique_ptr<DescriptorImpl> desc) : DescriptorImpl({}, std::move(desc), \"sh\") {}\n };\n@@ -626,7 +618,7 @@ class SHDescriptor final : public DescriptorImpl\n class WSHDescriptor final : public DescriptorImpl\n {\n protected:\n-    std::vector<CScript> MakeScripts(const std::vector<CPubKey>&, const CScript* script, FlatSigningProvider&) const override { return Singleton(GetScriptForDestination(WitnessV0ScriptHash(*script))); }\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>&, const CScript* script, FlatSigningProvider&) const override { return Vector(GetScriptForDestination(WitnessV0ScriptHash(*script))); }\n public:\n     WSHDescriptor(std::unique_ptr<DescriptorImpl> desc) : DescriptorImpl({}, std::move(desc), \"wsh\") {}\n };"
      },
      {
        "sha": "a7eb5f9f67826bf4467c99faa8e8ad121cf2699f",
        "filename": "src/txdb.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e65e61c812df90a56e3ce4a8e76c4b746766f387/src/txdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e65e61c812df90a56e3ce4a8e76c4b746766f387/src/txdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.cpp?ref=e65e61c812df90a56e3ce4a8e76c4b746766f387",
        "patch": "@@ -12,6 +12,7 @@\n #include <uint256.h>\n #include <util/system.h>\n #include <util/translation.h>\n+#include <util/vector.h>\n \n #include <stdint.h>\n \n@@ -102,7 +103,7 @@ bool CCoinsViewDB::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) {\n     // A vector is used for future extensibility, as we may want to support\n     // interrupting after partial writes from multiple independent reorgs.\n     batch.Erase(DB_BEST_BLOCK);\n-    batch.Write(DB_HEAD_BLOCKS, std::vector<uint256>{hashBlock, old_tip});\n+    batch.Write(DB_HEAD_BLOCKS, Vector(hashBlock, old_tip));\n \n     for (CCoinsMap::iterator it = mapCoins.begin(); it != mapCoins.end();) {\n         if (it->second.flags & CCoinsCacheEntry::DIRTY) {"
      },
      {
        "sha": "dab65ded2ace10910811d8656bfd800bde32c0af",
        "filename": "src/util/vector.h",
        "status": "added",
        "additions": 51,
        "deletions": 0,
        "changes": 51,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e65e61c812df90a56e3ce4a8e76c4b746766f387/src/util/vector.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e65e61c812df90a56e3ce4a8e76c4b746766f387/src/util/vector.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/vector.h?ref=e65e61c812df90a56e3ce4a8e76c4b746766f387",
        "patch": "@@ -0,0 +1,51 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_VECTOR_H\n+#define BITCOIN_UTIL_VECTOR_H\n+\n+#include <initializer_list>\n+#include <type_traits>\n+#include <vector>\n+\n+/** Construct a vector with the specified elements.\n+ *\n+ * This is preferable over the list initializing constructor of std::vector:\n+ * - It automatically infers the element type from its arguments.\n+ * - If any arguments are rvalue references, they will be moved into the vector\n+ *   (list initialization always copies).\n+ */\n+template<typename... Args>\n+inline std::vector<typename std::common_type<Args...>::type> Vector(Args&&... args)\n+{\n+    std::vector<typename std::common_type<Args...>::type> ret;\n+    ret.reserve(sizeof...(args));\n+    // The line below uses the trick from https://www.experts-exchange.com/articles/32502/None-recursive-variadic-templates-with-std-initializer-list.html\n+    (void)std::initializer_list<int>{(ret.emplace_back(std::forward<Args>(args)), 0)...};\n+    return ret;\n+}\n+\n+/** Concatenate two vectors, moving elements. */\n+template<typename V>\n+inline V Cat(V v1, V&& v2)\n+{\n+    v1.reserve(v1.size() + v2.size());\n+    for (auto& arg : v2) {\n+        v1.push_back(std::move(arg));\n+    }\n+    return v1;\n+}\n+\n+/** Concatenate two vectors. */\n+template<typename V>\n+inline V Cat(V v1, const V& v2)\n+{\n+    v1.reserve(v1.size() + v2.size());\n+    for (const auto& arg : v2) {\n+        v1.push_back(arg);\n+    }\n+    return v1;\n+}\n+\n+#endif // BITCOIN_UTIL_VECTOR_H"
      }
    ]
  },
  {
    "sha": "7d8d3e6a2ad827fa916e3909a18dedb9f7fdce43",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3ZDhkM2U2YTJhZDgyN2ZhOTE2ZTM5MDlhMThkZWRiOWY3ZmRjZTQz",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2019-10-10T18:23:41Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2019-10-16T15:57:26Z"
      },
      "message": "Add tests for util/vector.h's Cat and Vector",
      "tree": {
        "sha": "efdd46ab0679a8334ab1b139fe4eaa764556a902",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/efdd46ab0679a8334ab1b139fe4eaa764556a902"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7d8d3e6a2ad827fa916e3909a18dedb9f7fdce43",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7d8d3e6a2ad827fa916e3909a18dedb9f7fdce43",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7d8d3e6a2ad827fa916e3909a18dedb9f7fdce43",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7d8d3e6a2ad827fa916e3909a18dedb9f7fdce43/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e65e61c812df90a56e3ce4a8e76c4b746766f387",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e65e61c812df90a56e3ce4a8e76c4b746766f387",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e65e61c812df90a56e3ce4a8e76c4b746766f387"
      }
    ],
    "stats": {
      "total": 106,
      "additions": 106,
      "deletions": 0
    },
    "files": [
      {
        "sha": "02303d0f650f5a88e31db7de6b0c5e5e65d6ee78",
        "filename": "src/test/util_tests.cpp",
        "status": "modified",
        "additions": 106,
        "deletions": 0,
        "changes": 106,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7d8d3e6a2ad827fa916e3909a18dedb9f7fdce43/src/test/util_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7d8d3e6a2ad827fa916e3909a18dedb9f7fdce43/src/test/util_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util_tests.cpp?ref=7d8d3e6a2ad827fa916e3909a18dedb9f7fdce43",
        "patch": "@@ -13,6 +13,7 @@\n #include <util/string.h>\n #include <util/time.h>\n #include <util/spanparsing.h>\n+#include <util/vector.h>\n \n #include <stdint.h>\n #include <thread>\n@@ -1714,4 +1715,109 @@ BOOST_AUTO_TEST_CASE(test_LogEscapeMessage)\n     BOOST_CHECK_EQUAL(BCLog::LogEscapeMessage(NUL), R\"(O\\x00O)\");\n }\n \n+namespace {\n+\n+struct Tracker\n+{\n+    //! Points to the original object (possibly itself) we moved/copied from\n+    const Tracker* origin;\n+    //! How many copies where involved between the original object and this one (moves are not counted)\n+    int copies;\n+\n+    Tracker() noexcept : origin(this), copies(0) {}\n+    Tracker(const Tracker& t) noexcept : origin(t.origin), copies(t.copies + 1) {}\n+    Tracker(Tracker&& t) noexcept : origin(t.origin), copies(t.copies) {}\n+    Tracker& operator=(const Tracker& t) noexcept\n+    {\n+        origin = t.origin;\n+        copies = t.copies + 1;\n+        return *this;\n+    }\n+    Tracker& operator=(Tracker&& t) noexcept\n+    {\n+        origin = t.origin;\n+        copies = t.copies;\n+        return *this;\n+    }\n+};\n+\n+}\n+\n+BOOST_AUTO_TEST_CASE(test_tracked_vector)\n+{\n+    Tracker t1;\n+    Tracker t2;\n+    Tracker t3;\n+\n+    BOOST_CHECK(t1.origin == &t1);\n+    BOOST_CHECK(t2.origin == &t2);\n+    BOOST_CHECK(t3.origin == &t3);\n+\n+    auto v1 = Vector(t1);\n+    BOOST_CHECK_EQUAL(v1.size(), 1);\n+    BOOST_CHECK(v1[0].origin == &t1);\n+    BOOST_CHECK_EQUAL(v1[0].copies, 1);\n+\n+    auto v2 = Vector(std::move(t2));\n+    BOOST_CHECK_EQUAL(v2.size(), 1);\n+    BOOST_CHECK(v2[0].origin == &t2);\n+    BOOST_CHECK_EQUAL(v2[0].copies, 0);\n+\n+    auto v3 = Vector(t1, std::move(t2));\n+    BOOST_CHECK_EQUAL(v3.size(), 2);\n+    BOOST_CHECK(v3[0].origin == &t1);\n+    BOOST_CHECK(v3[1].origin == &t2);\n+    BOOST_CHECK_EQUAL(v3[0].copies, 1);\n+    BOOST_CHECK_EQUAL(v3[1].copies, 0);\n+\n+    auto v4 = Vector(std::move(v3[0]), v3[1], std::move(t3));\n+    BOOST_CHECK_EQUAL(v4.size(), 3);\n+    BOOST_CHECK(v4[0].origin == &t1);\n+    BOOST_CHECK(v4[1].origin == &t2);\n+    BOOST_CHECK(v4[2].origin == &t3);\n+    BOOST_CHECK_EQUAL(v4[0].copies, 1);\n+    BOOST_CHECK_EQUAL(v4[1].copies, 1);\n+    BOOST_CHECK_EQUAL(v4[2].copies, 0);\n+\n+    auto v5 = Cat(v1, v4);\n+    BOOST_CHECK_EQUAL(v5.size(), 4);\n+    BOOST_CHECK(v5[0].origin == &t1);\n+    BOOST_CHECK(v5[1].origin == &t1);\n+    BOOST_CHECK(v5[2].origin == &t2);\n+    BOOST_CHECK(v5[3].origin == &t3);\n+    BOOST_CHECK_EQUAL(v5[0].copies, 2);\n+    BOOST_CHECK_EQUAL(v5[1].copies, 2);\n+    BOOST_CHECK_EQUAL(v5[2].copies, 2);\n+    BOOST_CHECK_EQUAL(v5[3].copies, 1);\n+\n+    auto v6 = Cat(std::move(v1), v3);\n+    BOOST_CHECK_EQUAL(v6.size(), 3);\n+    BOOST_CHECK(v6[0].origin == &t1);\n+    BOOST_CHECK(v6[1].origin == &t1);\n+    BOOST_CHECK(v6[2].origin == &t2);\n+    BOOST_CHECK_EQUAL(v6[0].copies, 1);\n+    BOOST_CHECK_EQUAL(v6[1].copies, 2);\n+    BOOST_CHECK_EQUAL(v6[2].copies, 1);\n+\n+    auto v7 = Cat(v2, std::move(v4));\n+    BOOST_CHECK_EQUAL(v7.size(), 4);\n+    BOOST_CHECK(v7[0].origin == &t2);\n+    BOOST_CHECK(v7[1].origin == &t1);\n+    BOOST_CHECK(v7[2].origin == &t2);\n+    BOOST_CHECK(v7[3].origin == &t3);\n+    BOOST_CHECK_EQUAL(v7[0].copies, 1);\n+    BOOST_CHECK_EQUAL(v7[1].copies, 1);\n+    BOOST_CHECK_EQUAL(v7[2].copies, 1);\n+    BOOST_CHECK_EQUAL(v7[3].copies, 0);\n+\n+    auto v8 = Cat(std::move(v2), std::move(v3));\n+    BOOST_CHECK_EQUAL(v8.size(), 3);\n+    BOOST_CHECK(v8[0].origin == &t2);\n+    BOOST_CHECK(v8[1].origin == &t1);\n+    BOOST_CHECK(v8[2].origin == &t2);\n+    BOOST_CHECK_EQUAL(v8[0].copies, 0);\n+    BOOST_CHECK_EQUAL(v8[1].copies, 1);\n+    BOOST_CHECK_EQUAL(v8[2].copies, 0);\n+}\n+\n BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  }
]