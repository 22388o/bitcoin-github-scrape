[
  {
    "sha": "c9e5cf9688f7c2f67e368adf605bead75a1f2ade",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjOWU1Y2Y5Njg4ZjdjMmY2N2UzNjhhZGY2MDViZWFkNzVhMWYyYWRl",
    "commit": {
      "author": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2015-07-02T18:57:39Z"
      },
      "committer": {
        "name": "Jonas Schnelli",
        "email": "jonas.schnelli@include7.ch",
        "date": "2015-07-08T14:57:51Z"
      },
      "message": "Move recently introduced CTransAction::IsEquivalentTo to CWalletTx\n\nCTransAction::IsEquivalentTo was introduced in #5881.\nThis functionality is only useful to the wallet, and should never have\nbeen added to the primitive transaction type.",
      "tree": {
        "sha": "d46dd38cf56d4330650832c62998b6d47d6149de",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d46dd38cf56d4330650832c62998b6d47d6149de"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c9e5cf9688f7c2f67e368adf605bead75a1f2ade",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c9e5cf9688f7c2f67e368adf605bead75a1f2ade",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c9e5cf9688f7c2f67e368adf605bead75a1f2ade",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c9e5cf9688f7c2f67e368adf605bead75a1f2ade/comments",
    "author": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9546a977d354b2ec6cd8455538e68fe4ba343a44",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9546a977d354b2ec6cd8455538e68fe4ba343a44",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9546a977d354b2ec6cd8455538e68fe4ba343a44"
      }
    ],
    "stats": {
      "total": 24,
      "additions": 12,
      "deletions": 12
    },
    "files": [
      {
        "sha": "606dbea79857d2f4cc79b0136ad46486f3c187d9",
        "filename": "src/primitives/transaction.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 9,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9e5cf9688f7c2f67e368adf605bead75a1f2ade/src/primitives/transaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9e5cf9688f7c2f67e368adf605bead75a1f2ade/src/primitives/transaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/primitives/transaction.cpp?ref=c9e5cf9688f7c2f67e368adf605bead75a1f2ade",
        "patch": "@@ -87,15 +87,6 @@ CTransaction& CTransaction::operator=(const CTransaction &tx) {\n     return *this;\n }\n \n-bool CTransaction::IsEquivalentTo(const CTransaction& tx) const\n-{\n-\tCMutableTransaction tx1 = *this;\n-\tCMutableTransaction tx2 = tx;\n-\tfor (unsigned int i = 0; i < tx1.vin.size(); i++) tx1.vin[i].scriptSig = CScript();\n-\tfor (unsigned int i = 0; i < tx2.vin.size(); i++) tx2.vin[i].scriptSig = CScript();\n-\treturn CTransaction(tx1) == CTransaction(tx2);\n-}\n-\n CAmount CTransaction::GetValueOut() const\n {\n     CAmount nValueOut = 0;"
      },
      {
        "sha": "6cfd93a9a1891c6d19884b0096ffcb124d8c45ba",
        "filename": "src/primitives/transaction.h",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9e5cf9688f7c2f67e368adf605bead75a1f2ade/src/primitives/transaction.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9e5cf9688f7c2f67e368adf605bead75a1f2ade/src/primitives/transaction.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/primitives/transaction.h?ref=c9e5cf9688f7c2f67e368adf605bead75a1f2ade",
        "patch": "@@ -222,9 +222,6 @@ class CTransaction\n         return hash;\n     }\n \n-    // True if only scriptSigs are different\n-    bool IsEquivalentTo(const CTransaction& tx) const;\n-\n     // Return sum of txouts.\n     CAmount GetValueOut() const;\n     // GetValueIn() is a method on CCoinsViewCache, because"
      },
      {
        "sha": "7b3cd9803b31e5c81b0a2153dcc646f06506d59a",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 0,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9e5cf9688f7c2f67e368adf605bead75a1f2ade/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9e5cf9688f7c2f67e368adf605bead75a1f2ade/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=c9e5cf9688f7c2f67e368adf605bead75a1f2ade",
        "patch": "@@ -1332,6 +1332,15 @@ bool CWalletTx::IsTrusted() const\n     return true;\n }\n \n+bool CWalletTx::IsEquivalentTo(const CWalletTx& tx) const\n+{\n+        CMutableTransaction tx1 = *this;\n+        CMutableTransaction tx2 = tx;\n+        for (unsigned int i = 0; i < tx1.vin.size(); i++) tx1.vin[i].scriptSig = CScript();\n+        for (unsigned int i = 0; i < tx2.vin.size(); i++) tx2.vin[i].scriptSig = CScript();\n+        return CTransaction(tx1) == CTransaction(tx2);\n+}\n+\n std::vector<uint256> CWallet::ResendWalletTransactionsBefore(int64_t nTime)\n {\n     std::vector<uint256> result;"
      },
      {
        "sha": "003266ba19a6f2123df5822131e49f4e98095f25",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c9e5cf9688f7c2f67e368adf605bead75a1f2ade/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c9e5cf9688f7c2f67e368adf605bead75a1f2ade/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=c9e5cf9688f7c2f67e368adf605bead75a1f2ade",
        "patch": "@@ -378,6 +378,9 @@ class CWalletTx : public CMerkleTx\n         return (GetDebit(filter) > 0);\n     }\n \n+    // True if only scriptSigs are different\n+    bool IsEquivalentTo(const CWalletTx& tx) const;\n+\n     bool IsTrusted() const;\n \n     bool WriteToDisk(CWalletDB *pwalletdb);"
      }
    ]
  },
  {
    "sha": "c64ac71cf568d7ed137a3ee74c8673f210574d04",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjNjRhYzcxY2Y1NjhkN2VkMTM3YTNlZTc0Yzg2NzNmMjEwNTc0ZDA0",
    "commit": {
      "author": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2015-07-07T16:18:14Z"
      },
      "committer": {
        "name": "Jonas Schnelli",
        "email": "jonas.schnelli@include7.ch",
        "date": "2015-07-08T14:57:51Z"
      },
      "message": "tests: Fix bitcoin-tx signing testcase\n\nFixes wrong scriptPubkey problem, which caused the transaction to\nnot actually be signed.",
      "tree": {
        "sha": "902974544739f4f68303de3a3ab295021bd6de29",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/902974544739f4f68303de3a3ab295021bd6de29"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c64ac71cf568d7ed137a3ee74c8673f210574d04",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c64ac71cf568d7ed137a3ee74c8673f210574d04",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c64ac71cf568d7ed137a3ee74c8673f210574d04",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c64ac71cf568d7ed137a3ee74c8673f210574d04/comments",
    "author": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c9e5cf9688f7c2f67e368adf605bead75a1f2ade",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c9e5cf9688f7c2f67e368adf605bead75a1f2ade",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c9e5cf9688f7c2f67e368adf605bead75a1f2ade"
      }
    ],
    "stats": {
      "total": 4,
      "additions": 2,
      "deletions": 2
    },
    "files": [
      {
        "sha": "afd35af5031ea71e096a45a4ced2be6e55d8036e",
        "filename": "src/test/data/bitcoin-util-test.json",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c64ac71cf568d7ed137a3ee74c8673f210574d04/src/test/data/bitcoin-util-test.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c64ac71cf568d7ed137a3ee74c8673f210574d04/src/test/data/bitcoin-util-test.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/data/bitcoin-util-test.json?ref=c64ac71cf568d7ed137a3ee74c8673f210574d04",
        "patch": "@@ -52,7 +52,7 @@\n     [\"-create\",\n      \"in=4d49a71ec9da436f71ec4ee231d04f292a29cd316f598bb7068feccabdc59485:0\",\n      \"set=privatekeys:[\\\"5HpHagT65TZzG1PH3CSu63k8DbpvD8s5ip4nEB3kEsreAnchuDf\\\"]\",\n-     \"set=prevtxs:[{\\\"txid\\\":\\\"4d49a71ec9da436f71ec4ee231d04f292a29cd316f598bb7068feccabdc59485\\\",\\\"vout\\\":0,\\\"scriptPubKey\\\":\\\"4d49a71ec9da436f71ec4ee231d04f292a29cd316f598bb7068feccabdc59485\\\"}]\",\n+     \"set=prevtxs:[{\\\"txid\\\":\\\"4d49a71ec9da436f71ec4ee231d04f292a29cd316f598bb7068feccabdc59485\\\",\\\"vout\\\":0,\\\"scriptPubKey\\\":\\\"76a91491b24bf9f5288532960ac687abb035127b1d28a588ac\\\"}]\",\n      \"sign=ALL\",\n      \"outaddr=0.001:193P6LtvS4nCnkDvM9uXn1gsSRqh4aDAz7\"],\n     \"output_cmp\": \"txcreatesign.hex\""
      },
      {
        "sha": "a46fcc88cbc99db4f212bb70adf1c3422b2d251c",
        "filename": "src/test/data/txcreatesign.hex",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c64ac71cf568d7ed137a3ee74c8673f210574d04/src/test/data/txcreatesign.hex",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c64ac71cf568d7ed137a3ee74c8673f210574d04/src/test/data/txcreatesign.hex",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/data/txcreatesign.hex?ref=c64ac71cf568d7ed137a3ee74c8673f210574d04",
        "patch": "@@ -1 +1 @@\n-01000000018594c5bdcaec8f06b78b596f31cd292a294fd031e24eec716f43dac91ea7494d0000000000ffffffff01a0860100000000001976a9145834479edbbe0539b31ffd3a8f8ebadc2165ed0188ac00000000\n+01000000018594c5bdcaec8f06b78b596f31cd292a294fd031e24eec716f43dac91ea7494d000000008b48304502210096a75056c9e2cc62b7214777b3d2a592cfda7092520126d4ebfcd6d590c99bd8022051bb746359cf98c0603f3004477eac68701132380db8facba19c89dc5ab5c5e201410479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8ffffffff01a0860100000000001976a9145834479edbbe0539b31ffd3a8f8ebadc2165ed0188ac00000000"
      }
    ]
  },
  {
    "sha": "eb69554aa28f570b5884fe2d65c3819acfd5f016",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplYjY5NTU0YWEyOGY1NzBiNTg4NGZlMmQ2NWMzODE5YWNmZDVmMDE2",
    "commit": {
      "author": {
        "name": "Jonas Schnelli",
        "email": "jonas.schnelli@include7.ch",
        "date": "2015-07-07T10:15:44Z"
      },
      "committer": {
        "name": "Jonas Schnelli",
        "email": "jonas.schnelli@include7.ch",
        "date": "2015-07-08T14:57:51Z"
      },
      "message": "[bitcoin-cli] improve error output",
      "tree": {
        "sha": "21282d50ea4c204ed9257ef0cef04e53cf2a5d00",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/21282d50ea4c204ed9257ef0cef04e53cf2a5d00"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/eb69554aa28f570b5884fe2d65c3819acfd5f016",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/eb69554aa28f570b5884fe2d65c3819acfd5f016",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/eb69554aa28f570b5884fe2d65c3819acfd5f016",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/eb69554aa28f570b5884fe2d65c3819acfd5f016/comments",
    "author": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c64ac71cf568d7ed137a3ee74c8673f210574d04",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c64ac71cf568d7ed137a3ee74c8673f210574d04",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c64ac71cf568d7ed137a3ee74c8673f210574d04"
      }
    ],
    "stats": {
      "total": 9,
      "additions": 9,
      "deletions": 0
    },
    "files": [
      {
        "sha": "903777ba510844f5dca1f0aa23889e0aaed48d63",
        "filename": "src/bitcoin-cli.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 0,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/eb69554aa28f570b5884fe2d65c3819acfd5f016/src/bitcoin-cli.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/eb69554aa28f570b5884fe2d65c3819acfd5f016/src/bitcoin-cli.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-cli.cpp?ref=eb69554aa28f570b5884fe2d65c3819acfd5f016",
        "patch": "@@ -190,6 +190,15 @@ int CommandLineRPC(int argc, char *argv[])\n                         throw CConnectionFailed(\"server in warmup\");\n                     strPrint = \"error: \" + error.write();\n                     nRet = abs(code);\n+                    if (error.isObject())\n+                    {\n+                        UniValue errCode = find_value(error, \"code\");\n+                        UniValue errMsg  = find_value(error, \"message\");\n+                        strPrint = errCode.isNull() ? \"\" : \"error code: \"+errCode.getValStr()+\"\\n\";\n+\n+                        if (errMsg.isStr())\n+                            strPrint += \"error message:\\n\"+errMsg.get_str();\n+                    }\n                 } else {\n                     // Result\n                     if (result.isNull())"
      }
    ]
  },
  {
    "sha": "de52ba4c239c0d5198dcbfc637de2c5a17e02def",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkZTUyYmE0YzIzOWMwZDUxOThkY2JmYzYzN2RlMmM1YTE3ZTAyZGVm",
    "commit": {
      "author": {
        "name": "Jonas Schnelli",
        "email": "jonas.schnelli@include7.ch",
        "date": "2015-04-09T20:16:04Z"
      },
      "committer": {
        "name": "Jonas Schnelli",
        "email": "jonas.schnelli@include7.ch",
        "date": "2015-07-08T14:57:52Z"
      },
      "message": "[Wallet] refactor and optimize init.cpp/CWallet interaction\n\nReduced wallet/core coupling.\n\n- hides CWalletDB behind CWallet\n- reduces ENABLE_WALLET ifdefs\n- remove some whitespace",
      "tree": {
        "sha": "fe213c988316009eeb7e91bda5d849cc76248303",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fe213c988316009eeb7e91bda5d849cc76248303"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/de52ba4c239c0d5198dcbfc637de2c5a17e02def",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/de52ba4c239c0d5198dcbfc637de2c5a17e02def",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/de52ba4c239c0d5198dcbfc637de2c5a17e02def",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/de52ba4c239c0d5198dcbfc637de2c5a17e02def/comments",
    "author": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "eb69554aa28f570b5884fe2d65c3819acfd5f016",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/eb69554aa28f570b5884fe2d65c3819acfd5f016",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/eb69554aa28f570b5884fe2d65c3819acfd5f016"
      }
    ],
    "stats": {
      "total": 543,
      "additions": 302,
      "deletions": 241
    },
    "files": [
      {
        "sha": "4173077f515b6341563517407611524833f72115",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 32,
        "deletions": 222,
        "changes": 254,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/de52ba4c239c0d5198dcbfc637de2c5a17e02def/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/de52ba4c239c0d5198dcbfc637de2c5a17e02def/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=de52ba4c239c0d5198dcbfc637de2c5a17e02def",
        "patch": "@@ -29,7 +29,6 @@\n #include \"validationinterface.h\"\n #ifdef ENABLE_WALLET\n #include \"wallet/wallet.h\"\n-#include \"wallet/walletdb.h\"\n #endif\n \n #include <stdint.h>\n@@ -332,26 +331,7 @@ std::string HelpMessage(HelpMessageMode mode)\n         \" \" + _(\"Whitelisted peers cannot be DoS banned and their transactions are always relayed, even if they are already in the mempool, useful e.g. for a gateway\"));\n \n #ifdef ENABLE_WALLET\n-    strUsage += HelpMessageGroup(_(\"Wallet options:\"));\n-    strUsage += HelpMessageOpt(\"-disablewallet\", _(\"Do not load the wallet and disable wallet RPC calls\"));\n-    strUsage += HelpMessageOpt(\"-keypool=<n>\", strprintf(_(\"Set key pool size to <n> (default: %u)\"), 100));\n-    if (showDebug)\n-        strUsage += HelpMessageOpt(\"-mintxfee=<amt>\", strprintf(\"Fees (in BTC/Kb) smaller than this are considered zero fee for transaction creation (default: %s)\",\n-            FormatMoney(CWallet::minTxFee.GetFeePerK())));\n-    strUsage += HelpMessageOpt(\"-paytxfee=<amt>\", strprintf(_(\"Fee (in BTC/kB) to add to transactions you send (default: %s)\"), FormatMoney(payTxFee.GetFeePerK())));\n-    strUsage += HelpMessageOpt(\"-rescan\", _(\"Rescan the block chain for missing wallet transactions\") + \" \" + _(\"on startup\"));\n-    strUsage += HelpMessageOpt(\"-salvagewallet\", _(\"Attempt to recover private keys from a corrupt wallet.dat\") + \" \" + _(\"on startup\"));\n-    strUsage += HelpMessageOpt(\"-sendfreetransactions\", strprintf(_(\"Send transactions as zero-fee transactions if possible (default: %u)\"), 0));\n-    strUsage += HelpMessageOpt(\"-spendzeroconfchange\", strprintf(_(\"Spend unconfirmed change when sending transactions (default: %u)\"), 1));\n-    strUsage += HelpMessageOpt(\"-txconfirmtarget=<n>\", strprintf(_(\"If paytxfee is not set, include enough fee so transactions begin confirmation on average within n blocks (default: %u)\"), DEFAULT_TX_CONFIRM_TARGET));\n-    strUsage += HelpMessageOpt(\"-maxtxfee=<amt>\", strprintf(_(\"Maximum total fees to use in a single wallet transaction; setting this too low may abort large transactions (default: %s)\"),\n-        FormatMoney(maxTxFee)));\n-    strUsage += HelpMessageOpt(\"-upgradewallet\", _(\"Upgrade wallet to latest format\") + \" \" + _(\"on startup\"));\n-    strUsage += HelpMessageOpt(\"-wallet=<file>\", _(\"Specify wallet file (within data directory)\") + \" \" + strprintf(_(\"(default: %s)\"), \"wallet.dat\"));\n-    strUsage += HelpMessageOpt(\"-walletbroadcast\", _(\"Make the wallet broadcast transactions\") + \" \" + strprintf(_(\"(default: %u)\"), true));\n-    strUsage += HelpMessageOpt(\"-walletnotify=<cmd>\", _(\"Execute command when a wallet transaction changes (%s in cmd is replaced by TxID)\"));\n-    strUsage += HelpMessageOpt(\"-zapwallettxes=<mode>\", _(\"Delete all wallet transactions and only recover those parts of the blockchain through -rescan on startup\") +\n-        \" \" + _(\"(1 = keep tx meta data e.g. account owner and payment request information, 2 = drop tx meta data)\"));\n+    CWallet::AppendHelpMessageString(strUsage);\n #endif\n \n     strUsage += HelpMessageGroup(_(\"Debugging/Testing options:\"));\n@@ -797,10 +777,6 @@ bool AppInit2(boost::thread_group& threadGroup, CScheduler& scheduler)\n         fPruneMode = true;\n     }\n \n-#ifdef ENABLE_WALLET\n-    bool fDisableWallet = GetBoolArg(\"-disablewallet\", false);\n-#endif\n-\n     nConnectTimeout = GetArg(\"-timeout\", DEFAULT_CONNECT_TIMEOUT);\n     if (nConnectTimeout <= 0)\n         nConnectTimeout = DEFAULT_CONNECT_TIMEOUT;\n@@ -825,47 +801,14 @@ bool AppInit2(boost::thread_group& threadGroup, CScheduler& scheduler)\n         return InitError(strprintf(\"acceptnonstdtxn is not currently supported for %s chain\", chainparams.NetworkIDString()));\n \n #ifdef ENABLE_WALLET\n-    if (mapArgs.count(\"-mintxfee\"))\n-    {\n-        CAmount n = 0;\n-        if (ParseMoney(mapArgs[\"-mintxfee\"], n) && n > 0)\n-            CWallet::minTxFee = CFeeRate(n);\n-        else\n-            return InitError(strprintf(_(\"Invalid amount for -mintxfee=<amount>: '%s'\"), mapArgs[\"-mintxfee\"]));\n-    }\n-    if (mapArgs.count(\"-paytxfee\"))\n-    {\n-        CAmount nFeePerK = 0;\n-        if (!ParseMoney(mapArgs[\"-paytxfee\"], nFeePerK))\n-            return InitError(strprintf(_(\"Invalid amount for -paytxfee=<amount>: '%s'\"), mapArgs[\"-paytxfee\"]));\n-        if (nFeePerK > nHighTransactionFeeWarning)\n-            InitWarning(_(\"Warning: -paytxfee is set very high! This is the transaction fee you will pay if you send a transaction.\"));\n-        payTxFee = CFeeRate(nFeePerK, 1000);\n-        if (payTxFee < ::minRelayTxFee)\n-        {\n-            return InitError(strprintf(_(\"Invalid amount for -paytxfee=<amount>: '%s' (must be at least %s)\"),\n-                                       mapArgs[\"-paytxfee\"], ::minRelayTxFee.ToString()));\n-        }\n-    }\n-    if (mapArgs.count(\"-maxtxfee\"))\n-    {\n-        CAmount nMaxFee = 0;\n-        if (!ParseMoney(mapArgs[\"-maxtxfee\"], nMaxFee))\n-            return InitError(strprintf(_(\"Invalid amount for -maxtxfee=<amount>: '%s'\"), mapArgs[\"-maptxfee\"]));\n-        if (nMaxFee > nHighTransactionMaxFeeWarning)\n-            InitWarning(_(\"Warning: -maxtxfee is set very high! Fees this large could be paid on a single transaction.\"));\n-        maxTxFee = nMaxFee;\n-        if (CFeeRate(maxTxFee, 1000) < ::minRelayTxFee)\n-        {\n-            return InitError(strprintf(_(\"Invalid amount for -maxtxfee=<amount>: '%s' (must be at least the minrelay fee of %s to prevent stuck transactions)\"),\n-                                       mapArgs[\"-maxtxfee\"], ::minRelayTxFee.ToString()));\n-        }\n-    }\n-    nTxConfirmTarget = GetArg(\"-txconfirmtarget\", DEFAULT_TX_CONFIRM_TARGET);\n-    bSpendZeroConfChange = GetBoolArg(\"-spendzeroconfchange\", true);\n-    fSendFreeTransactions = GetBoolArg(\"-sendfreetransactions\", false);\n+    std::string warningString, errorString;\n+\n+    CWallet::MapParameters(warningString, errorString);\n \n-    std::string strWalletFile = GetArg(\"-wallet\", \"wallet.dat\");\n+    if (!warningString.empty())\n+        InitWarning(warningString);\n+    if (!errorString.empty())\n+        return InitError(errorString);\n #endif // ENABLE_WALLET\n \n     fIsBareMultisigStd = GetBoolArg(\"-permitbaremultisig\", true);\n@@ -887,9 +830,10 @@ bool AppInit2(boost::thread_group& threadGroup, CScheduler& scheduler)\n \n     std::string strDataDir = GetDataDir().string();\n #ifdef ENABLE_WALLET\n-    // Wallet file must be a plain filename without a directory\n-    if (strWalletFile != boost::filesystem::basename(strWalletFile) + boost::filesystem::extension(strWalletFile))\n-        return InitError(strprintf(_(\"Wallet %s resides outside data directory %s\"), strWalletFile, strDataDir));\n+    errorString.clear();\n+    CWallet::SanityCheck(errorString);\n+    if (!errorString.empty())\n+        return InitError(errorString);\n #endif\n     // Make sure only a single Bitcoin process is using the data directory.\n     boost::filesystem::path pathLockFile = GetDataDir() / \".lock\";\n@@ -913,7 +857,7 @@ bool AppInit2(boost::thread_group& threadGroup, CScheduler& scheduler)\n     LogPrintf(\"Bitcoin version %s (%s)\\n\", FormatFullVersion(), CLIENT_DATE);\n     LogPrintf(\"Using OpenSSL version %s\\n\", SSLeay_version(SSLEAY_VERSION));\n #ifdef ENABLE_WALLET\n-    LogPrintf(\"Using BerkeleyDB version %s\\n\", DbEnv::version(0, 0, 0));\n+    CWallet::LogGeneralInfos();\n #endif\n     if (!fLogTimestamps)\n         LogPrintf(\"Startup time: %s\\n\", DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", GetTime()));\n@@ -950,22 +894,20 @@ bool AppInit2(boost::thread_group& threadGroup, CScheduler& scheduler)\n \n     // ********************************************************* Step 5: verify wallet database integrity\n #ifdef ENABLE_WALLET\n-    if (!fDisableWallet) {\n-        LogPrintf(\"Using wallet %s\\n\", strWalletFile);\n+    if (!CWallet::IsDisabled()) {\n         uiInterface.InitMessage(_(\"Verifying wallet...\"));\n \n-        std::string warningString;\n-        std::string errorString;\n-\n-        if (!CWallet::Verify(strWalletFile, warningString, errorString))\n+        std::string warningString, errorString;\n+        \n+        if (!CWallet::Verify(warningString, errorString))\n             return false;\n \n         if (!warningString.empty())\n             InitWarning(warningString);\n         if (!errorString.empty())\n-            return InitError(warningString);\n-\n-    } // (!fDisableWallet)\n+            return InitError(errorString);\n+        \n+    }\n #endif // ENABLE_WALLET\n     // ********************************************************* Step 6: network initialization\n \n@@ -1242,154 +1184,23 @@ bool AppInit2(boost::thread_group& threadGroup, CScheduler& scheduler)\n \n     // ********************************************************* Step 8: load wallet\n #ifdef ENABLE_WALLET\n-    if (fDisableWallet) {\n+    if (CWallet::IsDisabled()) {\n         pwalletMain = NULL;\n         LogPrintf(\"Wallet disabled!\\n\");\n     } else {\n-\n-        // needed to restore wallet transaction meta data after -zapwallettxes\n-        std::vector<CWalletTx> vWtx;\n-\n-        if (GetBoolArg(\"-zapwallettxes\", false)) {\n-            uiInterface.InitMessage(_(\"Zapping all transactions from wallet...\"));\n-\n-            pwalletMain = new CWallet(strWalletFile);\n-            DBErrors nZapWalletRet = pwalletMain->ZapWalletTx(vWtx);\n-            if (nZapWalletRet != DB_LOAD_OK) {\n-                uiInterface.InitMessage(_(\"Error loading wallet.dat: Wallet corrupted\"));\n-                return false;\n-            }\n-\n-            delete pwalletMain;\n-            pwalletMain = NULL;\n-        }\n-\n         uiInterface.InitMessage(_(\"Loading wallet...\"));\n+        pwalletMain = new CWallet();\n \n-        nStart = GetTimeMillis();\n-        bool fFirstRun = true;\n-        pwalletMain = new CWallet(strWalletFile);\n-        DBErrors nLoadWalletRet = pwalletMain->LoadWallet(fFirstRun);\n-        if (nLoadWalletRet != DB_LOAD_OK)\n-        {\n-            if (nLoadWalletRet == DB_CORRUPT)\n-                strErrors << _(\"Error loading wallet.dat: Wallet corrupted\") << \"\\n\";\n-            else if (nLoadWalletRet == DB_NONCRITICAL_ERROR)\n-            {\n-                string msg(_(\"Warning: error reading wallet.dat! All keys read correctly, but transaction data\"\n-                             \" or address book entries might be missing or incorrect.\"));\n-                InitWarning(msg);\n-            }\n-            else if (nLoadWalletRet == DB_TOO_NEW)\n-                strErrors << _(\"Error loading wallet.dat: Wallet requires newer version of Bitcoin Core\") << \"\\n\";\n-            else if (nLoadWalletRet == DB_NEED_REWRITE)\n-            {\n-                strErrors << _(\"Wallet needed to be rewritten: restart Bitcoin Core to complete\") << \"\\n\";\n-                LogPrintf(\"%s\", strErrors.str());\n-                return InitError(strErrors.str());\n-            }\n-            else\n-                strErrors << _(\"Error loading wallet.dat\") << \"\\n\";\n-        }\n-\n-        if (GetBoolArg(\"-upgradewallet\", fFirstRun))\n-        {\n-            int nMaxVersion = GetArg(\"-upgradewallet\", 0);\n-            if (nMaxVersion == 0) // the -upgradewallet without argument case\n-            {\n-                LogPrintf(\"Performing wallet upgrade to %i\\n\", FEATURE_LATEST);\n-                nMaxVersion = CLIENT_VERSION;\n-                pwalletMain->SetMinVersion(FEATURE_LATEST); // permanently upgrade the wallet immediately\n-            }\n-            else\n-                LogPrintf(\"Allowing wallet upgrade up to %i\\n\", nMaxVersion);\n-            if (nMaxVersion < pwalletMain->GetVersion())\n-                strErrors << _(\"Cannot downgrade wallet\") << \"\\n\";\n-            pwalletMain->SetMaxVersion(nMaxVersion);\n-        }\n-\n-        if (fFirstRun)\n-        {\n-            // Create new keyUser and set as default key\n-            RandAddSeedPerfmon();\n-\n-            CPubKey newDefaultKey;\n-            if (pwalletMain->GetKeyFromPool(newDefaultKey)) {\n-                pwalletMain->SetDefaultKey(newDefaultKey);\n-                if (!pwalletMain->SetAddressBook(pwalletMain->vchDefaultKey.GetID(), \"\", \"receive\"))\n-                    strErrors << _(\"Cannot write default address\") << \"\\n\";\n-            }\n-\n-            pwalletMain->SetBestChain(chainActive.GetLocator());\n-        }\n-\n-        LogPrintf(\"%s\", strErrors.str());\n-        LogPrintf(\" wallet      %15dms\\n\", GetTimeMillis() - nStart);\n-\n-        RegisterValidationInterface(pwalletMain);\n+        std::string warningString, errorString;\n \n-        CBlockIndex *pindexRescan = chainActive.Tip();\n-        if (GetBoolArg(\"-rescan\", false))\n-            pindexRescan = chainActive.Genesis();\n-        else\n-        {\n-            CWalletDB walletdb(strWalletFile);\n-            CBlockLocator locator;\n-            if (walletdb.ReadBestBlock(locator))\n-                pindexRescan = FindForkInGlobalIndex(chainActive, locator);\n-            else\n-                pindexRescan = chainActive.Genesis();\n-        }\n-        if (chainActive.Tip() && chainActive.Tip() != pindexRescan)\n-        {\n-            //We can't rescan beyond non-pruned blocks, stop and throw an error\n-            //this might happen if a user uses a old wallet within a pruned node\n-            // or if he ran -disablewallet for a longer time, then decided to re-enable\n-            if (fPruneMode)\n-            {\n-                CBlockIndex *block = chainActive.Tip();\n-                while (block && block->pprev && (block->pprev->nStatus & BLOCK_HAVE_DATA) && block->pprev->nTx > 0 && pindexRescan != block)\n-                    block = block->pprev;\n-\n-                if (pindexRescan != block)\n-                    return InitError(_(\"Prune: last wallet synchronisation goes beyond pruned data. You need to -reindex (download the whole blockchain again in case of pruned node)\"));\n-            }\n+        if(!pwalletMain->LoadWallet(warningString, errorString))\n+            return false;\n \n-            uiInterface.InitMessage(_(\"Rescanning...\"));\n-            LogPrintf(\"Rescanning last %i blocks (from block %i)...\\n\", chainActive.Height() - pindexRescan->nHeight, pindexRescan->nHeight);\n-            nStart = GetTimeMillis();\n-            pwalletMain->ScanForWalletTransactions(pindexRescan, true);\n-            LogPrintf(\" rescan      %15dms\\n\", GetTimeMillis() - nStart);\n-            pwalletMain->SetBestChain(chainActive.GetLocator());\n-            nWalletDBUpdated++;\n-\n-            // Restore wallet transaction metadata after -zapwallettxes=1\n-            if (GetBoolArg(\"-zapwallettxes\", false) && GetArg(\"-zapwallettxes\", \"1\") != \"2\")\n-            {\n-                CWalletDB walletdb(strWalletFile);\n-\n-                BOOST_FOREACH(const CWalletTx& wtxOld, vWtx)\n-                {\n-                    uint256 hash = wtxOld.GetHash();\n-                    std::map<uint256, CWalletTx>::iterator mi = pwalletMain->mapWallet.find(hash);\n-                    if (mi != pwalletMain->mapWallet.end())\n-                    {\n-                        const CWalletTx* copyFrom = &wtxOld;\n-                        CWalletTx* copyTo = &mi->second;\n-                        copyTo->mapValue = copyFrom->mapValue;\n-                        copyTo->vOrderForm = copyFrom->vOrderForm;\n-                        copyTo->nTimeReceived = copyFrom->nTimeReceived;\n-                        copyTo->nTimeSmart = copyFrom->nTimeSmart;\n-                        copyTo->fFromMe = copyFrom->fFromMe;\n-                        copyTo->strFromAccount = copyFrom->strFromAccount;\n-                        copyTo->nOrderPos = copyFrom->nOrderPos;\n-                        copyTo->WriteToDisk(&walletdb);\n-                    }\n-                }\n-            }\n-        }\n-        pwalletMain->SetBroadcastTransactions(GetBoolArg(\"-walletbroadcast\", true));\n-    } // (!fDisableWallet)\n+        if (!warningString.empty())\n+            InitWarning(warningString);\n+        if (!errorString.empty())\n+            return InitError(errorString);\n+    }\n #else // ENABLE_WALLET\n     LogPrintf(\"No wallet support compiled in!\\n\");\n #endif // !ENABLE_WALLET\n@@ -1431,9 +1242,8 @@ bool AppInit2(boost::thread_group& threadGroup, CScheduler& scheduler)\n     LogPrintf(\"mapBlockIndex.size() = %u\\n\",   mapBlockIndex.size());\n     LogPrintf(\"nBestHeight = %d\\n\",                   chainActive.Height());\n #ifdef ENABLE_WALLET\n-    LogPrintf(\"setKeyPool.size() = %u\\n\",      pwalletMain ? pwalletMain->setKeyPool.size() : 0);\n-    LogPrintf(\"mapWallet.size() = %u\\n\",       pwalletMain ? pwalletMain->mapWallet.size() : 0);\n-    LogPrintf(\"mapAddressBook.size() = %u\\n\",  pwalletMain ? pwalletMain->mapAddressBook.size() : 0);\n+    if (pwalletMain)\n+        pwalletMain->LogInfos();\n #endif\n \n     StartNode(threadGroup, scheduler);"
      },
      {
        "sha": "2ac19f06d4da729427e2f9d9e7f9e460feb92c32",
        "filename": "src/test/test_bitcoin.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 4,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/de52ba4c239c0d5198dcbfc637de2c5a17e02def/src/test/test_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/de52ba4c239c0d5198dcbfc637de2c5a17e02def/src/test/test_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.cpp?ref=de52ba4c239c0d5198dcbfc637de2c5a17e02def",
        "patch": "@@ -54,10 +54,9 @@ TestingSetup::TestingSetup()\n         pcoinsTip = new CCoinsViewCache(pcoinsdbview);\n         InitBlockIndex();\n #ifdef ENABLE_WALLET\n-        bool fFirstRun;\n-        pwalletMain = new CWallet(\"wallet.dat\");\n-        pwalletMain->LoadWallet(fFirstRun);\n-        RegisterValidationInterface(pwalletMain);\n+        std::string warningString, errorString;\n+        pwalletMain = new CWallet();\n+        pwalletMain->LoadWallet(warningString, errorString);\n #endif\n         nScriptCheckThreads = 3;\n         for (int i=0; i < nScriptCheckThreads-1; i++)"
      },
      {
        "sha": "9d4a2cf007a1305138948db4d23555e0fd1571dc",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 243,
        "deletions": 12,
        "changes": 255,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/de52ba4c239c0d5198dcbfc637de2c5a17e02def/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/de52ba4c239c0d5198dcbfc637de2c5a17e02def/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=de52ba4c239c0d5198dcbfc637de2c5a17e02def",
        "patch": "@@ -349,8 +349,11 @@ void CWallet::Flush(bool shutdown)\n     bitdb.Flush(shutdown);\n }\n \n-bool CWallet::Verify(const string& walletFile, string& warningString, string& errorString)\n+bool CWallet::Verify(string& warningString, string& errorString)\n {\n+    const std::string walletFile = CWallet::GetWalletFile();\n+    LogPrintf(\"Using wallet %s\\n\", walletFile);\n+\n     if (!bitdb.Open(GetDataDir()))\n     {\n         // try moving the database env out of the way\n@@ -378,7 +381,7 @@ bool CWallet::Verify(const string& walletFile, string& warningString, string& er\n         if (!CWalletDB::Recover(bitdb, walletFile, true))\n             return false;\n     }\n-    \n+\n     if (boost::filesystem::exists(GetDataDir() / walletFile))\n     {\n         CDBEnv::VerifyResult r = bitdb.Verify(walletFile, CWalletDB::Recover);\n@@ -900,6 +903,99 @@ CAmount CWallet::GetChange(const CTransaction& tx) const\n     return nChange;\n }\n \n+bool CWallet::IsDisabled()\n+{\n+    return GetBoolArg(\"-disablewallet\", false);\n+}\n+\n+void CWallet::MapParameters(string& warningString, string& errorString)\n+{\n+    if (mapArgs.count(\"-mintxfee\"))\n+    {\n+        CAmount n = 0;\n+        if (ParseMoney(mapArgs[\"-mintxfee\"], n) && n > 0)\n+            CWallet::minTxFee = CFeeRate(n);\n+        else\n+        {\n+            errorString += strprintf(_(\"Invalid amount for -mintxfee=<amount>: '%s'\"), mapArgs[\"-mintxfee\"]);\n+            return;\n+        }\n+    }\n+    if (mapArgs.count(\"-paytxfee\"))\n+    {\n+        CAmount nFeePerK = 0;\n+        if (!ParseMoney(mapArgs[\"-paytxfee\"], nFeePerK))\n+            errorString += strprintf(_(\"Invalid amount for -paytxfee=<amount>: '%s'\"), mapArgs[\"-paytxfee\"]); return;\n+        if (nFeePerK > nHighTransactionFeeWarning)\n+            warningString += _(\"Warning: -paytxfee is set very high! This is the transaction fee you will pay if you send a transaction.\"); return;\n+        payTxFee = CFeeRate(nFeePerK, 1000);\n+        if (payTxFee < ::minRelayTxFee)\n+            errorString += strprintf(_(\"Invalid amount for -paytxfee=<amount>: '%s' (must be at least %s)\"),\n+                                     mapArgs[\"-paytxfee\"], ::minRelayTxFee.ToString()); return;\n+    }\n+    if (mapArgs.count(\"-maxtxfee\"))\n+    {\n+        CAmount nMaxFee = 0;\n+        if (!ParseMoney(mapArgs[\"-maxtxfee\"], nMaxFee))\n+            errorString += strprintf(_(\"Invalid amount for -maxtxfee=<amount>: '%s'\"), mapArgs[\"-maptxfee\"]); return;\n+        if (nMaxFee > nHighTransactionMaxFeeWarning)\n+            warningString += _(\"Warning: -maxtxfee is set very high! Fees this large could be paid on a single transaction.\"); return;\n+        maxTxFee = nMaxFee;\n+        if (CFeeRate(maxTxFee, 1000) < ::minRelayTxFee)\n+             errorString += strprintf(_(\"Invalid amount for -maxtxfee=<amount>: '%s' (must be at least the minrelay fee of %s to prevent stuck transactions)\"), mapArgs[\"-maxtxfee\"], ::minRelayTxFee.ToString()); return;\n+    }\n+    nTxConfirmTarget = GetArg(\"-txconfirmtarget\", DEFAULT_TX_CONFIRM_TARGET);\n+    bSpendZeroConfChange = GetArg(\"-spendzeroconfchange\", true);\n+    fSendFreeTransactions = GetArg(\"-sendfreetransactions\", false);\n+}\n+\n+std::string CWallet::GetWalletFile()\n+{\n+    return GetArg(\"-wallet\", \"wallet.dat\");\n+}\n+\n+void CWallet::SanityCheck(string& errorString)\n+{\n+    std::string strWalletFile = GetWalletFile();\n+    // Wallet file must be a plain filename without a directory\n+    if (strWalletFile != boost::filesystem::basename(strWalletFile) + boost::filesystem::extension(strWalletFile))\n+        errorString += strprintf(_(\"Wallet %s resides outside data directory\"), strWalletFile);\n+}\n+\n+void CWallet::LogGeneralInfos()\n+{\n+    LogPrintf(\"Using BerkeleyDB version %s\\n\", DbEnv::version(0, 0, 0));\n+}\n+void CWallet::LogInfos() const\n+{\n+    LogPrintf(\"setKeyPool.size() = %u\\n\",      this->setKeyPool.size());\n+    LogPrintf(\"mapWallet.size() = %u\\n\",       this->mapWallet.size());\n+    LogPrintf(\"mapAddressBook.size() = %u\\n\",  this->mapAddressBook.size());\n+}\n+\n+void CWallet::AppendHelpMessageString(std::string& strUsage)\n+{\n+strUsage += HelpMessageGroup(_(\"Wallet options:\"));\n+strUsage += HelpMessageOpt(\"-disablewallet\", _(\"Do not load the wallet and disable wallet RPC calls\"));\n+strUsage += HelpMessageOpt(\"-keypool=<n>\", strprintf(_(\"Set key pool size to <n> (default: %u)\"), 100));\n+if (showDebug)\n+    strUsage += HelpMessageOpt(\"-mintxfee=<amt>\", strprintf(\"Fees (in BTC/Kb) smaller than this are considered zero fee for transaction creation (default: %s)\",\n+                                                            FormatMoney(CWallet::minTxFee.GetFeePerK())));\n+strUsage += HelpMessageOpt(\"-paytxfee=<amt>\", strprintf(_(\"Fee (in BTC/kB) to add to transactions you send (default: %s)\"), FormatMoney(payTxFee.GetFeePerK())));\n+strUsage += HelpMessageOpt(\"-rescan\", _(\"Rescan the block chain for missing wallet transactions\") + \" \" + _(\"on startup\"));\n+strUsage += HelpMessageOpt(\"-salvagewallet\", _(\"Attempt to recover private keys from a corrupt wallet.dat\") + \" \" + _(\"on startup\"));\n+strUsage += HelpMessageOpt(\"-sendfreetransactions\", strprintf(_(\"Send transactions as zero-fee transactions if possible (default: %u)\"), 0));\n+strUsage += HelpMessageOpt(\"-spendzeroconfchange\", strprintf(_(\"Spend unconfirmed change when sending transactions (default: %u)\"), 1));\n+strUsage += HelpMessageOpt(\"-txconfirmtarget=<n>\", strprintf(_(\"If paytxfee is not set, include enough fee so transactions begin confirmation on average within n blocks (default: %u)\"), DEFAULT_TX_CONFIRM_TARGET));\n+strUsage += HelpMessageOpt(\"-maxtxfee=<amt>\", strprintf(_(\"Maximum total fees to use in a single wallet transaction; setting this too low may abort large transactions (default: %s)\"),\n+                                                        FormatMoney(maxTxFee)));\n+strUsage += HelpMessageOpt(\"-upgradewallet\", _(\"Upgrade wallet to latest format\") + \" \" + _(\"on startup\"));\n+strUsage += HelpMessageOpt(\"-wallet=<file>\", _(\"Specify wallet file (within data directory)\") + \" \" + strprintf(_(\"(default: %s)\"), \"wallet.dat\"));\n+strUsage += HelpMessageOpt(\"-walletbroadcast\", _(\"Make the wallet broadcast transactions\") + \" \" + strprintf(_(\"(default: %u)\"), true));\n+strUsage += HelpMessageOpt(\"-walletnotify=<cmd>\", _(\"Execute command when a wallet transaction changes (%s in cmd is replaced by TxID)\"));\n+strUsage += HelpMessageOpt(\"-zapwallettxes=<mode>\", _(\"Delete all wallet transactions and only recover those parts of the blockchain through -rescan on startup\") +\n+                           \" \" + _(\"(1 = keep tx meta data e.g. account owner and payment request information, 2 = drop tx meta data)\"));\n+}\n int64_t CWalletTx::GetTxTime() const\n {\n     int64_t n = nTimeSmart;\n@@ -2138,13 +2234,33 @@ CAmount CWallet::GetMinimumFee(unsigned int nTxBytes, unsigned int nConfirmTarge\n \n \n \n-DBErrors CWallet::LoadWallet(bool& fFirstRunRet)\n+bool CWallet::LoadWallet(std::string& warningString, std::string& errorString)\n {\n+    // needed to restore wallet transaction meta data after -zapwallettxes\n+    std::vector<CWalletTx> vWtx;\n+\n+    if (GetBoolArg(\"-zapwallettxes\", false)) {\n+        uiInterface.InitMessage(_(\"Zapping all transactions from wallet...\"));\n+\n+        CWallet *tmpWallet = new CWallet(strWalletFile);\n+        DBErrors nZapWalletRet = tmpWallet->ZapWalletTx(vWtx);\n+        if (nZapWalletRet != DB_LOAD_OK) {\n+            uiInterface.InitMessage(_(\"Error loading wallet.dat: Wallet corrupted\"));\n+            return false;\n+        }\n+\n+        delete tmpWallet;\n+        tmpWallet = NULL;\n+    }\n+\n+    int64_t nStart = GetTimeMillis();\n+    DBErrors nLoadWallet;\n+\n     if (!fFileBacked)\n-        return DB_LOAD_OK;\n-    fFirstRunRet = false;\n-    DBErrors nLoadWalletRet = CWalletDB(strWalletFile,\"cr+\").LoadWallet(this);\n-    if (nLoadWalletRet == DB_NEED_REWRITE)\n+        nLoadWallet = DB_LOAD_OK;\n+    bool fFirstRun = false;\n+    nLoadWallet = CWalletDB(strWalletFile,\"cr+\").LoadWallet(this);\n+    if (nLoadWallet == DB_NEED_REWRITE)\n     {\n         if (CDB::Rewrite(strWalletFile, \"\\x04pool\"))\n         {\n@@ -2156,13 +2272,128 @@ DBErrors CWallet::LoadWallet(bool& fFirstRunRet)\n         }\n     }\n \n-    if (nLoadWalletRet != DB_LOAD_OK)\n-        return nLoadWalletRet;\n-    fFirstRunRet = !vchDefaultKey.IsValid();\n-\n+    if (nLoadWallet != DB_LOAD_OK)\n+    {\n+        if (nLoadWallet == DB_CORRUPT)\n+            errorString += _(\"Error loading wallet.dat: Wallet corrupted\") + \"\\n\";\n+        else if (nLoadWallet == DB_NONCRITICAL_ERROR)\n+        {\n+            warningString += _(\"Warning: error reading wallet.dat! All keys read correctly, but transaction data\"\n+                                   \" or address book entries might be missing or incorrect.\"); return true;\n+        }\n+        else if (nLoadWallet == DB_TOO_NEW)\n+            errorString += _(\"Error loading wallet.dat: Wallet requires newer version of Bitcoin Core\") + \"\\n\";\n+        else if (nLoadWallet == DB_NEED_REWRITE)\n+        {\n+            errorString += _(\"Wallet needed to be rewritten: restart Bitcoin Core to complete\") + \"\\n\";\n+            LogPrintf(\"%s\", errorString);\n+            return true;\n+        }\n+        else\n+            errorString += _(\"Error loading wallet.dat\") + \"\\n\";\n+    }\n+    fFirstRun = !vchDefaultKey.IsValid();\n     uiInterface.LoadWallet(this);\n \n-    return DB_LOAD_OK;\n+    if (GetBoolArg(\"-upgradewallet\", fFirstRun))\n+    {\n+        int nMaxVersion = GetArg(\"-upgradewallet\", 0);\n+        if (nMaxVersion == 0) // the -upgradewallet without argument case\n+        {\n+            LogPrintf(\"Performing wallet upgrade to %i\\n\", FEATURE_LATEST);\n+            nMaxVersion = CLIENT_VERSION;\n+            this->SetMinVersion(FEATURE_LATEST); // permanently upgrade the wallet immediately\n+        }\n+        else\n+            LogPrintf(\"Allowing wallet upgrade up to %i\\n\", nMaxVersion);\n+        if (nMaxVersion < this->GetVersion())\n+            errorString += _(\"Cannot downgrade wallet\") + \"\\n\";\n+        this->SetMaxVersion(nMaxVersion);\n+    }\n+\n+    if (fFirstRun)\n+    {\n+        // Create new keyUser and set as default key\n+        RandAddSeedPerfmon();\n+\n+        CPubKey newDefaultKey;\n+        if (this->GetKeyFromPool(newDefaultKey)) {\n+            this->SetDefaultKey(newDefaultKey);\n+            if (!this->SetAddressBook(this->vchDefaultKey.GetID(), \"\", \"receive\"))\n+                errorString += _(\"Cannot write default address\") + \"\\n\";\n+        }\n+\n+        this->SetBestChain(chainActive.GetLocator());\n+    }\n+\n+    LogPrintf(\"%s\", errorString);\n+    LogPrintf(\" wallet      %15dms\\n\", GetTimeMillis() - nStart);\n+\n+    RegisterValidationInterface(this);\n+\n+    CBlockIndex *pindexRescan = chainActive.Tip();\n+    if (GetBoolArg(\"-rescan\", false))\n+        pindexRescan = chainActive.Genesis();\n+    else\n+    {\n+        CWalletDB walletdb(strWalletFile);\n+        CBlockLocator locator;\n+        if (walletdb.ReadBestBlock(locator))\n+            pindexRescan = FindForkInGlobalIndex(chainActive, locator);\n+        else\n+            pindexRescan = chainActive.Genesis();\n+    }\n+    if (chainActive.Tip() && chainActive.Tip() != pindexRescan)\n+    {\n+        //We can't rescan beyond non-pruned blocks, stop and throw an error\n+        //this might happen if a user uses a old wallet within a pruned node\n+        // or if he ran -disablewallet for a longer time, then decided to re-enable\n+        if (fPruneMode)\n+        {\n+            CBlockIndex *block = chainActive.Tip();\n+            while (block && block->pprev && (block->pprev->nStatus & BLOCK_HAVE_DATA) && block->pprev->nTx > 0 && pindexRescan != block)\n+                block = block->pprev;\n+\n+            if (pindexRescan != block)\n+                return InitError(_(\"Prune: last wallet synchronisation goes beyond pruned data. You need to -reindex (download the whole blockchain again in case of pruned node)\"));\n+        }\n+        \n+        uiInterface.InitMessage(_(\"Rescanning...\"));\n+        LogPrintf(\"Rescanning last %i blocks (from block %i)...\\n\", chainActive.Height() - pindexRescan->nHeight, pindexRescan->nHeight);\n+        nStart = GetTimeMillis();\n+        this->ScanForWalletTransactions(pindexRescan, true);\n+        LogPrintf(\" rescan      %15dms\\n\", GetTimeMillis() - nStart);\n+        this->SetBestChain(chainActive.GetLocator());\n+        nWalletDBUpdated++;\n+\n+        // Restore wallet transaction metadata after -zapwallettxes=1\n+        if (GetBoolArg(\"-zapwallettxes\", false) && GetArg(\"-zapwallettxes\", \"1\") != \"2\")\n+        {\n+            CWalletDB walletdb(strWalletFile);\n+\n+            BOOST_FOREACH(const CWalletTx& wtxOld, vWtx)\n+            {\n+                uint256 hash = wtxOld.GetHash();\n+                std::map<uint256, CWalletTx>::iterator mi = this->mapWallet.find(hash);\n+                if (mi != this->mapWallet.end())\n+                {\n+                    const CWalletTx* copyFrom = &wtxOld;\n+                    CWalletTx* copyTo = &mi->second;\n+                    copyTo->mapValue = copyFrom->mapValue;\n+                    copyTo->vOrderForm = copyFrom->vOrderForm;\n+                    copyTo->nTimeReceived = copyFrom->nTimeReceived;\n+                    copyTo->nTimeSmart = copyFrom->nTimeSmart;\n+                    copyTo->fFromMe = copyFrom->fFromMe;\n+                    copyTo->strFromAccount = copyFrom->strFromAccount;\n+                    copyTo->nOrderPos = copyFrom->nOrderPos;\n+                    copyTo->WriteToDisk(&walletdb);\n+                }\n+            }\n+        }\n+    }\n+    this->SetBroadcastTransactions(GetBoolArg(\"-walletbroadcast\", true));\n+\n+    return true;\n }\n \n "
      },
      {
        "sha": "2c8955852dc319b1c487caf91aab17db2af38ad7",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 24,
        "deletions": 3,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/de52ba4c239c0d5198dcbfc637de2c5a17e02def/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/de52ba4c239c0d5198dcbfc637de2c5a17e02def/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=de52ba4c239c0d5198dcbfc637de2c5a17e02def",
        "patch": "@@ -499,6 +499,9 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n     CWallet()\n     {\n         SetNull();\n+\n+        strWalletFile = GetWalletFile();\n+        fFileBacked = true;\n     }\n \n     CWallet(const std::string& strWalletFileIn)\n@@ -666,7 +669,7 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n     CAmount GetChange(const CTransaction& tx) const;\n     void SetBestChain(const CBlockLocator& loc);\n \n-    DBErrors LoadWallet(bool& fFirstRunRet);\n+    bool LoadWallet(std::string& warningString, std::string& errorString);\n     DBErrors ZapWalletTx(std::vector<CWalletTx>& vWtx);\n \n     bool SetAddressBook(const CTxDestination& address, const std::string& strName, const std::string& purpose);\n@@ -715,9 +718,27 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n     //! Flush wallet (bitdb flush)\n     void Flush(bool shutdown=false);\n \n+    //! Dump wallet infos to log\n+    void LogInfos() const;\n+    static void LogGeneralInfos();\n+\n     //! Verify the wallet database and perform salvage if required\n-    static bool Verify(const std::string& walletFile, std::string& warningString, std::string& errorString);\n-    \n+    static bool Verify(std::string& warningString, std::string& errorString);\n+\n+    static bool IsDisabled();\n+\n+    //! Map parameters to internal vars\n+    static void MapParameters(std::string& warningString, std::string& errorString);\n+\n+    //! Get user defined wallet file\n+    static std::string GetWalletFile();\n+\n+    //! Performs sanity check and appends possible errors to given string\n+    static void SanityCheck(std::string& errorString);\n+\n+    //! append help text to existing string\n+    static void AppendHelpMessageString(std::string& strUsage);\n+\n     /** \n      * Address book entry changed.\n      * @note called with lock cs_wallet held."
      }
    ]
  },
  {
    "sha": "fa6a5b28fcaa612c6512c6028184df6b346fdad4",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYTZhNWIyOGZjYWE2MTJjNjUxMmM2MDI4MTg0ZGY2YjM0NmZkYWQ0",
    "commit": {
      "author": {
        "name": "Jonas Schnelli",
        "email": "jonas.schnelli@include7.ch",
        "date": "2015-05-08T09:39:52Z"
      },
      "committer": {
        "name": "Jonas Schnelli",
        "email": "jonas.schnelli@include7.ch",
        "date": "2015-07-08T14:57:52Z"
      },
      "message": "decouple wallet from core, allow multiple wallets through signaling",
      "tree": {
        "sha": "825172ffeca426e3be94a2fd4c73e71bfdc26eeb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/825172ffeca426e3be94a2fd4c73e71bfdc26eeb"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fa6a5b28fcaa612c6512c6028184df6b346fdad4",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa6a5b28fcaa612c6512c6028184df6b346fdad4",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fa6a5b28fcaa612c6512c6028184df6b346fdad4",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa6a5b28fcaa612c6512c6028184df6b346fdad4/comments",
    "author": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "de52ba4c239c0d5198dcbfc637de2c5a17e02def",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/de52ba4c239c0d5198dcbfc637de2c5a17e02def",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/de52ba4c239c0d5198dcbfc637de2c5a17e02def"
      }
    ],
    "stats": {
      "total": 572,
      "additions": 356,
      "deletions": 216
    },
    "files": [
      {
        "sha": "8ae9d21e3ea5c907f9ae78100a7afc68b9d1f0c1",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa6a5b28fcaa612c6512c6028184df6b346fdad4/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa6a5b28fcaa612c6512c6028184df6b346fdad4/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=fa6a5b28fcaa612c6512c6028184df6b346fdad4",
        "patch": "@@ -150,7 +150,8 @@ BITCOIN_CORE_H = \\\n   validationinterface.h \\\n   version.h \\\n   wallet/crypter.h \\\n-  wallet/db.h \\\n+  wallet/legacywallet.h \\\n+  wallet/walletdb.h \\\n   wallet/wallet.h \\\n   wallet/wallet_ismine.h \\\n   wallet/walletdb.h\n@@ -199,6 +200,7 @@ libbitcoin_wallet_a_CPPFLAGS = $(BITCOIN_INCLUDES)\n libbitcoin_wallet_a_SOURCES = \\\n   wallet/crypter.cpp \\\n   wallet/db.cpp \\\n+  wallet/legacywallet.cpp \\\n   wallet/rpcdump.cpp \\\n   wallet/rpcwallet.cpp \\\n   wallet/wallet.cpp \\"
      },
      {
        "sha": "5954385d9fe03b286c3766847922b5435e4cd579",
        "filename": "src/bitcoind.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 0,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa6a5b28fcaa612c6512c6028184df6b346fdad4/src/bitcoind.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa6a5b28fcaa612c6512c6028184df6b346fdad4/src/bitcoind.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoind.cpp?ref=fa6a5b28fcaa612c6512c6028184df6b346fdad4",
        "patch": "@@ -11,6 +11,10 @@\n #include \"scheduler.h\"\n #include \"util.h\"\n \n+#ifdef ENABLE_WALLET\n+#include \"wallet/legacywallet.h\"\n+#endif\n+\n #include <boost/algorithm/string/predicate.hpp>\n #include <boost/filesystem.hpp>\n #include <boost/thread.hpp>\n@@ -66,6 +70,11 @@ bool AppInit(int argc, char* argv[])\n     // If Qt is used, parameters/bitcoin.conf are parsed in qt/bitcoin.cpp's main()\n     ParseParameters(argc, argv);\n \n+    // Register Devices\n+#ifdef ENABLE_WALLET\n+    CLegacyWalletModule::RegisterSignals();\n+#endif\n+    \n     // Process help and version before taking care about datadir\n     if (mapArgs.count(\"-?\") || mapArgs.count(\"-help\") || mapArgs.count(\"-version\"))\n     {\n@@ -163,6 +172,11 @@ bool AppInit(int argc, char* argv[])\n     }\n     Shutdown();\n \n+    // Unregister Devices\n+#ifdef ENABLE_WALLET\n+    CLegacyWalletModule::UnregisterSignals();\n+#endif\n+    \n     return fRet;\n }\n "
      },
      {
        "sha": "b752e4301b95920dd91bbabb36f754569df98f99",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 41,
        "deletions": 95,
        "changes": 136,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa6a5b28fcaa612c6512c6028184df6b346fdad4/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa6a5b28fcaa612c6512c6028184df6b346fdad4/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=fa6a5b28fcaa612c6512c6028184df6b346fdad4",
        "patch": "@@ -28,7 +28,7 @@\n #include \"utilmoneystr.h\"\n #include \"validationinterface.h\"\n #ifdef ENABLE_WALLET\n-#include \"wallet/wallet.h\"\n+#include \"wallet/legacywallet.h\"\n #endif\n \n #include <stdint.h>\n@@ -49,9 +49,6 @@\n \n using namespace std;\n \n-#ifdef ENABLE_WALLET\n-CWallet* pwalletMain = NULL;\n-#endif\n bool fFeeEstimatesInitialized = false;\n \n #ifdef WIN32\n@@ -153,10 +150,7 @@ void Shutdown()\n     RenameThread(\"bitcoin-shutoff\");\n     mempool.AddTransactionsUpdated(1);\n     StopRPCThreads();\n-#ifdef ENABLE_WALLET\n-    if (pwalletMain)\n-        pwalletMain->Flush(false);\n-#endif\n+    GetMainSignals().ShutdownRPCStopped();\n     GenerateBitcoins(false, 0, Params());\n     StopNode();\n     UnregisterNodeSignals(GetNodeSignals());\n@@ -186,10 +180,7 @@ void Shutdown()\n         delete pblocktree;\n         pblocktree = NULL;\n     }\n-#ifdef ENABLE_WALLET\n-    if (pwalletMain)\n-        pwalletMain->Flush(true);\n-#endif\n+    GetMainSignals().ShutdownNodeStopped();\n #ifndef WIN32\n     try {\n         boost::filesystem::remove(GetPidFile());\n@@ -198,10 +189,7 @@ void Shutdown()\n     }\n #endif\n     UnregisterAllValidationInterfaces();\n-#ifdef ENABLE_WALLET\n-    delete pwalletMain;\n-    pwalletMain = NULL;\n-#endif\n+    GetMainSignals().ShutdownFinished();\n     ECC_Stop();\n     LogPrintf(\"%s: done\\n\", __func__);\n }\n@@ -330,9 +318,8 @@ std::string HelpMessage(HelpMessageMode mode)\n     strUsage += HelpMessageOpt(\"-whitelist=<netmask>\", _(\"Whitelist peers connecting from the given netmask or IP address. Can be specified multiple times.\") +\n         \" \" + _(\"Whitelisted peers cannot be DoS banned and their transactions are always relayed, even if they are already in the mempool, useful e.g. for a gateway\"));\n \n-#ifdef ENABLE_WALLET\n-    CWallet::AppendHelpMessageString(strUsage);\n-#endif\n+    // Allow validation interfaces to add a string to the help/usage text\n+    GetMainSignals().CreateHelpString(strUsage, false);\n \n     strUsage += HelpMessageGroup(_(\"Debugging/Testing options:\"));\n     if (showDebug)\n@@ -343,8 +330,8 @@ std::string HelpMessage(HelpMessageMode mode)\n         strUsage += HelpMessageOpt(\"-testsafemode\", strprintf(\"Force safe mode (default: %u)\", 0));\n         strUsage += HelpMessageOpt(\"-dropmessagestest=<n>\", \"Randomly drop 1 of every <n> network messages\");\n         strUsage += HelpMessageOpt(\"-fuzzmessagestest=<n>\", \"Randomly fuzz 1 of every <n> network messages\");\n-        strUsage += HelpMessageOpt(\"-flushwallet\", strprintf(\"Run a thread to flush wallet periodically (default: %u)\", 1));\n         strUsage += HelpMessageOpt(\"-stopafterblockimport\", strprintf(\"Stop running after importing blocks from disk (default: %u)\", 0));\n+        GetMainSignals().CreateHelpString(strUsage, true);\n     }\n     string debugCategories = \"addrman, alert, bench, coindb, db, lock, rand, rpc, selectcoins, mempool, net, proxy, prune\"; // Don't translate these and qt below\n     if (mode == HMM_BITCOIN_QT)\n@@ -693,18 +680,6 @@ bool AppInit2(boost::thread_group& threadGroup, CScheduler& scheduler)\n             LogPrintf(\"%s: parameter interaction: -externalip set -> setting -discover=0\\n\", __func__);\n     }\n \n-    if (GetBoolArg(\"-salvagewallet\", false)) {\n-        // Rewrite just private keys: rescan to find transactions\n-        if (SoftSetBoolArg(\"-rescan\", true))\n-            LogPrintf(\"%s: parameter interaction: -salvagewallet=1 -> setting -rescan=1\\n\", __func__);\n-    }\n-\n-    // -zapwallettx implies a rescan\n-    if (GetBoolArg(\"-zapwallettxes\", false)) {\n-        if (SoftSetBoolArg(\"-rescan\", true))\n-            LogPrintf(\"%s: parameter interaction: -zapwallettxes=<mode> -> setting -rescan=1\\n\", __func__);\n-    }\n-\n     // Make sure enough file descriptors are available\n     int nBind = std::max((int)mapArgs.count(\"-bind\") + (int)mapArgs.count(\"-whitebind\"), 1);\n     nMaxConnections = GetArg(\"-maxconnections\", 125);\n@@ -800,16 +775,12 @@ bool AppInit2(boost::thread_group& threadGroup, CScheduler& scheduler)\n     if (Params().RequireStandard() && !fRequireStandard)\n         return InitError(strprintf(\"acceptnonstdtxn is not currently supported for %s chain\", chainparams.NetworkIDString()));\n \n-#ifdef ENABLE_WALLET\n     std::string warningString, errorString;\n-\n-    CWallet::MapParameters(warningString, errorString);\n-\n+    GetMainSignals().ParameterInteraction(warningString, errorString);\n     if (!warningString.empty())\n         InitWarning(warningString);\n     if (!errorString.empty())\n         return InitError(errorString);\n-#endif // ENABLE_WALLET\n \n     fIsBareMultisigStd = GetBoolArg(\"-permitbaremultisig\", true);\n     nMaxDatacarrierBytes = GetArg(\"-datacarriersize\", nMaxDatacarrierBytes);\n@@ -829,12 +800,13 @@ bool AppInit2(boost::thread_group& threadGroup, CScheduler& scheduler)\n         return InitError(_(\"Initialization sanity check failed. Bitcoin Core is shutting down.\"));\n \n     std::string strDataDir = GetDataDir().string();\n-#ifdef ENABLE_WALLET\n+    \n+    // Give registered devices the possibility of init\n     errorString.clear();\n-    CWallet::SanityCheck(errorString);\n+    GetMainSignals().AppInitialization(errorString);\n     if (!errorString.empty())\n         return InitError(errorString);\n-#endif\n+\n     // Make sure only a single Bitcoin process is using the data directory.\n     boost::filesystem::path pathLockFile = GetDataDir() / \".lock\";\n     FILE* file = fopen(pathLockFile.string().c_str(), \"a\"); // empty lock file; created if it doesn't exist.\n@@ -856,9 +828,9 @@ bool AppInit2(boost::thread_group& threadGroup, CScheduler& scheduler)\n     LogPrintf(\"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\");\n     LogPrintf(\"Bitcoin version %s (%s)\\n\", FormatFullVersion(), CLIENT_DATE);\n     LogPrintf(\"Using OpenSSL version %s\\n\", SSLeay_version(SSLEAY_VERSION));\n-#ifdef ENABLE_WALLET\n-    CWallet::LogGeneralInfos();\n-#endif\n+\n+    GetMainSignals().AppInitializationLogHead();\n+\n     if (!fLogTimestamps)\n         LogPrintf(\"Startup time: %s\\n\", DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", GetTime()));\n     LogPrintf(\"Default data directory %s\\n\", GetDefaultDataDir().string());\n@@ -892,23 +864,18 @@ bool AppInit2(boost::thread_group& threadGroup, CScheduler& scheduler)\n \n     int64_t nStart;\n \n-    // ********************************************************* Step 5: verify wallet database integrity\n-#ifdef ENABLE_WALLET\n-    if (!CWallet::IsDisabled()) {\n-        uiInterface.InitMessage(_(\"Verifying wallet...\"));\n-\n-        std::string warningString, errorString;\n-        \n-        if (!CWallet::Verify(warningString, errorString))\n-            return false;\n-\n-        if (!warningString.empty())\n-            InitWarning(warningString);\n-        if (!errorString.empty())\n-            return InitError(errorString);\n-        \n-    }\n-#endif // ENABLE_WALLET\n+    // ********************************************************* Step 5: verify integrity of connected devices\n+    warningString.clear();\n+    errorString.clear();\n+    bool stopInit = false;\n+    GetMainSignals().VerifyIntegrity(warningString, errorString, stopInit);\n+    if (stopInit)\n+        return false;\n+    \n+    if (!warningString.empty())\n+    InitWarning(warningString);\n+    if (!errorString.empty())\n+    return InitError(errorString);\n     // ********************************************************* Step 6: network initialization\n \n     RegisterNodeSignals(GetNodeSignals());\n@@ -1182,28 +1149,18 @@ bool AppInit2(boost::thread_group& threadGroup, CScheduler& scheduler)\n         }\n     }\n \n-    // ********************************************************* Step 8: load wallet\n-#ifdef ENABLE_WALLET\n-    if (CWallet::IsDisabled()) {\n-        pwalletMain = NULL;\n-        LogPrintf(\"Wallet disabled!\\n\");\n-    } else {\n-        uiInterface.InitMessage(_(\"Loading wallet...\"));\n-        pwalletMain = new CWallet();\n-\n-        std::string warningString, errorString;\n-\n-        if(!pwalletMain->LoadWallet(warningString, errorString))\n-            return false;\n-\n-        if (!warningString.empty())\n-            InitWarning(warningString);\n-        if (!errorString.empty())\n-            return InitError(errorString);\n-    }\n-#else // ENABLE_WALLET\n-    LogPrintf(\"No wallet support compiled in!\\n\");\n-#endif // !ENABLE_WALLET\n+    // ********************************************************* Step 8: load wallets/modules\n+    warningString.clear();\n+    errorString.clear();\n+    stopInit = false;\n+    GetMainSignals().LoadModules(warningString, errorString, stopInit);\n+    if (stopInit)\n+        return false;\n+    \n+    if (!warningString.empty())\n+    InitWarning(warningString);\n+    if (!errorString.empty())\n+    return InitError(errorString);\n     // ********************************************************* Step 9: import blocks\n \n     if (mapArgs.count(\"-blocknotify\"))\n@@ -1241,12 +1198,9 @@ bool AppInit2(boost::thread_group& threadGroup, CScheduler& scheduler)\n     //// debug print\n     LogPrintf(\"mapBlockIndex.size() = %u\\n\",   mapBlockIndex.size());\n     LogPrintf(\"nBestHeight = %d\\n\",                   chainActive.Height());\n-#ifdef ENABLE_WALLET\n-    if (pwalletMain)\n-        pwalletMain->LogInfos();\n-#endif\n \n     StartNode(threadGroup, scheduler);\n+    GetMainSignals().NodeStarted();\n \n     // Monitor the chain, and alert if we get blocks much quicker or slower than expected\n     int64_t nPowTargetSpacing = Params().GetConsensus().nPowTargetSpacing;\n@@ -1262,15 +1216,7 @@ bool AppInit2(boost::thread_group& threadGroup, CScheduler& scheduler)\n     SetRPCWarmupFinished();\n     uiInterface.InitMessage(_(\"Done loading\"));\n \n-#ifdef ENABLE_WALLET\n-    if (pwalletMain) {\n-        // Add wallet transactions that aren't already in a block to mapTransactions\n-        pwalletMain->ReacceptWalletTransactions();\n-\n-        // Run a thread to flush wallet periodically\n-        threadGroup.create_thread(boost::bind(&ThreadFlushWalletDB, boost::ref(pwalletMain->strWalletFile)));\n-    }\n-#endif\n+    GetMainSignals().FinishInitializing(threadGroup);\n \n     return !fRequestShutdown;\n }"
      },
      {
        "sha": "31ec1fa11d1eab0e4d3449b4a9f4f3e356b8c0f7",
        "filename": "src/init.h",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa6a5b28fcaa612c6512c6028184df6b346fdad4/src/init.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa6a5b28fcaa612c6512c6028184df6b346fdad4/src/init.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.h?ref=fa6a5b28fcaa612c6512c6028184df6b346fdad4",
        "patch": "@@ -16,8 +16,6 @@ namespace boost\n class thread_group;\n } // namespace boost\n \n-extern CWallet* pwalletMain;\n-\n void StartShutdown();\n bool ShutdownRequested();\n void Shutdown();"
      },
      {
        "sha": "4b435ea4c5d29220fc72f119abc715a7aaf35250",
        "filename": "src/qt/bitcoin.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa6a5b28fcaa612c6512c6028184df6b346fdad4/src/qt/bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa6a5b28fcaa612c6512c6028184df6b346fdad4/src/qt/bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoin.cpp?ref=fa6a5b28fcaa612c6512c6028184df6b346fdad4",
        "patch": "@@ -31,6 +31,7 @@\n #include \"util.h\"\n \n #ifdef ENABLE_WALLET\n+#include \"wallet/legacywallet.h\"\n #include \"wallet/wallet.h\"\n #endif\n "
      },
      {
        "sha": "2e8bd8741e648556375bd329d8c8eb24e95c001d",
        "filename": "src/qt/signverifymessagedialog.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa6a5b28fcaa612c6512c6028184df6b346fdad4/src/qt/signverifymessagedialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa6a5b28fcaa612c6512c6028184df6b346fdad4/src/qt/signverifymessagedialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/signverifymessagedialog.cpp?ref=fa6a5b28fcaa612c6512c6028184df6b346fdad4",
        "patch": "@@ -13,6 +13,7 @@\n #include \"base58.h\"\n #include \"init.h\"\n #include \"main.h\" // For strMessageMagic\n+#include \"wallet/legacywallet.h\"\n #include \"wallet/wallet.h\"\n \n #include <string>"
      },
      {
        "sha": "524dca1a860e1c356c1767581a592034744be14b",
        "filename": "src/qt/splashscreen.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa6a5b28fcaa612c6512c6028184df6b346fdad4/src/qt/splashscreen.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa6a5b28fcaa612c6512c6028184df6b346fdad4/src/qt/splashscreen.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/splashscreen.cpp?ref=fa6a5b28fcaa612c6512c6028184df6b346fdad4",
        "patch": "@@ -13,6 +13,7 @@\n #include \"version.h\"\n \n #ifdef ENABLE_WALLET\n+#include \"wallet/legacywallet.h\"\n #include \"wallet/wallet.h\"\n #endif\n "
      },
      {
        "sha": "8608eddbdc22d1bfb7bc9f376622b3f1473e70dd",
        "filename": "src/rpcmisc.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa6a5b28fcaa612c6512c6028184df6b346fdad4/src/rpcmisc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa6a5b28fcaa612c6512c6028184df6b346fdad4/src/rpcmisc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcmisc.cpp?ref=fa6a5b28fcaa612c6512c6028184df6b346fdad4",
        "patch": "@@ -13,6 +13,7 @@\n #include \"timedata.h\"\n #include \"util.h\"\n #ifdef ENABLE_WALLET\n+#include \"wallet/legacywallet.h\"\n #include \"wallet/wallet.h\"\n #include \"wallet/walletdb.h\"\n #endif"
      },
      {
        "sha": "cfb404d0ede4530b3f3934bf7e1e688bf79edb88",
        "filename": "src/rpcrawtransaction.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa6a5b28fcaa612c6512c6028184df6b346fdad4/src/rpcrawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa6a5b28fcaa612c6512c6028184df6b346fdad4/src/rpcrawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcrawtransaction.cpp?ref=fa6a5b28fcaa612c6512c6028184df6b346fdad4",
        "patch": "@@ -20,6 +20,7 @@\n #include \"script/standard.h\"\n #include \"uint256.h\"\n #ifdef ENABLE_WALLET\n+#include \"wallet/legacywallet.h\"\n #include \"wallet/wallet.h\"\n #endif\n "
      },
      {
        "sha": "83c9a7762545ea3da2a5dfea77a350d3880b9e07",
        "filename": "src/test/accounting_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa6a5b28fcaa612c6512c6028184df6b346fdad4/src/test/accounting_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa6a5b28fcaa612c6512c6028184df6b346fdad4/src/test/accounting_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/accounting_tests.cpp?ref=fa6a5b28fcaa612c6512c6028184df6b346fdad4",
        "patch": "@@ -2,6 +2,7 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n+#include \"wallet/legacywallet.h\"\n #include \"wallet/wallet.h\"\n #include \"wallet/walletdb.h\"\n "
      },
      {
        "sha": "660e7710b4920c4e0180f78d41dab11a523aa4e5",
        "filename": "src/test/test_bitcoin.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa6a5b28fcaa612c6512c6028184df6b346fdad4/src/test/test_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa6a5b28fcaa612c6512c6028184df6b346fdad4/src/test/test_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.cpp?ref=fa6a5b28fcaa612c6512c6028184df6b346fdad4",
        "patch": "@@ -14,6 +14,7 @@\n #include \"util.h\"\n #ifdef ENABLE_WALLET\n #include \"wallet/db.h\"\n+#include \"wallet/legacywallet.h\"\n #include \"wallet/wallet.h\"\n #endif\n \n@@ -22,7 +23,7 @@\n #include <boost/thread.hpp>\n \n CClientUIInterface uiInterface; // Declared but not defined in ui_interface.h\n-CWallet* pwalletMain;\n+extern CWallet* pwalletMain;\n \n extern bool fPrintToConsole;\n extern void noui_connect();\n@@ -55,7 +56,7 @@ TestingSetup::TestingSetup()\n         InitBlockIndex();\n #ifdef ENABLE_WALLET\n         std::string warningString, errorString;\n-        pwalletMain = new CWallet();\n+        pwalletMain = new CWallet(CLegacyWalletModule::GetWalletFile());\n         pwalletMain->LoadWallet(warningString, errorString);\n #endif\n         nScriptCheckThreads = 3;"
      },
      {
        "sha": "2b54174da3fdba237c35e3090b43173685442aeb",
        "filename": "src/validationinterface.h",
        "status": "modified",
        "additions": 38,
        "deletions": 0,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa6a5b28fcaa612c6512c6028184df6b346fdad4/src/validationinterface.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa6a5b28fcaa612c6512c6028184df6b346fdad4/src/validationinterface.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validationinterface.h?ref=fa6a5b28fcaa612c6512c6028184df6b346fdad4",
        "patch": "@@ -9,6 +9,11 @@\n #include <boost/signals2/signal.hpp>\n #include <boost/shared_ptr.hpp>\n \n+namespace boost\n+{\n+    class thread_group;\n+} // namespace boost\n+\n class CBlock;\n struct CBlockLocator;\n class CReserveScript;\n@@ -60,6 +65,39 @@ struct CMainSignals {\n     boost::signals2::signal<void (boost::shared_ptr<CReserveScript>&)> ScriptForMining;\n     /** Notifies listeners that a block has been successfully mined */\n     boost::signals2::signal<void (const uint256 &)> BlockFound;\n+    \n+    /** Notifies listeners that the help string gets created where listeners can append characters to the given string */\n+    boost::signals2::signal<void (std::string& strUsage, bool debugHelp)> CreateHelpString;\n+    \n+    /** Notifies listeners that we are in stage of mapping arguments */\n+    boost::signals2::signal<void (std::string& warningString, std::string& errorString)> ParameterInteraction;\n+\n+    /** Notifies listeners that we are in stage of initializing the app (datadir, pid file, etc.) */\n+    boost::signals2::signal<void (std::string& errorString)> AppInitialization;\n+\n+    /** Notifies listeners that now is the time to log startup/env infos */\n+    boost::signals2::signal<void ()> AppInitializationLogHead;\n+    \n+    /** Notifies listeners that now is the time to log startup/env infos */\n+    boost::signals2::signal<void (std::string& warningString, std::string& errorString, bool& stopInit)> VerifyIntegrity;\n+    \n+    /** Notifies listeners that modules should load now */\n+    boost::signals2::signal<void (std::string& warningString, std::string& errorString, bool& stopInit)> LoadModules;\n+    \n+    /** Notifies listeners that the node has just started */\n+    boost::signals2::signal<void ()> NodeStarted;\n+    \n+    /** Notifies listeners that we have successfully initialized */\n+    boost::signals2::signal<void (boost::thread_group&)> FinishInitializing;\n+    \n+    /** Notifies listeners that we are in shutdown state (RPC stopped) */\n+    boost::signals2::signal<void ()> ShutdownRPCStopped;\n+    \n+    /** Notifies listeners that we are in shutdown state (Node stopped) */\n+    boost::signals2::signal<void ()> ShutdownNodeStopped;\n+    \n+    /** Notifies listeners that we are in shutdown state (Node stopped) */\n+    boost::signals2::signal<void ()> ShutdownFinished;\n };\n \n CMainSignals& GetMainSignals();"
      },
      {
        "sha": "3b3c1ba86db95ddeff58b86b64e338b620d38db6",
        "filename": "src/wallet/legacywallet.cpp",
        "status": "added",
        "additions": 216,
        "deletions": 0,
        "changes": 216,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa6a5b28fcaa612c6512c6028184df6b346fdad4/src/wallet/legacywallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa6a5b28fcaa612c6512c6028184df6b346fdad4/src/wallet/legacywallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/legacywallet.cpp?ref=fa6a5b28fcaa612c6512c6028184df6b346fdad4",
        "patch": "@@ -0,0 +1,216 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2014 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"wallet/legacywallet.h\"\n+\n+#include \"main.h\"\n+#include \"util.h\"\n+#include \"utilmoneystr.h\"\n+#include \"validationinterface.h\"\n+\n+#include <boost/filesystem.hpp>\n+#include <boost/thread.hpp>\n+\n+CWallet* pwalletMain = NULL;\n+\n+const static std::string DEFAULT_WALLET_FILE = \"wallet.dat\";\n+\n+namespace CLegacyWalletModule {\n+\n+std::string GetWalletFile()\n+{\n+    return GetArg(\"-wallet\", DEFAULT_WALLET_FILE);\n+}\n+\n+void AppendHelpMessageString(std::string& strUsage, bool debugHelp)\n+{\n+    if (debugHelp)\n+    {\n+        strUsage += HelpMessageOpt(\"-flushwallet\", strprintf(\"Run a thread to flush wallet periodically (default: %u)\", 1));\n+        strUsage += HelpMessageOpt(\"-mintxfee=<amt>\", strprintf(\"Fees (in BTC/Kb) smaller than this are considered zero fee for transaction creation (default: %s)\", FormatMoney(CWallet::minTxFee.GetFeePerK())));\n+        return;\n+    }\n+    strUsage += HelpMessageGroup(_(\"Wallet options:\"));\n+    strUsage += HelpMessageOpt(\"-disablewallet\", _(\"Do not load the wallet and disable wallet RPC calls\"));\n+    strUsage += HelpMessageOpt(\"-keypool=<n>\", strprintf(_(\"Set key pool size to <n> (default: %u)\"), 100));\n+    strUsage += HelpMessageOpt(\"-paytxfee=<amt>\", strprintf(_(\"Fee (in BTC/kB) to add to transactions you send (default: %s)\"), FormatMoney(payTxFee.GetFeePerK())));\n+    strUsage += HelpMessageOpt(\"-rescan\", _(\"Rescan the block chain for missing wallet transactions\") + \" \" + _(\"on startup\"));\n+    strUsage += HelpMessageOpt(\"-salvagewallet\", _(\"Attempt to recover private keys from a corrupt wallet.dat\") + \" \" + _(\"on startup\"));\n+    strUsage += HelpMessageOpt(\"-sendfreetransactions\", strprintf(_(\"Send transactions as zero-fee transactions if possible (default: %u)\"), 0));\n+    strUsage += HelpMessageOpt(\"-spendzeroconfchange\", strprintf(_(\"Spend unconfirmed change when sending transactions (default: %u)\"), 1));\n+    strUsage += HelpMessageOpt(\"-txconfirmtarget=<n>\", strprintf(_(\"If paytxfee is not set, include enough fee so transactions begin confirmation on average within n blocks (default: %u)\"), DEFAULT_TX_CONFIRM_TARGET));\n+    strUsage += HelpMessageOpt(\"-maxtxfee=<amt>\", strprintf(_(\"Maximum total fees to use in a single wallet transaction; setting this too low may abort large transactions (default: %s)\"),\n+                                                            FormatMoney(maxTxFee)));\n+    strUsage += HelpMessageOpt(\"-upgradewallet\", _(\"Upgrade wallet to latest format\") + \" \" + _(\"on startup\"));\n+    strUsage += HelpMessageOpt(\"-wallet=<file>\", _(\"Specify wallet file (within data directory)\") + \" \" + strprintf(_(\"(default: %s)\"), \"wallet.dat\"));\n+    strUsage += HelpMessageOpt(\"-walletbroadcast\", _(\"Make the wallet broadcast transactions\") + \" \" + strprintf(_(\"(default: %u)\"), true));\n+    strUsage += HelpMessageOpt(\"-walletnotify=<cmd>\", _(\"Execute command when a wallet transaction changes (%s in cmd is replaced by TxID)\"));\n+    strUsage += HelpMessageOpt(\"-zapwallettxes=<mode>\", _(\"Delete all wallet transactions and only recover those parts of the blockchain through -rescan on startup\") +\n+                               \" \" + _(\"(1 = keep tx meta data e.g. account owner and payment request information, 2 = drop tx meta data)\"));\n+}\n+\n+void Flush(bool shutdown)\n+{\n+    if (pwalletMain)\n+        pwalletMain->Flush(shutdown);\n+}\n+\n+void Dealloc()\n+{\n+    delete pwalletMain;\n+    pwalletMain = NULL;\n+}\n+\n+//! Dump wallet infos to log\n+void LogGeneralInfos()\n+{\n+    LogPrintf(\"Using BerkeleyDB version %s\\n\", DbEnv::version(0, 0, 0));\n+}\n+\n+//! Dump wallet infos to log\n+void LogInfos()\n+{\n+    LogPrintf(\"setKeyPool.size() = %u\\n\",      pwalletMain ? pwalletMain->setKeyPool.size() : 0);\n+    LogPrintf(\"mapWallet.size() = %u\\n\",       pwalletMain ? pwalletMain->mapWallet.size() : 0);\n+    LogPrintf(\"mapAddressBook.size() = %u\\n\",  pwalletMain ? pwalletMain->mapAddressBook.size() : 0);\n+}\n+\n+//! Performs sanity check and appends possible errors to given string\n+void SanityCheck(std::string& errorString)\n+{\n+    std::string strWalletFile = GetWalletFile();\n+    // Wallet file must be a plain filename without a directory\n+    if (strWalletFile != boost::filesystem::basename(strWalletFile) + boost::filesystem::extension(strWalletFile))\n+        errorString += strprintf(_(\"Wallet %s resides outside data directory\"), strWalletFile);\n+}\n+\n+bool IsDisabled()\n+{\n+    return GetBoolArg(\"-disablewallet\", false);\n+}\n+\n+void LoadAsModule(std::string& warningString, std::string& errorString, bool& stopInit)\n+{\n+    if (IsDisabled()) {\n+        pwalletMain = NULL;\n+        LogPrintf(\"Wallet disabled!\\n\");\n+    } else {\n+        uiInterface.InitMessage(_(\"Loading wallet...\"));\n+        pwalletMain = new CWallet(GetWalletFile());\n+        \n+        if (!pwalletMain->LoadWallet(warningString, errorString))\n+            stopInit = true;\n+    }\n+}\n+\n+void Verify(std::string& warningString, std::string& errorString, bool &stopInit)\n+{\n+    if (IsDisabled())\n+        return;\n+    \n+    uiInterface.InitMessage(_(\"Verifying wallet...\"));\n+    \n+    const std::string walletFile = GetWalletFile();\n+    LogPrintf(\"Using wallet %s\\n\", walletFile);\n+    \n+    if (!pwalletMain->Verify(walletFile, warningString, errorString))\n+        stopInit = true;\n+}\n+\n+void MapParameters(std::string& warningString, std::string& errorString)\n+{\n+    if (GetBoolArg(\"-salvagewallet\", false)) {\n+        // Rewrite just private keys: rescan to find transactions\n+        if (SoftSetBoolArg(\"-rescan\", true))\n+            LogPrintf(\"%s: parameter interaction: -salvagewallet=1 -> setting -rescan=1\\n\", __func__);\n+    }\n+\n+    // -zapwallettx implies a rescan\n+    if (GetBoolArg(\"-zapwallettxes\", false)) {\n+        if (SoftSetBoolArg(\"-rescan\", true))\n+            LogPrintf(\"%s: parameter interaction: -zapwallettxes=<mode> -> setting -rescan=1\\n\", __func__);\n+    }\n+    \n+    if (mapArgs.count(\"-mintxfee\"))\n+    {\n+        CAmount n = 0;\n+        if (ParseMoney(mapArgs[\"-mintxfee\"], n) && n > 0)\n+        CWallet::minTxFee = CFeeRate(n);\n+        else\n+        {\n+            errorString += strprintf(_(\"Invalid amount for -mintxfee=<amount>: '%s'\"), mapArgs[\"-mintxfee\"]);\n+            return;\n+        }\n+        \n+    }\n+    if (mapArgs.count(\"-paytxfee\"))\n+    {\n+        CAmount nFeePerK = 0;\n+        if (!ParseMoney(mapArgs[\"-paytxfee\"], nFeePerK))\n+        errorString += strprintf(_(\"Invalid amount for -paytxfee=<amount>: '%s'\"), mapArgs[\"-paytxfee\"]); return;\n+        if (nFeePerK > nHighTransactionFeeWarning)\n+        warningString += _(\"Warning: -paytxfee is set very high! This is the transaction fee you will pay if you send a transaction.\"); return;\n+        payTxFee = CFeeRate(nFeePerK, 1000);\n+        if (payTxFee < ::minRelayTxFee)\n+        errorString += strprintf(_(\"Invalid amount for -paytxfee=<amount>: '%s' (must be at least %s)\"),\n+                                 mapArgs[\"-paytxfee\"], ::minRelayTxFee.ToString()); return;\n+    }\n+    if (mapArgs.count(\"-maxtxfee\"))\n+    {\n+        CAmount nMaxFee = 0;\n+        if (!ParseMoney(mapArgs[\"-maxtxfee\"], nMaxFee))\n+        errorString += strprintf(_(\"Invalid amount for -maxtxfee=<amount>: '%s'\"), mapArgs[\"-maptxfee\"]); return;\n+        if (nMaxFee > nHighTransactionMaxFeeWarning)\n+        warningString += _(\"Warning: -maxtxfee is set very high! Fees this large could be paid on a single transaction.\"); return;\n+        maxTxFee = nMaxFee;\n+        if (CFeeRate(maxTxFee, 1000) < ::minRelayTxFee)\n+        errorString += strprintf(_(\"Invalid amount for -maxtxfee=<amount>: '%s' (must be at least the minrelay fee of %s to prevent stuck transactions)\"), mapArgs[\"-maxtxfee\"], ::minRelayTxFee.ToString()); return;\n+    }\n+    nTxConfirmTarget = GetArg(\"-txconfirmtarget\", DEFAULT_TX_CONFIRM_TARGET);\n+    bSpendZeroConfChange = GetArg(\"-spendzeroconfchange\", true);\n+    fSendFreeTransactions = GetArg(\"-sendfreetransactions\", false);\n+}\n+\n+void StartWalletTasks(boost::thread_group& threadGroup)\n+{\n+    if (pwalletMain) {\n+        // Add wallet transactions that aren't already in a block to mapTransactions\n+        pwalletMain->ReacceptWalletTransactions();\n+        \n+        // Run a thread to flush wallet periodically\n+        threadGroup.create_thread(boost::bind(&ThreadFlushWalletDB, boost::ref(pwalletMain->strWalletFile)));\n+    }\n+}\n+    \n+void RegisterSignals()\n+{\n+    GetMainSignals().ShutdownRPCStopped.connect(boost::bind(&Flush, false));\n+    GetMainSignals().ShutdownNodeStopped.connect(boost::bind(&Flush, true));\n+    GetMainSignals().ShutdownFinished.connect(boost::bind(&Dealloc));\n+    GetMainSignals().CreateHelpString.connect(boost::bind(&AppendHelpMessageString, _1, _2));\n+    GetMainSignals().ParameterInteraction.connect(boost::bind(&MapParameters, _1, _2));\n+    GetMainSignals().AppInitialization.connect(boost::bind(&SanityCheck, _1));\n+    GetMainSignals().AppInitializationLogHead.connect(boost::bind(&LogGeneralInfos));\n+    GetMainSignals().VerifyIntegrity.connect(boost::bind(&Verify, _1, _2, _3));\n+    GetMainSignals().LoadModules.connect(boost::bind(&LoadAsModule, _1, _2, _3));\n+    GetMainSignals().NodeStarted.connect(boost::bind(&LogInfos));\n+    GetMainSignals().FinishInitializing.connect(boost::bind(&StartWalletTasks, _1));\n+}\n+\n+void UnregisterSignals()\n+{\n+    GetMainSignals().ShutdownRPCStopped.disconnect(boost::bind(&Flush, false));\n+    GetMainSignals().ShutdownNodeStopped.disconnect(boost::bind(&Flush, true));\n+    GetMainSignals().ShutdownFinished.disconnect(boost::bind(&Dealloc));\n+    GetMainSignals().CreateHelpString.disconnect(boost::bind(&AppendHelpMessageString, _1, _2));\n+    GetMainSignals().ParameterInteraction.disconnect(boost::bind(&MapParameters, _1, _2));\n+    GetMainSignals().AppInitialization.disconnect(boost::bind(&SanityCheck, _1));\n+    GetMainSignals().AppInitializationLogHead.disconnect(boost::bind(&LogGeneralInfos));\n+    GetMainSignals().VerifyIntegrity.disconnect(boost::bind(&Verify, _1, _2, _3));\n+    GetMainSignals().LoadModules.disconnect(boost::bind(&LoadAsModule, _1, _2, _3));\n+    GetMainSignals().NodeStarted.disconnect(boost::bind(&LogInfos));\n+    GetMainSignals().FinishInitializing.disconnect(boost::bind(&StartWalletTasks, _1));\n+}\n+};\n\\ No newline at end of file"
      },
      {
        "sha": "c6dcf1341d5d8c862593957013e6e7fac2b23def",
        "filename": "src/wallet/legacywallet.h",
        "status": "added",
        "additions": 20,
        "deletions": 0,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa6a5b28fcaa612c6512c6028184df6b346fdad4/src/wallet/legacywallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa6a5b28fcaa612c6512c6028184df6b346fdad4/src/wallet/legacywallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/legacywallet.h?ref=fa6a5b28fcaa612c6512c6028184df6b346fdad4",
        "patch": "@@ -0,0 +1,20 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2015 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_LEGACYWALLET_H\n+#define BITCOIN_LEGACYWALLET_H\n+\n+#include \"wallet/wallet.h\"\n+\n+extern CWallet* pwalletMain;\n+\n+namespace CLegacyWalletModule {\n+    void RegisterSignals();\n+    void UnregisterSignals();\n+    \n+    std::string GetWalletFile();\n+};\n+\n+#endif // BITCOIN_LEGACYWALLET_H"
      },
      {
        "sha": "99de101943112c647d65d09807a9a9b65aba177a",
        "filename": "src/wallet/rpcdump.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa6a5b28fcaa612c6512c6028184df6b346fdad4/src/wallet/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa6a5b28fcaa612c6512c6028184df6b346fdad4/src/wallet/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcdump.cpp?ref=fa6a5b28fcaa612c6512c6028184df6b346fdad4",
        "patch": "@@ -11,7 +11,7 @@\n #include \"sync.h\"\n #include \"util.h\"\n #include \"utiltime.h\"\n-#include \"wallet.h\"\n+#include \"wallet/legacywallet.h\"\n \n #include <fstream>\n #include <stdint.h>"
      },
      {
        "sha": "624e6a4f61a90604a77724cdf9ae3afb361761b4",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa6a5b28fcaa612c6512c6028184df6b346fdad4/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa6a5b28fcaa612c6512c6028184df6b346fdad4/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=fa6a5b28fcaa612c6512c6028184df6b346fdad4",
        "patch": "@@ -14,6 +14,7 @@\n #include \"timedata.h\"\n #include \"util.h\"\n #include \"utilmoneystr.h\"\n+#include \"legacywallet.h\"\n #include \"wallet.h\"\n #include \"walletdb.h\"\n "
      },
      {
        "sha": "cc772235c88c49a0e6eaa28ed87ca50b05393967",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 103,
        "changes": 110,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa6a5b28fcaa612c6512c6028184df6b346fdad4/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa6a5b28fcaa612c6512c6028184df6b346fdad4/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=fa6a5b28fcaa612c6512c6028184df6b346fdad4",
        "patch": "@@ -349,11 +349,8 @@ void CWallet::Flush(bool shutdown)\n     bitdb.Flush(shutdown);\n }\n \n-bool CWallet::Verify(string& warningString, string& errorString)\n+bool CWallet::Verify(const std::string& walletFile, std::string& warningString, std::string& errorString)\n {\n-    const std::string walletFile = CWallet::GetWalletFile();\n-    LogPrintf(\"Using wallet %s\\n\", walletFile);\n-\n     if (!bitdb.Open(GetDataDir()))\n     {\n         // try moving the database env out of the way\n@@ -371,15 +368,15 @@ bool CWallet::Verify(string& warningString, string& errorString)\n             // if it still fails, it probably means we can't even create the database env\n             string msg = strprintf(_(\"Error initializing wallet database environment %s!\"), GetDataDir());\n             errorString += msg;\n-            return true;\n+            return false;\n         }\n     }\n     \n     if (GetBoolArg(\"-salvagewallet\", false))\n     {\n         // Recover readable keypairs:\n         if (!CWalletDB::Recover(bitdb, walletFile, true))\n-            return false;\n+            return true;\n     }\n \n     if (boost::filesystem::exists(GetDataDir() / walletFile))\n@@ -903,99 +900,6 @@ CAmount CWallet::GetChange(const CTransaction& tx) const\n     return nChange;\n }\n \n-bool CWallet::IsDisabled()\n-{\n-    return GetBoolArg(\"-disablewallet\", false);\n-}\n-\n-void CWallet::MapParameters(string& warningString, string& errorString)\n-{\n-    if (mapArgs.count(\"-mintxfee\"))\n-    {\n-        CAmount n = 0;\n-        if (ParseMoney(mapArgs[\"-mintxfee\"], n) && n > 0)\n-            CWallet::minTxFee = CFeeRate(n);\n-        else\n-        {\n-            errorString += strprintf(_(\"Invalid amount for -mintxfee=<amount>: '%s'\"), mapArgs[\"-mintxfee\"]);\n-            return;\n-        }\n-    }\n-    if (mapArgs.count(\"-paytxfee\"))\n-    {\n-        CAmount nFeePerK = 0;\n-        if (!ParseMoney(mapArgs[\"-paytxfee\"], nFeePerK))\n-            errorString += strprintf(_(\"Invalid amount for -paytxfee=<amount>: '%s'\"), mapArgs[\"-paytxfee\"]); return;\n-        if (nFeePerK > nHighTransactionFeeWarning)\n-            warningString += _(\"Warning: -paytxfee is set very high! This is the transaction fee you will pay if you send a transaction.\"); return;\n-        payTxFee = CFeeRate(nFeePerK, 1000);\n-        if (payTxFee < ::minRelayTxFee)\n-            errorString += strprintf(_(\"Invalid amount for -paytxfee=<amount>: '%s' (must be at least %s)\"),\n-                                     mapArgs[\"-paytxfee\"], ::minRelayTxFee.ToString()); return;\n-    }\n-    if (mapArgs.count(\"-maxtxfee\"))\n-    {\n-        CAmount nMaxFee = 0;\n-        if (!ParseMoney(mapArgs[\"-maxtxfee\"], nMaxFee))\n-            errorString += strprintf(_(\"Invalid amount for -maxtxfee=<amount>: '%s'\"), mapArgs[\"-maptxfee\"]); return;\n-        if (nMaxFee > nHighTransactionMaxFeeWarning)\n-            warningString += _(\"Warning: -maxtxfee is set very high! Fees this large could be paid on a single transaction.\"); return;\n-        maxTxFee = nMaxFee;\n-        if (CFeeRate(maxTxFee, 1000) < ::minRelayTxFee)\n-             errorString += strprintf(_(\"Invalid amount for -maxtxfee=<amount>: '%s' (must be at least the minrelay fee of %s to prevent stuck transactions)\"), mapArgs[\"-maxtxfee\"], ::minRelayTxFee.ToString()); return;\n-    }\n-    nTxConfirmTarget = GetArg(\"-txconfirmtarget\", DEFAULT_TX_CONFIRM_TARGET);\n-    bSpendZeroConfChange = GetArg(\"-spendzeroconfchange\", true);\n-    fSendFreeTransactions = GetArg(\"-sendfreetransactions\", false);\n-}\n-\n-std::string CWallet::GetWalletFile()\n-{\n-    return GetArg(\"-wallet\", \"wallet.dat\");\n-}\n-\n-void CWallet::SanityCheck(string& errorString)\n-{\n-    std::string strWalletFile = GetWalletFile();\n-    // Wallet file must be a plain filename without a directory\n-    if (strWalletFile != boost::filesystem::basename(strWalletFile) + boost::filesystem::extension(strWalletFile))\n-        errorString += strprintf(_(\"Wallet %s resides outside data directory\"), strWalletFile);\n-}\n-\n-void CWallet::LogGeneralInfos()\n-{\n-    LogPrintf(\"Using BerkeleyDB version %s\\n\", DbEnv::version(0, 0, 0));\n-}\n-void CWallet::LogInfos() const\n-{\n-    LogPrintf(\"setKeyPool.size() = %u\\n\",      this->setKeyPool.size());\n-    LogPrintf(\"mapWallet.size() = %u\\n\",       this->mapWallet.size());\n-    LogPrintf(\"mapAddressBook.size() = %u\\n\",  this->mapAddressBook.size());\n-}\n-\n-void CWallet::AppendHelpMessageString(std::string& strUsage)\n-{\n-strUsage += HelpMessageGroup(_(\"Wallet options:\"));\n-strUsage += HelpMessageOpt(\"-disablewallet\", _(\"Do not load the wallet and disable wallet RPC calls\"));\n-strUsage += HelpMessageOpt(\"-keypool=<n>\", strprintf(_(\"Set key pool size to <n> (default: %u)\"), 100));\n-if (showDebug)\n-    strUsage += HelpMessageOpt(\"-mintxfee=<amt>\", strprintf(\"Fees (in BTC/Kb) smaller than this are considered zero fee for transaction creation (default: %s)\",\n-                                                            FormatMoney(CWallet::minTxFee.GetFeePerK())));\n-strUsage += HelpMessageOpt(\"-paytxfee=<amt>\", strprintf(_(\"Fee (in BTC/kB) to add to transactions you send (default: %s)\"), FormatMoney(payTxFee.GetFeePerK())));\n-strUsage += HelpMessageOpt(\"-rescan\", _(\"Rescan the block chain for missing wallet transactions\") + \" \" + _(\"on startup\"));\n-strUsage += HelpMessageOpt(\"-salvagewallet\", _(\"Attempt to recover private keys from a corrupt wallet.dat\") + \" \" + _(\"on startup\"));\n-strUsage += HelpMessageOpt(\"-sendfreetransactions\", strprintf(_(\"Send transactions as zero-fee transactions if possible (default: %u)\"), 0));\n-strUsage += HelpMessageOpt(\"-spendzeroconfchange\", strprintf(_(\"Spend unconfirmed change when sending transactions (default: %u)\"), 1));\n-strUsage += HelpMessageOpt(\"-txconfirmtarget=<n>\", strprintf(_(\"If paytxfee is not set, include enough fee so transactions begin confirmation on average within n blocks (default: %u)\"), DEFAULT_TX_CONFIRM_TARGET));\n-strUsage += HelpMessageOpt(\"-maxtxfee=<amt>\", strprintf(_(\"Maximum total fees to use in a single wallet transaction; setting this too low may abort large transactions (default: %s)\"),\n-                                                        FormatMoney(maxTxFee)));\n-strUsage += HelpMessageOpt(\"-upgradewallet\", _(\"Upgrade wallet to latest format\") + \" \" + _(\"on startup\"));\n-strUsage += HelpMessageOpt(\"-wallet=<file>\", _(\"Specify wallet file (within data directory)\") + \" \" + strprintf(_(\"(default: %s)\"), \"wallet.dat\"));\n-strUsage += HelpMessageOpt(\"-walletbroadcast\", _(\"Make the wallet broadcast transactions\") + \" \" + strprintf(_(\"(default: %u)\"), true));\n-strUsage += HelpMessageOpt(\"-walletnotify=<cmd>\", _(\"Execute command when a wallet transaction changes (%s in cmd is replaced by TxID)\"));\n-strUsage += HelpMessageOpt(\"-zapwallettxes=<mode>\", _(\"Delete all wallet transactions and only recover those parts of the blockchain through -rescan on startup\") +\n-                           \" \" + _(\"(1 = keep tx meta data e.g. account owner and payment request information, 2 = drop tx meta data)\"));\n-}\n int64_t CWalletTx::GetTxTime() const\n {\n     int64_t n = nTimeSmart;\n@@ -2231,9 +2135,6 @@ CAmount CWallet::GetMinimumFee(unsigned int nTxBytes, unsigned int nConfirmTarge\n     return nFeeNeeded;\n }\n \n-\n-\n-\n bool CWallet::LoadWallet(std::string& warningString, std::string& errorString)\n {\n     // needed to restore wallet transaction meta data after -zapwallettxes\n@@ -2355,7 +2256,10 @@ bool CWallet::LoadWallet(std::string& warningString, std::string& errorString)\n                 block = block->pprev;\n \n             if (pindexRescan != block)\n-                return InitError(_(\"Prune: last wallet synchronisation goes beyond pruned data. You need to -reindex (download the whole blockchain again in case of pruned node)\"));\n+            {\n+                errorString += _(\"Prune: last wallet synchronisation goes beyond pruned data. You need to -reindex (download the whole blockchain again in case of pruned node)\") + \"\\n\";\n+                return true;\n+            }\n         }\n         \n         uiInterface.InitMessage(_(\"Rescanning...\"));"
      },
      {
        "sha": "8de7b85a65f9a11035f9ba72409247b57d5a7664",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 6,
        "deletions": 12,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa6a5b28fcaa612c6512c6028184df6b346fdad4/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa6a5b28fcaa612c6512c6028184df6b346fdad4/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=fa6a5b28fcaa612c6512c6028184df6b346fdad4",
        "patch": "@@ -499,9 +499,6 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n     CWallet()\n     {\n         SetNull();\n-\n-        strWalletFile = GetWalletFile();\n-        fFileBacked = true;\n     }\n \n     CWallet(const std::string& strWalletFileIn)\n@@ -719,16 +716,13 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n     void Flush(bool shutdown=false);\n \n     //! Dump wallet infos to log\n-    void LogInfos() const;\n+    static void LogInfos();\n     static void LogGeneralInfos();\n \n     //! Verify the wallet database and perform salvage if required\n-    static bool Verify(std::string& warningString, std::string& errorString);\n-\n-    static bool IsDisabled();\n-\n-    //! Map parameters to internal vars\n-    static void MapParameters(std::string& warningString, std::string& errorString);\n+    static bool Verify(const std::string& walletFile, std::string& warningString, std::string& errorString);\n+    \n+    static void StartWalletTasks(boost::thread_group& threadGroup);\n \n     //! Get user defined wallet file\n     static std::string GetWalletFile();\n@@ -737,8 +731,8 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n     static void SanityCheck(std::string& errorString);\n \n     //! append help text to existing string\n-    static void AppendHelpMessageString(std::string& strUsage);\n-\n+    static void AppendHelpMessageString(std::string& strUsage, bool debugHelp);\n+    \n     /** \n      * Address book entry changed.\n      * @note called with lock cs_wallet held."
      }
    ]
  },
  {
    "sha": "4c956eebd69967a63bd6857f64cc052cef64d106",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0Yzk1NmVlYmQ2OTk2N2E2M2JkNjg1N2Y2NGNjMDUyY2VmNjRkMTA2",
    "commit": {
      "author": {
        "name": "Jonas Schnelli",
        "email": "jonas.schnelli@include7.ch",
        "date": "2015-04-12T12:44:27Z"
      },
      "committer": {
        "name": "Jonas Schnelli",
        "email": "jonas.schnelli@include7.ch",
        "date": "2015-07-08T14:57:52Z"
      },
      "message": "[RPC] add possibility to extend the JSONRPC URI schemas",
      "tree": {
        "sha": "a7cfda9a71d080bd809ad787c4903a01cf56f12e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a7cfda9a71d080bd809ad787c4903a01cf56f12e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4c956eebd69967a63bd6857f64cc052cef64d106",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4c956eebd69967a63bd6857f64cc052cef64d106",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4c956eebd69967a63bd6857f64cc052cef64d106",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4c956eebd69967a63bd6857f64cc052cef64d106/comments",
    "author": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fa6a5b28fcaa612c6512c6028184df6b346fdad4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa6a5b28fcaa612c6512c6028184df6b346fdad4",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fa6a5b28fcaa612c6512c6028184df6b346fdad4"
      }
    ],
    "stats": {
      "total": 76,
      "additions": 63,
      "deletions": 13
    },
    "files": [
      {
        "sha": "8cf6455c6dfe2330d44ce62ece694e5f8ec690fb",
        "filename": "src/rpcserver.cpp",
        "status": "modified",
        "additions": 57,
        "deletions": 13,
        "changes": 70,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4c956eebd69967a63bd6857f64cc052cef64d106/src/rpcserver.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4c956eebd69967a63bd6857f64cc052cef64d106/src/rpcserver.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcserver.cpp?ref=4c956eebd69967a63bd6857f64cc052cef64d106",
        "patch": "@@ -41,6 +41,8 @@ static bool fRPCRunning = false;\n static bool fRPCInWarmup = true;\n static std::string rpcWarmupStatus(\"RPC server started\");\n static CCriticalSection cs_rpcWarmup;\n+static CCriticalSection cs_vExtURI;\n+static std::vector<std::string> vExtURI;\n \n //! These are created by StartRPCThreads, destroyed in StopRPCThreads\n static boost::asio::io_service* rpc_io_service = NULL;\n@@ -53,12 +55,18 @@ static std::vector< boost::shared_ptr<ip::tcp::acceptor> > rpc_acceptors;\n \n static struct CRPCSignals\n {\n+    boost::signals2::signal<void (const std::string& strMethod, const UniValue& params, UniValue& result, bool& accept)> ExtCmdExecute; //!< Allow listeners to append result to a extended uri schema call\n     boost::signals2::signal<void ()> Started;\n     boost::signals2::signal<void ()> Stopped;\n     boost::signals2::signal<void (const CRPCCommand&)> PreCommand;\n     boost::signals2::signal<void (const CRPCCommand&)> PostCommand;\n } g_rpcSignals;\n \n+void RPCServer::OnExtendedCommandExecute(boost::function<void (const std::string& strMethod, const UniValue& params, UniValue& result, bool& accept)> slot)\n+{\n+    g_rpcSignals.ExtCmdExecute.connect(slot);\n+}\n+\n void RPCServer::OnStarted(boost::function<void ()> slot)\n {\n     g_rpcSignals.Started.connect(slot);\n@@ -824,6 +832,12 @@ void RPCRunLater(const std::string& name, boost::function<void(void)> func, int6\n     deadlineTimers[name]->async_wait(boost::bind(RPCRunHandler, _1, func));\n }\n \n+void AddJSONRPCURISchema(const std::string& uri)\n+{\n+    LOCK(cs_vExtURI);\n+    vExtURI.push_back(uri);\n+}\n+\n class JSONRequest\n {\n public:\n@@ -899,7 +913,8 @@ static string JSONRPCExecBatch(const UniValue& vReq)\n     return ret.write() + \"\\n\";\n }\n \n-static bool HTTPReq_JSONRPC(AcceptedConnection *conn,\n+static bool HTTPReq_JSONRPC(const std::string &sURI,\n+                            AcceptedConnection *conn,\n                             string& strRequest,\n                             map<string, string>& mapHeaders,\n                             bool fRun)\n@@ -932,21 +947,45 @@ static bool HTTPReq_JSONRPC(AcceptedConnection *conn,\n             throw JSONRPCError(RPC_PARSE_ERROR, \"Parse error\");\n \n         string strReply;\n+        size_t nVExtURISize = 0;\n+        {\n+            LOCK(cs_vExtURI);\n+            nVExtURISize = vExtURI.size();\n+        }\n \n-        // singleton request\n-        if (valRequest.isObject()) {\n-            jreq.parse(valRequest);\n+        if(sURI == \"/\" || nVExtURISize == 0)\n+        {\n+            // singleton request\n+            if (valRequest.isObject())\n+            {\n+                jreq.parse(valRequest);\n \n-            UniValue result = tableRPC.execute(jreq.strMethod, jreq.params);\n+                UniValue result = tableRPC.execute(jreq.strMethod, jreq.params);\n \n-            // Send reply\n-            strReply = JSONRPCReply(result, NullUniValue, jreq.id);\n+                // Send reply\n+                strReply = JSONRPCReply(result, NullUniValue, jreq.id);\n \n-        // array of requests\n-        } else if (valRequest.isArray())\n-            strReply = JSONRPCExecBatch(valRequest.get_array());\n+            // array of requests\n+            } else if (valRequest.isArray())\n+                strReply = JSONRPCExecBatch(valRequest.get_array());\n+            else\n+                throw JSONRPCError(RPC_PARSE_ERROR, \"Top-level object parse error\");\n+        }\n         else\n-            throw JSONRPCError(RPC_PARSE_ERROR, \"Top-level object parse error\");\n+        {\n+            UniValue result;\n+            jreq.parse(valRequest);\n+            \n+            // allow connected listeners to add response to the call\n+            // batch execution can be implemented within the listening code part\n+            bool accept = false;\n+            g_rpcSignals.ExtCmdExecute(jreq.strMethod, jreq.params, result, accept);\n+            if (!accept)\n+                throw JSONRPCError(RPC_METHOD_NOT_FOUND, \"Method not found\");\n+            \n+            // build JSON reply\n+            strReply = JSONRPCReply(result, NullUniValue, jreq.id);\n+        }\n \n         conn->stream() << HTTPReplyHeader(HTTP_OK, fRun, strReply.size()) << strReply << std::flush;\n     }\n@@ -984,8 +1023,13 @@ void ServiceConnection(AcceptedConnection *conn)\n             fRun = false;\n \n         // Process via JSON-RPC API\n-        if (strURI == \"/\") {\n-            if (!HTTPReq_JSONRPC(conn, strRequest, mapHeaders, fRun))\n+        bool extURIFound = false;\n+        {\n+            LOCK(cs_vExtURI);\n+            extURIFound = std::find(vExtURI.begin(), vExtURI.end(), strURI) != vExtURI.end();\n+        }\n+        if (strURI == \"/\" || extURIFound) {\n+            if (!HTTPReq_JSONRPC(strURI, conn, strRequest, mapHeaders, fRun))\n                 break;\n \n         // Process via HTTP REST API"
      },
      {
        "sha": "8c3720697a764b8ac6674d26e0ca5de260a42f44",
        "filename": "src/rpcserver.h",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4c956eebd69967a63bd6857f64cc052cef64d106/src/rpcserver.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4c956eebd69967a63bd6857f64cc052cef64d106/src/rpcserver.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcserver.h?ref=4c956eebd69967a63bd6857f64cc052cef64d106",
        "patch": "@@ -27,6 +27,7 @@ namespace RPCServer\n     void OnStopped(boost::function<void ()> slot);\n     void OnPreCommand(boost::function<void (const CRPCCommand&)> slot);\n     void OnPostCommand(boost::function<void (const CRPCCommand&)> slot);\n+    void OnExtendedCommandExecute(boost::function<void (const std::string& strMethod, const UniValue& params, UniValue& result, bool& accept)> slot);\n }\n \n class CBlockIndex;\n@@ -87,6 +88,11 @@ void RPCTypeCheckObj(const UniValue& o,\n  */\n void RPCRunLater(const std::string& name, boost::function<void(void)> func, int64_t nSeconds);\n \n+/**\n+ * Adds a JSONRPC entry point for using it over the OnExtendedCommandExecute signaling\n+ */\n+void AddJSONRPCURISchema(const std::string& uri);\n+\n //! Convert boost::asio address to CNetAddr\n extern CNetAddr BoostAsioToCNetAddr(boost::asio::ip::address address);\n "
      }
    ]
  },
  {
    "sha": "8bab0c341c043b48b88de435422ea8739dc45908",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4YmFiMGMzNDFjMDQzYjQ4Yjg4ZGU0MzU0MjJlYTg3MzlkYzQ1OTA4",
    "commit": {
      "author": {
        "name": "Jonas Schnelli",
        "email": "jonas.schnelli@include7.ch",
        "date": "2015-06-01T14:59:37Z"
      },
      "committer": {
        "name": "Jonas Schnelli",
        "email": "jonas.schnelli@include7.ch",
        "date": "2015-07-08T14:57:52Z"
      },
      "message": "add bip32 pub key serialization\n\nCExtPubKey should be serializable like CPubKey.",
      "tree": {
        "sha": "3e46578cd6ce2c7d63f68565dd1490be349763ce",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3e46578cd6ce2c7d63f68565dd1490be349763ce"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8bab0c341c043b48b88de435422ea8739dc45908",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8bab0c341c043b48b88de435422ea8739dc45908",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8bab0c341c043b48b88de435422ea8739dc45908",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8bab0c341c043b48b88de435422ea8739dc45908/comments",
    "author": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4c956eebd69967a63bd6857f64cc052cef64d106",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4c956eebd69967a63bd6857f64cc052cef64d106",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4c956eebd69967a63bd6857f64cc052cef64d106"
      }
    ],
    "stats": {
      "total": 26,
      "additions": 26,
      "deletions": 0
    },
    "files": [
      {
        "sha": "1e38b7cb2cb32567c9bc63e8bcfbdd64b8e7969a",
        "filename": "src/pubkey.h",
        "status": "modified",
        "additions": 22,
        "deletions": 0,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8bab0c341c043b48b88de435422ea8739dc45908/src/pubkey.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8bab0c341c043b48b88de435422ea8739dc45908/src/pubkey.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/pubkey.h?ref=8bab0c341c043b48b88de435422ea8739dc45908",
        "patch": "@@ -203,6 +203,28 @@ struct CExtPubKey {\n     void Encode(unsigned char code[74]) const;\n     void Decode(const unsigned char code[74]);\n     bool Derive(CExtPubKey& out, unsigned int nChild) const;\n+\n+    unsigned int GetSerializeSize(int nType, int nVersion) const\n+    {\n+        return 75;\n+    }\n+    template <typename Stream>\n+    void Serialize(Stream& s, int nType, int nVersion) const\n+    {\n+        unsigned int len = 74;\n+        ::WriteCompactSize(s, len);\n+        unsigned char code[74];\n+        Encode(code);\n+        s.write((const char *)&code[0], len);\n+    }\n+    template <typename Stream>\n+    void Unserialize(Stream& s, int nType, int nVersion)\n+    {\n+        unsigned int len = ::ReadCompactSize(s);\n+        unsigned char code[74];\n+        s.read((char *)&code[0], len);\n+        Decode(code);\n+    }\n };\n \n #endif // BITCOIN_PUBKEY_H"
      },
      {
        "sha": "a43371dc0ea74d20cc29e8547564ddd1a4003a90",
        "filename": "src/test/bip32_tests.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8bab0c341c043b48b88de435422ea8739dc45908/src/test/bip32_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8bab0c341c043b48b88de435422ea8739dc45908/src/test/bip32_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/bip32_tests.cpp?ref=8bab0c341c043b48b88de435422ea8739dc45908",
        "patch": "@@ -106,6 +106,10 @@ void RunTest(const TestVector &test) {\n         }\n         key = keyNew;\n         pubkey = pubkeyNew;\n+\n+        CDataStream ss(SER_DISK, CLIENT_VERSION);\n+        ss << pubkeyNew;\n+        BOOST_CHECK(ss.size() == 75);\n     }\n }\n "
      }
    ]
  },
  {
    "sha": "251ff6d0a575602df95a08ada0a3636859798aeb",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyNTFmZjZkMGE1NzU2MDJkZjk1YTA4YWRhMGEzNjM2ODU5Nzk4YWVi",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-05-27T17:07:34Z"
      },
      "committer": {
        "name": "Jonas Schnelli",
        "email": "jonas.schnelli@include7.ch",
        "date": "2015-07-08T14:57:52Z"
      },
      "message": "logdb: an safe append-only key-value store\n\nConflicts:\n\tsrc/makefile.unix",
      "tree": {
        "sha": "ac6bd9041829b2e50d5d872f4b0daa56421a0742",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ac6bd9041829b2e50d5d872f4b0daa56421a0742"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/251ff6d0a575602df95a08ada0a3636859798aeb",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/251ff6d0a575602df95a08ada0a3636859798aeb",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/251ff6d0a575602df95a08ada0a3636859798aeb",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/251ff6d0a575602df95a08ada0a3636859798aeb/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8bab0c341c043b48b88de435422ea8739dc45908",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8bab0c341c043b48b88de435422ea8739dc45908",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8bab0c341c043b48b88de435422ea8739dc45908"
      }
    ],
    "stats": {
      "total": 665,
      "additions": 665,
      "deletions": 0
    },
    "files": [
      {
        "sha": "8f65036befdddc7558251958e3d56a27e2994d6b",
        "filename": "src/logdb.cpp",
        "status": "added",
        "additions": 488,
        "deletions": 0,
        "changes": 488,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/251ff6d0a575602df95a08ada0a3636859798aeb/src/logdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/251ff6d0a575602df95a08ada0a3636859798aeb/src/logdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/logdb.cpp?ref=251ff6d0a575602df95a08ada0a3636859798aeb",
        "patch": "@@ -0,0 +1,488 @@\n+// Copyright (c) 2012 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file license.txt or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <stdio.h>\n+#include <unistd.h>\n+\n+#include \"logdb.h\"\n+\n+using namespace std;\n+\n+// Compact integers: least-significant digit first base-128 encoding.\n+// The high bit in each byte signifies whether another digit follows.\n+// To avoid redundancy, one is subtracted from all but the first digit.\n+// Thus, the byte sequence a[] where all but the last has bit 128 set,\n+// encodes the number (a[0] & 0x7F) + sum(i=1..n, 128^i*((a[i] & 0x7F)+1))\n+\n+size_t static WriteInt(FILE* file, uint64 n)\n+{\n+    int nRet = 0;\n+    do\n+    {\n+        nRet++;\n+        putc((n % 128) | (n>127)*128, file);\n+        if (n<128)\n+            break;\n+        n = (n / 128)-1;\n+    } while(1);\n+    return nRet;\n+}\n+\n+int static ReadInt(FILE *file)\n+{\n+    uint64_t nRet = 0;\n+    uint64_t nBase = 1;\n+    while (nBase)\n+    {\n+        int nByte = getc(file);\n+        nRet += nBase * ((nByte & 127) + (nBase>1));\n+        if (nByte < 128)\n+            break;\n+        nBase *= 128;\n+    }\n+    return nRet;\n+}\n+\n+// File format\n+// \n+// The file consists of a list of frames, each of which consists of:\n+// 4 bytes magic: 0xCC 0xC4 0xE6 0xB0\n+// N records, each of which consists of:\n+//   1 byte mode: 1=insert/overwrite, 2=erase\n+//   integer: key length (max 4 KiB)\n+//   key\n+//   if mode==1: integer: data length (max 1 MiB)\n+//   if mode==1: data\n+// 0 byte\n+// 8 bytes checksum: first 8 bytes of running SHA256\n+\n+class CModEntry\n+{\n+public:\n+    unsigned char nMode;\n+    data_t key;\n+    data_t value;\n+};\n+\n+void CLogDBFile::Init_()\n+{\n+    file = NULL;\n+    SHA256_Init(&ctxState);\n+    mapData.clear();\n+    nUsed = 0;\n+    nWritten = 0;\n+    setDirty.clear();\n+}\n+\n+bool CLogDBFile::Write_(const data_t &key, const data_t &value, bool fOverwrite, bool fLoad)\n+{\n+    if (!fLoad)\n+        return false;\n+\n+    // update nUsed\n+    std::map<data_t, data_t>::iterator it = mapData.find(key);\n+    if (it != mapData.end())\n+    {\n+        if ((*it).second == value)\n+            return true;\n+\n+        if (!fOverwrite)\n+            return false;\n+        nUsed -= (*it).first.size() + (*it).second.size();\n+    }\n+    nUsed += key.size() + value.size();\n+\n+    // update data\n+    mapData.insert(make_pair(key, value));\n+    if (!fLoad)\n+        setDirty.insert(key);\n+\n+    return true;\n+}\n+\n+bool CLogDBFile::Read_(const data_t &key, data_t &value) const\n+{\n+    std::map<data_t, data_t>::const_iterator it = mapData.find(key);\n+    if (it == mapData.end())\n+        return false;\n+\n+    value = (*it).second;\n+\n+    return true;\n+}\n+\n+bool CLogDBFile::Exists_(const data_t &key) const\n+{\n+    return mapData.count(key) > 0;\n+}\n+\n+bool CLogDBFile::Erase_(const data_t &key, bool fLoad)\n+{\n+    if (!fLoad)\n+        return false;\n+\n+    std::map<data_t, data_t>::iterator it = mapData.find(key);\n+    if (it != mapData.end())\n+    {\n+        nUsed -= (*it).first.size() + (*it).second.size();\n+        mapData.erase(it);\n+        if (!fLoad)\n+            setDirty.insert(key);\n+    }\n+\n+    return true;\n+}\n+\n+bool CLogDBFile::Close_()\n+{\n+    if (file)\n+    {\n+        Flush_();\n+        fclose(file);\n+        Init_();\n+    }\n+    return true;\n+}\n+\n+bool CLogDBFile::Load_()\n+{\n+    do\n+    {\n+        if (feof(file))\n+            return true;\n+        if (getc(file) != 0xCC) return feof(file);\n+        if (getc(file) != 0xC4) return false;\n+        if (getc(file) != 0xE6) return false;\n+        if (getc(file) != 0xB0) return false;\n+\n+        printf(\"CLogDB::Load(): frame header found\\n\");\n+\n+        vector<CModEntry> vMod;\n+\n+        // update a copy of the state, so we can revert in case of error\n+        SHA256_CTX ctx = ctxState;\n+\n+        do\n+        {\n+            if (feof(file))\n+            {\n+                printf(\"CLogDB::Load(): unexpected eof at record start\\n\");\n+                return false;\n+            }\n+\n+            CModEntry entry;\n+            entry.nMode = getc(file);\n+            if (entry.nMode > 2)\n+            {\n+                printf(\"CLogDB::Load(): unknown record mode\\n\");\n+                return false;\n+            }\n+\n+            SHA256_Update(&ctx, &entry.nMode, 1);\n+\n+            if (entry.nMode == 0)\n+                break;\n+\n+            printf(\"CLogDB::Load(): loading record mode %i\\n\", entry.nMode);\n+\n+            uint32_t nKeySize = ReadInt(file);\n+            if (nKeySize >= 0x1000)\n+            {\n+                printf(\"CLogDB::Load(): oversizes key (%lu bytes)\\n\", (unsigned long)nKeySize);\n+                return false;\n+            }\n+            entry.key.resize(nKeySize);\n+            if (fread(&entry.key[0], nKeySize, 1, file) != 1)\n+            {\n+                printf(\"CLogDB::Load(): unable to read key (%lu bytes)\\n\", (unsigned long)nKeySize);\n+                return false;\n+            }\n+\n+            printf(\"CLogDB::load(): loading key (%.*s)\\n\", nKeySize, &entry.key[0]);\n+\n+            SHA256_Update(&ctx, &nKeySize, 4);\n+            SHA256_Update(&ctx, &entry.key[0], nKeySize);\n+\n+            if (entry.nMode == 1)\n+            {\n+                int nValueSize = ReadInt(file);\n+                if (nValueSize >= 0x100000)\n+                {\n+                    printf(\"CLogDB::Load(): oversized value (%lu bytes)\\n\", (unsigned long)nValueSize);\n+                    return false;\n+                }\n+                entry.value.resize(nValueSize);\n+                if (fread(&entry.value[0], nValueSize, 1, file) != 1)\n+                {\n+                    printf(\"CLogDB::Load(): unable to read value (%lu bytes)\\n\", (unsigned long)nValueSize);\n+                    return false;\n+                }\n+\n+                SHA256_Update(&ctx, &nValueSize, 4);\n+                SHA256_Update(&ctx, &entry.value[0], nValueSize);\n+            }\n+\n+            vMod.push_back(entry);\n+        } while(true);\n+\n+        unsigned char check[8];\n+        if (fread(check, 8, 1, file)!=1)\n+        {\n+            printf(\"CLogDB::Load(): unable to read checksum\\n\");\n+            return false;\n+        }\n+\n+        SHA256_CTX ctxFinal = ctx;\n+\n+        unsigned char checkx[32];\n+        SHA256_Final(checkx, &ctxFinal);\n+        if (memcmp(check,checkx,8))\n+        {\n+            printf(\"CLogDB::Load(): checksum failed\\n\");\n+            return false;\n+        }\n+\n+        // if we reach this point, the entire read frame was valid\n+        ctxState = ctx;\n+\n+        for (vector<CModEntry>::iterator it = vMod.begin(); it != vMod.end(); it++)\n+        {\n+            CModEntry &mod = *it;\n+            nWritten += mod.key.size() + mod.value.size();\n+            switch (mod.nMode)\n+            {\n+                case 1:\n+                    Write_(mod.key, mod.value, true, true);\n+                    break;\n+\n+                case 2:\n+                    Erase_(mod.key, true);\n+                    break;\n+            }\n+        }\n+\n+    } while(true);\n+\n+    printf(\"CLogDB::Load(): done\\n\");\n+}\n+\n+bool CLogDBFile::Flush_()\n+{\n+    printf(\"CLogDB::Flush_()\\n\");\n+\n+    if (setDirty.empty())\n+        return true;\n+\n+    printf(\"CLogDB::Flush_(): not dirty\\n\");\n+\n+    unsigned char magic[4]={0xCC,0xC4,0xE6,0xB0};\n+\n+    if (fwrite(magic, 4, 1, file) != 1)\n+    {\n+        printf(\"CLogDB::Flush_(): error writing magic: %s\\n\", strerror(errno));\n+    }\n+\n+    SHA256_CTX ctx = ctxState;\n+\n+    for (set<data_t>::iterator it = setDirty.begin(); it != setDirty.end(); it++)\n+    {\n+        map<data_t, data_t>::iterator it2 = mapData.find(*it);\n+\n+        if (it2 != mapData.end())\n+        {\n+            // update\n+            unsigned char nMode = 1;\n+            uint32_t nKeySize = (*it).size();\n+            uint32_t nDataSize = (*it2).second.size();\n+            nWritten += nKeySize + nDataSize;\n+\n+            printf(\"CLogDB::Flush(): writing update(%.*s)\\n\", nKeySize, &(*it)[0]);\n+\n+            putc(nMode, file);\n+            WriteInt(file, nKeySize);\n+            fwrite(&(*it)[0], nKeySize, 1, file);\n+            WriteInt(file, nDataSize);\n+            fwrite(&(*it2).second[0], nDataSize, 1, file);\n+\n+            SHA256_Update(&ctx, &nMode, 1);\n+            SHA256_Update(&ctx, &nKeySize, 4);\n+            SHA256_Update(&ctx, &(*it)[0], nKeySize);\n+            SHA256_Update(&ctx, &nDataSize, 4);\n+            SHA256_Update(&ctx, &(*it2).second[0], nDataSize);\n+        }\n+        else\n+        {\n+            // erase\n+            unsigned char nMode = 2;\n+            uint32_t nKeySize = (*it).size();\n+            nWritten += nKeySize;\n+\n+            printf(\"CLogDB::Flush(): writing erase(%.*s)\\n\", nKeySize, &(*it)[0]);\n+\n+            putc(nMode, file);\n+            WriteInt(file, nKeySize);\n+            fwrite(&(*it)[0], nKeySize, 1, file);\n+\n+            SHA256_Update(&ctx, &nMode, 1);\n+            SHA256_Update(&ctx, &nKeySize, 4);\n+            SHA256_Update(&ctx, &(*it)[0], nKeySize);\n+        }\n+    }\n+\n+    unsigned char nMode = 0;\n+    putc(nMode, file);\n+    SHA256_Update(&ctx, &nMode, 1);\n+\n+    SHA256_CTX ctxFinal = ctx;\n+    unsigned char buf[32];\n+    SHA256_Final(buf, &ctxFinal);\n+    fwrite(buf, 8, 1, file);\n+    fflush(file);\n+    fdatasync(fileno(file));\n+    ctxState = ctx;\n+\n+    printf(\"CLogDB::Flush(): wrote frame\\n\");\n+\n+    setDirty.clear();\n+\n+    return true;\n+}\n+\n+bool CLogDB::TxnAbort() {\n+    LOCK(cs);\n+\n+    if (!fTransaction)\n+        return false;\n+\n+    mapData.clear();\n+    setDirty.clear();\n+\n+    fTransaction = false;\n+    if (fReadOnly)\n+        db->mutex.unlock_shared();\n+    else\n+        db->mutex.unlock();\n+\n+    return true;\n+}\n+\n+bool CLogDB::TxnBegin() {\n+    LOCK(cs);\n+\n+    if (fTransaction)\n+        return false;\n+\n+    if (fReadOnly)\n+        db->mutex.lock_shared();\n+    else\n+        db->mutex.lock();\n+\n+    fTransaction = true;\n+    return true;\n+}\n+\n+bool CLogDB::TxnCommit() {\n+    LOCK(cs);\n+\n+    if (!fTransaction)\n+        return false;\n+\n+    // commit modifications to backing CLogDBFile\n+    for (std::set<data_t>::const_iterator it = setDirty.begin(); it != setDirty.end(); it++) {\n+         std::map<data_t, data_t>::const_iterator it2 = mapData.find(*it);\n+         if (it2 != mapData.end()) {\n+             db->Erase_(*it);\n+         } else {\n+             db->Write_(*it, (*it2).second);\n+         }\n+    }\n+    mapData.clear();\n+    setDirty.clear();\n+    if (!fReadOnly)\n+        db->Flush_();\n+\n+    fTransaction = false;\n+    if (fReadOnly)\n+        db->mutex.unlock_shared();\n+    else\n+        db->mutex.unlock();\n+\n+    return true;\n+}\n+\n+bool CLogDB::Write(const data_t &key, const data_t &value) {\n+    if (fReadOnly)\n+        return false;\n+\n+    LOCK(cs);\n+\n+    bool fAutoTransaction = TxnBegin();\n+\n+    mapData[key] = value;\n+    setDirty.insert(key);\n+\n+    if (fAutoTransaction)\n+        return TxnCommit();\n+\n+    return true;\n+}\n+\n+bool CLogDB::Erase(const data_t &key) {\n+    if (fReadOnly)\n+        return false;\n+\n+    LOCK(cs);\n+\n+    bool fAutoTransaction = TxnBegin();\n+\n+    mapData.erase(key);\n+    setDirty.insert(key);\n+\n+    if (fAutoTransaction)\n+        return TxnCommit();\n+    return true;\n+}\n+\n+bool CLogDB::Read(const data_t &key, data_t &value) {\n+    LOCK(cs);\n+\n+    bool fAutoTransaction = TxnBegin();\n+    bool fOk = true;\n+\n+    // in readonly mode: no need to check for local modifications\n+    if (!fReadOnly && setDirty.count(key)) {\n+        std::map<data_t, data_t>::const_iterator it = mapData.find(key);\n+        if (it != mapData.end()) {\n+            value = (*it).second;\n+        } else {\n+            fOk = false;\n+        }\n+    } else {\n+        fOk = db->Read_(key, value);\n+    }\n+\n+    if (fAutoTransaction)\n+        fOk &= TxnCommit();\n+\n+    return fOk;\n+}\n+\n+bool CLogDB::Exists(const data_t &key) {\n+    LOCK(cs);\n+\n+    bool fAutoTransaction = TxnBegin();\n+\n+    bool fRet;\n+    // in readonly mode: no need to check for local modifications\n+    if (!fReadOnly && setDirty.count(key) != 0) {\n+        fRet = (mapData.count(key) != 0);\n+    } else {\n+        fRet = db->Exists_(key);\n+    }\n+\n+    if (fAutoTransaction)\n+        TxnCommit();\n+\n+    return fRet;\n+}"
      },
      {
        "sha": "ddc78a0ec4e2ed2a62f0fb0bde763b59cfdb1ae1",
        "filename": "src/logdb.h",
        "status": "added",
        "additions": 177,
        "deletions": 0,
        "changes": 177,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/251ff6d0a575602df95a08ada0a3636859798aeb/src/logdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/251ff6d0a575602df95a08ada0a3636859798aeb/src/logdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/logdb.h?ref=251ff6d0a575602df95a08ada0a3636859798aeb",
        "patch": "@@ -0,0 +1,177 @@\n+// Copyright (c) 2012 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file license.txt or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _BITCOIN_LOGDB_H_\n+#define _BITCOIN_LOGDB_H_\n+\n+#include <map>\n+#include <set>\n+\n+#include <openssl/sha.h>\n+#include <boost/thread/shared_mutex.hpp>\n+#include <boost/thread/locks.hpp>\n+\n+#include \"sync.h\"\n+#include \"serialize.h\"\n+\n+typedef std::vector<unsigned char> data_t;\n+\n+class CLogDB;\n+\n+class CLogDBFile\n+{\n+private:\n+    mutable boost::shared_mutex mutex;\n+\n+    FILE *file;\n+    SHA256_CTX ctxState;\n+\n+    // database\n+    std::map<data_t, data_t> mapData;\n+    size_t nUsed; // continuously updated\n+    size_t nWritten; // updated when writing a new block\n+\n+    // cached changes\n+    std::set<data_t> setDirty;\n+\n+    friend class CLogDB;\n+\n+protected:\n+    void Init_();\n+    bool Load_();\n+    bool Write_(const data_t &key, const data_t &value, bool fOverwrite = true, bool fLoad = false);\n+    bool Read_(const data_t &key, data_t &value) const;\n+    bool Exists_(const data_t &key) const;\n+    bool Erase_(const data_t &key, bool fLoad = false);\n+    bool Flush_();\n+    bool Close_();\n+\n+public:\n+    CLogDBFile()\n+    {\n+        Init_();\n+    }\n+\n+    ~CLogDBFile()\n+    {\n+        Close_();\n+    }\n+\n+    bool Open(const char *pszFile, bool fCreate = true)\n+    {\n+        boost::lock_guard<boost::shared_mutex> lock(mutex);\n+        Close_();\n+\n+        file = fopen(pszFile, fCreate ? \"a+b\" : \"r+b\");\n+\n+        if (file == NULL) {\n+            printf(\"Error opening %s: %s\\n\", pszFile, strerror(errno));\n+                return false;\n+        }\n+\n+        return Load_();\n+    }\n+\n+/*\n+    template<typename K, typename V>\n+    bool Write(const K &key, const V &value, bool fOverwrite = true)\n+    {\n+        CDataStream ssk(SER_DISK);\n+        ssk << key;\n+        data_t datak(ssk.begin(), ssk.end());\n+        CDataStream ssv(SER_DISK);\n+        ssv << value;\n+        data_t datav(ssv.begin(), ssv.end());\n+        CRITICAL_BLOCK(cs)\n+            return Write_(datak, datav, fOverwrite);\n+        return false;\n+    }\n+\n+    template<typename K, typename V>\n+    bool Read(const K &key, V &value) const\n+    {\n+        CDataStream ssk(SER_DISK);\n+        ssk << key;\n+        data_t datak(ssk.begin(), ssk.end());\n+        data_t datav;\n+        CRITICAL_BLOCK(cs)\n+            if (!Read_(datak,datav))\n+                return false;\n+        CDataStream ssv(datav, SER_DISK);\n+        ssv >> value;\n+        return true;\n+    }\n+\n+    template<typename K>\n+    bool Exists(const K &key) const\n+    {\n+        CDataStream ssk(SER_DISK);\n+        ssk << key;\n+        data_t datak(ssk.begin(), ssk.end());\n+        CRITICAL_BLOCK(cs)\n+            return Exists_(datak);\n+        return false;\n+    }\n+\n+    template<typename K>\n+    bool Erase(const K &key)\n+    { \n+        CDataStream ssk(SER_DISK);\n+        ssk << key;\n+        data_t datak(ssk.begin(), ssk.end());\n+        CRITICAL_BLOCK(cs)\n+            return Erase_(datak);\n+        return false;\n+    }\n+*/\n+\n+//    bool Flush()            { CRITICAL_BLOCK(cs) return Flush_();          return false; }\n+//    bool Close()            { CRITICAL_BLOCK(cs) return Close_();          return false; }\n+//    bool IsDirty() const    { CRITICAL_BLOCK(cs) return !setDirty.empty(); return false; }\n+//    bool IsOpen() const     { return file != NULL; }\n+\n+    bool Close() {\n+        boost::lock_guard<boost::shared_mutex> lock(mutex);\n+        return Close_();\n+    }\n+};\n+\n+class CLogDB\n+{\n+public:\n+    typedef data_t key_type;\n+    typedef data_t value_type;\n+    typedef std::map<key_type, value_type>::const_iterator const_iterator;\n+\n+private:\n+    mutable CCriticalSection cs;\n+    CLogDBFile * const db; // const pointer to non-const db\n+    const bool fReadOnly; // readonly CLogDB's use a shared lock instead of a normal\n+\n+    bool fTransaction; // true inside a transaction\n+    std::map<data_t, data_t> mapData; // must be empty outside transactions\n+    std::set<data_t> setDirty;\n+\n+public:\n+    bool TxnAbort();\n+    bool TxnBegin();\n+    bool TxnCommit();\n+\n+    CLogDB(CLogDBFile *dbIn, bool fReadOnlyIn = false) : db(dbIn), fReadOnly(fReadOnlyIn), fTransaction(false) { }\n+\n+    ~CLogDB() {\n+        TxnAbort();\n+    }\n+\n+    bool Write(const data_t &key, const data_t &value);\n+    bool Erase(const data_t &key);\n+    bool Read(const data_t &key, data_t &value);\n+    bool Exists(const data_t &key);\n+\n+    // only reads committed data, no local modifications\n+    const_iterator begin() const { return db->mapData.begin(); }\n+    const_iterator end() const   { return db->mapData.end(); }\n+};\n+\n+#endif"
      }
    ]
  },
  {
    "sha": "03c52a2da9440e48ac3cad7a7b1daf7728f3c61a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowM2M1MmEyZGE5NDQwZTQ4YWMzY2FkN2E3YjFkYWY3NzI4ZjNjNjFh",
    "commit": {
      "author": {
        "name": "Jonas Schnelli",
        "email": "jonas.schnelli@include7.ch",
        "date": "2015-04-12T14:04:21Z"
      },
      "committer": {
        "name": "Jonas Schnelli",
        "email": "jonas.schnelli@include7.ch",
        "date": "2015-07-08T14:57:52Z"
      },
      "message": "improve sipas logdb",
      "tree": {
        "sha": "0e2a9f7b8a143e9edf4492aeb599daa2e7649362",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0e2a9f7b8a143e9edf4492aeb599daa2e7649362"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/03c52a2da9440e48ac3cad7a7b1daf7728f3c61a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/03c52a2da9440e48ac3cad7a7b1daf7728f3c61a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/03c52a2da9440e48ac3cad7a7b1daf7728f3c61a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/03c52a2da9440e48ac3cad7a7b1daf7728f3c61a/comments",
    "author": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "251ff6d0a575602df95a08ada0a3636859798aeb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/251ff6d0a575602df95a08ada0a3636859798aeb",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/251ff6d0a575602df95a08ada0a3636859798aeb"
      }
    ],
    "stats": {
      "total": 440,
      "additions": 296,
      "deletions": 144
    },
    "files": [
      {
        "sha": "3ca11ef5d03d3dc5e3f5359b4320e33558b49e47",
        "filename": "src/logdb.cpp",
        "status": "modified",
        "additions": 190,
        "deletions": 64,
        "changes": 254,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/03c52a2da9440e48ac3cad7a7b1daf7728f3c61a/src/logdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/03c52a2da9440e48ac3cad7a7b1daf7728f3c61a/src/logdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/logdb.cpp?ref=03c52a2da9440e48ac3cad7a7b1daf7728f3c61a",
        "patch": "@@ -4,9 +4,21 @@\n \n #include <stdio.h>\n #include <unistd.h>\n+#include <sys/stat.h>\n \n #include \"logdb.h\"\n \n+#define LOGDB_MAX_KEY_SIZE 0x1000\n+#define LOGDB_MAX_VALUE_SIZE 0x100000\n+\n+static const unsigned char logdb_frameheader_magic[4] = {0xB1,0xA0,0xEE,0xC9};\n+\n+#ifdef DEBUG_LOGDB\n+#define LogDBDebug(...) LogPrint(NULL, __VA_ARGS__)\n+#else\n+#define LogDBDebug(...) ;\n+#endif\n+\n using namespace std;\n \n // Compact integers: least-significant digit first base-128 encoding.\n@@ -15,7 +27,7 @@ using namespace std;\n // Thus, the byte sequence a[] where all but the last has bit 128 set,\n // encodes the number (a[0] & 0x7F) + sum(i=1..n, 128^i*((a[i] & 0x7F)+1))\n \n-size_t static WriteInt(FILE* file, uint64 n)\n+size_t static WriteInt(FILE* file, uint64_t n)\n {\n     int nRet = 0;\n     do\n@@ -29,7 +41,7 @@ size_t static WriteInt(FILE* file, uint64 n)\n     return nRet;\n }\n \n-int static ReadInt(FILE *file)\n+uint64_t static ReadInt(FILE *file)\n {\n     uint64_t nRet = 0;\n     uint64_t nBase = 1;\n@@ -45,7 +57,7 @@ int static ReadInt(FILE *file)\n }\n \n // File format\n-// \n+//\n // The file consists of a list of frames, each of which consists of:\n // 4 bytes magic: 0xCC 0xC4 0xE6 0xB0\n // N records, each of which consists of:\n@@ -68,18 +80,37 @@ class CModEntry\n void CLogDBFile::Init_()\n {\n     file = NULL;\n-    SHA256_Init(&ctxState);\n+    ctxState.Reset();\n     mapData.clear();\n     nUsed = 0;\n     nWritten = 0;\n     setDirty.clear();\n }\n \n-bool CLogDBFile::Write_(const data_t &key, const data_t &value, bool fOverwrite, bool fLoad)\n+bool CLogDBFile::Open_(const char *pszFile, bool fCreate)\n {\n-    if (!fLoad)\n+    fileName = string(pszFile); //keep filename\n+    file = fopen(pszFile, \"a+b\"); //always use \"append\"-mode by default\n+    \n+    if (file == NULL) {\n+        LogPrintf(\"CLogDB::Open Error opening %s: %s\\n\", pszFile, strerror(errno));\n         return false;\n+    }\n+    \n+    if (fCreate)\n+    {\n+        if (ftell(file) > 0)\n+        {\n+            LogPrintf(\"CLogDB::Open Error creating %s. Existing file detected\\n\", pszFile);\n+            return false;\n+        }\n+    }\n+\n+    return true;\n+}\n \n+bool CLogDBFile::Write_(const data_t &key, const data_t &value, bool fOverwrite, bool fLoad)\n+{\n     // update nUsed\n     std::map<data_t, data_t>::iterator it = mapData.find(key);\n     if (it != mapData.end())\n@@ -94,6 +125,7 @@ bool CLogDBFile::Write_(const data_t &key, const data_t &value, bool fOverwrite,\n     nUsed += key.size() + value.size();\n \n     // update data\n+    mapData.erase(key);\n     mapData.insert(make_pair(key, value));\n     if (!fLoad)\n         setDirty.insert(key);\n@@ -119,9 +151,6 @@ bool CLogDBFile::Exists_(const data_t &key) const\n \n bool CLogDBFile::Erase_(const data_t &key, bool fLoad)\n {\n-    if (!fLoad)\n-        return false;\n-\n     std::map<data_t, data_t>::iterator it = mapData.find(key);\n     if (it != mapData.end())\n     {\n@@ -139,6 +168,8 @@ bool CLogDBFile::Close_()\n     if (file)\n     {\n         Flush_();\n+        \n+        LogDBDebug(\"CLogDBFile::Close(): closing file\\n\");\n         fclose(file);\n         Init_();\n     }\n@@ -147,80 +178,93 @@ bool CLogDBFile::Close_()\n \n bool CLogDBFile::Load_()\n {\n+    LogDBDebug(\"CLogDB::Load(): start loading\\n\");\n+    \n+    if (feof(file))\n+        return true;\n+    \n     do\n     {\n         if (feof(file))\n+        {\n+            LogDBDebug(\"CLogDB::Load(): end of file, returning\\n\");\n             return true;\n-        if (getc(file) != 0xCC) return feof(file);\n-        if (getc(file) != 0xC4) return false;\n-        if (getc(file) != 0xE6) return false;\n-        if (getc(file) != 0xB0) return false;\n+        }\n+        int aChar = getc(file);\n+        if (aChar != logdb_frameheader_magic[0])\n+        {\n+            LogDBDebug(\"CLogDB::Load(): first frame headerbyte is incorrect found %2x\\n\", aChar);\n+            return feof(file);\n+        }\n+        if (getc(file) != logdb_frameheader_magic[1]) return false;\n+        if (getc(file) != logdb_frameheader_magic[2]) return false;\n+        if (getc(file) != logdb_frameheader_magic[3]) return false;\n \n-        printf(\"CLogDB::Load(): frame header found\\n\");\n+        LogDBDebug(\"CLogDB::Load(): frame header found\\n\");\n \n         vector<CModEntry> vMod;\n \n         // update a copy of the state, so we can revert in case of error\n-        SHA256_CTX ctx = ctxState;\n+        CSHA256 ctx = ctxState;\n \n         do\n         {\n             if (feof(file))\n             {\n-                printf(\"CLogDB::Load(): unexpected eof at record start\\n\");\n+                LogPrintf(\"CLogDBFile::Load(): unexpected eof at record start\\n\");\n                 return false;\n             }\n \n             CModEntry entry;\n             entry.nMode = getc(file);\n             if (entry.nMode > 2)\n             {\n-                printf(\"CLogDB::Load(): unknown record mode\\n\");\n+                LogDBDebug(\"CLogDBFile::Load(): unknown record mode\\n\");\n                 return false;\n             }\n \n-            SHA256_Update(&ctx, &entry.nMode, 1);\n-\n+            ctx.Write((const unsigned char *)&entry.nMode, 1);\n+            \n             if (entry.nMode == 0)\n                 break;\n \n-            printf(\"CLogDB::Load(): loading record mode %i\\n\", entry.nMode);\n+            LogDBDebug(\"CLogDBFile::Load(): loading record mode %i\\n\", entry.nMode);\n \n             uint32_t nKeySize = ReadInt(file);\n-            if (nKeySize >= 0x1000)\n+            if (nKeySize >= LOGDB_MAX_KEY_SIZE)\n             {\n-                printf(\"CLogDB::Load(): oversizes key (%lu bytes)\\n\", (unsigned long)nKeySize);\n+                LogDBDebug(\"CLogDBFile::Load(): oversizes key (%lu bytes)\\n\", (unsigned long)nKeySize);\n                 return false;\n             }\n             entry.key.resize(nKeySize);\n             if (fread(&entry.key[0], nKeySize, 1, file) != 1)\n             {\n-                printf(\"CLogDB::Load(): unable to read key (%lu bytes)\\n\", (unsigned long)nKeySize);\n+                LogDBDebug(\"CLogDBFile::Load(): unable to read key (%lu bytes)\\n\", (unsigned long)nKeySize);\n                 return false;\n             }\n \n-            printf(\"CLogDB::load(): loading key (%.*s)\\n\", nKeySize, &entry.key[0]);\n+            LogDBDebug(\"CLogDBFile::load(): loading key (%.*s)\\n\", nKeySize, &entry.key[0]);\n \n-            SHA256_Update(&ctx, &nKeySize, 4);\n-            SHA256_Update(&ctx, &entry.key[0], nKeySize);\n+            ctx.Write((const unsigned char *)&nKeySize, 4);\n+            ctx.Write((const unsigned char *)&entry.key[0], nKeySize);\n \n             if (entry.nMode == 1)\n             {\n                 int nValueSize = ReadInt(file);\n-                if (nValueSize >= 0x100000)\n+                if (nValueSize >= LOGDB_MAX_VALUE_SIZE)\n                 {\n-                    printf(\"CLogDB::Load(): oversized value (%lu bytes)\\n\", (unsigned long)nValueSize);\n+                    LogDBDebug(\"CLogDBFile::Load(): oversized value (%lu bytes)\\n\", (unsigned long)nValueSize);\n                     return false;\n                 }\n                 entry.value.resize(nValueSize);\n                 if (fread(&entry.value[0], nValueSize, 1, file) != 1)\n                 {\n-                    printf(\"CLogDB::Load(): unable to read value (%lu bytes)\\n\", (unsigned long)nValueSize);\n+                    LogDBDebug(\"CLogDBFile::Load(): unable to read value (%lu bytes)\\n\", (unsigned long)nValueSize);\n                     return false;\n                 }\n \n-                SHA256_Update(&ctx, &nValueSize, 4);\n-                SHA256_Update(&ctx, &entry.value[0], nValueSize);\n+                ctx.Write((const unsigned char *)&nValueSize, 4);\n+                ctx.Write((const unsigned char *)&entry.value[0], nValueSize);\n             }\n \n             vMod.push_back(entry);\n@@ -229,17 +273,17 @@ bool CLogDBFile::Load_()\n         unsigned char check[8];\n         if (fread(check, 8, 1, file)!=1)\n         {\n-            printf(\"CLogDB::Load(): unable to read checksum\\n\");\n+            LogDBDebug(\"CLogDBFile::Load(): unable to read checksum\\n\");\n             return false;\n         }\n \n-        SHA256_CTX ctxFinal = ctx;\n+        CSHA256 ctxFinal = ctx;\n \n         unsigned char checkx[32];\n-        SHA256_Final(checkx, &ctxFinal);\n+        ctxFinal.Finalize(checkx);\n         if (memcmp(check,checkx,8))\n         {\n-            printf(\"CLogDB::Load(): checksum failed\\n\");\n+            LogPrintf(\"CLogDBFile::Load(): checksum failed\\n\");\n             return false;\n         }\n \n@@ -264,26 +308,37 @@ bool CLogDBFile::Load_()\n \n     } while(true);\n \n-    printf(\"CLogDB::Load(): done\\n\");\n+    LogDBDebug(\"CLogDBFile::Load(): done\\n\");\n+}\n+\n+bool CLogDBFile::Reopen_(bool readOnly)\n+{\n+    fclose(file);\n+    file = fopen(fileName.c_str(), (readOnly) ? \"rb+\" : \"ab+\");\n+    \n+    if(file)\n+        return true;\n+    else\n+        return false;\n }\n \n bool CLogDBFile::Flush_()\n {\n-    printf(\"CLogDB::Flush_()\\n\");\n+    LogDBDebug(\"CLogDBFile::Flush_()\\n\");\n \n     if (setDirty.empty())\n         return true;\n \n-    printf(\"CLogDB::Flush_(): not dirty\\n\");\n+    LogDBDebug(\"CLogDBFile::Flush_(): dirty entries found\\n\");\n \n-    unsigned char magic[4]={0xCC,0xC4,0xE6,0xB0};\n-\n-    if (fwrite(magic, 4, 1, file) != 1)\n+    if (fwrite(logdb_frameheader_magic, 4, 1, file) != 1)\n     {\n-        printf(\"CLogDB::Flush_(): error writing magic: %s\\n\", strerror(errno));\n+        LogDBDebug(\"CLogDBFile::Flush_(): error writing magic: %s\\n\", strerror(errno));\n+        return false;\n     }\n \n-    SHA256_CTX ctx = ctxState;\n+    \n+    CSHA256 ctx = ctxState;\n \n     for (set<data_t>::iterator it = setDirty.begin(); it != setDirty.end(); it++)\n     {\n@@ -297,19 +352,19 @@ bool CLogDBFile::Flush_()\n             uint32_t nDataSize = (*it2).second.size();\n             nWritten += nKeySize + nDataSize;\n \n-            printf(\"CLogDB::Flush(): writing update(%.*s)\\n\", nKeySize, &(*it)[0]);\n+            LogDBDebug(\"CLogDBFile::Flush(): writing update (keysize: %d, str0-2: %.3s)\\n\", nKeySize, &(*it)[0]);\n \n             putc(nMode, file);\n             WriteInt(file, nKeySize);\n             fwrite(&(*it)[0], nKeySize, 1, file);\n             WriteInt(file, nDataSize);\n             fwrite(&(*it2).second[0], nDataSize, 1, file);\n \n-            SHA256_Update(&ctx, &nMode, 1);\n-            SHA256_Update(&ctx, &nKeySize, 4);\n-            SHA256_Update(&ctx, &(*it)[0], nKeySize);\n-            SHA256_Update(&ctx, &nDataSize, 4);\n-            SHA256_Update(&ctx, &(*it2).second[0], nDataSize);\n+            ctx.Write((const unsigned char *)&nMode, 1);\n+            ctx.Write((const unsigned char *)&nKeySize, 4);\n+            ctx.Write((const unsigned char *)&(*it)[0], nKeySize);\n+            ctx.Write((const unsigned char *)&nDataSize, 4);\n+            ctx.Write((const unsigned char *)&(*it2).second[0], nDataSize);\n         }\n         else\n         {\n@@ -318,31 +373,32 @@ bool CLogDBFile::Flush_()\n             uint32_t nKeySize = (*it).size();\n             nWritten += nKeySize;\n \n-            printf(\"CLogDB::Flush(): writing erase(%.*s)\\n\", nKeySize, &(*it)[0]);\n+            \n+            LogDBDebug(\"CLogDBFile::Flush(): writing erase (keysize: %d, str0-2: %.3s)\\n\", nKeySize, &(*it)[0]);\n \n             putc(nMode, file);\n             WriteInt(file, nKeySize);\n             fwrite(&(*it)[0], nKeySize, 1, file);\n \n-            SHA256_Update(&ctx, &nMode, 1);\n-            SHA256_Update(&ctx, &nKeySize, 4);\n-            SHA256_Update(&ctx, &(*it)[0], nKeySize);\n+            ctx.Write((const unsigned char *)&nMode, 1);\n+            ctx.Write((const unsigned char *)&nKeySize, 4);\n+            ctx.Write((const unsigned char *)&(*it)[0], nKeySize);\n         }\n     }\n \n     unsigned char nMode = 0;\n     putc(nMode, file);\n-    SHA256_Update(&ctx, &nMode, 1);\n+    ctx.Write((const unsigned char *)&nMode, 1);\n \n-    SHA256_CTX ctxFinal = ctx;\n+    CSHA256 ctxFinal = ctx;\n     unsigned char buf[32];\n-    SHA256_Final(buf, &ctxFinal);\n+    ctxFinal.Finalize(buf);\n     fwrite(buf, 8, 1, file);\n     fflush(file);\n-    fdatasync(fileno(file));\n+    FileCommit(file);\n     ctxState = ctx;\n \n-    printf(\"CLogDB::Flush(): wrote frame\\n\");\n+    LogDBDebug(\"CLogDBFile::Flush(): wrote frame pos: %ld\\n\", ftell(file));\n \n     setDirty.clear();\n \n@@ -391,7 +447,7 @@ bool CLogDB::TxnCommit() {\n     // commit modifications to backing CLogDBFile\n     for (std::set<data_t>::const_iterator it = setDirty.begin(); it != setDirty.end(); it++) {\n          std::map<data_t, data_t>::const_iterator it2 = mapData.find(*it);\n-         if (it2 != mapData.end()) {\n+         if (it2 == mapData.end()) {\n              db->Erase_(*it);\n          } else {\n              db->Write_(*it, (*it2).second);\n@@ -401,24 +457,69 @@ bool CLogDB::TxnCommit() {\n     setDirty.clear();\n     if (!fReadOnly)\n         db->Flush_();\n-\n+    \n     fTransaction = false;\n     if (fReadOnly)\n         db->mutex.unlock_shared();\n     else\n         db->mutex.unlock();\n+    \n+    return true;\n+}\n+\n+bool CLogDB::ReloadDB(const string& walletFile)\n+{\n+    delete db;\n+    db = new CLogDBFile();\n+    db->Open(walletFile.c_str(), false);\n+    if (!Load())\n+    {\n+        loaded = false;\n+        return false;\n+    }\n \n     return true;\n }\n \n-bool CLogDB::Write(const data_t &key, const data_t &value) {\n+bool CLogDB::Load() {\n+    \n+    // for loading we need the file in \"rb+\" mode.\n+    db->Reopen_(true);\n+    \n+    // map to memory\n+    bool loadRet = db->Load_();\n+    \n+    // reset the file to append writing mode \"ab+\"\n+    if (loadRet)\n+    {\n+        db->Reopen_(false);\n+        loaded = true;\n+    }\n+    \n+    return loadRet;\n+}\n+\n+bool CLogDB::Write_(const data_t &key, const data_t &value, bool fOverwrite) {\n+    if (key.size() >= LOGDB_MAX_KEY_SIZE)\n+    {\n+        LogPrintf(\"CLogDB::Write(): max keysize exceeded\\n\");\n+        return false;\n+    }\n+    if (value.size() >= LOGDB_MAX_VALUE_SIZE)\n+    {\n+        LogPrintf(\"CLogDB::Write(): max keysize exceeded\\n\");\n+        return false;\n+    }\n     if (fReadOnly)\n         return false;\n \n     LOCK(cs);\n \n     bool fAutoTransaction = TxnBegin();\n \n+    if (!fOverwrite && Exists_(key))\n+        return false;\n+    \n     mapData[key] = value;\n     setDirty.insert(key);\n \n@@ -428,7 +529,7 @@ bool CLogDB::Write(const data_t &key, const data_t &value) {\n     return true;\n }\n \n-bool CLogDB::Erase(const data_t &key) {\n+bool CLogDB::Erase_(const data_t &key) {\n     if (fReadOnly)\n         return false;\n \n@@ -444,7 +545,7 @@ bool CLogDB::Erase(const data_t &key) {\n     return true;\n }\n \n-bool CLogDB::Read(const data_t &key, data_t &value) {\n+bool CLogDB::Read_(const data_t &key, data_t &value) {\n     LOCK(cs);\n \n     bool fAutoTransaction = TxnBegin();\n@@ -468,7 +569,7 @@ bool CLogDB::Read(const data_t &key, data_t &value) {\n     return fOk;\n }\n \n-bool CLogDB::Exists(const data_t &key) {\n+bool CLogDB::Exists_(const data_t &key) {\n     LOCK(cs);\n \n     bool fAutoTransaction = TxnBegin();\n@@ -486,3 +587,28 @@ bool CLogDB::Exists(const data_t &key) {\n \n     return fRet;\n }\n+\n+bool CLogDB::Flush(bool shutdown)\n+{\n+    boost::lock_guard<boost::shared_mutex> lock(db->mutex);\n+    bool state = db->Flush_();\n+    \n+    return state;\n+}\n+\n+bool CLogDB::Rewrite(const string &file)\n+{\n+    Flush();\n+\n+    CLogDBFile *newDB = new CLogDBFile();\n+    newDB->Open(file.c_str(), true); // create new file\n+    \n+    for (std::map<data_t, data_t>::iterator it = db->mapData.begin(); it != db->mapData.end(); it++)\n+    {\n+        newDB->Write_((*it).first, (*it).second);\n+    }\n+    \n+    newDB->Flush_();\n+    \n+    return true;\n+}"
      },
      {
        "sha": "c0b961cee06e248b59a612459e5cf9b67e7e8f5e",
        "filename": "src/logdb.h",
        "status": "modified",
        "additions": 106,
        "deletions": 80,
        "changes": 186,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/03c52a2da9440e48ac3cad7a7b1daf7728f3c61a/src/logdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/03c52a2da9440e48ac3cad7a7b1daf7728f3c61a/src/logdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/logdb.h?ref=03c52a2da9440e48ac3cad7a7b1daf7728f3c61a",
        "patch": "@@ -8,12 +8,17 @@\n #include <map>\n #include <set>\n \n-#include <openssl/sha.h>\n-#include <boost/thread/shared_mutex.hpp>\n-#include <boost/thread/locks.hpp>\n-\n-#include \"sync.h\"\n+#include \"clientversion.h\"\n #include \"serialize.h\"\n+#include \"streams.h\"\n+#include \"sync.h\"\n+#include \"util.h\"\n+#include \"version.h\"\n+\n+#include <boost/filesystem.hpp>\n+#include <boost/thread.hpp>\n+\n+#include \"crypto/sha256.h\"\n \n typedef std::vector<unsigned char> data_t;\n \n@@ -25,13 +30,15 @@ class CLogDBFile\n     mutable boost::shared_mutex mutex;\n \n     FILE *file;\n-    SHA256_CTX ctxState;\n-\n+    std::string fileName;\n+    \n+    CSHA256 ctxState;\n+    \n     // database\n     std::map<data_t, data_t> mapData;\n     size_t nUsed; // continuously updated\n     size_t nWritten; // updated when writing a new block\n-\n+    \n     // cached changes\n     std::set<data_t> setDirty;\n \n@@ -45,8 +52,10 @@ class CLogDBFile\n     bool Exists_(const data_t &key) const;\n     bool Erase_(const data_t &key, bool fLoad = false);\n     bool Flush_();\n+    bool Open_(const char *pszFile, bool fCreate = true);\n     bool Close_();\n-\n+    bool Reopen_(bool readOnly);\n+    \n public:\n     CLogDBFile()\n     {\n@@ -63,78 +72,13 @@ class CLogDBFile\n         boost::lock_guard<boost::shared_mutex> lock(mutex);\n         Close_();\n \n-        file = fopen(pszFile, fCreate ? \"a+b\" : \"r+b\");\n-\n-        if (file == NULL) {\n-            printf(\"Error opening %s: %s\\n\", pszFile, strerror(errno));\n-                return false;\n-        }\n-\n-        return Load_();\n+        return Open_(pszFile, fCreate);\n     }\n \n-/*\n-    template<typename K, typename V>\n-    bool Write(const K &key, const V &value, bool fOverwrite = true)\n-    {\n-        CDataStream ssk(SER_DISK);\n-        ssk << key;\n-        data_t datak(ssk.begin(), ssk.end());\n-        CDataStream ssv(SER_DISK);\n-        ssv << value;\n-        data_t datav(ssv.begin(), ssv.end());\n-        CRITICAL_BLOCK(cs)\n-            return Write_(datak, datav, fOverwrite);\n-        return false;\n-    }\n-\n-    template<typename K, typename V>\n-    bool Read(const K &key, V &value) const\n-    {\n-        CDataStream ssk(SER_DISK);\n-        ssk << key;\n-        data_t datak(ssk.begin(), ssk.end());\n-        data_t datav;\n-        CRITICAL_BLOCK(cs)\n-            if (!Read_(datak,datav))\n-                return false;\n-        CDataStream ssv(datav, SER_DISK);\n-        ssv >> value;\n-        return true;\n-    }\n-\n-    template<typename K>\n-    bool Exists(const K &key) const\n-    {\n-        CDataStream ssk(SER_DISK);\n-        ssk << key;\n-        data_t datak(ssk.begin(), ssk.end());\n-        CRITICAL_BLOCK(cs)\n-            return Exists_(datak);\n-        return false;\n-    }\n-\n-    template<typename K>\n-    bool Erase(const K &key)\n-    { \n-        CDataStream ssk(SER_DISK);\n-        ssk << key;\n-        data_t datak(ssk.begin(), ssk.end());\n-        CRITICAL_BLOCK(cs)\n-            return Erase_(datak);\n-        return false;\n-    }\n-*/\n-\n //    bool Flush()            { CRITICAL_BLOCK(cs) return Flush_();          return false; }\n //    bool Close()            { CRITICAL_BLOCK(cs) return Close_();          return false; }\n //    bool IsDirty() const    { CRITICAL_BLOCK(cs) return !setDirty.empty(); return false; }\n //    bool IsOpen() const     { return file != NULL; }\n-\n-    bool Close() {\n-        boost::lock_guard<boost::shared_mutex> lock(mutex);\n-        return Close_();\n-    }\n };\n \n class CLogDB\n@@ -143,35 +87,117 @@ class CLogDB\n     typedef data_t key_type;\n     typedef data_t value_type;\n     typedef std::map<key_type, value_type>::const_iterator const_iterator;\n-\n-private:\n     mutable CCriticalSection cs;\n-    CLogDBFile * const db; // const pointer to non-const db\n+    \n+private:\n+    CLogDBFile *db; // pointer to non-const db\n     const bool fReadOnly; // readonly CLogDB's use a shared lock instead of a normal\n \n     bool fTransaction; // true inside a transaction\n     std::map<data_t, data_t> mapData; // must be empty outside transactions\n     std::set<data_t> setDirty;\n \n+    bool loaded;\n+    \n public:\n     bool TxnAbort();\n     bool TxnBegin();\n     bool TxnCommit();\n-\n-    CLogDB(CLogDBFile *dbIn, bool fReadOnlyIn = false) : db(dbIn), fReadOnly(fReadOnlyIn), fTransaction(false) { }\n+    bool Flush(bool shutdown = false);\n+    \n+    CLogDB(std::string pathAndFile, bool fReadOnlyIn = false) : fReadOnly(fReadOnlyIn), fTransaction(false), loaded(false)\n+    {\n+        db = new CLogDBFile();\n+        bool createFile = true;\n+        if(boost::filesystem::exists(pathAndFile))\n+            createFile = false;\n+        \n+        if(db->Open(pathAndFile.c_str(), createFile) && createFile)\n+            loaded = true;\n+    }\n \n     ~CLogDB() {\n         TxnAbort();\n+        {\n+            boost::lock_guard<boost::shared_mutex> lock(db->mutex);\n+            db->Close_();\n+        }\n+        delete db;\n     }\n \n     bool Write(const data_t &key, const data_t &value);\n     bool Erase(const data_t &key);\n     bool Read(const data_t &key, data_t &value);\n     bool Exists(const data_t &key);\n+    bool Load();\n+    bool Rewrite(const std::string &file); //rewrite and compact to a new file\n+    bool ReloadDB(const std::string& walletFile); //!reload the db file\n+    \n+    bool Close() {\n+        boost::lock_guard<boost::shared_mutex> lock(db->mutex);\n+        loaded = false;\n+        return db->Close_();\n+    }\n+    \n+protected:\n+    bool Write_(const data_t &key, const data_t &value, bool fOverwrite = true);\n+    bool Erase_(const data_t &key);\n+    bool Read_(const data_t &key, data_t &value);\n+    bool Exists_(const data_t &key);\n \n+public:\n     // only reads committed data, no local modifications\n     const_iterator begin() const { return db->mapData.begin(); }\n     const_iterator end() const   { return db->mapData.end(); }\n+    \n+template<typename K, typename V>\n+bool Write(const K &key, const V &value, bool fOverwrite = true)\n+{\n+    if (!loaded) return false;\n+    \n+    CDataStream ssk(SER_DISK, CLIENT_VERSION);\n+    ssk << key;\n+    data_t datak(ssk.begin(), ssk.end());\n+    CDataStream ssv(SER_DISK, CLIENT_VERSION);\n+    ssv << value;\n+    data_t datav(ssv.begin(), ssv.end());\n+    return Write_(datak, datav, fOverwrite);\n+}\n+template<typename K, typename V>\n+bool Read(const K &key, V &value)\n+{\n+    if (!loaded) return false;\n+    \n+    CDataStream ssk(SER_DISK, CLIENT_VERSION);\n+    ssk << key;\n+    data_t datak(ssk.begin(), ssk.end());\n+    data_t datav;\n+    if (!Read_(datak,datav))\n+        return false;\n+    CDataStream ssv(datav, SER_DISK, CLIENT_VERSION);\n+    ssv >> value;\n+    return true;\n+}\n+template<typename K>\n+bool Exists(const K &key)\n+{\n+    if (!loaded) return false;\n+    \n+    CDataStream ssk(SER_DISK, CLIENT_VERSION);\n+    ssk << key;\n+    data_t datak(ssk.begin(), ssk.end());\n+    return Exists_(datak);\n+}\n+template<typename K>\n+bool Erase(const K &key)\n+{\n+    if (!loaded) return false;\n+    \n+    CDataStream ssk(SER_DISK, CLIENT_VERSION);\n+    ssk << key;\n+    data_t datak(ssk.begin(), ssk.end());\n+    return Erase_(datak);\n+}\n };\n \n #endif"
      }
    ]
  },
  {
    "sha": "6fec1c990651c0ad022f957b932bb94b9dd5bcc7",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2ZmVjMWM5OTA2NTFjMGFkMDIyZjk1N2I5MzJiYjk0YjlkZDViY2M3",
    "commit": {
      "author": {
        "name": "Jonas Schnelli",
        "email": "jonas.schnelli@include7.ch",
        "date": "2015-05-08T11:41:53Z"
      },
      "committer": {
        "name": "Jonas Schnelli",
        "email": "jonas.schnelli@include7.ch",
        "date": "2015-07-08T14:57:52Z"
      },
      "message": "[corewallet] add basic structur of a 2nd wallet implementation",
      "tree": {
        "sha": "bcda4dbe0559f8c8e65fc711970791f67c842545",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/bcda4dbe0559f8c8e65fc711970791f67c842545"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6fec1c990651c0ad022f957b932bb94b9dd5bcc7",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6fec1c990651c0ad022f957b932bb94b9dd5bcc7",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6fec1c990651c0ad022f957b932bb94b9dd5bcc7",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6fec1c990651c0ad022f957b932bb94b9dd5bcc7/comments",
    "author": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "03c52a2da9440e48ac3cad7a7b1daf7728f3c61a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/03c52a2da9440e48ac3cad7a7b1daf7728f3c61a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/03c52a2da9440e48ac3cad7a7b1daf7728f3c61a"
      }
    ],
    "stats": {
      "total": 2180,
      "additions": 2178,
      "deletions": 2
    },
    "files": [
      {
        "sha": "10800e5aeeb3eb97bdb231defe34ac5544ca2b17",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 18,
        "deletions": 0,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6fec1c990651c0ad022f957b932bb94b9dd5bcc7/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6fec1c990651c0ad022f957b932bb94b9dd5bcc7/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=6fec1c990651c0ad022f957b932bb94b9dd5bcc7",
        "patch": "@@ -74,6 +74,13 @@ AC_ARG_ENABLE([wallet],\n   [enable_wallet=$enableval],\n   [enable_wallet=yes])\n \n+# Enable corewallet\n+AC_ARG_ENABLE([corewallet],\n+  [AS_HELP_STRING([--enable-corewallet],\n+  [enable corewallet (default is no)])],\n+  [enable_corewallet=$enableval],\n+  [enable_corewallet=no])\n+\n AC_ARG_WITH([miniupnpc],\n   [AS_HELP_STRING([--with-miniupnpc],\n   [enable UPNP (default is yes if libminiupnpc is found)])],\n@@ -744,6 +751,16 @@ else\n   AC_MSG_RESULT(no)\n fi\n \n+dnl enable corewallet\n+AC_MSG_CHECKING([if corewallet should be enabled])\n+if test x$enable_corewallet != xno; then\n+  AC_MSG_RESULT(yes)\n+  AC_DEFINE_UNQUOTED([ENABLE_COREWALLET],[0],[Define to 1 to enable corewallet functions])\n+\n+else\n+  AC_MSG_RESULT(no)\n+fi\n+\n dnl enable upnp support\n AC_MSG_CHECKING([whether to build with support for UPnP])\n if test x$have_miniupnpc = xno; then\n@@ -834,6 +851,7 @@ AM_CONDITIONAL([TARGET_DARWIN], [test x$TARGET_OS = xdarwin])\n AM_CONDITIONAL([BUILD_DARWIN], [test x$BUILD_OS = xdarwin])\n AM_CONDITIONAL([TARGET_WINDOWS], [test x$TARGET_OS = xwindows])\n AM_CONDITIONAL([ENABLE_WALLET],[test x$enable_wallet = xyes])\n+AM_CONDITIONAL([ENABLE_COREWALLET],[test x$enable_corewallet = xyes])\n AM_CONDITIONAL([ENABLE_TESTS],[test x$use_tests = xyes])\n AM_CONDITIONAL([ENABLE_QT],[test x$bitcoin_enable_qt = xyes])\n AM_CONDITIONAL([ENABLE_QT_TESTS],[test x$use_tests$bitcoin_enable_qt_test = xyesyes])"
      },
      {
        "sha": "33ff6848f383b9ce6f2c7f5bb5e585fa285558cb",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 27,
        "deletions": 0,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6fec1c990651c0ad022f957b932bb94b9dd5bcc7/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6fec1c990651c0ad022f957b932bb94b9dd5bcc7/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=6fec1c990651c0ad022f957b932bb94b9dd5bcc7",
        "patch": "@@ -24,6 +24,7 @@ BITCOIN_INCLUDES += -I$(srcdir)/secp256k1/include\n \n LIBBITCOIN_SERVER=libbitcoin_server.a\n LIBBITCOIN_WALLET=libbitcoin_wallet.a\n+LIBBITCOIN_COREWALLET=libbitcoin_corewallet.a\n LIBBITCOIN_COMMON=libbitcoin_common.a\n LIBBITCOIN_CLI=libbitcoin_cli.a\n LIBBITCOIN_UTIL=libbitcoin_util.a\n@@ -48,6 +49,9 @@ if ENABLE_WALLET\n BITCOIN_INCLUDES += $(BDB_CPPFLAGS)\n EXTRA_LIBRARIES += libbitcoin_wallet.a\n endif\n+if ENABLE_COREWALLET\n+EXTRA_LIBRARIES += libbitcoin_corewallet.a\n+endif\n \n if BUILD_BITCOIN_LIBS\n lib_LTLIBRARIES = libbitcoinconsensus.la\n@@ -94,6 +98,12 @@ BITCOIN_CORE_H = \\\n   consensus/params.h \\\n   consensus/validation.h \\\n   core_io.h \\\n+  corewallet/corewallet.h \\\n+  corewallet/corewallet_basics.h \\\n+  corewallet/corewallet_db.h \\\n+  corewallet/corewallet_wallet.h \\\n+  corewallet/crypter.h \\\n+  corewallet/logdb.h \\\n   eccryptoverify.h \\\n   ecwrapper.h \\\n   hash.h \\\n@@ -150,6 +160,7 @@ BITCOIN_CORE_H = \\\n   validationinterface.h \\\n   version.h \\\n   wallet/crypter.h \\\n+  wallet/db.h \\\n   wallet/legacywallet.h \\\n   wallet/walletdb.h \\\n   wallet/wallet.h \\\n@@ -208,6 +219,18 @@ libbitcoin_wallet_a_SOURCES = \\\n   wallet/walletdb.cpp \\\n   $(BITCOIN_CORE_H)\n \n+# corewallet: shared between bitcoind and bitcoin-qt, but only linked\n+# when corewallet enabled\n+libbitcoin_corewallet_a_CPPFLAGS = $(BITCOIN_INCLUDES)\n+libbitcoin_corewallet_a_SOURCES = \\\n+  corewallet/corewallet.cpp \\\n+  corewallet/corewallet_db.cpp \\\n+  corewallet/corewallet_rpc.cpp \\\n+  corewallet/corewallet_wallet.cpp \\\n+  corewallet/crypter.cpp \\\n+  corewallet/logdb.cpp \\\n+  $(BITCOIN_CORE_H)\n+\n # crypto primitives library\n crypto_libbitcoin_crypto_a_CPPFLAGS = $(BITCOIN_CONFIG_INCLUDES)\n crypto_libbitcoin_crypto_a_SOURCES = \\\n@@ -320,6 +343,10 @@ if ENABLE_WALLET\n bitcoind_LDADD += libbitcoin_wallet.a\n endif\n \n+if ENABLE_COREWALLET\n+bitcoind_LDADD += libbitcoin_corewallet.a\n+endif\n+\n bitcoind_LDADD += $(BOOST_LIBS) $(BDB_LIBS) $(SSL_LIBS) $(CRYPTO_LIBS) $(MINIUPNPC_LIBS)\n #\n "
      },
      {
        "sha": "580273e000f16eca55ede3f945b7ce1089d90b56",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6fec1c990651c0ad022f957b932bb94b9dd5bcc7/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6fec1c990651c0ad022f957b932bb94b9dd5bcc7/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=6fec1c990651c0ad022f957b932bb94b9dd5bcc7",
        "patch": "@@ -84,13 +84,21 @@ BITCOIN_TESTS += \\\n   test/rpc_wallet_tests.cpp\n endif\n \n+if ENABLE_COREWALLET\n+BITCOIN_TESTS += \\\n+  corewallet/test/logdb_tests.cpp\n+endif\n+\n test_test_bitcoin_SOURCES = $(BITCOIN_TESTS) $(JSON_TEST_FILES) $(RAW_TEST_FILES)\n test_test_bitcoin_CPPFLAGS = $(BITCOIN_INCLUDES) -I$(builddir)/test/ $(TESTDEFS)\n test_test_bitcoin_LDADD = $(LIBBITCOIN_SERVER) $(LIBBITCOIN_CLI) $(LIBBITCOIN_COMMON) $(LIBBITCOIN_UTIL) $(LIBBITCOIN_CRYPTO) $(LIBBITCOIN_UNIVALUE) $(LIBLEVELDB) $(LIBMEMENV) \\\n   $(BOOST_LIBS) $(BOOST_UNIT_TEST_FRAMEWORK_LIB) $(LIBSECP256K1)\n if ENABLE_WALLET\n test_test_bitcoin_LDADD += $(LIBBITCOIN_WALLET)\n endif\n+if ENABLE_COREWALLET\n+test_test_bitcoin_LDADD += $(LIBBITCOIN_COREWALLET)\n+endif\n \n test_test_bitcoin_LDADD += $(LIBBITCOIN_CONSENSUS) $(BDB_LIBS) $(SSL_LIBS) $(CRYPTO_LIBS) $(MINIUPNPC_LIBS)\n test_test_bitcoin_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS) -static"
      },
      {
        "sha": "a20bbd8c56a6445ee472e9635458f2ece92eca64",
        "filename": "src/bitcoind.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 1,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6fec1c990651c0ad022f957b932bb94b9dd5bcc7/src/bitcoind.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6fec1c990651c0ad022f957b932bb94b9dd5bcc7/src/bitcoind.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoind.cpp?ref=6fec1c990651c0ad022f957b932bb94b9dd5bcc7",
        "patch": "@@ -14,6 +14,9 @@\n #ifdef ENABLE_WALLET\n #include \"wallet/legacywallet.h\"\n #endif\n+#ifdef ENABLE_COREWALLET\n+#include \"corewallet/corewallet.h\"\n+#endif\n \n #include <boost/algorithm/string/predicate.hpp>\n #include <boost/filesystem.hpp>\n@@ -74,6 +77,9 @@ bool AppInit(int argc, char* argv[])\n #ifdef ENABLE_WALLET\n     CLegacyWalletModule::RegisterSignals();\n #endif\n+#ifdef ENABLE_COREWALLET\n+    CoreWallet::RegisterSignals();\n+#endif\n     \n     // Process help and version before taking care about datadir\n     if (mapArgs.count(\"-?\") || mapArgs.count(\"-help\") || mapArgs.count(\"-version\"))\n@@ -176,7 +182,9 @@ bool AppInit(int argc, char* argv[])\n #ifdef ENABLE_WALLET\n     CLegacyWalletModule::UnregisterSignals();\n #endif\n-    \n+#ifdef ENABLE_COREWALLET\n+    CoreWallet::UnregisterSignals();\n+#endif\n     return fRet;\n }\n "
      },
      {
        "sha": "757499d617421bb09598468489094dbc4afa99fb",
        "filename": "src/corewallet/corewallet.cpp",
        "status": "added",
        "additions": 70,
        "deletions": 0,
        "changes": 70,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6fec1c990651c0ad022f957b932bb94b9dd5bcc7/src/corewallet/corewallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6fec1c990651c0ad022f957b932bb94b9dd5bcc7/src/corewallet/corewallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet.cpp?ref=6fec1c990651c0ad022f957b932bb94b9dd5bcc7",
        "patch": "@@ -0,0 +1,70 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2015 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"corewallet/corewallet.h\"\n+#include \"corewallet/corewallet_db.h\"\n+#include \"rpcserver.h\"\n+#include \"ui_interface.h\"\n+#include \"util.h\"\n+#include \"validationinterface.h\"\n+\n+#include <string>\n+\n+#include <boost/foreach.hpp>\n+\n+namespace CoreWallet {\n+\n+const static std::string DEFAULT_WALLET_FILE = \"wallet.wal\";\n+static std::map<std::string, WalletModel*> mapWallets;\n+static FileDB *walletsListDB;\n+    \n+//implemented in corewallet_rpc.cpp\n+extern void ExecuteRPC(const std::string& strMethod, const json_spirit::Array& params, json_spirit::Value& result, bool& accept);\n+\n+CoreWallet::Wallet* pCoreWallet = NULL;\n+\n+\n+CoreWallet::Wallet* GetWallet()\n+{\n+    return pCoreWallet;\n+}\n+    \n+void AppendHelpMessageString(std::string& strUsage, bool debugHelp)\n+{\n+    if (debugHelp)\n+        return;\n+    \n+    strUsage += HelpMessageGroup(_(\"CoreWallet options:\"));\n+    strUsage += HelpMessageOpt(\"-disablecorewallet\", _(\"Do not load the wallet and disable wallet RPC calls\"));\n+}\n+\n+void LoadAsModule(std::string& warningString, std::string& errorString, bool& stopInit)\n+{\n+    pCoreWallet = new Wallet(DEFAULT_WALLET_FILE);\n+}\n+    \n+void Dealloc()\n+{\n+    delete walletsListDB;\n+    walletsListDB = NULL;\n+}\n+    \n+void RegisterSignals()\n+{\n+    AddJSONRPCURISchema(\"/corewallet\");\n+    RPCServer::OnExtendedCommandExecute(boost::bind(&CoreWallet::ExecuteRPC, _1, _2, _3, _4));\n+    \n+    GetMainSignals().ShutdownFinished.connect(boost::bind(&Dealloc));\n+    GetMainSignals().CreateHelpString.connect(boost::bind(&AppendHelpMessageString, _1, _2));\n+    GetMainSignals().LoadModules.connect(boost::bind(&LoadAsModule, _1, _2, _3));\n+}\n+\n+void UnregisterSignals()\n+{\n+    GetMainSignals().ShutdownFinished.disconnect(boost::bind(&Dealloc));\n+    GetMainSignals().CreateHelpString.disconnect(boost::bind(&AppendHelpMessageString, _1, _2));\n+    GetMainSignals().LoadModules.disconnect(boost::bind(&LoadAsModule, _1, _2, _3));\n+}\n+};\n\\ No newline at end of file"
      },
      {
        "sha": "bd9c38e623343eb55a4e04fc5cc625b5a3a1c88d",
        "filename": "src/corewallet/corewallet.h",
        "status": "added",
        "additions": 18,
        "deletions": 0,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6fec1c990651c0ad022f957b932bb94b9dd5bcc7/src/corewallet/corewallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6fec1c990651c0ad022f957b932bb94b9dd5bcc7/src/corewallet/corewallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet.h?ref=6fec1c990651c0ad022f957b932bb94b9dd5bcc7",
        "patch": "@@ -0,0 +1,18 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2015 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_COREWALLT_COREWALLET_H\n+#define BITCOIN_COREWALLT_COREWALLET_H\n+\n+#include \"corewallet/corewallet_wallet.h\"\n+\n+namespace CoreWallet {\n+    void RegisterSignals();\n+    void UnregisterSignals();\n+    \n+    CoreWallet::Wallet* GetWallet();\n+};\n+\n+#endif // BITCOIN_COREWALLT_COREWALLET_H"
      },
      {
        "sha": "2e2fb52682fb210785109076a519cc83cb874db5",
        "filename": "src/corewallet/corewallet_basics.h",
        "status": "added",
        "additions": 84,
        "deletions": 0,
        "changes": 84,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6fec1c990651c0ad022f957b932bb94b9dd5bcc7/src/corewallet/corewallet_basics.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6fec1c990651c0ad022f957b932bb94b9dd5bcc7/src/corewallet/corewallet_basics.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet_basics.h?ref=6fec1c990651c0ad022f957b932bb94b9dd5bcc7",
        "patch": "@@ -0,0 +1,84 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2015 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_COREWALLET_COREWALLET_BASICS_H\n+#define BITCOIN_COREWALLET_COREWALLET_BASICS_H\n+\n+#include \"serialize.h\"\n+\n+#include <stdint.h>\n+\n+// basic/common corewallet classes\n+\n+namespace CoreWallet\n+{\n+    class CAddressBookMetadata\n+    {\n+    public:\n+        static const int CURRENT_VERSION=1;\n+        int nVersion;\n+        std::string label;\n+        std::string purpose;\n+        \n+        CAddressBookMetadata()\n+        {\n+            SetNull();\n+        }\n+\n+        ADD_SERIALIZE_METHODS;\n+        \n+        template <typename Stream, typename Operation>\n+        inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+            READWRITE(this->nVersion);\n+            nVersion = this->nVersion;\n+            READWRITE(label);\n+            READWRITE(purpose);\n+        }\n+        \n+        void SetNull()\n+        {\n+            nVersion = CURRENT_VERSION;\n+        }\n+    };\n+    \n+    class CKeyMetadata\n+    {\n+    public:\n+        static const int CURRENT_VERSION=1;\n+        int nVersion;\n+        int64_t nCreateTime; // 0 means unknown\n+        std::string label;\n+        std::string purpose;\n+        \n+        CKeyMetadata()\n+        {\n+            SetNull();\n+        }\n+        CKeyMetadata(int64_t nCreateTime_)\n+        {\n+            nVersion = CKeyMetadata::CURRENT_VERSION;\n+            nCreateTime = nCreateTime_;\n+        }\n+        \n+        ADD_SERIALIZE_METHODS;\n+        \n+        template <typename Stream, typename Operation>\n+        inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+            READWRITE(this->nVersion);\n+            nVersion = this->nVersion;\n+            READWRITE(nCreateTime);\n+            READWRITE(label);\n+            READWRITE(purpose);\n+        }\n+        \n+        void SetNull()\n+        {\n+            nVersion = CKeyMetadata::CURRENT_VERSION;\n+            nCreateTime = 0;\n+        }\n+    };\n+}; // end namespace CoreWallet\n+\n+#endif\n\\ No newline at end of file"
      },
      {
        "sha": "137eba096cde043af94e892c15de17bb15d84369",
        "filename": "src/corewallet/corewallet_db.cpp",
        "status": "added",
        "additions": 153,
        "deletions": 0,
        "changes": 153,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6fec1c990651c0ad022f957b932bb94b9dd5bcc7/src/corewallet/corewallet_db.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6fec1c990651c0ad022f957b932bb94b9dd5bcc7/src/corewallet/corewallet_db.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet_db.cpp?ref=6fec1c990651c0ad022f957b932bb94b9dd5bcc7",
        "patch": "@@ -0,0 +1,153 @@\n+#include \"corewallet/corewallet_db.h\"\n+#include \"corewallet/corewallet_wallet.h\"\n+\n+namespace CoreWallet\n+{\n+    \n+bool FileDB::WriteKey(const CPubKey& vchPubKey, const CPrivKey& vchPrivKey, const CoreWallet::CKeyMetadata& keyMeta)\n+{\n+    if (!Write(std::make_pair(std::string(\"keymeta\"), vchPubKey),\n+               keyMeta, false))\n+        return false;\n+    \n+    // hash pubkey/privkey to accelerate wallet load\n+    std::vector<unsigned char> vchKey;\n+    vchKey.reserve(vchPubKey.size() + vchPrivKey.size());\n+    vchKey.insert(vchKey.end(), vchPubKey.begin(), vchPubKey.end());\n+    vchKey.insert(vchKey.end(), vchPrivKey.begin(), vchPrivKey.end());\n+    \n+    return Write(std::make_pair(std::string(\"key\"), vchPubKey), std::make_pair(vchPrivKey, Hash(vchKey.begin(), vchKey.end())), false);\n+}\n+\n+bool ReadKeyValue(Wallet* pCoreWallet, CDataStream& ssKey, CDataStream& ssValue, std::string& strType, std::string& strErr)\n+{\n+    try {\n+        ssKey >> strType;\n+        if (strType == \"key\")\n+        {\n+            CPubKey vchPubKey;\n+            ssKey >> vchPubKey;\n+            if (!vchPubKey.IsValid())\n+            {\n+                strErr = \"Error reading wallet database: CPubKey corrupt\";\n+                return false;\n+            }\n+            CKey key;\n+            CPrivKey pkey;\n+            uint256 hash;\n+            \n+            ssValue >> pkey;\n+            ssValue >> hash;\n+\n+            bool fSkipCheck = false;\n+            \n+            if (!hash.IsNull())\n+            {\n+                // hash pubkey/privkey to accelerate wallet load\n+                std::vector<unsigned char> vchKey;\n+                vchKey.reserve(vchPubKey.size() + pkey.size());\n+                vchKey.insert(vchKey.end(), vchPubKey.begin(), vchPubKey.end());\n+                vchKey.insert(vchKey.end(), pkey.begin(), pkey.end());\n+                \n+                if (Hash(vchKey.begin(), vchKey.end()) != hash)\n+                {\n+                    strErr = \"Error reading wallet database: CPubKey/CPrivKey corrupt\";\n+                    return false;\n+                }\n+                \n+                fSkipCheck = true;\n+            }\n+            \n+            if (!key.Load(pkey, vchPubKey, fSkipCheck))\n+            {\n+                strErr = \"Error reading wallet database: CPrivKey corrupt\";\n+                return false;\n+            }\n+            if (!pCoreWallet->LoadKey(key, vchPubKey))\n+            {\n+                strErr = \"Error reading wallet database: LoadKey failed\";\n+                return false;\n+            }\n+        }\n+        else if (strType == \"keymeta\")\n+        {\n+            CPubKey vchPubKey;\n+            ssKey >> vchPubKey;\n+            CoreWallet::CKeyMetadata keyMeta;\n+            ssValue >> keyMeta;\n+            \n+            pCoreWallet->LoadKeyMetadata(vchPubKey, keyMeta);\n+            \n+            // find earliest key creation time, as wallet birthday\n+            if (!pCoreWallet->nTimeFirstKey ||\n+                (keyMeta.nCreateTime < pCoreWallet->nTimeFirstKey))\n+                pCoreWallet->nTimeFirstKey = keyMeta.nCreateTime;\n+        }\n+    } catch (...)\n+    {\n+        return false;\n+    }\n+    return true;\n+}\n+\n+bool FileDB::LoadWallet(Wallet* pCoreWallet)\n+{\n+    if(!Load())\n+        return false;\n+    \n+    bool fNoncriticalErrors = false;\n+    bool result = true;\n+    \n+    bool fAutoTransaction = TxnBegin();\n+    \n+    try {\n+        LOCK(pCoreWallet->cs_coreWallet);\n+        for (FileDB::const_iterator it = begin(); it != end(); it++)\n+        {\n+            // Read next record\n+            CDataStream ssKey((*it).first, SER_DISK, CLIENT_VERSION);\n+            CDataStream ssValue((*it).second, SER_DISK, CLIENT_VERSION);\n+            \n+            // Try to be tolerant of single corrupt records:\n+            std::string strType, strErr;\n+            if (!ReadKeyValue(pCoreWallet, ssKey, ssValue, strType, strErr))\n+            {\n+                // losing keys is considered a catastrophic error, anything else\n+                // we assume the user can live with:\n+                if (strType == \"key\")\n+                    result = false;\n+                else\n+                {\n+                    // Leave other errors alone, if we try to fix them we might make things worse.\n+                    fNoncriticalErrors = true; // ... but do warn the user there is something wrong.\n+                    if (strType == \"tx\")\n+                        // Rescan if there is a bad transaction record:\n+                        SoftSetBoolArg(\"-rescan\", true);\n+                }\n+            }\n+            if (!strErr.empty())\n+                LogPrintf(\"%s\\n\", strErr);\n+        }\n+    }\n+    catch (const boost::thread_interrupted&) {\n+        throw;\n+    }\n+    catch (...) {\n+        result = false;\n+    }\n+    \n+    if (fNoncriticalErrors && result == true)\n+        result = false;\n+    \n+    // Any wallet corruption at all: skip any rewriting or\n+    // upgrading, we don't want to make it worse.\n+    if (result != true)\n+        return result;\n+    \n+    if (fAutoTransaction)\n+        TxnCommit();\n+    \n+    return result;\n+}\n+\n+}; //end namespace\n\\ No newline at end of file"
      },
      {
        "sha": "a2f5e1b3de101741d64bbcc6e8719548f2ff0648",
        "filename": "src/corewallet/corewallet_db.h",
        "status": "added",
        "additions": 32,
        "deletions": 0,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6fec1c990651c0ad022f957b932bb94b9dd5bcc7/src/corewallet/corewallet_db.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6fec1c990651c0ad022f957b932bb94b9dd5bcc7/src/corewallet/corewallet_db.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet_db.h?ref=6fec1c990651c0ad022f957b932bb94b9dd5bcc7",
        "patch": "@@ -0,0 +1,32 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2013 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_COREWALLET_COREWALLET_DB_H\n+#define BITCOIN_COREWALLET_COREWALLET_DB_H\n+\n+#include \"corewallet/corewallet_basics.h\"\n+#include \"corewallet/logdb.h\"\n+#include \"key.h\"\n+#include \"keystore.h\"\n+\n+namespace CoreWallet\n+{\n+    \n+class Wallet;\n+\n+// FileDB: a wallet file-database based on logdb\n+class FileDB : public CLogDB\n+{\n+public:\n+    FileDB(const std::string& strFilename, const char* pszMode = \"r+\", bool fFlushOnClose = true) : CLogDB( (GetDataDir() / strFilename).string(), false) { }\n+\n+    bool LoadWallet(Wallet* pCoreWallet);\n+    \n+    bool WriteKey(const CPubKey& vchPubKey, const CPrivKey& vchPrivKey, const CoreWallet::CKeyMetadata &keyMeta);\n+};\n+    \n+}; // end namespace CoreWallet\n+\n+#endif // BITCOIN_COREWALLET_COREWALLET_DB_H"
      },
      {
        "sha": "80ffaa2e83ce3050c6edda352226131c4b2107ef",
        "filename": "src/corewallet/corewallet_rpc.cpp",
        "status": "added",
        "additions": 101,
        "deletions": 0,
        "changes": 101,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6fec1c990651c0ad022f957b932bb94b9dd5bcc7/src/corewallet/corewallet_rpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6fec1c990651c0ad022f957b932bb94b9dd5bcc7/src/corewallet/corewallet_rpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet_rpc.cpp?ref=6fec1c990651c0ad022f957b932bb94b9dd5bcc7",
        "patch": "@@ -0,0 +1,101 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2015 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"base58.h\"\n+#include \"corewallet/corewallet_basics.h\"\n+#include \"corewallet/corewallet.h\"\n+#include \"pubkey.h\"\n+#include \"rpcserver.h\"\n+#include \"utilstrencodings.h\"\n+\n+#include <string>\n+\n+#include \"json/json_spirit_utils.h\"\n+#include <boost/foreach.hpp>\n+\n+typedef json_spirit::Value(*rpcfn_type)(const json_spirit::Array& params, bool fHelp);\n+\n+namespace CoreWallet\n+{\n+\n+json_spirit::Value getnewaddress(const json_spirit::Array& params, bool fHelp)\n+{\n+    if (fHelp || params.size() != 0)\n+        throw std::runtime_error(\n+                            \"getnewaddress\\n\"\n+                            \"\\nReturns a new Bitcoin address for receiving payments.\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"\\\"bitcoinaddress\\\"    (string) The new bitcoin address\\n\"\n+                            \"\\nExamples:\\n\"\n+                            + HelpExampleCli(\"getnewaddress\", \"\")\n+                            + HelpExampleRpc(\"getnewaddress\", \"\")\n+                            );\n+    \n+\n+    CPubKey newKey = CoreWallet::GetWallet()->GenerateNewKey();\n+    CKeyID keyID = newKey.GetID();\n+    \n+    CoreWallet::GetWallet()->SetAddressBook(keyID, \"receive\");\n+    \n+    return CBitcoinAddress(keyID).ToString();\n+}\n+    \n+json_spirit::Value getaddresses(const json_spirit::Array& params, bool fHelp)\n+{\n+    if (fHelp || params.size() != 0)\n+        throw std::runtime_error(\n+                            \"getaddressesbyaccount \\\"account\\\"\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"[                     (json array of string)\\n\"\n+                            \"  \\\"bitcoinaddress\\\"  (string) a bitcoin address associated with the given account\\n\"\n+                            \"  ,...\\n\"\n+                            \"]\\n\"\n+                            \"\\nExamples:\\n\"\n+                            + HelpExampleCli(\"getaddressesbyaccount\", \"\\\"tabby\\\"\")\n+                            + HelpExampleRpc(\"getaddressesbyaccount\", \"\\\"tabby\\\"\")\n+                            );\n+    \n+    json_spirit::Array ret;\n+    BOOST_FOREACH(const PAIRTYPE(CBitcoinAddress, CoreWallet::CAddressBookMetadata)& item, CoreWallet::GetWallet()->mapAddressBook)\n+    {\n+        const CBitcoinAddress& address = item.first;\n+        ret.push_back(address.ToString());\n+    }\n+    return ret;\n+}\n+    \n+void ExecuteRPC(const std::string& strMethod, const json_spirit::Array& params, json_spirit::Value& result, bool& accept)\n+{\n+    if(strMethod == \"getnewaddress\")\n+    {\n+        result = getnewaddress(params, false);\n+        accept = true;\n+    }\n+    else if(strMethod == \"getaddresses\")\n+    {\n+        result = getaddresses(params, false);\n+        accept = true;\n+    }\n+}\n+    \n+void AddRPCHelp(std::string& helpString)\n+{\n+    helpString += \"\\n== CoreWallet ==\\n\";\n+    try {\n+        json_spirit::Array params;\n+        getnewaddress(params, true);\n+    } catch (const std::exception& e)\n+    {\n+        // Help text is returned in an exception\n+        std::string strHelp = std::string(e.what());\n+        if (strHelp.find('\\n') != std::string::npos)\n+            strHelp = strHelp.substr(0, strHelp.find('\\n'));\n+        \n+        helpString+=strHelp;\n+        \n+    }\n+}\n+    \n+}; //end namespace\n\\ No newline at end of file"
      },
      {
        "sha": "be5ef55adf14ba73518f56abb5380d49c856d57e",
        "filename": "src/corewallet/corewallet_wallet.cpp",
        "status": "added",
        "additions": 66,
        "deletions": 0,
        "changes": 66,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6fec1c990651c0ad022f957b932bb94b9dd5bcc7/src/corewallet/corewallet_wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6fec1c990651c0ad022f957b932bb94b9dd5bcc7/src/corewallet/corewallet_wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet_wallet.cpp?ref=6fec1c990651c0ad022f957b932bb94b9dd5bcc7",
        "patch": "@@ -0,0 +1,66 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2015 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"corewallet/corewallet_wallet.h\"\n+\n+#include \"base58.h\"\n+#include \"timedata.h\"\n+#include \"util.h\"\n+    \n+CPubKey CoreWallet::Wallet::GenerateNewKey()\n+{\n+    CKey secret;\n+    secret.MakeNewKey(true);\n+    \n+    CPubKey pubkey = secret.GetPubKey();\n+    assert(secret.VerifyPubKey(pubkey));\n+    \n+    // Create new metadata\n+    int64_t nCreationTime = GetTime();\n+    mapKeyMetadata[pubkey.GetID()] = CoreWallet::CKeyMetadata(nCreationTime);\n+    if (!nTimeFirstKey || nCreationTime < nTimeFirstKey)\n+        nTimeFirstKey = nCreationTime;\n+    \n+    if (!AddKeyPubKey(secret, pubkey))\n+        throw std::runtime_error(\"CWallet::GenerateNewKey(): AddKey failed\");\n+    return pubkey;\n+}\n+\n+bool CoreWallet::Wallet::LoadKey(const CKey& key, const CPubKey &pubkey)\n+{\n+    return CCryptoKeyStore::AddKeyPubKey(key, pubkey);\n+}\n+\n+bool CoreWallet::Wallet::AddKeyPubKey(const CKey& secret, const CPubKey &pubkey)\n+{\n+    if (!CCryptoKeyStore::AddKeyPubKey(secret, pubkey))\n+        return false;\n+    \n+    return walletDB->WriteKey(pubkey, secret.GetPrivKey(), mapKeyMetadata[pubkey.GetID()]);\n+}\n+\n+bool CoreWallet::Wallet::LoadKeyMetadata(const CPubKey &pubkey, const CoreWallet::CKeyMetadata &meta)\n+{\n+    if (meta.nCreateTime && (!nTimeFirstKey || meta.nCreateTime < nTimeFirstKey))\n+        nTimeFirstKey = meta.nCreateTime;\n+    \n+    mapKeyMetadata[pubkey.GetID()] = meta;\n+    return true;\n+}\n+\n+bool CoreWallet::Wallet::SetAddressBook(const CTxDestination& address, const std::string& strPurpose)\n+{\n+    CoreWallet::CAddressBookMetadata metadata;\n+    {\n+        LOCK(cs_coreWallet);\n+        std::map<CTxDestination, CoreWallet::CAddressBookMetadata> ::iterator mi = mapAddressBook.find(address);\n+        if(mi != mapAddressBook.end())\n+        {\n+            metadata = mapAddressBook[address];\n+        }\n+    }\n+    metadata.purpose = strPurpose;\n+    return walletDB->Write(make_pair(std::string(\"keymeta\"), CBitcoinAddress(address).ToString()), metadata);\n+}\n\\ No newline at end of file"
      },
      {
        "sha": "634400e0a2007cff80e678858fa6aab3cb4da562",
        "filename": "src/corewallet/corewallet_wallet.h",
        "status": "added",
        "additions": 81,
        "deletions": 0,
        "changes": 81,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6fec1c990651c0ad022f957b932bb94b9dd5bcc7/src/corewallet/corewallet_wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6fec1c990651c0ad022f957b932bb94b9dd5bcc7/src/corewallet/corewallet_wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet_wallet.h?ref=6fec1c990651c0ad022f957b932bb94b9dd5bcc7",
        "patch": "@@ -0,0 +1,81 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2015 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_COREWALLT_WALLET_H\n+#define BITCOIN_COREWALLT_WALLET_H\n+\n+#include \"corewallet/corewallet_basics.h\"\n+#include \"corewallet/corewallet_db.h\"\n+#include \"corewallet/crypter.h\"\n+#include \"key.h\"\n+#include \"keystore.h\"\n+#include \"validationinterface.h\"\n+\n+namespace CoreWallet {\n+    \n+class Wallet : public CCryptoKeyStore, public CValidationInterface{\n+public:\n+    mutable CCriticalSection cs_coreWallet;\n+    std::map<CKeyID, CoreWallet::CKeyMetadata> mapKeyMetadata;\n+    std::map<CTxDestination, CoreWallet::CAddressBookMetadata> mapAddressBook;\n+    int64_t nTimeFirstKey;\n+    FileDB *walletDB;\n+    \n+    Wallet(std::string strWalletFileIn)\n+    {\n+        //instantiate a wallet backend object and maps the stored values\n+        walletDB = new FileDB(strWalletFileIn);\n+        walletDB->LoadWallet(this);\n+    }\n+    \n+    /**\n+     * keystore implementation\n+     * Generate a new key\n+     */\n+    CPubKey GenerateNewKey();\n+    bool AddKeyPubKey(const CKey& key, const CPubKey &pubkey);\n+    bool LoadKeyMetadata(const CPubKey &pubkey, const CoreWallet::CKeyMetadata &metadata);\n+    bool LoadKey(const CKey& key, const CPubKey &pubkey);\n+    bool SetAddressBook(const CTxDestination& address, const std::string& purpose);\n+};\n+\n+// WalletModel: a wallet metadata class\n+class WalletModel\n+{\n+public:\n+    static const int CURRENT_VERSION=1;\n+    int nVersion;\n+    \n+    Wallet* pWallet; //no persistance\n+    std::string walletID; //only A-Za-z0-9._-\n+    std::string strWalletFilename;\n+    int64_t nCreateTime; // 0 means unknown\n+    \n+    WalletModel(const std::string& filenameIn, Wallet *pWalletIn)\n+    {\n+        strWalletFilename = filenameIn;\n+        pWallet = pWalletIn;\n+    }\n+    \n+    void SetNull()\n+    {\n+        nVersion = CURRENT_VERSION;\n+        nCreateTime = 0;\n+    }\n+    \n+    ADD_SERIALIZE_METHODS;\n+    \n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        READWRITE(this->nVersion);\n+        nVersion = this->nVersion;\n+        READWRITE(nCreateTime);\n+        READWRITE(strWalletFilename);\n+    }\n+};\n+\n+}\n+\n+#endif // BITCOIN_COREWALLT_WALLET_H"
      },
      {
        "sha": "f0a9d9ea801bb829727d2e0eb917deee1e297c21",
        "filename": "src/corewallet/crypter.cpp",
        "status": "added",
        "additions": 294,
        "deletions": 0,
        "changes": 294,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6fec1c990651c0ad022f957b932bb94b9dd5bcc7/src/corewallet/crypter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6fec1c990651c0ad022f957b932bb94b9dd5bcc7/src/corewallet/crypter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/crypter.cpp?ref=6fec1c990651c0ad022f957b932bb94b9dd5bcc7",
        "patch": "@@ -0,0 +1,294 @@\n+// Copyright (c) 2009-2013 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"corewallet/crypter.h\"\n+\n+#include \"script/script.h\"\n+#include \"script/standard.h\"\n+#include \"util.h\"\n+\n+#include <string>\n+#include <vector>\n+#include <boost/foreach.hpp>\n+#include <openssl/aes.h>\n+#include <openssl/evp.h>\n+\n+namespace CoreWallet {\n+bool CCrypter::SetKeyFromPassphrase(const SecureString& strKeyData, const std::vector<unsigned char>& chSalt, const unsigned int nRounds, const unsigned int nDerivationMethod)\n+{\n+    if (nRounds < 1 || chSalt.size() != WALLET_CRYPTO_SALT_SIZE)\n+        return false;\n+\n+    int i = 0;\n+    if (nDerivationMethod == 0)\n+        i = EVP_BytesToKey(EVP_aes_256_cbc(), EVP_sha512(), &chSalt[0],\n+                          (unsigned char *)&strKeyData[0], strKeyData.size(), nRounds, chKey, chIV);\n+\n+    if (i != (int)WALLET_CRYPTO_KEY_SIZE)\n+    {\n+        memory_cleanse(chKey, sizeof(chKey));\n+        memory_cleanse(chIV, sizeof(chIV));\n+        return false;\n+    }\n+\n+    fKeySet = true;\n+    return true;\n+}\n+\n+bool CCrypter::SetKey(const CKeyingMaterial& chNewKey, const std::vector<unsigned char>& chNewIV)\n+{\n+    if (chNewKey.size() != WALLET_CRYPTO_KEY_SIZE || chNewIV.size() != WALLET_CRYPTO_KEY_SIZE)\n+        return false;\n+\n+    memcpy(&chKey[0], &chNewKey[0], sizeof chKey);\n+    memcpy(&chIV[0], &chNewIV[0], sizeof chIV);\n+\n+    fKeySet = true;\n+    return true;\n+}\n+\n+bool CCrypter::Encrypt(const CKeyingMaterial& vchPlaintext, std::vector<unsigned char> &vchCiphertext)\n+{\n+    if (!fKeySet)\n+        return false;\n+\n+    // max ciphertext len for a n bytes of plaintext is\n+    // n + AES_BLOCK_SIZE - 1 bytes\n+    int nLen = vchPlaintext.size();\n+    int nCLen = nLen + AES_BLOCK_SIZE, nFLen = 0;\n+    vchCiphertext = std::vector<unsigned char> (nCLen);\n+\n+    EVP_CIPHER_CTX ctx;\n+\n+    bool fOk = true;\n+\n+    EVP_CIPHER_CTX_init(&ctx);\n+    if (fOk) fOk = EVP_EncryptInit_ex(&ctx, EVP_aes_256_cbc(), NULL, chKey, chIV) != 0;\n+    if (fOk) fOk = EVP_EncryptUpdate(&ctx, &vchCiphertext[0], &nCLen, &vchPlaintext[0], nLen) != 0;\n+    if (fOk) fOk = EVP_EncryptFinal_ex(&ctx, (&vchCiphertext[0]) + nCLen, &nFLen) != 0;\n+    EVP_CIPHER_CTX_cleanup(&ctx);\n+\n+    if (!fOk) return false;\n+\n+    vchCiphertext.resize(nCLen + nFLen);\n+    return true;\n+}\n+\n+bool CCrypter::Decrypt(const std::vector<unsigned char>& vchCiphertext, CKeyingMaterial& vchPlaintext)\n+{\n+    if (!fKeySet)\n+        return false;\n+\n+    // plaintext will always be equal to or lesser than length of ciphertext\n+    int nLen = vchCiphertext.size();\n+    int nPLen = nLen, nFLen = 0;\n+\n+    vchPlaintext = CKeyingMaterial(nPLen);\n+\n+    EVP_CIPHER_CTX ctx;\n+\n+    bool fOk = true;\n+\n+    EVP_CIPHER_CTX_init(&ctx);\n+    if (fOk) fOk = EVP_DecryptInit_ex(&ctx, EVP_aes_256_cbc(), NULL, chKey, chIV) != 0;\n+    if (fOk) fOk = EVP_DecryptUpdate(&ctx, &vchPlaintext[0], &nPLen, &vchCiphertext[0], nLen) != 0;\n+    if (fOk) fOk = EVP_DecryptFinal_ex(&ctx, (&vchPlaintext[0]) + nPLen, &nFLen) != 0;\n+    EVP_CIPHER_CTX_cleanup(&ctx);\n+\n+    if (!fOk) return false;\n+\n+    vchPlaintext.resize(nPLen + nFLen);\n+    return true;\n+}\n+\n+\n+static bool EncryptSecret(const CKeyingMaterial& vMasterKey, const CKeyingMaterial &vchPlaintext, const uint256& nIV, std::vector<unsigned char> &vchCiphertext)\n+{\n+    CCrypter cKeyCrypter;\n+    std::vector<unsigned char> chIV(WALLET_CRYPTO_KEY_SIZE);\n+    memcpy(&chIV[0], &nIV, WALLET_CRYPTO_KEY_SIZE);\n+    if(!cKeyCrypter.SetKey(vMasterKey, chIV))\n+        return false;\n+    return cKeyCrypter.Encrypt(*((const CKeyingMaterial*)&vchPlaintext), vchCiphertext);\n+}\n+\n+static bool DecryptSecret(const CKeyingMaterial& vMasterKey, const std::vector<unsigned char>& vchCiphertext, const uint256& nIV, CKeyingMaterial& vchPlaintext)\n+{\n+    CCrypter cKeyCrypter;\n+    std::vector<unsigned char> chIV(WALLET_CRYPTO_KEY_SIZE);\n+    memcpy(&chIV[0], &nIV, WALLET_CRYPTO_KEY_SIZE);\n+    if(!cKeyCrypter.SetKey(vMasterKey, chIV))\n+        return false;\n+    return cKeyCrypter.Decrypt(vchCiphertext, *((CKeyingMaterial*)&vchPlaintext));\n+}\n+\n+static bool DecryptKey(const CKeyingMaterial& vMasterKey, const std::vector<unsigned char>& vchCryptedSecret, const CPubKey& vchPubKey, CKey& key)\n+{\n+    CKeyingMaterial vchSecret;\n+    if(!DecryptSecret(vMasterKey, vchCryptedSecret, vchPubKey.GetHash(), vchSecret))\n+        return false;\n+\n+    if (vchSecret.size() != 32)\n+        return false;\n+\n+    key.Set(vchSecret.begin(), vchSecret.end(), vchPubKey.IsCompressed());\n+    return key.VerifyPubKey(vchPubKey);\n+}\n+\n+bool CCryptoKeyStore::SetCrypted()\n+{\n+    LOCK(cs_KeyStore);\n+    if (fUseCrypto)\n+        return true;\n+    if (!mapKeys.empty())\n+        return false;\n+    fUseCrypto = true;\n+    return true;\n+}\n+\n+bool CCryptoKeyStore::Lock()\n+{\n+    if (!SetCrypted())\n+        return false;\n+\n+    {\n+        LOCK(cs_KeyStore);\n+        vMasterKey.clear();\n+    }\n+\n+    NotifyStatusChanged(this);\n+    return true;\n+}\n+\n+bool CCryptoKeyStore::Unlock(const CKeyingMaterial& vMasterKeyIn)\n+{\n+    {\n+        LOCK(cs_KeyStore);\n+        if (!SetCrypted())\n+            return false;\n+\n+        bool keyPass = false;\n+        bool keyFail = false;\n+        CryptedKeyMap::const_iterator mi = mapCryptedKeys.begin();\n+        for (; mi != mapCryptedKeys.end(); ++mi)\n+        {\n+            const CPubKey &vchPubKey = (*mi).second.first;\n+            const std::vector<unsigned char> &vchCryptedSecret = (*mi).second.second;\n+            CKey key;\n+            if (!DecryptKey(vMasterKeyIn, vchCryptedSecret, vchPubKey, key))\n+            {\n+                keyFail = true;\n+                break;\n+            }\n+            keyPass = true;\n+            if (fDecryptionThoroughlyChecked)\n+                break;\n+        }\n+        if (keyPass && keyFail)\n+        {\n+            LogPrintf(\"The wallet is probably corrupted: Some keys decrypt but not all.\");\n+            assert(false);\n+        }\n+        if (keyFail || !keyPass)\n+            return false;\n+        vMasterKey = vMasterKeyIn;\n+        fDecryptionThoroughlyChecked = true;\n+    }\n+    NotifyStatusChanged(this);\n+    return true;\n+}\n+\n+bool CCryptoKeyStore::AddKeyPubKey(const CKey& key, const CPubKey &pubkey)\n+{\n+    {\n+        LOCK(cs_KeyStore);\n+        if (!IsCrypted())\n+            return CBasicKeyStore::AddKeyPubKey(key, pubkey);\n+\n+        if (IsLocked())\n+            return false;\n+\n+        std::vector<unsigned char> vchCryptedSecret;\n+        CKeyingMaterial vchSecret(key.begin(), key.end());\n+        if (!EncryptSecret(vMasterKey, vchSecret, pubkey.GetHash(), vchCryptedSecret))\n+            return false;\n+\n+        if (!AddCryptedKey(pubkey, vchCryptedSecret))\n+            return false;\n+    }\n+    return true;\n+}\n+\n+\n+bool CCryptoKeyStore::AddCryptedKey(const CPubKey &vchPubKey, const std::vector<unsigned char> &vchCryptedSecret)\n+{\n+    {\n+        LOCK(cs_KeyStore);\n+        if (!SetCrypted())\n+            return false;\n+\n+        mapCryptedKeys[vchPubKey.GetID()] = make_pair(vchPubKey, vchCryptedSecret);\n+    }\n+    return true;\n+}\n+\n+bool CCryptoKeyStore::GetKey(const CKeyID &address, CKey& keyOut) const\n+{\n+    {\n+        LOCK(cs_KeyStore);\n+        if (!IsCrypted())\n+            return CBasicKeyStore::GetKey(address, keyOut);\n+\n+        CryptedKeyMap::const_iterator mi = mapCryptedKeys.find(address);\n+        if (mi != mapCryptedKeys.end())\n+        {\n+            const CPubKey &vchPubKey = (*mi).second.first;\n+            const std::vector<unsigned char> &vchCryptedSecret = (*mi).second.second;\n+            return DecryptKey(vMasterKey, vchCryptedSecret, vchPubKey, keyOut);\n+        }\n+    }\n+    return false;\n+}\n+\n+bool CCryptoKeyStore::GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const\n+{\n+    {\n+        LOCK(cs_KeyStore);\n+        if (!IsCrypted())\n+            return CKeyStore::GetPubKey(address, vchPubKeyOut);\n+\n+        CryptedKeyMap::const_iterator mi = mapCryptedKeys.find(address);\n+        if (mi != mapCryptedKeys.end())\n+        {\n+            vchPubKeyOut = (*mi).second.first;\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n+bool CCryptoKeyStore::EncryptKeys(CKeyingMaterial& vMasterKeyIn)\n+{\n+    {\n+        LOCK(cs_KeyStore);\n+        if (!mapCryptedKeys.empty() || IsCrypted())\n+            return false;\n+\n+        fUseCrypto = true;\n+        BOOST_FOREACH(KeyMap::value_type& mKey, mapKeys)\n+        {\n+            const CKey &key = mKey.second;\n+            CPubKey vchPubKey = key.GetPubKey();\n+            CKeyingMaterial vchSecret(key.begin(), key.end());\n+            std::vector<unsigned char> vchCryptedSecret;\n+            if (!EncryptSecret(vMasterKeyIn, vchSecret, vchPubKey.GetHash(), vchCryptedSecret))\n+                return false;\n+            if (!AddCryptedKey(vchPubKey, vchCryptedSecret))\n+                return false;\n+        }\n+        mapKeys.clear();\n+    }\n+    return true;\n+}\n+}; //end namespace\n\\ No newline at end of file"
      },
      {
        "sha": "d3e461f0de3970da6a661a93e0240c0ed890b1e2",
        "filename": "src/corewallet/crypter.h",
        "status": "added",
        "additions": 197,
        "deletions": 0,
        "changes": 197,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6fec1c990651c0ad022f957b932bb94b9dd5bcc7/src/corewallet/crypter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6fec1c990651c0ad022f957b932bb94b9dd5bcc7/src/corewallet/crypter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/crypter.h?ref=6fec1c990651c0ad022f957b932bb94b9dd5bcc7",
        "patch": "@@ -0,0 +1,197 @@\n+// Copyright (c) 2009-2014 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_WALLET_CRYPTER_H\n+#define BITCOIN_WALLET_CRYPTER_H\n+\n+#include \"keystore.h\"\n+#include \"serialize.h\"\n+#include \"support/allocators/secure.h\"\n+\n+class uint256;\n+\n+namespace CoreWallet {\n+const unsigned int WALLET_CRYPTO_KEY_SIZE = 32;\n+const unsigned int WALLET_CRYPTO_SALT_SIZE = 8;\n+\n+/**\n+ * Private key encryption is done based on a CMasterKey,\n+ * which holds a salt and random encryption key.\n+ * \n+ * CMasterKeys are encrypted using AES-256-CBC using a key\n+ * derived using derivation method nDerivationMethod\n+ * (0 == EVP_sha512()) and derivation iterations nDeriveIterations.\n+ * vchOtherDerivationParameters is provided for alternative algorithms\n+ * which may require more parameters (such as scrypt).\n+ * \n+ * Wallet Private Keys are then encrypted using AES-256-CBC\n+ * with the double-sha256 of the public key as the IV, and the\n+ * master key's key as the encryption key (see keystore.[ch]).\n+ */\n+\n+/** Master key for wallet encryption */\n+class CMasterKey\n+{\n+public:\n+    std::vector<unsigned char> vchCryptedKey;\n+    std::vector<unsigned char> vchSalt;\n+    //! 0 = EVP_sha512()\n+    //! 1 = scrypt()\n+    unsigned int nDerivationMethod;\n+    unsigned int nDeriveIterations;\n+    //! Use this for more parameters to key derivation,\n+    //! such as the various parameters to scrypt\n+    std::vector<unsigned char> vchOtherDerivationParameters;\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        READWRITE(vchCryptedKey);\n+        READWRITE(vchSalt);\n+        READWRITE(nDerivationMethod);\n+        READWRITE(nDeriveIterations);\n+        READWRITE(vchOtherDerivationParameters);\n+    }\n+\n+    CMasterKey()\n+    {\n+        // 25000 rounds is just under 0.1 seconds on a 1.86 GHz Pentium M\n+        // ie slightly lower than the lowest hardware we need bother supporting\n+        nDeriveIterations = 25000;\n+        nDerivationMethod = 0;\n+        vchOtherDerivationParameters = std::vector<unsigned char>(0);\n+    }\n+};\n+\n+typedef std::vector<unsigned char, secure_allocator<unsigned char> > CKeyingMaterial;\n+\n+/** Encryption/decryption context with key information */\n+class CCrypter\n+{\n+private:\n+    unsigned char chKey[WALLET_CRYPTO_KEY_SIZE];\n+    unsigned char chIV[WALLET_CRYPTO_KEY_SIZE];\n+    bool fKeySet;\n+\n+public:\n+    bool SetKeyFromPassphrase(const SecureString &strKeyData, const std::vector<unsigned char>& chSalt, const unsigned int nRounds, const unsigned int nDerivationMethod);\n+    bool Encrypt(const CKeyingMaterial& vchPlaintext, std::vector<unsigned char> &vchCiphertext);\n+    bool Decrypt(const std::vector<unsigned char>& vchCiphertext, CKeyingMaterial& vchPlaintext);\n+    bool SetKey(const CKeyingMaterial& chNewKey, const std::vector<unsigned char>& chNewIV);\n+\n+    void CleanKey()\n+    {\n+        memory_cleanse(chKey, sizeof(chKey));\n+        memory_cleanse(chIV, sizeof(chIV));\n+        fKeySet = false;\n+    }\n+\n+    CCrypter()\n+    {\n+        fKeySet = false;\n+\n+        // Try to keep the key data out of swap (and be a bit over-careful to keep the IV that we don't even use out of swap)\n+        // Note that this does nothing about suspend-to-disk (which will put all our key data on disk)\n+        // Note as well that at no point in this program is any attempt made to prevent stealing of keys by reading the memory of the running process.\n+        LockedPageManager::Instance().LockRange(&chKey[0], sizeof chKey);\n+        LockedPageManager::Instance().LockRange(&chIV[0], sizeof chIV);\n+    }\n+\n+    ~CCrypter()\n+    {\n+        CleanKey();\n+\n+        LockedPageManager::Instance().UnlockRange(&chKey[0], sizeof chKey);\n+        LockedPageManager::Instance().UnlockRange(&chIV[0], sizeof chIV);\n+    }\n+};\n+\n+/** Keystore which keeps the private keys encrypted.\n+ * It derives from the basic key store, which is used if no encryption is active.\n+ */\n+class CCryptoKeyStore : public CBasicKeyStore\n+{\n+private:\n+    CryptedKeyMap mapCryptedKeys;\n+\n+    CKeyingMaterial vMasterKey;\n+\n+    //! if fUseCrypto is true, mapKeys must be empty\n+    //! if fUseCrypto is false, vMasterKey must be empty\n+    bool fUseCrypto;\n+\n+    //! keeps track of whether Unlock has run a thorough check before\n+    bool fDecryptionThoroughlyChecked;\n+\n+protected:\n+    bool SetCrypted();\n+\n+    //! will encrypt previously unencrypted keys\n+    bool EncryptKeys(CKeyingMaterial& vMasterKeyIn);\n+\n+    bool Unlock(const CKeyingMaterial& vMasterKeyIn);\n+\n+public:\n+    CCryptoKeyStore() : fUseCrypto(false), fDecryptionThoroughlyChecked(false)\n+    {\n+    }\n+\n+    bool IsCrypted() const\n+    {\n+        return fUseCrypto;\n+    }\n+\n+    bool IsLocked() const\n+    {\n+        if (!IsCrypted())\n+            return false;\n+        bool result;\n+        {\n+            LOCK(cs_KeyStore);\n+            result = vMasterKey.empty();\n+        }\n+        return result;\n+    }\n+\n+    bool Lock();\n+\n+    virtual bool AddCryptedKey(const CPubKey &vchPubKey, const std::vector<unsigned char> &vchCryptedSecret);\n+    bool AddKeyPubKey(const CKey& key, const CPubKey &pubkey);\n+    bool HaveKey(const CKeyID &address) const\n+    {\n+        {\n+            LOCK(cs_KeyStore);\n+            if (!IsCrypted())\n+                return CBasicKeyStore::HaveKey(address);\n+            return mapCryptedKeys.count(address) > 0;\n+        }\n+        return false;\n+    }\n+    bool GetKey(const CKeyID &address, CKey& keyOut) const;\n+    bool GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const;\n+    void GetKeys(std::set<CKeyID> &setAddress) const\n+    {\n+        if (!IsCrypted())\n+        {\n+            CBasicKeyStore::GetKeys(setAddress);\n+            return;\n+        }\n+        setAddress.clear();\n+        CryptedKeyMap::const_iterator mi = mapCryptedKeys.begin();\n+        while (mi != mapCryptedKeys.end())\n+        {\n+            setAddress.insert((*mi).first);\n+            mi++;\n+        }\n+    }\n+\n+    /**\n+     * Wallet status (encrypted, locked) changed.\n+     * Note: Called without locks held.\n+     */\n+    boost::signals2::signal<void (CCryptoKeyStore* wallet)> NotifyStatusChanged;\n+};\n+}; //end namespace\n+#endif // BITCOIN_WALLET_CRYPTER_H"
      },
      {
        "sha": "6a286ed6bc18dc20db01dff73da13cb05f6f168a",
        "filename": "src/corewallet/logdb.cpp",
        "status": "added",
        "additions": 614,
        "deletions": 0,
        "changes": 614,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6fec1c990651c0ad022f957b932bb94b9dd5bcc7/src/corewallet/logdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6fec1c990651c0ad022f957b932bb94b9dd5bcc7/src/corewallet/logdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/logdb.cpp?ref=6fec1c990651c0ad022f957b932bb94b9dd5bcc7",
        "patch": "@@ -0,0 +1,614 @@\n+// Copyright (c) 2012 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file license.txt or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <stdio.h>\n+#include <unistd.h>\n+#include <sys/stat.h>\n+\n+#include \"logdb.h\"\n+\n+#define LOGDB_MAX_KEY_SIZE 0x1000\n+#define LOGDB_MAX_VALUE_SIZE 0x100000\n+\n+static const unsigned char logdb_frameheader_magic[4] = {0xB1,0xA0,0xEE,0xC9};\n+#define DEBUG_LOGDB\n+#ifdef DEBUG_LOGDB\n+#define LogDBDebug(...) LogPrint(NULL, __VA_ARGS__)\n+#else\n+#define LogDBDebug(...) ;\n+#endif\n+\n+using namespace std;\n+\n+// Compact integers: least-significant digit first base-128 encoding.\n+// The high bit in each byte signifies whether another digit follows.\n+// To avoid redundancy, one is subtracted from all but the first digit.\n+// Thus, the byte sequence a[] where all but the last has bit 128 set,\n+// encodes the number (a[0] & 0x7F) + sum(i=1..n, 128^i*((a[i] & 0x7F)+1))\n+\n+size_t static WriteInt(FILE* file, uint64_t n)\n+{\n+    int nRet = 0;\n+    do\n+    {\n+        nRet++;\n+        putc((n % 128) | (n>127)*128, file);\n+        if (n<128)\n+            break;\n+        n = (n / 128)-1;\n+    } while(1);\n+    return nRet;\n+}\n+\n+uint64_t static ReadInt(FILE *file)\n+{\n+    uint64_t nRet = 0;\n+    uint64_t nBase = 1;\n+    while (nBase)\n+    {\n+        int nByte = getc(file);\n+        nRet += nBase * ((nByte & 127) + (nBase>1));\n+        if (nByte < 128)\n+            break;\n+        nBase *= 128;\n+    }\n+    return nRet;\n+}\n+\n+// File format\n+//\n+// The file consists of a list of frames, each of which consists of:\n+// 4 bytes magic: 0xCC 0xC4 0xE6 0xB0\n+// N records, each of which consists of:\n+//   1 byte mode: 1=insert/overwrite, 2=erase\n+//   integer: key length (max 4 KiB)\n+//   key\n+//   if mode==1: integer: data length (max 1 MiB)\n+//   if mode==1: data\n+// 0 byte\n+// 8 bytes checksum: first 8 bytes of running SHA256\n+\n+class CModEntry\n+{\n+public:\n+    unsigned char nMode;\n+    data_t key;\n+    data_t value;\n+};\n+\n+void CLogDBFile::Init_()\n+{\n+    file = NULL;\n+    ctxState.Reset();\n+    mapData.clear();\n+    nUsed = 0;\n+    nWritten = 0;\n+    setDirty.clear();\n+}\n+\n+bool CLogDBFile::Open_(const char *pszFile, bool fCreate)\n+{\n+    fileName = string(pszFile); //keep filename\n+    file = fopen(pszFile, \"a+b\"); //always use \"append\"-mode by default\n+    \n+    if (file == NULL) {\n+        LogPrintf(\"CLogDB::Open Error opening %s: %s\\n\", pszFile, strerror(errno));\n+        return false;\n+    }\n+    \n+    if (fCreate)\n+    {\n+        if (ftell(file) > 0)\n+        {\n+            LogPrintf(\"CLogDB::Open Error creating %s. Existing file detected\\n\", pszFile);\n+            return false;\n+        }\n+    }\n+\n+    return true;\n+}\n+\n+bool CLogDBFile::Write_(const data_t &key, const data_t &value, bool fOverwrite, bool fLoad)\n+{\n+    // update nUsed\n+    std::map<data_t, data_t>::iterator it = mapData.find(key);\n+    if (it != mapData.end())\n+    {\n+        if ((*it).second == value)\n+            return true;\n+\n+        if (!fOverwrite)\n+            return false;\n+        nUsed -= (*it).first.size() + (*it).second.size();\n+    }\n+    nUsed += key.size() + value.size();\n+\n+    // update data\n+    mapData.erase(key);\n+    mapData.insert(make_pair(key, value));\n+    if (!fLoad)\n+        setDirty.insert(key);\n+\n+    return true;\n+}\n+\n+bool CLogDBFile::Read_(const data_t &key, data_t &value) const\n+{\n+    std::map<data_t, data_t>::const_iterator it = mapData.find(key);\n+    if (it == mapData.end())\n+        return false;\n+\n+    value = (*it).second;\n+\n+    return true;\n+}\n+\n+bool CLogDBFile::Exists_(const data_t &key) const\n+{\n+    return mapData.count(key) > 0;\n+}\n+\n+bool CLogDBFile::Erase_(const data_t &key, bool fLoad)\n+{\n+    std::map<data_t, data_t>::iterator it = mapData.find(key);\n+    if (it != mapData.end())\n+    {\n+        nUsed -= (*it).first.size() + (*it).second.size();\n+        mapData.erase(it);\n+        if (!fLoad)\n+            setDirty.insert(key);\n+    }\n+\n+    return true;\n+}\n+\n+bool CLogDBFile::Close_()\n+{\n+    if (file)\n+    {\n+        Flush_();\n+        \n+        LogDBDebug(\"CLogDBFile::Close(): closing file\\n\");\n+        fclose(file);\n+        Init_();\n+    }\n+    return true;\n+}\n+\n+bool CLogDBFile::Load_()\n+{\n+    LogDBDebug(\"CLogDB::Load(): start loading\\n\");\n+    \n+    if (feof(file))\n+        return true;\n+    \n+    do\n+    {\n+        if (feof(file))\n+        {\n+            LogDBDebug(\"CLogDB::Load(): end of file, returning\\n\");\n+            return true;\n+        }\n+        int aChar = getc(file);\n+        if (aChar != logdb_frameheader_magic[0])\n+        {\n+            LogDBDebug(\"CLogDB::Load(): first frame headerbyte is incorrect found %2x\\n\", aChar);\n+            return feof(file);\n+        }\n+        if (getc(file) != logdb_frameheader_magic[1]) return false;\n+        if (getc(file) != logdb_frameheader_magic[2]) return false;\n+        if (getc(file) != logdb_frameheader_magic[3]) return false;\n+\n+        LogDBDebug(\"CLogDB::Load(): frame header found\\n\");\n+\n+        vector<CModEntry> vMod;\n+\n+        // update a copy of the state, so we can revert in case of error\n+        CSHA256 ctx = ctxState;\n+\n+        do\n+        {\n+            if (feof(file))\n+            {\n+                LogPrintf(\"CLogDBFile::Load(): unexpected eof at record start\\n\");\n+                return false;\n+            }\n+\n+            CModEntry entry;\n+            entry.nMode = getc(file);\n+            if (entry.nMode > 2)\n+            {\n+                LogDBDebug(\"CLogDBFile::Load(): unknown record mode\\n\");\n+                return false;\n+            }\n+\n+            ctx.Write((const unsigned char *)&entry.nMode, 1);\n+            \n+            if (entry.nMode == 0)\n+                break;\n+\n+            LogDBDebug(\"CLogDBFile::Load(): loading record mode %i\\n\", entry.nMode);\n+\n+            uint32_t nKeySize = ReadInt(file);\n+            if (nKeySize >= LOGDB_MAX_KEY_SIZE)\n+            {\n+                LogDBDebug(\"CLogDBFile::Load(): oversizes key (%lu bytes)\\n\", (unsigned long)nKeySize);\n+                return false;\n+            }\n+            entry.key.resize(nKeySize);\n+            if (fread(&entry.key[0], nKeySize, 1, file) != 1)\n+            {\n+                LogDBDebug(\"CLogDBFile::Load(): unable to read key (%lu bytes)\\n\", (unsigned long)nKeySize);\n+                return false;\n+            }\n+\n+            LogDBDebug(\"CLogDBFile::load(): loading key (%.*s)\\n\", nKeySize, &entry.key[0]);\n+\n+            ctx.Write((const unsigned char *)&nKeySize, 4);\n+            ctx.Write((const unsigned char *)&entry.key[0], nKeySize);\n+\n+            if (entry.nMode == 1)\n+            {\n+                int nValueSize = ReadInt(file);\n+                if (nValueSize >= LOGDB_MAX_VALUE_SIZE)\n+                {\n+                    LogDBDebug(\"CLogDBFile::Load(): oversized value (%lu bytes)\\n\", (unsigned long)nValueSize);\n+                    return false;\n+                }\n+                entry.value.resize(nValueSize);\n+                if (fread(&entry.value[0], nValueSize, 1, file) != 1)\n+                {\n+                    LogDBDebug(\"CLogDBFile::Load(): unable to read value (%lu bytes)\\n\", (unsigned long)nValueSize);\n+                    return false;\n+                }\n+\n+                ctx.Write((const unsigned char *)&nValueSize, 4);\n+                ctx.Write((const unsigned char *)&entry.value[0], nValueSize);\n+            }\n+\n+            vMod.push_back(entry);\n+        } while(true);\n+\n+        unsigned char check[8];\n+        if (fread(check, 8, 1, file)!=1)\n+        {\n+            LogDBDebug(\"CLogDBFile::Load(): unable to read checksum\\n\");\n+            return false;\n+        }\n+\n+        CSHA256 ctxFinal = ctx;\n+\n+        unsigned char checkx[32];\n+        ctxFinal.Finalize(checkx);\n+        if (memcmp(check,checkx,8))\n+        {\n+            LogPrintf(\"CLogDBFile::Load(): checksum failed\\n\");\n+            return false;\n+        }\n+\n+        // if we reach this point, the entire read frame was valid\n+        ctxState = ctx;\n+\n+        for (vector<CModEntry>::iterator it = vMod.begin(); it != vMod.end(); it++)\n+        {\n+            CModEntry &mod = *it;\n+            nWritten += mod.key.size() + mod.value.size();\n+            switch (mod.nMode)\n+            {\n+                case 1:\n+                    Write_(mod.key, mod.value, true, true);\n+                    break;\n+\n+                case 2:\n+                    Erase_(mod.key, true);\n+                    break;\n+            }\n+        }\n+\n+    } while(true);\n+\n+    LogDBDebug(\"CLogDBFile::Load(): done\\n\");\n+}\n+\n+bool CLogDBFile::Reopen_(bool readOnly)\n+{\n+    fclose(file);\n+    file = fopen(fileName.c_str(), (readOnly) ? \"rb+\" : \"ab+\");\n+    \n+    if(file)\n+        return true;\n+    else\n+        return false;\n+}\n+\n+bool CLogDBFile::Flush_()\n+{\n+    LogDBDebug(\"CLogDBFile::Flush_()\\n\");\n+\n+    if (setDirty.empty())\n+        return true;\n+\n+    LogDBDebug(\"CLogDBFile::Flush_(): dirty entries found\\n\");\n+\n+    if (fwrite(logdb_frameheader_magic, 4, 1, file) != 1)\n+    {\n+        LogDBDebug(\"CLogDBFile::Flush_(): error writing magic: %s\\n\", strerror(errno));\n+        return false;\n+    }\n+\n+    \n+    CSHA256 ctx = ctxState;\n+\n+    for (set<data_t>::iterator it = setDirty.begin(); it != setDirty.end(); it++)\n+    {\n+        map<data_t, data_t>::iterator it2 = mapData.find(*it);\n+\n+        if (it2 != mapData.end())\n+        {\n+            // update\n+            unsigned char nMode = 1;\n+            uint32_t nKeySize = (*it).size();\n+            uint32_t nDataSize = (*it2).second.size();\n+            nWritten += nKeySize + nDataSize;\n+\n+            LogDBDebug(\"CLogDBFile::Flush(): writing update (keysize: %d, str0-2: %.3s)\\n\", nKeySize, &(*it)[0]);\n+\n+            putc(nMode, file);\n+            WriteInt(file, nKeySize);\n+            fwrite(&(*it)[0], nKeySize, 1, file);\n+            WriteInt(file, nDataSize);\n+            fwrite(&(*it2).second[0], nDataSize, 1, file);\n+\n+            ctx.Write((const unsigned char *)&nMode, 1);\n+            ctx.Write((const unsigned char *)&nKeySize, 4);\n+            ctx.Write((const unsigned char *)&(*it)[0], nKeySize);\n+            ctx.Write((const unsigned char *)&nDataSize, 4);\n+            ctx.Write((const unsigned char *)&(*it2).second[0], nDataSize);\n+        }\n+        else\n+        {\n+            // erase\n+            unsigned char nMode = 2;\n+            uint32_t nKeySize = (*it).size();\n+            nWritten += nKeySize;\n+\n+            \n+            LogDBDebug(\"CLogDBFile::Flush(): writing erase (keysize: %d, str0-2: %.3s)\\n\", nKeySize, &(*it)[0]);\n+\n+            putc(nMode, file);\n+            WriteInt(file, nKeySize);\n+            fwrite(&(*it)[0], nKeySize, 1, file);\n+\n+            ctx.Write((const unsigned char *)&nMode, 1);\n+            ctx.Write((const unsigned char *)&nKeySize, 4);\n+            ctx.Write((const unsigned char *)&(*it)[0], nKeySize);\n+        }\n+    }\n+\n+    unsigned char nMode = 0;\n+    putc(nMode, file);\n+    ctx.Write((const unsigned char *)&nMode, 1);\n+\n+    CSHA256 ctxFinal = ctx;\n+    unsigned char buf[32];\n+    ctxFinal.Finalize(buf);\n+    fwrite(buf, 8, 1, file);\n+    fflush(file);\n+    FileCommit(file);\n+    ctxState = ctx;\n+\n+    LogDBDebug(\"CLogDBFile::Flush(): wrote frame pos: %ld\\n\", ftell(file));\n+\n+    setDirty.clear();\n+\n+    return true;\n+}\n+\n+bool CLogDB::TxnAbort() {\n+    LOCK(cs);\n+\n+    if (!fTransaction)\n+        return false;\n+\n+    mapData.clear();\n+    setDirty.clear();\n+\n+    fTransaction = false;\n+    if (fReadOnly)\n+        db->mutex.unlock_shared();\n+    else\n+        db->mutex.unlock();\n+\n+    return true;\n+}\n+\n+bool CLogDB::TxnBegin() {\n+    LOCK(cs);\n+\n+    if (fTransaction)\n+        return false;\n+\n+    if (fReadOnly)\n+        db->mutex.lock_shared();\n+    else\n+        db->mutex.lock();\n+\n+    fTransaction = true;\n+    return true;\n+}\n+\n+bool CLogDB::TxnCommit() {\n+    LOCK(cs);\n+\n+    if (!fTransaction)\n+        return false;\n+\n+    // commit modifications to backing CLogDBFile\n+    for (std::set<data_t>::const_iterator it = setDirty.begin(); it != setDirty.end(); it++) {\n+         std::map<data_t, data_t>::const_iterator it2 = mapData.find(*it);\n+         if (it2 == mapData.end()) {\n+             db->Erase_(*it);\n+         } else {\n+             db->Write_(*it, (*it2).second);\n+         }\n+    }\n+    mapData.clear();\n+    setDirty.clear();\n+    if (!fReadOnly)\n+        db->Flush_();\n+    \n+    fTransaction = false;\n+    if (fReadOnly)\n+        db->mutex.unlock_shared();\n+    else\n+        db->mutex.unlock();\n+    \n+    return true;\n+}\n+\n+bool CLogDB::ReloadDB(const string& walletFile)\n+{\n+    delete db;\n+    db = new CLogDBFile();\n+    db->Open(walletFile.c_str(), false);\n+    if (!Load())\n+    {\n+        loaded = false;\n+        return false;\n+    }\n+\n+    return true;\n+}\n+\n+bool CLogDB::Load() {\n+    \n+    // for loading we need the file in \"rb+\" mode.\n+    db->Reopen_(true);\n+    \n+    // map to memory\n+    bool loadRet = db->Load_();\n+    \n+    // reset the file to append writing mode \"ab+\"\n+    if (loadRet)\n+    {\n+        db->Reopen_(false);\n+        loaded = true;\n+    }\n+    \n+    return loadRet;\n+}\n+\n+bool CLogDB::Write_(const data_t &key, const data_t &value, bool fOverwrite) {\n+    if (key.size() >= LOGDB_MAX_KEY_SIZE)\n+    {\n+        LogPrintf(\"CLogDB::Write(): max keysize exceeded\\n\");\n+        return false;\n+    }\n+    if (value.size() >= LOGDB_MAX_VALUE_SIZE)\n+    {\n+        LogPrintf(\"CLogDB::Write(): max keysize exceeded\\n\");\n+        return false;\n+    }\n+    if (fReadOnly)\n+        return false;\n+\n+    LOCK(cs);\n+\n+    bool fAutoTransaction = TxnBegin();\n+\n+    if (!fOverwrite && Exists_(key))\n+        return false;\n+    \n+    mapData[key] = value;\n+    setDirty.insert(key);\n+\n+    if (fAutoTransaction)\n+        return TxnCommit();\n+\n+    return true;\n+}\n+\n+bool CLogDB::Erase_(const data_t &key) {\n+    if (fReadOnly)\n+        return false;\n+\n+    LOCK(cs);\n+\n+    bool fAutoTransaction = TxnBegin();\n+\n+    mapData.erase(key);\n+    setDirty.insert(key);\n+\n+    if (fAutoTransaction)\n+        return TxnCommit();\n+    return true;\n+}\n+\n+bool CLogDB::Read_(const data_t &key, data_t &value) {\n+    LOCK(cs);\n+\n+    bool fAutoTransaction = TxnBegin();\n+    bool fOk = true;\n+\n+    // in readonly mode: no need to check for local modifications\n+    if (!fReadOnly && setDirty.count(key)) {\n+        std::map<data_t, data_t>::const_iterator it = mapData.find(key);\n+        if (it != mapData.end()) {\n+            value = (*it).second;\n+        } else {\n+            fOk = false;\n+        }\n+    } else {\n+        fOk = db->Read_(key, value);\n+    }\n+\n+    if (fAutoTransaction)\n+        fOk &= TxnCommit();\n+\n+    return fOk;\n+}\n+\n+bool CLogDB::Exists_(const data_t &key) {\n+    LOCK(cs);\n+\n+    bool fAutoTransaction = TxnBegin();\n+\n+    bool fRet;\n+    // in readonly mode: no need to check for local modifications\n+    if (!fReadOnly && setDirty.count(key) != 0) {\n+        fRet = (mapData.count(key) != 0);\n+    } else {\n+        fRet = db->Exists_(key);\n+    }\n+\n+    if (fAutoTransaction)\n+        TxnCommit();\n+\n+    return fRet;\n+}\n+\n+bool CLogDB::Flush(bool shutdown)\n+{\n+    boost::lock_guard<boost::shared_mutex> lock(db->mutex);\n+    bool state = db->Flush_();\n+    \n+    return state;\n+}\n+\n+bool CLogDB::Rewrite(const string &file)\n+{\n+    Flush();\n+\n+    CLogDBFile *newDB = new CLogDBFile();\n+    newDB->Open(file.c_str(), true); // create new file\n+    \n+    for (std::map<data_t, data_t>::iterator it = db->mapData.begin(); it != db->mapData.end(); it++)\n+    {\n+        newDB->Write_((*it).first, (*it).second);\n+    }\n+    \n+    newDB->Flush_();\n+    \n+    return true;\n+}"
      },
      {
        "sha": "333cf02d6fe737f9d104213c9043cc1ed7607d4e",
        "filename": "src/corewallet/logdb.h",
        "status": "added",
        "additions": 203,
        "deletions": 0,
        "changes": 203,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6fec1c990651c0ad022f957b932bb94b9dd5bcc7/src/corewallet/logdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6fec1c990651c0ad022f957b932bb94b9dd5bcc7/src/corewallet/logdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/logdb.h?ref=6fec1c990651c0ad022f957b932bb94b9dd5bcc7",
        "patch": "@@ -0,0 +1,203 @@\n+// Copyright (c) 2012 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file license.txt or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _BITCOIN_LOGDB_H_\n+#define _BITCOIN_LOGDB_H_\n+\n+#include <map>\n+#include <set>\n+\n+#include \"clientversion.h\"\n+#include \"serialize.h\"\n+#include \"streams.h\"\n+#include \"sync.h\"\n+#include \"util.h\"\n+#include \"version.h\"\n+\n+#include <boost/filesystem.hpp>\n+#include <boost/thread.hpp>\n+\n+#include \"crypto/sha256.h\"\n+\n+typedef std::vector<unsigned char> data_t;\n+\n+class CLogDB;\n+\n+class CLogDBFile\n+{\n+private:\n+    mutable boost::shared_mutex mutex;\n+\n+    FILE *file;\n+    std::string fileName;\n+    \n+    CSHA256 ctxState;\n+    \n+    // database\n+    std::map<data_t, data_t> mapData;\n+    size_t nUsed; // continuously updated\n+    size_t nWritten; // updated when writing a new block\n+    \n+    // cached changes\n+    std::set<data_t> setDirty;\n+\n+    friend class CLogDB;\n+\n+protected:\n+    void Init_();\n+    bool Load_();\n+    bool Write_(const data_t &key, const data_t &value, bool fOverwrite = true, bool fLoad = false);\n+    bool Read_(const data_t &key, data_t &value) const;\n+    bool Exists_(const data_t &key) const;\n+    bool Erase_(const data_t &key, bool fLoad = false);\n+    bool Flush_();\n+    bool Open_(const char *pszFile, bool fCreate = true);\n+    bool Close_();\n+    bool Reopen_(bool readOnly);\n+    \n+public:\n+    CLogDBFile()\n+    {\n+        Init_();\n+    }\n+\n+    ~CLogDBFile()\n+    {\n+        Close_();\n+    }\n+\n+    bool Open(const char *pszFile, bool fCreate = true)\n+    {\n+        boost::lock_guard<boost::shared_mutex> lock(mutex);\n+        Close_();\n+\n+        return Open_(pszFile, fCreate);\n+    }\n+\n+//    bool Flush()            { CRITICAL_BLOCK(cs) return Flush_();          return false; }\n+//    bool Close()            { CRITICAL_BLOCK(cs) return Close_();          return false; }\n+//    bool IsDirty() const    { CRITICAL_BLOCK(cs) return !setDirty.empty(); return false; }\n+//    bool IsOpen() const     { return file != NULL; }\n+};\n+\n+class CLogDB\n+{\n+public:\n+    typedef data_t key_type;\n+    typedef data_t value_type;\n+    typedef std::map<key_type, value_type>::const_iterator const_iterator;\n+    mutable CCriticalSection cs;\n+    \n+private:\n+    CLogDBFile *db; // pointer to non-const db\n+    const bool fReadOnly; // readonly CLogDB's use a shared lock instead of a normal\n+\n+    bool fTransaction; // true inside a transaction\n+    std::map<data_t, data_t> mapData; // must be empty outside transactions\n+    std::set<data_t> setDirty;\n+\n+    bool loaded;\n+    \n+public:\n+    bool TxnAbort();\n+    bool TxnBegin();\n+    bool TxnCommit();\n+    bool Flush(bool shutdown = false);\n+    \n+    CLogDB(std::string pathAndFile, bool fReadOnlyIn = false) : fReadOnly(fReadOnlyIn), fTransaction(false), loaded(false)\n+    {\n+        db = new CLogDBFile();\n+        bool createFile = true;\n+        if(boost::filesystem::exists(pathAndFile))\n+            createFile = false;\n+        \n+        if(db->Open(pathAndFile.c_str(), createFile))\n+            loaded = true;\n+    }\n+\n+    ~CLogDB() {\n+        TxnAbort();\n+        {\n+            boost::lock_guard<boost::shared_mutex> lock(db->mutex);\n+            db->Close_();\n+        }\n+        delete db;\n+    }\n+\n+    bool Write(const data_t &key, const data_t &value);\n+    bool Erase(const data_t &key);\n+    bool Read(const data_t &key, data_t &value);\n+    bool Exists(const data_t &key);\n+    bool Load();\n+    bool Rewrite(const std::string &file); //rewrite and compact to a new file\n+    bool ReloadDB(const std::string& walletFile); //!reload the db file\n+    \n+    bool Close() {\n+        boost::lock_guard<boost::shared_mutex> lock(db->mutex);\n+        loaded = false;\n+        return db->Close_();\n+    }\n+    \n+protected:\n+    bool Write_(const data_t &key, const data_t &value, bool fOverwrite = true);\n+    bool Erase_(const data_t &key);\n+    bool Read_(const data_t &key, data_t &value);\n+    bool Exists_(const data_t &key);\n+\n+public:\n+    // only reads committed data, no local modifications\n+    const_iterator begin() const { return db->mapData.begin(); }\n+    const_iterator end() const   { return db->mapData.end(); }\n+    \n+template<typename K, typename V>\n+bool Write(const K &key, const V &value, bool fOverwrite = true)\n+{\n+    if (!loaded) return false;\n+    \n+    CDataStream ssk(SER_DISK, CLIENT_VERSION);\n+    ssk << key;\n+    data_t datak(ssk.begin(), ssk.end());\n+    CDataStream ssv(SER_DISK, CLIENT_VERSION);\n+    ssv << value;\n+    data_t datav(ssv.begin(), ssv.end());\n+    return Write_(datak, datav, fOverwrite);\n+}\n+template<typename K, typename V>\n+bool Read(const K &key, V &value)\n+{\n+    if (!loaded) return false;\n+    \n+    CDataStream ssk(SER_DISK, CLIENT_VERSION);\n+    ssk << key;\n+    data_t datak(ssk.begin(), ssk.end());\n+    data_t datav;\n+    if (!Read_(datak,datav))\n+        return false;\n+    CDataStream ssv(datav, SER_DISK, CLIENT_VERSION);\n+    ssv >> value;\n+    return true;\n+}\n+template<typename K>\n+bool Exists(const K &key)\n+{\n+    if (!loaded) return false;\n+    \n+    CDataStream ssk(SER_DISK, CLIENT_VERSION);\n+    ssk << key;\n+    data_t datak(ssk.begin(), ssk.end());\n+    return Exists_(datak);\n+}\n+template<typename K>\n+bool Erase(const K &key)\n+{\n+    if (!loaded) return false;\n+    \n+    CDataStream ssk(SER_DISK, CLIENT_VERSION);\n+    ssk << key;\n+    data_t datak(ssk.begin(), ssk.end());\n+    return Erase_(datak);\n+}\n+};\n+\n+#endif"
      },
      {
        "sha": "0e85eedbd0ff49c3a17215c397359305fff61027",
        "filename": "src/corewallet/test/logdb_tests.cpp",
        "status": "added",
        "additions": 202,
        "deletions": 0,
        "changes": 202,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6fec1c990651c0ad022f957b932bb94b9dd5bcc7/src/corewallet/test/logdb_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6fec1c990651c0ad022f957b932bb94b9dd5bcc7/src/corewallet/test/logdb_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/test/logdb_tests.cpp?ref=6fec1c990651c0ad022f957b932bb94b9dd5bcc7",
        "patch": "@@ -0,0 +1,202 @@\n+// Copyright (c) 2013 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"base58.h\"\n+#include \"key.h\"\n+#include \"corewallet/logdb.h\"\n+#include \"random.h\"\n+#include \"util.h\"\n+#include \"test/test_bitcoin.h\"\n+\n+#include <boost/test/unit_test.hpp>\n+\n+using namespace std;\n+static const string strSecret1     (\"Kwr371tjA9u2rFSMZjTNun2PXXP3WPZu2afRHTcta6KxEUdm1vEw\");\n+static const string strSecret2    (\"L3Hq7a8FEQwJkW1M2GNKDW28546Vp5miewcCzSqUD9kCAXrJdS3g\");\n+\n+BOOST_FIXTURE_TEST_SUITE(logdb_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(logdb_test_1)\n+{\n+    boost::filesystem::path tmpPath = GetTempPath() / strprintf(\"test_bitcoin_logdb_%lu_%i.logdb\", (unsigned long)GetTime(), (int)(GetRand(100000)));    \n+    std::string dbFile = tmpPath.string();\n+    \n+    \n+    LogPrintf(\"%s\", dbFile);\n+    \n+    int max_loops = 1;\n+    \n+    for(int i = 0;i<max_loops;i++)\n+    {\n+        \n+        // simple value test\n+        CLogDB *aDB = new CLogDB(dbFile, false);\n+        aDB->Load();\n+        aDB->Write(std::string(\"testvalue\"), std::string(\"aValue\"));\n+\n+        std::string returnString;\n+        aDB->Read(std::string(\"testvalue\"), returnString);\n+        BOOST_CHECK_EQUAL(returnString, std::string(\"aValue\"));\n+        \n+        aDB->Flush(true); //shutdown, close the file\n+        aDB->Close();\n+        delete aDB;\n+        \n+        aDB = new CLogDB(dbFile, false);\n+        aDB->Load();\n+        aDB->Read(std::string(\"testvalue\"), returnString);\n+        BOOST_CHECK_EQUAL(returnString, std::string(\"aValue\"));\n+        aDB->Write(std::string(\"testvalue\"), std::string(\"aValue2\"));\n+        aDB->Read(std::string(\"testvalue\"), returnString);\n+        BOOST_CHECK_EQUAL(returnString, std::string(\"aValue2\"));\n+        aDB->Flush(true); //shutdown, close the file\n+        aDB->Close();\n+        delete aDB;\n+        \n+        aDB = new CLogDB(dbFile, false);\n+        aDB->Load();\n+        aDB->Erase(std::string(\"testvalue\"));\n+        \n+        std::string returnString2;\n+        aDB->Read(std::string(\"testvalue\"), returnString2);\n+        BOOST_CHECK(returnString2 == \"\");\n+        aDB->Flush(true); //shutdown, close the file\n+        aDB->Close();\n+        delete aDB;\n+\n+        // store a key\n+        CLogDB *aDB2 = new CLogDB(dbFile, false);\n+        aDB2->Load();\n+        aDB2->Read(std::string(\"testvalue\"), returnString);\n+        BOOST_CHECK_EQUAL(returnString, std::string(\"aValue2\"));\n+        \n+        CBitcoinSecret bsecret;\n+        BOOST_CHECK( bsecret.SetString (strSecret1));\n+        CKey key1  = bsecret.GetKey();\n+        CPubKey pKey = key1.GetPubKey();\n+        aDB2->Write(std::string(\"keyOverwriteTest\"), pKey);\n+        aDB2->Flush(true); //shutdown, close the file\n+        aDB2->Close();\n+        delete aDB2;\n+        \n+        // overwrite existing key with a new pubkey\n+        aDB2 = new CLogDB(dbFile, false);\n+        aDB2->Load();\n+        bsecret.SetString(strSecret2);\n+        CKey key2  = bsecret.GetKey();\n+        CPubKey pKey2 = key2.GetPubKey();\n+        aDB2->Write(std::string(\"keyOverwriteTest\"), pKey2);\n+        aDB2->Flush(true); //shutdown, close the file\n+        aDB2->Close();\n+        delete aDB2;\n+\n+        // persistance and erase test\n+        aDB2 = new CLogDB(dbFile, false);\n+        aDB2->Load();\n+        CPubKey pKeyTest;\n+        aDB2->Read(std::string(\"keyOverwriteTest\"), pKeyTest);\n+        \n+        BOOST_CHECK(pKey2 == pKeyTest);\n+        BOOST_CHECK(pKey != pKeyTest);\n+        BOOST_CHECK(pKeyTest.IsValid() == true);\n+\n+        aDB2->Erase(std::string(\"keyOverwriteTest\"));\n+        CPubKey pKeyTestEmpty;\n+        aDB2->Read(std::string(\"keyOverwriteTest\"), pKeyTestEmpty);\n+        BOOST_CHECK(pKeyTestEmpty.IsValid() == false);\n+        aDB2->Flush(true); //shutdown, close the file\n+        aDB2->Close();\n+        delete aDB2;\n+        \n+        // check persistance of Erase\n+        aDB2 = new CLogDB(dbFile, false);\n+        aDB2->Load();\n+        CPubKey pKeyTestEmpty2;\n+        aDB2->Read(std::string(\"keyOverwriteTest\"), pKeyTestEmpty2);\n+        BOOST_CHECK(pKeyTestEmpty2.IsValid() == false);\n+        \n+        //maxKeySize\n+        std::string longKey = std::string(999,'a');\n+        bool state = aDB2->Write(longKey, std::string(\"newValue\"));\n+        BOOST_CHECK(state);\n+        aDB2->Flush(true); //shutdown, close the file\n+        aDB2->Close();\n+        delete aDB2;\n+        \n+        aDB2 = new CLogDB(dbFile, false);\n+        aDB2->Load();\n+        std::string newString;\n+        aDB2->Read(longKey, newString);\n+        BOOST_CHECK(newString == \"newValue\");\n+        aDB2->Flush(true); //shutdown, close the file\n+        \n+        std::string longKey2 = std::string(0x1001,'b');\n+        state = aDB2->Write(longKey2, std::string(\"newValue2\"));\n+        BOOST_CHECK(state == false);\n+        \n+        std::string newString2;\n+        aDB2->Read(longKey2, newString2);\n+        BOOST_CHECK(newString2 == \"\");\n+        \n+        aDB2->Close();\n+        delete aDB2;\n+    }\n+}\n+\n+\n+BOOST_AUTO_TEST_CASE(logdb_test_rewrite)\n+{\n+    boost::filesystem::path tmpPath = GetTempPath() / strprintf(\"test_bitcoin_logdb_compact_%lu_%i.logdb\", (unsigned long)GetTime(), (int)(GetRand(100000)));\n+    \n+    std::string dbFile = tmpPath.string();\n+    std::string dbFileRewritten = dbFile+\".tmp\";\n+    \n+\n+    CLogDB *aDB = new CLogDB(dbFile, false);\n+    aDB->Load();\n+    aDB->Write(std::string(\"testvalue\"), std::string(\"aValue\"));\n+    aDB->Flush(true); //shutdown, close the file\n+    aDB->Close();\n+    delete aDB;\n+    \n+    aDB = new CLogDB(dbFile, false);\n+    aDB->Load();\n+    std::string returnString;\n+    aDB->Read(std::string(\"testvalue\"), returnString);\n+    BOOST_CHECK_EQUAL(returnString, std::string(\"aValue\"));\n+    aDB->Write(std::string(\"testvalue\"), std::string(\"aValue2\")); //overwrite value\n+    aDB->Read(std::string(\"testvalue\"), returnString);\n+    BOOST_CHECK_EQUAL(returnString, std::string(\"aValue2\"));\n+    \n+    aDB->Rewrite(dbFileRewritten); //this new db should only containe key \"testvalue\" once\n+    \n+    aDB->Flush(true); //shutdown, close the file\n+    aDB->Close();\n+    delete aDB;\n+    \n+    \n+    //open the new compact db and check of the value\n+    aDB = new CLogDB(dbFileRewritten, false);\n+    aDB->Load();\n+    aDB->Read(std::string(\"testvalue\"), returnString);\n+    BOOST_CHECK_EQUAL(returnString, std::string(\"aValue2\"));\n+    aDB->Close();\n+    delete aDB;\n+\n+    \n+    // compare filesizes\n+    FILE *fh = fopen(dbFile.c_str(), \"rb\");\n+    fseek(fh, 0L, SEEK_END);\n+    size_t oldFileSize = ftell(fh);\n+    fclose(fh);\n+    \n+    fh = fopen(dbFileRewritten.c_str(), \"rb\");\n+    fseek(fh, 0L, SEEK_END);\n+    size_t newFileSize = ftell(fh);\n+    fclose(fh);\n+    \n+    BOOST_CHECK(newFileSize > (oldFileSize-8)/2.0); // file size must be half the size minus the ~8 header (depends on version int length) bytes\n+}\n+\n+BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "337ef536d0a7a7022b71cfbbad795eefebc525fb",
        "filename": "src/wallet/crypter.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6fec1c990651c0ad022f957b932bb94b9dd5bcc7/src/wallet/crypter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6fec1c990651c0ad022f957b932bb94b9dd5bcc7/src/wallet/crypter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/crypter.cpp?ref=6fec1c990651c0ad022f957b932bb94b9dd5bcc7",
        "patch": "@@ -2,7 +2,7 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#include \"crypter.h\"\n+#include \"wallet/crypter.h\"\n \n #include \"script/script.h\"\n #include \"script/standard.h\""
      },
      {
        "sha": "3ca11ef5d03d3dc5e3f5359b4320e33558b49e47",
        "filename": "src/wallet/logdb.cpp",
        "status": "renamed",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6fec1c990651c0ad022f957b932bb94b9dd5bcc7/src/wallet/logdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6fec1c990651c0ad022f957b932bb94b9dd5bcc7/src/wallet/logdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/logdb.cpp?ref=6fec1c990651c0ad022f957b932bb94b9dd5bcc7",
        "previous_filename": "src/logdb.cpp"
      },
      {
        "sha": "c0b961cee06e248b59a612459e5cf9b67e7e8f5e",
        "filename": "src/wallet/logdb.h",
        "status": "renamed",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6fec1c990651c0ad022f957b932bb94b9dd5bcc7/src/wallet/logdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6fec1c990651c0ad022f957b932bb94b9dd5bcc7/src/wallet/logdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/logdb.h?ref=6fec1c990651c0ad022f957b932bb94b9dd5bcc7",
        "previous_filename": "src/logdb.h"
      }
    ]
  },
  {
    "sha": "f42e8e79f2f3000013836209bc4f02516f676f6d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmNDJlOGU3OWYyZjMwMDAwMTM4MzYyMDliYzRmMDI1MTZmNjc2ZjZk",
    "commit": {
      "author": {
        "name": "Jonas Schnelli",
        "email": "jonas.schnelli@include7.ch",
        "date": "2015-04-13T13:00:47Z"
      },
      "committer": {
        "name": "Jonas Schnelli",
        "email": "jonas.schnelli@include7.ch",
        "date": "2015-07-08T14:57:53Z"
      },
      "message": "[corewallet] add basic multiwallet support",
      "tree": {
        "sha": "0ce355ceed132d1f44649e2606db75b2a7f5eb01",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0ce355ceed132d1f44649e2606db75b2a7f5eb01"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f42e8e79f2f3000013836209bc4f02516f676f6d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f42e8e79f2f3000013836209bc4f02516f676f6d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f42e8e79f2f3000013836209bc4f02516f676f6d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f42e8e79f2f3000013836209bc4f02516f676f6d/comments",
    "author": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6fec1c990651c0ad022f957b932bb94b9dd5bcc7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6fec1c990651c0ad022f957b932bb94b9dd5bcc7",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6fec1c990651c0ad022f957b932bb94b9dd5bcc7"
      }
    ],
    "stats": {
      "total": 269,
      "additions": 227,
      "deletions": 42
    },
    "files": [
      {
        "sha": "cf68a6fd1a8326d9ea5e1f9ca19da7f8d082a0c2",
        "filename": "src/corewallet/corewallet.cpp",
        "status": "modified",
        "additions": 75,
        "deletions": 6,
        "changes": 81,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f42e8e79f2f3000013836209bc4f02516f676f6d/src/corewallet/corewallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f42e8e79f2f3000013836209bc4f02516f676f6d/src/corewallet/corewallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet.cpp?ref=f42e8e79f2f3000013836209bc4f02516f676f6d",
        "patch": "@@ -5,6 +5,7 @@\n \n #include \"corewallet/corewallet.h\"\n #include \"corewallet/corewallet_db.h\"\n+#include \"corewallet/corewallet_wallet.h\"\n #include \"rpcserver.h\"\n #include \"ui_interface.h\"\n #include \"util.h\"\n@@ -17,18 +18,40 @@\n namespace CoreWallet {\n \n const static std::string DEFAULT_WALLET_FILE = \"wallet.wal\";\n-static std::map<std::string, WalletModel*> mapWallets;\n+const static std::string DEFAULT_WALLETS_METADATA_FILE = \"multiwallet.dat\";\n+static std::map<std::string, WalletModel> mapWallets;\n static FileDB *walletsListDB;\n     \n //implemented in corewallet_rpc.cpp\n extern void ExecuteRPC(const std::string& strMethod, const json_spirit::Array& params, json_spirit::Value& result, bool& accept);\n \n-CoreWallet::Wallet* pCoreWallet = NULL;\n \n-\n-CoreWallet::Wallet* GetWallet()\n+std::vector<std::string> GetWalletIDs()\n {\n-    return pCoreWallet;\n+    std::vector<std::string> vIDs;\n+    std::pair<std::string, WalletModel> walletAndMetadata; // what a map<int, int> is made of\n+    BOOST_FOREACH(walletAndMetadata, mapWallets) {\n+        vIDs.push_back(walletAndMetadata.first);\n+    }\n+    return vIDs;\n+}\n+    \n+CoreWallet::Wallet* GetWalletWithID(const std::string& walletIDIn)\n+{\n+    std::string walletID = walletIDIn;\n+    \n+    if (walletID == \"\" && mapWallets.size() == 1)\n+        walletID = mapWallets.begin()->first;\n+    \n+    if (mapWallets.find(walletID) != mapWallets.end())\n+    {\n+        if (!mapWallets[walletID].pWallet) //is it closed?\n+            mapWallets[walletID].pWallet = new Wallet(walletID);\n+        \n+        return mapWallets[walletID].pWallet;\n+    }\n+    \n+    return NULL;\n }\n     \n void AppendHelpMessageString(std::string& strUsage, bool debugHelp)\n@@ -39,12 +62,58 @@ void AppendHelpMessageString(std::string& strUsage, bool debugHelp)\n     strUsage += HelpMessageGroup(_(\"CoreWallet options:\"));\n     strUsage += HelpMessageOpt(\"-disablecorewallet\", _(\"Do not load the wallet and disable wallet RPC calls\"));\n }\n+    \n+void readWalletLists()\n+{\n+    CAutoFile multiwalletFile(fopen((GetDataDir() / DEFAULT_WALLETS_METADATA_FILE).string().c_str(), \"rb\"), SER_DISK, CLIENT_VERSION);\n+    if (!multiwalletFile.IsNull())\n+    {\n+        try {\n+            multiwalletFile >> mapWallets;\n+        } catch (const std::exception&) {\n+            LogPrintf(\"CoreWallet: could not read multiwallet metadata file (non-fatal)\");\n+        }\n+    }\n+}\n+\n+void writeWalletList()\n+{\n+    CAutoFile multiwalletFile(fopen((GetDataDir() / DEFAULT_WALLETS_METADATA_FILE).string().c_str(), \"wb\"), SER_DISK, CLIENT_VERSION);\n+    if (!multiwalletFile.IsNull())\n+        multiwalletFile << mapWallets;\n+}\n \n void LoadAsModule(std::string& warningString, std::string& errorString, bool& stopInit)\n {\n-    pCoreWallet = new Wallet(DEFAULT_WALLET_FILE);\n+    readWalletLists();\n+}\n+    \n+bool CheckFilenameString(const std::string& str)\n+{\n+    static std::string safeChars(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890._-\");\n+    std::string strResult;\n+    for (std::string::size_type i = 0; i < str.size(); i++)\n+    {\n+        if (safeChars.find(str[i]) == std::string::npos)\n+            return false;\n+    }\n+    return true;\n }\n     \n+void AddNewWallet(const std::string& walletID)\n+{\n+    if (mapWallets.find(walletID) != mapWallets.end())\n+        throw std::runtime_error(_(\"walletid already exists\"));\n+    \n+    if (!CheckFilenameString(walletID))\n+        throw std::runtime_error(_(\"wallet ids can only contain A-Za-z0-9._- chars\"));\n+    \n+    Wallet *newWallet = new Wallet(walletID);\n+    mapWallets[walletID] = WalletModel(walletID, newWallet);\n+    \n+    writeWalletList();\n+}\n+\n void Dealloc()\n {\n     delete walletsListDB;"
      },
      {
        "sha": "3ba8260ac629cfd4a31dbbaebe02a114e69b379e",
        "filename": "src/corewallet/corewallet.h",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f42e8e79f2f3000013836209bc4f02516f676f6d/src/corewallet/corewallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f42e8e79f2f3000013836209bc4f02516f676f6d/src/corewallet/corewallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet.h?ref=f42e8e79f2f3000013836209bc4f02516f676f6d",
        "patch": "@@ -12,7 +12,9 @@ namespace CoreWallet {\n     void RegisterSignals();\n     void UnregisterSignals();\n     \n-    CoreWallet::Wallet* GetWallet();\n+    std::vector<std::string> GetWalletIDs();\n+    Wallet* GetWalletWithID(const std::string& walletID = \"\");\n+    void AddNewWallet(const std::string& walletID);\n };\n \n #endif // BITCOIN_COREWALLT_COREWALLET_H"
      },
      {
        "sha": "e38409cbd46964d0ff8c5deb8d9db3fa509e7ede",
        "filename": "src/corewallet/corewallet_db.cpp",
        "status": "modified",
        "additions": 18,
        "deletions": 4,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f42e8e79f2f3000013836209bc4f02516f676f6d/src/corewallet/corewallet_db.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f42e8e79f2f3000013836209bc4f02516f676f6d/src/corewallet/corewallet_db.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet_db.cpp?ref=f42e8e79f2f3000013836209bc4f02516f676f6d",
        "patch": "@@ -1,13 +1,19 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2015 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"base58.h\"\n+\n #include \"corewallet/corewallet_db.h\"\n #include \"corewallet/corewallet_wallet.h\"\n \n namespace CoreWallet\n {\n     \n-bool FileDB::WriteKey(const CPubKey& vchPubKey, const CPrivKey& vchPrivKey, const CoreWallet::CKeyMetadata& keyMeta)\n+bool FileDB::WriteKey(const CPubKey& vchPubKey, const CPrivKey& vchPrivKey, const CKeyMetadata& keyMeta)\n {\n-    if (!Write(std::make_pair(std::string(\"keymeta\"), vchPubKey),\n-               keyMeta, false))\n+    if (!Write(std::make_pair(std::string(\"keymeta\"), vchPubKey), keyMeta, false))\n         return false;\n     \n     // hash pubkey/privkey to accelerate wallet load\n@@ -73,7 +79,7 @@ bool ReadKeyValue(Wallet* pCoreWallet, CDataStream& ssKey, CDataStream& ssValue,\n         {\n             CPubKey vchPubKey;\n             ssKey >> vchPubKey;\n-            CoreWallet::CKeyMetadata keyMeta;\n+            CKeyMetadata keyMeta;\n             ssValue >> keyMeta;\n             \n             pCoreWallet->LoadKeyMetadata(vchPubKey, keyMeta);\n@@ -83,6 +89,14 @@ bool ReadKeyValue(Wallet* pCoreWallet, CDataStream& ssKey, CDataStream& ssValue,\n                 (keyMeta.nCreateTime < pCoreWallet->nTimeFirstKey))\n                 pCoreWallet->nTimeFirstKey = keyMeta.nCreateTime;\n         }\n+        else if (strType == \"adrmeta\")\n+        {\n+            std::string strAddress;\n+            CAddressBookMetadata metadata;\n+            ssKey >> strAddress;\n+            ssValue >> metadata;\n+            pCoreWallet->mapAddressBook[CBitcoinAddress(strAddress).Get()] = metadata;\n+        }\n     } catch (...)\n     {\n         return false;"
      },
      {
        "sha": "e7b1f89032f4e68ddca074abd02f8c7696669fb2",
        "filename": "src/corewallet/corewallet_rpc.cpp",
        "status": "modified",
        "additions": 103,
        "deletions": 10,
        "changes": 113,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f42e8e79f2f3000013836209bc4f02516f676f6d/src/corewallet/corewallet_rpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f42e8e79f2f3000013836209bc4f02516f676f6d/src/corewallet/corewallet_rpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet_rpc.cpp?ref=f42e8e79f2f3000013836209bc4f02516f676f6d",
        "patch": "@@ -20,9 +20,38 @@ typedef json_spirit::Value(*rpcfn_type)(const json_spirit::Array& params, bool f\n namespace CoreWallet\n {\n \n+///////////////////////////\n+// helpers\n+///////////////////////////\n+\n+Wallet* WalletFromParams(const json_spirit::Array& params)\n+{\n+    if (params.size() < 1 || params[0].type() != json_spirit::obj_type)\n+        throw std::runtime_error(\"invalid parameters, always use a json key/value object\");\n+    std::string walletID = \"\"; //\"\" stands for default wallet\n+    \n+    const json_spirit::Object& o = params[0].get_obj();\n+    walletID = find_value(o, \"walletid\").get_str();\n+    if (params.size() > 0 && params[0].type() == json_spirit::obj_type) //TODO also allow params at index position different the 0\n+    {\n+        const json_spirit::Object& o = params[0].get_obj();\n+        json_spirit::Value possibleValue = find_value(o, \"walletid\");\n+        if (!possibleValue.is_null())\n+            walletID = possibleValue.get_str();\n+    }\n+    Wallet* wallet = CoreWallet::GetWalletWithID(walletID);\n+    if (!wallet)\n+        throw std::runtime_error(\"Wallet (\"+SanitizeString(walletID)+\") not found\");\n+    \n+    return wallet;\n+}\n+\n+///////////////////////////\n+// Keys/Addresses stack\n+///////////////////////////\n json_spirit::Value getnewaddress(const json_spirit::Array& params, bool fHelp)\n {\n-    if (fHelp || params.size() != 0)\n+    if (fHelp || params.size() != 1)\n         throw std::runtime_error(\n                             \"getnewaddress\\n\"\n                             \"\\nReturns a new Bitcoin address for receiving payments.\\n\"\n@@ -34,19 +63,20 @@ json_spirit::Value getnewaddress(const json_spirit::Array& params, bool fHelp)\n                             );\n     \n \n-    CPubKey newKey = CoreWallet::GetWallet()->GenerateNewKey();\n+    Wallet *wallet = WalletFromParams(params);\n+    CPubKey newKey = wallet->GenerateNewKey();\n     CKeyID keyID = newKey.GetID();\n     \n-    CoreWallet::GetWallet()->SetAddressBook(keyID, \"receive\");\n+    wallet->SetAddressBook(keyID, \"receive\");\n     \n     return CBitcoinAddress(keyID).ToString();\n }\n     \n-json_spirit::Value getaddresses(const json_spirit::Array& params, bool fHelp)\n+json_spirit::Value listaddresses(const json_spirit::Array& params, bool fHelp)\n {\n-    if (fHelp || params.size() != 0)\n+    if (fHelp || params.size() != 1)\n         throw std::runtime_error(\n-                            \"getaddressesbyaccount \\\"account\\\"\\n\"\n+                            \"listaddresses\\n\"\n                             \"\\nResult:\\n\"\n                             \"[                     (json array of string)\\n\"\n                             \"  \\\"bitcoinaddress\\\"  (string) a bitcoin address associated with the given account\\n\"\n@@ -56,26 +86,88 @@ json_spirit::Value getaddresses(const json_spirit::Array& params, bool fHelp)\n                             + HelpExampleCli(\"getaddressesbyaccount\", \"\\\"tabby\\\"\")\n                             + HelpExampleRpc(\"getaddressesbyaccount\", \"\\\"tabby\\\"\")\n                             );\n-    \n+    Wallet *wallet = WalletFromParams(params);\n     json_spirit::Array ret;\n-    BOOST_FOREACH(const PAIRTYPE(CBitcoinAddress, CoreWallet::CAddressBookMetadata)& item, CoreWallet::GetWallet()->mapAddressBook)\n+    BOOST_FOREACH(const PAIRTYPE(CBitcoinAddress, CoreWallet::CAddressBookMetadata)& item, wallet->mapAddressBook)\n     {\n         const CBitcoinAddress& address = item.first;\n         ret.push_back(address.ToString());\n     }\n     return ret;\n }\n+\n+    \n+    \n+///////////////////////////\n+// MultiWallet stack\n+///////////////////////////\n+json_spirit::Value addwallet(const json_spirit::Array& params, bool fHelp)\n+{\n+    if (fHelp || params.size() != 1)\n+        throw std::runtime_error(\n+                             \"addwallet \\\"walletid\\\"\\n\"\n+                             \"\\nArguments:\\n\"\n+                             \"  \\\"walletid\\\"    (string, required) allowed characters: A-Za-z0-9._-\\n\"\n+                             \"\\nExamples:\\n\"\n+                             + HelpExampleCli(\"addwallet\", \"\\\"anotherwallet\\\"\")\n+                             + HelpExampleRpc(\"addwallet\", \"\\\"anotherwallet\\\"\")\n+                             );\n+    \n+    std::string walletID = params[0].get_str();\n+    CoreWallet::AddNewWallet(walletID);\n+    \n+    return json_spirit::Value::null;\n+}\n+    \n+json_spirit::Value listwallets(const json_spirit::Array& params, bool fHelp)\n+{\n+    if (fHelp || params.size() != 0)\n+        throw std::runtime_error(\n+                                 \"listwallets\\n\"\n+                                 \"\\nResult:\\n\"\n+                                 \"[                     (json array of string)\\n\"\n+                                 \"  \\\"mainWallet\\\"  (string) a wallet identifier\\n\"\n+                                 \"  \\\"anotherWallet\\\"\\n\"\n+                                 \"]\\n\"\n+                                 \"\\nExamples:\\n\"\n+                                 + HelpExampleCli(\"listwallets\", \"\")\n+                                 + HelpExampleRpc(\"listwallets\", \"\")\n+                                 );\n+    \n+    json_spirit::Array ret;\n+    std::vector<std::string> vWalletIDs = CoreWallet::GetWalletIDs();\n+    BOOST_FOREACH(const std::string& walletID, vWalletIDs)\n+    {\n+        ret.push_back(walletID);\n+    }\n+    \n+    return ret;\n+}\n+\n     \n+///////////////////////////\n+// Dispatching/signaling stack\n+///////////////////////////\n void ExecuteRPC(const std::string& strMethod, const json_spirit::Array& params, json_spirit::Value& result, bool& accept)\n {\n     if(strMethod == \"getnewaddress\")\n     {\n         result = getnewaddress(params, false);\n         accept = true;\n     }\n-    else if(strMethod == \"getaddresses\")\n+    else if(strMethod == \"listaddresses\")\n+    {\n+        result = listaddresses(params, false);\n+        accept = true;\n+    }\n+    else if(strMethod == \"addwallet\")\n     {\n-        result = getaddresses(params, false);\n+        result = addwallet(params, false);\n+        accept = true;\n+    }\n+    else if(strMethod == \"listwallets\")\n+    {\n+        result = listwallets(params, false);\n         accept = true;\n     }\n }\n@@ -98,4 +190,5 @@ void AddRPCHelp(std::string& helpString)\n     }\n }\n     \n+\n }; //end namespace\n\\ No newline at end of file"
      },
      {
        "sha": "c765f7d8029316b45ac119d8ffba2c83649ebd87",
        "filename": "src/corewallet/corewallet_wallet.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 18,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f42e8e79f2f3000013836209bc4f02516f676f6d/src/corewallet/corewallet_wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f42e8e79f2f3000013836209bc4f02516f676f6d/src/corewallet/corewallet_wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet_wallet.cpp?ref=f42e8e79f2f3000013836209bc4f02516f676f6d",
        "patch": "@@ -8,8 +8,10 @@\n #include \"base58.h\"\n #include \"timedata.h\"\n #include \"util.h\"\n+\n+namespace CoreWallet {\n     \n-CPubKey CoreWallet::Wallet::GenerateNewKey()\n+CPubKey Wallet::GenerateNewKey()\n {\n     CKey secret;\n     secret.MakeNewKey(true);\n@@ -19,7 +21,7 @@ CPubKey CoreWallet::Wallet::GenerateNewKey()\n     \n     // Create new metadata\n     int64_t nCreationTime = GetTime();\n-    mapKeyMetadata[pubkey.GetID()] = CoreWallet::CKeyMetadata(nCreationTime);\n+    mapKeyMetadata[pubkey.GetID()] = CKeyMetadata(nCreationTime);\n     if (!nTimeFirstKey || nCreationTime < nTimeFirstKey)\n         nTimeFirstKey = nCreationTime;\n     \n@@ -28,20 +30,20 @@ CPubKey CoreWallet::Wallet::GenerateNewKey()\n     return pubkey;\n }\n \n-bool CoreWallet::Wallet::LoadKey(const CKey& key, const CPubKey &pubkey)\n+bool Wallet::LoadKey(const CKey& key, const CPubKey &pubkey)\n {\n     return CCryptoKeyStore::AddKeyPubKey(key, pubkey);\n }\n \n-bool CoreWallet::Wallet::AddKeyPubKey(const CKey& secret, const CPubKey &pubkey)\n+bool Wallet::AddKeyPubKey(const CKey& secret, const CPubKey &pubkey)\n {\n     if (!CCryptoKeyStore::AddKeyPubKey(secret, pubkey))\n         return false;\n     \n     return walletDB->WriteKey(pubkey, secret.GetPrivKey(), mapKeyMetadata[pubkey.GetID()]);\n }\n \n-bool CoreWallet::Wallet::LoadKeyMetadata(const CPubKey &pubkey, const CoreWallet::CKeyMetadata &meta)\n+bool Wallet::LoadKeyMetadata(const CPubKey &pubkey, const CKeyMetadata &meta)\n {\n     if (meta.nCreateTime && (!nTimeFirstKey || meta.nCreateTime < nTimeFirstKey))\n         nTimeFirstKey = meta.nCreateTime;\n@@ -50,17 +52,14 @@ bool CoreWallet::Wallet::LoadKeyMetadata(const CPubKey &pubkey, const CoreWallet\n     return true;\n }\n \n-bool CoreWallet::Wallet::SetAddressBook(const CTxDestination& address, const std::string& strPurpose)\n+bool Wallet::SetAddressBook(const CTxDestination& address, const std::string& strPurpose)\n {\n-    CoreWallet::CAddressBookMetadata metadata;\n-    {\n-        LOCK(cs_coreWallet);\n-        std::map<CTxDestination, CoreWallet::CAddressBookMetadata> ::iterator mi = mapAddressBook.find(address);\n-        if(mi != mapAddressBook.end())\n-        {\n-            metadata = mapAddressBook[address];\n-        }\n-    }\n-    metadata.purpose = strPurpose;\n-    return walletDB->Write(make_pair(std::string(\"keymeta\"), CBitcoinAddress(address).ToString()), metadata);\n-}\n\\ No newline at end of file\n+    LOCK(cs_coreWallet);\n+    std::map<CTxDestination, CAddressBookMetadata> ::iterator mi = mapAddressBook.find(address);\n+    if(mi == mapAddressBook.end())\n+        mapAddressBook[address] = CAddressBookMetadata();\n+    \n+    return walletDB->Write(make_pair(std::string(\"adrmeta\"), CBitcoinAddress(address).ToString()), mapAddressBook[address]);\n+}\n+\n+}; //end namespace\n\\ No newline at end of file"
      },
      {
        "sha": "51825ab8ea1ab061d0157162f41904e35616f5ba",
        "filename": "src/corewallet/corewallet_wallet.h",
        "status": "modified",
        "additions": 10,
        "deletions": 2,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f42e8e79f2f3000013836209bc4f02516f676f6d/src/corewallet/corewallet_wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f42e8e79f2f3000013836209bc4f02516f676f6d/src/corewallet/corewallet_wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet_wallet.h?ref=f42e8e79f2f3000013836209bc4f02516f676f6d",
        "patch": "@@ -18,8 +18,8 @@ namespace CoreWallet {\n class Wallet : public CCryptoKeyStore, public CValidationInterface{\n public:\n     mutable CCriticalSection cs_coreWallet;\n-    std::map<CKeyID, CoreWallet::CKeyMetadata> mapKeyMetadata;\n-    std::map<CTxDestination, CoreWallet::CAddressBookMetadata> mapAddressBook;\n+    std::map<CKeyID, CKeyMetadata> mapKeyMetadata;\n+    std::map<CTxDestination, CAddressBookMetadata> mapAddressBook;\n     int64_t nTimeFirstKey;\n     FileDB *walletDB;\n     \n@@ -53,8 +53,15 @@ class WalletModel\n     std::string strWalletFilename;\n     int64_t nCreateTime; // 0 means unknown\n     \n+    WalletModel()\n+    {\n+        SetNull();\n+    }\n+    \n     WalletModel(const std::string& filenameIn, Wallet *pWalletIn)\n     {\n+        SetNull();\n+        \n         strWalletFilename = filenameIn;\n         pWallet = pWalletIn;\n     }\n@@ -63,6 +70,7 @@ class WalletModel\n     {\n         nVersion = CURRENT_VERSION;\n         nCreateTime = 0;\n+        pWallet = NULL;\n     }\n     \n     ADD_SERIALIZE_METHODS;"
      },
      {
        "sha": "6cce4afa06293d21602d29b767d2335aabcf9167",
        "filename": "src/corewallet/logdb.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f42e8e79f2f3000013836209bc4f02516f676f6d/src/corewallet/logdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f42e8e79f2f3000013836209bc4f02516f676f6d/src/corewallet/logdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/logdb.cpp?ref=f42e8e79f2f3000013836209bc4f02516f676f6d",
        "patch": "@@ -488,7 +488,7 @@ bool CLogDB::Load() {\n     \n     // map to memory\n     bool loadRet = db->Load_();\n-    \n+    loadRet = true;\n     // reset the file to append writing mode \"ab+\"\n     if (loadRet)\n     {"
      }
    ]
  },
  {
    "sha": "288ca00817b4c7f922615ac239a3aaea3e593138",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyODhjYTAwODE3YjRjN2Y5MjI2MTVhYzIzOWEzYWFlYTNlNTkzMTM4",
    "commit": {
      "author": {
        "name": "Jonas Schnelli",
        "email": "jonas.schnelli@include7.ch",
        "date": "2015-04-13T16:50:36Z"
      },
      "committer": {
        "name": "Jonas Schnelli",
        "email": "jonas.schnelli@include7.ch",
        "date": "2015-07-08T14:57:53Z"
      },
      "message": "[corewallet] add very basic bip32 support",
      "tree": {
        "sha": "703c1833d11aa9976a22995200573de393adcbb9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/703c1833d11aa9976a22995200573de393adcbb9"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/288ca00817b4c7f922615ac239a3aaea3e593138",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/288ca00817b4c7f922615ac239a3aaea3e593138",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/288ca00817b4c7f922615ac239a3aaea3e593138",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/288ca00817b4c7f922615ac239a3aaea3e593138/comments",
    "author": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f42e8e79f2f3000013836209bc4f02516f676f6d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f42e8e79f2f3000013836209bc4f02516f676f6d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f42e8e79f2f3000013836209bc4f02516f676f6d"
      }
    ],
    "stats": {
      "total": 555,
      "additions": 487,
      "deletions": 68
    },
    "files": [
      {
        "sha": "226bf7e92ef6f60d6f0f4ecae47fefdc5d962361",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/288ca00817b4c7f922615ac239a3aaea3e593138/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/288ca00817b4c7f922615ac239a3aaea3e593138/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=288ca00817b4c7f922615ac239a3aaea3e593138",
        "patch": "@@ -101,6 +101,7 @@ BITCOIN_CORE_H = \\\n   corewallet/corewallet.h \\\n   corewallet/corewallet_basics.h \\\n   corewallet/corewallet_db.h \\\n+  corewallet/derivingkeystore.h \\\n   corewallet/corewallet_wallet.h \\\n   corewallet/crypter.h \\\n   corewallet/logdb.h \\\n@@ -225,6 +226,7 @@ libbitcoin_corewallet_a_CPPFLAGS = $(BITCOIN_INCLUDES)\n libbitcoin_corewallet_a_SOURCES = \\\n   corewallet/corewallet.cpp \\\n   corewallet/corewallet_db.cpp \\\n+  corewallet/derivingkeystore.cpp \\\n   corewallet/corewallet_rpc.cpp \\\n   corewallet/corewallet_wallet.cpp \\\n   corewallet/crypter.cpp \\"
      },
      {
        "sha": "0d5129be2558598a8b52427ab8c44e57c5f318b3",
        "filename": "src/corewallet/corewallet_basics.h",
        "status": "modified",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/288ca00817b4c7f922615ac239a3aaea3e593138/src/corewallet/corewallet_basics.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/288ca00817b4c7f922615ac239a3aaea3e593138/src/corewallet/corewallet_basics.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet_basics.h?ref=288ca00817b4c7f922615ac239a3aaea3e593138",
        "patch": "@@ -6,6 +6,7 @@\n #ifndef BITCOIN_COREWALLET_COREWALLET_BASICS_H\n #define BITCOIN_COREWALLET_COREWALLET_BASICS_H\n \n+#include \"pubkey.h\"\n #include \"serialize.h\"\n \n #include <stdint.h>\n@@ -52,6 +53,11 @@ namespace CoreWallet\n         std::string label;\n         std::string purpose;\n         \n+        // BIP32 metadata.\n+        CKeyID keyidParent;\n+        uint32_t nDerivationIndex;\n+        int nDepth;\n+        \n         CKeyMetadata()\n         {\n             SetNull();\n@@ -71,12 +77,18 @@ namespace CoreWallet\n             READWRITE(nCreateTime);\n             READWRITE(label);\n             READWRITE(purpose);\n+            READWRITE(keyidParent);\n+            READWRITE(nDerivationIndex);\n+            READWRITE(nDepth);\n         }\n         \n         void SetNull()\n         {\n             nVersion = CKeyMetadata::CURRENT_VERSION;\n             nCreateTime = 0;\n+            keyidParent = CKeyID();\n+            nDerivationIndex = 0;\n+            nDepth = 0;\n         }\n     };\n }; // end namespace CoreWallet"
      },
      {
        "sha": "d7fe1c28dbeef45303b890f1b09209282e481001",
        "filename": "src/corewallet/corewallet_db.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/288ca00817b4c7f922615ac239a3aaea3e593138/src/corewallet/corewallet_db.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/288ca00817b4c7f922615ac239a3aaea3e593138/src/corewallet/corewallet_db.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet_db.cpp?ref=288ca00817b4c7f922615ac239a3aaea3e593138",
        "patch": "@@ -97,6 +97,18 @@ bool ReadKeyValue(Wallet* pCoreWallet, CDataStream& ssKey, CDataStream& ssValue,\n             ssValue >> metadata;\n             pCoreWallet->mapAddressBook[CBitcoinAddress(strAddress).Get()] = metadata;\n         }\n+        else if (strType == \"masterkeyid\")\n+        {\n+            ssValue >> pCoreWallet->masterKeyID;\n+        }\n+        else if (strType == \"bip32intpubkey\")\n+        {\n+            ssValue >> pCoreWallet->internalPubKey.pubkey;\n+        }\n+        else if (strType == \"bip32extpubkey\")\n+        {\n+            ssValue >> pCoreWallet->externalPubKey.pubkey;\n+        }\n     } catch (...)\n     {\n         return false;"
      },
      {
        "sha": "b7146bd7e1f714a3eefb1a3de4634c021f73c75c",
        "filename": "src/corewallet/corewallet_rpc.cpp",
        "status": "modified",
        "additions": 183,
        "deletions": 50,
        "changes": 233,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/288ca00817b4c7f922615ac239a3aaea3e593138/src/corewallet/corewallet_rpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/288ca00817b4c7f922615ac239a3aaea3e593138/src/corewallet/corewallet_rpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet_rpc.cpp?ref=288ca00817b4c7f922615ac239a3aaea3e593138",
        "patch": "@@ -13,25 +13,62 @@\n #include <string>\n \n #include \"json/json_spirit_utils.h\"\n+\n+#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n #include <boost/foreach.hpp>\n \n+namespace CoreWallet\n+{\n+\n+//!rpc help exception\n+class RPCHelpException: public std::exception\n+{\n+public:\n+    explicit RPCHelpException(const std::string& message): msg_(message) {}\n+    virtual ~RPCHelpException() throw (){}\n+    virtual const char* what() const throw (){\n+        return msg_.c_str();\n+    }\n+protected:\n+    std::string msg_;\n+};\n+    \n typedef json_spirit::Value(*rpcfn_type)(const json_spirit::Array& params, bool fHelp);\n \n-namespace CoreWallet\n+struct RPCDispatchEntry\n {\n+    std::string name;\n+    rpcfn_type actor;\n+};\n \n+//dispatch compatible rpc function definitions\n+json_spirit::Value getnewaddress(const json_spirit::Array& params, bool fHelp);\n+json_spirit::Value listaddresses(const json_spirit::Array& params, bool fHelp);\n+json_spirit::Value addwallet(const json_spirit::Array& params, bool fHelp);\n+json_spirit::Value listwallets(const json_spirit::Array& params, bool fHelp);\n+json_spirit::Value help(const json_spirit::Array& params, bool fHelp);\n+    \n+static const RPCDispatchEntry vDispatchEntries[] = {\n+    { \"getnewaddress\",                  &getnewaddress },\n+    { \"listaddresses\",                  &listaddresses },\n+    \n+    // Multiwallet\n+    { \"addwallet\",                      &addwallet },\n+    { \"listwallets\",                    &listwallets },\n+    \n+    // Help / Debug\n+    { \"help\",                           &help },\n+};\n+\n+    \n ///////////////////////////\n // helpers\n ///////////////////////////\n \n+//! try to filter out the desired wallet instance via given params\n Wallet* WalletFromParams(const json_spirit::Array& params)\n {\n-    if (params.size() < 1 || params[0].type() != json_spirit::obj_type)\n-        throw std::runtime_error(\"invalid parameters, always use a json key/value object\");\n     std::string walletID = \"\"; //\"\" stands for default wallet\n-    \n-    const json_spirit::Object& o = params[0].get_obj();\n-    walletID = find_value(o, \"walletid\").get_str();\n     if (params.size() > 0 && params[0].type() == json_spirit::obj_type) //TODO also allow params at index position different the 0\n     {\n         const json_spirit::Object& o = params[0].get_obj();\n@@ -46,13 +83,23 @@ Wallet* WalletFromParams(const json_spirit::Array& params)\n     return wallet;\n }\n \n+//! search in exiting json object for a key/value pair and returns value\n+json_spirit::Value ValueFromParams(const json_spirit::Array& params, const std::string& key)\n+{\n+    if (params.size() < 1 || params[0].type() != json_spirit::obj_type)\n+        throw std::runtime_error(\"invalid parameters, always use a json key/value object\");\n+    \n+    const json_spirit::Object& o = params[0].get_obj();\n+    return find_value(o, key);\n+}\n+    \n ///////////////////////////\n // Keys/Addresses stack\n ///////////////////////////\n json_spirit::Value getnewaddress(const json_spirit::Array& params, bool fHelp)\n {\n     if (fHelp || params.size() != 1)\n-        throw std::runtime_error(\n+        throw RPCHelpException(\n                             \"getnewaddress\\n\"\n                             \"\\nReturns a new Bitcoin address for receiving payments.\\n\"\n                             \"\\nResult:\\n\"\n@@ -64,18 +111,61 @@ json_spirit::Value getnewaddress(const json_spirit::Array& params, bool fHelp)\n     \n \n     Wallet *wallet = WalletFromParams(params);\n-    CPubKey newKey = wallet->GenerateNewKey();\n-    CKeyID keyID = newKey.GetID();\n+    json_spirit::Value value = ValueFromParams(params, \"chainpath\");\n+    json_spirit::Value valueIndex = ValueFromParams(params, \"index\");\n     \n-    wallet->SetAddressBook(keyID, \"receive\");\n+    CKeyID keyID;\n     \n-    return CBitcoinAddress(keyID).ToString();\n+    if(value.is_null())\n+    {\n+        int index = -1;\n+        if (!valueIndex.is_null())\n+            index = atoi(valueIndex.get_str());\n+            \n+        CPubKey newKey = wallet->GenerateNewKey(index);\n+        keyID = newKey.GetID();\n+        wallet->SetAddressBook(keyID, \"receive\");\n+        return CBitcoinAddress(keyID).ToString();\n+    }\n+    else\n+    {\n+        //Bip32\n+        std::string chainpath = value.get_str();\n+        boost::to_lower(chainpath);\n+        \n+        json_spirit::Object obj;\n+        if (chainpath == \"m\")\n+        {\n+            unsigned char vch[32];\n+            json_spirit::Value seedHex = ValueFromParams(params, \"seed\");\n+            bool useSeed = false;\n+            if (!seedHex.is_null())\n+            {\n+                std::vector<unsigned char> result = ParseHex(seedHex.get_str());\n+                memcpy((void *)&vch,(const void *)&result.front(),32);\n+                useSeed = true;\n+            }\n+            \n+            CPubKey newKey = wallet->GenerateBip32Structure(\"m/44'/0'/0'/\", vch, useSeed);\n+            if (!useSeed)\n+                obj.push_back(json_spirit::Pair(\"seed\", HexStr(vch, vch+sizeof(vch))));\n+        }\n+        else\n+        {\n+//            CPubKey newKey = wallet->GenerateBip32Structure(vch, useSeed);\n+//            keyID = newKey.GetID();\n+//            wallet->SetAddressBook(keyID, \"receive\");\n+//            obj.push_back(json_spirit::Pair(\"address\", CBitcoinAddress(keyID).ToString()));\n+        }\n+            \n+        return obj;\n+    }\n }\n     \n json_spirit::Value listaddresses(const json_spirit::Array& params, bool fHelp)\n {\n-    if (fHelp || params.size() != 1)\n-        throw std::runtime_error(\n+    if (fHelp)\n+        throw RPCHelpException(\n                             \"listaddresses\\n\"\n                             \"\\nResult:\\n\"\n                             \"[                     (json array of string)\\n\"\n@@ -88,11 +178,23 @@ json_spirit::Value listaddresses(const json_spirit::Array& params, bool fHelp)\n                             );\n     Wallet *wallet = WalletFromParams(params);\n     json_spirit::Array ret;\n-    BOOST_FOREACH(const PAIRTYPE(CBitcoinAddress, CoreWallet::CAddressBookMetadata)& item, wallet->mapAddressBook)\n+    BOOST_FOREACH(const PAIRTYPE(CBitcoinAddress, CAddressBookMetadata)& item, wallet->mapAddressBook)\n     {\n         const CBitcoinAddress& address = item.first;\n-        ret.push_back(address.ToString());\n+        const CAddressBookMetadata& metadata = item.second;\n+        json_spirit::Object obj;\n+        obj.push_back(json_spirit::Pair(address.ToString(), metadata.purpose));\n+        ret.push_back(obj);\n     }\n+    \n+    CKeyID masterKeyID = wallet->masterKeyID;\n+    if (!masterKeyID.IsNull())\n+    {\n+        json_spirit::Object obj;\n+        obj.push_back(json_spirit::Pair(CBitcoinAddress(masterKeyID).ToString(), \"masterkey\"));\n+        ret.push_back(obj);\n+    }\n+    \n     return ret;\n }\n \n@@ -104,7 +206,7 @@ json_spirit::Value listaddresses(const json_spirit::Array& params, bool fHelp)\n json_spirit::Value addwallet(const json_spirit::Array& params, bool fHelp)\n {\n     if (fHelp || params.size() != 1)\n-        throw std::runtime_error(\n+        throw RPCHelpException(\n                              \"addwallet \\\"walletid\\\"\\n\"\n                              \"\\nArguments:\\n\"\n                              \"  \\\"walletid\\\"    (string, required) allowed characters: A-Za-z0-9._-\\n\"\n@@ -122,7 +224,7 @@ json_spirit::Value addwallet(const json_spirit::Array& params, bool fHelp)\n json_spirit::Value listwallets(const json_spirit::Array& params, bool fHelp)\n {\n     if (fHelp || params.size() != 0)\n-        throw std::runtime_error(\n+        throw RPCHelpException(\n                                  \"listwallets\\n\"\n                                  \"\\nResult:\\n\"\n                                  \"[                     (json array of string)\\n\"\n@@ -144,50 +246,81 @@ json_spirit::Value listwallets(const json_spirit::Array& params, bool fHelp)\n     return ret;\n }\n \n+///////////////////////////\n+// Help stack\n+///////////////////////////\n+json_spirit::Value help(const json_spirit::Array& params, bool fHelp)\n+{\n+    if (fHelp || params.size() != 1)\n+        throw RPCHelpException(\n+                            \"help ( \\\"command\\\" )\\n\"\n+                            \"\\nList all commands, or get help for a specified command.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"command\\\"     (string, optional) The command to get help on\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"\\\"text\\\"     (string) The help text\\n\"\n+                            );\n+    \n+    std::string helpString = \"\\n== CoreWallet ==\\n\";\n+    json_spirit::Value value = ValueFromParams(params, \"command\");\n+    \n+    unsigned int i;\n+    for (i = 0; i < (sizeof(vDispatchEntries) / sizeof(vDispatchEntries[0])); i++)\n+    {\n+        try {\n+            json_spirit::Array params;\n+            vDispatchEntries[i].actor(params, true);\n+        } catch (const RPCHelpException& e)\n+        {\n+            // Help text is returned in an exception\n+            std::string strHelp = std::string(e.what());\n+            if (!value.is_null() && value.get_str() == vDispatchEntries[i].name)\n+            {\n+                //shortcut if uses likes help of a single command\n+                helpString = strHelp;\n+                return helpString;\n+            }\n+            \n+            if (strHelp.find('\\n') != std::string::npos)\n+                strHelp = strHelp.substr(0, strHelp.find('\\n'));\n+               \n+            helpString+=strHelp+\"\\n\";\n+        }\n+    }\n+    \n+    return helpString;\n+}\n     \n ///////////////////////////\n // Dispatching/signaling stack\n ///////////////////////////\n+    \n+//! search for command in dispatch table and executes\n void ExecuteRPC(const std::string& strMethod, const json_spirit::Array& params, json_spirit::Value& result, bool& accept)\n {\n-    if(strMethod == \"getnewaddress\")\n-    {\n-        result = getnewaddress(params, false);\n-        accept = true;\n-    }\n-    else if(strMethod == \"listaddresses\")\n-    {\n-        result = listaddresses(params, false);\n-        accept = true;\n-    }\n-    else if(strMethod == \"addwallet\")\n-    {\n-        result = addwallet(params, false);\n-        accept = true;\n-    }\n-    else if(strMethod == \"listwallets\")\n+    unsigned int i;\n+    for (i = 0; i < (sizeof(vDispatchEntries) / sizeof(vDispatchEntries[0])); i++)\n     {\n-        result = listwallets(params, false);\n-        accept = true;\n+        if(vDispatchEntries[i].name == strMethod)\n+        {\n+            try\n+            {\n+                result = vDispatchEntries[i].actor(params, false);\n+            }\n+            catch (const RPCHelpException& e)\n+            {\n+                throw JSONRPCError(RPC_MISC_ERROR, e.what());\n+            }\n+            \n+            accept = true;\n+        }\n     }\n }\n-    \n+\n+//! Create helpstring by catching \"help\"-exceptions over dispatching table.\n void AddRPCHelp(std::string& helpString)\n {\n-    helpString += \"\\n== CoreWallet ==\\n\";\n-    try {\n-        json_spirit::Array params;\n-        getnewaddress(params, true);\n-    } catch (const std::exception& e)\n-    {\n-        // Help text is returned in an exception\n-        std::string strHelp = std::string(e.what());\n-        if (strHelp.find('\\n') != std::string::npos)\n-            strHelp = strHelp.substr(0, strHelp.find('\\n'));\n-        \n-        helpString+=strHelp;\n-        \n-    }\n+    \n }\n     \n "
      },
      {
        "sha": "56c944268113c0d032849affe415be782905a803",
        "filename": "src/corewallet/corewallet_wallet.cpp",
        "status": "modified",
        "additions": 132,
        "deletions": 12,
        "changes": 144,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/288ca00817b4c7f922615ac239a3aaea3e593138/src/corewallet/corewallet_wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/288ca00817b4c7f922615ac239a3aaea3e593138/src/corewallet/corewallet_wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet_wallet.cpp?ref=288ca00817b4c7f922615ac239a3aaea3e593138",
        "patch": "@@ -6,28 +6,146 @@\n #include \"corewallet/corewallet_wallet.h\"\n \n #include \"base58.h\"\n+#include \"eccryptoverify.h\"\n+#include \"random.h\"\n #include \"timedata.h\"\n #include \"util.h\"\n+#include \"utilstrencodings.h\"\n+\n+#include <boost/algorithm/string.hpp>\n+#include <boost/foreach.hpp>\n \n namespace CoreWallet {\n+  \n+CPubKey Wallet::GenerateBip32Structure(const std::string& chainPathIn, unsigned char (&vch)[32], bool useSeed)\n+{\n+    //currently seed size is fixed to 256bit\n+    if (!useSeed)\n+    {\n+        RandAddSeedPerfmon();\n+        do {\n+            GetRandBytes(vch, sizeof(vch));\n+        } while (!eccrypto::Check(vch));\n+    }\n+    else\n+    {\n+        LogPrintf(\"using given seed with first 4 chars: %s\", HexStr(vch, vch+4));\n+    }\n+    CExtKey Bip32MasterKey;\n+    CExtPubKey extPubkey;\n+    Bip32MasterKey.SetMaster(vch, sizeof(vch));\n+    \n+    CBitcoinExtKey b58key;\n+    b58key.SetKey(Bip32MasterKey);\n+    LogPrintf(\"key: %s\", b58key.ToString());\n+    \n+    \n+    extPubkey = Bip32MasterKey.Neuter();\n     \n-CPubKey Wallet::GenerateNewKey()\n+    masterKeyID = extPubkey.pubkey.GetID();\n+    \n+    int64_t nCreationTime = GetTime();\n+    CKeyMetadata meta(nCreationTime);\n+    mapKeyMetadata[masterKeyID] = meta;\n+    walletDB->Write(std::make_pair(std::string(\"keymeta\"), extPubkey.pubkey), meta, false);\n+    \n+//    if (!AddKeyPubKey(Bip32MasterKey.key, extPubkey.pubkey))\n+//        throw std::runtime_error(\"CWallet::GenerateNewKey(): AddKey failed\");\n+\n+    if (!walletDB->Write(std::string(\"masterseed\"), HexStr(vch, vch+sizeof(vch)), true)) //for easy serialization store the unsigned char[32] as hex string. //TODO: use 32byte binary ser.\n+        throw std::runtime_error(\"CWallet::GenerateBip32Structure(): Writing masterkeyid failed!\");\n+\n+    //take the given chainpath and extend it with /0 for external keys and /1 for internal\n+    //example: input chainpath \"m/44'/0'/0'/\" will result in m/44'/0'/0'/0/<nChild> for external and m/44'/0'/0'/1/<nChild> for internal keypair generation\n+    //disk cache the internal and external parent pubkey for faster pubkey generation\n+    std::string chainPath = chainPathIn;\n+    boost::to_lower(chainPath);\n+    boost::erase_all(chainPath, \" \");\n+    if (chainPath.size() > 0 && chainPath.back() == '/')\n+        chainPath.resize(chainPath.size() - 1);\n+    \n+    std::vector<std::string> pathFragments;\n+    boost::split(pathFragments, chainPath, boost::is_any_of(\"/\"));\n+    \n+    \n+    CExtKey parentKey = Bip32MasterKey;\n+    \n+    BOOST_FOREACH(std::string fragment, pathFragments)\n+    {\n+        if (fragment == \"m\") //todo, implement optional creation of masterkey and possibility for wallets with ext childkeys on the top\n+            continue;\n+        \n+        CExtKey childKey;\n+        \n+        bool harden = false;\n+        if (fragment.back() == '\\'')\n+            harden = true;\n+        \n+        int nIndex = atoi(fragment.c_str());\n+        parentKey.Derive(childKey, (harden ? 0x80000000 : 0)+nIndex);\n+        \n+        if(pathFragments.back() == fragment)\n+        {\n+            // last fragment\n+            CExtKey internalKey;\n+            CExtKey externalKey;\n+            childKey.Derive(internalKey, 1);\n+            childKey.Derive(externalKey, 0);\n+            \n+            internalPubKey = internalKey.Neuter();\n+            externalPubKey = externalKey.Neuter();\n+            walletDB->Write(std::string(\"bip32intpubkey\"), internalPubKey.pubkey, true);\n+            walletDB->Write(std::string(\"bip32extpubkey\"), externalPubKey.pubkey, true);\n+            \n+            CExtPubKey childPubKey = childKey.Neuter();\n+            int64_t nCreationTime = GetTime();\n+            \n+            CKeyMetadata metaInternal(nCreationTime);\n+            metaInternal.keyidParent = childPubKey.pubkey.GetID();\n+            metaInternal.nDepth = internalPubKey.nDepth;\n+            metaInternal.nDerivationIndex = internalPubKey.nChild;\n+            mapKeyMetadata[internalPubKey.pubkey.GetID()] = metaInternal;\n+            \n+            CKeyMetadata metaExternal(nCreationTime);\n+            metaExternal.keyidParent = childPubKey.pubkey.GetID();\n+            metaExternal.nDepth = internalPubKey.nDepth;\n+            metaExternal.nDerivationIndex = internalPubKey.nChild;\n+            mapKeyMetadata[externalPubKey.pubkey.GetID()] = metaExternal;\n+        }\n+        \n+        parentKey = childKey;\n+    }\n+    \n+//    AddKey(extKey.key);\n+//    AddMeta(keyid, CKeyID(), 0, extKey.chaincode, 0);\n+//    \n+//    if (!walletDB->Write(std::make_pair(std::string(\"keymeta\"), extPubkey.pubkey), mapKeyMetadata[extPubkey.pubkey.GetID()], true))\n+//        throw std::runtime_error(\"CWallet::GenerateBip32Structure(): Writing metadata failed!\");\n+//    \n+//    if (!walletDB->Write(std::make_pair(std::string(\"extpubkey\"), extPubkey.pubkey), extPubkey.pubkey, true))\n+//        throw std::runtime_error(\"CWallet::GenerateBip32Structure(): Writing pubkey failed!\");\n+//    \n+    return extPubkey.pubkey;\n+}\n+    \n+CPubKey Wallet::GenerateNewKey(int indexIn)\n {\n-    CKey secret;\n-    secret.MakeNewKey(true);\n+    unsigned int useIndex = 0;\n+    if (index >= 0)\n+        useIndex = indexIn;\n     \n-    CPubKey pubkey = secret.GetPubKey();\n-    assert(secret.VerifyPubKey(pubkey));\n+    CExtPubKey newExtPubKey;\n+    internalPubKey.Derive(newExtPubKey, useIndex);\n     \n-    // Create new metadata\n     int64_t nCreationTime = GetTime();\n-    mapKeyMetadata[pubkey.GetID()] = CKeyMetadata(nCreationTime);\n-    if (!nTimeFirstKey || nCreationTime < nTimeFirstKey)\n-        nTimeFirstKey = nCreationTime;\n     \n-    if (!AddKeyPubKey(secret, pubkey))\n-        throw std::runtime_error(\"CWallet::GenerateNewKey(): AddKey failed\");\n-    return pubkey;\n+    CKeyMetadata meta(nCreationTime);\n+    meta.keyidParent = internalPubKey.pubkey.GetID();\n+    meta.nDepth = newExtPubKey.nDepth;\n+    meta.nDerivationIndex = newExtPubKey.nChild;\n+    mapKeyMetadata[newExtPubKey.pubkey.GetID()] = meta;\n+    \n+    return newExtPubKey.pubkey;\n }\n \n bool Wallet::LoadKey(const CKey& key, const CPubKey &pubkey)\n@@ -59,6 +177,8 @@ bool Wallet::SetAddressBook(const CTxDestination& address, const std::string& st\n     if(mi == mapAddressBook.end())\n         mapAddressBook[address] = CAddressBookMetadata();\n     \n+    mapAddressBook[address].purpose = strPurpose;\n+    \n     return walletDB->Write(make_pair(std::string(\"adrmeta\"), CBitcoinAddress(address).ToString()), mapAddressBook[address]);\n }\n "
      },
      {
        "sha": "6bc1b9ac9deb7f7debf5aa0197b5246d18b5431e",
        "filename": "src/corewallet/corewallet_wallet.h",
        "status": "modified",
        "additions": 8,
        "deletions": 5,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/288ca00817b4c7f922615ac239a3aaea3e593138/src/corewallet/corewallet_wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/288ca00817b4c7f922615ac239a3aaea3e593138/src/corewallet/corewallet_wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet_wallet.h?ref=288ca00817b4c7f922615ac239a3aaea3e593138",
        "patch": "@@ -30,15 +30,18 @@ class Wallet : public CCryptoKeyStore, public CValidationInterface{\n         walletDB->LoadWallet(this);\n     }\n     \n-    /**\n-     * keystore implementation\n-     * Generate a new key\n-     */\n-    CPubKey GenerateNewKey();\n+    CPubKey GenerateBip32Structure(const std::string& chainpath, unsigned char (&vchOut)[32], bool useSeed=false);\n+    CPubKey GenerateNewKey(int index=-1);\n     bool AddKeyPubKey(const CKey& key, const CPubKey &pubkey);\n     bool LoadKeyMetadata(const CPubKey &pubkey, const CoreWallet::CKeyMetadata &metadata);\n     bool LoadKey(const CKey& key, const CPubKey &pubkey);\n     bool SetAddressBook(const CTxDestination& address, const std::string& purpose);\n+    \n+    CKeyID masterKeyID;\n+    CExtPubKey internalPubKey;\n+    CExtPubKey externalPubKey;\n+    unsigned char masterSeed[32];\n+    std::string strChainPath;\n };\n \n // WalletModel: a wallet metadata class"
      },
      {
        "sha": "be4ac02e81ddc7e6d5490b7cd66b499851896195",
        "filename": "src/corewallet/crypter.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/288ca00817b4c7f922615ac239a3aaea3e593138/src/corewallet/crypter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/288ca00817b4c7f922615ac239a3aaea3e593138/src/corewallet/crypter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/crypter.h?ref=288ca00817b4c7f922615ac239a3aaea3e593138",
        "patch": "@@ -6,6 +6,7 @@\n #define BITCOIN_WALLET_CRYPTER_H\n \n #include \"keystore.h\"\n+#include \"corewallet/derivingkeystore.h\"\n #include \"serialize.h\"\n #include \"support/allocators/secure.h\"\n \n@@ -111,7 +112,7 @@ class CCrypter\n /** Keystore which keeps the private keys encrypted.\n  * It derives from the basic key store, which is used if no encryption is active.\n  */\n-class CCryptoKeyStore : public CBasicKeyStore\n+class CCryptoKeyStore : public CDerivingKeyStore\n {\n private:\n     CryptedKeyMap mapCryptedKeys;"
      },
      {
        "sha": "9ecbac4b95505bba10fc84245ae9c317b5193ab3",
        "filename": "src/corewallet/derivingkeystore.cpp",
        "status": "added",
        "additions": 105,
        "deletions": 0,
        "changes": 105,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/288ca00817b4c7f922615ac239a3aaea3e593138/src/corewallet/derivingkeystore.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/288ca00817b4c7f922615ac239a3aaea3e593138/src/corewallet/derivingkeystore.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/derivingkeystore.cpp?ref=288ca00817b4c7f922615ac239a3aaea3e593138",
        "patch": "@@ -0,0 +1,105 @@\n+// Copyright (c) 2009-2013 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"corewallet/derivingkeystore.h\"\n+\n+namespace CoreWallet {\n+    \n+bool CDerivingKeyStore::AddMeta(const CKeyID &key, const CKeyID &keyParent, uint32_t nIndex, const ChainCode &chaincode, int nDepth)\n+{\n+    LOCK(cs_KeyStore);\n+    if (!keyParent.IsNull() || !chaincode.IsNull()) {\n+        // This is a deterministic key.\n+        mapDerivation[key].first = keyParent;\n+        mapDerivation[key].second = nIndex;\n+    }\n+    if (!chaincode.IsNull()) {\n+        mapChainCode[key].first = chaincode;\n+        mapChainCode[key].second = nDepth;\n+    }\n+    return true;\n+}\n+\n+bool CDerivingKeyStore::GetExtKey(const CKeyID &keyid, CExtKey& key) const\n+{\n+    CKey keyJust;\n+    ChainCodeMap::const_iterator itCC = mapChainCode.find(keyid);\n+    if (itCC != mapChainCode.end() && CBasicKeyStore::GetKey(keyid, keyJust)) {\n+        key.key = keyJust;\n+        key.chaincode = itCC->second.first;\n+        key.nDepth = itCC->second.second;\n+        DerivationMap::const_iterator itDer = mapDerivation.find(keyid);\n+        memcpy(key.vchFingerprint, &itDer->second.first, 4);\n+        key.nChild = itDer->second.second;\n+        return true;\n+    }\n+    \n+    CExtKey keyParent;\n+    DerivationMap::const_iterator itDer = mapDerivation.find(keyid);\n+    if (itDer != mapDerivation.end() && GetExtKey(itDer->second.first, keyParent)) {\n+        return keyParent.Derive(key, itDer->second.second);\n+    }\n+    \n+    return false;\n+}\n+\n+bool CDerivingKeyStore::GetExtPubKey(const CKeyID &keyid, CExtPubKey& key) const\n+{\n+    CPubKey keyJust;\n+    ChainCodeMap::const_iterator itCC = mapChainCode.find(keyid);\n+    if (itCC != mapChainCode.end() && CBasicKeyStore::GetPubKey(keyid, keyJust)) {\n+        key.pubkey = keyJust;\n+        key.chaincode = itCC->second.first;\n+        key.nDepth = itCC->second.second;\n+        DerivationMap::const_iterator itDer = mapDerivation.find(keyid);\n+        memcpy(key.vchFingerprint, &itDer->second.first, 4);\n+        key.nChild = itDer->second.second;\n+        return true;\n+    }\n+    \n+    CExtPubKey keyParent;\n+    DerivationMap::const_iterator itDer = mapDerivation.find(keyid);\n+    if (itDer != mapDerivation.end() && GetExtPubKey(itDer->second.first, keyParent)) {\n+        return keyParent.Derive(key, itDer->second.second);\n+    }\n+    \n+    return false;\n+}\n+\n+bool CDerivingKeyStore::HaveKey(const CKeyID &key) const\n+{\n+    return (CBasicKeyStore::HaveKey(key) || mapDerivation.count(key) != 0);\n+}\n+\n+bool CDerivingKeyStore::GetKey(const CKeyID &key, CKey &keyOut) const\n+{\n+    if (CBasicKeyStore::GetKey(key, keyOut))\n+        return true;\n+    CExtKey extkey;\n+    if (GetExtKey(key, extkey)) {\n+        keyOut = extkey.key;\n+        return true;\n+    }\n+    return false;\n+}\n+\n+bool CDerivingKeyStore::GetPubKey(const CKeyID &key, CPubKey &keyOut) const\n+{\n+    if (CBasicKeyStore::GetPubKey(key, keyOut))\n+        return true;\n+    CExtPubKey extkey;\n+    if (GetExtPubKey(key, extkey)) {\n+        keyOut = extkey.pubkey;\n+        return true;\n+    }\n+    return false;\n+}\n+\n+void CDerivingKeyStore::GetKeys(std::set<CKeyID> &setKeys) const\n+{\n+    CBasicKeyStore::GetKeys(setKeys);\n+    for (DerivationMap::const_iterator it = mapDerivation.begin(); it != mapDerivation.end(); it++)\n+        setKeys.insert(it->first);\n+}\n+}; //end namespace\n\\ No newline at end of file"
      },
      {
        "sha": "573fb610a4c3bb051f50bf1d40df3b7562010f12",
        "filename": "src/corewallet/derivingkeystore.h",
        "status": "added",
        "additions": 31,
        "deletions": 0,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/288ca00817b4c7f922615ac239a3aaea3e593138/src/corewallet/derivingkeystore.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/288ca00817b4c7f922615ac239a3aaea3e593138/src/corewallet/derivingkeystore.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/derivingkeystore.h?ref=288ca00817b4c7f922615ac239a3aaea3e593138",
        "patch": "@@ -0,0 +1,31 @@\n+// Copyright (c) 2009-2014 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_COREWALLET_DERIVINGKEYSTORE_H\n+#define BITCOIN_COREWALLET_DERIVINGKEYSTORE_H\n+\n+#include \"keystore.h\"\n+\n+namespace CoreWallet {\n+typedef std::map<CKeyID, std::pair<ChainCode, int> > ChainCodeMap;\n+typedef std::map<CKeyID, std::pair<CKeyID, uint32_t> > DerivationMap;\n+    \n+class CDerivingKeyStore : public CBasicKeyStore {\n+protected:\n+    DerivationMap mapDerivation;\n+    ChainCodeMap mapChainCode;\n+\n+public:\n+    virtual bool GetExtKey(const CKeyID &keyid, CExtKey& key) const;\n+    virtual bool GetExtPubKey(const CKeyID &keyid, CExtPubKey& key) const;\n+\n+    virtual bool AddMeta(const CKeyID &key, const CKeyID &keyParent, uint32_t nIndex, const ChainCode &chaincode = ChainCode(), int nDepth = 0);\n+\n+    virtual bool HaveKey(const CKeyID &key) const;\n+    virtual bool GetKey(const CKeyID &key, CKey &keyOut) const;\n+    virtual bool GetPubKey(const CKeyID &key, CPubKey &keyOut) const;\n+    virtual void GetKeys(std::set<CKeyID> &setKeys) const;\n+};\n+}\n+#endif // BITCOIN_COREWALLET_DERIVINGKEYSTORE_H\n\\ No newline at end of file"
      }
    ]
  },
  {
    "sha": "0b8ef46baa555a6bf6d6366b1da61a7ba7e39042",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowYjhlZjQ2YmFhNTU1YTZiZjZkNjM2NmIxZGE2MWE3YmE3ZTM5MDQy",
    "commit": {
      "author": {
        "name": "Jonas Schnelli",
        "email": "jonas.schnelli@include7.ch",
        "date": "2015-05-04T18:39:58Z"
      },
      "committer": {
        "name": "Jonas Schnelli",
        "email": "jonas.schnelli@include7.ch",
        "date": "2015-07-08T14:57:53Z"
      },
      "message": "[corewallet] remove most of the global corewallet functions, add wallet manager signeton\n\n- this is required to have a clean CValidationInterface listener who can support multiple wallets",
      "tree": {
        "sha": "b0b346cb0976177c3c0ef6912a80a1ceb19eb357",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b0b346cb0976177c3c0ef6912a80a1ceb19eb357"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0b8ef46baa555a6bf6d6366b1da61a7ba7e39042",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0b8ef46baa555a6bf6d6366b1da61a7ba7e39042",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0b8ef46baa555a6bf6d6366b1da61a7ba7e39042",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0b8ef46baa555a6bf6d6366b1da61a7ba7e39042/comments",
    "author": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "288ca00817b4c7f922615ac239a3aaea3e593138",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/288ca00817b4c7f922615ac239a3aaea3e593138",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/288ca00817b4c7f922615ac239a3aaea3e593138"
      }
    ],
    "stats": {
      "total": 149,
      "additions": 93,
      "deletions": 56
    },
    "files": [
      {
        "sha": "9d55a67a504c0f6947e6750dee17e5bba27e35f9",
        "filename": "src/corewallet/corewallet.cpp",
        "status": "modified",
        "additions": 71,
        "deletions": 48,
        "changes": 119,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0b8ef46baa555a6bf6d6366b1da61a7ba7e39042/src/corewallet/corewallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0b8ef46baa555a6bf6d6366b1da61a7ba7e39042/src/corewallet/corewallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet.cpp?ref=0b8ef46baa555a6bf6d6366b1da61a7ba7e39042",
        "patch": "@@ -17,41 +17,23 @@\n \n namespace CoreWallet {\n \n-const static std::string DEFAULT_WALLET_FILE = \"wallet.wal\";\n const static std::string DEFAULT_WALLETS_METADATA_FILE = \"multiwallet.dat\";\n-static std::map<std::string, WalletModel> mapWallets;\n-static FileDB *walletsListDB;\n-    \n+static Manager *managerSharedInstance;\n+\n //implemented in corewallet_rpc.cpp\n extern void ExecuteRPC(const std::string& strMethod, const json_spirit::Array& params, json_spirit::Value& result, bool& accept);\n \n \n-std::vector<std::string> GetWalletIDs()\n-{\n-    std::vector<std::string> vIDs;\n-    std::pair<std::string, WalletModel> walletAndMetadata; // what a map<int, int> is made of\n-    BOOST_FOREACH(walletAndMetadata, mapWallets) {\n-        vIDs.push_back(walletAndMetadata.first);\n-    }\n-    return vIDs;\n-}\n-    \n-CoreWallet::Wallet* GetWalletWithID(const std::string& walletIDIn)\n+bool CheckFilenameString(const std::string& str)\n {\n-    std::string walletID = walletIDIn;\n-    \n-    if (walletID == \"\" && mapWallets.size() == 1)\n-        walletID = mapWallets.begin()->first;\n-    \n-    if (mapWallets.find(walletID) != mapWallets.end())\n+    static std::string safeChars(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890._-\");\n+    std::string strResult;\n+    for (std::string::size_type i = 0; i < str.size(); i++)\n     {\n-        if (!mapWallets[walletID].pWallet) //is it closed?\n-            mapWallets[walletID].pWallet = new Wallet(walletID);\n-        \n-        return mapWallets[walletID].pWallet;\n+        if (safeChars.find(str[i]) == std::string::npos)\n+            return false;\n     }\n-    \n-    return NULL;\n+    return true;\n }\n     \n void AppendHelpMessageString(std::string& strUsage, bool debugHelp)\n@@ -62,8 +44,13 @@ void AppendHelpMessageString(std::string& strUsage, bool debugHelp)\n     strUsage += HelpMessageGroup(_(\"CoreWallet options:\"));\n     strUsage += HelpMessageOpt(\"-disablecorewallet\", _(\"Do not load the wallet and disable wallet RPC calls\"));\n }\n-    \n-void readWalletLists()\n+\n+Manager::Manager()\n+{\n+    ReadWalletLists();\n+}\n+\n+void Manager::ReadWalletLists()\n {\n     CAutoFile multiwalletFile(fopen((GetDataDir() / DEFAULT_WALLETS_METADATA_FILE).string().c_str(), \"rb\"), SER_DISK, CLIENT_VERSION);\n     if (!multiwalletFile.IsNull())\n@@ -76,7 +63,7 @@ void readWalletLists()\n     }\n }\n \n-void writeWalletList()\n+void Manager::WriteWalletList()\n {\n     CAutoFile multiwalletFile(fopen((GetDataDir() / DEFAULT_WALLETS_METADATA_FILE).string().c_str(), \"wb\"), SER_DISK, CLIENT_VERSION);\n     if (!multiwalletFile.IsNull())\n@@ -85,22 +72,10 @@ void writeWalletList()\n \n void LoadAsModule(std::string& warningString, std::string& errorString, bool& stopInit)\n {\n-    readWalletLists();\n-}\n-    \n-bool CheckFilenameString(const std::string& str)\n-{\n-    static std::string safeChars(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890._-\");\n-    std::string strResult;\n-    for (std::string::size_type i = 0; i < str.size(); i++)\n-    {\n-        if (safeChars.find(str[i]) == std::string::npos)\n-            return false;\n-    }\n-    return true;\n+    GetManager();\n }\n-    \n-void AddNewWallet(const std::string& walletID)\n+\n+void Manager::AddNewWallet(const std::string& walletID)\n {\n     if (mapWallets.find(walletID) != mapWallets.end())\n         throw std::runtime_error(_(\"walletid already exists\"));\n@@ -111,13 +86,45 @@ void AddNewWallet(const std::string& walletID)\n     Wallet *newWallet = new Wallet(walletID);\n     mapWallets[walletID] = WalletModel(walletID, newWallet);\n     \n-    writeWalletList();\n+    WriteWalletList();\n+}\n+\n+Wallet* Manager::GetWalletWithID(const std::string& walletIDIn)\n+{\n+    std::string walletID = walletIDIn;\n+\n+    if (walletID == \"\" && mapWallets.size() == 1)\n+        walletID = mapWallets.begin()->first;\n+\n+    if (mapWallets.find(walletID) != mapWallets.end())\n+    {\n+        if (!mapWallets[walletID].pWallet) //is it closed?\n+            mapWallets[walletID].pWallet = new Wallet(walletID);\n+\n+        return mapWallets[walletID].pWallet;\n+    }\n+    \n+    return NULL;\n+}\n+\n+std::vector<std::string> Manager::GetWalletIDs()\n+{\n+    std::vector<std::string> vIDs;\n+    std::pair<std::string, WalletModel> walletAndMetadata; // what a map<int, int> is made of\n+    BOOST_FOREACH(walletAndMetadata, mapWallets) {\n+        vIDs.push_back(walletAndMetadata.first);\n+    }\n+    return vIDs;\n }\n \n void Dealloc()\n {\n-    delete walletsListDB;\n-    walletsListDB = NULL;\n+    if (managerSharedInstance)\n+    {\n+        UnregisterValidationInterface(managerSharedInstance);\n+        delete managerSharedInstance;\n+        managerSharedInstance = NULL;\n+    }\n }\n     \n void RegisterSignals()\n@@ -136,4 +143,20 @@ void UnregisterSignals()\n     GetMainSignals().CreateHelpString.disconnect(boost::bind(&AppendHelpMessageString, _1, _2));\n     GetMainSignals().LoadModules.disconnect(boost::bind(&LoadAsModule, _1, _2, _3));\n }\n+\n+Manager* GetManager()\n+{\n+    if (!managerSharedInstance)\n+    {\n+        managerSharedInstance = new Manager();\n+        RegisterValidationInterface(managerSharedInstance);\n+    }\n+    return managerSharedInstance;\n+}\n+\n+void Manager::SyncTransaction(const CTransaction& tx, const CBlock* pblock)\n+{\n+\n+}\n+\n };\n\\ No newline at end of file"
      },
      {
        "sha": "f855bb38af26dc8b33a0c13c49183ec796ac4158",
        "filename": "src/corewallet/corewallet.h",
        "status": "modified",
        "additions": 18,
        "deletions": 4,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0b8ef46baa555a6bf6d6366b1da61a7ba7e39042/src/corewallet/corewallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0b8ef46baa555a6bf6d6366b1da61a7ba7e39042/src/corewallet/corewallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet.h?ref=0b8ef46baa555a6bf6d6366b1da61a7ba7e39042",
        "patch": "@@ -7,14 +7,28 @@\n #define BITCOIN_COREWALLT_COREWALLET_H\n \n #include \"corewallet/corewallet_wallet.h\"\n+#include \"validationinterface.h\"\n+\n \n namespace CoreWallet {\n+    class Manager : public CValidationInterface\n+    {\n+    public:\n+        Manager();\n+        ~Manager() { }\n+        Wallet* GetWalletWithID(const std::string& walletIDIn);\n+        std::vector<std::string> GetWalletIDs();\n+        void AddNewWallet(const std::string& walletID);\n+        void SyncTransaction(const CTransaction& tx, const CBlock* pblock);\n+    protected:\n+        std::map<std::string, WalletModel> mapWallets;\n+        void WriteWalletList();\n+        void ReadWalletLists();\n+    };\n+\n     void RegisterSignals();\n     void UnregisterSignals();\n-    \n-    std::vector<std::string> GetWalletIDs();\n-    Wallet* GetWalletWithID(const std::string& walletID = \"\");\n-    void AddNewWallet(const std::string& walletID);\n+    Manager* GetManager();\n };\n \n #endif // BITCOIN_COREWALLT_COREWALLET_H"
      },
      {
        "sha": "85ed5682669742a7ce1db54422cae566c63b90ba",
        "filename": "src/corewallet/corewallet_rpc.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0b8ef46baa555a6bf6d6366b1da61a7ba7e39042/src/corewallet/corewallet_rpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0b8ef46baa555a6bf6d6366b1da61a7ba7e39042/src/corewallet/corewallet_rpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet_rpc.cpp?ref=0b8ef46baa555a6bf6d6366b1da61a7ba7e39042",
        "patch": "@@ -76,7 +76,7 @@ Wallet* WalletFromParams(const json_spirit::Array& params)\n         if (!possibleValue.is_null())\n             walletID = possibleValue.get_str();\n     }\n-    Wallet* wallet = CoreWallet::GetWalletWithID(walletID);\n+    Wallet* wallet = CoreWallet::GetManager()->GetWalletWithID(walletID);\n     if (!wallet)\n         throw std::runtime_error(\"Wallet (\"+SanitizeString(walletID)+\") not found\");\n     \n@@ -146,7 +146,7 @@ json_spirit::Value getnewaddress(const json_spirit::Array& params, bool fHelp)\n                 useSeed = true;\n             }\n             \n-            CPubKey newKey = wallet->GenerateBip32Structure(\"m/44'/0'/0'/\", vch, useSeed);\n+            wallet->GenerateBip32Structure(\"m/44'/0'/0'/\", vch, useSeed);\n             if (!useSeed)\n                 obj.push_back(json_spirit::Pair(\"seed\", HexStr(vch, vch+sizeof(vch))));\n         }\n@@ -216,7 +216,7 @@ json_spirit::Value addwallet(const json_spirit::Array& params, bool fHelp)\n                              );\n     \n     std::string walletID = params[0].get_str();\n-    CoreWallet::AddNewWallet(walletID);\n+    CoreWallet::GetManager()->AddNewWallet(walletID);\n     \n     return json_spirit::Value::null;\n }\n@@ -237,7 +237,7 @@ json_spirit::Value listwallets(const json_spirit::Array& params, bool fHelp)\n                                  );\n     \n     json_spirit::Array ret;\n-    std::vector<std::string> vWalletIDs = CoreWallet::GetWalletIDs();\n+    std::vector<std::string> vWalletIDs = CoreWallet::GetManager()->GetWalletIDs();\n     BOOST_FOREACH(const std::string& walletID, vWalletIDs)\n     {\n         ret.push_back(walletID);"
      }
    ]
  },
  {
    "sha": "02364e20b982dae72c2d52bcb8c11325342937e5",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowMjM2NGUyMGI5ODJkYWU3MmMyZDUyYmNiOGMxMTMyNTM0MjkzN2U1",
    "commit": {
      "author": {
        "name": "Jonas Schnelli",
        "email": "jonas.schnelli@include7.ch",
        "date": "2015-05-04T12:30:02Z"
      },
      "committer": {
        "name": "Jonas Schnelli",
        "email": "jonas.schnelli@include7.ch",
        "date": "2015-07-08T14:57:53Z"
      },
      "message": "extend bitcoin-cli to support different endpoints and flexible parameter lists",
      "tree": {
        "sha": "d6ff62a5d32bb4e5a0d2ff415c9fafea614b9f21",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d6ff62a5d32bb4e5a0d2ff415c9fafea614b9f21"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/02364e20b982dae72c2d52bcb8c11325342937e5",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/02364e20b982dae72c2d52bcb8c11325342937e5",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/02364e20b982dae72c2d52bcb8c11325342937e5",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/02364e20b982dae72c2d52bcb8c11325342937e5/comments",
    "author": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "0b8ef46baa555a6bf6d6366b1da61a7ba7e39042",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0b8ef46baa555a6bf6d6366b1da61a7ba7e39042",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0b8ef46baa555a6bf6d6366b1da61a7ba7e39042"
      }
    ],
    "stats": {
      "total": 62,
      "additions": 49,
      "deletions": 13
    },
    "files": [
      {
        "sha": "5835215798796859a138a596ff69af2d3cb319b7",
        "filename": "src/bitcoin-cli.cpp",
        "status": "modified",
        "additions": 37,
        "deletions": 2,
        "changes": 39,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/02364e20b982dae72c2d52bcb8c11325342937e5/src/bitcoin-cli.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/02364e20b982dae72c2d52bcb8c11325342937e5/src/bitcoin-cli.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-cli.cpp?ref=02364e20b982dae72c2d52bcb8c11325342937e5",
        "patch": "@@ -10,7 +10,9 @@\n #include \"util.h\"\n #include \"utilstrencodings.h\"\n \n+#include <boost/algorithm/string.hpp>\n #include <boost/filesystem/operations.hpp>\n+#include <boost/foreach.hpp>\n \n #include \"univalue/univalue.h\"\n \n@@ -121,9 +123,42 @@ UniValue CallRPC(const string& strMethod, const UniValue& params)\n     map<string, string> mapRequestHeaders;\n     mapRequestHeaders[\"Authorization\"] = string(\"Basic \") + strUserPass64;\n \n+    // Check if we access a non root endpoint\n+    std::vector<std::string> vMethodParts;\n+    boost::split(vMethodParts, strMethod, boost::is_any_of(\"/\"));\n+    std::string pathToAccess = \"/\";\n+\n+    Array paramsToUse = params;\n+    std::string strMethodToUse = strMethod;\n+    if (vMethodParts.size() == 2)\n+    {\n+        pathToAccess = \"/\"+vMethodParts.front();\n+        strMethodToUse = vMethodParts.back();\n+    }\n+\n+    //for legacy support, we only use json objects property list as JSON RPC param arg if we access a non root uri\n+    if (pathToAccess != \"/\")\n+    {\n+        //convert key=value arguments to [\"key\":\"value\"] json object property list\n+        paramsToUse = Array();\n+        Object argObj;\n+        BOOST_FOREACH(const Value &val, params)\n+        {\n+            std::vector<std::string> strs;\n+            std::string strVal = val.get_str();\n+            size_t pos = strVal.find(\"=\");\n+            if (pos != std::string::npos)\n+                argObj.push_back(Pair(strVal.substr(0, pos), strVal.substr(pos+1)));\n+            else\n+                paramsToUse.push_back(val);\n+        }\n+\n+        paramsToUse.push_back(argObj);\n+    }\n+\n     // Send request\n-    string strRequest = JSONRPCRequest(strMethod, params, 1);\n-    string strPost = HTTPPost(strRequest, mapRequestHeaders);\n+    string strRequest = JSONRPCRequest(strMethodToUse, paramsToUse, 1);\n+    string strPost = HTTPPost(pathToAccess, strRequest, mapRequestHeaders);\n     stream << strPost << std::flush;\n \n     // Receive HTTP reply status"
      },
      {
        "sha": "f662b02bad57aaeeb77ea637092f1a1383187b30",
        "filename": "src/corewallet/corewallet_rpc.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 8,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/02364e20b982dae72c2d52bcb8c11325342937e5/src/corewallet/corewallet_rpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/02364e20b982dae72c2d52bcb8c11325342937e5/src/corewallet/corewallet_rpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet_rpc.cpp?ref=02364e20b982dae72c2d52bcb8c11325342937e5",
        "patch": "@@ -98,7 +98,8 @@ json_spirit::Value ValueFromParams(const json_spirit::Array& params, const std::\n ///////////////////////////\n json_spirit::Value getnewaddress(const json_spirit::Array& params, bool fHelp)\n {\n-    if (fHelp || params.size() != 1)\n+    Wallet *wallet = WalletFromParams(params);\n+    if (fHelp || !wallet)\n         throw RPCHelpException(\n                             \"getnewaddress\\n\"\n                             \"\\nReturns a new Bitcoin address for receiving payments.\\n\"\n@@ -110,7 +111,6 @@ json_spirit::Value getnewaddress(const json_spirit::Array& params, bool fHelp)\n                             );\n     \n \n-    Wallet *wallet = WalletFromParams(params);\n     json_spirit::Value value = ValueFromParams(params, \"chainpath\");\n     json_spirit::Value valueIndex = ValueFromParams(params, \"index\");\n     \n@@ -164,7 +164,8 @@ json_spirit::Value getnewaddress(const json_spirit::Array& params, bool fHelp)\n     \n json_spirit::Value listaddresses(const json_spirit::Array& params, bool fHelp)\n {\n-    if (fHelp)\n+    Wallet *wallet = WalletFromParams(params);\n+    if (fHelp || !wallet)\n         throw RPCHelpException(\n                             \"listaddresses\\n\"\n                             \"\\nResult:\\n\"\n@@ -176,7 +177,6 @@ json_spirit::Value listaddresses(const json_spirit::Array& params, bool fHelp)\n                             + HelpExampleCli(\"getaddressesbyaccount\", \"\\\"tabby\\\"\")\n                             + HelpExampleRpc(\"getaddressesbyaccount\", \"\\\"tabby\\\"\")\n                             );\n-    Wallet *wallet = WalletFromParams(params);\n     json_spirit::Array ret;\n     BOOST_FOREACH(const PAIRTYPE(CBitcoinAddress, CAddressBookMetadata)& item, wallet->mapAddressBook)\n     {\n@@ -205,25 +205,26 @@ json_spirit::Value listaddresses(const json_spirit::Array& params, bool fHelp)\n ///////////////////////////\n json_spirit::Value addwallet(const json_spirit::Array& params, bool fHelp)\n {\n-    if (fHelp || params.size() != 1)\n+    json_spirit::Value walletIDValue = ValueFromParams(params, \"walletid\");\n+    if (fHelp || walletIDValue.is_null())\n         throw RPCHelpException(\n-                             \"addwallet \\\"walletid\\\"\\n\"\n+                             \"addwallet walletid=<walletid>\\n\"\n                              \"\\nArguments:\\n\"\n                              \"  \\\"walletid\\\"    (string, required) allowed characters: A-Za-z0-9._-\\n\"\n                              \"\\nExamples:\\n\"\n                              + HelpExampleCli(\"addwallet\", \"\\\"anotherwallet\\\"\")\n                              + HelpExampleRpc(\"addwallet\", \"\\\"anotherwallet\\\"\")\n                              );\n     \n-    std::string walletID = params[0].get_str();\n+    std::string walletID = walletIDValue.get_str();\n     CoreWallet::GetManager()->AddNewWallet(walletID);\n     \n     return json_spirit::Value::null;\n }\n     \n json_spirit::Value listwallets(const json_spirit::Array& params, bool fHelp)\n {\n-    if (fHelp || params.size() != 0)\n+    if (fHelp)\n         throw RPCHelpException(\n                                  \"listwallets\\n\"\n                                  \"\\nResult:\\n\""
      },
      {
        "sha": "7c57827d0e1ba8d321705e9b3d86b1ca6a388038",
        "filename": "src/rpcprotocol.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/02364e20b982dae72c2d52bcb8c11325342937e5/src/rpcprotocol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/02364e20b982dae72c2d52bcb8c11325342937e5/src/rpcprotocol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcprotocol.cpp?ref=02364e20b982dae72c2d52bcb8c11325342937e5",
        "patch": "@@ -38,10 +38,10 @@ const size_t POST_READ_SIZE = 256 * 1024;\n  * and to be compatible with other JSON-RPC implementations.\n  */\n \n-string HTTPPost(const string& strMsg, const map<string,string>& mapRequestHeaders)\n+string HTTPPost(const string& path, const string& strMsg, const map<string,string>& mapRequestHeaders)\n {\n     ostringstream s;\n-    s << \"POST / HTTP/1.1\\r\\n\"\n+    s << \"POST \" << path << \" HTTP/1.1\\r\\n\"\n       << \"User-Agent: bitcoin-json-rpc/\" << FormatFullVersion() << \"\\r\\n\"\n       << \"Host: 127.0.0.1\\r\\n\"\n       << \"Content-Type: application/json\\r\\n\""
      },
      {
        "sha": "c123fe729d391ef4769e273fc4bccc0560f3ed44",
        "filename": "src/rpcprotocol.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/02364e20b982dae72c2d52bcb8c11325342937e5/src/rpcprotocol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/02364e20b982dae72c2d52bcb8c11325342937e5/src/rpcprotocol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcprotocol.h?ref=02364e20b982dae72c2d52bcb8c11325342937e5",
        "patch": "@@ -146,7 +146,7 @@ class SSLIOStreamDevice : public boost::iostreams::device<boost::iostreams::bidi\n     boost::asio::ssl::stream<typename Protocol::socket>& stream;\n };\n \n-std::string HTTPPost(const std::string& strMsg, const std::map<std::string,std::string>& mapRequestHeaders);\n+std::string HTTPPost(const std::string& path, const std::string& strMsg, const std::map<std::string,std::string>& mapRequestHeaders);\n std::string HTTPError(int nStatus, bool keepalive,\n                       bool headerOnly = false);\n std::string HTTPReplyHeader(int nStatus, bool keepalive, size_t contentLength,"
      }
    ]
  },
  {
    "sha": "4f804b038ea0b98904f03300f5ea93d2e0ac9ac3",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0ZjgwNGIwMzhlYTBiOTg5MDRmMDMzMDBmNWVhOTNkMmUwYWM5YWMz",
    "commit": {
      "author": {
        "name": "Jonas Schnelli",
        "email": "jonas.schnelli@include7.ch",
        "date": "2015-05-29T20:16:46Z"
      },
      "committer": {
        "name": "Jonas Schnelli",
        "email": "jonas.schnelli@include7.ch",
        "date": "2015-07-08T14:57:53Z"
      },
      "message": "[corewallet] improve bip32 support",
      "tree": {
        "sha": "14c905e52cb9f53df3ef92d3a807a85e5a56dab3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/14c905e52cb9f53df3ef92d3a807a85e5a56dab3"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4f804b038ea0b98904f03300f5ea93d2e0ac9ac3",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4f804b038ea0b98904f03300f5ea93d2e0ac9ac3",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4f804b038ea0b98904f03300f5ea93d2e0ac9ac3",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4f804b038ea0b98904f03300f5ea93d2e0ac9ac3/comments",
    "author": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "02364e20b982dae72c2d52bcb8c11325342937e5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/02364e20b982dae72c2d52bcb8c11325342937e5",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/02364e20b982dae72c2d52bcb8c11325342937e5"
      }
    ],
    "stats": {
      "total": 375,
      "additions": 225,
      "deletions": 150
    },
    "files": [
      {
        "sha": "217fba2e129f92b7fdb57b132e85441df754d30f",
        "filename": "src/corewallet/corewallet.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4f804b038ea0b98904f03300f5ea93d2e0ac9ac3/src/corewallet/corewallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4f804b038ea0b98904f03300f5ea93d2e0ac9ac3/src/corewallet/corewallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet.cpp?ref=4f804b038ea0b98904f03300f5ea93d2e0ac9ac3",
        "patch": "@@ -75,7 +75,7 @@ void LoadAsModule(std::string& warningString, std::string& errorString, bool& st\n     GetManager();\n }\n \n-void Manager::AddNewWallet(const std::string& walletID)\n+Wallet* Manager::AddNewWallet(const std::string& walletID)\n {\n     if (mapWallets.find(walletID) != mapWallets.end())\n         throw std::runtime_error(_(\"walletid already exists\"));\n@@ -87,6 +87,7 @@ void Manager::AddNewWallet(const std::string& walletID)\n     mapWallets[walletID] = WalletModel(walletID, newWallet);\n     \n     WriteWalletList();\n+    return newWallet;\n }\n \n Wallet* Manager::GetWalletWithID(const std::string& walletIDIn)"
      },
      {
        "sha": "7083723031c647d22d62fad6545ce6f9baa4bc36",
        "filename": "src/corewallet/corewallet.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4f804b038ea0b98904f03300f5ea93d2e0ac9ac3/src/corewallet/corewallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4f804b038ea0b98904f03300f5ea93d2e0ac9ac3/src/corewallet/corewallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet.h?ref=4f804b038ea0b98904f03300f5ea93d2e0ac9ac3",
        "patch": "@@ -18,7 +18,7 @@ namespace CoreWallet {\n         ~Manager() { }\n         Wallet* GetWalletWithID(const std::string& walletIDIn);\n         std::vector<std::string> GetWalletIDs();\n-        void AddNewWallet(const std::string& walletID);\n+        Wallet* AddNewWallet(const std::string& walletID);\n         void SyncTransaction(const CTransaction& tx, const CBlock* pblock);\n     protected:\n         std::map<std::string, WalletModel> mapWallets;"
      },
      {
        "sha": "1d30c891d162ce67b137a7cd4bb56921d13f0d05",
        "filename": "src/corewallet/corewallet_db.cpp",
        "status": "modified",
        "additions": 32,
        "deletions": 0,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4f804b038ea0b98904f03300f5ea93d2e0ac9ac3/src/corewallet/corewallet_db.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4f804b038ea0b98904f03300f5ea93d2e0ac9ac3/src/corewallet/corewallet_db.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet_db.cpp?ref=4f804b038ea0b98904f03300f5ea93d2e0ac9ac3",
        "patch": "@@ -5,6 +5,8 @@\n \n #include \"base58.h\"\n \n+#include <stdint.h>\n+\n #include \"corewallet/corewallet_db.h\"\n #include \"corewallet/corewallet_wallet.h\"\n \n@@ -109,6 +111,36 @@ bool ReadKeyValue(Wallet* pCoreWallet, CDataStream& ssKey, CDataStream& ssValue,\n         {\n             ssValue >> pCoreWallet->externalPubKey.pubkey;\n         }\n+        else if (strType == \"chainpath\")\n+        {\n+            ssValue >> pCoreWallet->strChainPath;\n+        }\n+        else if (strType == \"masterseed\")\n+        {\n+            uint32_t seedNum;\n+\n+            ssKey >> seedNum;\n+            ssValue >> pCoreWallet->strMasterseedHex;\n+        }\n+        else if (strType == \"internalpubkey\")\n+        {\n+            ssValue >> pCoreWallet->internalPubKey;\n+        }\n+        else if (strType == \"externalpubkey\")\n+        {\n+            ssValue >> pCoreWallet->externalPubKey;\n+        }\n+        else if (strType == \"extpubkey\")\n+        {\n+            CKeyID keyId;\n+            CExtPubKey extPubKey;\n+\n+            ssKey >> keyId;\n+            ssValue >> extPubKey;\n+        }\n+\n+\n+\n     } catch (...)\n     {\n         return false;"
      },
      {
        "sha": "ed71ddffd8538b06031b5c5e8f425c182ffe689c",
        "filename": "src/corewallet/corewallet_rpc.cpp",
        "status": "modified",
        "additions": 55,
        "deletions": 52,
        "changes": 107,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4f804b038ea0b98904f03300f5ea93d2e0ac9ac3/src/corewallet/corewallet_rpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4f804b038ea0b98904f03300f5ea93d2e0ac9ac3/src/corewallet/corewallet_rpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet_rpc.cpp?ref=4f804b038ea0b98904f03300f5ea93d2e0ac9ac3",
        "patch": "@@ -15,6 +15,7 @@\n #include \"json/json_spirit_utils.h\"\n \n #include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n+#include <boost/algorithm/string/replace.hpp>\n #include <boost/foreach.hpp>\n \n namespace CoreWallet\n@@ -42,14 +43,14 @@ struct RPCDispatchEntry\n };\n \n //dispatch compatible rpc function definitions\n-json_spirit::Value getnewaddress(const json_spirit::Array& params, bool fHelp);\n+json_spirit::Value getaddress(const json_spirit::Array& params, bool fHelp);\n json_spirit::Value listaddresses(const json_spirit::Array& params, bool fHelp);\n json_spirit::Value addwallet(const json_spirit::Array& params, bool fHelp);\n json_spirit::Value listwallets(const json_spirit::Array& params, bool fHelp);\n json_spirit::Value help(const json_spirit::Array& params, bool fHelp);\n     \n static const RPCDispatchEntry vDispatchEntries[] = {\n-    { \"getnewaddress\",                  &getnewaddress },\n+    { \"getaddress\",                  &getaddress },\n     { \"listaddresses\",                  &listaddresses },\n     \n     // Multiwallet\n@@ -96,72 +97,56 @@ json_spirit::Value ValueFromParams(const json_spirit::Array& params, const std::\n ///////////////////////////\n // Keys/Addresses stack\n ///////////////////////////\n-json_spirit::Value getnewaddress(const json_spirit::Array& params, bool fHelp)\n+json_spirit::Value getaddress(const json_spirit::Array& params, bool fHelp)\n {\n     Wallet *wallet = WalletFromParams(params);\n     if (fHelp || !wallet)\n         throw RPCHelpException(\n-                            \"getnewaddress\\n\"\n+                            \"getaddress\\n\"\n                             \"\\nReturns a new Bitcoin address for receiving payments.\\n\"\n                             \"\\nResult:\\n\"\n                             \"\\\"bitcoinaddress\\\"    (string) The new bitcoin address\\n\"\n                             \"\\nExamples:\\n\"\n-                            + HelpExampleCli(\"getnewaddress\", \"\")\n-                            + HelpExampleRpc(\"getnewaddress\", \"\")\n+                            + HelpExampleCli(\"getaddress\", \"\")\n+                            + HelpExampleRpc(\"getaddress\", \"\")\n                             );\n     \n \n-    json_spirit::Value value = ValueFromParams(params, \"chainpath\");\n     json_spirit::Value valueIndex = ValueFromParams(params, \"index\");\n     \n     CKeyID keyID;\n-    \n-    if(value.is_null())\n+    CPubKey newKey;\n+    unsigned int index;\n+\n+    if (!valueIndex.is_null())\n     {\n-        int index = -1;\n-        if (!valueIndex.is_null())\n+        if (valueIndex.type() == json_spirit::str_type)\n             index = atoi(valueIndex.get_str());\n-            \n-        CPubKey newKey = wallet->GenerateNewKey(index);\n-        keyID = newKey.GetID();\n-        wallet->SetAddressBook(keyID, \"receive\");\n-        return CBitcoinAddress(keyID).ToString();\n+        else\n+            index = valueIndex.get_int();\n+    }\n+\n+    if (valueIndex.is_null())\n+    {\n+        newKey = wallet->GetNextUnusedKey(index);\n     }\n     else\n     {\n-        //Bip32\n-        std::string chainpath = value.get_str();\n-        boost::to_lower(chainpath);\n-        \n-        json_spirit::Object obj;\n-        if (chainpath == \"m\")\n-        {\n-            unsigned char vch[32];\n-            json_spirit::Value seedHex = ValueFromParams(params, \"seed\");\n-            bool useSeed = false;\n-            if (!seedHex.is_null())\n-            {\n-                std::vector<unsigned char> result = ParseHex(seedHex.get_str());\n-                memcpy((void *)&vch,(const void *)&result.front(),32);\n-                useSeed = true;\n-            }\n-            \n-            wallet->GenerateBip32Structure(\"m/44'/0'/0'/\", vch, useSeed);\n-            if (!useSeed)\n-                obj.push_back(json_spirit::Pair(\"seed\", HexStr(vch, vch+sizeof(vch))));\n-        }\n-        else\n-        {\n-//            CPubKey newKey = wallet->GenerateBip32Structure(vch, useSeed);\n-//            keyID = newKey.GetID();\n-//            wallet->SetAddressBook(keyID, \"receive\");\n-//            obj.push_back(json_spirit::Pair(\"address\", CBitcoinAddress(keyID).ToString()));\n-        }\n-            \n-        return obj;\n+        newKey = wallet->GetKeyAtIndex(index);\n     }\n+\n+    keyID = newKey.GetID();\n+    std::stringstream ss; ss << index;\n+    json_spirit::Object obj;\n+    std::string chainPath = wallet->strChainPath;\n+    boost::replace_all(chainPath, \"c\", \"0\");\n+    boost::replace_all(chainPath, \"k\", ss.str());\n+    obj.push_back(json_spirit::Pair(chainPath, CBitcoinAddress(keyID).ToString()));\n+\n+\n+    return obj;\n }\n-    \n+\n json_spirit::Value listaddresses(const json_spirit::Array& params, bool fHelp)\n {\n     Wallet *wallet = WalletFromParams(params);\n@@ -215,13 +200,31 @@ json_spirit::Value addwallet(const json_spirit::Array& params, bool fHelp)\n                              + HelpExampleCli(\"addwallet\", \"\\\"anotherwallet\\\"\")\n                              + HelpExampleRpc(\"addwallet\", \"\\\"anotherwallet\\\"\")\n                              );\n-    \n+\n+    json_spirit::Object obj;\n+\n     std::string walletID = walletIDValue.get_str();\n-    CoreWallet::GetManager()->AddNewWallet(walletID);\n-    \n-    return json_spirit::Value::null;\n+    Wallet *wallet = CoreWallet::GetManager()->AddNewWallet(walletID);\n+\n+    unsigned char vch[32];\n+    json_spirit::Value seedHex = ValueFromParams(params, \"seed\");\n+    bool useSeed = false;\n+    if (!seedHex.is_null())\n+    {\n+        std::vector<unsigned char> result = ParseHex(seedHex.get_str());\n+        memcpy((void *)&vch,(const void *)&result.front(),32);\n+        useSeed = true;\n+    }\n+\n+\n+    bool success = wallet->GenerateBip32Structure(\"m/44'/0'/0'/c/k\", vch, useSeed);\n+    if (!useSeed)\n+        obj.push_back(json_spirit::Pair(\"seed\", HexStr(vch, vch+sizeof(vch))));\n+\n+\n+    return obj;\n }\n-    \n+\n json_spirit::Value listwallets(const json_spirit::Array& params, bool fHelp)\n {\n     if (fHelp)"
      },
      {
        "sha": "2ae9707fada0e8e8c1d8d74cde33b3e136e28091",
        "filename": "src/corewallet/corewallet_wallet.cpp",
        "status": "modified",
        "additions": 112,
        "deletions": 88,
        "changes": 200,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4f804b038ea0b98904f03300f5ea93d2e0ac9ac3/src/corewallet/corewallet_wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4f804b038ea0b98904f03300f5ea93d2e0ac9ac3/src/corewallet/corewallet_wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet_wallet.cpp?ref=4f804b038ea0b98904f03300f5ea93d2e0ac9ac3",
        "patch": "@@ -12,52 +12,22 @@\n #include \"util.h\"\n #include \"utilstrencodings.h\"\n \n+#include <stdint.h>\n+\n #include <boost/algorithm/string.hpp>\n #include <boost/foreach.hpp>\n \n namespace CoreWallet {\n   \n-CPubKey Wallet::GenerateBip32Structure(const std::string& chainPathIn, unsigned char (&vch)[32], bool useSeed)\n+bool Wallet::GenerateBip32Structure(const std::string& chainPathIn, unsigned char (&vch)[32], bool useSeed)\n {\n-    //currently seed size is fixed to 256bit\n-    if (!useSeed)\n-    {\n-        RandAddSeedPerfmon();\n-        do {\n-            GetRandBytes(vch, sizeof(vch));\n-        } while (!eccrypto::Check(vch));\n-    }\n-    else\n-    {\n-        LogPrintf(\"using given seed with first 4 chars: %s\", HexStr(vch, vch+4));\n-    }\n-    CExtKey Bip32MasterKey;\n-    CExtPubKey extPubkey;\n-    Bip32MasterKey.SetMaster(vch, sizeof(vch));\n-    \n-    CBitcoinExtKey b58key;\n-    b58key.SetKey(Bip32MasterKey);\n-    LogPrintf(\"key: %s\", b58key.ToString());\n-    \n-    \n-    extPubkey = Bip32MasterKey.Neuter();\n-    \n-    masterKeyID = extPubkey.pubkey.GetID();\n-    \n-    int64_t nCreationTime = GetTime();\n-    CKeyMetadata meta(nCreationTime);\n-    mapKeyMetadata[masterKeyID] = meta;\n-    walletDB->Write(std::make_pair(std::string(\"keymeta\"), extPubkey.pubkey), meta, false);\n-    \n-//    if (!AddKeyPubKey(Bip32MasterKey.key, extPubkey.pubkey))\n-//        throw std::runtime_error(\"CWallet::GenerateNewKey(): AddKey failed\");\n-\n-    if (!walletDB->Write(std::string(\"masterseed\"), HexStr(vch, vch+sizeof(vch)), true)) //for easy serialization store the unsigned char[32] as hex string. //TODO: use 32byte binary ser.\n-        throw std::runtime_error(\"CWallet::GenerateBip32Structure(): Writing masterkeyid failed!\");\n-\n     //take the given chainpath and extend it with /0 for external keys and /1 for internal\n     //example: input chainpath \"m/44'/0'/0'/\" will result in m/44'/0'/0'/0/<nChild> for external and m/44'/0'/0'/1/<nChild> for internal keypair generation\n     //disk cache the internal and external parent pubkey for faster pubkey generation\n+    if (!walletCacheDB->Write(std::string(\"chainpath\"), chainPathIn, true)) //for easy serialization store the unsigned char[32] as hex string. //TODO: use 32byte binary ser.\n+        throw std::runtime_error(\"CWallet::GenerateBip32Structure(): write chainpath failed!\");\n+\n+    strChainPath = chainPathIn;\n     std::string chainPath = chainPathIn;\n     boost::to_lower(chainPath);\n     boost::erase_all(chainPath, \" \");\n@@ -68,64 +38,68 @@ CPubKey Wallet::GenerateBip32Structure(const std::string& chainPathIn, unsigned\n     boost::split(pathFragments, chainPath, boost::is_any_of(\"/\"));\n     \n     \n-    CExtKey parentKey = Bip32MasterKey;\n+    CExtKey parentKey;\n     \n     BOOST_FOREACH(std::string fragment, pathFragments)\n     {\n-        if (fragment == \"m\") //todo, implement optional creation of masterkey and possibility for wallets with ext childkeys on the top\n-            continue;\n-        \n-        CExtKey childKey;\n-        \n         bool harden = false;\n         if (fragment.back() == '\\'')\n             harden = true;\n-        \n-        int nIndex = atoi(fragment.c_str());\n-        parentKey.Derive(childKey, (harden ? 0x80000000 : 0)+nIndex);\n-        \n-        if(pathFragments.back() == fragment)\n+\n+        if (fragment == \"m\")\n+        {\n+            // lets generate a master key seed\n+            //currently seed size is fixed to 256bit\n+            if (!useSeed)\n+            {\n+                RandAddSeedPerfmon();\n+                do {\n+                    GetRandBytes(vch, sizeof(vch));\n+                } while (!eccrypto::Check(vch));\n+            }\n+\n+            CExtKey bip32MasterKey;\n+            bip32MasterKey.SetMaster(vch, sizeof(vch));\n+\n+            CBitcoinExtKey b58key;\n+            b58key.SetKey(bip32MasterKey);\n+            LogPrintf(\"key: %s\", b58key.ToString());\n+\n+            strMasterseedHex = HexStr(vch, vch+sizeof(vch));\n+            uint32_t seedNum = 0;\n+            if (!walletPrivateDB->Write(std::make_pair(std::string(\"masterseed\"),seedNum), strMasterseedHex, true)) //for easy serialization store the unsigned char[32] as hex string. //TODO: use 32byte binary ser.\n+                throw std::runtime_error(\"CWallet::GenerateBip32Structure(): Writing masterkeyid failed!\");\n+\n+            parentKey = bip32MasterKey;\n+        }\n+        else if (fragment == \"k\")\n+        {\n+            harden = false;\n+        }\n+        else if (fragment == \"c\")\n         {\n-            // last fragment\n-            CExtKey internalKey;\n-            CExtKey externalKey;\n-            childKey.Derive(internalKey, 1);\n-            childKey.Derive(externalKey, 0);\n-            \n-            internalPubKey = internalKey.Neuter();\n-            externalPubKey = externalKey.Neuter();\n-            walletDB->Write(std::string(\"bip32intpubkey\"), internalPubKey.pubkey, true);\n-            walletDB->Write(std::string(\"bip32extpubkey\"), externalPubKey.pubkey, true);\n-            \n-            CExtPubKey childPubKey = childKey.Neuter();\n-            int64_t nCreationTime = GetTime();\n-            \n-            CKeyMetadata metaInternal(nCreationTime);\n-            metaInternal.keyidParent = childPubKey.pubkey.GetID();\n-            metaInternal.nDepth = internalPubKey.nDepth;\n-            metaInternal.nDerivationIndex = internalPubKey.nChild;\n-            mapKeyMetadata[internalPubKey.pubkey.GetID()] = metaInternal;\n-            \n-            CKeyMetadata metaExternal(nCreationTime);\n-            metaExternal.keyidParent = childPubKey.pubkey.GetID();\n-            metaExternal.nDepth = internalPubKey.nDepth;\n-            metaExternal.nDerivationIndex = internalPubKey.nChild;\n-            mapKeyMetadata[externalPubKey.pubkey.GetID()] = metaExternal;\n+            harden = false;\n+            CExtPubKey parentExtPubKey = parentKey.Neuter();\n+            parentExtPubKey.Derive(externalPubKey, 0);\n+            parentExtPubKey.Derive(internalPubKey, 1);\n+\n+            uint32_t keyRingNum = 0;\n+            if (!walletPrivateDB->Write(std::make_pair(std::string(\"externalpubkey\"),keyRingNum), externalPubKey, true))\n+                throw std::runtime_error(\"CWallet::GenerateBip32Structure(): Writing masterkeyid failed!\");\n+\n+            if (!walletPrivateDB->Write(std::make_pair(std::string(\"internalpubkey\"),keyRingNum), internalPubKey, true))\n+                throw std::runtime_error(\"CWallet::GenerateBip32Structure(): Writing masterkeyid failed!\");\n+        }\n+        else\n+        {\n+            CExtKey childKey;\n+            int nIndex = atoi(fragment.c_str());\n+            parentKey.Derive(childKey, (harden ? 0x80000000 : 0)+nIndex);\n+            parentKey = childKey;\n         }\n-        \n-        parentKey = childKey;\n     }\n-    \n-//    AddKey(extKey.key);\n-//    AddMeta(keyid, CKeyID(), 0, extKey.chaincode, 0);\n-//    \n-//    if (!walletDB->Write(std::make_pair(std::string(\"keymeta\"), extPubkey.pubkey), mapKeyMetadata[extPubkey.pubkey.GetID()], true))\n-//        throw std::runtime_error(\"CWallet::GenerateBip32Structure(): Writing metadata failed!\");\n-//    \n-//    if (!walletDB->Write(std::make_pair(std::string(\"extpubkey\"), extPubkey.pubkey), extPubkey.pubkey, true))\n-//        throw std::runtime_error(\"CWallet::GenerateBip32Structure(): Writing pubkey failed!\");\n-//    \n-    return extPubkey.pubkey;\n+\n+    return true;\n }\n     \n CPubKey Wallet::GenerateNewKey(int indexIn)\n@@ -148,6 +122,56 @@ CPubKey Wallet::GenerateNewKey(int indexIn)\n     return newExtPubKey.pubkey;\n }\n \n+CPubKey Wallet::GetNextUnusedKey(unsigned int& usedIndex)\n+{\n+\n+//\n+//            internalPubKey = internalKey.Neuter();\n+//            externalPubKey = externalKey.Neuter();\n+//\n+//            CExtPubKey childPubKey = childKey.Neuter();\n+//            int64_t nCreationTime = GetTime();\n+//\n+//            CKeyMetadata metaInternal(nCreationTime);\n+//            metaInternal.keyidParent = childPubKey.pubkey.GetID();\n+//            metaInternal.nDepth = internalPubKey.nDepth;\n+//            metaInternal.nDerivationIndex = internalPubKey.nChild;\n+//            mapKeyMetadata[internalPubKey.pubkey.GetID()] = metaInternal;\n+//\n+//            CKeyMetadata metaExternal(nCreationTime);\n+//            metaExternal.keyidParent = childPubKey.pubkey.GetID();\n+//            metaExternal.nDepth = internalPubKey.nDepth;\n+//            metaExternal.nDerivationIndex = internalPubKey.nChild;\n+//            mapKeyMetadata[externalPubKey.pubkey.GetID()] = metaExternal;\n+\n+\n+    usedIndex = internalNextPos;\n+    CPubKey pubKey = GetKeyAtIndex(internalNextPos++);\n+    return pubKey;\n+}\n+\n+CPubKey Wallet::GetKeyAtIndex(unsigned int index, bool internal)\n+{\n+    //check if this key is already generated\n+\n+    CExtPubKey childKey;\n+    externalPubKey.Derive(childKey,index);\n+\n+    int64_t nCreationTime = GetTime();\n+    CKeyMetadata meta(nCreationTime);\n+    meta.keyidParent = externalPubKey.pubkey.GetID();\n+    meta.nDepth = childKey.nDepth;\n+    meta.nDerivationIndex = childKey.nChild;\n+    mapKeyMetadata[childKey.pubkey.GetID()] = meta;\n+\n+    if (!walletCacheDB->Write(std::make_pair(std::string(\"extpubkey\"),childKey.pubkey.GetID()), childKey, true))\n+        throw std::runtime_error(\"CWallet::GenerateBip32Structure(): Writing masterkeyid failed!\");\n+\n+    externalUsedKeysCache.insert(childKey.nDepth);\n+\n+    return childKey.pubkey;\n+}\n+\n bool Wallet::LoadKey(const CKey& key, const CPubKey &pubkey)\n {\n     return CCryptoKeyStore::AddKeyPubKey(key, pubkey);\n@@ -158,7 +182,7 @@ bool Wallet::AddKeyPubKey(const CKey& secret, const CPubKey &pubkey)\n     if (!CCryptoKeyStore::AddKeyPubKey(secret, pubkey))\n         return false;\n     \n-    return walletDB->WriteKey(pubkey, secret.GetPrivKey(), mapKeyMetadata[pubkey.GetID()]);\n+    return walletCacheDB->WriteKey(pubkey, secret.GetPrivKey(), mapKeyMetadata[pubkey.GetID()]);\n }\n \n bool Wallet::LoadKeyMetadata(const CPubKey &pubkey, const CKeyMetadata &meta)\n@@ -179,7 +203,7 @@ bool Wallet::SetAddressBook(const CTxDestination& address, const std::string& st\n     \n     mapAddressBook[address].purpose = strPurpose;\n     \n-    return walletDB->Write(make_pair(std::string(\"adrmeta\"), CBitcoinAddress(address).ToString()), mapAddressBook[address]);\n+    return walletCacheDB->Write(make_pair(std::string(\"adrmeta\"), CBitcoinAddress(address).ToString()), mapAddressBook[address]);\n }\n \n }; //end namespace\n\\ No newline at end of file"
      },
      {
        "sha": "b2e030fe98a3e576691b9b778bd4ff07e552b008",
        "filename": "src/corewallet/corewallet_wallet.h",
        "status": "modified",
        "additions": 23,
        "deletions": 8,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4f804b038ea0b98904f03300f5ea93d2e0ac9ac3/src/corewallet/corewallet_wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4f804b038ea0b98904f03300f5ea93d2e0ac9ac3/src/corewallet/corewallet_wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet_wallet.h?ref=4f804b038ea0b98904f03300f5ea93d2e0ac9ac3",
        "patch": "@@ -21,27 +21,42 @@ class Wallet : public CCryptoKeyStore, public CValidationInterface{\n     std::map<CKeyID, CKeyMetadata> mapKeyMetadata;\n     std::map<CTxDestination, CAddressBookMetadata> mapAddressBook;\n     int64_t nTimeFirstKey;\n-    FileDB *walletDB;\n-    \n+    FileDB *walletPrivateDB;\n+    FileDB *walletCacheDB;\n+\n+    std::string strChainPath;\n+    std::string strMasterseedHex;\n+    CExtPubKey internalPubKey;\n+    CExtPubKey externalPubKey;\n+\n+\n+    std::set<int> externalUsedKeysCache;\n+\n+    unsigned int internalNextPos;\n+    unsigned int externalNextPos;\n+\n     Wallet(std::string strWalletFileIn)\n     {\n         //instantiate a wallet backend object and maps the stored values\n-        walletDB = new FileDB(strWalletFileIn);\n-        walletDB->LoadWallet(this);\n+        walletPrivateDB = new FileDB(strWalletFileIn+\".private.logdb\");\n+        walletPrivateDB->LoadWallet(this);\n+\n+        walletCacheDB = new FileDB(strWalletFileIn+\".cache.logdb\");\n+        walletCacheDB->LoadWallet(this);\n     }\n     \n-    CPubKey GenerateBip32Structure(const std::string& chainpath, unsigned char (&vchOut)[32], bool useSeed=false);\n+    bool GenerateBip32Structure(const std::string& chainpath, unsigned char (&vchOut)[32], bool useSeed=false);\n     CPubKey GenerateNewKey(int index=-1);\n+    CPubKey GetNextUnusedKey(unsigned int& usedIndex);\n+    CPubKey GetKeyAtIndex(unsigned int index, bool internal = false);\n+    \n     bool AddKeyPubKey(const CKey& key, const CPubKey &pubkey);\n     bool LoadKeyMetadata(const CPubKey &pubkey, const CoreWallet::CKeyMetadata &metadata);\n     bool LoadKey(const CKey& key, const CPubKey &pubkey);\n     bool SetAddressBook(const CTxDestination& address, const std::string& purpose);\n     \n     CKeyID masterKeyID;\n-    CExtPubKey internalPubKey;\n-    CExtPubKey externalPubKey;\n     unsigned char masterSeed[32];\n-    std::string strChainPath;\n };\n \n // WalletModel: a wallet metadata class"
      }
    ]
  },
  {
    "sha": "66689118034eb8a3f7e8f2018afffb4600546ed4",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2NjY4OTExODAzNGViOGEzZjdlOGYyMDE4YWZmZmI0NjAwNTQ2ZWQ0",
    "commit": {
      "author": {
        "name": "Jonas Schnelli",
        "email": "jonas.schnelli@include7.ch",
        "date": "2015-06-16T17:00:50Z"
      },
      "committer": {
        "name": "Jonas Schnelli",
        "email": "jonas.schnelli@include7.ch",
        "date": "2015-07-08T14:57:53Z"
      },
      "message": "[corewallet] Adapt UniValue for corewallet",
      "tree": {
        "sha": "cdab2cd76a604c68d693eec5f2c4a8b4893e3bf8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/cdab2cd76a604c68d693eec5f2c4a8b4893e3bf8"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/66689118034eb8a3f7e8f2018afffb4600546ed4",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/66689118034eb8a3f7e8f2018afffb4600546ed4",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/66689118034eb8a3f7e8f2018afffb4600546ed4",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/66689118034eb8a3f7e8f2018afffb4600546ed4/comments",
    "author": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4f804b038ea0b98904f03300f5ea93d2e0ac9ac3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4f804b038ea0b98904f03300f5ea93d2e0ac9ac3",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4f804b038ea0b98904f03300f5ea93d2e0ac9ac3"
      }
    ],
    "stats": {
      "total": 110,
      "additions": 58,
      "deletions": 52
    },
    "files": [
      {
        "sha": "b6354e3bce15e76ebca1d88a8f86c84636e5f398",
        "filename": "src/bitcoin-cli.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 6,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/66689118034eb8a3f7e8f2018afffb4600546ed4/src/bitcoin-cli.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/66689118034eb8a3f7e8f2018afffb4600546ed4/src/bitcoin-cli.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-cli.cpp?ref=66689118034eb8a3f7e8f2018afffb4600546ed4",
        "patch": "@@ -128,7 +128,7 @@ UniValue CallRPC(const string& strMethod, const UniValue& params)\n     boost::split(vMethodParts, strMethod, boost::is_any_of(\"/\"));\n     std::string pathToAccess = \"/\";\n \n-    Array paramsToUse = params;\n+    UniValue paramsToUse = params;\n     std::string strMethodToUse = strMethod;\n     if (vMethodParts.size() == 2)\n     {\n@@ -140,10 +140,10 @@ UniValue CallRPC(const string& strMethod, const UniValue& params)\n     if (pathToAccess != \"/\")\n     {\n         //convert key=value arguments to [\"key\":\"value\"] json object property list\n-        paramsToUse = Array();\n-        Object argObj;\n-        BOOST_FOREACH(const Value &val, params)\n-        {\n+        paramsToUse = UniValue(UniValue::VARR);\n+        UniValue argObj(UniValue::VOBJ);\n+        for (unsigned int idx = 0; idx < params.size(); idx++) {\n+            const UniValue& val = params[idx];\n             std::vector<std::string> strs;\n             std::string strVal = val.get_str();\n             size_t pos = strVal.find(\"=\");\n@@ -153,7 +153,8 @@ UniValue CallRPC(const string& strMethod, const UniValue& params)\n                 paramsToUse.push_back(val);\n         }\n \n-        paramsToUse.push_back(argObj);\n+        if (!argObj.empty())\n+            paramsToUse.push_back(argObj);\n     }\n \n     // Send request"
      },
      {
        "sha": "2ee684aece9258eed966e8b96bf5584cbf1b6a0a",
        "filename": "src/corewallet/corewallet.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/66689118034eb8a3f7e8f2018afffb4600546ed4/src/corewallet/corewallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/66689118034eb8a3f7e8f2018afffb4600546ed4/src/corewallet/corewallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet.cpp?ref=66689118034eb8a3f7e8f2018afffb4600546ed4",
        "patch": "@@ -8,6 +8,7 @@\n #include \"corewallet/corewallet_wallet.h\"\n #include \"rpcserver.h\"\n #include \"ui_interface.h\"\n+#include \"univalue/univalue.h\"\n #include \"util.h\"\n #include \"validationinterface.h\"\n \n@@ -21,7 +22,7 @@ const static std::string DEFAULT_WALLETS_METADATA_FILE = \"multiwallet.dat\";\n static Manager *managerSharedInstance;\n \n //implemented in corewallet_rpc.cpp\n-extern void ExecuteRPC(const std::string& strMethod, const json_spirit::Array& params, json_spirit::Value& result, bool& accept);\n+extern void ExecuteRPC(const std::string& strMethod, const UniValue& params, UniValue& result, bool& accept);\n \n \n bool CheckFilenameString(const std::string& str)"
      },
      {
        "sha": "3e10a12806da0ce701b378d453918bf9f4abc297",
        "filename": "src/corewallet/corewallet_rpc.cpp",
        "status": "modified",
        "additions": 49,
        "deletions": 45,
        "changes": 94,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/66689118034eb8a3f7e8f2018afffb4600546ed4/src/corewallet/corewallet_rpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/66689118034eb8a3f7e8f2018afffb4600546ed4/src/corewallet/corewallet_rpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet_rpc.cpp?ref=66689118034eb8a3f7e8f2018afffb4600546ed4",
        "patch": "@@ -12,7 +12,7 @@\n \n #include <string>\n \n-#include \"json/json_spirit_utils.h\"\n+#include \"univalue/univalue.h\"\n \n #include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n #include <boost/algorithm/string/replace.hpp>\n@@ -34,7 +34,7 @@ class RPCHelpException: public std::exception\n     std::string msg_;\n };\n     \n-typedef json_spirit::Value(*rpcfn_type)(const json_spirit::Array& params, bool fHelp);\n+typedef UniValue(*rpcfn_type)(const UniValue& params, bool fHelp);\n \n struct RPCDispatchEntry\n {\n@@ -43,11 +43,11 @@ struct RPCDispatchEntry\n };\n \n //dispatch compatible rpc function definitions\n-json_spirit::Value getaddress(const json_spirit::Array& params, bool fHelp);\n-json_spirit::Value listaddresses(const json_spirit::Array& params, bool fHelp);\n-json_spirit::Value addwallet(const json_spirit::Array& params, bool fHelp);\n-json_spirit::Value listwallets(const json_spirit::Array& params, bool fHelp);\n-json_spirit::Value help(const json_spirit::Array& params, bool fHelp);\n+UniValue getaddress(const UniValue& params, bool fHelp);\n+UniValue listaddresses(const UniValue& params, bool fHelp);\n+UniValue addwallet(const UniValue& params, bool fHelp);\n+UniValue listwallets(const UniValue& params, bool fHelp);\n+UniValue help(const UniValue& params, bool fHelp);\n     \n static const RPCDispatchEntry vDispatchEntries[] = {\n     { \"getaddress\",                  &getaddress },\n@@ -67,14 +67,14 @@ static const RPCDispatchEntry vDispatchEntries[] = {\n ///////////////////////////\n \n //! try to filter out the desired wallet instance via given params\n-Wallet* WalletFromParams(const json_spirit::Array& params)\n+Wallet* WalletFromParams(const UniValue& params)\n {\n     std::string walletID = \"\"; //\"\" stands for default wallet\n-    if (params.size() > 0 && params[0].type() == json_spirit::obj_type) //TODO also allow params at index position different the 0\n+    if (params.size() > 0 && params[0].isObject()) //TODO also allow params at index position different the 0\n     {\n-        const json_spirit::Object& o = params[0].get_obj();\n-        json_spirit::Value possibleValue = find_value(o, \"walletid\");\n-        if (!possibleValue.is_null())\n+        const UniValue& o = params[0].get_obj();\n+        UniValue possibleValue = find_value(o, \"walletid\");\n+        if (!possibleValue.isNull())\n             walletID = possibleValue.get_str();\n     }\n     Wallet* wallet = CoreWallet::GetManager()->GetWalletWithID(walletID);\n@@ -85,19 +85,23 @@ Wallet* WalletFromParams(const json_spirit::Array& params)\n }\n \n //! search in exiting json object for a key/value pair and returns value\n-json_spirit::Value ValueFromParams(const json_spirit::Array& params, const std::string& key)\n+UniValue ValueFromParams(const UniValue& params, const std::string& key)\n {\n-    if (params.size() < 1 || params[0].type() != json_spirit::obj_type)\n-        throw std::runtime_error(\"invalid parameters, always use a json key/value object\");\n-    \n-    const json_spirit::Object& o = params[0].get_obj();\n-    return find_value(o, key);\n+    if (params.size() > 0 && params[0].isObject())\n+    {\n+        const UniValue& o = params[0].get_obj();\n+        return find_value(o, key);\n+    }\n+    else\n+    {\n+        return NullUniValue;\n+    }\n }\n     \n ///////////////////////////\n // Keys/Addresses stack\n ///////////////////////////\n-json_spirit::Value getaddress(const json_spirit::Array& params, bool fHelp)\n+UniValue getaddress(const UniValue& params, bool fHelp)\n {\n     Wallet *wallet = WalletFromParams(params);\n     if (fHelp || !wallet)\n@@ -112,21 +116,21 @@ json_spirit::Value getaddress(const json_spirit::Array& params, bool fHelp)\n                             );\n     \n \n-    json_spirit::Value valueIndex = ValueFromParams(params, \"index\");\n+    UniValue valueIndex = ValueFromParams(params, \"index\");\n     \n     CKeyID keyID;\n     CPubKey newKey;\n     unsigned int index;\n \n-    if (!valueIndex.is_null())\n+    if (!valueIndex.isNull())\n     {\n-        if (valueIndex.type() == json_spirit::str_type)\n+        if (valueIndex.isStr())\n             index = atoi(valueIndex.get_str());\n         else\n             index = valueIndex.get_int();\n     }\n \n-    if (valueIndex.is_null())\n+    if (valueIndex.isNull())\n     {\n         newKey = wallet->GetNextUnusedKey(index);\n     }\n@@ -137,17 +141,17 @@ json_spirit::Value getaddress(const json_spirit::Array& params, bool fHelp)\n \n     keyID = newKey.GetID();\n     std::stringstream ss; ss << index;\n-    json_spirit::Object obj;\n+    UniValue obj(UniValue::VOBJ);\n     std::string chainPath = wallet->strChainPath;\n     boost::replace_all(chainPath, \"c\", \"0\");\n     boost::replace_all(chainPath, \"k\", ss.str());\n-    obj.push_back(json_spirit::Pair(chainPath, CBitcoinAddress(keyID).ToString()));\n+    obj.push_back(Pair(chainPath, CBitcoinAddress(keyID).ToString()));\n \n \n     return obj;\n }\n \n-json_spirit::Value listaddresses(const json_spirit::Array& params, bool fHelp)\n+UniValue listaddresses(const UniValue& params, bool fHelp)\n {\n     Wallet *wallet = WalletFromParams(params);\n     if (fHelp || !wallet)\n@@ -162,21 +166,21 @@ json_spirit::Value listaddresses(const json_spirit::Array& params, bool fHelp)\n                             + HelpExampleCli(\"getaddressesbyaccount\", \"\\\"tabby\\\"\")\n                             + HelpExampleRpc(\"getaddressesbyaccount\", \"\\\"tabby\\\"\")\n                             );\n-    json_spirit::Array ret;\n+    UniValue ret(UniValue::VARR);\n     BOOST_FOREACH(const PAIRTYPE(CBitcoinAddress, CAddressBookMetadata)& item, wallet->mapAddressBook)\n     {\n         const CBitcoinAddress& address = item.first;\n         const CAddressBookMetadata& metadata = item.second;\n-        json_spirit::Object obj;\n-        obj.push_back(json_spirit::Pair(address.ToString(), metadata.purpose));\n+        UniValue obj(UniValue::VOBJ);\n+        obj.push_back(Pair(address.ToString(), metadata.purpose));\n         ret.push_back(obj);\n     }\n     \n     CKeyID masterKeyID = wallet->masterKeyID;\n     if (!masterKeyID.IsNull())\n     {\n-        json_spirit::Object obj;\n-        obj.push_back(json_spirit::Pair(CBitcoinAddress(masterKeyID).ToString(), \"masterkey\"));\n+        UniValue obj(UniValue::VOBJ);\n+        obj.push_back(Pair(CBitcoinAddress(masterKeyID).ToString(), \"masterkey\"));\n         ret.push_back(obj);\n     }\n     \n@@ -188,10 +192,10 @@ json_spirit::Value listaddresses(const json_spirit::Array& params, bool fHelp)\n ///////////////////////////\n // MultiWallet stack\n ///////////////////////////\n-json_spirit::Value addwallet(const json_spirit::Array& params, bool fHelp)\n+UniValue addwallet(const UniValue& params, bool fHelp)\n {\n-    json_spirit::Value walletIDValue = ValueFromParams(params, \"walletid\");\n-    if (fHelp || walletIDValue.is_null())\n+    UniValue walletIDValue = ValueFromParams(params, \"walletid\");\n+    if (fHelp || walletIDValue.isNull())\n         throw RPCHelpException(\n                              \"addwallet walletid=<walletid>\\n\"\n                              \"\\nArguments:\\n\"\n@@ -201,15 +205,15 @@ json_spirit::Value addwallet(const json_spirit::Array& params, bool fHelp)\n                              + HelpExampleRpc(\"addwallet\", \"\\\"anotherwallet\\\"\")\n                              );\n \n-    json_spirit::Object obj;\n+    UniValue obj(UniValue::VOBJ);\n \n     std::string walletID = walletIDValue.get_str();\n     Wallet *wallet = CoreWallet::GetManager()->AddNewWallet(walletID);\n \n     unsigned char vch[32];\n-    json_spirit::Value seedHex = ValueFromParams(params, \"seed\");\n+    UniValue seedHex = ValueFromParams(params, \"seed\");\n     bool useSeed = false;\n-    if (!seedHex.is_null())\n+    if (!seedHex.isNull())\n     {\n         std::vector<unsigned char> result = ParseHex(seedHex.get_str());\n         memcpy((void *)&vch,(const void *)&result.front(),32);\n@@ -219,13 +223,13 @@ json_spirit::Value addwallet(const json_spirit::Array& params, bool fHelp)\n \n     bool success = wallet->GenerateBip32Structure(\"m/44'/0'/0'/c/k\", vch, useSeed);\n     if (!useSeed)\n-        obj.push_back(json_spirit::Pair(\"seed\", HexStr(vch, vch+sizeof(vch))));\n+        obj.push_back(Pair(\"seed\", HexStr(vch, vch+sizeof(vch))));\n \n \n     return obj;\n }\n \n-json_spirit::Value listwallets(const json_spirit::Array& params, bool fHelp)\n+UniValue listwallets(const UniValue& params, bool fHelp)\n {\n     if (fHelp)\n         throw RPCHelpException(\n@@ -240,7 +244,7 @@ json_spirit::Value listwallets(const json_spirit::Array& params, bool fHelp)\n                                  + HelpExampleRpc(\"listwallets\", \"\")\n                                  );\n     \n-    json_spirit::Array ret;\n+    UniValue ret(UniValue::VARR);\n     std::vector<std::string> vWalletIDs = CoreWallet::GetManager()->GetWalletIDs();\n     BOOST_FOREACH(const std::string& walletID, vWalletIDs)\n     {\n@@ -253,7 +257,7 @@ json_spirit::Value listwallets(const json_spirit::Array& params, bool fHelp)\n ///////////////////////////\n // Help stack\n ///////////////////////////\n-json_spirit::Value help(const json_spirit::Array& params, bool fHelp)\n+UniValue help(const UniValue& params, bool fHelp)\n {\n     if (fHelp || params.size() != 1)\n         throw RPCHelpException(\n@@ -266,19 +270,19 @@ json_spirit::Value help(const json_spirit::Array& params, bool fHelp)\n                             );\n     \n     std::string helpString = \"\\n== CoreWallet ==\\n\";\n-    json_spirit::Value value = ValueFromParams(params, \"command\");\n+    UniValue value = ValueFromParams(params, \"command\");\n     \n     unsigned int i;\n     for (i = 0; i < (sizeof(vDispatchEntries) / sizeof(vDispatchEntries[0])); i++)\n     {\n         try {\n-            json_spirit::Array params;\n+            UniValue params(UniValue::VARR);\n             vDispatchEntries[i].actor(params, true);\n         } catch (const RPCHelpException& e)\n         {\n             // Help text is returned in an exception\n             std::string strHelp = std::string(e.what());\n-            if (!value.is_null() && value.get_str() == vDispatchEntries[i].name)\n+            if (!value.isNull() && value.get_str() == vDispatchEntries[i].name)\n             {\n                 //shortcut if uses likes help of a single command\n                 helpString = strHelp;\n@@ -300,7 +304,7 @@ json_spirit::Value help(const json_spirit::Array& params, bool fHelp)\n ///////////////////////////\n     \n //! search for command in dispatch table and executes\n-void ExecuteRPC(const std::string& strMethod, const json_spirit::Array& params, json_spirit::Value& result, bool& accept)\n+void ExecuteRPC(const std::string& strMethod, const UniValue& params, UniValue& result, bool& accept)\n {\n     unsigned int i;\n     for (i = 0; i < (sizeof(vDispatchEntries) / sizeof(vDispatchEntries[0])); i++)"
      }
    ]
  },
  {
    "sha": "f29c400eed6d77df835a08d63a15faa6943f04a2",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmMjljNDAwZWVkNmQ3N2RmODM1YTA4ZDYzYTE1ZmFhNjk0M2YwNGEy",
    "commit": {
      "author": {
        "name": "Jonas Schnelli",
        "email": "jonas.schnelli@include7.ch",
        "date": "2015-06-17T18:41:56Z"
      },
      "committer": {
        "name": "Jonas Schnelli",
        "email": "jonas.schnelli@include7.ch",
        "date": "2015-07-08T14:57:53Z"
      },
      "message": "[corewallet] add hdkeystore#",
      "tree": {
        "sha": "f0beb376f663b0b1816c403f5665a3d59464160d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f0beb376f663b0b1816c403f5665a3d59464160d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f29c400eed6d77df835a08d63a15faa6943f04a2",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f29c400eed6d77df835a08d63a15faa6943f04a2",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f29c400eed6d77df835a08d63a15faa6943f04a2",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f29c400eed6d77df835a08d63a15faa6943f04a2/comments",
    "author": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "66689118034eb8a3f7e8f2018afffb4600546ed4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/66689118034eb8a3f7e8f2018afffb4600546ed4",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/66689118034eb8a3f7e8f2018afffb4600546ed4"
      }
    ],
    "stats": {
      "total": 1025,
      "additions": 1010,
      "deletions": 15
    },
    "files": [
      {
        "sha": "1331c7920948a4a95fa69add8927f16f68c6fe06",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f29c400eed6d77df835a08d63a15faa6943f04a2/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f29c400eed6d77df835a08d63a15faa6943f04a2/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=f29c400eed6d77df835a08d63a15faa6943f04a2",
        "patch": "@@ -101,9 +101,9 @@ BITCOIN_CORE_H = \\\n   corewallet/corewallet.h \\\n   corewallet/corewallet_basics.h \\\n   corewallet/corewallet_db.h \\\n-  corewallet/derivingkeystore.h \\\n   corewallet/corewallet_wallet.h \\\n   corewallet/crypter.h \\\n+  corewallet/hdkeystore.h \\\n   corewallet/logdb.h \\\n   eccryptoverify.h \\\n   ecwrapper.h \\\n@@ -226,10 +226,10 @@ libbitcoin_corewallet_a_CPPFLAGS = $(BITCOIN_INCLUDES)\n libbitcoin_corewallet_a_SOURCES = \\\n   corewallet/corewallet.cpp \\\n   corewallet/corewallet_db.cpp \\\n-  corewallet/derivingkeystore.cpp \\\n   corewallet/corewallet_rpc.cpp \\\n   corewallet/corewallet_wallet.cpp \\\n   corewallet/crypter.cpp \\\n+  corewallet/hdkeystore.cpp \\\n   corewallet/logdb.cpp \\\n   $(BITCOIN_CORE_H)\n "
      },
      {
        "sha": "90b7ab6d6aa0671d8654b9e1a8a6687e92d0ef77",
        "filename": "src/corewallet/corewallet_db.cpp",
        "status": "modified",
        "additions": 40,
        "deletions": 0,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f29c400eed6d77df835a08d63a15faa6943f04a2/src/corewallet/corewallet_db.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f29c400eed6d77df835a08d63a15faa6943f04a2/src/corewallet/corewallet_db.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet_db.cpp?ref=f29c400eed6d77df835a08d63a15faa6943f04a2",
        "patch": "@@ -27,6 +27,46 @@ bool FileDB::WriteKey(const CPubKey& vchPubKey, const CPrivKey& vchPrivKey, cons\n     return Write(std::make_pair(std::string(\"key\"), vchPubKey), std::make_pair(vchPrivKey, Hash(vchKey.begin(), vchKey.end())), false);\n }\n \n+bool FileDB::WriteHDMasterSeed(const uint256& hash, const CKeyingMaterial& masterSeed)\n+{\n+    return Write(std::make_pair(std::string(\"hdmasterseed\"), hash), masterSeed);\n+}\n+\n+bool FileDB::WriteHDCryptedMasterSeed(const uint256& hash, const std::vector<unsigned char>& vchCryptedSecret)\n+{\n+    if (!Write(std::make_pair(std::string(\"hdcryptedmasterseed\"), hash), vchCryptedSecret))\n+        return false;\n+\n+    Erase(std::make_pair(std::string(\"hdmasterseed\"), hash));\n+    Erase(std::make_pair(std::string(\"hdmasterseed\"), hash));\n+\n+    return true;\n+}\n+\n+bool FileDB::EraseHDMasterSeed(const uint256& hash)\n+{\n+    return Erase(std::make_pair(std::string(\"hdmasterseed\"), hash));\n+}\n+\n+bool FileDB::WriteHDChain(const CHDChain &chain)\n+{\n+    return Write(std::make_pair(std::string(\"hdchain\"), chain.chainHash), chain);\n+}\n+\n+bool FileDB::WriteHDPubKey(const CHDPubKey& hdPubKey, const CKeyMetadata& keyMeta)\n+{\n+    if (!Write(std::make_pair(std::string(\"keymeta\"), hdPubKey.pubkey),\n+               keyMeta))\n+        return false;\n+\n+    return Write(std::make_pair(std::string(\"hdpubkey\"), hdPubKey.pubkey), hdPubKey);\n+}\n+\n+bool FileDB::WriteHDAchiveChain(const uint256& hash)\n+{\n+    return Write(std::string(\"hdactivechain\"), hash);\n+}\n+\n bool ReadKeyValue(Wallet* pCoreWallet, CDataStream& ssKey, CDataStream& ssValue, std::string& strType, std::string& strErr)\n {\n     try {"
      },
      {
        "sha": "c5c2a0e22faca65dd9d58b5672e3e21756824927",
        "filename": "src/corewallet/corewallet_db.h",
        "status": "modified",
        "additions": 7,
        "deletions": 1,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f29c400eed6d77df835a08d63a15faa6943f04a2/src/corewallet/corewallet_db.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f29c400eed6d77df835a08d63a15faa6943f04a2/src/corewallet/corewallet_db.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet_db.h?ref=f29c400eed6d77df835a08d63a15faa6943f04a2",
        "patch": "@@ -9,7 +9,7 @@\n #include \"corewallet/corewallet_basics.h\"\n #include \"corewallet/logdb.h\"\n #include \"key.h\"\n-#include \"keystore.h\"\n+#include \"hdkeystore.h\"\n \n namespace CoreWallet\n {\n@@ -25,6 +25,12 @@ class FileDB : public CLogDB\n     bool LoadWallet(Wallet* pCoreWallet);\n     \n     bool WriteKey(const CPubKey& vchPubKey, const CPrivKey& vchPrivKey, const CoreWallet::CKeyMetadata &keyMeta);\n+    bool WriteHDMasterSeed(const uint256& hash, const CKeyingMaterial& masterSeed);\n+    bool WriteHDCryptedMasterSeed(const uint256& hash, const std::vector<unsigned char>& vchCryptedSecret);\n+    bool EraseHDMasterSeed(const uint256& hash);\n+    bool WriteHDChain(const CHDChain& chain);\n+    bool WriteHDPubKey(const CHDPubKey& hdPubKey, const CKeyMetadata& keyMeta);\n+    bool WriteHDAchiveChain(const uint256& hash);\n };\n     \n }; // end namespace CoreWallet"
      },
      {
        "sha": "94275bbc180207229ebdcb80d3eea45916209589",
        "filename": "src/corewallet/corewallet_rpc.cpp",
        "status": "modified",
        "additions": 203,
        "deletions": 2,
        "changes": 205,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f29c400eed6d77df835a08d63a15faa6943f04a2/src/corewallet/corewallet_rpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f29c400eed6d77df835a08d63a15faa6943f04a2/src/corewallet/corewallet_rpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet_rpc.cpp?ref=f29c400eed6d77df835a08d63a15faa6943f04a2",
        "patch": "@@ -43,15 +43,24 @@ struct RPCDispatchEntry\n };\n \n //dispatch compatible rpc function definitions\n+UniValue hdaddchain(const UniValue& params, bool fHelp);\n+UniValue hdsetchain(const UniValue& params, bool fHelp);\n+UniValue hdgetinfo(const UniValue& params, bool fHelp);\n+UniValue hdgetaddress(const UniValue& params, bool fHelp);\n UniValue getaddress(const UniValue& params, bool fHelp);\n UniValue listaddresses(const UniValue& params, bool fHelp);\n UniValue addwallet(const UniValue& params, bool fHelp);\n UniValue listwallets(const UniValue& params, bool fHelp);\n UniValue help(const UniValue& params, bool fHelp);\n     \n static const RPCDispatchEntry vDispatchEntries[] = {\n-    { \"getaddress\",                  &getaddress },\n+    { \"getaddress\",                     &getaddress },\n     { \"listaddresses\",                  &listaddresses },\n+\n+    { \"hdaddchain\",                       &hdaddchain },\n+    { \"hdsetchain\",                       &hdsetchain },\n+    { \"hdgetinfo\",                        &hdgetinfo },\n+    { \"hdgetaddress\",                     &hdgetaddress },\n     \n     // Multiwallet\n     { \"addwallet\",                      &addwallet },\n@@ -259,7 +268,7 @@ UniValue listwallets(const UniValue& params, bool fHelp)\n ///////////////////////////\n UniValue help(const UniValue& params, bool fHelp)\n {\n-    if (fHelp || params.size() != 1)\n+    if (fHelp || params.size() == 1)\n         throw RPCHelpException(\n                             \"help ( \\\"command\\\" )\\n\"\n                             \"\\nList all commands, or get help for a specified command.\\n\"\n@@ -298,6 +307,198 @@ UniValue help(const UniValue& params, bool fHelp)\n     \n     return helpString;\n }\n+\n+/*\n+ \n+******* HDSTACK ********\n+\n+default chainpath after bip44\n+m = master key\n+<num>' or <num>h = hardened key\n+c stands for internal/external chain switch\n+c=0 for external addresses\n+c=1 for internal addresses\n+\n+example \"m/44'/0'/0'/c\" will result in m/44'/0'/0'/0/0 for the first external key\n+example \"m/44'/0'/0'/c\" will result in m/44'/0'/0'/1/0 for the first internal key\n+example \"m/44'/0'/0'/c\" will result in m/44'/0'/0'/0/1 for the second external key\n+example \"m/44'/0'/0'/c\" will result in m/44'/0'/0'/1/1 for the second internal key\n+*/\n+const std::string hd_default_chainpath = \"m/44'/0'/0'/c\";\n+\n+UniValue hdaddchain(const UniValue& params, bool fHelp)\n+{\n+    if (fHelp)\n+        throw std::runtime_error(\n+                            \"hdaddchain (<chainpath>|default) (<masterseed_hex>)\\n\"\n+                            \"\\nAdds a HD/Bip32 chain \\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. chainpath        (string, optional, default=\"+hd_default_chainpath+\") chainpath for hd wallet structure\\n\"\n+                            \"   m stands for master, c for internal/external key-switch, k stands for upcounting child key index\"\n+                            \"2. masterseed_hex   (string/hex, optional) use this seed for master key generation\\n\"\n+                            \"\\nResult\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"seed_hex\\\" : \\\"<hexstr>\\\",  (string) seed used during master key generation (only if no masterseed hex was provided\\n\"\n+                            \"}\\n\"\n+\n+                            \"\\nExamples\\n\"\n+                            + HelpExampleCli(\"hdaddchain\", \"set\")\n+                            + HelpExampleCli(\"hdaddchain\", \"set m/44'/0'/0'/c/k\")\n+                            + HelpExampleRpc(\"hdaddchain\", \"set m/44'/0'/0'/c/k\")\n+                            );\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    Wallet *wallet = WalletFromParams(params);\n+    UniValue chainpathParam = ValueFromParams(params, \"chainpath\");\n+    UniValue seedParam = ValueFromParams(params, \"seed\");\n+\n+    //EnsureWalletIsUnlocked();\n+\n+    const unsigned int bip32MasterSeedLength = 32;\n+    CKeyingMaterial vSeed = CKeyingMaterial(bip32MasterSeedLength);\n+    bool fGenerateMasterSeed = true;\n+    HDChainID chainId;\n+    std::string chainPath = hd_default_chainpath;\n+    if (!chainpathParam.isNull() && chainpathParam.isStr() && chainpathParam.get_str() != \"default\")\n+        chainPath = chainpathParam.get_str(); //todo bip32 chainpath sanity\n+\n+    if (!seedParam.isNull() && seedParam.isStr())\n+    {\n+        if (!IsHex(seedParam.get_str()))\n+            throw std::runtime_error(\"HD master seed must encoded in hex\");\n+\n+        std::vector<unsigned char> seed = ParseHex(seedParam.get_str());\n+        if (seed.size() != bip32MasterSeedLength)\n+            throw std::runtime_error(\"HD master seed must be \"+itostr(bip32MasterSeedLength*8)+\"bit\");\n+\n+        memcpy(&vSeed[0], &seed[0], bip32MasterSeedLength);\n+        memory_cleanse(&seed[0], bip32MasterSeedLength);\n+        fGenerateMasterSeed = false;\n+    }\n+    \n+    wallet->HDSetChainPath(chainPath, fGenerateMasterSeed, vSeed, chainId);\n+    if (fGenerateMasterSeed)\n+        result.push_back(Pair(\"seed_hex\", HexStr(vSeed)));\n+    result.push_back(Pair(\"chainid\", chainId.GetHex()));\n+    return result;\n+}\n+\n+UniValue hdsetchain(const UniValue& params, bool fHelp)\n+{\n+    if (fHelp || params.size() != 1)\n+        throw std::runtime_error(\n+                            \"hdsetchain <chainid>\\n\"\n+                            \"\\nReturns some hd relevant information.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"chainid\\\"        (string|hex, required) chainid is a bitcoin hash of the master public key of the corresponding chain.\\n\"\n+                            \"\\nExamples:\\n\"\n+                            + HelpExampleCli(\"hdsetchain\", \"\")\n+                            + HelpExampleCli(\"hdgetinfo\", \"True\")\n+                            + HelpExampleRpc(\"hdgetinfo\", \"\")\n+                            );\n+\n+    Wallet *wallet = WalletFromParams(params);\n+\n+    HDChainID chainId;\n+    if (!IsHex(params[0].get_str()))\n+        throw std::runtime_error(\"Chain id format is invalid\");\n+\n+    chainId.SetHex(params[0].get_str());\n+\n+    if (!wallet->HDSetActiveChainID(chainId))\n+        throw std::runtime_error(\"Could not set active chain\");\n+\n+    return NullUniValue;\n+}\n+\n+UniValue hdgetinfo(const UniValue& params, bool fHelp)\n+{\n+    if (fHelp || params.size() != 0)\n+        throw std::runtime_error(\n+                            \"hdgetinfo\\n\"\n+                            \"\\nReturns some hd relevant information.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"chainid\\\" : \\\"<chainid>\\\",  string) A bitcoinhash of the master public key\\n\"\n+                            \"  \\\"creationtime\\\" : The creation time in seconds since epoch (midnight Jan 1 1970 GMT).\\n\"\n+                            \"  \\\"chainpath\\\" : \\\"<keyschainpath>\\\",  string) The chainpath (like m/44'/0'/0'/c)\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            + HelpExampleCli(\"hdgetinfo\", \"\")\n+                            + HelpExampleCli(\"hdgetinfo\", \"True\")\n+                            + HelpExampleRpc(\"hdgetinfo\", \"\")\n+                            );\n+\n+    Wallet *wallet = WalletFromParams(params);\n+\n+    std::vector<HDChainID> chainIDs;\n+    if (!wallet->GetAvailableChainIDs(chainIDs))\n+        throw std::runtime_error(\"Could not load chain ids\");\n+\n+    UniValue result(UniValue::VARR);\n+    BOOST_FOREACH(const HDChainID& chainId, chainIDs)\n+    {\n+        CHDChain chain;\n+        if (!wallet->GetChain(chainId, chain))\n+            throw std::runtime_error(\"Could not load chain\");\n+\n+        UniValue chainObject(UniValue::VOBJ);\n+        chainObject.push_back(Pair(\"chainid\", chainId.GetHex()));\n+        chainObject.push_back(Pair(\"creationtime\", chain.nCreateTime));\n+        chainObject.push_back(Pair(\"chainpath\", chain.chainPath));\n+\n+        result.push_back(chainObject);\n+    }\n+\n+    return result;\n+}\n+\n+UniValue hdgetaddress(const UniValue& params, bool fHelp)\n+{\n+    if (fHelp || params.size() > 1)\n+        throw std::runtime_error(\n+                            \"hdgetaddress (<childindex>)\\n\"\n+                            \"\\nReturns a Bitcoin address for receiving payments.\\n\"\n+                            \"\\nAutomatically uses the next available childindex if no index is given\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"childindex\\\"        (numeric, optional) child key index. ATTENTION: automatic index counting will start at the highes available child key index\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"address\\\" : \\\"<address>\\\",  string) The new bitcoin address\\n\"\n+                            \"  \\\"chainpath\\\" : \\\"<keyschainpath>\\\",  string) The used chainpath\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            + HelpExampleCli(\"hdgetaddress\", \"\")\n+                            + HelpExampleCli(\"hdgetaddress\", \"100\")\n+                            + HelpExampleRpc(\"hdgetaddress\", \"\")\n+                            );\n+\n+    Wallet *wallet = WalletFromParams(params);\n+\n+    CPubKey newKey;\n+    std::string keyChainPath;\n+    if (params.size() == 1 && params[0].isNum())\n+    {\n+        HDChainID emptyId;\n+        if (!wallet->HDGetChildPubKeyAtIndex(emptyId, newKey, params[0].get_int()))\n+            throw JSONRPCError(RPC_WALLET_KEYPOOL_RAN_OUT, \"Error: Can't generate HD child key\");\n+    }\n+    else\n+    {\n+        HDChainID emptyId;\n+        if (!wallet->HDGetNextChildPubKey(emptyId, newKey, keyChainPath))\n+            throw JSONRPCError(RPC_WALLET_KEYPOOL_RAN_OUT, \"Error: Can't generate HD child key\");\n+    }\n+    CKeyID keyID = newKey.GetID();\n+    \n+    wallet->SetAddressBook(keyID, \"receive\");\n+    \n+    UniValue result(UniValue::VOBJ);\n+    result.push_back(Pair(\"address\", CBitcoinAddress(keyID).ToString()));\n+    result.push_back(Pair(\"chainpath\", keyChainPath));\n+    return result;\n+}\n+\n     \n ///////////////////////////\n // Dispatching/signaling stack"
      },
      {
        "sha": "a91a67a25832be80a4e1f29a27e95a7ecc04d306",
        "filename": "src/corewallet/corewallet_wallet.cpp",
        "status": "modified",
        "additions": 220,
        "deletions": 7,
        "changes": 227,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f29c400eed6d77df835a08d63a15faa6943f04a2/src/corewallet/corewallet_wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f29c400eed6d77df835a08d63a15faa6943f04a2/src/corewallet/corewallet_wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet_wallet.cpp?ref=f29c400eed6d77df835a08d63a15faa6943f04a2",
        "patch": "@@ -25,7 +25,7 @@ bool Wallet::GenerateBip32Structure(const std::string& chainPathIn, unsigned cha\n     //example: input chainpath \"m/44'/0'/0'/\" will result in m/44'/0'/0'/0/<nChild> for external and m/44'/0'/0'/1/<nChild> for internal keypair generation\n     //disk cache the internal and external parent pubkey for faster pubkey generation\n     if (!walletCacheDB->Write(std::string(\"chainpath\"), chainPathIn, true)) //for easy serialization store the unsigned char[32] as hex string. //TODO: use 32byte binary ser.\n-        throw std::runtime_error(\"CWallet::GenerateBip32Structure(): write chainpath failed!\");\n+        throw std::runtime_error(\"CoreWallet::GenerateBip32Structure(): write chainpath failed!\");\n \n     strChainPath = chainPathIn;\n     std::string chainPath = chainPathIn;\n@@ -68,7 +68,7 @@ bool Wallet::GenerateBip32Structure(const std::string& chainPathIn, unsigned cha\n             strMasterseedHex = HexStr(vch, vch+sizeof(vch));\n             uint32_t seedNum = 0;\n             if (!walletPrivateDB->Write(std::make_pair(std::string(\"masterseed\"),seedNum), strMasterseedHex, true)) //for easy serialization store the unsigned char[32] as hex string. //TODO: use 32byte binary ser.\n-                throw std::runtime_error(\"CWallet::GenerateBip32Structure(): Writing masterkeyid failed!\");\n+                throw std::runtime_error(\"CoreWallet::GenerateBip32Structure(): Writing masterkeyid failed!\");\n \n             parentKey = bip32MasterKey;\n         }\n@@ -85,10 +85,10 @@ bool Wallet::GenerateBip32Structure(const std::string& chainPathIn, unsigned cha\n \n             uint32_t keyRingNum = 0;\n             if (!walletPrivateDB->Write(std::make_pair(std::string(\"externalpubkey\"),keyRingNum), externalPubKey, true))\n-                throw std::runtime_error(\"CWallet::GenerateBip32Structure(): Writing masterkeyid failed!\");\n+                throw std::runtime_error(\"CoreWallet::GenerateBip32Structure(): Writing masterkeyid failed!\");\n \n             if (!walletPrivateDB->Write(std::make_pair(std::string(\"internalpubkey\"),keyRingNum), internalPubKey, true))\n-                throw std::runtime_error(\"CWallet::GenerateBip32Structure(): Writing masterkeyid failed!\");\n+                throw std::runtime_error(\"CoreWallet::GenerateBip32Structure(): Writing masterkeyid failed!\");\n         }\n         else\n         {\n@@ -152,7 +152,7 @@ CPubKey Wallet::GetNextUnusedKey(unsigned int& usedIndex)\n \n CPubKey Wallet::GetKeyAtIndex(unsigned int index, bool internal)\n {\n-    //check if this key is already generated\n+    LOCK(cs_coreWallet);\n \n     CExtPubKey childKey;\n     externalPubKey.Derive(childKey,index);\n@@ -165,7 +165,7 @@ CPubKey Wallet::GetKeyAtIndex(unsigned int index, bool internal)\n     mapKeyMetadata[childKey.pubkey.GetID()] = meta;\n \n     if (!walletCacheDB->Write(std::make_pair(std::string(\"extpubkey\"),childKey.pubkey.GetID()), childKey, true))\n-        throw std::runtime_error(\"CWallet::GenerateBip32Structure(): Writing masterkeyid failed!\");\n+        throw std::runtime_error(\"CoreWallet::GenerateBip32Structure(): Writing masterkeyid failed!\");\n \n     externalUsedKeysCache.insert(childKey.nDepth);\n \n@@ -187,9 +187,10 @@ bool Wallet::AddKeyPubKey(const CKey& secret, const CPubKey &pubkey)\n \n bool Wallet::LoadKeyMetadata(const CPubKey &pubkey, const CKeyMetadata &meta)\n {\n+    LOCK(cs_coreWallet);\n     if (meta.nCreateTime && (!nTimeFirstKey || meta.nCreateTime < nTimeFirstKey))\n         nTimeFirstKey = meta.nCreateTime;\n-    \n+\n     mapKeyMetadata[pubkey.GetID()] = meta;\n     return true;\n }\n@@ -206,4 +207,216 @@ bool Wallet::SetAddressBook(const CTxDestination& address, const std::string& st\n     return walletCacheDB->Write(make_pair(std::string(\"adrmeta\"), CBitcoinAddress(address).ToString()), mapAddressBook[address]);\n }\n \n+\n+\n+const unsigned int HD_MAX_DEPTH = 20;\n+\n+bool Wallet::HDSetChainPath(const std::string& chainPathIn, bool generateMaster, CKeyingMaterial& vSeed, HDChainID& chainId, bool overwrite)\n+{\n+    LOCK(cs_coreWallet);\n+\n+    if (IsLocked())\n+        return false;\n+\n+    if (chainPathIn[0] != 'm')\n+        throw std::runtime_error(\"CoreWallet::SetHDChainPath(): Non masterkey chainpaths are not allowed.\");\n+\n+    if (chainPathIn.find_first_of(\"c\", 1) == std::string::npos)\n+        throw std::runtime_error(\"CoreWallet::SetHDChainPath(): 'c' (internal/external chain selection) is requires in the given chainpath.\");\n+\n+    if (chainPathIn.find_first_not_of(\"0123456789'/mch\", 0) != std::string::npos)\n+        throw std::runtime_error(\"CoreWallet::SetHDChainPath(): Invalid chainpath.\");\n+\n+    std::string newChainPath = chainPathIn;\n+    boost::to_lower(newChainPath);\n+    boost::erase_all(newChainPath, \" \");\n+    boost::replace_all(newChainPath, \"h\", \"'\"); //support h instead of ' to allow easy JSON input over cmd line\n+    if (newChainPath.size() > 0 && *newChainPath.rbegin() == '/')\n+        newChainPath.resize(newChainPath.size() - 1);\n+\n+    std::vector<std::string> pathFragments;\n+    boost::split(pathFragments, newChainPath, boost::is_any_of(\"/\"));\n+\n+    if (pathFragments.size() > HD_MAX_DEPTH)\n+        throw std::runtime_error(\"CoreWallet::SetHDChainPath(): Max chain depth (\"+itostr(HD_MAX_DEPTH)+\") exceeded!\");\n+\n+    int64_t nCreationTime = GetTime();\n+    CHDChain newChain(nCreationTime);\n+    newChain.chainPath = newChainPath;\n+    CExtKey parentKey;\n+    BOOST_FOREACH(std::string fragment, pathFragments)\n+    {\n+        bool harden = false;\n+        if (*fragment.rbegin() == '\\'')\n+        {\n+            harden = true;\n+            fragment = fragment.substr(0,fragment.size()-1);\n+        }\n+\n+        if (fragment == \"m\")\n+        {\n+            //generate a master key seed\n+            //currently seed size is fixed to 256bit\n+            assert(vSeed.size() == 32);\n+            if (generateMaster)\n+            {\n+                RandAddSeedPerfmon();\n+                do {\n+                    GetRandBytes(&vSeed[0], vSeed.size());\n+                } while (!eccrypto::Check(&vSeed[0]));\n+            }\n+\n+            CExtKey bip32MasterKey;\n+            bip32MasterKey.SetMaster(&vSeed[0], vSeed.size());\n+\n+            CBitcoinExtKey b58key;\n+            b58key.SetKey(bip32MasterKey);\n+            chainId = bip32MasterKey.key.GetPubKey().GetHash();\n+\n+            //only one chain per master seed is allowed\n+            CHDChain possibleChain;\n+            if (GetChain(chainId, possibleChain) && possibleChain.IsValid())\n+                throw std::runtime_error(\"CoreWallet::SetHDChainPath(): Only one chain per masterseed is allowed.\");\n+\n+            if (!AddMasterSeed(chainId, vSeed))\n+                throw std::runtime_error(\"CoreWallet::SetHDChainPath(): Could not store master seed.\");\n+\n+            //keep the master pubkeyhash for chain identifying\n+            newChain.chainHash = chainId;\n+\n+            if (IsCrypted())\n+            {\n+                std::vector<unsigned char> vchCryptedSecret;\n+                GetCryptedMasterSeed(chainId, vchCryptedSecret);\n+\n+                if (!walletPrivateDB->WriteHDCryptedMasterSeed(chainId, vchCryptedSecret))\n+                    throw std::runtime_error(\"CoreWallet::SetHDChainPath(): Writing hdmasterseed failed!\");\n+            }\n+            else\n+            {\n+                if (!walletPrivateDB->WriteHDMasterSeed(chainId, vSeed))\n+                    throw std::runtime_error(\"CoreWallet::SetHDChainPath(): Writing cryted hdmasterseed failed!\");\n+            }\n+\n+            //set active hd chain\n+            activeHDChain = chainId;\n+            if (!walletCacheDB->WriteHDAchiveChain(chainId))\n+                throw std::runtime_error(\"CoreWallet::SetHDChainPath(): Writing active hd chain failed!\");\n+\n+            parentKey = bip32MasterKey;\n+        }\n+        else if (fragment == \"c\")\n+        {\n+            harden = false; //external / internal chain root keys can not be hardened\n+            CExtPubKey parentExtPubKey = parentKey.Neuter();\n+            parentExtPubKey.Derive(newChain.externalPubKey, 0);\n+            parentExtPubKey.Derive(newChain.internalPubKey, 1);\n+\n+            AddChain(newChain);\n+\n+            if (!walletCacheDB->WriteHDChain(newChain))\n+                throw std::runtime_error(\"CoreWallet::SetHDChainPath(): Writing new chain failed!\");\n+        }\n+        else\n+        {\n+            CExtKey childKey;\n+            int32_t nIndex;\n+            if (!ParseInt32(fragment,&nIndex))\n+                return false;\n+            parentKey.Derive(childKey, (harden ? 0x80000000 : 0)+nIndex);\n+            parentKey = childKey;\n+        }\n+    }\n+\n+    return true;\n+}\n+\n+bool Wallet::HDGetChildPubKeyAtIndex(const HDChainID& chainID, CPubKey &pubKeyOut, unsigned int nIndex, bool internal)\n+{\n+    AssertLockHeld(cs_coreWallet);\n+\n+    CHDPubKey newHdPubKey;\n+    if (!DeriveHDPubKeyAtIndex(chainID, newHdPubKey, nIndex, internal))\n+        throw std::runtime_error(\"CoreWallet::HDGetChildPubKeyAtIndex(): Deriving child key faild!\");\n+\n+    // Create new metadata\n+    int64_t nCreationTime = GetTime();\n+    mapKeyMetadata[newHdPubKey.pubkey.GetID()] = CKeyMetadata(nCreationTime);\n+    if (!nTimeFirstKey || nCreationTime < nTimeFirstKey)\n+        nTimeFirstKey = nCreationTime;\n+\n+    if (!LoadHDPubKey(newHdPubKey))\n+        throw std::runtime_error(\"CoreWallet::HDGetChildPubKeyAtIndex(): Add key to keystore failed!\");\n+\n+    if (!walletCacheDB->WriteHDPubKey(newHdPubKey, mapKeyMetadata[newHdPubKey.pubkey.GetID()]))\n+        throw std::runtime_error(\"CoreWallet::HDGetChildPubKeyAtIndex(): Writing pubkey failed!\");\n+\n+    pubKeyOut = newHdPubKey.pubkey;\n+    return true;\n+}\n+\n+bool Wallet::HDGetNextChildPubKey(const HDChainID& chainIDIn, CPubKey &pubKeyOut, std::string& newKeysChainpath, bool internal)\n+{\n+    AssertLockHeld(cs_coreWallet);\n+\n+    CHDChain chain;\n+    HDChainID chainID = chainIDIn;\n+    if (chainID.IsNull())\n+        chainID = activeHDChain;\n+\n+    if (!GetChain(chainID, chain) || !chain.IsValid())\n+        throw std::runtime_error(\"CoreWallet::HDGetNextChildPubKey(): Selected chain is not vailid!\");\n+\n+    unsigned int nextIndex = GetNextChildIndex(chainID, internal);\n+    if (!HDGetChildPubKeyAtIndex(chainID, pubKeyOut, nextIndex, internal))\n+        return false;\n+\n+    newKeysChainpath = chain.chainPath;\n+    boost::replace_all(newKeysChainpath, \"c\", itostr(internal)); //replace the chain switch index\n+    newKeysChainpath += \"/\"+itostr(nextIndex);\n+\n+    return true;\n+}\n+\n+bool Wallet::EncryptHDSeeds(CKeyingMaterial& vMasterKeyIn)\n+{\n+    EncryptSeeds();\n+\n+    std::vector<HDChainID> chainIds;\n+    GetAvailableChainIDs(chainIds);\n+\n+    BOOST_FOREACH(HDChainID& chainId, chainIds)\n+    {\n+        std::vector<unsigned char> vchCryptedSecret;\n+        if (!GetCryptedMasterSeed(chainId, vchCryptedSecret))\n+            throw std::runtime_error(\"CoreWallet::EncryptHDSeeds(): Encrypting seeds failed!\");\n+        \n+        if (!walletPrivateDB->WriteHDCryptedMasterSeed(chainId, vchCryptedSecret))\n+            throw std::runtime_error(\"CoreWallet::EncryptHDSeeds(): Writing hdmasterseed failed!\");\n+    }\n+    \n+    return true;\n+}\n+\n+bool Wallet::HDSetActiveChainID(const HDChainID& chainID, bool check)\n+{\n+    LOCK(cs_coreWallet);\n+    CHDChain chainOut;\n+    \n+    //do the chainID check optional because we need a way of setting the chainID before the acctual chain is loaded into the memory\n+    //this is becuase of the way we load the chains from the wallet.dat\n+    if (check && !GetChain(chainID, chainOut)) //TODO: implement FindChain() to avoild copy of CHDChain\n+        return false;\n+    \n+    activeHDChain = chainID;\n+    return true;\n+}\n+\n+bool Wallet::HDGetActiveChainID(HDChainID& chainID)\n+{\n+    LOCK(cs_coreWallet);\n+    chainID = activeHDChain;\n+    return true;\n+}\n+\n }; //end namespace\n\\ No newline at end of file"
      },
      {
        "sha": "cc772b3d91d59490aa7ba5b2cb504c0e85aefa07",
        "filename": "src/corewallet/corewallet_wallet.h",
        "status": "modified",
        "additions": 68,
        "deletions": 2,
        "changes": 70,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f29c400eed6d77df835a08d63a15faa6943f04a2/src/corewallet/corewallet_wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f29c400eed6d77df835a08d63a15faa6943f04a2/src/corewallet/corewallet_wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet_wallet.h?ref=f29c400eed6d77df835a08d63a15faa6943f04a2",
        "patch": "@@ -8,14 +8,14 @@\n \n #include \"corewallet/corewallet_basics.h\"\n #include \"corewallet/corewallet_db.h\"\n-#include \"corewallet/crypter.h\"\n+#include \"corewallet/hdkeystore.h\"\n #include \"key.h\"\n #include \"keystore.h\"\n #include \"validationinterface.h\"\n \n namespace CoreWallet {\n     \n-class Wallet : public CCryptoKeyStore, public CValidationInterface{\n+class Wallet : public CHDKeyStore, public CValidationInterface{\n public:\n     mutable CCriticalSection cs_coreWallet;\n     std::map<CKeyID, CKeyMetadata> mapKeyMetadata;\n@@ -24,6 +24,9 @@ class Wallet : public CCryptoKeyStore, public CValidationInterface{\n     FileDB *walletPrivateDB;\n     FileDB *walletCacheDB;\n \n+    //! state: current active hd chain\n+    HDChainID activeHDChain;\n+\n     std::string strChainPath;\n     std::string strMasterseedHex;\n     CExtPubKey internalPubKey;\n@@ -44,6 +47,24 @@ class Wallet : public CCryptoKeyStore, public CValidationInterface{\n         walletCacheDB = new FileDB(strWalletFileIn+\".cache.logdb\");\n         walletCacheDB->LoadWallet(this);\n     }\n+\n+    //!adds a hd chain of keys to the wallet\n+    bool HDSetChainPath(const std::string& chainPath, bool generateMaster, CKeyingMaterial& vSeed, HDChainID& chainId, bool overwrite = false);\n+\n+    //!gets a child key from the internal or external chain at given index\n+    bool HDGetChildPubKeyAtIndex(const HDChainID& chainID, CPubKey &pubKeyOut, unsigned int nIndex, bool internal = false);\n+\n+    //!get next free child key\n+    bool HDGetNextChildPubKey(const HDChainID& chainId, CPubKey &pubKeyOut, std::string& newKeysChainpathOut, bool internal = false);\n+\n+    //!encrypt your master seeds\n+    bool EncryptHDSeeds(CKeyingMaterial& vMasterKeyIn);\n+\n+    //!set the active chain of keys\n+    bool HDSetActiveChainID(const HDChainID& chainID, bool check = true);\n+\n+    //!set the active chain of keys\n+    bool HDGetActiveChainID(HDChainID& chainID);\n     \n     bool GenerateBip32Structure(const std::string& chainpath, unsigned char (&vchOut)[32], bool useSeed=false);\n     CPubKey GenerateNewKey(int index=-1);\n@@ -102,6 +123,51 @@ class WalletModel\n     }\n };\n \n+/** A key allocated from the key pool. */\n+class CReserveKey\n+{\n+protected:\n+    Wallet* pwallet;\n+    int64_t nIndex;\n+    CPubKey vchPubKey;\n+public:\n+    CReserveKey(Wallet* pwalletIn)\n+    {\n+        nIndex = -1;\n+        pwallet = pwalletIn;\n+    }\n+\n+    ~CReserveKey()\n+    {\n+        ReturnKey();\n+    }\n+\n+    void ReturnKey();\n+    virtual bool GetReservedKey(CPubKey &pubkey);\n+    void KeepKey();\n+};\n+\n+class CHDReserveKey : public CReserveKey\n+{\n+protected:\n+    CPubKey vchPubKey;\n+    HDChainID chainID;\n+public:\n+    CHDReserveKey(Wallet* pwalletIn) : CReserveKey(pwalletIn)\n+    {\n+        pwalletIn->HDGetActiveChainID(chainID);\n+    }\n+\n+    ~CHDReserveKey()\n+    {\n+        ReturnKey();\n+    }\n+\n+    void ReturnKey();\n+    bool GetReservedKey(CPubKey &pubkey);\n+    void KeepKey();\n+};\n+\n }\n \n #endif // BITCOIN_COREWALLT_WALLET_H"
      },
      {
        "sha": "3dc73096ec085edc828af7a55c6aaf945d31641d",
        "filename": "src/corewallet/crypter.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 0,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f29c400eed6d77df835a08d63a15faa6943f04a2/src/corewallet/crypter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f29c400eed6d77df835a08d63a15faa6943f04a2/src/corewallet/crypter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/crypter.cpp?ref=f29c400eed6d77df835a08d63a15faa6943f04a2",
        "patch": "@@ -291,4 +291,24 @@ bool CCryptoKeyStore::EncryptKeys(CKeyingMaterial& vMasterKeyIn)\n     }\n     return true;\n }\n+\n+bool CCryptoKeyStore::EncryptSeed(const CKeyingMaterial& seedIn, const uint256& seedPubHash, std::vector<unsigned char> &vchCiphertext) const\n+{\n+    LOCK(cs_KeyStore);\n+\n+    if (!EncryptSecret(vMasterKey, seedIn, seedPubHash, vchCiphertext))\n+        return false;\n+\n+    return true;\n+}\n+\n+bool CCryptoKeyStore::DecryptSeed(const std::vector<unsigned char>& vchCiphertextIn, const uint256& seedPubHash, CKeyingMaterial& seedOut) const\n+{\n+    LOCK(cs_KeyStore);\n+\n+    if (!DecryptSecret(vMasterKey, vchCiphertextIn, seedPubHash, seedOut))\n+        return false;\n+    \n+    return true;\n+}\n }; //end namespace\n\\ No newline at end of file"
      },
      {
        "sha": "d592806e795f7e70181d582ab9245e7a63768be3",
        "filename": "src/corewallet/crypter.h",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f29c400eed6d77df835a08d63a15faa6943f04a2/src/corewallet/crypter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f29c400eed6d77df835a08d63a15faa6943f04a2/src/corewallet/crypter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/crypter.h?ref=f29c400eed6d77df835a08d63a15faa6943f04a2",
        "patch": "@@ -112,7 +112,7 @@ class CCrypter\n /** Keystore which keeps the private keys encrypted.\n  * It derives from the basic key store, which is used if no encryption is active.\n  */\n-class CCryptoKeyStore : public CDerivingKeyStore\n+class CCryptoKeyStore : public CBasicKeyStore\n {\n private:\n     CryptedKeyMap mapCryptedKeys;\n@@ -193,6 +193,9 @@ class CCryptoKeyStore : public CDerivingKeyStore\n      * Note: Called without locks held.\n      */\n     boost::signals2::signal<void (CCryptoKeyStore* wallet)> NotifyStatusChanged;\n+\n+    bool EncryptSeed(const CKeyingMaterial& seedIn, const uint256& seedPubHash, std::vector<unsigned char> &vchCiphertext) const;\n+    bool DecryptSeed(const std::vector<unsigned char>& vchCiphertextIn, const uint256& seedPubHash, CKeyingMaterial& seedOut) const;\n };\n }; //end namespace\n #endif // BITCOIN_WALLET_CRYPTER_H"
      },
      {
        "sha": "79998164e4226dba84bede20bcb818daa3e2b620",
        "filename": "src/corewallet/hdkeystore.cpp",
        "status": "added",
        "additions": 275,
        "deletions": 0,
        "changes": 275,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f29c400eed6d77df835a08d63a15faa6943f04a2/src/corewallet/hdkeystore.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f29c400eed6d77df835a08d63a15faa6943f04a2/src/corewallet/hdkeystore.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/hdkeystore.cpp?ref=f29c400eed6d77df835a08d63a15faa6943f04a2",
        "patch": "@@ -0,0 +1,275 @@\n+// Copyright (c) 2015 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"corewallet/hdkeystore.h\"\n+\n+#include \"base58.h\"\n+#include \"util.h\"\n+#include \"utilstrencodings.h\"\n+\n+#include <boost/algorithm/string.hpp>\n+#include <boost/foreach.hpp>\n+\n+namespace CoreWallet {\n+bool CHDKeyStore::AddMasterSeed(const HDChainID& hash, const CKeyingMaterial& masterSeed)\n+{\n+    LOCK(cs_KeyStore);\n+    if (IsCrypted())\n+    {\n+        std::vector<unsigned char> vchCryptedSecret;\n+        if (!EncryptSeed(masterSeed, hash, vchCryptedSecret))\n+            return false;\n+\n+        mapHDCryptedMasterSeeds[hash] = vchCryptedSecret;\n+        return true;\n+    }\n+    mapHDMasterSeeds[hash] = masterSeed;\n+    return true;\n+}\n+\n+bool CHDKeyStore::AddCryptedMasterSeed(const HDChainID& hash, const std::vector<unsigned char>& vchCryptedSecret)\n+{\n+    LOCK(cs_KeyStore);\n+    mapHDCryptedMasterSeeds[hash] = vchCryptedSecret;\n+    return true;\n+}\n+\n+bool CHDKeyStore::GetMasterSeed(const HDChainID& hash, CKeyingMaterial& seedOut) const\n+{\n+    LOCK(cs_KeyStore);\n+    if (!IsCrypted())\n+    {\n+        std::map<HDChainID, CKeyingMaterial >::const_iterator it=mapHDMasterSeeds.find(hash);\n+        if (it == mapHDMasterSeeds.end())\n+            return false;\n+\n+        seedOut = it->second;\n+        return true;\n+    }\n+    else\n+    {\n+        std::map<HDChainID, std::vector<unsigned char> >::const_iterator it=mapHDCryptedMasterSeeds.find(hash);\n+        if (it == mapHDCryptedMasterSeeds.end())\n+            return false;\n+\n+        std::vector<unsigned char> vchCryptedSecret = it->second;\n+        if (!DecryptSeed(vchCryptedSecret, hash, seedOut))\n+            return false;\n+\n+        return true;\n+    }\n+    return false;\n+}\n+\n+bool CHDKeyStore::EncryptSeeds()\n+{\n+    LOCK(cs_KeyStore);\n+    for (std::map<HDChainID, CKeyingMaterial >::iterator it = mapHDMasterSeeds.begin(); it != mapHDMasterSeeds.end(); ++it)\n+    {\n+        std::vector<unsigned char> vchCryptedSecret;\n+        if (!EncryptSeed(it->second, it->first, vchCryptedSecret))\n+            return false;\n+        AddCryptedMasterSeed(it->first, vchCryptedSecret);\n+    }\n+    mapHDMasterSeeds.clear();\n+    return true;\n+}\n+\n+bool CHDKeyStore::GetCryptedMasterSeed(const HDChainID& hash, std::vector<unsigned char>& vchCryptedSecret) const\n+{\n+    LOCK(cs_KeyStore);\n+    if (!IsCrypted())\n+        return false;\n+\n+    std::map<HDChainID, std::vector<unsigned char> >::const_iterator it=mapHDCryptedMasterSeeds.find(hash);\n+    if (it == mapHDCryptedMasterSeeds.end())\n+        return false;\n+\n+    vchCryptedSecret = it->second;\n+    return true;\n+}\n+\n+bool CHDKeyStore::HaveKey(const CKeyID &address) const\n+{\n+    LOCK(cs_KeyStore);\n+    if (mapHDPubKeys.count(address) > 0)\n+        return true;\n+\n+    return CCryptoKeyStore::HaveKey(address);\n+}\n+\n+bool CHDKeyStore::LoadHDPubKey(const CHDPubKey &pubkey)\n+{\n+    LOCK(cs_KeyStore);\n+    mapHDPubKeys[pubkey.pubkey.GetID()] = pubkey;\n+    return true;\n+}\n+\n+bool CHDKeyStore::GetAvailableChainIDs(std::vector<HDChainID>& chainIDs)\n+{\n+    LOCK(cs_KeyStore);\n+    chainIDs.clear();\n+\n+    if (IsCrypted())\n+    {\n+        for (std::map<HDChainID, std::vector<unsigned char> >::iterator it = mapHDCryptedMasterSeeds.begin(); it != mapHDCryptedMasterSeeds.end(); ++it) {\n+            chainIDs.push_back(it->first);\n+        }\n+    }\n+    else\n+    {\n+        for (std::map<HDChainID, CKeyingMaterial >::iterator it = mapHDMasterSeeds.begin(); it != mapHDMasterSeeds.end(); ++it) {\n+            chainIDs.push_back(it->first);\n+        }\n+    }\n+    \n+    return true;\n+}\n+\n+bool CHDKeyStore::GetKey(const CKeyID &address, CKey &keyOut) const\n+{\n+    LOCK(cs_KeyStore);\n+\n+    std::map<CKeyID, CHDPubKey>::const_iterator mi = mapHDPubKeys.find(address);\n+    if (mi != mapHDPubKeys.end())\n+    {\n+        if (!DeriveKey(mi->second, keyOut))\n+            return false;\n+\n+        return true;\n+    }\n+\n+    return CCryptoKeyStore::GetKey(address, keyOut);\n+}\n+\n+bool CHDKeyStore::GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const\n+{\n+    LOCK(cs_KeyStore);\n+\n+    std::map<CKeyID, CHDPubKey>::const_iterator mi = mapHDPubKeys.find(address);\n+    if (mi != mapHDPubKeys.end())\n+    {\n+        vchPubKeyOut = mi->second.pubkey;\n+        return true;\n+    }\n+\n+    return CCryptoKeyStore::GetPubKey(address, vchPubKeyOut);\n+}\n+\n+bool CHDKeyStore::DeriveKey(const CHDPubKey hdPubKey, CKey& keyOut) const\n+{\n+    //this methode required no locking\n+    \n+    std::string chainPath = hdPubKey.chainPath;\n+    std::vector<std::string> pathFragments;\n+    boost::split(pathFragments, chainPath, boost::is_any_of(\"/\"));\n+\n+    LogPrintf(\"hdwallet\", \"derive key %s\\n\", chainPath);\n+    CExtKey extKey;\n+    CExtKey parentKey;\n+    BOOST_FOREACH(std::string fragment, pathFragments)\n+    {\n+        bool harden = false;\n+        if (*fragment.rbegin() == '\\'')\n+        {\n+            harden = true;\n+            fragment = fragment.substr(0,fragment.size()-1);\n+        }\n+\n+        if (fragment == \"m\")\n+        {\n+            CExtKey bip32MasterKey;\n+            CKeyingMaterial masterSeed;\n+\n+            // get master seed\n+            if (!GetMasterSeed(hdPubKey.chainHash, masterSeed))\n+                return false;\n+\n+            bip32MasterKey.SetMaster(&masterSeed[0], masterSeed.size());\n+            parentKey = bip32MasterKey;\n+        }\n+        else if (fragment == \"c\")\n+        {\n+            return false;\n+        }\n+        else\n+        {\n+            CExtKey childKey;\n+            int32_t nIndex;\n+            if (!ParseInt32(fragment,&nIndex))\n+                return false;\n+            parentKey.Derive(childKey, (harden ? 0x80000000 : 0)+nIndex);\n+            parentKey = childKey;\n+        }\n+    }\n+    keyOut = parentKey.key;\n+    LogPrintf(\"hdwallet\", \"derived key with adr: %s\\n\", CBitcoinAddress(keyOut.GetPubKey().GetID()).ToString());\n+    return true;\n+}\n+\n+bool CHDKeyStore::DeriveHDPubKeyAtIndex(const HDChainID chainId, CHDPubKey& hdPubKeyOut, unsigned int nIndex, bool internal) const\n+{\n+    CHDChain hdChain;\n+    if (!GetChain(chainId, hdChain))\n+        return false;\n+\n+    if ( (internal && !hdChain.internalPubKey.pubkey.IsValid()) || !hdChain.externalPubKey.pubkey.IsValid())\n+        throw std::runtime_error(\"CHDKeyStore::HDGetChildPubKeyAtIndex(): Missing HD extended pubkey!\");\n+\n+    if (nIndex >= 0x80000000)\n+        throw std::runtime_error(\"CHDKeyStore::HDGetChildPubKeyAtIndex(): No more available keys!\");\n+\n+    CExtPubKey useExtKey = internal ? hdChain.internalPubKey : hdChain.externalPubKey;\n+    CExtPubKey childKey;\n+    if (!useExtKey.Derive(childKey, nIndex))\n+        throw std::runtime_error(\"CHDKeyStore::HDGetChildPubKeyAtIndex(): Key deriving failed!\");\n+\n+    hdPubKeyOut.pubkey = childKey.pubkey;\n+    hdPubKeyOut.chainHash = chainId;\n+    hdPubKeyOut.nChild = nIndex;\n+    hdPubKeyOut.chainPath = hdChain.chainPath;\n+    hdPubKeyOut.internal = internal;\n+    boost::replace_all(hdPubKeyOut.chainPath, \"c\", itostr(internal)); //replace the chain switch index\n+    hdPubKeyOut.chainPath += \"/\"+itostr(nIndex);\n+\n+    return true;\n+}\n+\n+unsigned int CHDKeyStore::GetNextChildIndex(const HDChainID& chainId, bool internal)\n+{\n+    std::vector<unsigned int> vIndices;\n+\n+    {\n+        LOCK(cs_KeyStore);\n+        //get next unused child index\n+        for (std::map<CKeyID, CHDPubKey>::iterator it = mapHDPubKeys.begin(); it != mapHDPubKeys.end(); ++it)\n+            if (it->second.chainHash == chainId && it->second.internal == internal)\n+                vIndices.push_back(it->second.nChild);\n+    }\n+\n+    for (unsigned int i=0;i<0x80000000;i++)\n+        if (std::find(vIndices.begin(), vIndices.end(), i) == vIndices.end())\n+            return i;\n+\n+    return 0;\n+}\n+\n+bool CHDKeyStore::AddChain(const CHDChain& chain)\n+{\n+    LOCK(cs_KeyStore);\n+    mapChains[chain.chainHash] = chain;\n+    return true;\n+}\n+\n+bool CHDKeyStore::GetChain(const HDChainID chainId, CHDChain& chainOut) const\n+{\n+    LOCK(cs_KeyStore);\n+    std::map<HDChainID, CHDChain>::const_iterator it=mapChains.find(chainId);\n+    if (it == mapChains.end())\n+        return false;\n+\n+    chainOut = it->second;\n+    return true;\n+}\n+}; //end namespace\n\\ No newline at end of file"
      },
      {
        "sha": "400f89a531552339761c9015ab95a457f6a60d02",
        "filename": "src/corewallet/hdkeystore.h",
        "status": "added",
        "additions": 171,
        "deletions": 0,
        "changes": 171,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f29c400eed6d77df835a08d63a15faa6943f04a2/src/corewallet/hdkeystore.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f29c400eed6d77df835a08d63a15faa6943f04a2/src/corewallet/hdkeystore.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/hdkeystore.h?ref=f29c400eed6d77df835a08d63a15faa6943f04a2",
        "patch": "@@ -0,0 +1,171 @@\n+// Copyright (c) 2015 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_WALLET_HDKEYSTORE_H\n+#define BITCOIN_WALLET_HDKEYSTORE_H\n+\n+#include \"keystore.h\"\n+#include \"corewallet/crypter.h\"\n+#include \"serialize.h\"\n+#include \"pubkey.h\"\n+\n+typedef uint256 HDChainID;\n+\n+namespace CoreWallet {\n+/** hdpublic key for a persistant store. */\n+class CHDPubKey\n+{\n+public:\n+    static const int CURRENT_VERSION=1;\n+    int nVersion;\n+    CPubKey pubkey; //the acctual pubkey\n+    unsigned int nChild; //child index\n+    HDChainID chainHash; //hash of the chains master pubkey\n+    std::string chainPath; //individual key chainpath like m/44'/0'/0'/0/1\n+    bool internal;\n+\n+    CHDPubKey()\n+    {\n+        SetNull();\n+    }\n+\n+    bool IsValid()\n+    {\n+        return pubkey.IsValid();\n+    }\n+\n+    void SetNull()\n+    {\n+        nVersion = CHDPubKey::CURRENT_VERSION;\n+        chainHash.SetNull();\n+        chainPath.clear();\n+    }\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        READWRITE(this->nVersion);\n+        nVersion = this->nVersion;\n+\n+        READWRITE(pubkey);\n+        READWRITE(nChild);\n+        READWRITE(chainHash);\n+        READWRITE(chainPath);\n+        READWRITE(internal);\n+    }\n+};\n+\n+/** class for representing a hd chain of keys. */\n+class CHDChain\n+{\n+public:\n+    static const int CURRENT_VERSION=1;\n+    int nVersion;\n+    int64_t nCreateTime; // 0 means unknown\n+\n+    HDChainID chainHash; //hash() of the masterpubkey\n+    std::string chainPath; //something like \"m'/44'/0'/0'/c\"\n+    CExtPubKey externalPubKey;\n+    CExtPubKey internalPubKey; // pubkey.IsValid() == false means only use external chain\n+\n+    CHDChain()\n+    {\n+        SetNull();\n+    }\n+\n+    CHDChain(int64_t nCreateTime_)\n+    {\n+        SetNull();\n+        nCreateTime = nCreateTime_;\n+    }\n+\n+    bool IsValid()\n+    {\n+        return externalPubKey.pubkey.IsValid();\n+    }\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        READWRITE(this->nVersion);\n+        nVersion = this->nVersion;\n+\n+        READWRITE(nCreateTime);\n+        READWRITE(chainHash);\n+        READWRITE(chainPath);\n+        READWRITE(externalPubKey);\n+        READWRITE(internalPubKey);\n+    }\n+\n+    void SetNull()\n+    {\n+        nVersion = CHDChain::CURRENT_VERSION;\n+        nCreateTime = 0;\n+        chainHash.SetNull();\n+    }\n+};\n+\n+class CHDKeyStore : public CCryptoKeyStore\n+{\n+protected:\n+    std::map<HDChainID, CKeyingMaterial > mapHDMasterSeeds; //master seeds are stored outside of CHDChain (crypto)\n+    std::map<HDChainID, std::vector<unsigned char> > mapHDCryptedMasterSeeds;\n+    std::map<CKeyID, CHDPubKey> mapHDPubKeys; //all hd pubkeys of all chains\n+    std::map<HDChainID, CHDChain> mapChains; //all available chains\n+\n+    //!derive key from a CHDPubKey object\n+    bool DeriveKey(const CHDPubKey hdPubKey, CKey& keyOut) const;\n+\n+public:\n+    //!add a master seed with a given pubkeyhash (memory only)\n+    virtual bool AddMasterSeed(const HDChainID& pubkeyhash, const CKeyingMaterial& masterSeed);\n+\n+    //!add a crypted master seed with a given pubkeyhash (memory only)\n+    virtual bool AddCryptedMasterSeed(const HDChainID& hash, const std::vector<unsigned char>& vchCryptedSecret);\n+\n+    //!encrypt existing uncrypted seeds and remove unencrypted data\n+    virtual bool EncryptSeeds();\n+\n+    //!export the master seed from a given chain id (hash of the master pub key)\n+    virtual bool GetMasterSeed(const HDChainID& hash, CKeyingMaterial& seedOut) const;\n+\n+    //!get the encrypted master seed of a giveb chain id\n+    virtual bool GetCryptedMasterSeed(const HDChainID& hash, std::vector<unsigned char>& vchCryptedSecret) const;\n+\n+    //!writes all available chain ids to a vector\n+    virtual bool GetAvailableChainIDs(std::vector<HDChainID>& chainIDs);\n+\n+    //!add a CHDPubKey object to the keystore (memory only)\n+    bool LoadHDPubKey(const CHDPubKey &pubkey);\n+\n+\n+    //!add a new chain to the keystore (memory only)\n+    bool AddChain(const CHDChain& chain);\n+\n+    //!writes a chain defined by given chainId to chainOut, returns false if not found\n+    bool GetChain(const HDChainID chainId, CHDChain& chainOut) const;\n+\n+    //!Derives a hdpubkey object in a given chain defined by chainId from the existing external oder internal chain root pub key\n+    bool DeriveHDPubKeyAtIndex(const HDChainID chainId, CHDPubKey& hdPubKeyOut, unsigned int nIndex, bool internal) const;\n+\n+    /**\n+     * Get next available index for a child key in chain defined by given chain id\n+     * @return next available index\n+     * @warning This will \"fill gaps\". If you have m/0/0, m/0/1, m/0/2, m/0/100 it will return 3 (m/0/3)\n+     */\n+    unsigned int GetNextChildIndex(const HDChainID& chainId, bool internal);\n+\n+    //!check if a wallet has a certain key\n+    bool HaveKey(const CKeyID &address) const;\n+\n+    //!get a key with given keyid for signing, etc. (private key operation)\n+    bool GetKey(const CKeyID &address, CKey &keyOut) const;\n+\n+    //!get a pubkey with given keyid for verifiying, etc.\n+    bool GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const;\n+};\n+};  //end namespace\n+#endif // BITCOIN_WALLET_HDKEYSTORE_H\n\\ No newline at end of file"
      }
    ]
  },
  {
    "sha": "a43c52031ceaaf735bec4d6513ac451906f34a4c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphNDNjNTIwMzFjZWFhZjczNWJlYzRkNjUxM2FjNDUxOTA2ZjM0YTRj",
    "commit": {
      "author": {
        "name": "Jonas Schnelli",
        "email": "jonas.schnelli@include7.ch",
        "date": "2015-06-21T19:44:12Z"
      },
      "committer": {
        "name": "Jonas Schnelli",
        "email": "jonas.schnelli@include7.ch",
        "date": "2015-07-08T14:57:53Z"
      },
      "message": "[corewallet] add multiwallet map lock",
      "tree": {
        "sha": "5fc126b2f4a2aab1888726f1c8738f0dddfe4ceb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5fc126b2f4a2aab1888726f1c8738f0dddfe4ceb"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a43c52031ceaaf735bec4d6513ac451906f34a4c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a43c52031ceaaf735bec4d6513ac451906f34a4c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a43c52031ceaaf735bec4d6513ac451906f34a4c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a43c52031ceaaf735bec4d6513ac451906f34a4c/comments",
    "author": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f29c400eed6d77df835a08d63a15faa6943f04a2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f29c400eed6d77df835a08d63a15faa6943f04a2",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f29c400eed6d77df835a08d63a15faa6943f04a2"
      }
    ],
    "stats": {
      "total": 52,
      "additions": 34,
      "deletions": 18
    },
    "files": [
      {
        "sha": "7844f3f3f8adcf3f0212c8d0f640f033e8fc977f",
        "filename": "src/corewallet/corewallet.cpp",
        "status": "modified",
        "additions": 33,
        "deletions": 18,
        "changes": 51,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a43c52031ceaaf735bec4d6513ac451906f34a4c/src/corewallet/corewallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a43c52031ceaaf735bec4d6513ac451906f34a4c/src/corewallet/corewallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet.cpp?ref=a43c52031ceaaf735bec4d6513ac451906f34a4c",
        "patch": "@@ -57,6 +57,7 @@ void Manager::ReadWalletLists()\n     if (!multiwalletFile.IsNull())\n     {\n         try {\n+            LOCK(cs_mapWallets);\n             multiwalletFile >> mapWallets;\n         } catch (const std::exception&) {\n             LogPrintf(\"CoreWallet: could not read multiwallet metadata file (non-fatal)\");\n@@ -68,7 +69,10 @@ void Manager::WriteWalletList()\n {\n     CAutoFile multiwalletFile(fopen((GetDataDir() / DEFAULT_WALLETS_METADATA_FILE).string().c_str(), \"wb\"), SER_DISK, CLIENT_VERSION);\n     if (!multiwalletFile.IsNull())\n+    {\n+        LOCK(cs_mapWallets);\n         multiwalletFile << mapWallets;\n+    }\n }\n \n void LoadAsModule(std::string& warningString, std::string& errorString, bool& stopInit)\n@@ -78,15 +82,19 @@ void LoadAsModule(std::string& warningString, std::string& errorString, bool& st\n \n Wallet* Manager::AddNewWallet(const std::string& walletID)\n {\n-    if (mapWallets.find(walletID) != mapWallets.end())\n-        throw std::runtime_error(_(\"walletid already exists\"));\n-    \n-    if (!CheckFilenameString(walletID))\n-        throw std::runtime_error(_(\"wallet ids can only contain A-Za-z0-9._- chars\"));\n-    \n-    Wallet *newWallet = new Wallet(walletID);\n-    mapWallets[walletID] = WalletModel(walletID, newWallet);\n-    \n+    Wallet *newWallet = NULL;\n+    LOCK(cs_mapWallets);\n+    {\n+        if (mapWallets.find(walletID) != mapWallets.end())\n+            throw std::runtime_error(_(\"walletid already exists\"));\n+        \n+        if (!CheckFilenameString(walletID))\n+            throw std::runtime_error(_(\"wallet ids can only contain A-Za-z0-9._- chars\"));\n+        \n+        newWallet = new Wallet(walletID);\n+        mapWallets[walletID] = WalletModel(walletID, newWallet);\n+    }\n+\n     WriteWalletList();\n     return newWallet;\n }\n@@ -95,15 +103,18 @@ Wallet* Manager::GetWalletWithID(const std::string& walletIDIn)\n {\n     std::string walletID = walletIDIn;\n \n-    if (walletID == \"\" && mapWallets.size() == 1)\n-        walletID = mapWallets.begin()->first;\n-\n-    if (mapWallets.find(walletID) != mapWallets.end())\n+    LOCK(cs_mapWallets);\n     {\n-        if (!mapWallets[walletID].pWallet) //is it closed?\n-            mapWallets[walletID].pWallet = new Wallet(walletID);\n+        if (walletID == \"\" && mapWallets.size() == 1)\n+            walletID = mapWallets.begin()->first;\n \n-        return mapWallets[walletID].pWallet;\n+        if (mapWallets.find(walletID) != mapWallets.end())\n+        {\n+            if (!mapWallets[walletID].pWallet) //is it closed?\n+                mapWallets[walletID].pWallet = new Wallet(walletID);\n+\n+            return mapWallets[walletID].pWallet;\n+        }\n     }\n     \n     return NULL;\n@@ -113,8 +124,12 @@ std::vector<std::string> Manager::GetWalletIDs()\n {\n     std::vector<std::string> vIDs;\n     std::pair<std::string, WalletModel> walletAndMetadata; // what a map<int, int> is made of\n-    BOOST_FOREACH(walletAndMetadata, mapWallets) {\n-        vIDs.push_back(walletAndMetadata.first);\n+\n+    LOCK(cs_mapWallets);\n+    {\n+        BOOST_FOREACH(walletAndMetadata, mapWallets) {\n+            vIDs.push_back(walletAndMetadata.first);\n+        }\n     }\n     return vIDs;\n }"
      },
      {
        "sha": "e0108f9f85e4fdcb7387497d243c4c188b6da76c",
        "filename": "src/corewallet/corewallet.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a43c52031ceaaf735bec4d6513ac451906f34a4c/src/corewallet/corewallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a43c52031ceaaf735bec4d6513ac451906f34a4c/src/corewallet/corewallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet.h?ref=a43c52031ceaaf735bec4d6513ac451906f34a4c",
        "patch": "@@ -21,6 +21,7 @@ namespace CoreWallet {\n         Wallet* AddNewWallet(const std::string& walletID);\n         void SyncTransaction(const CTransaction& tx, const CBlock* pblock);\n     protected:\n+        CCriticalSection cs_mapWallets;\n         std::map<std::string, WalletModel> mapWallets;\n         void WriteWalletList();\n         void ReadWalletLists();"
      }
    ]
  },
  {
    "sha": "b7ff3f90f668d3315655517998af8b5ce030787d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiN2ZmM2Y5MGY2NjhkMzMxNTY1NTUxNzk5OGFmOGI1Y2UwMzA3ODdk",
    "commit": {
      "author": {
        "name": "Jonas Schnelli",
        "email": "jonas.schnelli@include7.ch",
        "date": "2015-06-26T09:07:03Z"
      },
      "committer": {
        "name": "Jonas Schnelli",
        "email": "jonas.schnelli@include7.ch",
        "date": "2015-07-08T14:57:54Z"
      },
      "message": "[corewallet] adapt main wallet HD PR to corewallet",
      "tree": {
        "sha": "1ecfe74ed576814043258b127743e445d3549e0a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1ecfe74ed576814043258b127743e445d3549e0a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b7ff3f90f668d3315655517998af8b5ce030787d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b7ff3f90f668d3315655517998af8b5ce030787d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b7ff3f90f668d3315655517998af8b5ce030787d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b7ff3f90f668d3315655517998af8b5ce030787d/comments",
    "author": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a43c52031ceaaf735bec4d6513ac451906f34a4c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a43c52031ceaaf735bec4d6513ac451906f34a4c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a43c52031ceaaf735bec4d6513ac451906f34a4c"
      }
    ],
    "stats": {
      "total": 373,
      "additions": 90,
      "deletions": 283
    },
    "files": [
      {
        "sha": "42be0081d51390ad1736ec9cb60e3abe9306fff1",
        "filename": "src/corewallet/corewallet_db.cpp",
        "status": "modified",
        "additions": 37,
        "deletions": 29,
        "changes": 66,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b7ff3f90f668d3315655517998af8b5ce030787d/src/corewallet/corewallet_db.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b7ff3f90f668d3315655517998af8b5ce030787d/src/corewallet/corewallet_db.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet_db.cpp?ref=b7ff3f90f668d3315655517998af8b5ce030787d",
        "patch": "@@ -139,44 +139,52 @@ bool ReadKeyValue(Wallet* pCoreWallet, CDataStream& ssKey, CDataStream& ssValue,\n             ssValue >> metadata;\n             pCoreWallet->mapAddressBook[CBitcoinAddress(strAddress).Get()] = metadata;\n         }\n-        else if (strType == \"masterkeyid\")\n+        else if (strType == \"hdmasterseed\")\n         {\n-            ssValue >> pCoreWallet->masterKeyID;\n+            uint256 masterPubKeyHash;\n+            CKeyingMaterial masterSeed;\n+            ssKey >> masterPubKeyHash;\n+            ssValue >> masterSeed;\n+            pCoreWallet->AddMasterSeed(masterPubKeyHash, masterSeed);\n         }\n-        else if (strType == \"bip32intpubkey\")\n+        else if (strType == \"hdcryptedmasterseed\")\n         {\n-            ssValue >> pCoreWallet->internalPubKey.pubkey;\n+            uint256 masterPubKeyHash;\n+            std::vector<unsigned char> vchCryptedSecret;\n+            ssKey >> masterPubKeyHash;\n+            ssValue >> vchCryptedSecret;\n+            pCoreWallet->AddCryptedMasterSeed(masterPubKeyHash, vchCryptedSecret);\n         }\n-        else if (strType == \"bip32extpubkey\")\n+        else if (strType == \"hdactivechain\")\n         {\n-            ssValue >> pCoreWallet->externalPubKey.pubkey;\n+            HDChainID chainID;\n+            ssValue >> chainID;\n+            pCoreWallet->HDSetActiveChainID(chainID, false); //don't check if the chain exists because this record could come in before the CHDChain object itself\n         }\n-        else if (strType == \"chainpath\")\n+        else if (strType == \"hdpubkey\")\n         {\n-            ssValue >> pCoreWallet->strChainPath;\n-        }\n-        else if (strType == \"masterseed\")\n-        {\n-            uint32_t seedNum;\n-\n-            ssKey >> seedNum;\n-            ssValue >> pCoreWallet->strMasterseedHex;\n-        }\n-        else if (strType == \"internalpubkey\")\n-        {\n-            ssValue >> pCoreWallet->internalPubKey;\n-        }\n-        else if (strType == \"externalpubkey\")\n-        {\n-            ssValue >> pCoreWallet->externalPubKey;\n+            CHDPubKey hdPubKey;\n+            ssValue >> hdPubKey;\n+            if (!hdPubKey.IsValid())\n+            {\n+                strErr = \"Error reading wallet database: CHDPubKey corrupt\";\n+                return false;\n+            }\n+            if (!pCoreWallet->LoadHDPubKey(hdPubKey))\n+            {\n+                strErr = \"Error reading wallet database: LoadHDPubKey failed\";\n+                return false;\n+            }\n         }\n-        else if (strType == \"extpubkey\")\n+        else if (strType == \"hdchain\")\n         {\n-            CKeyID keyId;\n-            CExtPubKey extPubKey;\n-\n-            ssKey >> keyId;\n-            ssValue >> extPubKey;\n+            CHDChain chain;\n+            ssValue >> chain;\n+            if (!pCoreWallet->AddChain(chain))\n+            {\n+                strErr = \"Error reading wallet database: AddChain failed\";\n+                return false;\n+            }\n         }\n \n "
      },
      {
        "sha": "6d3e4ceb9297e956264a7d98c7b2682b9bbfe586",
        "filename": "src/corewallet/corewallet_rpc.cpp",
        "status": "modified",
        "additions": 35,
        "deletions": 74,
        "changes": 109,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b7ff3f90f668d3315655517998af8b5ce030787d/src/corewallet/corewallet_rpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b7ff3f90f668d3315655517998af8b5ce030787d/src/corewallet/corewallet_rpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet_rpc.cpp?ref=b7ff3f90f668d3315655517998af8b5ce030787d",
        "patch": "@@ -54,22 +54,21 @@ UniValue listwallets(const UniValue& params, bool fHelp);\n UniValue help(const UniValue& params, bool fHelp);\n     \n static const RPCDispatchEntry vDispatchEntries[] = {\n-    { \"getaddress\",                     &getaddress },\n-    { \"listaddresses\",                  &listaddresses },\n+    { \"getnewaddress\",                    &getnewaddress },\n+    { \"listaddresses\",                    &listaddresses },\n \n     { \"hdaddchain\",                       &hdaddchain },\n     { \"hdsetchain\",                       &hdsetchain },\n     { \"hdgetinfo\",                        &hdgetinfo },\n     { \"hdgetaddress\",                     &hdgetaddress },\n     \n     // Multiwallet\n-    { \"addwallet\",                      &addwallet },\n-    { \"listwallets\",                    &listwallets },\n+    { \"addwallet\",                        &addwallet },\n+    { \"listwallets\",                      &listwallets },\n     \n     // Help / Debug\n-    { \"help\",                           &help },\n+    { \"help\",                             &help },\n };\n-\n     \n ///////////////////////////\n // helpers\n@@ -110,13 +109,13 @@ UniValue ValueFromParams(const UniValue& params, const std::string& key)\n ///////////////////////////\n // Keys/Addresses stack\n ///////////////////////////\n-UniValue getaddress(const UniValue& params, bool fHelp)\n+UniValue getnewaddress(const UniValue& params, bool fHelp)\n {\n     Wallet *wallet = WalletFromParams(params);\n     if (fHelp || !wallet)\n         throw RPCHelpException(\n-                            \"getaddress\\n\"\n-                            \"\\nReturns a new Bitcoin address for receiving payments.\\n\"\n+                            \"getnewaddress\\n\"\n+                            \"\\nReturns a new non-deterministic Bitcoin address for receiving payments.\\n\"\n                             \"\\nResult:\\n\"\n                             \"\\\"bitcoinaddress\\\"    (string) The new bitcoin address\\n\"\n                             \"\\nExamples:\\n\"\n@@ -125,39 +124,9 @@ UniValue getaddress(const UniValue& params, bool fHelp)\n                             );\n     \n \n-    UniValue valueIndex = ValueFromParams(params, \"index\");\n-    \n-    CKeyID keyID;\n-    CPubKey newKey;\n-    unsigned int index;\n-\n-    if (!valueIndex.isNull())\n-    {\n-        if (valueIndex.isStr())\n-            index = atoi(valueIndex.get_str());\n-        else\n-            index = valueIndex.get_int();\n-    }\n+    //TODO: non deterministic single key generation\n \n-    if (valueIndex.isNull())\n-    {\n-        newKey = wallet->GetNextUnusedKey(index);\n-    }\n-    else\n-    {\n-        newKey = wallet->GetKeyAtIndex(index);\n-    }\n-\n-    keyID = newKey.GetID();\n-    std::stringstream ss; ss << index;\n-    UniValue obj(UniValue::VOBJ);\n-    std::string chainPath = wallet->strChainPath;\n-    boost::replace_all(chainPath, \"c\", \"0\");\n-    boost::replace_all(chainPath, \"k\", ss.str());\n-    obj.push_back(Pair(chainPath, CBitcoinAddress(keyID).ToString()));\n-\n-\n-    return obj;\n+    return NullUniValue;\n }\n \n UniValue listaddresses(const UniValue& params, bool fHelp)\n@@ -185,19 +154,10 @@ UniValue listaddresses(const UniValue& params, bool fHelp)\n         ret.push_back(obj);\n     }\n     \n-    CKeyID masterKeyID = wallet->masterKeyID;\n-    if (!masterKeyID.IsNull())\n-    {\n-        UniValue obj(UniValue::VOBJ);\n-        obj.push_back(Pair(CBitcoinAddress(masterKeyID).ToString(), \"masterkey\"));\n-        ret.push_back(obj);\n-    }\n-    \n     return ret;\n }\n \n     \n-    \n ///////////////////////////\n // MultiWallet stack\n ///////////////////////////\n@@ -219,22 +179,6 @@ UniValue addwallet(const UniValue& params, bool fHelp)\n     std::string walletID = walletIDValue.get_str();\n     Wallet *wallet = CoreWallet::GetManager()->AddNewWallet(walletID);\n \n-    unsigned char vch[32];\n-    UniValue seedHex = ValueFromParams(params, \"seed\");\n-    bool useSeed = false;\n-    if (!seedHex.isNull())\n-    {\n-        std::vector<unsigned char> result = ParseHex(seedHex.get_str());\n-        memcpy((void *)&vch,(const void *)&result.front(),32);\n-        useSeed = true;\n-    }\n-\n-\n-    bool success = wallet->GenerateBip32Structure(\"m/44'/0'/0'/c/k\", vch, useSeed);\n-    if (!useSeed)\n-        obj.push_back(Pair(\"seed\", HexStr(vch, vch+sizeof(vch))));\n-\n-\n     return obj;\n }\n \n@@ -310,7 +254,9 @@ UniValue help(const UniValue& params, bool fHelp)\n \n /*\n  \n-******* HDSTACK ********\n+///////////////////////////\n+// HD/Bip32 stack\n+///////////////////////////\n \n default chainpath after bip44\n m = master key\n@@ -381,12 +327,13 @@ UniValue hdaddchain(const UniValue& params, bool fHelp)\n     if (fGenerateMasterSeed)\n         result.push_back(Pair(\"seed_hex\", HexStr(vSeed)));\n     result.push_back(Pair(\"chainid\", chainId.GetHex()));\n+    result.push_back(Pair(\"chainpath\", chainPath));\n     return result;\n }\n \n UniValue hdsetchain(const UniValue& params, bool fHelp)\n {\n-    if (fHelp || params.size() != 1)\n+    if (fHelp)\n         throw std::runtime_error(\n                             \"hdsetchain <chainid>\\n\"\n                             \"\\nReturns some hd relevant information.\\n\"\n@@ -399,12 +346,13 @@ UniValue hdsetchain(const UniValue& params, bool fHelp)\n                             );\n \n     Wallet *wallet = WalletFromParams(params);\n+    UniValue chainIdParam = ValueFromParams(params, \"chainid\");\n \n     HDChainID chainId;\n-    if (!IsHex(params[0].get_str()))\n+    if (!chainIdParam.isStr() && !IsHex(chainIdParam.get_str()))\n         throw std::runtime_error(\"Chain id format is invalid\");\n \n-    chainId.SetHex(params[0].get_str());\n+    chainId.SetHex(chainIdParam.get_str());\n \n     if (!wallet->HDSetActiveChainID(chainId))\n         throw std::runtime_error(\"Could not set active chain\");\n@@ -436,7 +384,11 @@ UniValue hdgetinfo(const UniValue& params, bool fHelp)\n     if (!wallet->GetAvailableChainIDs(chainIDs))\n         throw std::runtime_error(\"Could not load chain ids\");\n \n-    UniValue result(UniValue::VARR);\n+    HDChainID activeChain;\n+    wallet->HDGetActiveChainID(activeChain);\n+\n+    UniValue result(UniValue::VOBJ);\n+    UniValue chains(UniValue::VARR);\n     BOOST_FOREACH(const HDChainID& chainId, chainIDs)\n     {\n         CHDChain chain;\n@@ -448,9 +400,12 @@ UniValue hdgetinfo(const UniValue& params, bool fHelp)\n         chainObject.push_back(Pair(\"creationtime\", chain.nCreateTime));\n         chainObject.push_back(Pair(\"chainpath\", chain.chainPath));\n \n-        result.push_back(chainObject);\n+\n+        chains.push_back(chainObject);\n     }\n \n+    result.push_back(Pair(\"availablechains\", chains));\n+    result.push_back(Pair(\"activechainid\", activeChain.GetHex()));\n     return result;\n }\n \n@@ -474,13 +429,19 @@ UniValue hdgetaddress(const UniValue& params, bool fHelp)\n                             );\n \n     Wallet *wallet = WalletFromParams(params);\n+    UniValue childIndex = ValueFromParams(params, \"index\");\n \n     CPubKey newKey;\n     std::string keyChainPath;\n-    if (params.size() == 1 && params[0].isNum())\n+    if (!childIndex.isNull())\n     {\n+        if (childIndex.isStr())\n+        {\n+            childIndex.setNumStr(childIndex.get_str());\n+        }\n+\n         HDChainID emptyId;\n-        if (!wallet->HDGetChildPubKeyAtIndex(emptyId, newKey, params[0].get_int()))\n+        if (!wallet->HDGetChildPubKeyAtIndex(emptyId, newKey, keyChainPath, childIndex.get_int()))\n             throw JSONRPCError(RPC_WALLET_KEYPOOL_RAN_OUT, \"Error: Can't generate HD child key\");\n     }\n     else"
      },
      {
        "sha": "57193f8373fc9e645c742d1529724d8082eb0eee",
        "filename": "src/corewallet/corewallet_wallet.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 159,
        "changes": 175,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b7ff3f90f668d3315655517998af8b5ce030787d/src/corewallet/corewallet_wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b7ff3f90f668d3315655517998af8b5ce030787d/src/corewallet/corewallet_wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet_wallet.cpp?ref=b7ff3f90f668d3315655517998af8b5ce030787d",
        "patch": "@@ -18,159 +18,6 @@\n #include <boost/foreach.hpp>\n \n namespace CoreWallet {\n-  \n-bool Wallet::GenerateBip32Structure(const std::string& chainPathIn, unsigned char (&vch)[32], bool useSeed)\n-{\n-    //take the given chainpath and extend it with /0 for external keys and /1 for internal\n-    //example: input chainpath \"m/44'/0'/0'/\" will result in m/44'/0'/0'/0/<nChild> for external and m/44'/0'/0'/1/<nChild> for internal keypair generation\n-    //disk cache the internal and external parent pubkey for faster pubkey generation\n-    if (!walletCacheDB->Write(std::string(\"chainpath\"), chainPathIn, true)) //for easy serialization store the unsigned char[32] as hex string. //TODO: use 32byte binary ser.\n-        throw std::runtime_error(\"CoreWallet::GenerateBip32Structure(): write chainpath failed!\");\n-\n-    strChainPath = chainPathIn;\n-    std::string chainPath = chainPathIn;\n-    boost::to_lower(chainPath);\n-    boost::erase_all(chainPath, \" \");\n-    if (chainPath.size() > 0 && chainPath.back() == '/')\n-        chainPath.resize(chainPath.size() - 1);\n-    \n-    std::vector<std::string> pathFragments;\n-    boost::split(pathFragments, chainPath, boost::is_any_of(\"/\"));\n-    \n-    \n-    CExtKey parentKey;\n-    \n-    BOOST_FOREACH(std::string fragment, pathFragments)\n-    {\n-        bool harden = false;\n-        if (fragment.back() == '\\'')\n-            harden = true;\n-\n-        if (fragment == \"m\")\n-        {\n-            // lets generate a master key seed\n-            //currently seed size is fixed to 256bit\n-            if (!useSeed)\n-            {\n-                RandAddSeedPerfmon();\n-                do {\n-                    GetRandBytes(vch, sizeof(vch));\n-                } while (!eccrypto::Check(vch));\n-            }\n-\n-            CExtKey bip32MasterKey;\n-            bip32MasterKey.SetMaster(vch, sizeof(vch));\n-\n-            CBitcoinExtKey b58key;\n-            b58key.SetKey(bip32MasterKey);\n-            LogPrintf(\"key: %s\", b58key.ToString());\n-\n-            strMasterseedHex = HexStr(vch, vch+sizeof(vch));\n-            uint32_t seedNum = 0;\n-            if (!walletPrivateDB->Write(std::make_pair(std::string(\"masterseed\"),seedNum), strMasterseedHex, true)) //for easy serialization store the unsigned char[32] as hex string. //TODO: use 32byte binary ser.\n-                throw std::runtime_error(\"CoreWallet::GenerateBip32Structure(): Writing masterkeyid failed!\");\n-\n-            parentKey = bip32MasterKey;\n-        }\n-        else if (fragment == \"k\")\n-        {\n-            harden = false;\n-        }\n-        else if (fragment == \"c\")\n-        {\n-            harden = false;\n-            CExtPubKey parentExtPubKey = parentKey.Neuter();\n-            parentExtPubKey.Derive(externalPubKey, 0);\n-            parentExtPubKey.Derive(internalPubKey, 1);\n-\n-            uint32_t keyRingNum = 0;\n-            if (!walletPrivateDB->Write(std::make_pair(std::string(\"externalpubkey\"),keyRingNum), externalPubKey, true))\n-                throw std::runtime_error(\"CoreWallet::GenerateBip32Structure(): Writing masterkeyid failed!\");\n-\n-            if (!walletPrivateDB->Write(std::make_pair(std::string(\"internalpubkey\"),keyRingNum), internalPubKey, true))\n-                throw std::runtime_error(\"CoreWallet::GenerateBip32Structure(): Writing masterkeyid failed!\");\n-        }\n-        else\n-        {\n-            CExtKey childKey;\n-            int nIndex = atoi(fragment.c_str());\n-            parentKey.Derive(childKey, (harden ? 0x80000000 : 0)+nIndex);\n-            parentKey = childKey;\n-        }\n-    }\n-\n-    return true;\n-}\n-    \n-CPubKey Wallet::GenerateNewKey(int indexIn)\n-{\n-    unsigned int useIndex = 0;\n-    if (index >= 0)\n-        useIndex = indexIn;\n-    \n-    CExtPubKey newExtPubKey;\n-    internalPubKey.Derive(newExtPubKey, useIndex);\n-    \n-    int64_t nCreationTime = GetTime();\n-    \n-    CKeyMetadata meta(nCreationTime);\n-    meta.keyidParent = internalPubKey.pubkey.GetID();\n-    meta.nDepth = newExtPubKey.nDepth;\n-    meta.nDerivationIndex = newExtPubKey.nChild;\n-    mapKeyMetadata[newExtPubKey.pubkey.GetID()] = meta;\n-    \n-    return newExtPubKey.pubkey;\n-}\n-\n-CPubKey Wallet::GetNextUnusedKey(unsigned int& usedIndex)\n-{\n-\n-//\n-//            internalPubKey = internalKey.Neuter();\n-//            externalPubKey = externalKey.Neuter();\n-//\n-//            CExtPubKey childPubKey = childKey.Neuter();\n-//            int64_t nCreationTime = GetTime();\n-//\n-//            CKeyMetadata metaInternal(nCreationTime);\n-//            metaInternal.keyidParent = childPubKey.pubkey.GetID();\n-//            metaInternal.nDepth = internalPubKey.nDepth;\n-//            metaInternal.nDerivationIndex = internalPubKey.nChild;\n-//            mapKeyMetadata[internalPubKey.pubkey.GetID()] = metaInternal;\n-//\n-//            CKeyMetadata metaExternal(nCreationTime);\n-//            metaExternal.keyidParent = childPubKey.pubkey.GetID();\n-//            metaExternal.nDepth = internalPubKey.nDepth;\n-//            metaExternal.nDerivationIndex = internalPubKey.nChild;\n-//            mapKeyMetadata[externalPubKey.pubkey.GetID()] = metaExternal;\n-\n-\n-    usedIndex = internalNextPos;\n-    CPubKey pubKey = GetKeyAtIndex(internalNextPos++);\n-    return pubKey;\n-}\n-\n-CPubKey Wallet::GetKeyAtIndex(unsigned int index, bool internal)\n-{\n-    LOCK(cs_coreWallet);\n-\n-    CExtPubKey childKey;\n-    externalPubKey.Derive(childKey,index);\n-\n-    int64_t nCreationTime = GetTime();\n-    CKeyMetadata meta(nCreationTime);\n-    meta.keyidParent = externalPubKey.pubkey.GetID();\n-    meta.nDepth = childKey.nDepth;\n-    meta.nDerivationIndex = childKey.nChild;\n-    mapKeyMetadata[childKey.pubkey.GetID()] = meta;\n-\n-    if (!walletCacheDB->Write(std::make_pair(std::string(\"extpubkey\"),childKey.pubkey.GetID()), childKey, true))\n-        throw std::runtime_error(\"CoreWallet::GenerateBip32Structure(): Writing masterkeyid failed!\");\n-\n-    externalUsedKeysCache.insert(childKey.nDepth);\n-\n-    return childKey.pubkey;\n-}\n \n bool Wallet::LoadKey(const CKey& key, const CPubKey &pubkey)\n {\n@@ -331,10 +178,19 @@ bool Wallet::HDSetChainPath(const std::string& chainPathIn, bool generateMaster,\n     return true;\n }\n \n-bool Wallet::HDGetChildPubKeyAtIndex(const HDChainID& chainID, CPubKey &pubKeyOut, unsigned int nIndex, bool internal)\n+bool Wallet::HDGetChildPubKeyAtIndex(const HDChainID& chainIDIn, CPubKey &pubKeyOut, std::string& newKeysChainpath, unsigned int nIndex, bool internal)\n {\n     AssertLockHeld(cs_coreWallet);\n \n+    //check possible null chainId and load current active chain\n+    CHDChain chain;\n+    HDChainID chainID = chainIDIn;\n+    if (chainID.IsNull())\n+        chainID = activeHDChain;\n+\n+    if (!GetChain(chainID, chain) || !chain.IsValid())\n+        throw std::runtime_error(\"CoreWallet::HDGetChildPubKeyAtIndex(): Selected chain is not vailid!\");\n+\n     CHDPubKey newHdPubKey;\n     if (!DeriveHDPubKeyAtIndex(chainID, newHdPubKey, nIndex, internal))\n         throw std::runtime_error(\"CoreWallet::HDGetChildPubKeyAtIndex(): Deriving child key faild!\");\n@@ -352,6 +208,11 @@ bool Wallet::HDGetChildPubKeyAtIndex(const HDChainID& chainID, CPubKey &pubKeyOu\n         throw std::runtime_error(\"CoreWallet::HDGetChildPubKeyAtIndex(): Writing pubkey failed!\");\n \n     pubKeyOut = newHdPubKey.pubkey;\n+\n+    newKeysChainpath = chain.chainPath;\n+    boost::replace_all(newKeysChainpath, \"c\", itostr(internal)); //replace the chain switch index\n+    newKeysChainpath += \"/\"+itostr(nIndex);\n+\n     return true;\n }\n \n@@ -368,13 +229,9 @@ bool Wallet::HDGetNextChildPubKey(const HDChainID& chainIDIn, CPubKey &pubKeyOut\n         throw std::runtime_error(\"CoreWallet::HDGetNextChildPubKey(): Selected chain is not vailid!\");\n \n     unsigned int nextIndex = GetNextChildIndex(chainID, internal);\n-    if (!HDGetChildPubKeyAtIndex(chainID, pubKeyOut, nextIndex, internal))\n+    if (!HDGetChildPubKeyAtIndex(chainID, pubKeyOut, newKeysChainpath, nextIndex, internal))\n         return false;\n \n-    newKeysChainpath = chain.chainPath;\n-    boost::replace_all(newKeysChainpath, \"c\", itostr(internal)); //replace the chain switch index\n-    newKeysChainpath += \"/\"+itostr(nextIndex);\n-\n     return true;\n }\n "
      },
      {
        "sha": "1508da6aea26238d9cbe6e9a370d551cdd87c018",
        "filename": "src/corewallet/corewallet_wallet.h",
        "status": "modified",
        "additions": 2,
        "deletions": 21,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b7ff3f90f668d3315655517998af8b5ce030787d/src/corewallet/corewallet_wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b7ff3f90f668d3315655517998af8b5ce030787d/src/corewallet/corewallet_wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet_wallet.h?ref=b7ff3f90f668d3315655517998af8b5ce030787d",
        "patch": "@@ -24,20 +24,9 @@ class Wallet : public CHDKeyStore, public CValidationInterface{\n     FileDB *walletPrivateDB;\n     FileDB *walletCacheDB;\n \n-    //! state: current active hd chain\n+    //! state: current active hd chain, must be protected over cs_coreWallet\n     HDChainID activeHDChain;\n \n-    std::string strChainPath;\n-    std::string strMasterseedHex;\n-    CExtPubKey internalPubKey;\n-    CExtPubKey externalPubKey;\n-\n-\n-    std::set<int> externalUsedKeysCache;\n-\n-    unsigned int internalNextPos;\n-    unsigned int externalNextPos;\n-\n     Wallet(std::string strWalletFileIn)\n     {\n         //instantiate a wallet backend object and maps the stored values\n@@ -52,7 +41,7 @@ class Wallet : public CHDKeyStore, public CValidationInterface{\n     bool HDSetChainPath(const std::string& chainPath, bool generateMaster, CKeyingMaterial& vSeed, HDChainID& chainId, bool overwrite = false);\n \n     //!gets a child key from the internal or external chain at given index\n-    bool HDGetChildPubKeyAtIndex(const HDChainID& chainID, CPubKey &pubKeyOut, unsigned int nIndex, bool internal = false);\n+    bool HDGetChildPubKeyAtIndex(const HDChainID& chainID, CPubKey &pubKeyOut, std::string& newKeysChainpath, unsigned int nIndex, bool internal = false);\n \n     //!get next free child key\n     bool HDGetNextChildPubKey(const HDChainID& chainId, CPubKey &pubKeyOut, std::string& newKeysChainpathOut, bool internal = false);\n@@ -66,18 +55,10 @@ class Wallet : public CHDKeyStore, public CValidationInterface{\n     //!set the active chain of keys\n     bool HDGetActiveChainID(HDChainID& chainID);\n     \n-    bool GenerateBip32Structure(const std::string& chainpath, unsigned char (&vchOut)[32], bool useSeed=false);\n-    CPubKey GenerateNewKey(int index=-1);\n-    CPubKey GetNextUnusedKey(unsigned int& usedIndex);\n-    CPubKey GetKeyAtIndex(unsigned int index, bool internal = false);\n-    \n     bool AddKeyPubKey(const CKey& key, const CPubKey &pubkey);\n     bool LoadKeyMetadata(const CPubKey &pubkey, const CoreWallet::CKeyMetadata &metadata);\n     bool LoadKey(const CKey& key, const CPubKey &pubkey);\n     bool SetAddressBook(const CTxDestination& address, const std::string& purpose);\n-    \n-    CKeyID masterKeyID;\n-    unsigned char masterSeed[32];\n };\n \n // WalletModel: a wallet metadata class"
      }
    ]
  },
  {
    "sha": "6a5952114c96dc63f69768097cc6fd68b7ca991c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2YTU5NTIxMTRjOTZkYzYzZjY5NzY4MDk3Y2M2ZmQ2OGI3Y2E5OTFj",
    "commit": {
      "author": {
        "name": "Jonas Schnelli",
        "email": "jonas.schnelli@include7.ch",
        "date": "2015-06-26T13:08:20Z"
      },
      "committer": {
        "name": "Jonas Schnelli",
        "email": "jonas.schnelli@include7.ch",
        "date": "2015-07-08T14:57:54Z"
      },
      "message": "[corewallet] extend receiving, try to refactor WalletTX/Core interaction",
      "tree": {
        "sha": "92f8504c343f9ea2d60634dba45f5a3956808ede",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/92f8504c343f9ea2d60634dba45f5a3956808ede"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6a5952114c96dc63f69768097cc6fd68b7ca991c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6a5952114c96dc63f69768097cc6fd68b7ca991c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6a5952114c96dc63f69768097cc6fd68b7ca991c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6a5952114c96dc63f69768097cc6fd68b7ca991c/comments",
    "author": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b7ff3f90f668d3315655517998af8b5ce030787d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b7ff3f90f668d3315655517998af8b5ce030787d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b7ff3f90f668d3315655517998af8b5ce030787d"
      }
    ],
    "stats": {
      "total": 1489,
      "additions": 1468,
      "deletions": 21
    },
    "files": [
      {
        "sha": "72466997a8a4b2d48326aa592a39de5af2e65956",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 7,
        "deletions": 1,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6a5952114c96dc63f69768097cc6fd68b7ca991c/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6a5952114c96dc63f69768097cc6fd68b7ca991c/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=6a5952114c96dc63f69768097cc6fd68b7ca991c",
        "patch": "@@ -98,10 +98,13 @@ BITCOIN_CORE_H = \\\n   consensus/params.h \\\n   consensus/validation.h \\\n   core_io.h \\\n+\tcorewallet/coreinterface.h \\\n   corewallet/corewallet.h \\\n   corewallet/corewallet_basics.h \\\n   corewallet/corewallet_db.h \\\n+\tcorewallet/corewallet_ismine.h \\\n   corewallet/corewallet_wallet.h \\\n+\tcorewallet/corewallet_wtx.h \\\n   corewallet/crypter.h \\\n   corewallet/hdkeystore.h \\\n   corewallet/logdb.h \\\n@@ -224,10 +227,13 @@ libbitcoin_wallet_a_SOURCES = \\\n # when corewallet enabled\n libbitcoin_corewallet_a_CPPFLAGS = $(BITCOIN_INCLUDES)\n libbitcoin_corewallet_a_SOURCES = \\\n-  corewallet/corewallet.cpp \\\n+  corewallet/coreinterface.cpp \\\n+\tcorewallet/corewallet.cpp \\\n   corewallet/corewallet_db.cpp \\\n+\tcorewallet/corewallet_ismine.cpp \\\n   corewallet/corewallet_rpc.cpp \\\n   corewallet/corewallet_wallet.cpp \\\n+\tcorewallet/corewallet_wtx.cpp \\\n   corewallet/crypter.cpp \\\n   corewallet/hdkeystore.cpp \\\n   corewallet/logdb.cpp \\"
      },
      {
        "sha": "a43fe6b57802958c8b9ea19552f77c47023c611c",
        "filename": "src/corewallet/corewallet.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6a5952114c96dc63f69768097cc6fd68b7ca991c/src/corewallet/corewallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6a5952114c96dc63f69768097cc6fd68b7ca991c/src/corewallet/corewallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet.cpp?ref=6a5952114c96dc63f69768097cc6fd68b7ca991c",
        "patch": "@@ -173,7 +173,19 @@ Manager* GetManager()\n \n void Manager::SyncTransaction(const CTransaction& tx, const CBlock* pblock)\n {\n+    LOCK(cs_mapWallets);\n+    {\n+        std::pair<std::string, WalletModel> walletAndMetadata;\n+        BOOST_FOREACH(walletAndMetadata, mapWallets) {\n+            //TODO: looks ugly\n+            //Open the wallet within the SyncTransaction call is probably a bad idea, need to be changed\n+            if (!mapWallets[walletAndMetadata.first].pWallet) //is it closed?\n+                mapWallets[walletAndMetadata.first].pWallet = new Wallet(walletAndMetadata.first);\n \n+\n+            mapWallets[walletAndMetadata.first].pWallet->SyncTransaction(tx, pblock);\n+        }\n+    }\n }\n \n };\n\\ No newline at end of file"
      },
      {
        "sha": "58eadb38181ba5fb56e4365420352460b9723a16",
        "filename": "src/corewallet/corewallet_basics.h",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6a5952114c96dc63f69768097cc6fd68b7ca991c/src/corewallet/corewallet_basics.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6a5952114c96dc63f69768097cc6fd68b7ca991c/src/corewallet/corewallet_basics.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet_basics.h?ref=6a5952114c96dc63f69768097cc6fd68b7ca991c",
        "patch": "@@ -15,6 +15,14 @@\n \n namespace CoreWallet\n {\n+    enum CREDIT_DEBIT_TYPE\n+    {\n+        CREDIT_DEBIT_TYPE_AVAILABLE = 0,\n+        CREDIT_DEBIT_TYPE_UNCONFIRMED = 1,\n+        CREDIT_DEBIT_TYPE_IMMATURE = 2,\n+        CREDIT_DEBIT_TYPE_DEBIT = 3\n+    };\n+\n     class CAddressBookMetadata\n     {\n     public:"
      },
      {
        "sha": "5be63bb5b9332113cdf3f74d715b6f3594eb484a",
        "filename": "src/corewallet/corewallet_db.cpp",
        "status": "modified",
        "additions": 19,
        "deletions": 0,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6a5952114c96dc63f69768097cc6fd68b7ca991c/src/corewallet/corewallet_db.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6a5952114c96dc63f69768097cc6fd68b7ca991c/src/corewallet/corewallet_db.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet_db.cpp?ref=6a5952114c96dc63f69768097cc6fd68b7ca991c",
        "patch": "@@ -9,6 +9,7 @@\n \n #include \"corewallet/corewallet_db.h\"\n #include \"corewallet/corewallet_wallet.h\"\n+#include \"corewallet/corewallet_wtx.h\"\n \n namespace CoreWallet\n {\n@@ -67,6 +68,16 @@ bool FileDB::WriteHDAchiveChain(const uint256& hash)\n     return Write(std::string(\"hdactivechain\"), hash);\n }\n \n+bool FileDB::WriteTx(uint256 hash, const WalletTx& wtx)\n+{\n+    return Write(std::make_pair(std::string(\"tx\"), hash), wtx);\n+}\n+\n+bool FileDB::EraseTx(uint256 hash)\n+{\n+    return Erase(std::make_pair(std::string(\"tx\"), hash));\n+}\n+\n bool ReadKeyValue(Wallet* pCoreWallet, CDataStream& ssKey, CDataStream& ssValue, std::string& strType, std::string& strErr)\n {\n     try {\n@@ -186,6 +197,14 @@ bool ReadKeyValue(Wallet* pCoreWallet, CDataStream& ssKey, CDataStream& ssValue,\n                 return false;\n             }\n         }\n+        else if (strType == \"tx\")\n+        {\n+            uint256 hash;\n+            ssKey >> hash;\n+            WalletTx wtx;\n+            ssValue >> wtx;\n+            pCoreWallet->AddToWallet(wtx, true);\n+        }\n \n \n "
      },
      {
        "sha": "29cef4efd6928e5b798c8d305c964a48648600e3",
        "filename": "src/corewallet/corewallet_db.h",
        "status": "modified",
        "additions": 5,
        "deletions": 1,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6a5952114c96dc63f69768097cc6fd68b7ca991c/src/corewallet/corewallet_db.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6a5952114c96dc63f69768097cc6fd68b7ca991c/src/corewallet/corewallet_db.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet_db.h?ref=6a5952114c96dc63f69768097cc6fd68b7ca991c",
        "patch": "@@ -13,7 +13,8 @@\n \n namespace CoreWallet\n {\n-    \n+\n+class WalletTx;\n class Wallet;\n \n // FileDB: a wallet file-database based on logdb\n@@ -31,6 +32,9 @@ class FileDB : public CLogDB\n     bool WriteHDChain(const CHDChain& chain);\n     bool WriteHDPubKey(const CHDPubKey& hdPubKey, const CKeyMetadata& keyMeta);\n     bool WriteHDAchiveChain(const uint256& hash);\n+\n+    bool WriteTx(uint256 hash, const WalletTx& wtx);\n+    bool EraseTx(uint256 hash);\n };\n     \n }; // end namespace CoreWallet"
      },
      {
        "sha": "524f9c7f90dd00fffb6090c8d4dd8ef29e1580c3",
        "filename": "src/corewallet/corewallet_ismine.cpp",
        "status": "added",
        "additions": 93,
        "deletions": 0,
        "changes": 93,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6a5952114c96dc63f69768097cc6fd68b7ca991c/src/corewallet/corewallet_ismine.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6a5952114c96dc63f69768097cc6fd68b7ca991c/src/corewallet/corewallet_ismine.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet_ismine.cpp?ref=6a5952114c96dc63f69768097cc6fd68b7ca991c",
        "patch": "@@ -0,0 +1,93 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2014 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"corewallet/corewallet_ismine.h\"\n+\n+#include \"key.h\"\n+#include \"keystore.h\"\n+#include \"script/script.h\"\n+#include \"script/standard.h\"\n+\n+#include <boost/foreach.hpp>\n+\n+namespace CoreWallet\n+{\n+\n+typedef std::vector<unsigned char> valtype;\n+\n+unsigned int HaveKeys(const std::vector<valtype>& pubkeys, const CKeyStore& keystore)\n+{\n+    unsigned int nResult = 0;\n+    BOOST_FOREACH(const valtype& pubkey, pubkeys)\n+    {\n+        CKeyID keyID = CPubKey(pubkey).GetID();\n+        if (keystore.HaveKey(keyID))\n+            ++nResult;\n+    }\n+    return nResult;\n+}\n+\n+isminetype IsMine(const CKeyStore &keystore, const CTxDestination& dest)\n+{\n+    CScript script = GetScriptForDestination(dest);\n+    return IsMine(keystore, script);\n+}\n+\n+isminetype IsMine(const CKeyStore &keystore, const CScript& scriptPubKey)\n+{\n+    std::vector<valtype> vSolutions;\n+    txnouttype whichType;\n+    if (!Solver(scriptPubKey, whichType, vSolutions)) {\n+        if (keystore.HaveWatchOnly(scriptPubKey))\n+            return ISMINE_WATCH_ONLY;\n+        return ISMINE_NO;\n+    }\n+\n+    CKeyID keyID;\n+    switch (whichType)\n+    {\n+    case TX_NONSTANDARD:\n+    case TX_NULL_DATA:\n+        break;\n+    case TX_PUBKEY:\n+        keyID = CPubKey(vSolutions[0]).GetID();\n+        if (keystore.HaveKey(keyID))\n+            return ISMINE_SPENDABLE;\n+        break;\n+    case TX_PUBKEYHASH:\n+        keyID = CKeyID(uint160(vSolutions[0]));\n+        if (keystore.HaveKey(keyID))\n+            return ISMINE_SPENDABLE;\n+        break;\n+    case TX_SCRIPTHASH:\n+    {\n+        CScriptID scriptID = CScriptID(uint160(vSolutions[0]));\n+        CScript subscript;\n+        if (keystore.GetCScript(scriptID, subscript)) {\n+            isminetype ret = IsMine(keystore, subscript);\n+            if (ret == ISMINE_SPENDABLE)\n+                return ret;\n+        }\n+        break;\n+    }\n+    case TX_MULTISIG:\n+    {\n+        // Only consider transactions \"mine\" if we own ALL the\n+        // keys involved. Multi-signature transactions that are\n+        // partially owned (somebody else has a key that can spend\n+        // them) enable spend-out-from-under-you attacks, especially\n+        // in shared-wallet situations.\n+        std::vector<valtype> keys(vSolutions.begin()+1, vSolutions.begin()+vSolutions.size()-1);\n+        if (HaveKeys(keys, keystore) == keys.size())\n+            return ISMINE_SPENDABLE;\n+        break;\n+    }\n+    }\n+\n+    if (keystore.HaveWatchOnly(scriptPubKey))\n+        return ISMINE_WATCH_ONLY;\n+    return ISMINE_NO;\n+}\n+}\n\\ No newline at end of file"
      },
      {
        "sha": "2b053487c37ed341eb32154ff66c8a8651eb2778",
        "filename": "src/corewallet/corewallet_ismine.h",
        "status": "added",
        "additions": 33,
        "deletions": 0,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6a5952114c96dc63f69768097cc6fd68b7ca991c/src/corewallet/corewallet_ismine.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6a5952114c96dc63f69768097cc6fd68b7ca991c/src/corewallet/corewallet_ismine.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet_ismine.h?ref=6a5952114c96dc63f69768097cc6fd68b7ca991c",
        "patch": "@@ -0,0 +1,33 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2014 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_COREWALLETWALLET_COREWALLET_ISMINE_H\n+#define BITCOIN_COREWALLETWALLET_COREWALLET_ISMINE_H\n+\n+#include \"key.h\"\n+#include \"script/standard.h\"\n+\n+class CKeyStore;\n+class CScript;\n+\n+namespace CoreWallet\n+{\n+/** IsMine() return codes */\n+enum isminetype\n+{\n+    ISMINE_NO = 0,\n+    ISMINE_WATCH_ONLY = 1,\n+    ISMINE_SPENDABLE = 2,\n+    ISMINE_ALL = ISMINE_WATCH_ONLY | ISMINE_SPENDABLE\n+};\n+/** used for bitflags of isminetype */\n+typedef uint8_t isminefilter;\n+\n+isminetype IsMine(const CKeyStore& keystore, const CScript& scriptPubKey);\n+isminetype IsMine(const CKeyStore& keystore, const CTxDestination& dest);\n+\n+} //end namespace\n+\n+#endif // BITCOIN_COREWALLETWALLET_COREWALLET_ISMINE_H"
      },
      {
        "sha": "7e4077fd461b4e90b66cc777eacc05fef65bf5a0",
        "filename": "src/corewallet/corewallet_rpc.cpp",
        "status": "modified",
        "additions": 268,
        "deletions": 17,
        "changes": 285,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6a5952114c96dc63f69768097cc6fd68b7ca991c/src/corewallet/corewallet_rpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6a5952114c96dc63f69768097cc6fd68b7ca991c/src/corewallet/corewallet_rpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet_rpc.cpp?ref=6a5952114c96dc63f69768097cc6fd68b7ca991c",
        "patch": "@@ -52,6 +52,10 @@ UniValue listaddresses(const UniValue& params, bool fHelp);\n UniValue addwallet(const UniValue& params, bool fHelp);\n UniValue listwallets(const UniValue& params, bool fHelp);\n UniValue help(const UniValue& params, bool fHelp);\n+UniValue listtransactions(const UniValue& params, bool fHelp);\n+UniValue listunspent(const UniValue& params, bool fHelp);\n+UniValue createtx(const UniValue& params, bool fHelp);\n+UniValue getbalance(const UniValue& params, bool fHelp);\n     \n static const RPCDispatchEntry vDispatchEntries[] = {\n     { \"getnewaddress\",                    &getnewaddress },\n@@ -61,7 +65,13 @@ static const RPCDispatchEntry vDispatchEntries[] = {\n     { \"hdsetchain\",                       &hdsetchain },\n     { \"hdgetinfo\",                        &hdgetinfo },\n     { \"hdgetaddress\",                     &hdgetaddress },\n-    \n+\n+    { \"listtransactions\",                 &listtransactions },\n+    { \"listunspent\",                      &listunspent },\n+\n+    { \"createtx\",                         &createtx },\n+    { \"getbalance\",                       &getbalance },\n+\n     // Multiwallet\n     { \"addwallet\",                        &addwallet },\n     { \"listwallets\",                      &listwallets },\n@@ -93,12 +103,22 @@ Wallet* WalletFromParams(const UniValue& params)\n }\n \n //! search in exiting json object for a key/value pair and returns value\n-UniValue ValueFromParams(const UniValue& params, const std::string& key)\n+UniValue ValueFromParams(const UniValue& params, const std::string& key, UniValue::VType forceType = UniValue::VNULL)\n {\n     if (params.size() > 0 && params[0].isObject())\n     {\n         const UniValue& o = params[0].get_obj();\n-        return find_value(o, key);\n+        UniValue val = find_value(o, key);\n+        if (forceType == UniValue::VNUM && val.isStr())\n+            val.setNumStr(val.get_str()); //convert str to int\n+        if (forceType == UniValue::VBOOL)\n+        {\n+            if (val.isStr() && ( val.get_str() == \"true\" || val.get_str() == \"1\" ))\n+                val.setBool(true);\n+            else\n+                val.setBool(false);\n+        }\n+        return val;\n     }\n     else\n     {\n@@ -137,12 +157,12 @@ UniValue listaddresses(const UniValue& params, bool fHelp)\n                             \"listaddresses\\n\"\n                             \"\\nResult:\\n\"\n                             \"[                     (json array of string)\\n\"\n-                            \"  \\\"bitcoinaddress\\\"  (string) a bitcoin address associated with the given account\\n\"\n+                            \"  \\\"bitcoinaddress\\\"  (string) a bitcoin address\\n\"\n                             \"  ,...\\n\"\n                             \"]\\n\"\n                             \"\\nExamples:\\n\"\n-                            + HelpExampleCli(\"getaddressesbyaccount\", \"\\\"tabby\\\"\")\n-                            + HelpExampleRpc(\"getaddressesbyaccount\", \"\\\"tabby\\\"\")\n+                            + HelpExampleCli(\"listaddresses\", \"\")\n+                            + HelpExampleRpc(\"listaddresses\", \"\")\n                             );\n     UniValue ret(UniValue::VARR);\n     BOOST_FOREACH(const PAIRTYPE(CBitcoinAddress, CAddressBookMetadata)& item, wallet->mapAddressBook)\n@@ -174,12 +194,9 @@ UniValue addwallet(const UniValue& params, bool fHelp)\n                              + HelpExampleRpc(\"addwallet\", \"\\\"anotherwallet\\\"\")\n                              );\n \n-    UniValue obj(UniValue::VOBJ);\n-\n     std::string walletID = walletIDValue.get_str();\n-    Wallet *wallet = CoreWallet::GetManager()->AddNewWallet(walletID);\n-\n-    return obj;\n+    CoreWallet::GetManager()->AddNewWallet(walletID);\n+    return NullUniValue;\n }\n \n UniValue listwallets(const UniValue& params, bool fHelp)\n@@ -429,23 +446,20 @@ UniValue hdgetaddress(const UniValue& params, bool fHelp)\n                             );\n \n     Wallet *wallet = WalletFromParams(params);\n-    UniValue childIndex = ValueFromParams(params, \"index\");\n+    UniValue childIndex = ValueFromParams(params, \"index\", UniValue::VNUM);\n \n     CPubKey newKey;\n     std::string keyChainPath;\n     if (!childIndex.isNull())\n     {\n-        if (childIndex.isStr())\n-        {\n-            childIndex.setNumStr(childIndex.get_str());\n-        }\n-\n+        LOCK(wallet->cs_coreWallet);\n         HDChainID emptyId;\n         if (!wallet->HDGetChildPubKeyAtIndex(emptyId, newKey, keyChainPath, childIndex.get_int()))\n             throw JSONRPCError(RPC_WALLET_KEYPOOL_RAN_OUT, \"Error: Can't generate HD child key\");\n     }\n     else\n     {\n+        LOCK(wallet->cs_coreWallet);\n         HDChainID emptyId;\n         if (!wallet->HDGetNextChildPubKey(emptyId, newKey, keyChainPath))\n             throw JSONRPCError(RPC_WALLET_KEYPOOL_RAN_OUT, \"Error: Can't generate HD child key\");\n@@ -460,6 +474,242 @@ UniValue hdgetaddress(const UniValue& params, bool fHelp)\n     return result;\n }\n \n+void WalletTxToJSON(const Wallet* wallet, const WalletTx& wtx, UniValue& entry)\n+{\n+    int confirms = wtx.GetDepthInMainChain();\n+    entry.push_back(Pair(\"confirmations\", confirms));\n+    if (wtx.IsCoinBase())\n+        entry.push_back(Pair(\"generated\", true));\n+    if (confirms > 0)\n+    {\n+        entry.push_back(Pair(\"blockhash\", wtx.hashBlock.GetHex()));\n+        entry.push_back(Pair(\"blockindex\", wtx.nIndex));\n+    }\n+    uint256 hash = wtx.GetHash();\n+    entry.push_back(Pair(\"txid\", hash.GetHex()));\n+    UniValue conflicts(UniValue::VARR);\n+    BOOST_FOREACH(const uint256& conflict, wallet->GetConflicts(wtx.GetHash()))\n+    conflicts.push_back(conflict.GetHex());\n+    entry.push_back(Pair(\"walletconflicts\", conflicts));\n+    entry.push_back(Pair(\"time\", wtx.GetTxTime()));\n+    entry.push_back(Pair(\"timereceived\", (int64_t)wtx.nTimeReceived));\n+\n+    isminefilter filter = ISMINE_SPENDABLE; //TODO: make filter configurable over params\n+\n+    CAmount nCredit = wallet->GetCredit(wtx, filter);\n+    CAmount nDebit = wtx.GetDebit(filter);\n+    CAmount nNet = nCredit - nDebit;\n+    CAmount nFee = (wtx.IsFromMe(filter) ? wtx.GetValueOut() - nDebit : 0);\n+\n+    entry.push_back(Pair(\"amount\", ValueFromAmount(nNet - nFee)));\n+    if (wtx.IsFromMe(filter))\n+        entry.push_back(Pair(\"fee\", ValueFromAmount(nFee)));\n+\n+\n+\n+    BOOST_FOREACH(const PAIRTYPE(std::string, std::string)& item, wtx.mapValue)\n+    entry.push_back(Pair(item.first, item.second));\n+}\n+\n+UniValue listtransactions(const UniValue& params, bool fHelp)\n+{\n+\n+    Wallet *wallet = WalletFromParams(params);\n+    \n+    LOCK(wallet->cs_coreWallet);\n+    Wallet::TxItems txOrdered = wallet->OrderedTxItems();\n+\n+    UniValue result(UniValue::VARR);\n+\n+    // iterate backwards until we have nCount items to return:\n+    for (Wallet::TxItems::reverse_iterator it = txOrdered.rbegin(); it != txOrdered.rend(); ++it)\n+    {\n+        WalletTx *const pwtx = (*it).second.first;\n+        UniValue entry(UniValue::VOBJ);\n+        WalletTxToJSON(wallet, *pwtx, entry);\n+        result.push_back(entry);\n+    }\n+\n+    return result;\n+}\n+\n+UniValue listunspent(const UniValue& params, bool fHelp)\n+{\n+    Wallet *wallet = WalletFromParams(params);\n+\n+    if (fHelp)\n+        throw std::runtime_error(\n+                            \"listunspent ( minconf maxconf  [\\\"address\\\",...] )\\n\"\n+                            \"\\nReturns array of unspent transaction outputs\\n\"\n+                            \"with between minconf and maxconf (inclusive) confirmations.\\n\"\n+                            \"Optionally filter to only include txouts paid to specified addresses.\\n\"\n+                            \"Results are an array of Objects, each of which has:\\n\"\n+                            \"{txid, vout, scriptPubKey, amount, confirmations}\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. minconf          (numeric, optional, default=1) The minimum confirmations to filter\\n\"\n+                            \"2. maxconf          (numeric, optional, default=9999999) The maximum confirmations to filter\\n\"\n+                            \"3. \\\"addresses\\\"    (string) A json array of bitcoin addresses to filter\\n\"\n+                            \"    [\\n\"\n+                            \"      \\\"address\\\"   (string) bitcoin address\\n\"\n+                            \"      ,...\\n\"\n+                            \"    ]\\n\"\n+                            \"\\nResult\\n\"\n+                            \"[                   (array of json object)\\n\"\n+                            \"  {\\n\"\n+                            \"    \\\"txid\\\" : \\\"txid\\\",        (string) the transaction id \\n\"\n+                            \"    \\\"vout\\\" : n,               (numeric) the vout value\\n\"\n+                            \"    \\\"address\\\" : \\\"address\\\",  (string) the bitcoin address\\n\"\n+                            \"    \\\"account\\\" : \\\"account\\\",  (string) DEPRECATED. The associated account, or \\\"\\\" for the default account\\n\"\n+                            \"    \\\"scriptPubKey\\\" : \\\"key\\\", (string) the script key\\n\"\n+                            \"    \\\"amount\\\" : x.xxx,         (numeric) the transaction amount in btc\\n\"\n+                            \"    \\\"confirmations\\\" : n       (numeric) The number of confirmations\\n\"\n+                            \"  }\\n\"\n+                            \"  ,...\\n\"\n+                            \"]\\n\"\n+\n+                            \"\\nExamples\\n\"\n+                            + HelpExampleCli(\"listunspent\", \"\")\n+                            + HelpExampleCli(\"listunspent\", \"6 9999999 \\\"[\\\\\\\"1PGFqEzfmQch1gKD3ra4k18PNj3tTUUSqg\\\\\\\",\\\\\\\"1LtvqCaApEdUGFkpKMM4MstjcaL4dKg8SP\\\\\\\"]\\\"\")\n+                            + HelpExampleRpc(\"listunspent\", \"6, 9999999 \\\"[\\\\\\\"1PGFqEzfmQch1gKD3ra4k18PNj3tTUUSqg\\\\\\\",\\\\\\\"1LtvqCaApEdUGFkpKMM4MstjcaL4dKg8SP\\\\\\\"]\\\"\")\n+                            );\n+\n+    //RPCTypeCheck(params, boost::assign::list_of(UniValue::VNUM)(UniValue::VNUM)(UniValue::VARR));\n+\n+    int nMinDepth = 1;\n+    UniValue minconf = ValueFromParams(params, \"minconf\", UniValue::VNUM);\n+    if (!minconf.isNull())\n+        nMinDepth = minconf.get_int();\n+\n+    UniValue maxconf = ValueFromParams(params, \"maxconf\", UniValue::VNUM);\n+    int nMaxDepth = 9999999;\n+    if (!maxconf.isNull())\n+        nMaxDepth = maxconf.get_int();\n+\n+    UniValue addresses = ValueFromParams(params, \"addresses\");\n+    std::set<CBitcoinAddress> setAddress;\n+    if (!addresses.isNull())\n+    {\n+        UniValue inputs = addresses.get_array();\n+        for (unsigned int idx = 0; idx < inputs.size(); idx++) {\n+            const UniValue& input = inputs[idx];\n+            CBitcoinAddress address(input.get_str());\n+            if (!address.IsValid())\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid Bitcoin address: \"+input.get_str());\n+            if (setAddress.count(address))\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid parameter, duplicated address: \"+input.get_str());\n+            setAddress.insert(address);\n+        }\n+    }\n+\n+    UniValue results(UniValue::VARR);\n+    std::vector<COutput> vecOutputs;\n+\n+    LOCK(wallet->cs_coreWallet);\n+    wallet->AvailableCoins(vecOutputs, false, NULL, true);\n+    BOOST_FOREACH(const COutput& out, vecOutputs) {\n+        if (out.nDepth < nMinDepth || out.nDepth > nMaxDepth)\n+            continue;\n+\n+        if (setAddress.size()) {\n+            CTxDestination address;\n+            if (!ExtractDestination(out.tx->vout[out.i].scriptPubKey, address))\n+                continue;\n+\n+            if (!setAddress.count(address))\n+                continue;\n+        }\n+\n+        CAmount nValue = out.tx->vout[out.i].nValue;\n+        const CScript& pk = out.tx->vout[out.i].scriptPubKey;\n+        UniValue entry(UniValue::VOBJ);\n+        entry.push_back(Pair(\"txid\", out.tx->GetHash().GetHex()));\n+        entry.push_back(Pair(\"vout\", out.i));\n+        CTxDestination address;\n+        if (ExtractDestination(out.tx->vout[out.i].scriptPubKey, address)) {\n+            entry.push_back(Pair(\"address\", CBitcoinAddress(address).ToString()));\n+        }\n+        entry.push_back(Pair(\"scriptPubKey\", HexStr(pk.begin(), pk.end())));\n+        if (pk.IsPayToScriptHash()) {\n+            CTxDestination address;\n+            if (ExtractDestination(pk, address)) {\n+                const CScriptID& hash = boost::get<CScriptID>(address);\n+                CScript redeemScript;\n+                if (wallet->GetCScript(hash, redeemScript))\n+                    entry.push_back(Pair(\"redeemScript\", HexStr(redeemScript.begin(), redeemScript.end())));\n+            }\n+        }\n+        entry.push_back(Pair(\"amount\",ValueFromAmount(nValue)));\n+        entry.push_back(Pair(\"confirmations\",out.nDepth));\n+        entry.push_back(Pair(\"spendable\", out.fSpendable));\n+        results.push_back(entry);\n+    }\n+    \n+    return results;\n+}\n+\n+UniValue getbalance(const UniValue& params, bool fHelp)\n+{\n+    if (fHelp)\n+        throw std::runtime_error(\n+                            \"getbalance type=(all|available|unconfirmed|immature) includewatchonly=true\\n\"\n+                            \"\\nIf account is not specified, returns the server's total available balance.\\n\"\n+                            \"If account is specified (DEPRECATED), returns the balance in the account.\\n\"\n+                            \"Note that the account \\\"\\\" is not the same as leaving the parameter out.\\n\"\n+                            \"The server total may be different to the balance in the default \\\"\\\" account.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"type\\\"      (string, optional) define the desired balance type \\\"\\\".\\n\"\n+                            \"1. includewatchonly (bool, optional, default=false) Also include balance in watchonly addresses (see 'importaddress')\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"amount              (numeric) The total amount in btc received for this account (or a object in case of type=all).\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nThe total amount in the wallet\\n\"\n+                            + HelpExampleCli(\"getbalance\", \"\") +\n+                            \"\\nThe total amount in the wallet at least 5 blocks confirmed\\n\"\n+                            + HelpExampleCli(\"getbalance\", \"type=all includewatchonly=true\") +\n+                            \"\\nAs a json rpc call\\n\"\n+                            + HelpExampleRpc(\"getbalance\", \"type=all\")\n+                            );\n+\n+    Wallet *wallet = WalletFromParams(params);\n+    LOCK(wallet->cs_coreWallet);\n+\n+    isminefilter filter = ISMINE_SPENDABLE;\n+    UniValue includewatchonly = ValueFromParams(params, \"includewatchonly\", UniValue::VBOOL);\n+    if (!includewatchonly.isNull() && includewatchonly.isBool() && includewatchonly.isTrue())\n+        filter = filter | ISMINE_WATCH_ONLY;\n+\n+    UniValue balanceType = ValueFromParams(params, \"type\");\n+    if (!balanceType.isNull() && balanceType.get_str() == \"immature\")\n+        return ValueFromAmount(wallet->GetBalance(CREDIT_DEBIT_TYPE_IMMATURE, filter));\n+    if (!balanceType.isNull() && balanceType.get_str() == \"unconfirmed\")\n+        return ValueFromAmount(wallet->GetBalance(CREDIT_DEBIT_TYPE_UNCONFIRMED, filter));\n+    if (!balanceType.isNull() && balanceType.get_str() == \"all\")\n+    {\n+        UniValue balanceArray = UniValue(UniValue::VOBJ);\n+        balanceArray.push_back(Pair(\"available\", ValueFromAmount(wallet->GetBalance(CREDIT_DEBIT_TYPE_AVAILABLE, filter))));\n+        balanceArray.push_back(Pair(\"unconfirmed\", ValueFromAmount(wallet->GetBalance(CREDIT_DEBIT_TYPE_UNCONFIRMED, filter))));\n+        balanceArray.push_back(Pair(\"immature\", ValueFromAmount(wallet->GetBalance(CREDIT_DEBIT_TYPE_IMMATURE, filter))));\n+        return balanceArray;\n+    }\n+    else\n+        return ValueFromAmount(wallet->GetBalance(CREDIT_DEBIT_TYPE_AVAILABLE, filter));\n+}\n+\n+UniValue createtx(const UniValue& params, bool fHelp)\n+{\n+    if (fHelp || params.size() > 1)\n+        throw std::runtime_error(\n+                                 \"createtx sendto=([{address0:amount}, {address1:amount}]) send=(1|0)\\n\"\n+                                 \"\\nExamples:\\n\"\n+                                 + HelpExampleCli(\"createtx\", \"{\\\"1PGFqEzfmQch1gKD3ra4k18PNj3tTUUSqg\\\":10.0}\")\n+                                 + HelpExampleRpc(\"createtx\", \"\")\n+                                 );\n+    \n+    Wallet *wallet = WalletFromParams(params);\n+    std::vector<std::pair<CBitcoinAddress, CAmount> > sendToList;\n+\n+    UniValue sendToArray = ValueFromParams(params, \"sendto\");\n+}\n     \n ///////////////////////////\n // Dispatching/signaling stack\n@@ -487,6 +737,7 @@ void ExecuteRPC(const std::string& strMethod, const UniValue& params, UniValue&\n     }\n }\n \n+\n //! Create helpstring by catching \"help\"-exceptions over dispatching table.\n void AddRPCHelp(std::string& helpString)\n {"
      },
      {
        "sha": "5eba43de90588ae21ba40b4ef0476c2674133757",
        "filename": "src/corewallet/corewallet_wallet.cpp",
        "status": "modified",
        "additions": 608,
        "deletions": 1,
        "changes": 609,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6a5952114c96dc63f69768097cc6fd68b7ca991c/src/corewallet/corewallet_wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6a5952114c96dc63f69768097cc6fd68b7ca991c/src/corewallet/corewallet_wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet_wallet.cpp?ref=6a5952114c96dc63f69768097cc6fd68b7ca991c",
        "patch": "@@ -19,6 +19,8 @@\n \n namespace CoreWallet {\n \n+bool bSpendZeroConfChange = true;\n+\n bool Wallet::LoadKey(const CKey& key, const CPubKey &pubkey)\n {\n     return CCryptoKeyStore::AddKeyPubKey(key, pubkey);\n@@ -51,7 +53,7 @@ bool Wallet::SetAddressBook(const CTxDestination& address, const std::string& st\n     \n     mapAddressBook[address].purpose = strPurpose;\n     \n-    return walletCacheDB->Write(make_pair(std::string(\"adrmeta\"), CBitcoinAddress(address).ToString()), mapAddressBook[address]);\n+    return walletCacheDB->Write(std::make_pair(std::string(\"adrmeta\"), CBitcoinAddress(address).ToString()), mapAddressBook[address]);\n }\n \n \n@@ -276,4 +278,609 @@ bool Wallet::HDGetActiveChainID(HDChainID& chainID)\n     return true;\n }\n \n+/*\n+ ######################\n+ # WTX list stack     #\n+ ######################\n+ */\n+\n+const WalletTx* Wallet::GetWalletTx(const uint256& hash) const\n+{\n+    LOCK(cs_coreWallet);\n+    std::map<uint256, WalletTx>::const_iterator it = mapWallet.find(hash);\n+    if (it == mapWallet.end())\n+        return NULL;\n+    return &(it->second);\n+}\n+\n+Wallet::TxItems Wallet::OrderedTxItems()\n+{\n+    AssertLockHeld(cs_coreWallet); // mapWallet\n+\n+    // First: get all WalletTx and CAccountingEntry into a sorted-by-order multimap.\n+    TxItems txOrdered;\n+\n+    // Note: maintaining indices in the database of (account,time) --> txid and (account, time) --> acentry\n+    // would make this much faster for applications that do this a lot.\n+    for (std::map<uint256, WalletTx>::iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n+    {\n+        WalletTx* wtx = &((*it).second);\n+        txOrdered.insert(std::make_pair(wtx->nOrderPos, TxPair(wtx, \"\")));\n+    }\n+    \n+    return txOrdered;\n+}\n+\n+/*\n+ ########################\n+ # Coin Lock Stack #\n+ ########################\n+ */\n+void Wallet::LockCoin(COutPoint& output)\n+{\n+    AssertLockHeld(cs_coreWallet); // setLockedCoins\n+    setLockedCoins.insert(output);\n+}\n+\n+void Wallet::UnlockCoin(COutPoint& output)\n+{\n+    AssertLockHeld(cs_coreWallet); // setLockedCoins\n+    setLockedCoins.erase(output);\n+}\n+\n+void Wallet::UnlockAllCoins()\n+{\n+    AssertLockHeld(cs_coreWallet); // setLockedCoins\n+    setLockedCoins.clear();\n+}\n+\n+bool Wallet::IsLockedCoin(uint256 hash, unsigned int n) const\n+{\n+    AssertLockHeld(cs_coreWallet); // setLockedCoins\n+    COutPoint outpt(hash, n);\n+\n+    return (setLockedCoins.count(outpt) > 0);\n+}\n+\n+void Wallet::ListLockedCoins(std::vector<COutPoint>& vOutpts)\n+{\n+    AssertLockHeld(cs_coreWallet); // setLockedCoins\n+    for (std::set<COutPoint>::iterator it = setLockedCoins.begin();\n+         it != setLockedCoins.end(); it++) {\n+        COutPoint outpt = (*it);\n+        vOutpts.push_back(outpt);\n+    }\n+}\n+\n+/*\n+ ########################\n+ # Coin Selection Stack #\n+ ########################\n+ */\n+\n+/**\n+ * populate vCoins with vector of available COutputs.\n+ */\n+\n+bool Wallet::IsTrustedWTx(const WalletTx &wtx) const\n+{\n+    AssertLockHeld(cs_coreWallet);\n+\n+    // Quick answer in most cases\n+    if (!coreInterface.CheckFinalTx(wtx))\n+        return false;\n+    int nDepth = wtx.GetDepthInMainChain();\n+    if (nDepth >= 1)\n+        return true;\n+    if (nDepth < 0)\n+        return false;\n+    if (!bSpendZeroConfChange || !wtx.IsFromMe(ISMINE_ALL)) // using wtx's cached debit\n+        return false;\n+\n+    // Trusted if all inputs are from us and are in the mempool:\n+    BOOST_FOREACH(const CTxIn& txin, wtx.vin)\n+    {\n+        // Transactions not sent by us: not trusted\n+        const WalletTx* parent = GetWalletTx(txin.prevout.hash);\n+        if (parent == NULL)\n+            return false;\n+        const CTxOut& parentOut = parent->vout[txin.prevout.n];\n+        if (IsMine(parentOut) != ISMINE_SPENDABLE)\n+            return false;\n+    }\n+    return true;\n+}\n+\n+void Wallet::AvailableCoins(std::vector<COutput>& vCoins, bool fOnlyConfirmed, const CCoinControl *coinControl, bool fIncludeZeroValue) const\n+{\n+    vCoins.clear();\n+\n+    {\n+        LOCK(cs_coreWallet);\n+        for (std::map<uint256, WalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n+        {\n+            const uint256& wtxid = it->first;\n+            const WalletTx* pcoin = &(*it).second;\n+\n+            if (fOnlyConfirmed && !IsTrustedWTx(*pcoin))\n+                continue;\n+\n+            if (pcoin->IsCoinBase() && pcoin->GetBlocksToMaturity() > 0)\n+                continue;\n+\n+            int nDepth = pcoin->GetDepthInMainChain();\n+            if (nDepth < 0)\n+                continue;\n+\n+            for (unsigned int i = 0; i < pcoin->vout.size(); i++) {\n+                isminetype mine = IsMine(pcoin->vout[i]);\n+                if (!(IsSpent(wtxid, i)) && mine != ISMINE_NO &&\n+                    !IsLockedCoin((*it).first, i) && (pcoin->vout[i].nValue > 0 || fIncludeZeroValue) &&\n+                    (!coinControl || !coinControl->HasSelected() || coinControl->fAllowOtherInputs || coinControl->IsSelected((*it).first, i)))\n+                    vCoins.push_back(COutput(pcoin, i, nDepth, (mine & ISMINE_SPENDABLE) != ISMINE_NO));\n+            }\n+        }\n+    }\n+}\n+\n+bool Wallet::RelayWalletTransaction(const WalletTx &wtx)\n+{\n+    assert(GetBroadcastTransactions());\n+    if (!wtx.IsCoinBase())\n+    {\n+        if (wtx.GetDepthInMainChain() == 0) {\n+            LogPrintf(\"Relaying wtx %s\\n\", wtx.GetHash().ToString());\n+            coreInterface.RelayTransaction((CTransaction)wtx);\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n+/*\n+ ######################\n+ # Receiving tx stack #\n+ ######################\n+*/\n+\n+std::set<uint256> Wallet::GetConflicts(const uint256& txid) const\n+{\n+    std::set<uint256> result;\n+    AssertLockHeld(cs_coreWallet);\n+\n+    std::map<uint256, WalletTx>::const_iterator it = mapWallet.find(txid);\n+    if (it == mapWallet.end())\n+        return result;\n+    const WalletTx& wtx = it->second;\n+\n+    std::pair<TxSpends::const_iterator, TxSpends::const_iterator> range;\n+\n+    BOOST_FOREACH(const CTxIn& txin, wtx.vin)\n+    {\n+        if (mapTxSpends.count(txin.prevout) <= 1)\n+            continue;  // No conflict if zero or one spends\n+        range = mapTxSpends.equal_range(txin.prevout);\n+        for (TxSpends::const_iterator it = range.first; it != range.second; ++it)\n+            result.insert(it->second);\n+    }\n+    return result;\n+}\n+\n+/**\n+ * Outpoint is spent if any non-conflicted transaction\n+ * spends it:\n+ */\n+bool Wallet::IsSpent(const uint256& hash, unsigned int n) const\n+{\n+    AssertLockHeld(cs_coreWallet);\n+\n+    const COutPoint outpoint(hash, n);\n+    std::pair<TxSpends::const_iterator, TxSpends::const_iterator> range;\n+    range = mapTxSpends.equal_range(outpoint);\n+\n+    for (TxSpends::const_iterator it = range.first; it != range.second; ++it)\n+    {\n+        const uint256& wtxid = it->second;\n+        std::map<uint256, WalletTx>::const_iterator mit = mapWallet.find(wtxid);\n+        if (mit != mapWallet.end() && mit->second.GetDepthInMainChain() >= 0)\n+            return true; // Spent\n+    }\n+    return false;\n+}\n+\n+void Wallet::AddToSpends(const COutPoint& outpoint, const uint256& wtxid)\n+{\n+    AssertLockHeld(cs_coreWallet);\n+\n+    mapTxSpends.insert(std::make_pair(outpoint, wtxid));\n+\n+    std::pair<TxSpends::iterator, TxSpends::iterator> range;\n+    range = mapTxSpends.equal_range(outpoint);\n+    SyncMetaData(range);\n+}\n+\n+\n+void Wallet::AddToSpends(const uint256& wtxid)\n+{\n+    AssertLockHeld(cs_coreWallet);\n+\n+    assert(mapWallet.count(wtxid));\n+    WalletTx& thisTx = mapWallet[wtxid];\n+    if (thisTx.IsCoinBase()) // Coinbases don't spend anything!\n+        return;\n+    \n+    BOOST_FOREACH(const CTxIn& txin, thisTx.vin)\n+    AddToSpends(txin.prevout, wtxid);\n+}\n+\n+bool Wallet::AddToWallet(const WalletTx& wtxIn, bool fFromLoadWallet)\n+{\n+    LOCK(cs_coreWallet);\n+\n+    uint256 hash = wtxIn.GetHash();\n+\n+    if (fFromLoadWallet)\n+    {\n+        //TODO add CheckTransaction from main.cpp like check\n+        mapWallet[hash] = wtxIn;\n+        mapWallet[hash].BindWallet(this);\n+        AddToSpends(hash);\n+    }\n+    else\n+    {\n+        // Inserts only if not already there, returns tx inserted or tx found\n+        std::pair<std::map<uint256, WalletTx>::iterator, bool> ret = mapWallet.insert(std::make_pair(hash, wtxIn));\n+        WalletTx& wtx = (*ret.first).second;\n+        wtx.BindWallet(this);\n+        bool fInsertedNew = ret.second;\n+        if (fInsertedNew)\n+        {\n+            wtx.nTimeReceived = GetAdjustedTime();\n+            wtx.nOrderPos = 0; //IncOrderPosNext(pwalletdb);\n+\n+            wtx.nTimeSmart = wtx.nTimeReceived;\n+            if (!wtxIn.hashBlock.IsNull())\n+            {\n+                const CBlockIndex *possibleIndex = GetBlockIndex(wtxIn.hashBlock);\n+                if (possibleIndex)\n+                {\n+                    int64_t latestNow = wtx.nTimeReceived;\n+                    int64_t latestEntry = 0;\n+                    {\n+                        // Tolerate times up to the last timestamp in the wallet not more than 5 minutes into the future\n+                        int64_t latestTolerated = latestNow + 300;\n+                        TxItems txOrdered = OrderedTxItems();\n+                        for (TxItems::reverse_iterator it = txOrdered.rbegin(); it != txOrdered.rend(); ++it)\n+                        {\n+                            WalletTx *const pwtx = (*it).second.first;\n+                            if (pwtx == &wtx)\n+                                continue;\n+\n+                            int64_t nSmartTime = 0;\n+                            if (pwtx)\n+                            {\n+                                nSmartTime = pwtx->nTimeSmart;\n+                                if (!nSmartTime)\n+                                    nSmartTime = pwtx->nTimeReceived;\n+                            }\n+                            if (nSmartTime <= latestTolerated)\n+                            {\n+                                latestEntry = nSmartTime;\n+                                if (nSmartTime > latestNow)\n+                                    latestNow = nSmartTime;\n+                                break;\n+                            }\n+                        }\n+                    }\n+\n+                    int64_t blocktime = possibleIndex->GetBlockTime();\n+                    wtx.nTimeSmart = std::max(latestEntry, std::min(blocktime, latestNow));\n+                }\n+                else\n+                    LogPrintf(\"AddToWallet(): found %s in block %s not in index\\n\",\n+                              wtxIn.GetHash().ToString(),\n+                              wtxIn.hashBlock.ToString());\n+            }\n+            AddToSpends(hash);\n+        }\n+\n+        bool fUpdated = false;\n+        if (!fInsertedNew)\n+        {\n+            // Merge\n+            if (!wtxIn.hashBlock.IsNull() && wtxIn.hashBlock != wtx.hashBlock)\n+            {\n+                wtx.hashBlock = wtxIn.hashBlock;\n+                fUpdated = true;\n+            }\n+            if (wtxIn.nIndex != -1 && (wtxIn.vMerkleBranch != wtx.vMerkleBranch || wtxIn.nIndex != wtx.nIndex))\n+            {\n+                wtx.vMerkleBranch = wtxIn.vMerkleBranch;\n+                wtx.nIndex = wtxIn.nIndex;\n+                fUpdated = true;\n+            }\n+            if (wtxIn.fFromMe && wtxIn.fFromMe != wtx.fFromMe)\n+            {\n+                wtx.fFromMe = wtxIn.fFromMe;\n+                fUpdated = true;\n+            }\n+        }\n+\n+        //// debug print\n+        LogPrintf(\"AddToWallet %s  %s%s\\n\", wtxIn.GetHash().ToString(), (fInsertedNew ? \"new\" : \"\"), (fUpdated ? \"update\" : \"\"));\n+\n+        // Write to disk\n+        if (fInsertedNew || fUpdated)\n+            if (!WriteWTXToDisk(wtx))\n+                return false;\n+\n+        // Break debit/credit balance caches:\n+        wtx.MarkDirty();\n+\n+        // Notify UI of new or updated transaction\n+        NotifyTransactionChanged(this, hash, fInsertedNew ? CT_NEW : CT_UPDATED);\n+    }\n+    return true;\n+}\n+\n+/**\n+ * Add a transaction to the wallet, or update it.\n+ * pblock is optional, but should be provided if the transaction is known to be in a block.\n+ * If fUpdate is true, existing transactions will be updated.\n+ */\n+bool Wallet::AddToWalletIfInvolvingMe(const CTransaction& tx, const CBlock* pblock, bool fUpdate)\n+{\n+    {\n+        AssertLockHeld(cs_coreWallet);\n+        bool fExisted = mapWallet.count(tx.GetHash()) != 0;\n+        if (fExisted && !fUpdate) return false;\n+        if (fExisted || IsMine(tx) || IsFromMe(tx))\n+        {\n+            WalletTx wtx(this,tx);\n+\n+            // Get merkle branch if transaction was found in a block\n+            if (pblock)\n+                wtx.SetMerkleBranch(*pblock);\n+\n+            return AddToWallet(wtx, false);\n+        }\n+    }\n+    return false;\n+}\n+\n+isminetype Wallet::IsMine(const CTxIn &txin) const\n+{\n+    {\n+        LOCK(cs_coreWallet);\n+        std::map<uint256, WalletTx>::const_iterator mi = mapWallet.find(txin.prevout.hash);\n+        if (mi != mapWallet.end())\n+        {\n+            const WalletTx& prev = (*mi).second;\n+            if (txin.prevout.n < prev.vout.size())\n+                return IsMine(prev.vout[txin.prevout.n]);\n+        }\n+    }\n+    return ISMINE_NO;\n+}\n+\n+CAmount Wallet::GetDebit(const CTxIn &txin, const isminefilter& filter) const\n+{\n+    {\n+        LOCK(cs_coreWallet);\n+        std::map<uint256, WalletTx>::const_iterator mi = mapWallet.find(txin.prevout.hash);\n+        if (mi != mapWallet.end())\n+        {\n+            const WalletTx& prev = (*mi).second;\n+            if (txin.prevout.n < prev.vout.size())\n+                if (IsMine(prev.vout[txin.prevout.n]) & filter)\n+                    return prev.vout[txin.prevout.n].nValue;\n+        }\n+    }\n+    return 0;\n+}\n+\n+isminetype Wallet::IsMine(const CTxOut& txout) const\n+{\n+    return CoreWallet::IsMine(*this, txout.scriptPubKey);\n+}\n+\n+CAmount Wallet::GetCredit(const CTxOut& txout, const isminefilter& filter) const\n+{\n+    if (!MoneyRange(txout.nValue))\n+        throw std::runtime_error(\"Wallet::GetCredit(): value out of range\");\n+    return ((IsMine(txout) & filter) ? txout.nValue : 0);\n+}\n+\n+bool Wallet::IsMine(const CTransaction& tx) const\n+{\n+    BOOST_FOREACH(const CTxOut& txout, tx.vout)\n+    if (IsMine(txout))\n+        return true;\n+    return false;\n+}\n+\n+bool Wallet::IsFromMe(const CTransaction& tx) const\n+{\n+    return (GetDebit(tx, ISMINE_ALL) > 0);\n+}\n+\n+bool Wallet::WriteWTXToDisk(const WalletTx &wtx)\n+{\n+    return walletCacheDB->WriteTx(wtx.GetHash(), wtx);\n+}\n+\n+void Wallet::SyncMetaData(std::pair<TxSpends::iterator, TxSpends::iterator> range)\n+{\n+    // We want all the wallet transactions in range to have the same metadata as\n+    // the oldest (smallest nOrderPos).\n+    // So: find smallest nOrderPos:\n+\n+    int nMinOrderPos = std::numeric_limits<int>::max();\n+    const WalletTx* copyFrom = NULL;\n+    for (TxSpends::iterator it = range.first; it != range.second; ++it)\n+    {\n+        const uint256& hash = it->second;\n+        int n = mapWallet[hash].nOrderPos;\n+        if (n < nMinOrderPos)\n+        {\n+            nMinOrderPos = n;\n+            copyFrom = &mapWallet[hash];\n+        }\n+    }\n+    // Now copy data from copyFrom to rest:\n+    for (TxSpends::iterator it = range.first; it != range.second; ++it)\n+    {\n+        const uint256& hash = it->second;\n+        WalletTx* copyTo = &mapWallet[hash];\n+        if (copyFrom == copyTo) continue;\n+        copyTo->mapValue = copyFrom->mapValue;\n+        copyTo->vOrderForm = copyFrom->vOrderForm;\n+        // fTimeReceivedIsTxTime not copied on purpose\n+        // nTimeReceived not copied on purpose\n+        copyTo->nTimeSmart = copyFrom->nTimeSmart;\n+        copyTo->fFromMe = copyFrom->fFromMe;\n+        // nOrderPos not copied on purpose\n+        // cached members not copied on purpose\n+    }\n+}\n+\n+void Wallet::SyncTransaction(const CTransaction& tx, const CBlock* pblock)\n+{\n+    LOCK(cs_coreWallet);\n+    if (!AddToWalletIfInvolvingMe(tx, pblock, true))\n+        return; // Not one of ours\n+\n+    // If a transaction changes 'conflicted' state, that changes the balance\n+    // available of the outputs it spends. So force those to be\n+    // recomputed, also:\n+    BOOST_FOREACH(const CTxIn& txin, tx.vin)\n+    {\n+        if (mapWallet.count(txin.prevout.hash))\n+            mapWallet[txin.prevout.hash].MarkDirty();\n+    }\n+}\n+\n+/*\n+ #############################\n+ # Balance calculation stack #\n+ #############################\n+ */\n+\n+CAmount Wallet::GetDebit(const CTransaction& tx, const isminefilter& filter) const\n+{\n+    CAmount nDebit = 0;\n+    BOOST_FOREACH(const CTxIn& txin, tx.vin)\n+    {\n+        nDebit += GetDebit(txin, filter);\n+        if (!MoneyRange(nDebit))\n+            throw std::runtime_error(\"Wallet::GetDebit(): value out of range\");\n+    }\n+    return nDebit;\n+}\n+\n+CAmount Wallet::GetCredit(const CTransaction& tx, const isminefilter& filter) const\n+{\n+    CAmount nCredit = 0;\n+    BOOST_FOREACH(const CTxOut& txout, tx.vout)\n+    {\n+        nCredit += GetCredit(txout, filter);\n+        if (!MoneyRange(nCredit))\n+            throw std::runtime_error(\"Wallet::GetCredit(): value out of range\");\n+    }\n+    return nCredit;\n+}\n+\n+CAmount Wallet::GetBalance(const enum CREDIT_DEBIT_TYPE &balanceType, const isminefilter& filter) const\n+{\n+    CAmount nTotal = 0;\n+    {\n+        LOCK(cs_coreWallet);\n+        for (std::map<uint256, WalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n+        {\n+            const WalletTx* pcoin = &(*it).second;\n+            if (\n+                ( balanceType == CREDIT_DEBIT_TYPE_AVAILABLE && IsTrustedWTx(*pcoin) )\n+                || //OR\n+                ( balanceType == CREDIT_DEBIT_TYPE_UNCONFIRMED && !IsTrustedWTx(*pcoin) && pcoin->GetDepthInMainChain() == 0)\n+                || //OR\n+                ( balanceType == CREDIT_DEBIT_TYPE_IMMATURE && pcoin->IsCoinBase() && pcoin->GetBlocksToMaturity() > 0 && pcoin->IsInMainChain())\n+                )\n+            {\n+                CAmount cacheOut;\n+                bool cacheFound = pcoin->GetCache(balanceType, filter, cacheOut);\n+\n+                if (balanceType == CREDIT_DEBIT_TYPE_IMMATURE && pcoin->IsCoinBase() && pcoin->GetBlocksToMaturity() > 0 && pcoin->IsInMainChain())\n+                {\n+                    //shortcut for imature balance\n+                    if (cacheFound)\n+                    {\n+                        nTotal += cacheOut;\n+                        break;\n+                    }\n+\n+                    CAmount nCredit = GetCredit(*pcoin, filter);\n+                    pcoin->SetCache(balanceType, filter, nCredit);\n+                    nTotal += nCredit;\n+                    break;\n+                }\n+\n+                // Must wait until coinbase is safely deep enough in the chain before valuing it\n+                if (pcoin->IsCoinBase() && pcoin->GetBlocksToMaturity() < 0)\n+                    break;\n+\n+                if (cacheFound)\n+                {\n+                    nTotal += cacheOut;\n+                    break;\n+                }\n+\n+                CAmount nCredit = 0;\n+                uint256 hashTx = pcoin->GetHash();\n+                for (unsigned int i = 0; i < pcoin->vout.size(); i++)\n+                {\n+                    if (!IsSpent(hashTx, i))\n+                    {\n+                        const CTxOut &txout = pcoin->vout[i];\n+                        nCredit += GetCredit(txout, filter);\n+                    }\n+                }\n+                pcoin->SetCache(balanceType, filter, nCredit);\n+                nTotal += nCredit;\n+            }\n+        }\n+    }\n+    return nTotal;\n+}\n+\n+/*\n+ #########################\n+ # Full Node Interaction #\n+ #########################\n+ */\n+\n+const CBlockIndex* Wallet::GetBlockIndex(uint256 blockhash, bool inActiveChain) const\n+{\n+    LOCK(cs_coreWallet);\n+    return coreInterface.GetBlockIndex(blockhash, inActiveChain);\n+}\n+\n+int Wallet::GetActiveChainHeight() const\n+{\n+    LOCK(cs_coreWallet);\n+    return coreInterface.GetActiveChainHeight();\n+}\n+\n+int Wallet::MempoolExists(uint256 hash) const\n+{\n+    LOCK(cs_coreWallet);\n+    return coreInterface.MempoolExists(hash);\n+}\n+\n+bool Wallet::AcceptToMemoryPool(const WalletTx &wtx, bool fLimitFree, bool fRejectAbsurdFee)\n+{\n+    LOCK(cs_coreWallet);\n+    CValidationState state;\n+    return coreInterface.AcceptToMemoryPool(state, wtx, fLimitFree, fRejectAbsurdFee);\n+}\n+\n }; //end namespace\n\\ No newline at end of file"
      },
      {
        "sha": "c2f23d9ff8f50df5ff29cf2da7437de89fdeedf3",
        "filename": "src/corewallet/corewallet_wallet.h",
        "status": "modified",
        "additions": 90,
        "deletions": 1,
        "changes": 91,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6a5952114c96dc63f69768097cc6fd68b7ca991c/src/corewallet/corewallet_wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6a5952114c96dc63f69768097cc6fd68b7ca991c/src/corewallet/corewallet_wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet_wallet.h?ref=6a5952114c96dc63f69768097cc6fd68b7ca991c",
        "patch": "@@ -6,20 +6,36 @@\n #ifndef BITCOIN_COREWALLT_WALLET_H\n #define BITCOIN_COREWALLT_WALLET_H\n \n+#include \"corewallet/coreinterface.h\"\n+\n #include \"corewallet/corewallet_basics.h\"\n #include \"corewallet/corewallet_db.h\"\n+#include \"corewallet/corewallet_wtx.h\"\n+#include \"corewallet/corewallet_ismine.h\"\n #include \"corewallet/hdkeystore.h\"\n+\n+#include \"coincontrol.h\"\n #include \"key.h\"\n #include \"keystore.h\"\n+#include \"ui_interface.h\"\n #include \"validationinterface.h\"\n \n+class WalletTx;\n+\n namespace CoreWallet {\n-    \n+\n+extern bool bSpendZeroConfChange;\n+\n class Wallet : public CHDKeyStore, public CValidationInterface{\n public:\n+\n+    CoreInterface coreInterface;\n+\n     mutable CCriticalSection cs_coreWallet;\n     std::map<CKeyID, CKeyMetadata> mapKeyMetadata;\n     std::map<CTxDestination, CAddressBookMetadata> mapAddressBook;\n+    std::map<uint256, WalletTx> mapWallet;\n+    std::set<COutPoint> setLockedCoins;\n     int64_t nTimeFirstKey;\n     FileDB *walletPrivateDB;\n     FileDB *walletCacheDB;\n@@ -35,6 +51,8 @@ class Wallet : public CHDKeyStore, public CValidationInterface{\n \n         walletCacheDB = new FileDB(strWalletFileIn+\".cache.logdb\");\n         walletCacheDB->LoadWallet(this);\n+\n+        coreInterface = CoreInterface();\n     }\n \n     //!adds a hd chain of keys to the wallet\n@@ -59,6 +77,77 @@ class Wallet : public CHDKeyStore, public CValidationInterface{\n     bool LoadKeyMetadata(const CPubKey &pubkey, const CoreWallet::CKeyMetadata &metadata);\n     bool LoadKey(const CKey& key, const CPubKey &pubkey);\n     bool SetAddressBook(const CTxDestination& address, const std::string& purpose);\n+\n+\n+    void SyncTransaction(const CTransaction& tx, const CBlock* pblock);\n+\n+    //receiving stack\n+    bool AddToWallet(const WalletTx& wtxIn, bool fFromLoadWallet);\n+    bool AddToWalletIfInvolvingMe(const CTransaction& tx, const CBlock* pblock, bool fUpdate);\n+    isminetype IsMine(const CTxIn& txin) const;\n+    CAmount GetDebit(const CTxIn& txin, const isminefilter& filter) const;\n+    isminetype IsMine(const CTxOut& txout) const;\n+    CAmount GetCredit(const CTxOut& txout, const isminefilter& filter) const;\n+    bool IsMine(const CTransaction& tx) const;\n+    /** should probably be renamed to IsRelevantToMe */\n+    bool IsFromMe(const CTransaction& tx) const;\n+    CAmount GetDebit(const CTransaction& tx, const isminefilter& filter) const;\n+    CAmount GetCredit(const CTransaction& tx, const isminefilter& filter) const;\n+\n+    bool fBroadcastTransactions;\n+    /** Inquire whether this wallet broadcasts transactions. */\n+    bool GetBroadcastTransactions() const { return fBroadcastTransactions; }\n+    /** Set whether this wallet broadcasts transactions. */\n+    void SetBroadcastTransactions(bool broadcast) { fBroadcastTransactions = broadcast; }\n+\n+    std::set<uint256> GetConflicts(const uint256& txid) const;\n+\n+    /**\n+     * Used to keep track of spent outpoints, and\n+     * detect and report conflicts (double-spends or\n+     * mutated transactions where the mutant gets mined).\n+     */\n+    typedef std::multimap<COutPoint, uint256> TxSpends;\n+    TxSpends mapTxSpends;\n+    void AddToSpends(const COutPoint& outpoint, const uint256& wtxid);\n+    void AddToSpends(const uint256& wtxid);\n+    bool IsSpent(const uint256& hash, unsigned int n) const;\n+    void SyncMetaData(std::pair<TxSpends::iterator, TxSpends::iterator>);\n+\n+    const WalletTx* GetWalletTx(const uint256& hash) const;\n+\n+    typedef std::pair<WalletTx*, std::string > TxPair;\n+    typedef std::multimap<int64_t, TxPair > TxItems;\n+    Wallet::TxItems OrderedTxItems();\n+\n+    bool WriteWTXToDisk(const WalletTx &wtx);\n+\n+    bool IsTrustedWTx(const WalletTx &wtx) const;\n+    void AvailableCoins(std::vector<COutput>& vCoins, bool fOnlyConfirmed, const CCoinControl *coinControl, bool fIncludeZeroValue) const;\n+\n+    bool IsLockedCoin(uint256 hash, unsigned int n) const;\n+    void LockCoin(COutPoint& output);\n+    void UnlockCoin(COutPoint& output);\n+    void UnlockAllCoins();\n+    void ListLockedCoins(std::vector<COutPoint>& vOutpts);\n+\n+    //Balance funtions // needs refactor\n+    CAmount GetBalance(const enum CREDIT_DEBIT_TYPE &balanceType, const isminefilter& filter) const;\n+\n+    bool RelayWalletTransaction(const WalletTx &wtx);\n+\n+    //core node interaction\n+    const CBlockIndex* GetBlockIndex(uint256 blockhash, bool inActiveChain = false) const;\n+    int GetActiveChainHeight() const;\n+    int MempoolExists(uint256 hash) const;\n+    bool AcceptToMemoryPool(const WalletTx &wtx, bool fLimitFree, bool fRejectAbsurdFee);\n+\n+    /**\n+     * Wallet transaction added, removed or updated.\n+     * @note called with lock cs_wallet held.\n+     */\n+    boost::signals2::signal<void (Wallet *wallet, const uint256 &hashTx,\n+                                  ChangeType status)> NotifyTransactionChanged;\n };\n \n // WalletModel: a wallet metadata class"
      },
      {
        "sha": "c4120843fafad47bc775fdd5f8f9d1b4ee8e36ac",
        "filename": "src/corewallet/corewallet_wtx.cpp",
        "status": "added",
        "additions": 132,
        "deletions": 0,
        "changes": 132,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6a5952114c96dc63f69768097cc6fd68b7ca991c/src/corewallet/corewallet_wtx.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6a5952114c96dc63f69768097cc6fd68b7ca991c/src/corewallet/corewallet_wtx.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet_wtx.cpp?ref=6a5952114c96dc63f69768097cc6fd68b7ca991c",
        "patch": "@@ -0,0 +1,132 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2015 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"corewallet/corewallet_wallet.h\"\n+#include \"corewallet/corewallet_wtx.h\"\n+\n+#include \"consensus/validation.h\"\n+#include \"consensus/consensus.h\"\n+\n+#include <algorithm>\n+\n+namespace CoreWallet {\n+\n+bool WalletTx::RelayWalletTransaction()\n+{\n+    assert(pwallet->GetBroadcastTransactions());\n+    if (!IsCoinBase())\n+    {\n+        if (GetDepthInMainChain() == 0) {\n+            LogPrintf(\"Relaying wtx %s\\n\", GetHash().ToString());\n+            //RelayTransaction((CTransaction)*this);\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n+CAmount WalletTx::GetDebit(const isminefilter& filter) const\n+{\n+    if (vin.empty())\n+        return 0;\n+\n+    CAmount debit = 0;\n+    CAmount cacheOut;\n+    if (GetCache(CREDIT_DEBIT_TYPE_DEBIT, filter, cacheOut))\n+        debit += cacheOut;\n+    else\n+    {\n+        cacheOut = pwallet->GetDebit(*this, filter);\n+        SetCache(CREDIT_DEBIT_TYPE_DEBIT, filter, cacheOut);\n+        debit += cacheOut;\n+    }\n+    \n+    return debit;\n+}\n+\n+int64_t WalletTx::GetTxTime() const\n+{\n+    int64_t n = nTimeSmart;\n+    return n ? n : nTimeReceived;\n+}\n+\n+int WalletTx::GetDepthInMainChainInternal(const CBlockIndex* &pindexRet) const\n+{\n+    if (hashBlock.IsNull() || nIndex == -1)\n+        return 0;\n+\n+    // Find the block it claims to be in\n+    const CBlockIndex* pindex = pwallet->GetBlockIndex(hashBlock, true);\n+    if (!pindex)\n+        return 0;\n+\n+    // Make sure the merkle branch connects to this block\n+    if (!fMerkleVerified)\n+    {\n+        if (CBlock::CheckMerkleBranch(GetHash(), vMerkleBranch, nIndex) != pindex->hashMerkleRoot)\n+            return 0;\n+        fMerkleVerified = true;\n+    }\n+\n+    pindexRet = pindex;\n+    return pwallet->GetActiveChainHeight() - pindex->nHeight + 1;\n+}\n+\n+int WalletTx::GetDepthInMainChain(const CBlockIndex* &pindexRet) const\n+{\n+    int nResult = GetDepthInMainChainInternal(pindexRet);\n+    if (nResult == 0 && !pwallet->MempoolExists(GetHash()))\n+        return -1; // Not in chain, not in mempool\n+\n+    return nResult;\n+}\n+\n+int WalletTx::GetBlocksToMaturity() const\n+{\n+    if (!IsCoinBase())\n+        return 0;\n+    return std::max(0, (COINBASE_MATURITY+1) - GetDepthInMainChain());\n+}\n+\n+bool WalletTx::SetMerkleBranch(const CBlock& block)\n+{\n+    CBlock blockTmp;\n+\n+    // Update the tx's hashBlock\n+    hashBlock = block.GetHash();\n+\n+    // Locate the transaction\n+    for (nIndex = 0; nIndex < (int)block.vtx.size(); nIndex++)\n+        if (block.vtx[nIndex] == *(CTransaction*)this)\n+            break;\n+    if (nIndex == (int)block.vtx.size())\n+    {\n+        vMerkleBranch.clear();\n+        nIndex = -1;\n+        LogPrintf(\"ERROR: SetMerkleBranch(): couldn't find tx in block\\n\");\n+        return false;\n+    }\n+\n+    // Fill in merkle branch\n+    vMerkleBranch = block.GetMerkleBranch(nIndex);\n+    return true;\n+}\n+\n+void WalletTx::SetCache(const enum CREDIT_DEBIT_TYPE &balanceType, const isminefilter& filter, const CAmount &amount) const\n+{\n+    std::pair<uint8_t, uint8_t> key(balanceType,filter);\n+    std::pair<bool, CAmount> value(true, amount);\n+    cacheMap[key] = value;\n+}\n+\n+bool WalletTx::GetCache(const enum CREDIT_DEBIT_TYPE &balanceType, const isminefilter& filter, CAmount &amountOut) const\n+{\n+    std::pair<uint8_t, uint8_t> key(balanceType,filter);\n+    std::pair<bool, CAmount> value = cacheMap[key];\n+    amountOut = value.second;\n+    return value.first;\n+}\n+\n+}; //end namespace\n\\ No newline at end of file"
      },
      {
        "sha": "d8316e4f24cb22599057797533040d6f2b9feac1",
        "filename": "src/corewallet/corewallet_wtx.h",
        "status": "added",
        "additions": 193,
        "deletions": 0,
        "changes": 193,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6a5952114c96dc63f69768097cc6fd68b7ca991c/src/corewallet/corewallet_wtx.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6a5952114c96dc63f69768097cc6fd68b7ca991c/src/corewallet/corewallet_wtx.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet_wtx.h?ref=6a5952114c96dc63f69768097cc6fd68b7ca991c",
        "patch": "@@ -0,0 +1,193 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2015 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_COREWALLT_WTX_H\n+#define BITCOIN_COREWALLT_WTX_H\n+\n+#include \"corewallet/corewallet_basics.h\"\n+#include \"corewallet/corewallet_ismine.h\"\n+#include \"corewallet/corewallet_wallet.h\"\n+\n+#include \"primitives/block.h\"\n+#include \"primitives/transaction.h\"\n+\n+#include \"chain.h\"\n+#include \"utilstrencodings.h\"\n+\n+#include <list>\n+\n+class Wallet;\n+\n+namespace CoreWallet {\n+\n+typedef std::map<std::string, std::string> mapValue_t;\n+\n+struct COutputEntry\n+{\n+    CTxDestination destination;\n+    CAmount amount;\n+    int vout;\n+};\n+\n+/**\n+ * A transaction with a bunch of additional info that only the owner cares about.\n+ * It includes any unrecorded transactions needed to link it back to the block chain.\n+ */\n+class WalletTx : public CTransaction\n+{\n+private:\n+    const Wallet* pwallet;\n+    int GetDepthInMainChainInternal(const CBlockIndex* &pindexRet) const;\n+    \n+public:\n+    static const int CURRENT_VERSION=1;\n+    uint8_t nVersion;\n+\n+    mapValue_t mapValue;\n+    std::vector<std::pair<std::string, std::string> > vOrderForm;\n+    std::vector<uint32_t> vChangeOutputs; //! stores the positions of the change vouts\n+    unsigned int fTimeReceivedIsTxTime;\n+    unsigned int nTimeReceived; //! time received by this node\n+    unsigned int nTimeSmart;\n+    char fFromMe;\n+    int64_t nOrderPos; //! position in ordered transaction list\n+\n+    uint256 hashBlock;\n+    std::vector<uint256> vMerkleBranch;\n+    int nIndex;\n+\n+    // memory only\n+    mutable std::map<std::pair<uint8_t, uint8_t>, std::pair<bool, CAmount> > cacheMap; //! cache map for storing credit/debit caches\n+    mutable bool fMerkleVerified;\n+    mutable CAmount nChangeCached;\n+\n+    WalletTx()\n+    {\n+        Init(NULL);\n+    }\n+\n+    WalletTx(const Wallet* pwalletIn)\n+    {\n+        Init(pwalletIn);\n+    }\n+\n+    WalletTx(const Wallet* pwalletIn, const CTransaction& txIn) : CTransaction(txIn)\n+    {\n+        Init(pwalletIn);\n+    }\n+\n+    void Init(const Wallet* pwalletIn)\n+    {\n+        nVersion = WalletTx::CURRENT_VERSION;\n+        hashBlock = uint256();\n+        nIndex = -1; //!position in block\n+        fMerkleVerified = false;\n+        pwallet = pwalletIn;\n+        mapValue.clear(); //!flexible key/value set for wtx metadata\n+        vOrderForm.clear();\n+        vChangeOutputs.clear(); //!todo: store which outputs of this wtx are change outputs\n+        cacheMap.clear();\n+        fTimeReceivedIsTxTime = false;\n+        nTimeReceived = 0;\n+        nTimeSmart = 0;\n+        fFromMe = false;\n+        nChangeCached = 0;\n+        nOrderPos = -1;\n+    }\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        READWRITE(*(CTransaction*)this);\n+        READWRITE(hashBlock);\n+        READWRITE(vMerkleBranch);\n+        READWRITE(nIndex);\n+        std::vector<WalletTx> vUnused; //! Used to be vtxPrev\n+        READWRITE(vUnused);\n+        READWRITE(mapValue);\n+        READWRITE(vOrderForm);\n+        READWRITE(vChangeOutputs);\n+        READWRITE(fTimeReceivedIsTxTime);\n+        READWRITE(nTimeReceived);\n+        READWRITE(nTimeSmart);\n+        READWRITE(fFromMe);\n+        READWRITE(nOrderPos);\n+    }\n+\n+    //! make sure balances are recalculated\n+    void MarkDirty()\n+    {\n+        cacheMap.clear();\n+    }\n+\n+    void BindWallet(Wallet *pwalletIn)\n+    {\n+        pwallet = pwalletIn;\n+        MarkDirty();\n+    }\n+\n+    //! filter decides which addresses will count towards the debit\n+    CAmount GetDebit(const isminefilter& filter) const;\n+    CAmount GetChange() const;\n+\n+    void GetAmounts(std::list<COutputEntry>& listReceived,\n+                    std::list<COutputEntry>& listSent, CAmount& nFee, std::string& strSentAccount, const isminefilter& filter) const;\n+\n+    void GetAccountAmounts(const std::string& strAccount, CAmount& nReceived,\n+                           CAmount& nSent, CAmount& nFee, const isminefilter& filter) const;\n+    \n+    bool IsFromMe(const isminefilter& filter) const\n+    {\n+        return (GetDebit(filter) > 0);\n+    }\n+\n+    int64_t GetTxTime() const;\n+    int GetRequestCount() const;\n+    \n+    bool RelayWalletTransaction();\n+\n+    /**\n+     * Return depth of transaction in blockchain:\n+     * -1  : not in blockchain, and not in memory pool (conflicted transaction)\n+     *  0  : in memory pool, waiting to be included in a block\n+     * >=1 : this many blocks deep in the main chain\n+     */\n+    int GetDepthInMainChain(const CBlockIndex* &pindexRet) const;\n+    int GetDepthInMainChain() const { const CBlockIndex *pindexRet; return GetDepthInMainChain(pindexRet); }\n+    bool IsInMainChain() const { const CBlockIndex *pindexRet; return GetDepthInMainChainInternal(pindexRet) > 0; }\n+    int GetBlocksToMaturity() const;\n+\n+    bool SetMerkleBranch(const CBlock& block);\n+\n+    //store a amount in in-mem cache\n+    void SetCache(const enum CREDIT_DEBIT_TYPE &balanceType, const isminefilter& filter, const CAmount &amount) const;\n+\n+    //get a value from in-mem cache\n+    bool GetCache(const enum CREDIT_DEBIT_TYPE &balanceType, const isminefilter& filter, CAmount &amountOut) const;\n+};\n+\n+\n+\n+\n+class COutput\n+{\n+public:\n+    const WalletTx *tx;\n+    int i;\n+    int nDepth;\n+    bool fSpendable;\n+    \n+    COutput(const WalletTx *txIn, int iIn, int nDepthIn, bool fSpendableIn)\n+    {\n+        tx = txIn; i = iIn; nDepth = nDepthIn; fSpendable = fSpendableIn;\n+    }\n+    \n+    std::string ToString() const;\n+};\n+\n+} //end namespace\n+\n+#endif // BITCOIN_COREWALLT_WTX_H"
      }
    ]
  },
  {
    "sha": "433e58d97ac44d6d4c298e175aa006c77598a0f6",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0MzNlNThkOTdhYzQ0ZDZkNGMyOThlMTc1YWEwMDZjNzc1OThhMGY2",
    "commit": {
      "author": {
        "name": "Jonas Schnelli",
        "email": "jonas.schnelli@include7.ch",
        "date": "2015-06-30T19:44:20Z"
      },
      "committer": {
        "name": "Jonas Schnelli",
        "email": "jonas.schnelli@include7.ch",
        "date": "2015-07-08T14:57:54Z"
      },
      "message": "[corewallet] basic sending and receiving done\n\n- create transaction logic is more or less copied from the current wallet\n- refactoring of main/mempool interaction from corewallet",
      "tree": {
        "sha": "f3706c53eef56f8269efd3189225d9de4890cc5f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f3706c53eef56f8269efd3189225d9de4890cc5f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/433e58d97ac44d6d4c298e175aa006c77598a0f6",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/433e58d97ac44d6d4c298e175aa006c77598a0f6",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/433e58d97ac44d6d4c298e175aa006c77598a0f6",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/433e58d97ac44d6d4c298e175aa006c77598a0f6/comments",
    "author": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6a5952114c96dc63f69768097cc6fd68b7ca991c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6a5952114c96dc63f69768097cc6fd68b7ca991c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6a5952114c96dc63f69768097cc6fd68b7ca991c"
      }
    ],
    "stats": {
      "total": 1050,
      "additions": 970,
      "deletions": 80
    },
    "files": [
      {
        "sha": "076ab1acc81ad4ab66208b08a096cf79dcf9c7f4",
        "filename": "src/corewallet/coreinterface.cpp",
        "status": "added",
        "additions": 81,
        "deletions": 0,
        "changes": 81,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/433e58d97ac44d6d4c298e175aa006c77598a0f6/src/corewallet/coreinterface.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/433e58d97ac44d6d4c298e175aa006c77598a0f6/src/corewallet/coreinterface.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/coreinterface.cpp?ref=433e58d97ac44d6d4c298e175aa006c77598a0f6",
        "patch": "@@ -0,0 +1,81 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2014 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"corewallet/coreinterface.h\"\n+\n+#include \"main.h\"\n+#include \"net.h\"\n+\n+namespace CoreWallet\n+{\n+//TODO: create a proper interface over ZMQ\n+const CBlockIndex* CoreInterface::GetBlockIndex(uint256 blockhash, bool inActiveChain) const\n+{\n+    //for now, this interacts directly with the mapBlockIndex in global scope\n+    LOCK(cs_main);\n+    BlockMap::iterator mi = mapBlockIndex.find(blockhash);\n+    if (mi == mapBlockIndex.end())\n+        return NULL;\n+    CBlockIndex* pindex = (*mi).second;\n+    if( (!inActiveChain && pindex) || (inActiveChain && pindex && chainActive.Contains(pindex)))\n+       return pindex;\n+    return NULL;\n+}\n+\n+bool CoreInterface::CheckFinalTx(const CTransaction &tx) const\n+{\n+    LOCK(cs_main);\n+    return ::CheckFinalTx(tx);\n+}\n+\n+int CoreInterface::GetActiveChainHeight() const\n+{\n+    LOCK(cs_main);\n+    return chainActive.Height();\n+}\n+\n+bool CoreInterface::MempoolExists(uint256 hash) const\n+{\n+    LOCK(mempool.cs);\n+    return mempool.exists(hash);\n+}\n+\n+bool CoreInterface::AcceptToMemoryPool(CValidationState &state, const CTransaction &tx, bool fLimitFree, bool fRejectAbsurdFee)\n+{\n+    LOCK(cs_main);\n+    return ::AcceptToMemoryPool(mempool, state, tx, fLimitFree, NULL, fRejectAbsurdFee);\n+}\n+\n+void CoreInterface::RelayTransaction(const CTransaction& tx) const\n+{\n+    ::RelayTransaction(tx);\n+}\n+\n+CFeeRate CoreInterface::GetMinRelayTxFee() const\n+{\n+    return ::minRelayTxFee;\n+}\n+\n+unsigned int CoreInterface::GetMaxStandardTxSize() const\n+{\n+    return MAX_STANDARD_TX_SIZE;\n+}\n+\n+CAmount CoreInterface::EstimateFee(int confirmationTarget, size_t txSize) const\n+{\n+    return mempool.estimateFee(confirmationTarget).GetFee(txSize);\n+}\n+\n+double CoreInterface::EstimatePriority(int confirmationTarget) const\n+{\n+    return mempool.estimatePriority(confirmationTarget);\n+}\n+\n+bool CoreInterface::AllowFree(double dPriority) const\n+{\n+    return AllowFree(dPriority);\n+}\n+\n+} // end namespace\n\\ No newline at end of file"
      },
      {
        "sha": "23430b36b602840ab50e2fd320f639fbd8bc0476",
        "filename": "src/corewallet/coreinterface.h",
        "status": "added",
        "additions": 36,
        "deletions": 0,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/433e58d97ac44d6d4c298e175aa006c77598a0f6/src/corewallet/coreinterface.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/433e58d97ac44d6d4c298e175aa006c77598a0f6/src/corewallet/coreinterface.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/coreinterface.h?ref=433e58d97ac44d6d4c298e175aa006c77598a0f6",
        "patch": "@@ -0,0 +1,36 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2014 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_COREWALLETWALLET_COREINTERFACE_H\n+#define BITCOIN_COREWALLETWALLET_COREINTERFACE_H\n+\n+#include \"chain.h\"\n+#include \"primitives/block.h\"\n+#include \"primitives/transaction.h\"\n+#include \"consensus/validation.h\"\n+\n+namespace CoreWallet\n+{\n+//bridge/layer for interacting with the full node\n+//this will allow later process seperation; APIing of the command below\n+class CoreInterface {\n+public:\n+    //!returns a block index if the block was found\n+    const CBlockIndex* GetBlockIndex(uint256 blockhash, bool inActiveChain = false) const;\n+    bool CheckFinalTx(const CTransaction &tx) const;\n+    int GetActiveChainHeight() const;\n+    bool MempoolExists(uint256 hash) const;\n+    bool AcceptToMemoryPool(CValidationState &state, const CTransaction &tx, bool fLimitFree, bool fRejectAbsurdFee=false);\n+    void RelayTransaction(const CTransaction &tx) const;\n+\n+    CFeeRate GetMinRelayTxFee() const;\n+    unsigned int GetMaxStandardTxSize() const;\n+    CAmount EstimateFee(int confirmationTarget, size_t txSize) const;\n+    double EstimatePriority(int confirmationTarget) const;\n+    bool AllowFree(double dPriority) const;\n+};\n+\n+} // end namespace\n+#endif // BITCOIN_COREWALLETWALLET_COREINTERFACE_H"
      },
      {
        "sha": "cc111d5a2574d8a3c11b75be19596e9fdee77261",
        "filename": "src/corewallet/corewallet.cpp",
        "status": "modified",
        "additions": 27,
        "deletions": 17,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/433e58d97ac44d6d4c298e175aa006c77598a0f6/src/corewallet/corewallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/433e58d97ac44d6d4c298e175aa006c77598a0f6/src/corewallet/corewallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet.cpp?ref=433e58d97ac44d6d4c298e175aa006c77598a0f6",
        "patch": "@@ -7,6 +7,7 @@\n #include \"corewallet/corewallet_db.h\"\n #include \"corewallet/corewallet_wallet.h\"\n #include \"rpcserver.h\"\n+#include \"script/script.h\"\n #include \"ui_interface.h\"\n #include \"univalue/univalue.h\"\n #include \"util.h\"\n@@ -15,6 +16,7 @@\n #include <string>\n \n #include <boost/foreach.hpp>\n+#include <boost/shared_ptr.hpp>\n \n namespace CoreWallet {\n \n@@ -143,23 +145,6 @@ void Dealloc()\n         managerSharedInstance = NULL;\n     }\n }\n-    \n-void RegisterSignals()\n-{\n-    AddJSONRPCURISchema(\"/corewallet\");\n-    RPCServer::OnExtendedCommandExecute(boost::bind(&CoreWallet::ExecuteRPC, _1, _2, _3, _4));\n-    \n-    GetMainSignals().ShutdownFinished.connect(boost::bind(&Dealloc));\n-    GetMainSignals().CreateHelpString.connect(boost::bind(&AppendHelpMessageString, _1, _2));\n-    GetMainSignals().LoadModules.connect(boost::bind(&LoadAsModule, _1, _2, _3));\n-}\n-\n-void UnregisterSignals()\n-{\n-    GetMainSignals().ShutdownFinished.disconnect(boost::bind(&Dealloc));\n-    GetMainSignals().CreateHelpString.disconnect(boost::bind(&AppendHelpMessageString, _1, _2));\n-    GetMainSignals().LoadModules.disconnect(boost::bind(&LoadAsModule, _1, _2, _3));\n-}\n \n Manager* GetManager()\n {\n@@ -188,4 +173,29 @@ void Manager::SyncTransaction(const CTransaction& tx, const CBlock* pblock)\n     }\n }\n \n+void GetScriptForMining(boost::shared_ptr<CReserveScript> &script)\n+{\n+    Wallet *wallet = CoreWallet::GetManager()->GetWalletWithID(\"\");\n+    if (wallet)\n+        wallet->GetScriptForMining(script);\n+}\n+\n+void RegisterSignals()\n+{\n+    AddJSONRPCURISchema(\"/corewallet\");\n+    RPCServer::OnExtendedCommandExecute(boost::bind(&CoreWallet::ExecuteRPC, _1, _2, _3, _4));\n+\n+    GetMainSignals().ShutdownFinished.connect(boost::bind(&Dealloc));\n+    GetMainSignals().CreateHelpString.connect(boost::bind(&AppendHelpMessageString, _1, _2));\n+    GetMainSignals().LoadModules.connect(boost::bind(&LoadAsModule, _1, _2, _3));\n+    GetMainSignals().ScriptForMining.connect(boost::bind(&GetScriptForMining, _1));\n+}\n+\n+void UnregisterSignals()\n+{\n+    GetMainSignals().ShutdownFinished.disconnect(boost::bind(&Dealloc));\n+    GetMainSignals().CreateHelpString.disconnect(boost::bind(&AppendHelpMessageString, _1, _2));\n+    GetMainSignals().LoadModules.disconnect(boost::bind(&LoadAsModule, _1, _2, _3));\n+    GetMainSignals().ScriptForMining.disconnect(boost::bind(&GetScriptForMining, _1));\n+}\n };\n\\ No newline at end of file"
      },
      {
        "sha": "56fc248d2e2f7ae3578e228d3c9aee6ad7986dae",
        "filename": "src/corewallet/corewallet_basics.h",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/433e58d97ac44d6d4c298e175aa006c77598a0f6/src/corewallet/corewallet_basics.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/433e58d97ac44d6d4c298e175aa006c77598a0f6/src/corewallet/corewallet_basics.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet_basics.h?ref=433e58d97ac44d6d4c298e175aa006c77598a0f6",
        "patch": "@@ -6,6 +6,7 @@\n #ifndef BITCOIN_COREWALLET_COREWALLET_BASICS_H\n #define BITCOIN_COREWALLET_COREWALLET_BASICS_H\n \n+#include \"base58.h\"\n #include \"pubkey.h\"\n #include \"serialize.h\"\n \n@@ -99,6 +100,13 @@ namespace CoreWallet\n             nDepth = 0;\n         }\n     };\n+\n+    struct CRecipient\n+    {\n+        CScript scriptPubKey;\n+        CAmount nAmount;\n+        bool fSubtractFeeFromAmount;\n+    };\n }; // end namespace CoreWallet\n \n #endif\n\\ No newline at end of file"
      },
      {
        "sha": "00fdbfb2b3d1fa8a2bbe995dd51447aba45e6666",
        "filename": "src/corewallet/corewallet_rpc.cpp",
        "status": "modified",
        "additions": 64,
        "deletions": 2,
        "changes": 66,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/433e58d97ac44d6d4c298e175aa006c77598a0f6/src/corewallet/corewallet_rpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/433e58d97ac44d6d4c298e175aa006c77598a0f6/src/corewallet/corewallet_rpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet_rpc.cpp?ref=433e58d97ac44d6d4c298e175aa006c77598a0f6",
        "patch": "@@ -3,12 +3,15 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#include \"base58.h\"\n #include \"corewallet/corewallet_basics.h\"\n #include \"corewallet/corewallet.h\"\n+\n+#include \"base58.h\"\n+#include \"core_io.h\"\n #include \"pubkey.h\"\n #include \"rpcserver.h\"\n #include \"utilstrencodings.h\"\n+#include \"utilmoneystr.h\"\n \n #include <string>\n \n@@ -118,6 +121,14 @@ UniValue ValueFromParams(const UniValue& params, const std::string& key, UniValu\n             else\n                 val.setBool(false);\n         }\n+        if (forceType == UniValue::VOBJ)\n+            if (val.isStr())\n+            {\n+                std::string jsonStr = val.get_str();\n+                if (!val.read(jsonStr))\n+                    throw std::runtime_error(\"Invalid JSON\");\n+            }\n+\n         return val;\n     }\n     else\n@@ -708,7 +719,58 @@ UniValue createtx(const UniValue& params, bool fHelp)\n     Wallet *wallet = WalletFromParams(params);\n     std::vector<std::pair<CBitcoinAddress, CAmount> > sendToList;\n \n-    UniValue sendToArray = ValueFromParams(params, \"sendto\");\n+    UniValue sendToArray = ValueFromParams(params, \"sendto\", UniValue::VOBJ);\n+    UniValue sendTx = ValueFromParams(params, \"send\", UniValue::VBOOL);\n+\n+    CAmount curBalance = wallet->GetBalance(CREDIT_DEBIT_TYPE_AVAILABLE, ISMINE_SPENDABLE);\n+\n+    CBitcoinAddress address(sendToArray.getKeys()[0]);\n+    if (!address.IsValid())\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid Bitcoin address\");\n+\n+    CAmount nValue = AmountFromValue(sendToArray.getValues()[0]);\n+    // Check amount\n+    if (nValue <= 0)\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid amount\");\n+\n+    if (nValue > curBalance)\n+        throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Insufficient funds\");\n+\n+    bool shouldSend = false;\n+    if (!sendTx.isNull() && sendTx.isTrue())\n+        shouldSend = true;\n+\n+    // Parse Bitcoin address\n+    CScript scriptPubKey = GetScriptForDestination(address.Get());\n+\n+    bool fSubtractFeeFromAmount = false;\n+    WalletTx wtxNew;\n+\n+    // Create and send the transaction\n+    CHDReserveKey reservekey(wallet);\n+    CAmount nFeeRequired;\n+    std::string strError;\n+    std::vector<CRecipient> vecSend;\n+    int nChangePosRet = -1;\n+    CRecipient recipient = {scriptPubKey, nValue, fSubtractFeeFromAmount};\n+    vecSend.push_back(recipient);\n+    if (!wallet->CreateTransaction(vecSend, wtxNew, reservekey, nFeeRequired, nChangePosRet, strError)) {\n+        if (!fSubtractFeeFromAmount && nValue + nFeeRequired > curBalance)\n+            strError = strprintf(\"Error: This transaction requires a transaction fee of at least %s because of its amount, complexity, or use of recently received funds!\", FormatMoney(nFeeRequired));\n+        throw JSONRPCError(RPC_WALLET_ERROR, strError);\n+    }\n+\n+    if (shouldSend && !wallet->CommitTransaction(wtxNew, reservekey))\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Error: The transaction was rejected! This might happen if some of the coins in your wallet were already spent, such as if you used a copy of wallet.dat and coins were spent in the copy but not marked as spent here.\");\n+\n+    UniValue result(UniValue::VOBJ);\n+    result.push_back(Pair(\"hex\", EncodeHexTx(wtxNew)));\n+    result.push_back(Pair(\"fee\", ValueFromAmount(nFeeRequired)));\n+    result.push_back(Pair(\"sent\", shouldSend));\n+    if (shouldSend)\n+        result.push_back(Pair(\"txid\", wtxNew.GetHash().GetHex()));\n+\n+    return result;\n }\n     \n ///////////////////////////"
      },
      {
        "sha": "8824739ceee685992bbf9f0b7c45e08b9cd1d851",
        "filename": "src/corewallet/corewallet_wallet.cpp",
        "status": "modified",
        "additions": 723,
        "deletions": 43,
        "changes": 766,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/433e58d97ac44d6d4c298e175aa006c77598a0f6/src/corewallet/corewallet_wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/433e58d97ac44d6d4c298e175aa006c77598a0f6/src/corewallet/corewallet_wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet_wallet.cpp?ref=433e58d97ac44d6d4c298e175aa006c77598a0f6",
        "patch": "@@ -5,11 +5,17 @@\n \n #include \"corewallet/corewallet_wallet.h\"\n \n+#include \"consensus/consensus.h\"\n+\n+#include \"script/script.h\"\n+#include \"script/sign.h\"\n+\n #include \"base58.h\"\n #include \"eccryptoverify.h\"\n #include \"random.h\"\n #include \"timedata.h\"\n #include \"util.h\"\n+#include \"utilmoneystr.h\"\n #include \"utilstrencodings.h\"\n \n #include <stdint.h>\n@@ -20,6 +26,27 @@\n namespace CoreWallet {\n \n bool bSpendZeroConfChange = true;\n+bool fSendFreeTransactions = false;\n+bool fPayAtLeastCustomFee = true;\n+unsigned int nTxConfirmTarget = 2;\n+CFeeRate payTxFee(0);\n+CAmount maxTxFee = 0.1 * COIN;\n+CFeeRate Wallet::minTxFee = CFeeRate(1000);\n+\n+\n+Wallet::Wallet(std::string strWalletFileIn)\n+{\n+    //instantiate a wallet backend object and maps the stored values\n+    walletPrivateDB = new FileDB(strWalletFileIn+\".private.logdb\");\n+    walletPrivateDB->LoadWallet(this);\n+\n+    walletCacheDB = new FileDB(strWalletFileIn+\".cache.logdb\");\n+    walletCacheDB->LoadWallet(this);\n+\n+    this->SetBroadcastTransactions(GetBoolArg(\"-walletbroadcast\", true));\n+\n+    coreInterface = CoreInterface();\n+}\n \n bool Wallet::LoadKey(const CKey& key, const CPubKey &pubkey)\n {\n@@ -423,6 +450,580 @@ void Wallet::AvailableCoins(std::vector<COutput>& vCoins, bool fOnlyConfirmed, c\n     }\n }\n \n+\n+struct CompareValueOnly\n+{\n+    bool operator()(const std::pair<CAmount, std::pair<const WalletTx*, unsigned int> >& t1,\n+                    const std::pair<CAmount, std::pair<const WalletTx*, unsigned int> >& t2) const\n+    {\n+        return t1.first < t2.first;\n+    }\n+};\n+\n+static void ApproximateBestSubset(std::vector<std::pair<CAmount, std::pair<const WalletTx*,unsigned int> > >vValue, const CAmount& nTotalLower, const CAmount& nTargetValue, std::vector<char>& vfBest, CAmount& nBest, int iterations = 1000)\n+{\n+    std::vector<char> vfIncluded;\n+\n+    vfBest.assign(vValue.size(), true);\n+    nBest = nTotalLower;\n+\n+    seed_insecure_rand();\n+\n+    for (int nRep = 0; nRep < iterations && nBest != nTargetValue; nRep++)\n+    {\n+        vfIncluded.assign(vValue.size(), false);\n+        CAmount nTotal = 0;\n+        bool fReachedTarget = false;\n+        for (int nPass = 0; nPass < 2 && !fReachedTarget; nPass++)\n+        {\n+            for (unsigned int i = 0; i < vValue.size(); i++)\n+            {\n+                //The solver here uses a randomized algorithm,\n+                //the randomness serves no real security purpose but is just\n+                //needed to prevent degenerate behavior and it is important\n+                //that the rng is fast. We do not use a constant random sequence,\n+                //because there may be some privacy improvement by making\n+                //the selection random.\n+                if (nPass == 0 ? insecure_rand()&1 : !vfIncluded[i])\n+                {\n+                    nTotal += vValue[i].first;\n+                    vfIncluded[i] = true;\n+                    if (nTotal >= nTargetValue)\n+                    {\n+                        fReachedTarget = true;\n+                        if (nTotal < nBest)\n+                        {\n+                            nBest = nTotal;\n+                            vfBest = vfIncluded;\n+                        }\n+                        nTotal -= vValue[i].first;\n+                        vfIncluded[i] = false;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+bool Wallet::SelectCoinsMinConf(const CAmount& nTargetValue, int nConfMine, int nConfTheirs, std::vector<COutput> vCoins,\n+                                 std::set<std::pair<const WalletTx*,unsigned int> >& setCoinsRet, CAmount& nValueRet) const\n+{\n+    setCoinsRet.clear();\n+    nValueRet = 0;\n+\n+    // List of values less than target\n+    std::pair<CAmount, std::pair<const WalletTx*,unsigned int> > coinLowestLarger;\n+    coinLowestLarger.first = std::numeric_limits<CAmount>::max();\n+    coinLowestLarger.second.first = NULL;\n+    std::vector<std::pair<CAmount, std::pair<const WalletTx*,unsigned int> > > vValue;\n+    CAmount nTotalLower = 0;\n+\n+    random_shuffle(vCoins.begin(), vCoins.end(), GetRandInt);\n+\n+    BOOST_FOREACH(const COutput &output, vCoins)\n+    {\n+        if (!output.fSpendable)\n+            continue;\n+\n+        const WalletTx *pcoin = output.tx;\n+\n+        if (output.nDepth < (pcoin->IsFromMe(ISMINE_ALL) ? nConfMine : nConfTheirs))\n+            continue;\n+\n+        int i = output.i;\n+        CAmount n = pcoin->vout[i].nValue;\n+\n+        std::pair<CAmount,std::pair<const WalletTx*,unsigned int> > coin = std::make_pair(n,std::make_pair(pcoin, i));\n+\n+        if (n == nTargetValue)\n+        {\n+            setCoinsRet.insert(coin.second);\n+            nValueRet += coin.first;\n+            return true;\n+        }\n+        else if (n < nTargetValue + CENT)\n+        {\n+            vValue.push_back(coin);\n+            nTotalLower += n;\n+        }\n+        else if (n < coinLowestLarger.first)\n+        {\n+            coinLowestLarger = coin;\n+        }\n+    }\n+\n+    if (nTotalLower == nTargetValue)\n+    {\n+        for (unsigned int i = 0; i < vValue.size(); ++i)\n+        {\n+            setCoinsRet.insert(vValue[i].second);\n+            nValueRet += vValue[i].first;\n+        }\n+        return true;\n+    }\n+\n+    if (nTotalLower < nTargetValue)\n+    {\n+        if (coinLowestLarger.second.first == NULL)\n+            return false;\n+        setCoinsRet.insert(coinLowestLarger.second);\n+        nValueRet += coinLowestLarger.first;\n+        return true;\n+    }\n+\n+    // Solve subset sum by stochastic approximation\n+    sort(vValue.rbegin(), vValue.rend(), CompareValueOnly());\n+    std::vector<char> vfBest;\n+    CAmount nBest;\n+\n+    ApproximateBestSubset(vValue, nTotalLower, nTargetValue, vfBest, nBest, 1000);\n+    if (nBest != nTargetValue && nTotalLower >= nTargetValue + CENT)\n+        ApproximateBestSubset(vValue, nTotalLower, nTargetValue + CENT, vfBest, nBest, 1000);\n+\n+    // If we have a bigger coin and (either the stochastic approximation didn't find a good solution,\n+    //                                   or the next bigger coin is closer), return the bigger coin\n+    if (coinLowestLarger.second.first &&\n+        ((nBest != nTargetValue && nBest < nTargetValue + CENT) || coinLowestLarger.first <= nBest))\n+    {\n+        setCoinsRet.insert(coinLowestLarger.second);\n+        nValueRet += coinLowestLarger.first;\n+    }\n+    else {\n+        for (unsigned int i = 0; i < vValue.size(); i++)\n+            if (vfBest[i])\n+            {\n+                setCoinsRet.insert(vValue[i].second);\n+                nValueRet += vValue[i].first;\n+            }\n+\n+        LogPrint(\"selectcoins\", \"SelectCoins() best subset: \");\n+        for (unsigned int i = 0; i < vValue.size(); i++)\n+            if (vfBest[i])\n+                LogPrint(\"selectcoins\", \"%s \", FormatMoney(vValue[i].first));\n+        LogPrint(\"selectcoins\", \"total %s\\n\", FormatMoney(nBest));\n+    }\n+\n+    return true;\n+}\n+\n+bool Wallet::SelectCoins(const CAmount& nTargetValue, std::set<std::pair<const WalletTx*,unsigned int> >& setCoinsRet, CAmount& nValueRet, const CCoinControl* coinControl) const\n+{\n+    std::vector<COutput> vCoins;\n+    AvailableCoins(vCoins, true, coinControl);\n+\n+    // coin control -> return all selected outputs (we want all selected to go into the transaction for sure)\n+    if (coinControl && coinControl->HasSelected() && !coinControl->fAllowOtherInputs)\n+    {\n+        BOOST_FOREACH(const COutput& out, vCoins)\n+        {\n+            if (!out.fSpendable)\n+                continue;\n+            nValueRet += out.tx->vout[out.i].nValue;\n+            setCoinsRet.insert(std::make_pair(out.tx, out.i));\n+        }\n+        return (nValueRet >= nTargetValue);\n+    }\n+\n+    // calculate value from preset inputs and store them\n+    std::set<std::pair<const WalletTx*, uint32_t> > setPresetCoins;\n+    CAmount nValueFromPresetInputs = 0;\n+\n+    std::vector<COutPoint> vPresetInputs;\n+    if (coinControl)\n+        coinControl->ListSelected(vPresetInputs);\n+    BOOST_FOREACH(const COutPoint& outpoint, vPresetInputs)\n+    {\n+        std::map<uint256, WalletTx>::const_iterator it = mapWallet.find(outpoint.hash);\n+        if (it != mapWallet.end())\n+        {\n+            const WalletTx* pcoin = &it->second;\n+            // Clearly invalid input, fail\n+            if (pcoin->vout.size() <= outpoint.n)\n+                return false;\n+            nValueFromPresetInputs += pcoin->vout[outpoint.n].nValue;\n+            setPresetCoins.insert(std::make_pair(pcoin, outpoint.n));\n+        } else\n+            return false; // TODO: Allow non-wallet inputs\n+    }\n+    \n+    // remove preset inputs from vCoins\n+    for (std::vector<COutput>::iterator it = vCoins.begin(); it != vCoins.end() && coinControl && coinControl->HasSelected();)\n+    {\n+        if (setPresetCoins.count(std::make_pair(it->tx, it->i)))\n+            it = vCoins.erase(it);\n+        else\n+            ++it;\n+    }\n+    \n+    bool res = nTargetValue <= nValueFromPresetInputs ||\n+    SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, 1, 6, vCoins, setCoinsRet, nValueRet) ||\n+    SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, 1, 1, vCoins, setCoinsRet, nValueRet) ||\n+    (bSpendZeroConfChange && SelectCoinsMinConf(nTargetValue - nValueFromPresetInputs, 0, 1, vCoins, setCoinsRet, nValueRet));\n+    \n+    // because SelectCoinsMinConf clears the setCoinsRet, we now add the possible inputs to the coinset\n+    setCoinsRet.insert(setPresetCoins.begin(), setPresetCoins.end());\n+    \n+    // add preset inputs to the total value selected\n+    nValueRet += nValueFromPresetInputs;\n+    \n+    return res;\n+}\n+\n+bool Wallet::CreateTransaction(const std::vector<CRecipient>& vecSend, WalletTx& wtxNew, CReserveKey& reservekey, CAmount& nFeeRet,\n+                                int& nChangePosRet, std::string& strFailReason, const CCoinControl* coinControl, bool sign)\n+{\n+    CAmount nValue = 0;\n+    unsigned int nSubtractFeeFromAmount = 0;\n+    CFeeRate minRelayTxFee = GetMinRelayTxFee();\n+    BOOST_FOREACH (const CRecipient& recipient, vecSend)\n+    {\n+        if (nValue < 0 || recipient.nAmount < 0)\n+        {\n+            strFailReason = _(\"Transaction amounts must be positive\");\n+            return false;\n+        }\n+        nValue += recipient.nAmount;\n+\n+        if (recipient.fSubtractFeeFromAmount)\n+            nSubtractFeeFromAmount++;\n+    }\n+    if (vecSend.empty() || nValue < 0)\n+    {\n+        strFailReason = _(\"Transaction amounts must be positive\");\n+        return false;\n+    }\n+\n+    wtxNew.fTimeReceivedIsTxTime = true;\n+    wtxNew.BindWallet(this);\n+    CMutableTransaction txNew;\n+\n+    // Discourage fee sniping.\n+    //\n+    // However because of a off-by-one-error in previous versions we need to\n+    // neuter it by setting nLockTime to at least one less than nBestHeight.\n+    // Secondly currently propagation of transactions created for block heights\n+    // corresponding to blocks that were just mined may be iffy - transactions\n+    // aren't re-accepted into the mempool - we additionally neuter the code by\n+    // going ten blocks back. Doesn't yet do anything for sniping, but does act\n+    // to shake out wallet bugs like not showing nLockTime'd transactions at\n+    // all.\n+    int activeChainHeight = GetActiveChainHeight();\n+\n+    txNew.nLockTime = std::max(0, activeChainHeight - 10);\n+\n+    // Secondly occasionally randomly pick a nLockTime even further back, so\n+    // that transactions that are delayed after signing for whatever reason,\n+    // e.g. high-latency mix networks and some CoinJoin implementations, have\n+    // better privacy.\n+    if (GetRandInt(10) == 0)\n+        txNew.nLockTime = std::max(0, (int)txNew.nLockTime - GetRandInt(100));\n+\n+    assert(txNew.nLockTime <= (unsigned int)activeChainHeight);\n+    assert(txNew.nLockTime < LOCKTIME_THRESHOLD);\n+\n+    {\n+        LOCK(cs_coreWallet);\n+        {\n+            nFeeRet = 0;\n+            while (true)\n+            {\n+                txNew.vin.clear();\n+                txNew.vout.clear();\n+                wtxNew.fFromMe = true;\n+                nChangePosRet = -1;\n+                bool fFirst = true;\n+\n+                CAmount nTotalValue = nValue;\n+                if (nSubtractFeeFromAmount == 0)\n+                    nTotalValue += nFeeRet;\n+                double dPriority = 0;\n+                // vouts to the payees\n+                BOOST_FOREACH (const CRecipient& recipient, vecSend)\n+                {\n+                    CTxOut txout(recipient.nAmount, recipient.scriptPubKey);\n+\n+                    if (recipient.fSubtractFeeFromAmount)\n+                    {\n+                        txout.nValue -= nFeeRet / nSubtractFeeFromAmount; // Subtract fee equally from each selected recipient\n+\n+                        if (fFirst) // first receiver pays the remainder not divisible by output count\n+                        {\n+                            fFirst = false;\n+                            txout.nValue -= nFeeRet % nSubtractFeeFromAmount;\n+                        }\n+                    }\n+\n+                    if (txout.IsDust(minRelayTxFee))\n+                    {\n+                        if (recipient.fSubtractFeeFromAmount && nFeeRet > 0)\n+                        {\n+                            if (txout.nValue < 0)\n+                                strFailReason = _(\"The transaction amount is too small to pay the fee\");\n+                            else\n+                                strFailReason = _(\"The transaction amount is too small to send after the fee has been deducted\");\n+                        }\n+                        else\n+                            strFailReason = _(\"Transaction amount too small\");\n+                        return false;\n+                    }\n+                    txNew.vout.push_back(txout);\n+                }\n+\n+                // Choose coins to use\n+                std::set<std::pair<const WalletTx*,unsigned int> > setCoins;\n+                CAmount nValueIn = 0;\n+                if (!SelectCoins(nTotalValue, setCoins, nValueIn, coinControl))\n+                {\n+                    strFailReason = _(\"Insufficient funds\");\n+                    return false;\n+                }\n+                BOOST_FOREACH(PAIRTYPE(const WalletTx*, unsigned int) pcoin, setCoins)\n+                {\n+                    CAmount nCredit = pcoin.first->vout[pcoin.second].nValue;\n+                    //The coin age after the next block (depth+1) is used instead of the current,\n+                    //reflecting an assumption the user would accept a bit more delay for\n+                    //a chance at a free transaction.\n+                    //But mempool inputs might still be in the mempool, so their age stays 0\n+                    int age = pcoin.first->GetDepthInMainChain();\n+                    if (age != 0)\n+                        age += 1;\n+                    dPriority += (double)nCredit * age;\n+                }\n+\n+                CAmount nChange = nValueIn - nValue;\n+                if (nSubtractFeeFromAmount == 0)\n+                    nChange -= nFeeRet;\n+\n+                if (nChange > 0)\n+                {\n+                    // Fill a vout to ourself\n+                    // TODO: pass in scriptChange instead of reservekey so\n+                    // change transaction isn't always pay-to-bitcoin-address\n+                    CScript scriptChange;\n+\n+                    // coin control: send change to custom address\n+                    if (coinControl && !boost::get<CNoDestination>(&coinControl->destChange))\n+                        scriptChange = GetScriptForDestination(coinControl->destChange);\n+\n+                    // no coin control: send change to newly generated address\n+                    else\n+                    {\n+                        // Note: We use a new key here to keep it from being obvious which side is the change.\n+                        //  The drawback is that by not reusing a previous key, the change may be lost if a\n+                        //  backup is restored, if the backup doesn't have the new private key for the change.\n+                        //  If we reused the old key, it would be possible to add code to look for and\n+                        //  rediscover unknown transactions that were written with keys of ours to recover\n+                        //  post-backup change.\n+\n+                        // Reserve a new key pair from key pool\n+                        CPubKey vchPubKey;\n+                        bool ret;\n+                        ret = reservekey.GetReservedKey(vchPubKey);\n+                        assert(ret); // should never fail, as we just unlocked\n+\n+                        scriptChange = GetScriptForDestination(vchPubKey.GetID());\n+                    }\n+\n+                    CTxOut newTxOut(nChange, scriptChange);\n+\n+                    // We do not move dust-change to fees, because the sender would end up paying more than requested.\n+                    // This would be against the purpose of the all-inclusive feature.\n+                    // So instead we raise the change and deduct from the recipient.\n+                    if (nSubtractFeeFromAmount > 0 && newTxOut.IsDust(minRelayTxFee))\n+                    {\n+                        CAmount nDust = newTxOut.GetDustThreshold(minRelayTxFee) - newTxOut.nValue;\n+                        newTxOut.nValue += nDust; // raise change until no more dust\n+                        for (unsigned int i = 0; i < vecSend.size(); i++) // subtract from first recipient\n+                        {\n+                            if (vecSend[i].fSubtractFeeFromAmount)\n+                            {\n+                                txNew.vout[i].nValue -= nDust;\n+                                if (txNew.vout[i].IsDust(minRelayTxFee))\n+                                {\n+                                    strFailReason = _(\"The transaction amount is too small to send after the fee has been deducted\");\n+                                    return false;\n+                                }\n+                                break;\n+                            }\n+                        }\n+                    }\n+\n+                    // Never create dust outputs; if we would, just\n+                    // add the dust to the fee.\n+                    if (newTxOut.IsDust(minRelayTxFee))\n+                    {\n+                        nFeeRet += nChange;\n+                        reservekey.ReturnKey();\n+                    }\n+                    else\n+                    {\n+                        // Insert change txn at random position:\n+                        nChangePosRet = GetRandInt(txNew.vout.size()+1);\n+                        std::vector<CTxOut>::iterator position = txNew.vout.begin()+nChangePosRet;\n+                        txNew.vout.insert(position, newTxOut);\n+                    }\n+                }\n+                else\n+                    reservekey.ReturnKey();\n+\n+                // Fill vin\n+                //\n+                // Note how the sequence number is set to max()-1 so that the\n+                // nLockTime set above actually works.\n+                BOOST_FOREACH(const PAIRTYPE(const WalletTx*,unsigned int)& coin, setCoins)\n+                txNew.vin.push_back(CTxIn(coin.first->GetHash(),coin.second,CScript(),\n+                                          std::numeric_limits<unsigned int>::max()-1));\n+\n+                // Sign\n+                int nIn = 0;\n+                CTransaction txNewConst(txNew);\n+                BOOST_FOREACH(const PAIRTYPE(const WalletTx*,unsigned int)& coin, setCoins)\n+                {\n+                    bool signSuccess;\n+                    const CScript& scriptPubKey = coin.first->vout[coin.second].scriptPubKey;\n+                    CScript& scriptSigRes = txNew.vin[nIn].scriptSig;\n+                    if (sign)\n+                        signSuccess = ProduceSignature(TransactionSignatureCreator(this, &txNewConst, nIn, SIGHASH_ALL), scriptPubKey, scriptSigRes);\n+                    else\n+                        signSuccess = ProduceSignature(DummySignatureCreator(this), scriptPubKey, scriptSigRes);\n+\n+                    if (!signSuccess)\n+                    {\n+                        strFailReason = _(\"Signing transaction failed\");\n+                        return false;\n+                    }\n+                    nIn++;\n+                }\n+\n+                unsigned int nBytes = ::GetSerializeSize(txNew, SER_NETWORK, PROTOCOL_VERSION);\n+\n+                // Remove scriptSigs if we used dummy signatures for fee calculation\n+                if (!sign) {\n+                    BOOST_FOREACH (CTxIn& vin, txNew.vin)\n+                    vin.scriptSig = CScript();\n+                }\n+\n+                // Embed the constructed transaction data in wtxNew.\n+                *static_cast<CTransaction*>(&wtxNew) = CTransaction(txNew);\n+\n+                // Limit size\n+                if (nBytes >= GetMaxStandardTxSize())\n+                {\n+                    strFailReason = _(\"Transaction too large\");\n+                    return false;\n+                }\n+\n+                dPriority = wtxNew.ComputePriority(dPriority, nBytes);\n+\n+                // Can we complete this as a free transaction?\n+                if (fSendFreeTransactions && nBytes <= MAX_FREE_TRANSACTION_CREATE_SIZE)\n+                {\n+                    // Not enough fee: enough priority?\n+                    double dPriorityNeeded = coreInterface.EstimatePriority(nTxConfirmTarget);\n+\n+                    // Not enough mempool history to estimate: use hard-coded AllowFree.\n+                    if (dPriorityNeeded <= 0 && coreInterface.AllowFree(dPriority))\n+                        break;\n+                    \n+                    // Small enough, and priority high enough, to send for free\n+                    if (dPriorityNeeded > 0 && dPriority >= dPriorityNeeded)\n+                        break;\n+                }\n+                \n+                CAmount nFeeNeeded = GetMinimumFee(nBytes, nTxConfirmTarget);\n+                \n+                // If we made it here and we aren't even able to meet the relay fee on the next pass, give up\n+                // because we must be at the maximum allowed fee.\n+                if (nFeeNeeded < minRelayTxFee.GetFee(nBytes))\n+                {\n+                    strFailReason = _(\"Transaction too large for fee policy\");\n+                    return false;\n+                }\n+                \n+                if (nFeeRet >= nFeeNeeded)\n+                    break; // Done, enough fee included.\n+                \n+                // Include more fee and try again.\n+                nFeeRet = nFeeNeeded;\n+                continue;\n+            }\n+        }\n+    }\n+    \n+    return true;\n+}\n+\n+/**\n+ * Call after CreateTransaction unless you want to abort\n+ */\n+bool Wallet::CommitTransaction(WalletTx& wtxNew, CReserveKey& reservekey)\n+{\n+    LogPrintf(\"CommitTransaction:\\n%s\", wtxNew.ToString());\n+\n+    // Take key pair from key pool so it won't be used again\n+    reservekey.KeepKey();\n+\n+    // Add tx to wallet, because if it has change it's also ours,\n+    // otherwise just for transaction history.\n+    AddToWallet(wtxNew, false);\n+\n+    // Notify that old coins are spent\n+    {\n+        LOCK(cs_coreWallet);\n+\n+        std::set<WalletTx*> setCoins;\n+        BOOST_FOREACH(const CTxIn& txin, wtxNew.vin)\n+        {\n+            WalletTx &coin = mapWallet[txin.prevout.hash];\n+            coin.BindWallet(this);\n+            NotifyTransactionChanged(this, coin.GetHash(), CT_UPDATED);\n+        }\n+\n+        // Track how many getdata requests our transaction gets\n+        mapRequestCount[wtxNew.GetHash()] = 0;\n+    }\n+\n+    if (fBroadcastTransactions)\n+    {\n+        // Broadcast\n+        if (!AcceptToMemoryPool(wtxNew, false))\n+        {\n+            // This must not fail. The transaction has already been signed and recorded.\n+            LogPrintf(\"CommitTransaction(): Error: Transaction not valid\");\n+            return false;\n+        }\n+        RelayWalletTransaction(wtxNew);\n+    }\n+    return true;\n+}\n+\n+CAmount Wallet::GetMinimumFee(unsigned int nTxBytes, unsigned int nConfirmTarget)\n+{\n+    // payTxFee is user-set \"I want to pay this much\"\n+    CAmount nFeeNeeded = payTxFee.GetFee(nTxBytes);\n+    // user selected total at least (default=true)\n+    if (fPayAtLeastCustomFee && nFeeNeeded > 0 && nFeeNeeded < payTxFee.GetFeePerK())\n+        nFeeNeeded = payTxFee.GetFeePerK();\n+    // User didn't set: use -txconfirmtarget to estimate...\n+    if (nFeeNeeded == 0)\n+    {\n+        LOCK(cs_coreWallet);\n+        nFeeNeeded = coreInterface.EstimateFee(nConfirmTarget, nTxBytes);\n+    }\n+    // ... unless we don't have enough mempool data, in which case fall\n+    // back to a hard-coded fee\n+    if (nFeeNeeded == 0)\n+        nFeeNeeded = minTxFee.GetFee(nTxBytes);\n+    // prevent user from paying a non-sense fee (like 1 satoshi): 0 < fee < minRelayFee\n+    CFeeRate minRelayTxFee = GetMinRelayTxFee();\n+    if (nFeeNeeded < minRelayTxFee.GetFee(nTxBytes))\n+        nFeeNeeded = minRelayTxFee.GetFee(nTxBytes);\n+    // But always obey the maximum\n+    if (nFeeNeeded > maxTxFee)\n+        nFeeNeeded = maxTxFee;\n+    return nFeeNeeded;\n+}\n+\n bool Wallet::RelayWalletTransaction(const WalletTx &wtx)\n {\n     assert(GetBroadcastTransactions());\n@@ -792,61 +1393,60 @@ CAmount Wallet::GetCredit(const CTransaction& tx, const isminefilter& filter) co\n \n CAmount Wallet::GetBalance(const enum CREDIT_DEBIT_TYPE &balanceType, const isminefilter& filter) const\n {\n+    LOCK(cs_coreWallet);\n+\n     CAmount nTotal = 0;\n+    for (std::map<uint256, WalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n     {\n-        LOCK(cs_coreWallet);\n-        for (std::map<uint256, WalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n+        const WalletTx* pcoin = &(*it).second;\n+        if (\n+            ( balanceType == CREDIT_DEBIT_TYPE_AVAILABLE && IsTrustedWTx(*pcoin) )\n+            || //OR\n+            ( balanceType == CREDIT_DEBIT_TYPE_UNCONFIRMED && !IsTrustedWTx(*pcoin) && pcoin->GetDepthInMainChain() == 0)\n+            || //OR\n+            ( balanceType == CREDIT_DEBIT_TYPE_IMMATURE && pcoin->IsCoinBase() && pcoin->GetBlocksToMaturity() > 0 && pcoin->IsInMainChain())\n+            )\n         {\n-            const WalletTx* pcoin = &(*it).second;\n-            if (\n-                ( balanceType == CREDIT_DEBIT_TYPE_AVAILABLE && IsTrustedWTx(*pcoin) )\n-                || //OR\n-                ( balanceType == CREDIT_DEBIT_TYPE_UNCONFIRMED && !IsTrustedWTx(*pcoin) && pcoin->GetDepthInMainChain() == 0)\n-                || //OR\n-                ( balanceType == CREDIT_DEBIT_TYPE_IMMATURE && pcoin->IsCoinBase() && pcoin->GetBlocksToMaturity() > 0 && pcoin->IsInMainChain())\n-                )\n-            {\n-                CAmount cacheOut;\n-                bool cacheFound = pcoin->GetCache(balanceType, filter, cacheOut);\n-\n-                if (balanceType == CREDIT_DEBIT_TYPE_IMMATURE && pcoin->IsCoinBase() && pcoin->GetBlocksToMaturity() > 0 && pcoin->IsInMainChain())\n-                {\n-                    //shortcut for imature balance\n-                    if (cacheFound)\n-                    {\n-                        nTotal += cacheOut;\n-                        break;\n-                    }\n-\n-                    CAmount nCredit = GetCredit(*pcoin, filter);\n-                    pcoin->SetCache(balanceType, filter, nCredit);\n-                    nTotal += nCredit;\n-                    break;\n-                }\n-\n-                // Must wait until coinbase is safely deep enough in the chain before valuing it\n-                if (pcoin->IsCoinBase() && pcoin->GetBlocksToMaturity() < 0)\n-                    break;\n+            CAmount cacheOut;\n+            bool cacheFound = pcoin->GetCache(balanceType, filter, cacheOut);\n \n+            if (balanceType == CREDIT_DEBIT_TYPE_IMMATURE && pcoin->IsCoinBase() && pcoin->GetBlocksToMaturity() > 0 && pcoin->IsInMainChain())\n+            {\n+                //shortcut for imature balance\n                 if (cacheFound)\n                 {\n                     nTotal += cacheOut;\n-                    break;\n+                    continue;\n                 }\n \n-                CAmount nCredit = 0;\n-                uint256 hashTx = pcoin->GetHash();\n-                for (unsigned int i = 0; i < pcoin->vout.size(); i++)\n-                {\n-                    if (!IsSpent(hashTx, i))\n-                    {\n-                        const CTxOut &txout = pcoin->vout[i];\n-                        nCredit += GetCredit(txout, filter);\n-                    }\n-                }\n+                CAmount nCredit = GetCredit(*pcoin, filter);\n                 pcoin->SetCache(balanceType, filter, nCredit);\n                 nTotal += nCredit;\n+                continue;\n             }\n+\n+            // Must wait until coinbase is safely deep enough in the chain before valuing it\n+            if (pcoin->IsCoinBase() && pcoin->GetBlocksToMaturity() > 0)\n+                continue;\n+\n+            if (cacheFound)\n+            {\n+                nTotal += cacheOut;\n+                continue;\n+            }\n+\n+            CAmount nCredit = 0;\n+            uint256 hashTx = pcoin->GetHash();\n+            for (unsigned int i = 0; i < pcoin->vout.size(); i++)\n+            {\n+                if (!IsSpent(hashTx, i))\n+                {\n+                    const CTxOut &txout = pcoin->vout[i];\n+                    nCredit += GetCredit(txout, filter);\n+                }\n+            }\n+            pcoin->SetCache(balanceType, filter, nCredit);\n+            nTotal += nCredit;\n         }\n     }\n     return nTotal;\n@@ -883,4 +1483,84 @@ bool Wallet::AcceptToMemoryPool(const WalletTx &wtx, bool fLimitFree, bool fReje\n     return coreInterface.AcceptToMemoryPool(state, wtx, fLimitFree, fRejectAbsurdFee);\n }\n \n+CFeeRate Wallet::GetMinRelayTxFee()\n+{\n+    LOCK(cs_coreWallet);\n+    return coreInterface.GetMinRelayTxFee();\n+}\n+\n+unsigned int Wallet::GetMaxStandardTxSize()\n+{\n+    LOCK(cs_coreWallet);\n+    return coreInterface.GetMaxStandardTxSize();\n+}\n+\n+\n+void Wallet::GetScriptForMining(boost::shared_ptr<CReserveScript> &script)\n+{\n+    boost::shared_ptr<CHDReserveKey> rKey(new CHDReserveKey(this));\n+    CPubKey pubkey;\n+    if (!rKey->GetReservedKey(pubkey))\n+        return;\n+\n+    script = rKey;\n+    script->reserveScript = CScript() << ToByteVector(pubkey) << OP_CHECKSIG;\n+}\n+\n+/*\n+###########################\n+# Reserve & Keypool Stack #\n+###########################\n+*/\n+bool CReserveKey::GetReservedKey(CPubKey& pubkey)\n+{\n+//    if (nIndex == -1)\n+//    {\n+//        CKeyPool keypool;\n+//        pwallet->ReserveKeyFromKeyPool(nIndex, keypool);\n+//        if (nIndex != -1)\n+//            vchPubKey = keypool.vchPubKey;\n+//        else {\n+//            return false;\n+//        }\n+//    }\n+//    assert(vchPubKey.IsValid());\n+//    pubkey = vchPubKey;\n+    return true;\n+}\n+\n+void CReserveKey::KeepKey()\n+{\n+//    if (nIndex != -1)\n+//        pwallet->KeepKey(nIndex);\n+//    nIndex = -1;\n+//    vchPubKey = CPubKey();\n+}\n+\n+void CReserveKey::ReturnKey()\n+{\n+//    if (nIndex != -1)\n+//        pwallet->ReturnKey(nIndex);\n+//    nIndex = -1;\n+//    vchPubKey = CPubKey();\n+}\n+\n+bool CHDReserveKey::GetReservedKey(CPubKey& pubkey)\n+{\n+    std::string newKeysChainpath;\n+    LOCK(pwallet->cs_coreWallet);\n+    return pwallet->HDGetNextChildPubKey(chainID, pubkey, newKeysChainpath, true);\n+}\n+\n+void CHDReserveKey::KeepKey()\n+{\n+\n+}\n+\n+void CHDReserveKey::ReturnKey()\n+{\n+    //TODO: implement a way of release the nChild index of a returned HDReserveKey\n+    //at the moment there is no way of returning HD change keys\n+}\n+    \n }; //end namespace\n\\ No newline at end of file"
      },
      {
        "sha": "88233fe3164cd38fba61e0b921909222bfb4c14c",
        "filename": "src/corewallet/corewallet_wallet.h",
        "status": "modified",
        "additions": 29,
        "deletions": 16,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/433e58d97ac44d6d4c298e175aa006c77598a0f6/src/corewallet/corewallet_wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/433e58d97ac44d6d4c298e175aa006c77598a0f6/src/corewallet/corewallet_wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet_wallet.h?ref=433e58d97ac44d6d4c298e175aa006c77598a0f6",
        "patch": "@@ -20,20 +20,32 @@\n #include \"ui_interface.h\"\n #include \"validationinterface.h\"\n \n-class WalletTx;\n+\n \n namespace CoreWallet {\n \n+class WalletTx;\n+class CReserveKey;\n+\n+static const unsigned int MAX_FREE_TRANSACTION_CREATE_SIZE = 1000;\n extern bool bSpendZeroConfChange;\n+extern bool fSendFreeTransactions;\n+extern bool fPayAtLeastCustomFee;\n+extern unsigned int nTxConfirmTarget;\n+extern CFeeRate payTxFee;\n+extern CAmount maxTxFee;\n \n class Wallet : public CHDKeyStore, public CValidationInterface{\n+private:\n+    bool SelectCoins(const CAmount& nTargetValue, std::set<std::pair<const WalletTx*,unsigned int> >& setCoinsRet, CAmount& nValueRet, const CCoinControl *coinControl = NULL) const;\n public:\n-\n+    static CFeeRate minTxFee;\n     CoreInterface coreInterface;\n \n     mutable CCriticalSection cs_coreWallet;\n     std::map<CKeyID, CKeyMetadata> mapKeyMetadata;\n     std::map<CTxDestination, CAddressBookMetadata> mapAddressBook;\n+    std::map<uint256, int> mapRequestCount;\n     std::map<uint256, WalletTx> mapWallet;\n     std::set<COutPoint> setLockedCoins;\n     int64_t nTimeFirstKey;\n@@ -43,17 +55,7 @@ class Wallet : public CHDKeyStore, public CValidationInterface{\n     //! state: current active hd chain, must be protected over cs_coreWallet\n     HDChainID activeHDChain;\n \n-    Wallet(std::string strWalletFileIn)\n-    {\n-        //instantiate a wallet backend object and maps the stored values\n-        walletPrivateDB = new FileDB(strWalletFileIn+\".private.logdb\");\n-        walletPrivateDB->LoadWallet(this);\n-\n-        walletCacheDB = new FileDB(strWalletFileIn+\".cache.logdb\");\n-        walletCacheDB->LoadWallet(this);\n-\n-        coreInterface = CoreInterface();\n-    }\n+    Wallet(std::string strWalletFileIn);\n \n     //!adds a hd chain of keys to the wallet\n     bool HDSetChainPath(const std::string& chainPath, bool generateMaster, CKeyingMaterial& vSeed, HDChainID& chainId, bool overwrite = false);\n@@ -123,7 +125,7 @@ class Wallet : public CHDKeyStore, public CValidationInterface{\n     bool WriteWTXToDisk(const WalletTx &wtx);\n \n     bool IsTrustedWTx(const WalletTx &wtx) const;\n-    void AvailableCoins(std::vector<COutput>& vCoins, bool fOnlyConfirmed, const CCoinControl *coinControl, bool fIncludeZeroValue) const;\n+    void AvailableCoins(std::vector<COutput>& vCoins, bool fOnlyConfirmed, const CCoinControl *coinControl, bool fIncludeZeroValue = false) const;\n \n     bool IsLockedCoin(uint256 hash, unsigned int n) const;\n     void LockCoin(COutPoint& output);\n@@ -136,11 +138,21 @@ class Wallet : public CHDKeyStore, public CValidationInterface{\n \n     bool RelayWalletTransaction(const WalletTx &wtx);\n \n+    bool SelectCoinsMinConf(const CAmount& nTargetValue, int nConfMine, int nConfTheirs, std::vector<COutput> vCoins, std::set<std::pair<const WalletTx*,unsigned int> >& setCoinsRet, CAmount& nValueRet) const;\n+    bool CreateTransaction(const std::vector<CRecipient>& vecSend, WalletTx& wtxNew, CReserveKey& reservekey, CAmount& nFeeRet, int& nChangePosRet, std::string& strFailReason, const CCoinControl *coinControl = NULL, bool sign = true);\n+    bool CommitTransaction(WalletTx& wtxNew, CReserveKey& reservekey);\n+    CAmount GetMinimumFee(unsigned int nTxBytes, unsigned int nConfirmTarget);\n+\n     //core node interaction\n     const CBlockIndex* GetBlockIndex(uint256 blockhash, bool inActiveChain = false) const;\n     int GetActiveChainHeight() const;\n     int MempoolExists(uint256 hash) const;\n-    bool AcceptToMemoryPool(const WalletTx &wtx, bool fLimitFree, bool fRejectAbsurdFee);\n+    bool AcceptToMemoryPool(const WalletTx &wtx, bool fLimitFree=true, bool fRejectAbsurdFee=true);\n+    CFeeRate GetMinRelayTxFee();\n+    unsigned int GetMaxStandardTxSize();\n+\n+    //mining\n+    void GetScriptForMining(boost::shared_ptr<CReserveScript> &script);\n \n     /**\n      * Wallet transaction added, removed or updated.\n@@ -194,7 +206,7 @@ class WalletModel\n };\n \n /** A key allocated from the key pool. */\n-class CReserveKey\n+class CReserveKey : public CReserveScript\n {\n protected:\n     Wallet* pwallet;\n@@ -215,6 +227,7 @@ class CReserveKey\n     void ReturnKey();\n     virtual bool GetReservedKey(CPubKey &pubkey);\n     void KeepKey();\n+    void KeepScript() { KeepKey(); }\n };\n \n class CHDReserveKey : public CReserveKey"
      },
      {
        "sha": "a6f1a0a86bfef8fd1b4fef6eea2191d0073c807b",
        "filename": "src/corewallet/hdkeystore.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/433e58d97ac44d6d4c298e175aa006c77598a0f6/src/corewallet/hdkeystore.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/433e58d97ac44d6d4c298e175aa006c77598a0f6/src/corewallet/hdkeystore.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/hdkeystore.cpp?ref=433e58d97ac44d6d4c298e175aa006c77598a0f6",
        "patch": "@@ -165,7 +165,7 @@ bool CHDKeyStore::DeriveKey(const CHDPubKey hdPubKey, CKey& keyOut) const\n     std::vector<std::string> pathFragments;\n     boost::split(pathFragments, chainPath, boost::is_any_of(\"/\"));\n \n-    LogPrintf(\"hdwallet\", \"derive key %s\\n\", chainPath);\n+    LogPrint(\"hdwallet\", \"derive key %s\\n\", chainPath);\n     CExtKey extKey;\n     CExtKey parentKey;\n     BOOST_FOREACH(std::string fragment, pathFragments)\n@@ -204,7 +204,7 @@ bool CHDKeyStore::DeriveKey(const CHDPubKey hdPubKey, CKey& keyOut) const\n         }\n     }\n     keyOut = parentKey.key;\n-    LogPrintf(\"hdwallet\", \"derived key with adr: %s\\n\", CBitcoinAddress(keyOut.GetPubKey().GetID()).ToString());\n+    LogPrint(\"hdwallet\", \"derived key with adr: %s\\n\", CBitcoinAddress(keyOut.GetPubKey().GetID()).ToString());\n     return true;\n }\n "
      }
    ]
  },
  {
    "sha": "f21c70f3061c9fb0722f52aa694f704d976ef711",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmMjFjNzBmMzA2MWM5ZmIwNzIyZjUyYWE2OTRmNzA0ZDk3NmVmNzEx",
    "commit": {
      "author": {
        "name": "Jonas Schnelli",
        "email": "jonas.schnelli@include7.ch",
        "date": "2015-07-06T09:02:22Z"
      },
      "committer": {
        "name": "Jonas Schnelli",
        "email": "jonas.schnelli@include7.ch",
        "date": "2015-07-08T14:57:54Z"
      },
      "message": "[corewallet] GetDebit refactoring, cleanup and commenting",
      "tree": {
        "sha": "16290ec2662f34b0ea9540e6d50ca455257713ff",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/16290ec2662f34b0ea9540e6d50ca455257713ff"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f21c70f3061c9fb0722f52aa694f704d976ef711",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f21c70f3061c9fb0722f52aa694f704d976ef711",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f21c70f3061c9fb0722f52aa694f704d976ef711",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f21c70f3061c9fb0722f52aa694f704d976ef711/comments",
    "author": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "433e58d97ac44d6d4c298e175aa006c77598a0f6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/433e58d97ac44d6d4c298e175aa006c77598a0f6",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/433e58d97ac44d6d4c298e175aa006c77598a0f6"
      }
    ],
    "stats": {
      "total": 583,
      "additions": 330,
      "deletions": 253
    },
    "files": [
      {
        "sha": "0e5eb5fb5e679740cc7a19b20c2a675cd913aa54",
        "filename": "src/corewallet/corewallet.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 5,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f21c70f3061c9fb0722f52aa694f704d976ef711/src/corewallet/corewallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f21c70f3061c9fb0722f52aa694f704d976ef711/src/corewallet/corewallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet.cpp?ref=f21c70f3061c9fb0722f52aa694f704d976ef711",
        "patch": "@@ -125,7 +125,7 @@ Wallet* Manager::GetWalletWithID(const std::string& walletIDIn)\n std::vector<std::string> Manager::GetWalletIDs()\n {\n     std::vector<std::string> vIDs;\n-    std::pair<std::string, WalletModel> walletAndMetadata; // what a map<int, int> is made of\n+    std::pair<std::string, WalletModel> walletAndMetadata;\n \n     LOCK(cs_mapWallets);\n     {\n@@ -162,29 +162,38 @@ void Manager::SyncTransaction(const CTransaction& tx, const CBlock* pblock)\n     {\n         std::pair<std::string, WalletModel> walletAndMetadata;\n         BOOST_FOREACH(walletAndMetadata, mapWallets) {\n-            //TODO: looks ugly\n+            //TODO: needs a better approach\n             //Open the wallet within the SyncTransaction call is probably a bad idea, need to be changed\n-            if (!mapWallets[walletAndMetadata.first].pWallet) //is it closed?\n+            //Also we lock all wallets during the new wallet open (will map everything to mem)\n+            if (!mapWallets[walletAndMetadata.first].pWallet)\n                 mapWallets[walletAndMetadata.first].pWallet = new Wallet(walletAndMetadata.first);\n \n-\n             mapWallets[walletAndMetadata.first].pWallet->SyncTransaction(tx, pblock);\n         }\n     }\n }\n \n void GetScriptForMining(boost::shared_ptr<CReserveScript> &script)\n {\n+    //get the default wallet for mining coins\n+    //TODO: allow user to configure which wallet is used for mining\n     Wallet *wallet = CoreWallet::GetManager()->GetWalletWithID(\"\");\n     if (wallet)\n         wallet->GetScriptForMining(script);\n }\n \n-void RegisterSignals()\n+void RegisterRPC()\n {\n+    //Extend the existing RPC Server\n+    //After adding a new endpoint, we can listen to any incomming\n+    //command over the RPCServer::OnExtendedCommandExecute signal.\n     AddJSONRPCURISchema(\"/corewallet\");\n     RPCServer::OnExtendedCommandExecute(boost::bind(&CoreWallet::ExecuteRPC, _1, _2, _3, _4));\n+}\n \n+void RegisterSignals()\n+{\n+    RegisterRPC();\n     GetMainSignals().ShutdownFinished.connect(boost::bind(&Dealloc));\n     GetMainSignals().CreateHelpString.connect(boost::bind(&AppendHelpMessageString, _1, _2));\n     GetMainSignals().LoadModules.connect(boost::bind(&LoadAsModule, _1, _2, _3));"
      },
      {
        "sha": "69ed6efe2b58e9ab270d7af4475a9941493f7041",
        "filename": "src/corewallet/corewallet.h",
        "status": "modified",
        "additions": 18,
        "deletions": 2,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f21c70f3061c9fb0722f52aa694f704d976ef711/src/corewallet/corewallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f21c70f3061c9fb0722f52aa694f704d976ef711/src/corewallet/corewallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet.h?ref=f21c70f3061c9fb0722f52aa694f704d976ef711",
        "patch": "@@ -15,20 +15,36 @@ namespace CoreWallet {\n     {\n     public:\n         Manager();\n-        ~Manager() { }\n+        virtual ~Manager() {}\n+\n+        //!will return a wallet with given walletid, \"\" (empty string) will return the default wallet (if exists)\n         Wallet* GetWalletWithID(const std::string& walletIDIn);\n+\n+        //!will return all existing walletids\n         std::vector<std::string> GetWalletIDs();\n+\n+        //!add a new wallet without any keys, hdchains, encryption\n         Wallet* AddNewWallet(const std::string& walletID);\n+\n+        //CValidationInterface listener, will ask all wallets to sync a given transaction\n         void SyncTransaction(const CTransaction& tx, const CBlock* pblock);\n     protected:\n         CCriticalSection cs_mapWallets;\n-        std::map<std::string, WalletModel> mapWallets;\n+        std::map<std::string, WalletModel> mapWallets; //!map with wallet metadata\n+\n+        //!store wallets metadata map from memory to disk (multiwallet.dat)\n         void WriteWalletList();\n+\n+        //!read wallet metadata file and map in into memory\n         void ReadWalletLists();\n     };\n \n+\n+    //!global function (namespace CoreWallet) to register the corewallet bitcoin-core module\n     void RegisterSignals();\n     void UnregisterSignals();\n+\n+    //!singleton pattern\n     Manager* GetManager();\n };\n "
      },
      {
        "sha": "4b6b4f3f53d304187360462ab77bfb214a6c24fa",
        "filename": "src/corewallet/corewallet_basics.h",
        "status": "modified",
        "additions": 60,
        "deletions": 1,
        "changes": 61,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f21c70f3061c9fb0722f52aa694f704d976ef711/src/corewallet/corewallet_basics.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f21c70f3061c9fb0722f52aa694f704d976ef711/src/corewallet/corewallet_basics.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet_basics.h?ref=f21c70f3061c9fb0722f52aa694f704d976ef711",
        "patch": "@@ -16,6 +16,20 @@\n \n namespace CoreWallet\n {\n+    class Wallet;\n+\n+    //keyvalue store (database/logdb) keys\n+    static const std::string kvs_keymetadata_key                = \"keymeta\";\n+    static const std::string kvs_key_key                        = \"key\";\n+    static const std::string kvs_hd_master_seed_key             = \"hdmasterseed\";\n+    static const std::string kvs_hd_hdchain_key                 = \"hdchain\"; //chain of keys metadata like m/44'/0'... (CHDChain)\n+    static const std::string kvs_hd_encrypted_master_seed_key   = \"hdcryptedmasterseed\";\n+    static const std::string kvs_hdpubkey_key                   = \"hdpubkey\"; //a pubkey with some hd metadata (CHDPubKey)\n+    static const std::string kvs_hdactivechain_key              = \"hdactivechain\"; //the current active hd chain of keys (uint256)\n+    static const std::string kvs_wtx_key                        = \"tx\";\n+    static const std::string kvs_address_book_metadata_key      = \"adrmeta\";\n+\n+\n     enum CREDIT_DEBIT_TYPE\n     {\n         CREDIT_DEBIT_TYPE_AVAILABLE = 0,\n@@ -31,7 +45,8 @@ namespace CoreWallet\n         int nVersion;\n         std::string label;\n         std::string purpose;\n-        \n+        std::map<std::string, std::string> destdata; //flexible key wallet store for the UI layer\n+\n         CAddressBookMetadata()\n         {\n             SetNull();\n@@ -45,6 +60,7 @@ namespace CoreWallet\n             nVersion = this->nVersion;\n             READWRITE(label);\n             READWRITE(purpose);\n+            READWRITE(destdata);\n         }\n         \n         void SetNull()\n@@ -107,6 +123,49 @@ namespace CoreWallet\n         CAmount nAmount;\n         bool fSubtractFeeFromAmount;\n     };\n+\n+    // WalletModel: a wallet metadata class\n+    class WalletModel\n+    {\n+    public:\n+        static const int CURRENT_VERSION=1;\n+        int nVersion;\n+\n+        Wallet* pWallet; //no persistance\n+        std::string walletID; //only A-Za-z0-9._-\n+        std::string strWalletFilename;\n+        int64_t nCreateTime; // 0 means unknown\n+\n+        WalletModel()\n+        {\n+            SetNull();\n+        }\n+\n+        WalletModel(const std::string& filenameIn, Wallet *pWalletIn)\n+        {\n+            SetNull();\n+\n+            strWalletFilename = filenameIn;\n+            pWallet = pWalletIn;\n+        }\n+\n+        void SetNull()\n+        {\n+            nVersion = CURRENT_VERSION;\n+            nCreateTime = 0;\n+            pWallet = NULL;\n+        }\n+\n+        ADD_SERIALIZE_METHODS;\n+\n+        template <typename Stream, typename Operation>\n+        inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+            READWRITE(this->nVersion);\n+            nVersion = this->nVersion;\n+            READWRITE(nCreateTime);\n+            READWRITE(strWalletFilename);\n+        }\n+    };\n }; // end namespace CoreWallet\n \n #endif\n\\ No newline at end of file"
      },
      {
        "sha": "2254e185426763de14d28c39a09044a319305f83",
        "filename": "src/corewallet/corewallet_db.cpp",
        "status": "modified",
        "additions": 26,
        "deletions": 26,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f21c70f3061c9fb0722f52aa694f704d976ef711/src/corewallet/corewallet_db.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f21c70f3061c9fb0722f52aa694f704d976ef711/src/corewallet/corewallet_db.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet_db.cpp?ref=f21c70f3061c9fb0722f52aa694f704d976ef711",
        "patch": "@@ -16,7 +16,7 @@ namespace CoreWallet\n     \n bool FileDB::WriteKey(const CPubKey& vchPubKey, const CPrivKey& vchPrivKey, const CKeyMetadata& keyMeta)\n {\n-    if (!Write(std::make_pair(std::string(\"keymeta\"), vchPubKey), keyMeta, false))\n+    if (!Write(std::make_pair(kvs_keymetadata_key, vchPubKey), keyMeta, false))\n         return false;\n     \n     // hash pubkey/privkey to accelerate wallet load\n@@ -25,64 +25,64 @@ bool FileDB::WriteKey(const CPubKey& vchPubKey, const CPrivKey& vchPrivKey, cons\n     vchKey.insert(vchKey.end(), vchPubKey.begin(), vchPubKey.end());\n     vchKey.insert(vchKey.end(), vchPrivKey.begin(), vchPrivKey.end());\n     \n-    return Write(std::make_pair(std::string(\"key\"), vchPubKey), std::make_pair(vchPrivKey, Hash(vchKey.begin(), vchKey.end())), false);\n+    return Write(std::make_pair(kvs_key_key, vchPubKey), std::make_pair(vchPrivKey, Hash(vchKey.begin(), vchKey.end())), false);\n }\n \n bool FileDB::WriteHDMasterSeed(const uint256& hash, const CKeyingMaterial& masterSeed)\n {\n-    return Write(std::make_pair(std::string(\"hdmasterseed\"), hash), masterSeed);\n+    return Write(std::make_pair(kvs_hd_master_seed_key, hash), masterSeed);\n }\n \n bool FileDB::WriteHDCryptedMasterSeed(const uint256& hash, const std::vector<unsigned char>& vchCryptedSecret)\n {\n-    if (!Write(std::make_pair(std::string(\"hdcryptedmasterseed\"), hash), vchCryptedSecret))\n+    if (!Write(std::make_pair(kvs_hd_encrypted_master_seed_key, hash), vchCryptedSecret))\n         return false;\n \n-    Erase(std::make_pair(std::string(\"hdmasterseed\"), hash));\n-    Erase(std::make_pair(std::string(\"hdmasterseed\"), hash));\n+    Erase(std::make_pair(kvs_hd_master_seed_key, hash));\n+    Erase(std::make_pair(kvs_hd_master_seed_key, hash));\n \n     return true;\n }\n \n bool FileDB::EraseHDMasterSeed(const uint256& hash)\n {\n-    return Erase(std::make_pair(std::string(\"hdmasterseed\"), hash));\n+    return Erase(std::make_pair(kvs_hd_master_seed_key, hash));\n }\n \n bool FileDB::WriteHDChain(const CHDChain &chain)\n {\n-    return Write(std::make_pair(std::string(\"hdchain\"), chain.chainHash), chain);\n+    return Write(std::make_pair(kvs_hd_hdchain_key, chain.chainHash), chain);\n }\n \n bool FileDB::WriteHDPubKey(const CHDPubKey& hdPubKey, const CKeyMetadata& keyMeta)\n {\n-    if (!Write(std::make_pair(std::string(\"keymeta\"), hdPubKey.pubkey),\n+    if (!Write(std::make_pair(kvs_keymetadata_key, hdPubKey.pubkey),\n                keyMeta))\n         return false;\n \n-    return Write(std::make_pair(std::string(\"hdpubkey\"), hdPubKey.pubkey), hdPubKey);\n+    return Write(std::make_pair(kvs_hdpubkey_key, hdPubKey.pubkey), hdPubKey);\n }\n \n bool FileDB::WriteHDAchiveChain(const uint256& hash)\n {\n-    return Write(std::string(\"hdactivechain\"), hash);\n+    return Write(kvs_hdactivechain_key, hash);\n }\n \n bool FileDB::WriteTx(uint256 hash, const WalletTx& wtx)\n {\n-    return Write(std::make_pair(std::string(\"tx\"), hash), wtx);\n+    return Write(std::make_pair(kvs_wtx_key, hash), wtx);\n }\n \n bool FileDB::EraseTx(uint256 hash)\n {\n-    return Erase(std::make_pair(std::string(\"tx\"), hash));\n+    return Erase(std::make_pair(kvs_wtx_key, hash));\n }\n \n bool ReadKeyValue(Wallet* pCoreWallet, CDataStream& ssKey, CDataStream& ssValue, std::string& strType, std::string& strErr)\n {\n     try {\n         ssKey >> strType;\n-        if (strType == \"key\")\n+        if (strType == kvs_key_key)\n         {\n             CPubKey vchPubKey;\n             ssKey >> vchPubKey;\n@@ -122,57 +122,57 @@ bool ReadKeyValue(Wallet* pCoreWallet, CDataStream& ssKey, CDataStream& ssValue,\n                 strErr = \"Error reading wallet database: CPrivKey corrupt\";\n                 return false;\n             }\n-            if (!pCoreWallet->LoadKey(key, vchPubKey))\n+            if (!pCoreWallet->InMemAddKey(key, vchPubKey))\n             {\n                 strErr = \"Error reading wallet database: LoadKey failed\";\n                 return false;\n             }\n         }\n-        else if (strType == \"keymeta\")\n+        else if (strType == kvs_keymetadata_key)\n         {\n             CPubKey vchPubKey;\n             ssKey >> vchPubKey;\n             CKeyMetadata keyMeta;\n             ssValue >> keyMeta;\n             \n-            pCoreWallet->LoadKeyMetadata(vchPubKey, keyMeta);\n+            pCoreWallet->InMemAddKeyMetadata(vchPubKey, keyMeta);\n             \n             // find earliest key creation time, as wallet birthday\n             if (!pCoreWallet->nTimeFirstKey ||\n                 (keyMeta.nCreateTime < pCoreWallet->nTimeFirstKey))\n                 pCoreWallet->nTimeFirstKey = keyMeta.nCreateTime;\n         }\n-        else if (strType == \"adrmeta\")\n+        else if (strType == kvs_address_book_metadata_key)\n         {\n             std::string strAddress;\n             CAddressBookMetadata metadata;\n             ssKey >> strAddress;\n             ssValue >> metadata;\n             pCoreWallet->mapAddressBook[CBitcoinAddress(strAddress).Get()] = metadata;\n         }\n-        else if (strType == \"hdmasterseed\")\n+        else if (strType == kvs_hd_master_seed_key)\n         {\n             uint256 masterPubKeyHash;\n             CKeyingMaterial masterSeed;\n             ssKey >> masterPubKeyHash;\n             ssValue >> masterSeed;\n             pCoreWallet->AddMasterSeed(masterPubKeyHash, masterSeed);\n         }\n-        else if (strType == \"hdcryptedmasterseed\")\n+        else if (strType == kvs_hd_encrypted_master_seed_key)\n         {\n             uint256 masterPubKeyHash;\n             std::vector<unsigned char> vchCryptedSecret;\n             ssKey >> masterPubKeyHash;\n             ssValue >> vchCryptedSecret;\n             pCoreWallet->AddCryptedMasterSeed(masterPubKeyHash, vchCryptedSecret);\n         }\n-        else if (strType == \"hdactivechain\")\n+        else if (strType == kvs_hdactivechain_key)\n         {\n             HDChainID chainID;\n             ssValue >> chainID;\n             pCoreWallet->HDSetActiveChainID(chainID, false); //don't check if the chain exists because this record could come in before the CHDChain object itself\n         }\n-        else if (strType == \"hdpubkey\")\n+        else if (strType == kvs_hdpubkey_key)\n         {\n             CHDPubKey hdPubKey;\n             ssValue >> hdPubKey;\n@@ -187,7 +187,7 @@ bool ReadKeyValue(Wallet* pCoreWallet, CDataStream& ssKey, CDataStream& ssValue,\n                 return false;\n             }\n         }\n-        else if (strType == \"hdchain\")\n+        else if (strType == kvs_hd_hdchain_key)\n         {\n             CHDChain chain;\n             ssValue >> chain;\n@@ -197,7 +197,7 @@ bool ReadKeyValue(Wallet* pCoreWallet, CDataStream& ssKey, CDataStream& ssValue,\n                 return false;\n             }\n         }\n-        else if (strType == \"tx\")\n+        else if (strType == kvs_wtx_key)\n         {\n             uint256 hash;\n             ssKey >> hash;\n@@ -239,13 +239,13 @@ bool FileDB::LoadWallet(Wallet* pCoreWallet)\n             {\n                 // losing keys is considered a catastrophic error, anything else\n                 // we assume the user can live with:\n-                if (strType == \"key\")\n+                if (strType == kvs_key_key)\n                     result = false;\n                 else\n                 {\n                     // Leave other errors alone, if we try to fix them we might make things worse.\n                     fNoncriticalErrors = true; // ... but do warn the user there is something wrong.\n-                    if (strType == \"tx\")\n+                    if (strType == kvs_wtx_key)\n                         // Rescan if there is a bad transaction record:\n                         SoftSetBoolArg(\"-rescan\", true);\n                 }"
      },
      {
        "sha": "125fcc9081f4964d7a669ea23333e1fea87c95fb",
        "filename": "src/corewallet/corewallet_rpc.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 7,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f21c70f3061c9fb0722f52aa694f704d976ef711/src/corewallet/corewallet_rpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f21c70f3061c9fb0722f52aa694f704d976ef711/src/corewallet/corewallet_rpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet_rpc.cpp?ref=f21c70f3061c9fb0722f52aa694f704d976ef711",
        "patch": "@@ -176,6 +176,8 @@ UniValue listaddresses(const UniValue& params, bool fHelp)\n                             + HelpExampleRpc(\"listaddresses\", \"\")\n                             );\n     UniValue ret(UniValue::VARR);\n+\n+    LOCK(wallet->cs_coreWallet);\n     BOOST_FOREACH(const PAIRTYPE(CBitcoinAddress, CAddressBookMetadata)& item, wallet->mapAddressBook)\n     {\n         const CBitcoinAddress& address = item.first;\n@@ -477,7 +479,7 @@ UniValue hdgetaddress(const UniValue& params, bool fHelp)\n     }\n     CKeyID keyID = newKey.GetID();\n     \n-    wallet->SetAddressBook(keyID, \"receive\");\n+    wallet->SetAndStoreAddressBook(keyID, \"receive\");\n     \n     UniValue result(UniValue::VOBJ);\n     result.push_back(Pair(\"address\", CBitcoinAddress(keyID).ToString()));\n@@ -508,12 +510,12 @@ void WalletTxToJSON(const Wallet* wallet, const WalletTx& wtx, UniValue& entry)\n     isminefilter filter = ISMINE_SPENDABLE; //TODO: make filter configurable over params\n \n     CAmount nCredit = wallet->GetCredit(wtx, filter);\n-    CAmount nDebit = wtx.GetDebit(filter);\n+    CAmount nDebit = wallet->GetDebit(wtx, filter);\n     CAmount nNet = nCredit - nDebit;\n-    CAmount nFee = (wtx.IsFromMe(filter) ? wtx.GetValueOut() - nDebit : 0);\n+    CAmount nFee = (wallet->IsFromMe(wtx, filter) ? wtx.GetValueOut() - nDebit : 0);\n \n     entry.push_back(Pair(\"amount\", ValueFromAmount(nNet - nFee)));\n-    if (wtx.IsFromMe(filter))\n+    if (wallet->IsFromMe(wtx, filter))\n         entry.push_back(Pair(\"fee\", ValueFromAmount(nFee)));\n \n \n@@ -528,14 +530,14 @@ UniValue listtransactions(const UniValue& params, bool fHelp)\n     Wallet *wallet = WalletFromParams(params);\n     \n     LOCK(wallet->cs_coreWallet);\n-    Wallet::TxItems txOrdered = wallet->OrderedTxItems();\n+    Wallet::WtxItems txOrdered = wallet->OrderedTxItems();\n \n     UniValue result(UniValue::VARR);\n \n     // iterate backwards until we have nCount items to return:\n-    for (Wallet::TxItems::reverse_iterator it = txOrdered.rbegin(); it != txOrdered.rend(); ++it)\n+    for (Wallet::WtxItems::reverse_iterator it = txOrdered.rbegin(); it != txOrdered.rend(); ++it)\n     {\n-        WalletTx *const pwtx = (*it).second.first;\n+        WalletTx *const pwtx = (*it).second;\n         UniValue entry(UniValue::VOBJ);\n         WalletTxToJSON(wallet, *pwtx, entry);\n         result.push_back(entry);"
      },
      {
        "sha": "7d59d173847d2915bad1c163734a2e155d2587c5",
        "filename": "src/corewallet/corewallet_wallet.cpp",
        "status": "modified",
        "additions": 127,
        "deletions": 106,
        "changes": 233,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f21c70f3061c9fb0722f52aa694f704d976ef711/src/corewallet/corewallet_wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f21c70f3061c9fb0722f52aa694f704d976ef711/src/corewallet/corewallet_wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet_wallet.cpp?ref=f21c70f3061c9fb0722f52aa694f704d976ef711",
        "patch": "@@ -48,20 +48,20 @@ Wallet::Wallet(std::string strWalletFileIn)\n     coreInterface = CoreInterface();\n }\n \n-bool Wallet::LoadKey(const CKey& key, const CPubKey &pubkey)\n+bool Wallet::InMemAddKey(const CKey& key, const CPubKey &pubkey)\n {\n     return CCryptoKeyStore::AddKeyPubKey(key, pubkey);\n }\n \n-bool Wallet::AddKeyPubKey(const CKey& secret, const CPubKey &pubkey)\n+bool Wallet::AddAndStoreKeyPubKey(const CKey& secret, const CPubKey &pubkey)\n {\n     if (!CCryptoKeyStore::AddKeyPubKey(secret, pubkey))\n         return false;\n     \n     return walletCacheDB->WriteKey(pubkey, secret.GetPrivKey(), mapKeyMetadata[pubkey.GetID()]);\n }\n \n-bool Wallet::LoadKeyMetadata(const CPubKey &pubkey, const CKeyMetadata &meta)\n+bool Wallet::InMemAddKeyMetadata(const CPubKey &pubkey, const CKeyMetadata &meta)\n {\n     LOCK(cs_coreWallet);\n     if (meta.nCreateTime && (!nTimeFirstKey || meta.nCreateTime < nTimeFirstKey))\n@@ -71,16 +71,17 @@ bool Wallet::LoadKeyMetadata(const CPubKey &pubkey, const CKeyMetadata &meta)\n     return true;\n }\n \n-bool Wallet::SetAddressBook(const CTxDestination& address, const std::string& strPurpose)\n+bool Wallet::SetAndStoreAddressBook(const CTxDestination& address, const std::string& strPurpose)\n {\n     LOCK(cs_coreWallet);\n     std::map<CTxDestination, CAddressBookMetadata> ::iterator mi = mapAddressBook.find(address);\n     if(mi == mapAddressBook.end())\n         mapAddressBook[address] = CAddressBookMetadata();\n     \n     mapAddressBook[address].purpose = strPurpose;\n-    \n-    return walletCacheDB->Write(std::make_pair(std::string(\"adrmeta\"), CBitcoinAddress(address).ToString()), mapAddressBook[address]);\n+\n+    //TODO: move to database and not directly call ->Write()\n+    return walletCacheDB->Write(std::make_pair(std::string(kvs_address_book_metadata_key), CBitcoinAddress(address).ToString()), mapAddressBook[address]);\n }\n \n \n@@ -320,28 +321,28 @@ const WalletTx* Wallet::GetWalletTx(const uint256& hash) const\n     return &(it->second);\n }\n \n-Wallet::TxItems Wallet::OrderedTxItems()\n+Wallet::WtxItems Wallet::OrderedTxItems()\n {\n     AssertLockHeld(cs_coreWallet); // mapWallet\n \n     // First: get all WalletTx and CAccountingEntry into a sorted-by-order multimap.\n-    TxItems txOrdered;\n+    WtxItems txOrdered;\n \n     // Note: maintaining indices in the database of (account,time) --> txid and (account, time) --> acentry\n     // would make this much faster for applications that do this a lot.\n     for (std::map<uint256, WalletTx>::iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n     {\n         WalletTx* wtx = &((*it).second);\n-        txOrdered.insert(std::make_pair(wtx->nOrderPos, TxPair(wtx, \"\")));\n+        txOrdered.insert(std::make_pair(wtx->nOrderPos, wtx));\n     }\n     \n     return txOrdered;\n }\n \n /*\n- ########################\n+ ###################\n  # Coin Lock Stack #\n- ########################\n+ ###################\n  */\n void Wallet::LockCoin(COutPoint& output)\n {\n@@ -401,7 +402,7 @@ bool Wallet::IsTrustedWTx(const WalletTx &wtx) const\n         return true;\n     if (nDepth < 0)\n         return false;\n-    if (!bSpendZeroConfChange || !wtx.IsFromMe(ISMINE_ALL)) // using wtx's cached debit\n+    if (!bSpendZeroConfChange || !IsFromMe(wtx, ISMINE_ALL)) // using wtx's cached debit\n         return false;\n \n     // Trusted if all inputs are from us and are in the mempool:\n@@ -527,7 +528,7 @@ bool Wallet::SelectCoinsMinConf(const CAmount& nTargetValue, int nConfMine, int\n \n         const WalletTx *pcoin = output.tx;\n \n-        if (output.nDepth < (pcoin->IsFromMe(ISMINE_ALL) ? nConfMine : nConfTheirs))\n+        if (output.nDepth < (IsFromMe(*pcoin, ISMINE_ALL) ? nConfMine : nConfTheirs))\n             continue;\n \n         int i = output.i;\n@@ -1044,83 +1045,13 @@ bool Wallet::RelayWalletTransaction(const WalletTx &wtx)\n  ######################\n */\n \n-std::set<uint256> Wallet::GetConflicts(const uint256& txid) const\n-{\n-    std::set<uint256> result;\n-    AssertLockHeld(cs_coreWallet);\n-\n-    std::map<uint256, WalletTx>::const_iterator it = mapWallet.find(txid);\n-    if (it == mapWallet.end())\n-        return result;\n-    const WalletTx& wtx = it->second;\n-\n-    std::pair<TxSpends::const_iterator, TxSpends::const_iterator> range;\n-\n-    BOOST_FOREACH(const CTxIn& txin, wtx.vin)\n-    {\n-        if (mapTxSpends.count(txin.prevout) <= 1)\n-            continue;  // No conflict if zero or one spends\n-        range = mapTxSpends.equal_range(txin.prevout);\n-        for (TxSpends::const_iterator it = range.first; it != range.second; ++it)\n-            result.insert(it->second);\n-    }\n-    return result;\n-}\n-\n-/**\n- * Outpoint is spent if any non-conflicted transaction\n- * spends it:\n- */\n-bool Wallet::IsSpent(const uint256& hash, unsigned int n) const\n-{\n-    AssertLockHeld(cs_coreWallet);\n-\n-    const COutPoint outpoint(hash, n);\n-    std::pair<TxSpends::const_iterator, TxSpends::const_iterator> range;\n-    range = mapTxSpends.equal_range(outpoint);\n-\n-    for (TxSpends::const_iterator it = range.first; it != range.second; ++it)\n-    {\n-        const uint256& wtxid = it->second;\n-        std::map<uint256, WalletTx>::const_iterator mit = mapWallet.find(wtxid);\n-        if (mit != mapWallet.end() && mit->second.GetDepthInMainChain() >= 0)\n-            return true; // Spent\n-    }\n-    return false;\n-}\n-\n-void Wallet::AddToSpends(const COutPoint& outpoint, const uint256& wtxid)\n-{\n-    AssertLockHeld(cs_coreWallet);\n-\n-    mapTxSpends.insert(std::make_pair(outpoint, wtxid));\n-\n-    std::pair<TxSpends::iterator, TxSpends::iterator> range;\n-    range = mapTxSpends.equal_range(outpoint);\n-    SyncMetaData(range);\n-}\n-\n-\n-void Wallet::AddToSpends(const uint256& wtxid)\n-{\n-    AssertLockHeld(cs_coreWallet);\n-\n-    assert(mapWallet.count(wtxid));\n-    WalletTx& thisTx = mapWallet[wtxid];\n-    if (thisTx.IsCoinBase()) // Coinbases don't spend anything!\n-        return;\n-    \n-    BOOST_FOREACH(const CTxIn& txin, thisTx.vin)\n-    AddToSpends(txin.prevout, wtxid);\n-}\n-\n-bool Wallet::AddToWallet(const WalletTx& wtxIn, bool fFromLoadWallet)\n+bool Wallet::AddToWallet(const WalletTx& wtxIn, bool fOnlyInMemory)\n {\n     LOCK(cs_coreWallet);\n \n     uint256 hash = wtxIn.GetHash();\n \n-    if (fFromLoadWallet)\n+    if (fOnlyInMemory)\n     {\n         //TODO add CheckTransaction from main.cpp like check\n         mapWallet[hash] = wtxIn;\n@@ -1150,10 +1081,10 @@ bool Wallet::AddToWallet(const WalletTx& wtxIn, bool fFromLoadWallet)\n                     {\n                         // Tolerate times up to the last timestamp in the wallet not more than 5 minutes into the future\n                         int64_t latestTolerated = latestNow + 300;\n-                        TxItems txOrdered = OrderedTxItems();\n-                        for (TxItems::reverse_iterator it = txOrdered.rbegin(); it != txOrdered.rend(); ++it)\n+                        WtxItems txOrdered = OrderedTxItems();\n+                        for (WtxItems::reverse_iterator it = txOrdered.rbegin(); it != txOrdered.rend(); ++it)\n                         {\n-                            WalletTx *const pwtx = (*it).second.first;\n+                            WalletTx *const pwtx = (*it).second;\n                             if (pwtx == &wtx)\n                                 continue;\n \n@@ -1272,9 +1203,18 @@ CAmount Wallet::GetDebit(const CTxIn &txin, const isminefilter& filter) const\n         if (mi != mapWallet.end())\n         {\n             const WalletTx& prev = (*mi).second;\n+\n+            CAmount debit = 0;\n+            if (prev.GetCache(CREDIT_DEBIT_TYPE_DEBIT, filter, debit))\n+                return debit;\n+\n             if (txin.prevout.n < prev.vout.size())\n                 if (IsMine(prev.vout[txin.prevout.n]) & filter)\n-                    return prev.vout[txin.prevout.n].nValue;\n+                {\n+                    debit = prev.vout[txin.prevout.n].nValue;\n+                    prev.SetCache(CREDIT_DEBIT_TYPE_DEBIT, filter, debit);\n+                    return debit;\n+                }\n         }\n     }\n     return 0;\n@@ -1300,16 +1240,111 @@ bool Wallet::IsMine(const CTransaction& tx) const\n     return false;\n }\n \n-bool Wallet::IsFromMe(const CTransaction& tx) const\n+bool Wallet::IsFromMe(const CTransaction& tx, const isminefilter& filter) const\n {\n-    return (GetDebit(tx, ISMINE_ALL) > 0);\n+    return (GetDebit(tx, filter) > 0);\n }\n \n bool Wallet::WriteWTXToDisk(const WalletTx &wtx)\n {\n     return walletCacheDB->WriteTx(wtx.GetHash(), wtx);\n }\n \n+void Wallet::SyncTransaction(const CTransaction& tx, const CBlock* pblock)\n+{\n+    LOCK(cs_coreWallet);\n+    if (!AddToWalletIfInvolvingMe(tx, pblock, true))\n+        return; // Not one of ours\n+\n+    // If a transaction changes 'conflicted' state, that changes the balance\n+    // available of the outputs it spends. So force those to be\n+    // recomputed, also:\n+    BOOST_FOREACH(const CTxIn& txin, tx.vin)\n+    {\n+        if (mapWallet.count(txin.prevout.hash))\n+            mapWallet[txin.prevout.hash].MarkDirty();\n+    }\n+}\n+\n+\n+\n+/*\n+ #############################\n+ # Conflict management stack #\n+ #############################\n+ */\n+\n+\n+std::set<uint256> Wallet::GetConflicts(const uint256& txid) const\n+{\n+    std::set<uint256> result;\n+    AssertLockHeld(cs_coreWallet);\n+\n+    std::map<uint256, WalletTx>::const_iterator it = mapWallet.find(txid);\n+    if (it == mapWallet.end())\n+        return result;\n+    const WalletTx& wtx = it->second;\n+\n+    std::pair<TxSpends::const_iterator, TxSpends::const_iterator> range;\n+\n+    BOOST_FOREACH(const CTxIn& txin, wtx.vin)\n+    {\n+        if (mapTxSpends.count(txin.prevout) <= 1)\n+            continue;  // No conflict if zero or one spends\n+        range = mapTxSpends.equal_range(txin.prevout);\n+        for (TxSpends::const_iterator it = range.first; it != range.second; ++it)\n+            result.insert(it->second);\n+    }\n+    return result;\n+}\n+\n+/**\n+ * Outpoint is spent if any non-conflicted transaction\n+ * spends it:\n+ */\n+bool Wallet::IsSpent(const uint256& hash, unsigned int n) const\n+{\n+    AssertLockHeld(cs_coreWallet);\n+\n+    const COutPoint outpoint(hash, n);\n+    std::pair<TxSpends::const_iterator, TxSpends::const_iterator> range;\n+    range = mapTxSpends.equal_range(outpoint);\n+\n+    for (TxSpends::const_iterator it = range.first; it != range.second; ++it)\n+    {\n+        const uint256& wtxid = it->second;\n+        std::map<uint256, WalletTx>::const_iterator mit = mapWallet.find(wtxid);\n+        if (mit != mapWallet.end() && mit->second.GetDepthInMainChain() >= 0)\n+            return true; // Spent\n+    }\n+    return false;\n+}\n+\n+void Wallet::AddToSpends(const COutPoint& outpoint, const uint256& wtxid)\n+{\n+    AssertLockHeld(cs_coreWallet);\n+\n+    mapTxSpends.insert(std::make_pair(outpoint, wtxid));\n+\n+    std::pair<TxSpends::iterator, TxSpends::iterator> range;\n+    range = mapTxSpends.equal_range(outpoint);\n+    SyncMetaData(range);\n+}\n+\n+\n+void Wallet::AddToSpends(const uint256& wtxid)\n+{\n+    AssertLockHeld(cs_coreWallet);\n+\n+    assert(mapWallet.count(wtxid));\n+    WalletTx& thisTx = mapWallet[wtxid];\n+    if (thisTx.IsCoinBase()) // Coinbases don't spend anything!\n+        return;\n+\n+    BOOST_FOREACH(const CTxIn& txin, thisTx.vin)\n+    AddToSpends(txin.prevout, wtxid);\n+}\n+\n void Wallet::SyncMetaData(std::pair<TxSpends::iterator, TxSpends::iterator> range)\n {\n     // We want all the wallet transactions in range to have the same metadata as\n@@ -1345,21 +1380,7 @@ void Wallet::SyncMetaData(std::pair<TxSpends::iterator, TxSpends::iterator> rang\n     }\n }\n \n-void Wallet::SyncTransaction(const CTransaction& tx, const CBlock* pblock)\n-{\n-    LOCK(cs_coreWallet);\n-    if (!AddToWalletIfInvolvingMe(tx, pblock, true))\n-        return; // Not one of ours\n \n-    // If a transaction changes 'conflicted' state, that changes the balance\n-    // available of the outputs it spends. So force those to be\n-    // recomputed, also:\n-    BOOST_FOREACH(const CTxIn& txin, tx.vin)\n-    {\n-        if (mapWallet.count(txin.prevout.hash))\n-            mapWallet[txin.prevout.hash].MarkDirty();\n-    }\n-}\n \n /*\n  #############################\n@@ -1495,9 +1516,9 @@ unsigned int Wallet::GetMaxStandardTxSize()\n     return coreInterface.GetMaxStandardTxSize();\n }\n \n-\n void Wallet::GetScriptForMining(boost::shared_ptr<CReserveScript> &script)\n {\n+    //used for mining (mainly for regression tests)\n     boost::shared_ptr<CHDReserveKey> rKey(new CHDReserveKey(this));\n     CPubKey pubkey;\n     if (!rKey->GetReservedKey(pubkey))"
      },
      {
        "sha": "607b1164056b3db33249fc56affca90595b4f16c",
        "filename": "src/corewallet/corewallet_wallet.h",
        "status": "modified",
        "additions": 76,
        "deletions": 82,
        "changes": 158,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f21c70f3061c9fb0722f52aa694f704d976ef711/src/corewallet/corewallet_wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f21c70f3061c9fb0722f52aa694f704d976ef711/src/corewallet/corewallet_wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet_wallet.h?ref=f21c70f3061c9fb0722f52aa694f704d976ef711",
        "patch": "@@ -37,24 +37,45 @@ extern CAmount maxTxFee;\n \n class Wallet : public CHDKeyStore, public CValidationInterface{\n private:\n+    //!default coin selection function\n     bool SelectCoins(const CAmount& nTargetValue, std::set<std::pair<const WalletTx*,unsigned int> >& setCoinsRet, CAmount& nValueRet, const CCoinControl *coinControl = NULL) const;\n+\n+    //!wallet tx map\n+    std::map<uint256, WalletTx> mapWallet;\n+\n+    //!in memory only map that tracks how many nodes did request a certain hash (mainly tx hash)\n+    std::map<uint256, int> mapRequestCount;\n+\n+protected:\n+    CoreInterface coreInterface; //!instance of a interface between bitcoin-core and the corewallet module\n+    bool fBroadcastTransactions;\n+\n+    //!Add a transaction to the wallet if it's relevant\n+    bool AddToWalletIfInvolvingMe(const CTransaction& tx, const CBlock* pblock, bool fUpdate);\n+\n+    //!write a wtx to disk\n+    bool WriteWTXToDisk(const WalletTx &wtx);\n+    const WalletTx* GetWalletTx(const uint256& hash) const;\n+    bool IsTrustedWTx(const WalletTx &wtx) const;\n+\n public:\n     static CFeeRate minTxFee;\n-    CoreInterface coreInterface;\n \n-    mutable CCriticalSection cs_coreWallet;\n-    std::map<CKeyID, CKeyMetadata> mapKeyMetadata;\n-    std::map<CTxDestination, CAddressBookMetadata> mapAddressBook;\n-    std::map<uint256, int> mapRequestCount;\n-    std::map<uint256, WalletTx> mapWallet;\n-    std::set<COutPoint> setLockedCoins;\n-    int64_t nTimeFirstKey;\n+    mutable CCriticalSection cs_coreWallet; //main wallet lock\n+    std::map<CKeyID, CKeyMetadata> mapKeyMetadata; //!map of all generated/derived keys\n+    std::map<CTxDestination, CAddressBookMetadata> mapAddressBook; //!addressbook with a variant (CScript/CKeyID)\n+    std::set<COutPoint> setLockedCoins; //! set for locking coins (in mem only)\n+\n+    int64_t nTimeFirstKey; //!oldest key timestamp\n+\n+    //wallet backends\n     FileDB *walletPrivateDB;\n     FileDB *walletCacheDB;\n \n     //! state: current active hd chain, must be protected over cs_coreWallet\n     HDChainID activeHDChain;\n \n+    //!wallet constructor, will open wallet and read the database and map everyhing into memory\n     Wallet(std::string strWalletFileIn);\n \n     //!adds a hd chain of keys to the wallet\n@@ -74,29 +95,36 @@ class Wallet : public CHDKeyStore, public CValidationInterface{\n \n     //!set the active chain of keys\n     bool HDGetActiveChainID(HDChainID& chainID);\n-    \n-    bool AddKeyPubKey(const CKey& key, const CPubKey &pubkey);\n-    bool LoadKeyMetadata(const CPubKey &pubkey, const CoreWallet::CKeyMetadata &metadata);\n-    bool LoadKey(const CKey& key, const CPubKey &pubkey);\n-    bool SetAddressBook(const CTxDestination& address, const std::string& purpose);\n \n+    //!add a key to the keystore (mem only)\n+    bool InMemAddKey(const CKey& key, const CPubKey &pubkey);\n+    bool InMemAddKeyMetadata(const CPubKey &pubkey, const CoreWallet::CKeyMetadata &metadata);\n+\n+     //!add a key to the keystore and store in into the database\n+    bool AddAndStoreKeyPubKey(const CKey& key, const CPubKey &pubkey);\n+    bool SetAndStoreAddressBook(const CTxDestination& address, const std::string& purpose);\n \n+    //! inform wallet about a new arrived transaction\n     void SyncTransaction(const CTransaction& tx, const CBlock* pblock);\n \n-    //receiving stack\n-    bool AddToWallet(const WalletTx& wtxIn, bool fFromLoadWallet);\n-    bool AddToWalletIfInvolvingMe(const CTransaction& tx, const CBlock* pblock, bool fUpdate);\n-    isminetype IsMine(const CTxIn& txin) const;\n+    /*\n+     receiving stack\n+     */\n+    //! Add a transaction to the mapWallet (if fOnlyInMemory is false, it will also be stored into the database)\n+    //no signal are called if fOnlyInMemory == true\n+    bool AddToWallet(const WalletTx& wtxIn, bool fOnlyInMemory);\n+\n     CAmount GetDebit(const CTxIn& txin, const isminefilter& filter) const;\n-    isminetype IsMine(const CTxOut& txout) const;\n-    CAmount GetCredit(const CTxOut& txout, const isminefilter& filter) const;\n-    bool IsMine(const CTransaction& tx) const;\n-    /** should probably be renamed to IsRelevantToMe */\n-    bool IsFromMe(const CTransaction& tx) const;\n     CAmount GetDebit(const CTransaction& tx, const isminefilter& filter) const;\n+    CAmount GetCredit(const CTxOut& txout, const isminefilter& filter) const;\n     CAmount GetCredit(const CTransaction& tx, const isminefilter& filter) const;\n \n-    bool fBroadcastTransactions;\n+    isminetype IsMine(const CTxIn& txin) const;\n+    isminetype IsMine(const CTxOut& txout) const;\n+    bool IsMine(const CTransaction& tx) const;\n+    bool IsFromMe(const CTransaction& tx, const isminefilter& filter = ISMINE_ALL) const;\n+\n+\n     /** Inquire whether this wallet broadcasts transactions. */\n     bool GetBroadcastTransactions() const { return fBroadcastTransactions; }\n     /** Set whether this wallet broadcasts transactions. */\n@@ -116,95 +144,61 @@ class Wallet : public CHDKeyStore, public CValidationInterface{\n     bool IsSpent(const uint256& hash, unsigned int n) const;\n     void SyncMetaData(std::pair<TxSpends::iterator, TxSpends::iterator>);\n \n-    const WalletTx* GetWalletTx(const uint256& hash) const;\n-\n-    typedef std::pair<WalletTx*, std::string > TxPair;\n-    typedef std::multimap<int64_t, TxPair > TxItems;\n-    Wallet::TxItems OrderedTxItems();\n-\n-    bool WriteWTXToDisk(const WalletTx &wtx);\n-\n-    bool IsTrustedWTx(const WalletTx &wtx) const;\n-    void AvailableCoins(std::vector<COutput>& vCoins, bool fOnlyConfirmed, const CCoinControl *coinControl, bool fIncludeZeroValue = false) const;\n+    //!sort mapWallet to a ordered multimap\n+    typedef std::multimap<int64_t, WalletTx*> WtxItems;\n+    Wallet::WtxItems OrderedTxItems();\n \n+    //coin locking functions\n     bool IsLockedCoin(uint256 hash, unsigned int n) const;\n     void LockCoin(COutPoint& output);\n     void UnlockCoin(COutPoint& output);\n     void UnlockAllCoins();\n     void ListLockedCoins(std::vector<COutPoint>& vOutpts);\n \n-    //Balance funtions // needs refactor\n+    //Balance funtions\n     CAmount GetBalance(const enum CREDIT_DEBIT_TYPE &balanceType, const isminefilter& filter) const;\n \n+    //Broadcast a wtx over connected core interface\n     bool RelayWalletTransaction(const WalletTx &wtx);\n \n+    //Coin selection and create transaction functions\n+    //!get all available coins\n+    void AvailableCoins(std::vector<COutput>& vCoins, bool fOnlyConfirmed, const CCoinControl *coinControl, bool fIncludeZeroValue = false) const;\n+    //!select coins for a target value\n     bool SelectCoinsMinConf(const CAmount& nTargetValue, int nConfMine, int nConfTheirs, std::vector<COutput> vCoins, std::set<std::pair<const WalletTx*,unsigned int> >& setCoinsRet, CAmount& nValueRet) const;\n+    //!create a transaction for n recipients, auto-add a change output\n     bool CreateTransaction(const std::vector<CRecipient>& vecSend, WalletTx& wtxNew, CReserveKey& reservekey, CAmount& nFeeRet, int& nChangePosRet, std::string& strFailReason, const CCoinControl *coinControl = NULL, bool sign = true);\n     bool CommitTransaction(WalletTx& wtxNew, CReserveKey& reservekey);\n     CAmount GetMinimumFee(unsigned int nTxBytes, unsigned int nConfirmTarget);\n \n-    //core node interaction\n+\n+    /* \n+     core node interaction\n+     */\n     const CBlockIndex* GetBlockIndex(uint256 blockhash, bool inActiveChain = false) const;\n     int GetActiveChainHeight() const;\n     int MempoolExists(uint256 hash) const;\n     bool AcceptToMemoryPool(const WalletTx &wtx, bool fLimitFree=true, bool fRejectAbsurdFee=true);\n     CFeeRate GetMinRelayTxFee();\n     unsigned int GetMaxStandardTxSize();\n \n-    //mining\n+\n+\n+    /*\n+     mining\n+     */\n     void GetScriptForMining(boost::shared_ptr<CReserveScript> &script);\n \n-    /**\n-     * Wallet transaction added, removed or updated.\n-     * @note called with lock cs_wallet held.\n+\n+\n+    /*\n+     signals\n      */\n+    //!Wallet transaction added, removed or updated.\n     boost::signals2::signal<void (Wallet *wallet, const uint256 &hashTx,\n                                   ChangeType status)> NotifyTransactionChanged;\n };\n \n-// WalletModel: a wallet metadata class\n-class WalletModel\n-{\n-public:\n-    static const int CURRENT_VERSION=1;\n-    int nVersion;\n-    \n-    Wallet* pWallet; //no persistance\n-    std::string walletID; //only A-Za-z0-9._-\n-    std::string strWalletFilename;\n-    int64_t nCreateTime; // 0 means unknown\n-    \n-    WalletModel()\n-    {\n-        SetNull();\n-    }\n-    \n-    WalletModel(const std::string& filenameIn, Wallet *pWalletIn)\n-    {\n-        SetNull();\n-        \n-        strWalletFilename = filenameIn;\n-        pWallet = pWalletIn;\n-    }\n-    \n-    void SetNull()\n-    {\n-        nVersion = CURRENT_VERSION;\n-        nCreateTime = 0;\n-        pWallet = NULL;\n-    }\n-    \n-    ADD_SERIALIZE_METHODS;\n-    \n-    template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n-        READWRITE(this->nVersion);\n-        nVersion = this->nVersion;\n-        READWRITE(nCreateTime);\n-        READWRITE(strWalletFilename);\n-    }\n-};\n-\n /** A key allocated from the key pool. */\n class CReserveKey : public CReserveScript\n {"
      },
      {
        "sha": "21e25fe4b2b4349625c3fc4a36443f28203da658",
        "filename": "src/corewallet/corewallet_wtx.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 19,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f21c70f3061c9fb0722f52aa694f704d976ef711/src/corewallet/corewallet_wtx.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f21c70f3061c9fb0722f52aa694f704d976ef711/src/corewallet/corewallet_wtx.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet_wtx.cpp?ref=f21c70f3061c9fb0722f52aa694f704d976ef711",
        "patch": "@@ -27,25 +27,6 @@ bool WalletTx::RelayWalletTransaction()\n     return false;\n }\n \n-CAmount WalletTx::GetDebit(const isminefilter& filter) const\n-{\n-    if (vin.empty())\n-        return 0;\n-\n-    CAmount debit = 0;\n-    CAmount cacheOut;\n-    if (GetCache(CREDIT_DEBIT_TYPE_DEBIT, filter, cacheOut))\n-        debit += cacheOut;\n-    else\n-    {\n-        cacheOut = pwallet->GetDebit(*this, filter);\n-        SetCache(CREDIT_DEBIT_TYPE_DEBIT, filter, cacheOut);\n-        debit += cacheOut;\n-    }\n-    \n-    return debit;\n-}\n-\n int64_t WalletTx::GetTxTime() const\n {\n     int64_t n = nTimeSmart;"
      },
      {
        "sha": "ee08bebea15e792cf8cce4c5b5be3e08ed31d759",
        "filename": "src/corewallet/corewallet_wtx.h",
        "status": "modified",
        "additions": 0,
        "deletions": 5,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f21c70f3061c9fb0722f52aa694f704d976ef711/src/corewallet/corewallet_wtx.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f21c70f3061c9fb0722f52aa694f704d976ef711/src/corewallet/corewallet_wtx.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet_wtx.h?ref=f21c70f3061c9fb0722f52aa694f704d976ef711",
        "patch": "@@ -130,7 +130,6 @@ class WalletTx : public CTransaction\n     }\n \n     //! filter decides which addresses will count towards the debit\n-    CAmount GetDebit(const isminefilter& filter) const;\n     CAmount GetChange() const;\n \n     void GetAmounts(std::list<COutputEntry>& listReceived,\n@@ -139,10 +138,6 @@ class WalletTx : public CTransaction\n     void GetAccountAmounts(const std::string& strAccount, CAmount& nReceived,\n                            CAmount& nSent, CAmount& nFee, const isminefilter& filter) const;\n     \n-    bool IsFromMe(const isminefilter& filter) const\n-    {\n-        return (GetDebit(filter) > 0);\n-    }\n \n     int64_t GetTxTime() const;\n     int GetRequestCount() const;"
      }
    ]
  },
  {
    "sha": "b951a040f622e60e21d9eee7067819314a360348",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiOTUxYTA0MGY2MjJlNjBlMjFkOWVlZTcwNjc4MTkzMTRhMzYwMzQ4",
    "commit": {
      "author": {
        "name": "Jonas Schnelli",
        "email": "jonas.schnelli@include7.ch",
        "date": "2015-07-07T10:11:54Z"
      },
      "committer": {
        "name": "Jonas Schnelli",
        "email": "jonas.schnelli@include7.ch",
        "date": "2015-07-08T14:57:54Z"
      },
      "message": "[corewallet] refactor rpc help/error handling",
      "tree": {
        "sha": "1890c3315996145d8a7ec7e0ea884ccc7751129d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1890c3315996145d8a7ec7e0ea884ccc7751129d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b951a040f622e60e21d9eee7067819314a360348",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b951a040f622e60e21d9eee7067819314a360348",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b951a040f622e60e21d9eee7067819314a360348",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b951a040f622e60e21d9eee7067819314a360348/comments",
    "author": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f21c70f3061c9fb0722f52aa694f704d976ef711",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f21c70f3061c9fb0722f52aa694f704d976ef711",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f21c70f3061c9fb0722f52aa694f704d976ef711"
      }
    ],
    "stats": {
      "total": 147,
      "additions": 117,
      "deletions": 30
    },
    "files": [
      {
        "sha": "8753b2eaeea02df2890d9d43bb0380853fad8e78",
        "filename": "src/corewallet/corewallet_rpc.cpp",
        "status": "modified",
        "additions": 117,
        "deletions": 30,
        "changes": 147,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b951a040f622e60e21d9eee7067819314a360348/src/corewallet/corewallet_rpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b951a040f622e60e21d9eee7067819314a360348/src/corewallet/corewallet_rpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet_rpc.cpp?ref=b951a040f622e60e21d9eee7067819314a360348",
        "patch": "@@ -13,12 +13,16 @@\n #include \"utilstrencodings.h\"\n #include \"utilmoneystr.h\"\n \n+#include <list>\n+#include <algorithm>\n #include <string>\n \n #include \"univalue/univalue.h\"\n \n-#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n+#include <boost/algorithm/string/case_conv.hpp>\n+#include <boost/algorithm/string/join.hpp>\n #include <boost/algorithm/string/replace.hpp>\n+#include <boost/assign/list_of.hpp>\n #include <boost/foreach.hpp>\n \n namespace CoreWallet\n@@ -45,6 +49,30 @@ struct RPCDispatchEntry\n     rpcfn_type actor;\n };\n \n+enum ParamVTypes { VFLEX, VSTR, VNUM, VBOOL };\n+\n+struct RPCParamEntry\n+{\n+    bool mandatory;\n+    std::string key;\n+    enum ParamVTypes vtype;\n+    std::string helptext;\n+    std::string example;\n+};\n+\n+const char *RPCTypeName(enum ParamVTypes t)\n+{\n+    switch (t) {\n+        case VFLEX: return \"not defined\";\n+        case VBOOL: return \"bool\";\n+        case VSTR: return \"string\";\n+        case VNUM: return \"number\";\n+    }\n+    \n+    // not reached\n+    return NULL;\n+}\n+\n //dispatch compatible rpc function definitions\n UniValue hdaddchain(const UniValue& params, bool fHelp);\n UniValue hdsetchain(const UniValue& params, bool fHelp);\n@@ -61,7 +89,6 @@ UniValue createtx(const UniValue& params, bool fHelp);\n UniValue getbalance(const UniValue& params, bool fHelp);\n     \n static const RPCDispatchEntry vDispatchEntries[] = {\n-    { \"getnewaddress\",                    &getnewaddress },\n     { \"listaddresses\",                    &listaddresses },\n \n     { \"hdaddchain\",                       &hdaddchain },\n@@ -105,6 +132,86 @@ Wallet* WalletFromParams(const UniValue& params)\n     return wallet;\n }\n \n+void AllowKeysInParams(const std::string &callname, const UniValue& params, bool forceHelp, Wallet *wallet, RPCParamEntry *allowedParams, const std::string &helptext) {\n+    unsigned int i;\n+\n+    std::string errorPart = \"\";\n+    for (i = 0; i < (sizeof(*allowedParams) / sizeof(RPCParamEntry)); i++)\n+    {\n+        RPCParamEntry *param = &allowedParams[i];\n+\n+        bool found = false;\n+        bool typeCheck = false;\n+        if (params.size() > 0 && params[0].isObject())\n+        {\n+            const UniValue& o = params[0].get_obj();\n+            BOOST_FOREACH(const std::string &key, o.getKeys())\n+            {\n+                UniValue val = find_value(o, key);\n+                std::string lowercaseKey = key;\n+                boost::to_lower(lowercaseKey);\n+                if (lowercaseKey == param->key)\n+                {\n+                    found = true;\n+\n+                    if (param->vtype == VSTR && val.isStr())\n+                        typeCheck = true;\n+                    if (param->vtype == VNUM && val.isNum())\n+                        typeCheck = true;\n+                    if (param->vtype == VBOOL && val.isBool())\n+                        typeCheck = true;\n+                    if (param->vtype == VFLEX)\n+                        typeCheck = true;\n+\n+                    break;\n+                }\n+            }\n+        }\n+\n+        if (param->mandatory && !found)\n+            errorPart += \"Parameter \"+SanitizeString(param->key)+\" not found but is required\\n\";\n+\n+        if (found && !typeCheck)\n+            errorPart += \"Parameter \"+SanitizeString(param->key)+\" has wrong type (TODO)\\n\";\n+    }\n+\n+    //check if we have a unrecognized parameter\n+    if (params.size() > 0 && params[0].isObject())\n+    {\n+        const UniValue& o = params[0].get_obj();\n+        BOOST_FOREACH(const std::string &key, o.getKeys())\n+        {\n+            bool found = false;\n+            unsigned int i;\n+            for (i = 0; i < (sizeof(*allowedParams) / sizeof(RPCParamEntry)); i++)\n+            {\n+                RPCParamEntry *param = &allowedParams[i];\n+                std::string lowercaseKey = key;\n+                boost::to_lower(lowercaseKey);\n+                if (param->key == lowercaseKey)\n+                {\n+                    found = true;\n+                    break;\n+                }\n+            }\n+            if (!found)\n+                errorPart += \"Parameter \"+SanitizeString(key)+\" is unknown\\n\";\n+        }\n+    }\n+\n+    if (errorPart.size() > 0 || forceHelp)\n+    {\n+        std::string paramText = \"\";\n+        unsigned int i;\n+        for (i = 0; i < (sizeof(*allowedParams) / sizeof(RPCParamEntry)); i++)\n+        {\n+            RPCParamEntry *param = &allowedParams[i];\n+            paramText += param->key+\" (\"+(param->mandatory ? \"reuired\" : \"optional\")+\", \"+RPCTypeName(param->vtype)+\" \"+param->helptext+\"\\n\";\n+        }\n+        throw RPCHelpException(errorPart+\"\\n\"+callname+\"\\n\"+helptext+\"\\n\"+paramText);\n+    }\n+}\n+\n //! search in exiting json object for a key/value pair and returns value\n UniValue ValueFromParams(const UniValue& params, const std::string& key, UniValue::VType forceType = UniValue::VNULL)\n {\n@@ -140,25 +247,6 @@ UniValue ValueFromParams(const UniValue& params, const std::string& key, UniValu\n ///////////////////////////\n // Keys/Addresses stack\n ///////////////////////////\n-UniValue getnewaddress(const UniValue& params, bool fHelp)\n-{\n-    Wallet *wallet = WalletFromParams(params);\n-    if (fHelp || !wallet)\n-        throw RPCHelpException(\n-                            \"getnewaddress\\n\"\n-                            \"\\nReturns a new non-deterministic Bitcoin address for receiving payments.\\n\"\n-                            \"\\nResult:\\n\"\n-                            \"\\\"bitcoinaddress\\\"    (string) The new bitcoin address\\n\"\n-                            \"\\nExamples:\\n\"\n-                            + HelpExampleCli(\"getaddress\", \"\")\n-                            + HelpExampleRpc(\"getaddress\", \"\")\n-                            );\n-    \n-\n-    //TODO: non deterministic single key generation\n-\n-    return NullUniValue;\n-}\n \n UniValue listaddresses(const UniValue& params, bool fHelp)\n {\n@@ -197,15 +285,14 @@ UniValue listaddresses(const UniValue& params, bool fHelp)\n UniValue addwallet(const UniValue& params, bool fHelp)\n {\n     UniValue walletIDValue = ValueFromParams(params, \"walletid\");\n-    if (fHelp || walletIDValue.isNull())\n-        throw RPCHelpException(\n-                             \"addwallet walletid=<walletid>\\n\"\n-                             \"\\nArguments:\\n\"\n-                             \"  \\\"walletid\\\"    (string, required) allowed characters: A-Za-z0-9._-\\n\"\n-                             \"\\nExamples:\\n\"\n-                             + HelpExampleCli(\"addwallet\", \"\\\"anotherwallet\\\"\")\n-                             + HelpExampleRpc(\"addwallet\", \"\\\"anotherwallet\\\"\")\n-                             );\n+    static RPCParamEntry allowedParams[] = {\n+        { true, \"wallteid\", VSTR, \"allowed characters: A-Za-z0-9._-\", \"testwallet\"}\n+    };\n+\n+    AllowKeysInParams(\"addwallet\", params, fHelp, NULL, allowedParams,\n+                      \"\\nCreates a new wallet with given walletid.\\n\"\n+                      \"\\nResult:\\n\"\n+                      \"\\\"bitcoinaddress\\\"    (string) The new bitcoin address\\n\");\n \n     std::string walletID = walletIDValue.get_str();\n     CoreWallet::GetManager()->AddNewWallet(walletID);"
      }
    ]
  },
  {
    "sha": "dfec9c42da33c5591d2216d6d33628542e64b85e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkZmVjOWM0MmRhMzNjNTU5MWQyMjE2ZDZkMzM2Mjg1NDJlNjRiODVl",
    "commit": {
      "author": {
        "name": "Jonas Schnelli",
        "email": "jonas.schnelli@include7.ch",
        "date": "2015-07-08T14:44:05Z"
      },
      "committer": {
        "name": "Jonas Schnelli",
        "email": "jonas.schnelli@include7.ch",
        "date": "2015-07-08T14:57:54Z"
      },
      "message": "[corewallet] add getter for HDPubKey in hdkeystore",
      "tree": {
        "sha": "846c8e023319309961e5a0024cf0a35bf884a637",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/846c8e023319309961e5a0024cf0a35bf884a637"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/dfec9c42da33c5591d2216d6d33628542e64b85e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dfec9c42da33c5591d2216d6d33628542e64b85e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/dfec9c42da33c5591d2216d6d33628542e64b85e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dfec9c42da33c5591d2216d6d33628542e64b85e/comments",
    "author": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b951a040f622e60e21d9eee7067819314a360348",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b951a040f622e60e21d9eee7067819314a360348",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b951a040f622e60e21d9eee7067819314a360348"
      }
    ],
    "stats": {
      "total": 18,
      "additions": 18,
      "deletions": 0
    },
    "files": [
      {
        "sha": "6571059ca76af1b3eec4caf52b3c5f166a9fa3e7",
        "filename": "src/corewallet/hdkeystore.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dfec9c42da33c5591d2216d6d33628542e64b85e/src/corewallet/hdkeystore.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dfec9c42da33c5591d2216d6d33628542e64b85e/src/corewallet/hdkeystore.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/hdkeystore.cpp?ref=dfec9c42da33c5591d2216d6d33628542e64b85e",
        "patch": "@@ -106,6 +106,21 @@ bool CHDKeyStore::LoadHDPubKey(const CHDPubKey &pubkey)\n     return true;\n }\n \n+bool CHDKeyStore::GetHDPubKey(const CKeyID &address, CHDPubKey &pubkeyOut) const\n+{\n+    LOCK(cs_KeyStore);\n+    if (mapHDPubKeys.count(address) > 0)\n+    {\n+        std::map<CKeyID, CHDPubKey>::const_iterator mi = mapHDPubKeys.find(address);\n+        if (mi != mapHDPubKeys.end())\n+        {\n+            pubkeyOut = mi->second;\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n bool CHDKeyStore::GetAvailableChainIDs(std::vector<HDChainID>& chainIDs)\n {\n     LOCK(cs_KeyStore);"
      },
      {
        "sha": "18b598d72e81b987997ec64c3928190cca9ddbb6",
        "filename": "src/corewallet/hdkeystore.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dfec9c42da33c5591d2216d6d33628542e64b85e/src/corewallet/hdkeystore.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dfec9c42da33c5591d2216d6d33628542e64b85e/src/corewallet/hdkeystore.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/hdkeystore.h?ref=dfec9c42da33c5591d2216d6d33628542e64b85e",
        "patch": "@@ -166,6 +166,9 @@ class CHDKeyStore : public CCryptoKeyStore\n \n     //!get a pubkey with given keyid for verifiying, etc.\n     bool GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const;\n+\n+    //!get a hdpubkey\n+    bool GetHDPubKey(const CKeyID &address, CHDPubKey &pubkeyOut) const;\n };\n };  //end namespace\n #endif // BITCOIN_WALLET_HDKEYSTORE_H\n\\ No newline at end of file"
      }
    ]
  },
  {
    "sha": "50a8c57652777d26a15a79e7e000ac4b573f6006",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1MGE4YzU3NjUyNzc3ZDI2YTE1YTc5ZTdlMDAwYWM0YjU3M2Y2MDA2",
    "commit": {
      "author": {
        "name": "Jonas Schnelli",
        "email": "jonas.schnelli@include7.ch",
        "date": "2015-07-08T14:45:22Z"
      },
      "committer": {
        "name": "Jonas Schnelli",
        "email": "jonas.schnelli@include7.ch",
        "date": "2015-07-08T14:57:54Z"
      },
      "message": "[corewallet] rpc cleanup, add verifying of params, better help",
      "tree": {
        "sha": "f0e6c7d429d75fc9aaefdbe56319229b820c0a29",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f0e6c7d429d75fc9aaefdbe56319229b820c0a29"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/50a8c57652777d26a15a79e7e000ac4b573f6006",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/50a8c57652777d26a15a79e7e000ac4b573f6006",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/50a8c57652777d26a15a79e7e000ac4b573f6006",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/50a8c57652777d26a15a79e7e000ac4b573f6006/comments",
    "author": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "dfec9c42da33c5591d2216d6d33628542e64b85e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dfec9c42da33c5591d2216d6d33628542e64b85e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/dfec9c42da33c5591d2216d6d33628542e64b85e"
      }
    ],
    "stats": {
      "total": 497,
      "additions": 284,
      "deletions": 213
    },
    "files": [
      {
        "sha": "369c97f066756cdb5bb66d43ec38eab6a7421a04",
        "filename": "src/corewallet/corewallet_basics.h",
        "status": "modified",
        "additions": 26,
        "deletions": 12,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/50a8c57652777d26a15a79e7e000ac4b573f6006/src/corewallet/corewallet_basics.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/50a8c57652777d26a15a79e7e000ac4b573f6006/src/corewallet/corewallet_basics.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet_basics.h?ref=50a8c57652777d26a15a79e7e000ac4b573f6006",
        "patch": "@@ -42,6 +42,7 @@ namespace CoreWallet\n     {\n     public:\n         static const int CURRENT_VERSION=1;\n+\n         int nVersion;\n         std::string label;\n         std::string purpose;\n@@ -73,23 +74,25 @@ namespace CoreWallet\n     {\n     public:\n         static const int CURRENT_VERSION=1;\n+        static const uint8_t KEY_ORIGIN_UNSET         = 0x0000;\n+        static const uint8_t KEY_ORIGIN_UNKNOWN       = 0x0001;\n+        static const uint8_t KEY_ORIGIN_IMPORTED      = 0x0002;\n+        static const uint8_t KEY_ORIGIN_UNENC_WALLET  = 0x0004;\n+        static const uint8_t KEY_ORIGIN_ENC_WALLET    = 0x0008;\n+\n         int nVersion;\n         int64_t nCreateTime; // 0 means unknown\n+        uint8_t keyFlags;\n         std::string label;\n         std::string purpose;\n         \n-        // BIP32 metadata.\n-        CKeyID keyidParent;\n-        uint32_t nDerivationIndex;\n-        int nDepth;\n-        \n         CKeyMetadata()\n         {\n             SetNull();\n         }\n         CKeyMetadata(int64_t nCreateTime_)\n         {\n-            nVersion = CKeyMetadata::CURRENT_VERSION;\n+            SetNull();\n             nCreateTime = nCreateTime_;\n         }\n         \n@@ -102,18 +105,29 @@ namespace CoreWallet\n             READWRITE(nCreateTime);\n             READWRITE(label);\n             READWRITE(purpose);\n-            READWRITE(keyidParent);\n-            READWRITE(nDerivationIndex);\n-            READWRITE(nDepth);\n+            READWRITE(keyFlags);\n         }\n         \n         void SetNull()\n         {\n             nVersion = CKeyMetadata::CURRENT_VERSION;\n             nCreateTime = 0;\n-            keyidParent = CKeyID();\n-            nDerivationIndex = 0;\n-            nDepth = 0;\n+            keyFlags = KEY_ORIGIN_UNSET;\n+        }\n+\n+        std::string KeyflagsAsString() const\n+        {\n+            std::string keyFlagsStr;\n+            if (keyFlags & CKeyMetadata::KEY_ORIGIN_UNKNOWN)\n+                keyFlagsStr = \"unknown\";\n+            if (keyFlags & CKeyMetadata::KEY_ORIGIN_ENC_WALLET)\n+                keyFlagsStr = \"created_in_encrypted_wallet\";\n+            else if (keyFlags & CKeyMetadata::KEY_ORIGIN_UNENC_WALLET)\n+                keyFlagsStr = \"created_in_unencrypted_wallet\";\n+            if (keyFlags & CKeyMetadata::KEY_ORIGIN_IMPORTED)\n+                keyFlagsStr = \"imported\";\n+\n+            return keyFlagsStr;\n         }\n     };\n "
      },
      {
        "sha": "86086ef6ea641c2b58e6989f9a9bf39f05be2e33",
        "filename": "src/corewallet/corewallet_rpc.cpp",
        "status": "modified",
        "additions": 255,
        "deletions": 200,
        "changes": 455,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/50a8c57652777d26a15a79e7e000ac4b573f6006/src/corewallet/corewallet_rpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/50a8c57652777d26a15a79e7e000ac4b573f6006/src/corewallet/corewallet_rpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet_rpc.cpp?ref=50a8c57652777d26a15a79e7e000ac4b573f6006",
        "patch": "@@ -7,6 +7,7 @@\n #include \"corewallet/corewallet.h\"\n \n #include \"base58.h\"\n+#include \"chainparamsbase.h\"\n #include \"core_io.h\"\n #include \"pubkey.h\"\n #include \"rpcserver.h\"\n@@ -19,11 +20,10 @@\n \n #include \"univalue/univalue.h\"\n \n-#include <boost/algorithm/string/case_conv.hpp>\n-#include <boost/algorithm/string/join.hpp>\n-#include <boost/algorithm/string/replace.hpp>\n+#include <boost/algorithm/string.hpp>\n #include <boost/assign/list_of.hpp>\n #include <boost/foreach.hpp>\n+#include <boost/lexical_cast.hpp>\n \n namespace CoreWallet\n {\n@@ -49,14 +49,15 @@ struct RPCDispatchEntry\n     rpcfn_type actor;\n };\n \n-enum ParamVTypes { VFLEX, VSTR, VNUM, VBOOL };\n+enum ParamVTypes { VFLEX, VSTR, VNUM, VARR, VOBJ, VBOOL };\n \n struct RPCParamEntry\n {\n     bool mandatory;\n     std::string key;\n     enum ParamVTypes vtype;\n     std::string helptext;\n+    std::string defaultvalue;\n     std::string example;\n };\n \n@@ -67,12 +68,26 @@ const char *RPCTypeName(enum ParamVTypes t)\n         case VBOOL: return \"bool\";\n         case VSTR: return \"string\";\n         case VNUM: return \"number\";\n+        case VARR: return \"array\";\n+        case VOBJ: return \"object\";\n+\n     }\n     \n     // not reached\n     return NULL;\n }\n \n+std::string HelpExampleCli(const std::string& methodname, const std::string& args)\n+{\n+    return \"> bitcoin-cli \" + methodname + \" \" + args + \"\\n\";\n+}\n+\n+std::string HelpExampleRpc(const std::string& methodname, const std::string& args)\n+{\n+    return \"> curl --user bitcoinrpc:<password> --data-binary '{\\\"jsonrpc\\\": \\\"1.0\\\", \\\"id\\\":\\\"curltest\\\", \"\n+    \"\\\"method\\\": \\\"\" + methodname + \"\\\", \\\"params\\\": [\" + args + \"] }' -H 'content-type: text/plain;' http://127.0.0.1:\"+boost::lexical_cast<std::string>(BaseParams().RPCPort())+\"/corewallet\\n\";\n+}\n+\n //dispatch compatible rpc function definitions\n UniValue hdaddchain(const UniValue& params, bool fHelp);\n UniValue hdsetchain(const UniValue& params, bool fHelp);\n@@ -117,8 +132,8 @@ static const RPCDispatchEntry vDispatchEntries[] = {\n //! try to filter out the desired wallet instance via given params\n Wallet* WalletFromParams(const UniValue& params)\n {\n-    std::string walletID = \"\"; //\"\" stands for default wallet\n-    if (params.size() > 0 && params[0].isObject()) //TODO also allow params at index position different the 0\n+    std::string walletID = \"\";\n+    if (params.size() > 0 && params[0].isObject())\n     {\n         const UniValue& o = params[0].get_obj();\n         UniValue possibleValue = find_value(o, \"walletid\");\n@@ -132,33 +147,42 @@ Wallet* WalletFromParams(const UniValue& params)\n     return wallet;\n }\n \n-void AllowKeysInParams(const std::string &callname, const UniValue& params, bool forceHelp, Wallet *wallet, RPCParamEntry *allowedParams, const std::string &helptext) {\n+//Verifies given and expected parameters and form a help string if required\n+void VerifyParams(const std::string &callname, const UniValue& params, bool forceHelp, RPCParamEntry *allowedParams, unsigned int aPsize, const std::string &helptext) {\n     unsigned int i;\n \n+    if (params.size() > 0 && (!params[0].isObject()))\n+        throw RPCHelpException(\"Corewallet only supports key=value parameters\");\n+\n     std::string errorPart = \"\";\n-    for (i = 0; i < (sizeof(*allowedParams) / sizeof(RPCParamEntry)); i++)\n+    for (i = 0; i < aPsize; i++)\n     {\n         RPCParamEntry *param = &allowedParams[i];\n \n         bool found = false;\n         bool typeCheck = false;\n+        UniValue::VType hasType = UniValue::VNULL;\n+\n         if (params.size() > 0 && params[0].isObject())\n         {\n             const UniValue& o = params[0].get_obj();\n             BOOST_FOREACH(const std::string &key, o.getKeys())\n             {\n                 UniValue val = find_value(o, key);\n-                std::string lowercaseKey = key;\n-                boost::to_lower(lowercaseKey);\n-                if (lowercaseKey == param->key)\n+                if (boost::to_lower_copy(key) == param->key)\n                 {\n                     found = true;\n-\n+                    hasType = val.getType();\n                     if (param->vtype == VSTR && val.isStr())\n                         typeCheck = true;\n-                    if (param->vtype == VNUM && val.isNum())\n-                        typeCheck = true;\n-                    if (param->vtype == VBOOL && val.isBool())\n+                    if (param->vtype == VNUM)\n+                    {\n+                        UniValue testVal(UniValue::VNUM);\n+                        testVal.setNumStr(val.get_str()); //also allow VSTR if it can be converted to VNUM\n+                        if (testVal.isNum())\n+                            typeCheck = true;\n+                    }\n+                    if ( (param->vtype == VBOOL && val.isBool() ) || (val.isStr() && (boost::to_lower_copy(val.get_str()) == \"true\" || val.get_str() == \"1\")))\n                         typeCheck = true;\n                     if (param->vtype == VFLEX)\n                         typeCheck = true;\n@@ -172,7 +196,7 @@ void AllowKeysInParams(const std::string &callname, const UniValue& params, bool\n             errorPart += \"Parameter \"+SanitizeString(param->key)+\" not found but is required\\n\";\n \n         if (found && !typeCheck)\n-            errorPart += \"Parameter \"+SanitizeString(param->key)+\" has wrong type (TODO)\\n\";\n+            errorPart += \"Parameter \"+SanitizeString(param->key)+\" has wrong type ('\"+uvTypeName(hasType)+\"' but should be '\"+RPCTypeName(param->vtype)+\"')\\n\";\n     }\n \n     //check if we have a unrecognized parameter\n@@ -183,12 +207,10 @@ void AllowKeysInParams(const std::string &callname, const UniValue& params, bool\n         {\n             bool found = false;\n             unsigned int i;\n-            for (i = 0; i < (sizeof(*allowedParams) / sizeof(RPCParamEntry)); i++)\n+            for (i = 0; i < aPsize; i++)\n             {\n                 RPCParamEntry *param = &allowedParams[i];\n-                std::string lowercaseKey = key;\n-                boost::to_lower(lowercaseKey);\n-                if (param->key == lowercaseKey)\n+                if (param->key == boost::to_lower_copy(key))\n                 {\n                     found = true;\n                     break;\n@@ -202,13 +224,28 @@ void AllowKeysInParams(const std::string &callname, const UniValue& params, bool\n     if (errorPart.size() > 0 || forceHelp)\n     {\n         std::string paramText = \"\";\n+        std::string keylistText = \"\";\n+        std::string exampleCLIText = \"\";\n+        std::string exampleRPCText = \"\";\n+\n         unsigned int i;\n-        for (i = 0; i < (sizeof(*allowedParams) / sizeof(RPCParamEntry)); i++)\n+        for (i = 0; i < aPsize; i++)\n         {\n+            if (paramText == \"\")\n+                paramText = \"Arguments:\\n\";\n+\n             RPCParamEntry *param = &allowedParams[i];\n-            paramText += param->key+\" (\"+(param->mandatory ? \"reuired\" : \"optional\")+\", \"+RPCTypeName(param->vtype)+\" \"+param->helptext+\"\\n\";\n+            paramText += param->key+\" (\"+(param->mandatory ? \"required\" : \"optional\")+\", \"+RPCTypeName(param->vtype)+\") \"+param->helptext+\"\\n\";\n+\n+            keylistText += (param->mandatory ? \"\" : \"(\") + param->key + (param->mandatory ? \"\" : \")\");\n+            exampleCLIText += param->key+\"=\"+param->example+\" \";\n+            exampleRPCText += \"\\\"\"+param->key+\"\\\":\"+(param->vtype == VSTR ? \"\\\"\" : \"\")+param->example+(param->vtype == VSTR ? \"\\\"\" : \"\")+\" \";\n         }\n-        throw RPCHelpException(errorPart+\"\\n\"+callname+\"\\n\"+helptext+\"\\n\"+paramText);\n+        boost::trim_right(exampleCLIText);\n+        boost::trim_right(exampleRPCText);\n+\n+        //generate the huge help string\n+        throw RPCHelpException(errorPart+\"\\ncorewallet/\"+callname+\" \"+keylistText+\"\\n\"+boost::replace_all_copy(boost::replace_all_copy(helptext, \"%args%\", paramText), \"%examples%\", \"Examples:\\n\"+HelpExampleCli(callname, exampleCLIText)+HelpExampleRpc(callname, \"{\"+exampleRPCText+\"}\")));\n     }\n }\n \n@@ -220,10 +257,14 @@ UniValue ValueFromParams(const UniValue& params, const std::string& key, UniValu\n         const UniValue& o = params[0].get_obj();\n         UniValue val = find_value(o, key);\n         if (forceType == UniValue::VNUM && val.isStr())\n+        {\n             val.setNumStr(val.get_str()); //convert str to int\n+            if (!val.isNum())\n+                throw std::runtime_error(\"Parameter '\"+SanitizeString(key)+\"' is not numeric\");\n+        }\n         if (forceType == UniValue::VBOOL)\n         {\n-            if (val.isStr() && ( val.get_str() == \"true\" || val.get_str() == \"1\" ))\n+            if (val.isStr() && ( boost::to_lower_copy(val.get_str()) == \"true\" || val.get_str() == \"1\" ))\n                 val.setBool(true);\n             else\n                 val.setBool(false);\n@@ -250,31 +291,63 @@ UniValue ValueFromParams(const UniValue& params, const std::string& key, UniValu\n \n UniValue listaddresses(const UniValue& params, bool fHelp)\n {\n+    VerifyParams( \"listaddresses\", params, fHelp, NULL, 0,\n+                 \"\\nList all available addresses.\\n\"\n+                 \"%args%\"\n+                 \"\\nResult:\\n\"\n+                 \"[                     (json array of string)\\n\"\n+                 \"  \\\"bitcoinaddress\\\"  (string) a bitcoin address\\n\"\n+                 \"  ,...\\n\"\n+                 \"]\\n\"\n+                 \"\\n%examples%\"\n+                 );\n+\n     Wallet *wallet = WalletFromParams(params);\n-    if (fHelp || !wallet)\n-        throw RPCHelpException(\n-                            \"listaddresses\\n\"\n-                            \"\\nResult:\\n\"\n-                            \"[                     (json array of string)\\n\"\n-                            \"  \\\"bitcoinaddress\\\"  (string) a bitcoin address\\n\"\n-                            \"  ,...\\n\"\n-                            \"]\\n\"\n-                            \"\\nExamples:\\n\"\n-                            + HelpExampleCli(\"listaddresses\", \"\")\n-                            + HelpExampleRpc(\"listaddresses\", \"\")\n-                            );\n+\n     UniValue ret(UniValue::VARR);\n \n     LOCK(wallet->cs_coreWallet);\n-    BOOST_FOREACH(const PAIRTYPE(CBitcoinAddress, CAddressBookMetadata)& item, wallet->mapAddressBook)\n+    std::vector<CKeyID> alreadyAdded;\n+\n+    BOOST_FOREACH(const PAIRTYPE(CKeyID, CKeyMetadata)& item, wallet->mapKeyMetadata)\n     {\n-        const CBitcoinAddress& address = item.first;\n-        const CAddressBookMetadata& metadata = item.second;\n+        const CKeyID& keyID = item.first;\n+        const CBitcoinAddress& address = CBitcoinAddress(keyID);\n+\n         UniValue obj(UniValue::VOBJ);\n-        obj.push_back(Pair(address.ToString(), metadata.purpose));\n+        obj.push_back(Pair(\"address\", address.ToString()));\n+\n+        std::map<CTxDestination, CAddressBookMetadata>::const_iterator miAddr = wallet->mapAddressBook.find(keyID);\n+        if (miAddr != wallet->mapAddressBook.end())\n+        {\n+            obj.push_back(Pair(\"addressbook\", true));\n+            obj.push_back(Pair(\"purpose\", miAddr->second.purpose));\n+        }\n+        else\n+            obj.push_back(Pair(\"addressbook\", false));\n+\n+        CHDPubKey hdPubKey;\n+        if (wallet->GetHDPubKey(keyID, hdPubKey))\n+        {\n+            obj.push_back(Pair(\"hd\", true));\n+            obj.push_back(Pair(\"chainpath\", hdPubKey.chainPath));\n+        }\n+        else\n+            obj.push_back(Pair(\"hd\", false));\n+\n+        std::map<CKeyID, CKeyMetadata>::const_iterator miKMeta = wallet->mapKeyMetadata.find(keyID);\n+        if (miKMeta != wallet->mapKeyMetadata.end())\n+        {\n+            obj.push_back(Pair(\"createtime\", miKMeta->second.nCreateTime));\n+            obj.push_back(Pair(\"keyflags\", miKMeta->second.KeyflagsAsString()));\n+        }\n+        else\n+            obj.push_back(Pair(\"missing_key_metadata\", true));\n+\n+\n         ret.push_back(obj);\n+        alreadyAdded.push_back(keyID);\n     }\n-    \n     return ret;\n }\n \n@@ -284,15 +357,17 @@ UniValue listaddresses(const UniValue& params, bool fHelp)\n ///////////////////////////\n UniValue addwallet(const UniValue& params, bool fHelp)\n {\n-    UniValue walletIDValue = ValueFromParams(params, \"walletid\");\n     static RPCParamEntry allowedParams[] = {\n-        { true, \"wallteid\", VSTR, \"allowed characters: A-Za-z0-9._-\", \"testwallet\"}\n+        { true, \"walletid\", VSTR, \"allowed characters: A-Za-z0-9._-\", \"\", \"testwallet\"}\n     };\n \n-    AllowKeysInParams(\"addwallet\", params, fHelp, NULL, allowedParams,\n-                      \"\\nCreates a new wallet with given walletid.\\n\"\n-                      \"\\nResult:\\n\"\n-                      \"\\\"bitcoinaddress\\\"    (string) The new bitcoin address\\n\");\n+    VerifyParams( \"addwallet\", params, fHelp, allowedParams, 1,\n+                  \"\\nCreates a new wallet with given walletid.\\n\"\n+                  \"%args%\"\n+                  \"\\n%examples%\"\n+                  );\n+\n+    UniValue walletIDValue = ValueFromParams(params, \"walletid\");\n \n     std::string walletID = walletIDValue.get_str();\n     CoreWallet::GetManager()->AddNewWallet(walletID);\n@@ -301,24 +376,25 @@ UniValue addwallet(const UniValue& params, bool fHelp)\n \n UniValue listwallets(const UniValue& params, bool fHelp)\n {\n-    if (fHelp)\n-        throw RPCHelpException(\n-                                 \"listwallets\\n\"\n-                                 \"\\nResult:\\n\"\n-                                 \"[                     (json array of string)\\n\"\n-                                 \"  \\\"mainWallet\\\"  (string) a wallet identifier\\n\"\n-                                 \"  \\\"anotherWallet\\\"\\n\"\n-                                 \"]\\n\"\n-                                 \"\\nExamples:\\n\"\n-                                 + HelpExampleCli(\"listwallets\", \"\")\n-                                 + HelpExampleRpc(\"listwallets\", \"\")\n-                                 );\n+    VerifyParams( \"listwallets\", params, fHelp, NULL, 0,\n+                  \"\\nList all available wallets.\\n\"\n+                  \"%args%\"\n+                  \"\\nResult:\\n\"\n+                  \"[\\n\"\n+                  \"  {\\n\"\n+                  \"      \\\"walletid\\\": \\\"<walletname>\\\"      (string) a wallet identifier\\n\"\n+                  \"  }\\n\"\n+                  \"]\\n\"\n+                  \"\\n%examples%\"\n+                  );\n     \n     UniValue ret(UniValue::VARR);\n     std::vector<std::string> vWalletIDs = CoreWallet::GetManager()->GetWalletIDs();\n     BOOST_FOREACH(const std::string& walletID, vWalletIDs)\n     {\n-        ret.push_back(walletID);\n+        UniValue wObj(UniValue::VOBJ);\n+        wObj.push_back(Pair(\"wallteid\", walletID));\n+        ret.push_back(wObj);\n     }\n     \n     return ret;\n@@ -329,15 +405,16 @@ UniValue listwallets(const UniValue& params, bool fHelp)\n ///////////////////////////\n UniValue help(const UniValue& params, bool fHelp)\n {\n-    if (fHelp || params.size() == 1)\n-        throw RPCHelpException(\n-                            \"help ( \\\"command\\\" )\\n\"\n-                            \"\\nList all commands, or get help for a specified command.\\n\"\n-                            \"\\nArguments:\\n\"\n-                            \"1. \\\"command\\\"     (string, optional) The command to get help on\\n\"\n-                            \"\\nResult:\\n\"\n-                            \"\\\"text\\\"     (string) The help text\\n\"\n-                            );\n+    static RPCParamEntry allowedParams[] = {\n+        { true, \"command\", VSTR, \"The command to get help on\", \"\", \"corewallet/listwallets\"}\n+    };\n+    VerifyParams( \"help\", params, fHelp, allowedParams, 1,\n+                 \"\\nList all commands, or get help for a specified command.\\n\"\n+                 \"%args%\"\n+                 \"\\nResult:\\n\"\n+                 \"\\\"text\\\"     (string) The help text\\n\"\n+                 \"\\n%examples%\"\n+                 );\n     \n     std::string helpString = \"\\n== CoreWallet ==\\n\";\n     UniValue value = ValueFromParams(params, \"command\");\n@@ -391,33 +468,25 @@ const std::string hd_default_chainpath = \"m/44'/0'/0'/c\";\n \n UniValue hdaddchain(const UniValue& params, bool fHelp)\n {\n-    if (fHelp)\n-        throw std::runtime_error(\n-                            \"hdaddchain (<chainpath>|default) (<masterseed_hex>)\\n\"\n-                            \"\\nAdds a HD/Bip32 chain \\n\"\n-                            \"\\nArguments:\\n\"\n-                            \"1. chainpath        (string, optional, default=\"+hd_default_chainpath+\") chainpath for hd wallet structure\\n\"\n-                            \"   m stands for master, c for internal/external key-switch, k stands for upcounting child key index\"\n-                            \"2. masterseed_hex   (string/hex, optional) use this seed for master key generation\\n\"\n-                            \"\\nResult\\n\"\n-                            \"{\\n\"\n-                            \"  \\\"seed_hex\\\" : \\\"<hexstr>\\\",  (string) seed used during master key generation (only if no masterseed hex was provided\\n\"\n-                            \"}\\n\"\n-\n-                            \"\\nExamples\\n\"\n-                            + HelpExampleCli(\"hdaddchain\", \"set\")\n-                            + HelpExampleCli(\"hdaddchain\", \"set m/44'/0'/0'/c/k\")\n-                            + HelpExampleRpc(\"hdaddchain\", \"set m/44'/0'/0'/c/k\")\n-                            );\n+    static RPCParamEntry allowedParams[] = {\n+        { false, \"chainpath\", VSTR, \"chainpath for hd wallet structure\\nm stands for master, c for internal/external key-switch, k stands for upcounting child key index\", \"m/44h/0h/0h/c/k\", \"m/32h/c/k\"},\n+        { false, \"seed\", VSTR, \"use this seed for master key generation\", \"\", \"abcdef...\"},\n+    };\n+    VerifyParams(\"hdaddchain\", params, fHelp, allowedParams, 2,\n+                 \"\\nList all commands, or get help for a specified command.\\n\"\n+                 \"%args%\"\n+                 \"\\nResult\\n\"\n+                 \"{\\n\"\n+                 \"  \\\"seed_hex\\\" : \\\"<hexstr>\\\",  (string) seed used during master key generation (only if no masterseed hex was provided\\n\"\n+                 \"}\\n\"\n+                 \"\\n%examples%\"\n+                 );\n \n     UniValue result(UniValue::VOBJ);\n-\n     Wallet *wallet = WalletFromParams(params);\n     UniValue chainpathParam = ValueFromParams(params, \"chainpath\");\n     UniValue seedParam = ValueFromParams(params, \"seed\");\n \n-    //EnsureWalletIsUnlocked();\n-\n     const unsigned int bip32MasterSeedLength = 32;\n     CKeyingMaterial vSeed = CKeyingMaterial(bip32MasterSeedLength);\n     bool fGenerateMasterSeed = true;\n@@ -450,21 +519,17 @@ UniValue hdaddchain(const UniValue& params, bool fHelp)\n \n UniValue hdsetchain(const UniValue& params, bool fHelp)\n {\n-    if (fHelp)\n-        throw std::runtime_error(\n-                            \"hdsetchain <chainid>\\n\"\n-                            \"\\nReturns some hd relevant information.\\n\"\n-                            \"\\nArguments:\\n\"\n-                            \"1. \\\"chainid\\\"        (string|hex, required) chainid is a bitcoin hash of the master public key of the corresponding chain.\\n\"\n-                            \"\\nExamples:\\n\"\n-                            + HelpExampleCli(\"hdsetchain\", \"\")\n-                            + HelpExampleCli(\"hdgetinfo\", \"True\")\n-                            + HelpExampleRpc(\"hdgetinfo\", \"\")\n-                            );\n+    static RPCParamEntry allowedParams[] = {\n+        { true, \"chainid\", VSTR, \"chainid is a bitcoin hash of the master public key of the corresponding chain.\", \"\", \"e2e658234be33a32ab60831d44190d397497aad0f45e6a2d59f69c3a34d4d9b6\"}\n+    };\n+    VerifyParams(\"hdsetchain\", params, fHelp, allowedParams, 1,\n+                 \"\\nSet the active chains of key.\\n\"\n+                 \"%args%\"\n+                 \"\\n%examples%\"\n+                 );\n \n     Wallet *wallet = WalletFromParams(params);\n     UniValue chainIdParam = ValueFromParams(params, \"chainid\");\n-\n     HDChainID chainId;\n     if (!chainIdParam.isStr() && !IsHex(chainIdParam.get_str()))\n         throw std::runtime_error(\"Chain id format is invalid\");\n@@ -479,24 +544,19 @@ UniValue hdsetchain(const UniValue& params, bool fHelp)\n \n UniValue hdgetinfo(const UniValue& params, bool fHelp)\n {\n-    if (fHelp || params.size() != 0)\n-        throw std::runtime_error(\n-                            \"hdgetinfo\\n\"\n-                            \"\\nReturns some hd relevant information.\\n\"\n-                            \"\\nArguments:\\n\"\n-                            \"{\\n\"\n-                            \"  \\\"chainid\\\" : \\\"<chainid>\\\",  string) A bitcoinhash of the master public key\\n\"\n-                            \"  \\\"creationtime\\\" : The creation time in seconds since epoch (midnight Jan 1 1970 GMT).\\n\"\n-                            \"  \\\"chainpath\\\" : \\\"<keyschainpath>\\\",  string) The chainpath (like m/44'/0'/0'/c)\\n\"\n-                            \"}\\n\"\n-                            \"\\nExamples:\\n\"\n-                            + HelpExampleCli(\"hdgetinfo\", \"\")\n-                            + HelpExampleCli(\"hdgetinfo\", \"True\")\n-                            + HelpExampleRpc(\"hdgetinfo\", \"\")\n-                            );\n+    VerifyParams(\"hdgetinfo\", params, fHelp, NULL, 0,\n+                 \"\\nReturns some hd relevant information.\\n\"\n+                 \"%args%\"\n+                 \"\\nResult\\n\"\n+                 \"{\\n\"\n+                 \"  \\\"chainid\\\": \\\"<chainid>\\\",           (string) A bitcoinhash of the master public key\\n\"\n+                 \"  \\\"creationtime\\\": <timestamp>,        (numeric) The creation time in seconds since epoch (midnight Jan 1 1970 GMT).\\n\"\n+                 \"  \\\"chainpath\\\": \\\"<keyschainpath>\\\",   (string) The chainpath (like m/44'/0'/0'/c)\\n\"\n+                 \"}\\n\"\n+                 \"\\n%examples%\"\n+                 );\n \n     Wallet *wallet = WalletFromParams(params);\n-\n     std::vector<HDChainID> chainIDs;\n     if (!wallet->GetAvailableChainIDs(chainIDs))\n         throw std::runtime_error(\"Could not load chain ids\");\n@@ -528,22 +588,21 @@ UniValue hdgetinfo(const UniValue& params, bool fHelp)\n \n UniValue hdgetaddress(const UniValue& params, bool fHelp)\n {\n-    if (fHelp || params.size() > 1)\n-        throw std::runtime_error(\n-                            \"hdgetaddress (<childindex>)\\n\"\n-                            \"\\nReturns a Bitcoin address for receiving payments.\\n\"\n-                            \"\\nAutomatically uses the next available childindex if no index is given\"\n-                            \"\\nArguments:\\n\"\n-                            \"1. \\\"childindex\\\"        (numeric, optional) child key index. ATTENTION: automatic index counting will start at the highes available child key index\\n\"\n-                            \"{\\n\"\n-                            \"  \\\"address\\\" : \\\"<address>\\\",  string) The new bitcoin address\\n\"\n-                            \"  \\\"chainpath\\\" : \\\"<keyschainpath>\\\",  string) The used chainpath\\n\"\n-                            \"}\\n\"\n-                            \"\\nExamples:\\n\"\n-                            + HelpExampleCli(\"hdgetaddress\", \"\")\n-                            + HelpExampleCli(\"hdgetaddress\", \"100\")\n-                            + HelpExampleRpc(\"hdgetaddress\", \"\")\n-                            );\n+    static RPCParamEntry allowedParams[] = {\n+        { false, \"index\", VNUM, \"child key index. ATTENTION: automatic index counting will start at the highes available child key index\", \"\", \"100\"},\n+        { false, \"internal\", VBOOL, \"if true, the internal chain will be used for the new key\", \"\", \"false\"}\n+    };\n+    VerifyParams(\"hdgetaddress\", params, fHelp, allowedParams, 2,\n+                 \"\\nReturns a Bitcoin address for receiving payments.\\n\"\n+                 \"Automatically uses the next available childindex if no index is given\\n\"\n+                 \"\\n%args%\"\n+                 \"\\nResult\\n\"\n+                 \"{\\n\"\n+                 \"  \\\"address\\\" : \\\"<address>\\\",          (string) the new bitcoin address\\n\"\n+                 \"  \\\"chainpath\\\" : \\\"<keyschainpath>\\\",  (string) used chainpath\\n\"\n+                 \"}\\n\"\n+                 \"\\n%examples%\"\n+                 );\n \n     Wallet *wallet = WalletFromParams(params);\n     UniValue childIndex = ValueFromParams(params, \"index\", UniValue::VNUM);\n@@ -613,7 +672,6 @@ void WalletTxToJSON(const Wallet* wallet, const WalletTx& wtx, UniValue& entry)\n \n UniValue listtransactions(const UniValue& params, bool fHelp)\n {\n-\n     Wallet *wallet = WalletFromParams(params);\n     \n     LOCK(wallet->cs_coreWallet);\n@@ -635,45 +693,36 @@ UniValue listtransactions(const UniValue& params, bool fHelp)\n \n UniValue listunspent(const UniValue& params, bool fHelp)\n {\n-    Wallet *wallet = WalletFromParams(params);\n+    static RPCParamEntry allowedParams[] = {\n+        { false, \"minconf\", VNUM, \"The minimum confirmations to filter\", \"1\", \"2\"},\n+        { false, \"maxconf\", VNUM, \"The maximum confirmations to filter\", \"9999999\", \"10\"},\n+        { false, \"addresses\", VARR, \"A json array of bitcoin addresses to filter\", \"\", \"[\\\"1PGFqEzfmQch1gKD3ra4k18PNj3tTUUSqg\\\"]\"},\n+    };\n \n-    if (fHelp)\n-        throw std::runtime_error(\n-                            \"listunspent ( minconf maxconf  [\\\"address\\\",...] )\\n\"\n-                            \"\\nReturns array of unspent transaction outputs\\n\"\n-                            \"with between minconf and maxconf (inclusive) confirmations.\\n\"\n-                            \"Optionally filter to only include txouts paid to specified addresses.\\n\"\n-                            \"Results are an array of Objects, each of which has:\\n\"\n-                            \"{txid, vout, scriptPubKey, amount, confirmations}\\n\"\n-                            \"\\nArguments:\\n\"\n-                            \"1. minconf          (numeric, optional, default=1) The minimum confirmations to filter\\n\"\n-                            \"2. maxconf          (numeric, optional, default=9999999) The maximum confirmations to filter\\n\"\n-                            \"3. \\\"addresses\\\"    (string) A json array of bitcoin addresses to filter\\n\"\n-                            \"    [\\n\"\n-                            \"      \\\"address\\\"   (string) bitcoin address\\n\"\n-                            \"      ,...\\n\"\n-                            \"    ]\\n\"\n-                            \"\\nResult\\n\"\n-                            \"[                   (array of json object)\\n\"\n-                            \"  {\\n\"\n-                            \"    \\\"txid\\\" : \\\"txid\\\",        (string) the transaction id \\n\"\n-                            \"    \\\"vout\\\" : n,               (numeric) the vout value\\n\"\n-                            \"    \\\"address\\\" : \\\"address\\\",  (string) the bitcoin address\\n\"\n-                            \"    \\\"account\\\" : \\\"account\\\",  (string) DEPRECATED. The associated account, or \\\"\\\" for the default account\\n\"\n-                            \"    \\\"scriptPubKey\\\" : \\\"key\\\", (string) the script key\\n\"\n-                            \"    \\\"amount\\\" : x.xxx,         (numeric) the transaction amount in btc\\n\"\n-                            \"    \\\"confirmations\\\" : n       (numeric) The number of confirmations\\n\"\n-                            \"  }\\n\"\n-                            \"  ,...\\n\"\n-                            \"]\\n\"\n-\n-                            \"\\nExamples\\n\"\n-                            + HelpExampleCli(\"listunspent\", \"\")\n-                            + HelpExampleCli(\"listunspent\", \"6 9999999 \\\"[\\\\\\\"1PGFqEzfmQch1gKD3ra4k18PNj3tTUUSqg\\\\\\\",\\\\\\\"1LtvqCaApEdUGFkpKMM4MstjcaL4dKg8SP\\\\\\\"]\\\"\")\n-                            + HelpExampleRpc(\"listunspent\", \"6, 9999999 \\\"[\\\\\\\"1PGFqEzfmQch1gKD3ra4k18PNj3tTUUSqg\\\\\\\",\\\\\\\"1LtvqCaApEdUGFkpKMM4MstjcaL4dKg8SP\\\\\\\"]\\\"\")\n-                            );\n-\n-    //RPCTypeCheck(params, boost::assign::list_of(UniValue::VNUM)(UniValue::VNUM)(UniValue::VARR));\n+    VerifyParams(\"listunspent\", params, fHelp, allowedParams, 3,\n+                 \"\\nReturns array of unspent transaction outputs\\n\"\n+                 \"with between minconf and maxconf (inclusive) confirmations.\\n\"\n+                 \"Optionally filter to only include txouts paid to specified addresses.\\n\"\n+                 \"Results are an array of Objects, each of which has:\\n\"\n+                 \"{txid, vout, scriptPubKey, amount, confirmations}\\n\"\n+                 \"%args%\"\n+                 \"\\nResult\\n\"\n+                 \"[                   (array of json object)\\n\"\n+                 \"  {\\n\"\n+                 \"    \\\"txid\\\" : \\\"txid\\\",        (string) the transaction id \\n\"\n+                 \"    \\\"vout\\\" : n,               (numeric) the vout value\\n\"\n+                 \"    \\\"address\\\" : \\\"address\\\",  (string) the bitcoin address\\n\"\n+                 \"    \\\"account\\\" : \\\"account\\\",  (string) DEPRECATED. The associated account, or \\\"\\\" for the default account\\n\"\n+                 \"    \\\"scriptPubKey\\\" : \\\"key\\\", (string) the script key\\n\"\n+                 \"    \\\"amount\\\" : x.xxx,         (numeric) the transaction amount in btc\\n\"\n+                 \"    \\\"confirmations\\\" : n       (numeric) The number of confirmations\\n\"\n+                 \"  }\\n\"\n+                 \"  ,...\\n\"\n+                 \"]\\n\"\n+                 \"\\n%examples%\"\n+                 );\n+\n+    Wallet *wallet = WalletFromParams(params);\n \n     int nMinDepth = 1;\n     UniValue minconf = ValueFromParams(params, \"minconf\", UniValue::VNUM);\n@@ -749,26 +798,18 @@ UniValue listunspent(const UniValue& params, bool fHelp)\n \n UniValue getbalance(const UniValue& params, bool fHelp)\n {\n-    if (fHelp)\n-        throw std::runtime_error(\n-                            \"getbalance type=(all|available|unconfirmed|immature) includewatchonly=true\\n\"\n-                            \"\\nIf account is not specified, returns the server's total available balance.\\n\"\n-                            \"If account is specified (DEPRECATED), returns the balance in the account.\\n\"\n-                            \"Note that the account \\\"\\\" is not the same as leaving the parameter out.\\n\"\n-                            \"The server total may be different to the balance in the default \\\"\\\" account.\\n\"\n-                            \"\\nArguments:\\n\"\n-                            \"1. \\\"type\\\"      (string, optional) define the desired balance type \\\"\\\".\\n\"\n-                            \"1. includewatchonly (bool, optional, default=false) Also include balance in watchonly addresses (see 'importaddress')\\n\"\n-                            \"\\nResult:\\n\"\n-                            \"amount              (numeric) The total amount in btc received for this account (or a object in case of type=all).\\n\"\n-                            \"\\nExamples:\\n\"\n-                            \"\\nThe total amount in the wallet\\n\"\n-                            + HelpExampleCli(\"getbalance\", \"\") +\n-                            \"\\nThe total amount in the wallet at least 5 blocks confirmed\\n\"\n-                            + HelpExampleCli(\"getbalance\", \"type=all includewatchonly=true\") +\n-                            \"\\nAs a json rpc call\\n\"\n-                            + HelpExampleRpc(\"getbalance\", \"type=all\")\n-                            );\n+    static RPCParamEntry allowedParams[] = {\n+        { false, \"type\", VSTR, \"define the desired balance type (confirmed, unconfirmed, immature, all)\", \"confirmed\", \"all\"},\n+        { false, \"includewatchonly\", VBOOL, \"Also include balance in watchonly addresses (see 'importaddress')\", \"false\", \"true\"},\n+    };\n+\n+    VerifyParams(\"listunspent\", params, fHelp, allowedParams, 2,\n+                 \"\\nReturns the total available balance.\\n\"\n+                 \"%args%\"\n+                 \"\\nResult:\\n\"\n+                 \"amount              (numeric) The total amount in btc received for this account (or a object in case of type=all).\\n\"\n+                 \"\\n%examples%\"\n+                 );\n \n     Wallet *wallet = WalletFromParams(params);\n     LOCK(wallet->cs_coreWallet);\n@@ -797,13 +838,27 @@ UniValue getbalance(const UniValue& params, bool fHelp)\n \n UniValue createtx(const UniValue& params, bool fHelp)\n {\n-    if (fHelp || params.size() > 1)\n-        throw std::runtime_error(\n-                                 \"createtx sendto=([{address0:amount}, {address1:amount}]) send=(1|0)\\n\"\n-                                 \"\\nExamples:\\n\"\n-                                 + HelpExampleCli(\"createtx\", \"{\\\"1PGFqEzfmQch1gKD3ra4k18PNj3tTUUSqg\\\":10.0}\")\n-                                 + HelpExampleRpc(\"createtx\", \"\")\n-                                 );\n+    static RPCParamEntry allowedParams[] = {\n+        { false, \"sendto\", VSTR, \"object containing n bitcoin/value pairs\", \"\", \"{\\\"1PGFqEzfmQch1gKD3ra4k18PNj3tTUUSqg\\\":10.0}\"},\n+        { false, \"send\", VBOOL, \"is set, the transaction will be broadcasted\", \"false\", \"true\"},\n+    };\n+\n+    VerifyParams(\"createtx\", params, fHelp, allowedParams, 2,\n+                 \"\\nCreates a new transaction with the options to directly broadcast the transaction (send=true).\\n\"\n+                 \"%args%\"\n+\n+                 \"\\nResult\\n\"\n+                 \"[                   (array of json object)\\n\"\n+                 \"  {\\n\"\n+                 \"    \\\"hex\\\" : \\\"hex\\\",          (string) hex string of the raw transaction\\n\"\n+                 \"    \\\"fee\\\" : n,                (numeric) the fee used in the transaction\\n\"\n+                 \"    \\\"sent\\\" : true|false,      (boolean) will be set to true if transaction has been successfully broadcastet\\n\"\n+                 \"    \\\"txid\\\" : \\\"txid\\\",        (optional, string) the transaction id if the transaction has been broadcasted\\n\"\n+                 \"  }\\n\"\n+                 \"  ,...\\n\"\n+                 \"]\\n\"\n+                 \"\\n%examples%\"\n+                 );\n     \n     Wallet *wallet = WalletFromParams(params);\n     std::vector<std::pair<CBitcoinAddress, CAmount> > sendToList;"
      },
      {
        "sha": "a552cbe3e1cd53c679bc341674d3c47e68946b4a",
        "filename": "src/corewallet/corewallet_wallet.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/50a8c57652777d26a15a79e7e000ac4b573f6006/src/corewallet/corewallet_wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/50a8c57652777d26a15a79e7e000ac4b573f6006/src/corewallet/corewallet_wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet_wallet.cpp?ref=50a8c57652777d26a15a79e7e000ac4b573f6006",
        "patch": "@@ -231,6 +231,8 @@ bool Wallet::HDGetChildPubKeyAtIndex(const HDChainID& chainIDIn, CPubKey &pubKey\n     if (!nTimeFirstKey || nCreationTime < nTimeFirstKey)\n         nTimeFirstKey = nCreationTime;\n \n+    mapKeyMetadata[newHdPubKey.pubkey.GetID()].keyFlags |= IsCrypted() ? CKeyMetadata::KEY_ORIGIN_ENC_WALLET : CKeyMetadata::KEY_ORIGIN_UNENC_WALLET;\n+\n     if (!LoadHDPubKey(newHdPubKey))\n         throw std::runtime_error(\"CoreWallet::HDGetChildPubKeyAtIndex(): Add key to keystore failed!\");\n "
      },
      {
        "sha": "18a7f3b99b9135d84dc4b11525573f03f6bae3a7",
        "filename": "src/corewallet/corewallet_wallet.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/50a8c57652777d26a15a79e7e000ac4b573f6006/src/corewallet/corewallet_wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/50a8c57652777d26a15a79e7e000ac4b573f6006/src/corewallet/corewallet_wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/corewallet/corewallet_wallet.h?ref=50a8c57652777d26a15a79e7e000ac4b573f6006",
        "patch": "@@ -63,7 +63,7 @@ class Wallet : public CHDKeyStore, public CValidationInterface{\n \n     mutable CCriticalSection cs_coreWallet; //main wallet lock\n     std::map<CKeyID, CKeyMetadata> mapKeyMetadata; //!map of all generated/derived keys\n-    std::map<CTxDestination, CAddressBookMetadata> mapAddressBook; //!addressbook with a variant (CScript/CKeyID)\n+    std::map<CTxDestination, CAddressBookMetadata> mapAddressBook; //!addressbook with a variant key (CScript/CKeyID)\n     std::set<COutPoint> setLockedCoins; //! set for locking coins (in mem only)\n \n     int64_t nTimeFirstKey; //!oldest key timestamp"
      }
    ]
  }
]