[
  {
    "sha": "d05d55f2d47b4fb55443e6aa351b398cfdcd3cf8",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkMDVkNTVmMmQ0N2I0ZmI1NTQ0M2U2YWEzNTFiMzk4Y2ZkY2QzY2Y4",
    "commit": {
      "author": {
        "name": "Niklas G\u00f6gge",
        "email": "n.goeggi@gmail.com",
        "date": "2021-04-16T14:52:19Z"
      },
      "committer": {
        "name": "Niklas G\u00f6gge",
        "email": "n.goeggi@gmail.com",
        "date": "2021-06-12T09:16:15Z"
      },
      "message": "log: Mitigate disk filling attacks by temporarily and globally rate limiting LogPrintf(\u2026)",
      "tree": {
        "sha": "5655487fb785faa75bfe525d61c2283d5ff48a65",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5655487fb785faa75bfe525d61c2283d5ff48a65"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d05d55f2d47b4fb55443e6aa351b398cfdcd3cf8",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d05d55f2d47b4fb55443e6aa351b398cfdcd3cf8",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d05d55f2d47b4fb55443e6aa351b398cfdcd3cf8",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d05d55f2d47b4fb55443e6aa351b398cfdcd3cf8/comments",
    "author": {
      "login": "dergoegge",
      "id": 8077169,
      "node_id": "MDQ6VXNlcjgwNzcxNjk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dergoegge",
      "html_url": "https://github.com/dergoegge",
      "followers_url": "https://api.github.com/users/dergoegge/followers",
      "following_url": "https://api.github.com/users/dergoegge/following{/other_user}",
      "gists_url": "https://api.github.com/users/dergoegge/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dergoegge/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
      "organizations_url": "https://api.github.com/users/dergoegge/orgs",
      "repos_url": "https://api.github.com/users/dergoegge/repos",
      "events_url": "https://api.github.com/users/dergoegge/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dergoegge/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "dergoegge",
      "id": 8077169,
      "node_id": "MDQ6VXNlcjgwNzcxNjk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dergoegge",
      "html_url": "https://github.com/dergoegge",
      "followers_url": "https://api.github.com/users/dergoegge/followers",
      "following_url": "https://api.github.com/users/dergoegge/following{/other_user}",
      "gists_url": "https://api.github.com/users/dergoegge/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dergoegge/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
      "organizations_url": "https://api.github.com/users/dergoegge/orgs",
      "repos_url": "https://api.github.com/users/dergoegge/repos",
      "events_url": "https://api.github.com/users/dergoegge/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dergoegge/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "96f828ba4d69f8acadf335ee79fa8f06cd33c0a6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/96f828ba4d69f8acadf335ee79fa8f06cd33c0a6",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/96f828ba4d69f8acadf335ee79fa8f06cd33c0a6"
      }
    ],
    "stats": {
      "total": 176,
      "additions": 161,
      "deletions": 15
    },
    "files": [
      {
        "sha": "8d1587ca4f1adb3386fe15e74be20f8a1edbc87b",
        "filename": "src/init/common.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d05d55f2d47b4fb55443e6aa351b398cfdcd3cf8/src/init/common.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d05d55f2d47b4fb55443e6aa351b398cfdcd3cf8/src/init/common.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init/common.cpp?ref=d05d55f2d47b4fb55443e6aa351b398cfdcd3cf8",
        "patch": "@@ -76,6 +76,7 @@ void AddLoggingArgs(ArgsManager& argsman)\n     argsman.AddArg(\"-logtimemicros\", strprintf(\"Add microsecond precision to debug timestamps (default: %u)\", DEFAULT_LOGTIMEMICROS), ArgsManager::ALLOW_ANY | ArgsManager::DEBUG_ONLY, OptionsCategory::DEBUG_TEST);\n     argsman.AddArg(\"-printtoconsole\", \"Send trace/debug info to console (default: 1 when no -daemon. To disable logging to file, set -nodebuglogfile)\", ArgsManager::ALLOW_ANY, OptionsCategory::DEBUG_TEST);\n     argsman.AddArg(\"-shrinkdebugfile\", \"Shrink debug.log file on client startup (default: 1 when no -debug)\", ArgsManager::ALLOW_ANY, OptionsCategory::DEBUG_TEST);\n+    argsman.AddArg(\"-logratelimiting\", strprintf(\"Rate limit debug logging to disk (default: %u)\", DEFAULT_LOGRATELIMITING), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n }\n \n void SetLoggingOptions(const ArgsManager& args)\n@@ -89,6 +90,7 @@ void SetLoggingOptions(const ArgsManager& args)\n     LogInstance().m_log_threadnames = args.GetBoolArg(\"-logthreadnames\", DEFAULT_LOGTHREADNAMES);\n #endif\n     LogInstance().m_log_sourcelocations = args.GetBoolArg(\"-logsourcelocations\", DEFAULT_LOGSOURCELOCATIONS);\n+    LogInstance().m_rate_limiting = args.GetBoolArg(\"-logratelimiting\", DEFAULT_LOGRATELIMITING);\n \n     fLogIPs = args.GetBoolArg(\"-logips\", DEFAULT_LOGIPS);\n }"
      },
      {
        "sha": "1634e988a3d2da68cb7a5cfd2529e1baf7dd3f7f",
        "filename": "src/logging.cpp",
        "status": "modified",
        "additions": 95,
        "deletions": 4,
        "changes": 99,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d05d55f2d47b4fb55443e6aa351b398cfdcd3cf8/src/logging.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d05d55f2d47b4fb55443e6aa351b398cfdcd3cf8/src/logging.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/logging.cpp?ref=d05d55f2d47b4fb55443e6aa351b398cfdcd3cf8",
        "patch": "@@ -239,13 +239,39 @@ namespace BCLog {\n     }\n }\n \n-void BCLog::Logger::LogPrintStr(const std::string& str, const std::string& logging_function, const std::string& source_file, const int source_line)\n+static constexpr uint64_t HOURLY_LOG_QUOTA_IN_BYTES_PER_SOURCE_LOCATION{1024 * 1024};\n+\n+void ComputeQuotaUsageStats(const std::unordered_map<SourceLocation, QuotaUsage, SourceLocationHasher>& quota_usage_per_source_location,\n+                            QuotaUsage& total_usage, std::string& all_locations, std::string& excessive_locations)\n+{\n+    for (const auto& quota_map_entry : quota_usage_per_source_location) {\n+        const SourceLocation& location = quota_map_entry.first;\n+        const QuotaUsage& location_usage = quota_map_entry.second;\n+\n+        total_usage.m_bytes_dropped += location_usage.m_bytes_dropped;\n+        total_usage.m_messages_dropped += location_usage.m_messages_dropped;\n+        total_usage.m_bytes_logged += location_usage.m_bytes_logged;\n+\n+        if (location_usage.m_messages_dropped > 0) {\n+            // Append all locations that dropped at least one message.\n+            all_locations = strprintf(\"%s%s:%d, \", all_locations, location.first, location.second);\n+\n+            if (location_usage.m_bytes_logged > HOURLY_LOG_QUOTA_IN_BYTES_PER_SOURCE_LOCATION ||\n+                location_usage.m_bytes_dropped > HOURLY_LOG_QUOTA_IN_BYTES_PER_SOURCE_LOCATION) {\n+                // Append all locations that either logged or dropped excessively.\n+                excessive_locations = strprintf(\"%s%s:%d, \", excessive_locations, location.first, location.second);\n+            }\n+        }\n+    }\n+}\n+\n+void BCLog::Logger::LogPrintStr(const std::string& str, const std::string& logging_function, const SourceLocation& source_location, const bool skip_disk_usage_rate_limiting)\n {\n     StdLockGuard scoped_lock(m_cs);\n     std::string str_prefixed = LogEscapeMessage(str);\n \n     if (m_log_sourcelocations && m_started_new_line) {\n-        str_prefixed.insert(0, \"[\" + RemovePrefix(source_file, \"./\") + \":\" + ToString(source_line) + \"] [\" + logging_function + \"] \");\n+        str_prefixed.insert(0, \"[\" + RemovePrefix(source_location.first, \"./\") + \":\" + ToString(source_location.second) + \"] [\" + logging_function + \"] \");\n     }\n \n     if (m_log_threadnames && m_started_new_line) {\n@@ -254,7 +280,66 @@ void BCLog::Logger::LogPrintStr(const std::string& str, const std::string& loggi\n \n     str_prefixed = LogTimestampStr(str_prefixed);\n \n-    m_started_new_line = !str.empty() && str[str.size()-1] == '\\n';\n+    // Rate limit logging to disk to avoid disk filling attacks.\n+    bool log_rate_limit_message = false;\n+    if (!skip_disk_usage_rate_limiting && m_rate_limiting) {\n+        // Every hour the quota usage for a all source locations is reset.\n+        const std::chrono::seconds now = GetTime<std::chrono::seconds>();\n+        if ((now - m_last_quota_usage_reset) > std::chrono::hours{1}) {\n+            if (m_num_excessive_locations > 0) {\n+                // There are source locations that exceeded the rate limits in the last hour.\n+\n+                // The total usage (bytes/messages dropped/logged) for the last hour.\n+                QuotaUsage total_usage;\n+                // Comma speparated list of source locations.\n+                // - all_locations: All locations that were dropped.\n+                // - excessive_locations: the subset of locations that tried to log excessively.\n+                std::string all_locations, excessive_locations;\n+                ComputeQuotaUsageStats(m_quota_usage_per_source_location, total_usage, all_locations, excessive_locations);\n+                // Log the new message as well as the \"restart\" message.\n+                str_prefixed = LogTimestampStr(\n+                    strprintf(\n+                        \"Restarting logging! A total of %d messages (%.1f MiB) were dropped from these locations: %s. \"\n+                        \"Rate limiting was triggered because %d locations tried to log excessively: %s.\\n%s\",\n+                        total_usage.m_messages_dropped, total_usage.m_bytes_dropped / (1024.0 * 1024),\n+                        all_locations, m_num_excessive_locations, excessive_locations, str_prefixed)),\n+\n+                m_num_excessive_locations = 0;\n+                log_rate_limit_message = true;\n+            }\n+\n+            // Clear the quota usage stats for all locations.\n+            m_quota_usage_per_source_location.clear();\n+            m_last_quota_usage_reset = now;\n+        }\n+\n+        QuotaUsage& quota_usage = m_quota_usage_per_source_location[source_location];\n+\n+        bool quota_exceeded_before = quota_usage.m_bytes_logged > HOURLY_LOG_QUOTA_IN_BYTES_PER_SOURCE_LOCATION;\n+        if (!log_rate_limit_message && !quota_exceeded_before) quota_usage.m_bytes_logged += str_prefixed.size();\n+        bool quota_exceeded_after = quota_usage.m_bytes_logged > HOURLY_LOG_QUOTA_IN_BYTES_PER_SOURCE_LOCATION;\n+\n+        if (!quota_exceeded_before && quota_exceeded_after) {\n+            if (m_num_excessive_locations == 0) {\n+                // This is the first excessively logging location.\n+                // We start dropping all logging to disk for up to one hour.\n+                str_prefixed = LogTimestampStr(\n+                    strprintf(\"Excessive logging detected from %s:%d: >%d MiB logged during the last hour. \"\n+                              \"Suppressing all logging to disk for up to one hour. \"\n+                              \"Console logging unaffected. Last log entry: %s\",\n+                              source_location.first, source_location.second,\n+                              HOURLY_LOG_QUOTA_IN_BYTES_PER_SOURCE_LOCATION / (1024 * 1024), str_prefixed));\n+                log_rate_limit_message = true;\n+            }\n+\n+            ++m_num_excessive_locations;\n+        } else if (quota_exceeded_after) {\n+            quota_usage.m_messages_dropped++;\n+            quota_usage.m_bytes_dropped += str_prefixed.size();\n+        }\n+    }\n+\n+    m_started_new_line = !str.empty() && str[str.size() - 1] == '\\n';\n \n     if (m_buffering) {\n         // buffer if we haven't started logging yet\n@@ -270,7 +355,13 @@ void BCLog::Logger::LogPrintStr(const std::string& str, const std::string& loggi\n     for (const auto& cb : m_print_callbacks) {\n         cb(str_prefixed);\n     }\n-    if (m_print_to_file) {\n+    if (m_print_to_file &&\n+        // We skip logging to disk if there is at least one source location that is trying to log excessively.\n+        (m_num_excessive_locations == 0 ||\n+         // We make an exception for messages that originate from the rate limiting logic.\n+         log_rate_limit_message ||\n+         // Ensure that the rate limiting skip flag is always respected.\n+         skip_disk_usage_rate_limiting)) {\n         assert(m_fileout != nullptr);\n \n         // reopen the log file, if requested"
      },
      {
        "sha": "2a41e7642018dc9985ba96fe9c5af55182eb1d27",
        "filename": "src/logging.h",
        "status": "modified",
        "additions": 63,
        "deletions": 10,
        "changes": 73,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d05d55f2d47b4fb55443e6aa351b398cfdcd3cf8/src/logging.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d05d55f2d47b4fb55443e6aa351b398cfdcd3cf8/src/logging.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/logging.h?ref=d05d55f2d47b4fb55443e6aa351b398cfdcd3cf8",
        "patch": "@@ -6,23 +6,29 @@\n #ifndef BITCOIN_LOGGING_H\n #define BITCOIN_LOGGING_H\n \n+#include <crypto/siphash.h>\n #include <fs.h>\n #include <tinyformat.h>\n #include <threadsafety.h>\n #include <util/string.h>\n \n #include <atomic>\n+#include <chrono>\n #include <cstdint>\n+#include <functional>\n #include <list>\n #include <mutex>\n #include <string>\n+#include <unordered_map>\n+#include <utility>\n #include <vector>\n \n static const bool DEFAULT_LOGTIMEMICROS = false;\n static const bool DEFAULT_LOGIPS        = false;\n static const bool DEFAULT_LOGTIMESTAMPS = true;\n static const bool DEFAULT_LOGTHREADNAMES = false;\n static const bool DEFAULT_LOGSOURCELOCATIONS = false;\n+static const bool DEFAULT_LOGRATELIMITING = true;\n extern const char * const DEFAULT_DEBUGLOGFILE;\n \n extern bool fLogIPs;\n@@ -32,6 +38,22 @@ struct LogCategory {\n     bool active;\n };\n \n+// Replace with std::source_location when switching to C++20.\n+using SourceLocation = std::pair<const char*, int>;\n+struct SourceLocationHasher {\n+    size_t operator()(const SourceLocation& source_location) const noexcept\n+    {\n+        // Use CSipHasher(0, 0) as a simple way to get uniform distribution.\n+        return static_cast<size_t>(CSipHasher(0, 0).Write(std::hash<const char*>{}(source_location.first)).Write(std::hash<int>{}(source_location.second)).Finalize());\n+    }\n+};\n+\n+struct QuotaUsage {\n+    uint64_t m_bytes_logged{0};\n+    uint64_t m_bytes_dropped{0};\n+    uint64_t m_messages_dropped{0};\n+};\n+\n namespace BCLog {\n     enum LogFlags : uint32_t {\n         NONE        = 0,\n@@ -71,6 +93,14 @@ namespace BCLog {\n         std::list<std::string> m_msgs_before_open GUARDED_BY(m_cs);\n         bool m_buffering GUARDED_BY(m_cs) = true; //!< Buffer messages before logging can be started.\n \n+        // Number of source locations that have exceeded the log rate limits for a single location.\n+        // If there is 1 or more of these locations, we skip logging to disk until the next quota usage reset.\n+        uint32_t m_num_excessive_locations GUARDED_BY(m_cs){0};\n+        // Time of last quota usage reset.\n+        std::chrono::seconds m_last_quota_usage_reset GUARDED_BY(m_cs){0};\n+        // Track quota usage for rate limiting per source location.\n+        std::unordered_map<SourceLocation, QuotaUsage, SourceLocationHasher> m_quota_usage_per_source_location GUARDED_BY(m_cs);\n+\n         /**\n          * m_started_new_line is a state variable that will suppress printing of\n          * the timestamp when multiple calls are made that don't end in a\n@@ -94,12 +124,13 @@ namespace BCLog {\n         bool m_log_time_micros = DEFAULT_LOGTIMEMICROS;\n         bool m_log_threadnames = DEFAULT_LOGTHREADNAMES;\n         bool m_log_sourcelocations = DEFAULT_LOGSOURCELOCATIONS;\n+        bool m_rate_limiting = DEFAULT_LOGRATELIMITING;\n \n         fs::path m_file_path;\n         std::atomic<bool> m_reopen_file{false};\n \n         /** Send a string to the log output */\n-        void LogPrintStr(const std::string& str, const std::string& logging_function, const std::string& source_file, const int source_line);\n+        void LogPrintStr(const std::string& str, const std::string& logging_function, const SourceLocation& source_location, const bool skip_disk_usage_rate_limiting);\n \n         /** Returns whether logs will be written to any output */\n         bool Enabled() const\n@@ -147,6 +178,13 @@ namespace BCLog {\n         };\n \n         bool DefaultShrinkDebugFile() const;\n+\n+        // Only for testing to help with mocked time.\n+        void ResetRateLimitingTime()\n+        {\n+            StdLockGuard scoped_lock(m_cs);\n+            m_last_quota_usage_reset = std::chrono::seconds{0};\n+        }\n     };\n \n } // namespace BCLog\n@@ -165,9 +203,11 @@ bool GetLogCategory(BCLog::LogFlags& flag, const std::string& str);\n // Be conservative when using LogPrintf/error or other things which\n // unconditionally log to debug.log! It should not be the case that an inbound\n // peer can fill up a user's disk with debug.log entries.\n-\n+//\n+// An attempt to mitigate disk filling attacks is made unless skip_disk_usage_rate_limiting\n+// is set to true.\n template <typename... Args>\n-static inline void LogPrintf_(const std::string& logging_function, const std::string& source_file, const int source_line, const char* fmt, const Args&... args)\n+static inline void LogPrintf_(const std::string& logging_function, const char* source_file, const int source_line, const bool skip_disk_usage_rate_limiting, const char* fmt, const Args&... args)\n {\n     if (LogInstance().Enabled()) {\n         std::string log_msg;\n@@ -177,19 +217,32 @@ static inline void LogPrintf_(const std::string& logging_function, const std::st\n             /* Original format string will have newline so don't add one here */\n             log_msg = \"Error \\\"\" + std::string(fmterr.what()) + \"\\\" while formatting log message: \" + fmt;\n         }\n-        LogInstance().LogPrintStr(log_msg, logging_function, source_file, source_line);\n+\n+        const SourceLocation source_location = std::make_pair(source_file, source_line);\n+        LogInstance().LogPrintStr(log_msg, logging_function, source_location, skip_disk_usage_rate_limiting);\n     }\n }\n \n-#define LogPrintf(...) LogPrintf_(__func__, __FILE__, __LINE__, __VA_ARGS__)\n+// Unconditional logging. Uses basic rate limiting to mitigate disk filling attacks.\n+#define LogPrintf(...) LogPrintf_(__func__, __FILE__, __LINE__, /* skip_disk_usage_rate_limiting */ false, __VA_ARGS__)\n+\n+// Unconditional logging WITHOUT rate limiting. Use only for log messages that\n+// MUST NOT be rate limited no matter how often they are logged. That requirement\n+// should be extremely rare, so please use with care. Prefer LogPrintf(...) if\n+// possible.\n+#define LogPrintfWithoutRateLimiting(...) LogPrintf_(__func__, __FILE__, __LINE__, /* skip_disk_usage_rate_limiting */ true, __VA_ARGS__)\n \n // Use a macro instead of a function for conditional logging to prevent\n // evaluating arguments when logging for the category is not enabled.\n-#define LogPrint(category, ...)              \\\n-    do {                                     \\\n-        if (LogAcceptCategory((category))) { \\\n-            LogPrintf(__VA_ARGS__);          \\\n-        }                                    \\\n+//\n+// Note that conditional logging is performed WITHOUT rate limiting. Users\n+// specifying -debug are assumed to be developers or power users who are aware\n+// that -debug may cause excessive disk usage due to logging.\n+#define LogPrint(category, ...)                                                                              \\\n+    do {                                                                                                     \\\n+        if (LogAcceptCategory((category))) {                                                                 \\\n+            LogPrintf_(__func__, __FILE__, __LINE__, /* skip_disk_usage_rate_limiting */ true, __VA_ARGS__); \\\n+        }                                                                                                    \\\n     } while (0)\n \n #endif // BITCOIN_LOGGING_H"
      },
      {
        "sha": "552d4596db96a44621257861649da2004a6624db",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d05d55f2d47b4fb55443e6aa351b398cfdcd3cf8/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d05d55f2d47b4fb55443e6aa351b398cfdcd3cf8/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=d05d55f2d47b4fb55443e6aa351b398cfdcd3cf8",
        "patch": "@@ -2260,7 +2260,7 @@ static void UpdateTip(CTxMemPool& mempool, const CBlockIndex* pindexNew, const C\n             }\n         }\n     }\n-    LogPrintf(\"%s: new best=%s height=%d version=0x%08x log2_work=%f tx=%lu date='%s' progress=%f cache=%.1fMiB(%utxo)%s\\n\", __func__,\n+    LogPrintfWithoutRateLimiting(\"%s: new best=%s height=%d version=0x%08x log2_work=%f tx=%lu date='%s' progress=%f cache=%.1fMiB(%utxo)%s\\n\", __func__,\n       pindexNew->GetBlockHash().ToString(), pindexNew->nHeight, pindexNew->nVersion,\n       log(pindexNew->nChainWork.getdouble())/log(2.0), (unsigned long)pindexNew->nChainTx,\n       FormatISO8601DateTime(pindexNew->GetBlockTime()),"
      }
    ]
  },
  {
    "sha": "aa6a1398240b97525efc0a7d2b5fce39b2617a34",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphYTZhMTM5ODI0MGI5NzUyNWVmYzBhN2QyYjVmY2UzOWIyNjE3YTM0",
    "commit": {
      "author": {
        "name": "Niklas G\u00f6gge",
        "email": "n.goeggi@gmail.com",
        "date": "2021-04-16T15:01:47Z"
      },
      "committer": {
        "name": "Niklas G\u00f6gge",
        "email": "n.goeggi@gmail.com",
        "date": "2021-06-12T09:16:17Z"
      },
      "message": "test: Add logging test for rate limiting",
      "tree": {
        "sha": "3cb101ad9886da3098b95c78f129d379920e2d9f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3cb101ad9886da3098b95c78f129d379920e2d9f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/aa6a1398240b97525efc0a7d2b5fce39b2617a34",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/aa6a1398240b97525efc0a7d2b5fce39b2617a34",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/aa6a1398240b97525efc0a7d2b5fce39b2617a34",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/aa6a1398240b97525efc0a7d2b5fce39b2617a34/comments",
    "author": {
      "login": "dergoegge",
      "id": 8077169,
      "node_id": "MDQ6VXNlcjgwNzcxNjk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dergoegge",
      "html_url": "https://github.com/dergoegge",
      "followers_url": "https://api.github.com/users/dergoegge/followers",
      "following_url": "https://api.github.com/users/dergoegge/following{/other_user}",
      "gists_url": "https://api.github.com/users/dergoegge/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dergoegge/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
      "organizations_url": "https://api.github.com/users/dergoegge/orgs",
      "repos_url": "https://api.github.com/users/dergoegge/repos",
      "events_url": "https://api.github.com/users/dergoegge/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dergoegge/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "dergoegge",
      "id": 8077169,
      "node_id": "MDQ6VXNlcjgwNzcxNjk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dergoegge",
      "html_url": "https://github.com/dergoegge",
      "followers_url": "https://api.github.com/users/dergoegge/followers",
      "following_url": "https://api.github.com/users/dergoegge/following{/other_user}",
      "gists_url": "https://api.github.com/users/dergoegge/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dergoegge/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
      "organizations_url": "https://api.github.com/users/dergoegge/orgs",
      "repos_url": "https://api.github.com/users/dergoegge/repos",
      "events_url": "https://api.github.com/users/dergoegge/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dergoegge/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d05d55f2d47b4fb55443e6aa351b398cfdcd3cf8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d05d55f2d47b4fb55443e6aa351b398cfdcd3cf8",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d05d55f2d47b4fb55443e6aa351b398cfdcd3cf8"
      }
    ],
    "stats": {
      "total": 97,
      "additions": 97,
      "deletions": 0
    },
    "files": [
      {
        "sha": "1ce9eb96f7111eb5512ebe24d4b0f3835f2ba553",
        "filename": "src/test/logging_tests.cpp",
        "status": "modified",
        "additions": 97,
        "deletions": 0,
        "changes": 97,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/aa6a1398240b97525efc0a7d2b5fce39b2617a34/src/test/logging_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/aa6a1398240b97525efc0a7d2b5fce39b2617a34/src/test/logging_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/logging_tests.cpp?ref=aa6a1398240b97525efc0a7d2b5fce39b2617a34",
        "patch": "@@ -30,4 +30,101 @@ BOOST_AUTO_TEST_CASE(logging_timer)\n     BOOST_CHECK_EQUAL(micro_timer.LogMsg(\"test micros\"), \"tests: test micros (1000000.00\u03bcs)\");\n }\n \n+void GetLogFileSize(size_t& size)\n+{\n+    boost::system::error_code ec;\n+    size = fs::file_size(LogInstance().m_file_path, ec);\n+    if (ec) LogPrintf(\"%s: %s %s\\n\", __func__, ec.message(), LogInstance().m_file_path);\n+    BOOST_CHECK(!ec);\n+}\n+\n+void LogFromFixedLocation(const std::string& str)\n+{\n+    LogPrintf(\"%s\\n\", str);\n+}\n+\n+BOOST_AUTO_TEST_CASE(rate_limiting)\n+{\n+#if defined(_WIN32)\n+    // TODO\n+    // Since windows prints \\r\\n to file instead of \\n, the log file size\n+    // does not match up with the internal \"bytes logged\" count.\n+    // This test relies on matching file sizes with expected values.\n+    return;\n+#endif\n+\n+    // This allows us to check for exact size differences in the log file.\n+    bool prev_log_timestamps = LogInstance().m_log_sourcelocations;\n+    LogInstance().m_log_timestamps = false;\n+    bool prev_log_sourcelocations = LogInstance().m_log_sourcelocations;\n+    LogInstance().m_log_sourcelocations = false;\n+    bool prev_log_threadnames = LogInstance().m_log_threadnames;\n+    LogInstance().m_log_threadnames = false;\n+\n+    std::string log_message(1023, 'a');\n+\n+    SetMockTime(std::chrono::seconds{1});\n+\n+    LogInstance().ResetRateLimitingTime();\n+\n+    size_t prev_log_file_size, curr_log_file_size;\n+    GetLogFileSize(prev_log_file_size);\n+\n+    // Log 1 MiB, this should be allowed.\n+    for (int i = 0; i < 1024; ++i) {\n+        LogFromFixedLocation(log_message);\n+    }\n+    GetLogFileSize(curr_log_file_size);\n+    BOOST_CHECK(curr_log_file_size - prev_log_file_size == 1024 * 1024);\n+\n+    LogFromFixedLocation(\"This should trigger rate limiting\");\n+    GetLogFileSize(prev_log_file_size);\n+\n+    // Log 0.5 MiB, this should not be allowed and all messages should be dropped.\n+    for (int i = 0; i < 512; ++i) {\n+        LogFromFixedLocation(log_message);\n+    }\n+    GetLogFileSize(curr_log_file_size);\n+    BOOST_CHECK(curr_log_file_size - prev_log_file_size == 0);\n+\n+    // Let one hour pass.\n+    SetMockTime(std::chrono::seconds{60 * 60 + 2});\n+    LogFromFixedLocation(\"This should trigger the quota usage reset\");\n+    GetLogFileSize(prev_log_file_size);\n+\n+    // Log 1 MiB, this should be allowed since the usage was reset.\n+    for (int i = 0; i < 1024; ++i) {\n+        LogFromFixedLocation(log_message);\n+    }\n+    GetLogFileSize(curr_log_file_size);\n+    BOOST_CHECK(curr_log_file_size - prev_log_file_size == 1024 * 1024);\n+\n+    LogFromFixedLocation(\"This should trigger rate limiting\");\n+    GetLogFileSize(prev_log_file_size);\n+\n+    // Log 1 MiB, this should not be allowed and all messages should be dropped.\n+    for (int i = 0; i < 1024; ++i) {\n+        LogFromFixedLocation(log_message);\n+    }\n+    GetLogFileSize(curr_log_file_size);\n+    BOOST_CHECK(curr_log_file_size - prev_log_file_size == 0);\n+\n+    // Let another hour pass\n+    SetMockTime(std::chrono::seconds{2 * 60 * 60 + 3});\n+    LogFromFixedLocation(\"This should trigger the quota usage reset\");\n+    GetLogFileSize(prev_log_file_size);\n+\n+    // Log 1 MiB, this should be allowed since the usage was reset.\n+    for (int i = 0; i < 1024; ++i) {\n+        LogFromFixedLocation(log_message);\n+    }\n+    GetLogFileSize(curr_log_file_size);\n+    BOOST_CHECK(curr_log_file_size - prev_log_file_size == 1024 * 1024);\n+\n+    LogInstance().m_log_timestamps = prev_log_timestamps;\n+    LogInstance().m_log_sourcelocations = prev_log_sourcelocations;\n+    LogInstance().m_log_threadnames = prev_log_threadnames;\n+    SetMockTime(std::chrono::seconds{0});\n+}\n+\n BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  }
]