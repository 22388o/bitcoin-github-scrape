[
  {
    "sha": "cb41ade6b1d9e9b0abea42f7a6946c13ebfb2083",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjYjQxYWRlNmIxZDllOWIwYWJlYTQyZjdhNjk0NmMxM2ViZmIyMDgz",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-11-30T22:47:46Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-12-06T17:18:52Z"
      },
      "message": "[tests] fix flake8 warnings in wallet_importmulti.py",
      "tree": {
        "sha": "8e6b884441e1cd9d8e6d977eddcbc2ae7176f07c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8e6b884441e1cd9d8e6d977eddcbc2ae7176f07c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/cb41ade6b1d9e9b0abea42f7a6946c13ebfb2083",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cb41ade6b1d9e9b0abea42f7a6946c13ebfb2083",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/cb41ade6b1d9e9b0abea42f7a6946c13ebfb2083",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cb41ade6b1d9e9b0abea42f7a6946c13ebfb2083/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "86ff0413bb8f8173d3b3a1987875ff40b1094926",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/86ff0413bb8f8173d3b3a1987875ff40b1094926",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/86ff0413bb8f8173d3b3a1987875ff40b1094926"
      }
    ],
    "stats": {
      "total": 78,
      "additions": 32,
      "deletions": 46
    },
    "files": [
      {
        "sha": "0e99a6b36481750bf5b68bc73fc122425b014619",
        "filename": "test/functional/wallet_importmulti.py",
        "status": "modified",
        "additions": 32,
        "deletions": 46,
        "changes": 78,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cb41ade6b1d9e9b0abea42f7a6946c13ebfb2083/test/functional/wallet_importmulti.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cb41ade6b1d9e9b0abea42f7a6946c13ebfb2083/test/functional/wallet_importmulti.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_importmulti.py?ref=cb41ade6b1d9e9b0abea42f7a6946c13ebfb2083",
        "patch": "@@ -32,26 +32,25 @@ def skip_test_if_missing_module(self):\n     def setup_network(self):\n         self.setup_nodes()\n \n-    def run_test (self):\n+    def run_test(self):\n         self.log.info(\"Mining blocks...\")\n         self.nodes[0].generate(1)\n         self.nodes[1].generate(1)\n         timestamp = self.nodes[1].getblock(self.nodes[1].getbestblockhash())['mediantime']\n \n         node0_address1 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n \n-        #Check only one address\n+        # Check only one address\n         assert_equal(node0_address1['ismine'], True)\n \n-        #Node 1 sync test\n-        assert_equal(self.nodes[1].getblockcount(),1)\n+        # Node 1 sync test\n+        assert_equal(self.nodes[1].getblockcount(), 1)\n \n-        #Address Test - before import\n+        # Address Test - before import\n         address_info = self.nodes[1].getaddressinfo(node0_address1['address'])\n         assert_equal(address_info['iswatchonly'], False)\n         assert_equal(address_info['ismine'], False)\n \n-\n         # RPC importmulti -----------------------------------------------\n \n         # Bitcoin Address (implicit non-internal)\n@@ -127,7 +126,6 @@ def run_test (self):\n         assert_equal(address_assert['ismine'], False)\n         assert_equal('timestamp' in address_assert, False)\n \n-\n         # Address + Public key + !Internal(explicit)\n         self.log.info(\"Should import an address with public key\")\n         address = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n@@ -136,7 +134,7 @@ def run_test (self):\n                 \"address\": address['address']\n             },\n             \"timestamp\": \"now\",\n-            \"pubkeys\": [ address['pubkey'] ],\n+            \"pubkeys\": [address['pubkey']],\n             \"internal\": False\n         }])\n         assert_equal(result[0]['success'], True)\n@@ -145,14 +143,13 @@ def run_test (self):\n         assert_equal(address_assert['ismine'], False)\n         assert_equal(address_assert['timestamp'], timestamp)\n \n-\n         # ScriptPubKey + Public key + internal\n         self.log.info(\"Should import a scriptPubKey with internal and with public key\")\n         address = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n         request = [{\n             \"scriptPubKey\": address['scriptPubKey'],\n             \"timestamp\": \"now\",\n-            \"pubkeys\": [ address['pubkey'] ],\n+            \"pubkeys\": [address['pubkey']],\n             \"internal\": True\n         }]\n         result = self.nodes[1].importmulti(requests=request)\n@@ -168,7 +165,7 @@ def run_test (self):\n         request = [{\n             \"scriptPubKey\": nonstandardScriptPubKey,\n             \"timestamp\": \"now\",\n-            \"pubkeys\": [ address['pubkey'] ]\n+            \"pubkeys\": [address['pubkey']]\n         }]\n         result = self.nodes[1].importmulti(requests=request)\n         assert_equal(result[0]['success'], False)\n@@ -187,7 +184,7 @@ def run_test (self):\n                 \"address\": address['address']\n             },\n             \"timestamp\": \"now\",\n-            \"keys\": [ self.nodes[0].dumpprivkey(address['address']) ]\n+            \"keys\": [self.nodes[0].dumpprivkey(address['address'])]\n         }])\n         assert_equal(result[0]['success'], True)\n         address_assert = self.nodes[1].getaddressinfo(address['address'])\n@@ -201,7 +198,7 @@ def run_test (self):\n                 \"address\": address['address']\n             },\n             \"timestamp\": \"now\",\n-            \"keys\": [ self.nodes[0].dumpprivkey(address['address']) ]\n+            \"keys\": [self.nodes[0].dumpprivkey(address['address'])]\n         }])\n         assert_equal(result[0]['success'], False)\n         assert_equal(result[0]['error']['code'], -4)\n@@ -215,7 +212,7 @@ def run_test (self):\n                 \"address\": address['address']\n             },\n             \"timestamp\": \"now\",\n-            \"keys\": [ self.nodes[0].dumpprivkey(address['address']) ],\n+            \"keys\": [self.nodes[0].dumpprivkey(address['address'])],\n             \"watchonly\": True\n         }])\n         assert_equal(result[0]['success'], False)\n@@ -232,7 +229,7 @@ def run_test (self):\n         result = self.nodes[1].importmulti([{\n             \"scriptPubKey\": address['scriptPubKey'],\n             \"timestamp\": \"now\",\n-            \"keys\": [ self.nodes[0].dumpprivkey(address['address']) ],\n+            \"keys\": [self.nodes[0].dumpprivkey(address['address'])],\n             \"internal\": True\n         }])\n         assert_equal(result[0]['success'], True)\n@@ -247,7 +244,7 @@ def run_test (self):\n         result = self.nodes[1].importmulti([{\n             \"scriptPubKey\": nonstandardScriptPubKey,\n             \"timestamp\": \"now\",\n-            \"keys\": [ self.nodes[0].dumpprivkey(address['address']) ]\n+            \"keys\": [self.nodes[0].dumpprivkey(address['address'])]\n         }])\n         assert_equal(result[0]['success'], False)\n         assert_equal(result[0]['error']['code'], -8)\n@@ -257,7 +254,6 @@ def run_test (self):\n         assert_equal(address_assert['ismine'], False)\n         assert_equal('timestamp' in address_assert, False)\n \n-\n         # P2SH address\n         sig_address_1 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n         sig_address_2 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n@@ -280,11 +276,10 @@ def run_test (self):\n         assert_equal(address_assert['isscript'], True)\n         assert_equal(address_assert['iswatchonly'], True)\n         assert_equal(address_assert['timestamp'], timestamp)\n-        p2shunspent = self.nodes[1].listunspent(0,999999, [multi_sig_script['address']])[0]\n+        p2shunspent = self.nodes[1].listunspent(0, 999999, [multi_sig_script['address']])[0]\n         assert_equal(p2shunspent['spendable'], False)\n         assert_equal(p2shunspent['solvable'], False)\n \n-\n         # P2SH + Redeem script\n         sig_address_1 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n         sig_address_2 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n@@ -307,11 +302,10 @@ def run_test (self):\n         address_assert = self.nodes[1].getaddressinfo(multi_sig_script['address'])\n         assert_equal(address_assert['timestamp'], timestamp)\n \n-        p2shunspent = self.nodes[1].listunspent(0,999999, [multi_sig_script['address']])[0]\n+        p2shunspent = self.nodes[1].listunspent(0, 999999, [multi_sig_script['address']])[0]\n         assert_equal(p2shunspent['spendable'], False)\n         assert_equal(p2shunspent['solvable'], True)\n \n-\n         # P2SH + Redeem script + Private Keys + !Watchonly\n         sig_address_1 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n         sig_address_2 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n@@ -329,13 +323,13 @@ def run_test (self):\n             },\n             \"timestamp\": \"now\",\n             \"redeemscript\": multi_sig_script['redeemScript'],\n-            \"keys\": [ self.nodes[0].dumpprivkey(sig_address_1['address']), self.nodes[0].dumpprivkey(sig_address_2['address'])]\n+            \"keys\": [self.nodes[0].dumpprivkey(sig_address_1['address']), self.nodes[0].dumpprivkey(sig_address_2['address'])]\n         }])\n         assert_equal(result[0]['success'], True)\n         address_assert = self.nodes[1].getaddressinfo(multi_sig_script['address'])\n         assert_equal(address_assert['timestamp'], timestamp)\n \n-        p2shunspent = self.nodes[1].listunspent(0,999999, [multi_sig_script['address']])[0]\n+        p2shunspent = self.nodes[1].listunspent(0, 999999, [multi_sig_script['address']])[0]\n         assert_equal(p2shunspent['spendable'], False)\n         assert_equal(p2shunspent['solvable'], True)\n \n@@ -356,14 +350,13 @@ def run_test (self):\n             },\n             \"timestamp\": \"now\",\n             \"redeemscript\": multi_sig_script['redeemScript'],\n-            \"keys\": [ self.nodes[0].dumpprivkey(sig_address_1['address']), self.nodes[0].dumpprivkey(sig_address_2['address'])],\n+            \"keys\": [self.nodes[0].dumpprivkey(sig_address_1['address']), self.nodes[0].dumpprivkey(sig_address_2['address'])],\n             \"watchonly\": True\n         }])\n         assert_equal(result[0]['success'], False)\n         assert_equal(result[0]['error']['code'], -8)\n         assert_equal(result[0]['error']['message'], 'Watch-only addresses should not include private keys')\n \n-\n         # Address + Public key + !Internal + Wrong pubkey\n         self.log.info(\"Should not import an address with a wrong public key\")\n         address = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n@@ -373,7 +366,7 @@ def run_test (self):\n                 \"address\": address['address']\n             },\n             \"timestamp\": \"now\",\n-            \"pubkeys\": [ address2['pubkey'] ]\n+            \"pubkeys\": [address2['pubkey']]\n         }])\n         assert_equal(result[0]['success'], False)\n         assert_equal(result[0]['error']['code'], -5)\n@@ -383,15 +376,14 @@ def run_test (self):\n         assert_equal(address_assert['ismine'], False)\n         assert_equal('timestamp' in address_assert, False)\n \n-\n         # ScriptPubKey + Public key + internal + Wrong pubkey\n         self.log.info(\"Should not import a scriptPubKey with internal and with a wrong public key\")\n         address = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n         address2 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n         request = [{\n             \"scriptPubKey\": address['scriptPubKey'],\n             \"timestamp\": \"now\",\n-            \"pubkeys\": [ address2['pubkey'] ],\n+            \"pubkeys\": [address2['pubkey']],\n             \"internal\": True\n         }]\n         result = self.nodes[1].importmulti(request)\n@@ -403,7 +395,6 @@ def run_test (self):\n         assert_equal(address_assert['ismine'], False)\n         assert_equal('timestamp' in address_assert, False)\n \n-\n         # Address + Private key + !watchonly + Wrong private key\n         self.log.info(\"Should not import an address with a wrong private key\")\n         address = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n@@ -413,7 +404,7 @@ def run_test (self):\n                 \"address\": address['address']\n             },\n             \"timestamp\": \"now\",\n-            \"keys\": [ self.nodes[0].dumpprivkey(address2['address']) ]\n+            \"keys\": [self.nodes[0].dumpprivkey(address2['address'])]\n         }])\n         assert_equal(result[0]['success'], False)\n         assert_equal(result[0]['error']['code'], -5)\n@@ -423,15 +414,14 @@ def run_test (self):\n         assert_equal(address_assert['ismine'], False)\n         assert_equal('timestamp' in address_assert, False)\n \n-\n         # ScriptPubKey + Private key + internal + Wrong private key\n         self.log.info(\"Should not import a scriptPubKey with internal and with a wrong private key\")\n         address = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n         address2 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n         result = self.nodes[1].importmulti([{\n             \"scriptPubKey\": address['scriptPubKey'],\n             \"timestamp\": \"now\",\n-            \"keys\": [ self.nodes[0].dumpprivkey(address2['address']) ],\n+            \"keys\": [self.nodes[0].dumpprivkey(address2['address'])],\n             \"internal\": True\n         }])\n         assert_equal(result[0]['success'], False)\n@@ -442,7 +432,6 @@ def run_test (self):\n         assert_equal(address_assert['ismine'], False)\n         assert_equal('timestamp' in address_assert, False)\n \n-\n         # Importing existing watch only address with new timestamp should replace saved timestamp.\n         assert_greater_than(timestamp, watchonly_timestamp)\n         self.log.info(\"Should replace previously saved watch only timestamp.\")\n@@ -459,7 +448,6 @@ def run_test (self):\n         assert_equal(address_assert['timestamp'], timestamp)\n         watchonly_timestamp = timestamp\n \n-\n         # restart nodes to check for proper serialization/deserialization of watch only address\n         self.stop_nodes()\n         self.start_nodes()\n@@ -471,14 +459,12 @@ def run_test (self):\n         # Bad or missing timestamps\n         self.log.info(\"Should throw on invalid or missing timestamp values\")\n         assert_raises_rpc_error(-3, 'Missing required timestamp field for key',\n-            self.nodes[1].importmulti, [{\n-                \"scriptPubKey\": address['scriptPubKey'],\n-            }])\n+                                self.nodes[1].importmulti, [{\"scriptPubKey\": address['scriptPubKey']}])\n         assert_raises_rpc_error(-3, 'Expected number or \"now\" timestamp value for key. got type string',\n-            self.nodes[1].importmulti, [{\n-                \"scriptPubKey\": address['scriptPubKey'],\n-                \"timestamp\": \"\",\n-            }])\n+                                self.nodes[1].importmulti, [{\n+                                    \"scriptPubKey\": address['scriptPubKey'],\n+                                    \"timestamp\": \"\"\n+                                }])\n \n         # Import P2WPKH address as watch only\n         self.log.info(\"Should import a P2WPKH address as watch only\")\n@@ -502,7 +488,7 @@ def run_test (self):\n                 \"address\": address['address']\n             },\n             \"timestamp\": \"now\",\n-            \"pubkeys\": [ address['pubkey'] ]\n+            \"pubkeys\": [address['pubkey']]\n         }])\n         assert_equal(result[0]['success'], True)\n         address_assert = self.nodes[1].getaddressinfo(address['address'])\n@@ -547,7 +533,7 @@ def run_test (self):\n             },\n             \"timestamp\": \"now\",\n             \"witnessscript\": multi_sig_script['redeemScript'],\n-            \"keys\": [ self.nodes[0].dumpprivkey(sig_address_1['address']), self.nodes[0].dumpprivkey(sig_address_2['address']) ]\n+            \"keys\": [self.nodes[0].dumpprivkey(sig_address_1['address']), self.nodes[0].dumpprivkey(sig_address_2['address'])]\n         }])\n         assert_equal(result[0]['success'], True)\n         address_assert = self.nodes[1].getaddressinfo(multi_sig_script['address'])\n@@ -579,7 +565,7 @@ def run_test (self):\n             },\n             \"timestamp\": \"now\",\n             \"redeemscript\": bytes_to_hex_str(pkscript),\n-            \"pubkeys\": [ sig_address_1['pubkey'] ]\n+            \"pubkeys\": [sig_address_1['pubkey']]\n         }])\n         assert_equal(result[0]['success'], True)\n         address_assert = self.nodes[1].getaddressinfo(sig_address_1['address'])\n@@ -597,7 +583,7 @@ def run_test (self):\n             },\n             \"timestamp\": \"now\",\n             \"redeemscript\": bytes_to_hex_str(pkscript),\n-            \"keys\": [ self.nodes[0].dumpprivkey(sig_address_1['address'])]\n+            \"keys\": [self.nodes[0].dumpprivkey(sig_address_1['address'])]\n         }])\n         assert_equal(result[0]['success'], True)\n         address_assert = self.nodes[1].getaddressinfo(sig_address_1['address'])\n@@ -623,4 +609,4 @@ def run_test (self):\n         assert_equal(address_assert['solvable'], True)\n \n if __name__ == '__main__':\n-    ImportMultiTest ().main ()\n+    ImportMultiTest().main()"
      }
    ]
  },
  {
    "sha": "e5a8ea8f146393e2a5e7d73a49335f3670bada11",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplNWE4ZWE4ZjE0NjM5M2UyYTVlN2Q3M2E0OTMzNWYzNjcwYmFkYTEx",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-11-30T22:49:03Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-12-06T17:18:52Z"
      },
      "message": "[tests] tidy up imports in wallet_importmulti.py",
      "tree": {
        "sha": "30c7696918d0fed7d2edbc77ef0585674c170d32",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/30c7696918d0fed7d2edbc77ef0585674c170d32"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e5a8ea8f146393e2a5e7d73a49335f3670bada11",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e5a8ea8f146393e2a5e7d73a49335f3670bada11",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e5a8ea8f146393e2a5e7d73a49335f3670bada11",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e5a8ea8f146393e2a5e7d73a49335f3670bada11/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "cb41ade6b1d9e9b0abea42f7a6946c13ebfb2083",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cb41ade6b1d9e9b0abea42f7a6946c13ebfb2083",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/cb41ade6b1d9e9b0abea42f7a6946c13ebfb2083"
      }
    ],
    "stats": {
      "total": 16,
      "additions": 8,
      "deletions": 8
    },
    "files": [
      {
        "sha": "b6159063e13ca77fab4f88bdd1521e638710a764",
        "filename": "test/functional/wallet_importmulti.py",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e5a8ea8f146393e2a5e7d73a49335f3670bada11/test/functional/wallet_importmulti.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e5a8ea8f146393e2a5e7d73a49335f3670bada11/test/functional/wallet_importmulti.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_importmulti.py?ref=e5a8ea8f146393e2a5e7d73a49335f3670bada11",
        "patch": "@@ -4,7 +4,13 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test the importmulti RPC.\"\"\"\n \n-from test_framework import script\n+from test_framework.messages import sha256\n+from test_framework.script import (\n+    CScript,\n+    OP_0,\n+    OP_NOP,\n+    hash160\n+)\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n     assert_equal,\n@@ -13,12 +19,6 @@\n     bytes_to_hex_str,\n     hex_str_to_bytes\n )\n-from test_framework.script import (\n-    CScript,\n-    OP_0,\n-    hash160\n-)\n-from test_framework.messages import sha256\n \n class ImportMultiTest(BitcoinTestFramework):\n     def set_test_params(self):\n@@ -112,7 +112,7 @@ def run_test(self):\n \n         # Nonstandard scriptPubKey + !internal\n         self.log.info(\"Should not import a nonstandard scriptPubKey without internal flag\")\n-        nonstandardScriptPubKey = address['scriptPubKey'] + bytes_to_hex_str(script.CScript([script.OP_NOP]))\n+        nonstandardScriptPubKey = address['scriptPubKey'] + bytes_to_hex_str(CScript([OP_NOP]))\n         address = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n         result = self.nodes[1].importmulti([{\n             \"scriptPubKey\": nonstandardScriptPubKey,"
      }
    ]
  },
  {
    "sha": "7c99614b40301daba5e526c6e3ab281965e869c6",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3Yzk5NjE0YjQwMzAxZGFiYTVlNTI2YzZlM2FiMjgxOTY1ZTg2OWM2",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-12-05T23:28:32Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-12-10T20:17:26Z"
      },
      "message": "[tests] add get_key function to wallet_importmulti.py\n\nAdds a new get_key function which generates\na new key and returns the public key,\nprivate key and all script and address types.",
      "tree": {
        "sha": "853c99ac97ccd6f411c7a677143bb18c6fb4d8bb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/853c99ac97ccd6f411c7a677143bb18c6fb4d8bb"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7c99614b40301daba5e526c6e3ab281965e869c6",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7c99614b40301daba5e526c6e3ab281965e869c6",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7c99614b40301daba5e526c6e3ab281965e869c6",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7c99614b40301daba5e526c6e3ab281965e869c6/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e5a8ea8f146393e2a5e7d73a49335f3670bada11",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e5a8ea8f146393e2a5e7d73a49335f3670bada11",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e5a8ea8f146393e2a5e7d73a49335f3670bada11"
      }
    ],
    "stats": {
      "total": 232,
      "additions": 142,
      "deletions": 90
    },
    "files": [
      {
        "sha": "6cf854882e04b941f3283f6377e45bcc39cdd50b",
        "filename": "test/functional/wallet_importmulti.py",
        "status": "modified",
        "additions": 142,
        "deletions": 90,
        "changes": 232,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c99614b40301daba5e526c6e3ab281965e869c6/test/functional/wallet_importmulti.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c99614b40301daba5e526c6e3ab281965e869c6/test/functional/wallet_importmulti.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_importmulti.py?ref=7c99614b40301daba5e526c6e3ab281965e869c6",
        "patch": "@@ -3,13 +3,24 @@\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test the importmulti RPC.\"\"\"\n+from collections import namedtuple\n \n+from test_framework.address import (\n+    key_to_p2pkh,\n+    key_to_p2sh_p2wpkh,\n+    key_to_p2wpkh,\n+)\n from test_framework.messages import sha256\n from test_framework.script import (\n     CScript,\n     OP_0,\n+    OP_CHECKSIG,\n+    OP_DUP,\n+    OP_EQUAL,\n+    OP_EQUALVERIFY,\n+    OP_HASH160,\n     OP_NOP,\n-    hash160\n+    hash160,\n )\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n@@ -20,6 +31,16 @@\n     hex_str_to_bytes\n )\n \n+Key = namedtuple('Key', ['privkey',\n+                         'pubkey',\n+                         'p2pkh_script',\n+                         'p2pkh_addr',\n+                         'p2wpkh_script',\n+                         'p2wpkh_addr',\n+                         'p2sh_p2wpkh_script',\n+                         'p2sh_p2wpkh_redeem_script',\n+                         'p2sh_p2wpkh_addr'])\n+\n class ImportMultiTest(BitcoinTestFramework):\n     def set_test_params(self):\n         self.num_nodes = 2\n@@ -32,6 +53,23 @@ def skip_test_if_missing_module(self):\n     def setup_network(self):\n         self.setup_nodes()\n \n+    def get_key(self):\n+        \"\"\"Generate a fresh key on node0\n+\n+        Returns a named tuple of privkey, pubkey and all address and scripts.\"\"\"\n+        addr = self.nodes[0].getnewaddress()\n+        pubkey = self.nodes[0].getaddressinfo(addr)['pubkey']\n+        pkh = hash160(hex_str_to_bytes(pubkey))\n+        return Key(self.nodes[0].dumpprivkey(addr),\n+                   pubkey,\n+                   CScript([OP_DUP, OP_HASH160, pkh, OP_EQUALVERIFY, OP_CHECKSIG]).hex(),  # p2pkh\n+                   key_to_p2pkh(pubkey),  # p2pkh addr\n+                   CScript([OP_0, pkh]).hex(),  # p2wpkh\n+                   key_to_p2wpkh(pubkey),  # p2wpkh addr\n+                   CScript([OP_HASH160, hash160(CScript([OP_0, pkh])), OP_EQUAL]).hex(),  # p2sh-p2wpkh\n+                   CScript([OP_0, pkh]).hex(),  # p2sh-p2wpkh redeem script\n+                   key_to_p2sh_p2wpkh(pubkey))  # p2sh-p2wpkh addr\n+\n     def run_test(self):\n         self.log.info(\"Mining blocks...\")\n         self.nodes[0].generate(1)\n@@ -55,20 +93,21 @@ def run_test(self):\n \n         # Bitcoin Address (implicit non-internal)\n         self.log.info(\"Should import an address\")\n-        address = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n+        key = self.get_key()\n+        address = key.p2pkh_addr\n         result = self.nodes[1].importmulti([{\n             \"scriptPubKey\": {\n-                \"address\": address['address']\n+                \"address\": address\n             },\n             \"timestamp\": \"now\",\n         }])\n         assert_equal(result[0]['success'], True)\n-        address_assert = self.nodes[1].getaddressinfo(address['address'])\n+        address_assert = self.nodes[1].getaddressinfo(address)\n         assert_equal(address_assert['iswatchonly'], True)\n         assert_equal(address_assert['ismine'], False)\n         assert_equal(address_assert['timestamp'], timestamp)\n         assert_equal(address_assert['ischange'], False)\n-        watchonly_address = address['address']\n+        watchonly_address = address\n         watchonly_timestamp = timestamp\n \n         self.log.info(\"Should not import an invalid address\")\n@@ -84,24 +123,24 @@ def run_test(self):\n \n         # ScriptPubKey + internal\n         self.log.info(\"Should import a scriptPubKey with internal flag\")\n-        address = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n+        key = self.get_key()\n         result = self.nodes[1].importmulti([{\n-            \"scriptPubKey\": address['scriptPubKey'],\n+            \"scriptPubKey\": key.p2pkh_script,\n             \"timestamp\": \"now\",\n             \"internal\": True\n         }])\n         assert_equal(result[0]['success'], True)\n-        address_assert = self.nodes[1].getaddressinfo(address['address'])\n+        address_assert = self.nodes[1].getaddressinfo(key.p2pkh_addr)\n         assert_equal(address_assert['iswatchonly'], True)\n         assert_equal(address_assert['ismine'], False)\n         assert_equal(address_assert['timestamp'], timestamp)\n         assert_equal(address_assert['ischange'], True)\n \n         # ScriptPubKey + internal + label\n         self.log.info(\"Should not allow a label to be specified when internal is true\")\n-        address = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n+        key = self.get_key()\n         result = self.nodes[1].importmulti([{\n-            \"scriptPubKey\": address['scriptPubKey'],\n+            \"scriptPubKey\": key.p2pkh_script,\n             \"timestamp\": \"now\",\n             \"internal\": True,\n             \"label\": \"Example label\"\n@@ -112,144 +151,152 @@ def run_test(self):\n \n         # Nonstandard scriptPubKey + !internal\n         self.log.info(\"Should not import a nonstandard scriptPubKey without internal flag\")\n-        nonstandardScriptPubKey = address['scriptPubKey'] + bytes_to_hex_str(CScript([OP_NOP]))\n-        address = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n+        nonstandardScriptPubKey = key.p2pkh_script + bytes_to_hex_str(CScript([OP_NOP]))\n+        key = self.get_key()\n+        address = key.p2pkh_addr\n         result = self.nodes[1].importmulti([{\n             \"scriptPubKey\": nonstandardScriptPubKey,\n             \"timestamp\": \"now\",\n         }])\n         assert_equal(result[0]['success'], False)\n         assert_equal(result[0]['error']['code'], -8)\n         assert_equal(result[0]['error']['message'], 'Internal must be set to true for nonstandard scriptPubKey imports.')\n-        address_assert = self.nodes[1].getaddressinfo(address['address'])\n+        address_assert = self.nodes[1].getaddressinfo(address)\n         assert_equal(address_assert['iswatchonly'], False)\n         assert_equal(address_assert['ismine'], False)\n         assert_equal('timestamp' in address_assert, False)\n \n         # Address + Public key + !Internal(explicit)\n         self.log.info(\"Should import an address with public key\")\n-        address = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n+        key = self.get_key()\n+        address = key.p2pkh_addr\n         result = self.nodes[1].importmulti([{\n             \"scriptPubKey\": {\n-                \"address\": address['address']\n+                \"address\": address\n             },\n             \"timestamp\": \"now\",\n-            \"pubkeys\": [address['pubkey']],\n+            \"pubkeys\": [key.pubkey],\n             \"internal\": False\n         }])\n         assert_equal(result[0]['success'], True)\n-        address_assert = self.nodes[1].getaddressinfo(address['address'])\n+        address_assert = self.nodes[1].getaddressinfo(address)\n         assert_equal(address_assert['iswatchonly'], True)\n         assert_equal(address_assert['ismine'], False)\n         assert_equal(address_assert['timestamp'], timestamp)\n \n         # ScriptPubKey + Public key + internal\n         self.log.info(\"Should import a scriptPubKey with internal and with public key\")\n-        address = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n+        key = self.get_key()\n+        address = key.p2pkh_addr\n         request = [{\n-            \"scriptPubKey\": address['scriptPubKey'],\n+            \"scriptPubKey\": key.p2pkh_script,\n             \"timestamp\": \"now\",\n-            \"pubkeys\": [address['pubkey']],\n+            \"pubkeys\": [key.pubkey],\n             \"internal\": True\n         }]\n         result = self.nodes[1].importmulti(requests=request)\n         assert_equal(result[0]['success'], True)\n-        address_assert = self.nodes[1].getaddressinfo(address['address'])\n+        address_assert = self.nodes[1].getaddressinfo(address)\n         assert_equal(address_assert['iswatchonly'], True)\n         assert_equal(address_assert['ismine'], False)\n         assert_equal(address_assert['timestamp'], timestamp)\n \n         # Nonstandard scriptPubKey + Public key + !internal\n         self.log.info(\"Should not import a nonstandard scriptPubKey without internal and with public key\")\n-        address = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n+        key = self.get_key()\n+        address = key.p2pkh_addr\n         request = [{\n             \"scriptPubKey\": nonstandardScriptPubKey,\n             \"timestamp\": \"now\",\n-            \"pubkeys\": [address['pubkey']]\n+            \"pubkeys\": [key.pubkey]\n         }]\n         result = self.nodes[1].importmulti(requests=request)\n         assert_equal(result[0]['success'], False)\n         assert_equal(result[0]['error']['code'], -8)\n         assert_equal(result[0]['error']['message'], 'Internal must be set to true for nonstandard scriptPubKey imports.')\n-        address_assert = self.nodes[1].getaddressinfo(address['address'])\n+        address_assert = self.nodes[1].getaddressinfo(address)\n         assert_equal(address_assert['iswatchonly'], False)\n         assert_equal(address_assert['ismine'], False)\n         assert_equal('timestamp' in address_assert, False)\n \n         # Address + Private key + !watchonly\n         self.log.info(\"Should import an address with private key\")\n-        address = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n+        key = self.get_key()\n+        address = key.p2pkh_addr\n         result = self.nodes[1].importmulti([{\n             \"scriptPubKey\": {\n-                \"address\": address['address']\n+                \"address\": address\n             },\n             \"timestamp\": \"now\",\n-            \"keys\": [self.nodes[0].dumpprivkey(address['address'])]\n+            \"keys\": [key.privkey]\n         }])\n         assert_equal(result[0]['success'], True)\n-        address_assert = self.nodes[1].getaddressinfo(address['address'])\n+        address_assert = self.nodes[1].getaddressinfo(address)\n         assert_equal(address_assert['iswatchonly'], False)\n         assert_equal(address_assert['ismine'], True)\n         assert_equal(address_assert['timestamp'], timestamp)\n \n         self.log.info(\"Should not import an address with private key if is already imported\")\n         result = self.nodes[1].importmulti([{\n             \"scriptPubKey\": {\n-                \"address\": address['address']\n+                \"address\": address\n             },\n             \"timestamp\": \"now\",\n-            \"keys\": [self.nodes[0].dumpprivkey(address['address'])]\n+            \"keys\": [key.privkey]\n         }])\n         assert_equal(result[0]['success'], False)\n         assert_equal(result[0]['error']['code'], -4)\n         assert_equal(result[0]['error']['message'], 'The wallet already contains the private key for this address or script')\n \n         # Address + Private key + watchonly\n         self.log.info(\"Should not import an address with private key and with watchonly\")\n-        address = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n+        key = self.get_key()\n+        address = key.p2pkh_addr\n         result = self.nodes[1].importmulti([{\n             \"scriptPubKey\": {\n-                \"address\": address['address']\n+                \"address\": address\n             },\n             \"timestamp\": \"now\",\n-            \"keys\": [self.nodes[0].dumpprivkey(address['address'])],\n+            \"keys\": [key.privkey],\n             \"watchonly\": True\n         }])\n         assert_equal(result[0]['success'], False)\n         assert_equal(result[0]['error']['code'], -8)\n         assert_equal(result[0]['error']['message'], 'Watch-only addresses should not include private keys')\n-        address_assert = self.nodes[1].getaddressinfo(address['address'])\n+        address_assert = self.nodes[1].getaddressinfo(address)\n         assert_equal(address_assert['iswatchonly'], False)\n         assert_equal(address_assert['ismine'], False)\n         assert_equal('timestamp' in address_assert, False)\n \n         # ScriptPubKey + Private key + internal\n         self.log.info(\"Should import a scriptPubKey with internal and with private key\")\n-        address = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n+        key = self.get_key()\n+        address = key.p2pkh_addr\n         result = self.nodes[1].importmulti([{\n-            \"scriptPubKey\": address['scriptPubKey'],\n+            \"scriptPubKey\": key.p2pkh_script,\n             \"timestamp\": \"now\",\n-            \"keys\": [self.nodes[0].dumpprivkey(address['address'])],\n+            \"keys\": [key.privkey],\n             \"internal\": True\n         }])\n         assert_equal(result[0]['success'], True)\n-        address_assert = self.nodes[1].getaddressinfo(address['address'])\n+        address_assert = self.nodes[1].getaddressinfo(address)\n         assert_equal(address_assert['iswatchonly'], False)\n         assert_equal(address_assert['ismine'], True)\n         assert_equal(address_assert['timestamp'], timestamp)\n \n         # Nonstandard scriptPubKey + Private key + !internal\n         self.log.info(\"Should not import a nonstandard scriptPubKey without internal and with private key\")\n-        address = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n+        key = self.get_key()\n+        address = key.p2pkh_addr\n         result = self.nodes[1].importmulti([{\n             \"scriptPubKey\": nonstandardScriptPubKey,\n             \"timestamp\": \"now\",\n-            \"keys\": [self.nodes[0].dumpprivkey(address['address'])]\n+            \"keys\": [key.privkey]\n         }])\n         assert_equal(result[0]['success'], False)\n         assert_equal(result[0]['error']['code'], -8)\n         assert_equal(result[0]['error']['message'], 'Internal must be set to true for nonstandard scriptPubKey imports.')\n-        address_assert = self.nodes[1].getaddressinfo(address['address'])\n+        address_assert = self.nodes[1].getaddressinfo(address)\n         assert_equal(address_assert['iswatchonly'], False)\n         assert_equal(address_assert['ismine'], False)\n         assert_equal('timestamp' in address_assert, False)\n@@ -359,75 +406,79 @@ def run_test(self):\n \n         # Address + Public key + !Internal + Wrong pubkey\n         self.log.info(\"Should not import an address with a wrong public key\")\n-        address = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n-        address2 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n+        key = self.get_key()\n+        address = key.p2pkh_addr\n+        wrong_key = self.get_key().pubkey\n         result = self.nodes[1].importmulti([{\n             \"scriptPubKey\": {\n-                \"address\": address['address']\n+                \"address\": address\n             },\n             \"timestamp\": \"now\",\n-            \"pubkeys\": [address2['pubkey']]\n+            \"pubkeys\": [wrong_key]\n         }])\n         assert_equal(result[0]['success'], False)\n         assert_equal(result[0]['error']['code'], -5)\n         assert_equal(result[0]['error']['message'], 'Key does not match address destination')\n-        address_assert = self.nodes[1].getaddressinfo(address['address'])\n+        address_assert = self.nodes[1].getaddressinfo(address)\n         assert_equal(address_assert['iswatchonly'], False)\n         assert_equal(address_assert['ismine'], False)\n         assert_equal('timestamp' in address_assert, False)\n \n         # ScriptPubKey + Public key + internal + Wrong pubkey\n         self.log.info(\"Should not import a scriptPubKey with internal and with a wrong public key\")\n-        address = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n-        address2 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n+        key = self.get_key()\n+        address = key.p2pkh_addr\n+        wrong_key = self.get_key().pubkey\n         request = [{\n-            \"scriptPubKey\": address['scriptPubKey'],\n+            \"scriptPubKey\": key.p2pkh_script,\n             \"timestamp\": \"now\",\n-            \"pubkeys\": [address2['pubkey']],\n+            \"pubkeys\": [wrong_key],\n             \"internal\": True\n         }]\n         result = self.nodes[1].importmulti(request)\n         assert_equal(result[0]['success'], False)\n         assert_equal(result[0]['error']['code'], -5)\n         assert_equal(result[0]['error']['message'], 'Key does not match address destination')\n-        address_assert = self.nodes[1].getaddressinfo(address['address'])\n+        address_assert = self.nodes[1].getaddressinfo(address)\n         assert_equal(address_assert['iswatchonly'], False)\n         assert_equal(address_assert['ismine'], False)\n         assert_equal('timestamp' in address_assert, False)\n \n         # Address + Private key + !watchonly + Wrong private key\n         self.log.info(\"Should not import an address with a wrong private key\")\n-        address = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n-        address2 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n+        key = self.get_key()\n+        address = key.p2pkh_addr\n+        wrong_privkey = self.get_key().privkey\n         result = self.nodes[1].importmulti([{\n             \"scriptPubKey\": {\n-                \"address\": address['address']\n+                \"address\": address\n             },\n             \"timestamp\": \"now\",\n-            \"keys\": [self.nodes[0].dumpprivkey(address2['address'])]\n+            \"keys\": [wrong_privkey]\n         }])\n         assert_equal(result[0]['success'], False)\n         assert_equal(result[0]['error']['code'], -5)\n         assert_equal(result[0]['error']['message'], 'Key does not match address destination')\n-        address_assert = self.nodes[1].getaddressinfo(address['address'])\n+        address_assert = self.nodes[1].getaddressinfo(address)\n         assert_equal(address_assert['iswatchonly'], False)\n         assert_equal(address_assert['ismine'], False)\n         assert_equal('timestamp' in address_assert, False)\n \n         # ScriptPubKey + Private key + internal + Wrong private key\n         self.log.info(\"Should not import a scriptPubKey with internal and with a wrong private key\")\n-        address = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n-        address2 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n+        key = self.get_key()\n+        address = key.p2pkh_addr\n+        wrong_privkey = self.get_key().privkey\n         result = self.nodes[1].importmulti([{\n-            \"scriptPubKey\": address['scriptPubKey'],\n+            \"scriptPubKey\": key.p2pkh_script,\n             \"timestamp\": \"now\",\n-            \"keys\": [self.nodes[0].dumpprivkey(address2['address'])],\n+            \"keys\": [wrong_privkey],\n             \"internal\": True\n         }])\n         assert_equal(result[0]['success'], False)\n         assert_equal(result[0]['error']['code'], -5)\n         assert_equal(result[0]['error']['message'], 'Key does not match address destination')\n-        address_assert = self.nodes[1].getaddressinfo(address['address'])\n+        address_assert = self.nodes[1].getaddressinfo(address)\n         assert_equal(address_assert['iswatchonly'], False)\n         assert_equal(address_assert['ismine'], False)\n         assert_equal('timestamp' in address_assert, False)\n@@ -459,54 +510,57 @@ def run_test(self):\n         # Bad or missing timestamps\n         self.log.info(\"Should throw on invalid or missing timestamp values\")\n         assert_raises_rpc_error(-3, 'Missing required timestamp field for key',\n-                                self.nodes[1].importmulti, [{\"scriptPubKey\": address['scriptPubKey']}])\n+                                self.nodes[1].importmulti, [{\"scriptPubKey\": key.p2pkh_script}])\n         assert_raises_rpc_error(-3, 'Expected number or \"now\" timestamp value for key. got type string',\n                                 self.nodes[1].importmulti, [{\n-                                    \"scriptPubKey\": address['scriptPubKey'],\n+                                    \"scriptPubKey\": key.p2pkh_script,\n                                     \"timestamp\": \"\"\n                                 }])\n \n         # Import P2WPKH address as watch only\n         self.log.info(\"Should import a P2WPKH address as watch only\")\n-        address = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress(address_type=\"bech32\"))\n+        key = self.get_key()\n+        address = key.p2wpkh_addr\n         result = self.nodes[1].importmulti([{\n             \"scriptPubKey\": {\n-                \"address\": address['address']\n+                \"address\": address\n             },\n             \"timestamp\": \"now\",\n         }])\n         assert_equal(result[0]['success'], True)\n-        address_assert = self.nodes[1].getaddressinfo(address['address'])\n+        address_assert = self.nodes[1].getaddressinfo(address)\n         assert_equal(address_assert['iswatchonly'], True)\n         assert_equal(address_assert['solvable'], False)\n \n         # Import P2WPKH address with public key but no private key\n         self.log.info(\"Should import a P2WPKH address and public key as solvable but not spendable\")\n-        address = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress(address_type=\"bech32\"))\n+        key = self.get_key()\n+        address = key.p2wpkh_addr\n         result = self.nodes[1].importmulti([{\n             \"scriptPubKey\": {\n-                \"address\": address['address']\n+                \"address\": address\n             },\n             \"timestamp\": \"now\",\n-            \"pubkeys\": [address['pubkey']]\n+            \"pubkeys\": [key.pubkey]\n         }])\n         assert_equal(result[0]['success'], True)\n-        address_assert = self.nodes[1].getaddressinfo(address['address'])\n+        address_assert = self.nodes[1].getaddressinfo(address)\n         assert_equal(address_assert['ismine'], False)\n         assert_equal(address_assert['solvable'], True)\n \n         # Import P2WPKH address with key and check it is spendable\n         self.log.info(\"Should import a P2WPKH address with key\")\n-        address = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress(address_type=\"bech32\"))\n+        key = self.get_key()\n+        address = key.p2wpkh_addr\n         result = self.nodes[1].importmulti([{\n             \"scriptPubKey\": {\n-                \"address\": address['address']\n+                \"address\": address\n             },\n             \"timestamp\": \"now\",\n-            \"keys\": [self.nodes[0].dumpprivkey(address['address'])]\n+            \"keys\": [key.privkey]\n         }])\n         assert_equal(result[0]['success'], True)\n-        address_assert = self.nodes[1].getaddressinfo(address['address'])\n+        address_assert = self.nodes[1].getaddressinfo(address)\n         assert_equal(address_assert['iswatchonly'], False)\n         assert_equal(address_assert['ismine'], True)\n \n@@ -542,51 +596,49 @@ def run_test(self):\n         assert_equal(address_assert['sigsrequired'], 2)\n \n         # P2SH-P2WPKH address with no redeemscript or public or private key\n-        sig_address_1 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress(address_type=\"p2sh-segwit\"))\n-        pubkeyhash = hash160(hex_str_to_bytes(sig_address_1['pubkey']))\n-        pkscript = CScript([OP_0, pubkeyhash])\n+        key = self.get_key()\n+        address = key.p2sh_p2wpkh_addr\n         self.log.info(\"Should import a p2sh-p2wpkh without redeem script or keys\")\n         result = self.nodes[1].importmulti([{\n             \"scriptPubKey\": {\n-                \"address\": sig_address_1['address']\n+                \"address\": address\n             },\n             \"timestamp\": \"now\"\n         }])\n         assert_equal(result[0]['success'], True)\n-        address_assert = self.nodes[1].getaddressinfo(sig_address_1['address'])\n+        address_assert = self.nodes[1].getaddressinfo(address)\n         assert_equal(address_assert['solvable'], False)\n         assert_equal(address_assert['ismine'], False)\n \n         # P2SH-P2WPKH address + redeemscript + public key with no private key\n         self.log.info(\"Should import a p2sh-p2wpkh with respective redeem script and pubkey as solvable\")\n         result = self.nodes[1].importmulti([{\n             \"scriptPubKey\": {\n-                \"address\": sig_address_1['address']\n+                \"address\": address\n             },\n             \"timestamp\": \"now\",\n-            \"redeemscript\": bytes_to_hex_str(pkscript),\n-            \"pubkeys\": [sig_address_1['pubkey']]\n+            \"redeemscript\": key.p2sh_p2wpkh_redeem_script,\n+            \"pubkeys\": [key.pubkey]\n         }])\n         assert_equal(result[0]['success'], True)\n-        address_assert = self.nodes[1].getaddressinfo(sig_address_1['address'])\n+        address_assert = self.nodes[1].getaddressinfo(address)\n         assert_equal(address_assert['solvable'], True)\n         assert_equal(address_assert['ismine'], False)\n \n         # P2SH-P2WPKH address + redeemscript + private key\n-        sig_address_1 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress(address_type=\"p2sh-segwit\"))\n-        pubkeyhash = hash160(hex_str_to_bytes(sig_address_1['pubkey']))\n-        pkscript = CScript([OP_0, pubkeyhash])\n+        key = self.get_key()\n+        address = key.p2sh_p2wpkh_addr\n         self.log.info(\"Should import a p2sh-p2wpkh with respective redeem script and private keys\")\n         result = self.nodes[1].importmulti([{\n             \"scriptPubKey\": {\n-                \"address\": sig_address_1['address']\n+                \"address\": address\n             },\n             \"timestamp\": \"now\",\n-            \"redeemscript\": bytes_to_hex_str(pkscript),\n-            \"keys\": [self.nodes[0].dumpprivkey(sig_address_1['address'])]\n+            \"redeemscript\": key.p2sh_p2wpkh_redeem_script,\n+            \"keys\": [key.privkey]\n         }])\n         assert_equal(result[0]['success'], True)\n-        address_assert = self.nodes[1].getaddressinfo(sig_address_1['address'])\n+        address_assert = self.nodes[1].getaddressinfo(address)\n         assert_equal(address_assert['solvable'], True)\n         assert_equal(address_assert['ismine'], True)\n "
      }
    ]
  },
  {
    "sha": "08a4a0f70f545e114bc35dc76056282cb04bf013",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowOGE0YTBmNzBmNTQ1ZTExNGJjMzVkYzc2MDU2MjgyY2IwNGJmMDEz",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-12-05T23:28:32Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-12-10T20:17:28Z"
      },
      "message": "[tests] add get_multisig function to wallet_importmulti.py\n\nAdds a new get_multisig function which generates\na new multisig and returns the public keys,\nprivate keys and all script and address types.",
      "tree": {
        "sha": "6df8f2dabb99beb7b9f30550c8f0c2fe73645aba",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6df8f2dabb99beb7b9f30550c8f0c2fe73645aba"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/08a4a0f70f545e114bc35dc76056282cb04bf013",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/08a4a0f70f545e114bc35dc76056282cb04bf013",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/08a4a0f70f545e114bc35dc76056282cb04bf013",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/08a4a0f70f545e114bc35dc76056282cb04bf013/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7c99614b40301daba5e526c6e3ab281965e869c6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7c99614b40301daba5e526c6e3ab281965e869c6",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7c99614b40301daba5e526c6e3ab281965e869c6"
      }
    ],
    "stats": {
      "total": 131,
      "additions": 76,
      "deletions": 55
    },
    "files": [
      {
        "sha": "39927cfb9912eeca28e5a2cab90aa9184cad75a8",
        "filename": "test/functional/wallet_importmulti.py",
        "status": "modified",
        "additions": 76,
        "deletions": 55,
        "changes": 131,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/08a4a0f70f545e114bc35dc76056282cb04bf013/test/functional/wallet_importmulti.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/08a4a0f70f545e114bc35dc76056282cb04bf013/test/functional/wallet_importmulti.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_importmulti.py?ref=08a4a0f70f545e114bc35dc76056282cb04bf013",
        "patch": "@@ -9,18 +9,24 @@\n     key_to_p2pkh,\n     key_to_p2sh_p2wpkh,\n     key_to_p2wpkh,\n+    script_to_p2sh,\n+    script_to_p2sh_p2wsh,\n+    script_to_p2wsh,\n )\n-from test_framework.messages import sha256\n from test_framework.script import (\n     CScript,\n     OP_0,\n+    OP_2,\n+    OP_3,\n+    OP_CHECKMULTISIG,\n     OP_CHECKSIG,\n     OP_DUP,\n     OP_EQUAL,\n     OP_EQUALVERIFY,\n     OP_HASH160,\n     OP_NOP,\n     hash160,\n+    sha256,\n )\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n@@ -41,6 +47,16 @@\n                          'p2sh_p2wpkh_redeem_script',\n                          'p2sh_p2wpkh_addr'])\n \n+Multisig = namedtuple('Multisig', ['privkeys',\n+                                   'pubkeys',\n+                                   'p2sh_script',\n+                                   'p2sh_addr',\n+                                   'redeem_script',\n+                                   'p2wsh_script',\n+                                   'p2wsh_addr',\n+                                   'p2sh_p2wsh_script',\n+                                   'p2sh_p2wsh_addr'])\n+\n class ImportMultiTest(BitcoinTestFramework):\n     def set_test_params(self):\n         self.num_nodes = 2\n@@ -70,6 +86,28 @@ def get_key(self):\n                    CScript([OP_0, pkh]).hex(),  # p2sh-p2wpkh redeem script\n                    key_to_p2sh_p2wpkh(pubkey))  # p2sh-p2wpkh addr\n \n+    def get_multisig(self):\n+        \"\"\"Generate a fresh multisig on node0\n+\n+        Returns a named tuple of privkeys, pubkeys and all address and scripts.\"\"\"\n+        addrs = []\n+        pubkeys = []\n+        for _ in range(3):\n+            addr = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n+            addrs.append(addr['address'])\n+            pubkeys.append(addr['pubkey'])\n+        script_code = CScript([OP_2] + [hex_str_to_bytes(pubkey) for pubkey in pubkeys] + [OP_3, OP_CHECKMULTISIG])\n+        witness_script = CScript([OP_0, sha256(script_code)])\n+        return Multisig([self.nodes[0].dumpprivkey(addr) for addr in addrs],\n+                        pubkeys,\n+                        CScript([OP_HASH160, hash160(script_code), OP_EQUAL]).hex(),  # p2sh\n+                        script_to_p2sh(script_code),  # p2sh addr\n+                        script_code.hex(),  # redeem script\n+                        witness_script.hex(),  # p2wsh\n+                        script_to_p2wsh(script_code),  # p2wsh addr\n+                        CScript([OP_HASH160, witness_script, OP_EQUAL]).hex(),  # p2sh-p2wsh\n+                        script_to_p2sh_p2wsh(script_code))  # p2sh-p2wsh addr\n+\n     def run_test(self):\n         self.log.info(\"Mining blocks...\")\n         self.nodes[0].generate(1)\n@@ -302,102 +340,90 @@ def run_test(self):\n         assert_equal('timestamp' in address_assert, False)\n \n         # P2SH address\n-        sig_address_1 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n-        sig_address_2 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n-        sig_address_3 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n-        multi_sig_script = self.nodes[0].createmultisig(2, [sig_address_1['pubkey'], sig_address_2['pubkey'], sig_address_3['pubkey']])\n+        multisig = self.get_multisig()\n         self.nodes[1].generate(100)\n-        self.nodes[1].sendtoaddress(multi_sig_script['address'], 10.00)\n+        self.nodes[1].sendtoaddress(multisig.p2sh_addr, 10.00)\n         self.nodes[1].generate(1)\n         timestamp = self.nodes[1].getblock(self.nodes[1].getbestblockhash())['mediantime']\n \n         self.log.info(\"Should import a p2sh\")\n         result = self.nodes[1].importmulti([{\n             \"scriptPubKey\": {\n-                \"address\": multi_sig_script['address']\n+                \"address\": multisig.p2sh_addr\n             },\n             \"timestamp\": \"now\",\n         }])\n         assert_equal(result[0]['success'], True)\n-        address_assert = self.nodes[1].getaddressinfo(multi_sig_script['address'])\n+        address_assert = self.nodes[1].getaddressinfo(multisig.p2sh_addr)\n         assert_equal(address_assert['isscript'], True)\n         assert_equal(address_assert['iswatchonly'], True)\n         assert_equal(address_assert['timestamp'], timestamp)\n-        p2shunspent = self.nodes[1].listunspent(0, 999999, [multi_sig_script['address']])[0]\n+        p2shunspent = self.nodes[1].listunspent(0, 999999, [multisig.p2sh_addr])[0]\n         assert_equal(p2shunspent['spendable'], False)\n         assert_equal(p2shunspent['solvable'], False)\n \n         # P2SH + Redeem script\n-        sig_address_1 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n-        sig_address_2 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n-        sig_address_3 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n-        multi_sig_script = self.nodes[0].createmultisig(2, [sig_address_1['pubkey'], sig_address_2['pubkey'], sig_address_3['pubkey']])\n+        multisig = self.get_multisig()\n         self.nodes[1].generate(100)\n-        self.nodes[1].sendtoaddress(multi_sig_script['address'], 10.00)\n+        self.nodes[1].sendtoaddress(multisig.p2sh_addr, 10.00)\n         self.nodes[1].generate(1)\n         timestamp = self.nodes[1].getblock(self.nodes[1].getbestblockhash())['mediantime']\n \n         self.log.info(\"Should import a p2sh with respective redeem script\")\n         result = self.nodes[1].importmulti([{\n             \"scriptPubKey\": {\n-                \"address\": multi_sig_script['address']\n+                \"address\": multisig.p2sh_addr\n             },\n             \"timestamp\": \"now\",\n-            \"redeemscript\": multi_sig_script['redeemScript']\n+            \"redeemscript\": multisig.redeem_script\n         }])\n         assert_equal(result[0]['success'], True)\n-        address_assert = self.nodes[1].getaddressinfo(multi_sig_script['address'])\n+        address_assert = self.nodes[1].getaddressinfo(multisig.p2sh_addr)\n         assert_equal(address_assert['timestamp'], timestamp)\n \n-        p2shunspent = self.nodes[1].listunspent(0, 999999, [multi_sig_script['address']])[0]\n+        p2shunspent = self.nodes[1].listunspent(0, 999999, [multisig.p2sh_addr])[0]\n         assert_equal(p2shunspent['spendable'], False)\n         assert_equal(p2shunspent['solvable'], True)\n \n         # P2SH + Redeem script + Private Keys + !Watchonly\n-        sig_address_1 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n-        sig_address_2 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n-        sig_address_3 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n-        multi_sig_script = self.nodes[0].createmultisig(2, [sig_address_1['pubkey'], sig_address_2['pubkey'], sig_address_3['pubkey']])\n+        multisig = self.get_multisig()\n         self.nodes[1].generate(100)\n-        self.nodes[1].sendtoaddress(multi_sig_script['address'], 10.00)\n+        self.nodes[1].sendtoaddress(multisig.p2sh_addr, 10.00)\n         self.nodes[1].generate(1)\n         timestamp = self.nodes[1].getblock(self.nodes[1].getbestblockhash())['mediantime']\n \n         self.log.info(\"Should import a p2sh with respective redeem script and private keys\")\n         result = self.nodes[1].importmulti([{\n             \"scriptPubKey\": {\n-                \"address\": multi_sig_script['address']\n+                \"address\": multisig.p2sh_addr\n             },\n             \"timestamp\": \"now\",\n-            \"redeemscript\": multi_sig_script['redeemScript'],\n-            \"keys\": [self.nodes[0].dumpprivkey(sig_address_1['address']), self.nodes[0].dumpprivkey(sig_address_2['address'])]\n+            \"redeemscript\": multisig.redeem_script,\n+            \"keys\": multisig.privkeys[0:2]\n         }])\n         assert_equal(result[0]['success'], True)\n-        address_assert = self.nodes[1].getaddressinfo(multi_sig_script['address'])\n+        address_assert = self.nodes[1].getaddressinfo(multisig.p2sh_addr)\n         assert_equal(address_assert['timestamp'], timestamp)\n \n-        p2shunspent = self.nodes[1].listunspent(0, 999999, [multi_sig_script['address']])[0]\n+        p2shunspent = self.nodes[1].listunspent(0, 999999, [multisig.p2sh_addr])[0]\n         assert_equal(p2shunspent['spendable'], False)\n         assert_equal(p2shunspent['solvable'], True)\n \n         # P2SH + Redeem script + Private Keys + Watchonly\n-        sig_address_1 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n-        sig_address_2 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n-        sig_address_3 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n-        multi_sig_script = self.nodes[0].createmultisig(2, [sig_address_1['pubkey'], sig_address_2['pubkey'], sig_address_3['pubkey']])\n+        multisig = self.get_multisig()\n         self.nodes[1].generate(100)\n-        self.nodes[1].sendtoaddress(multi_sig_script['address'], 10.00)\n+        self.nodes[1].sendtoaddress(multisig.p2sh_addr, 10.00)\n         self.nodes[1].generate(1)\n         timestamp = self.nodes[1].getblock(self.nodes[1].getbestblockhash())['mediantime']\n \n         self.log.info(\"Should import a p2sh with respective redeem script and private keys\")\n         result = self.nodes[1].importmulti([{\n             \"scriptPubKey\": {\n-                \"address\": multi_sig_script['address']\n+                \"address\": multisig.p2sh_addr\n             },\n             \"timestamp\": \"now\",\n-            \"redeemscript\": multi_sig_script['redeemScript'],\n-            \"keys\": [self.nodes[0].dumpprivkey(sig_address_1['address']), self.nodes[0].dumpprivkey(sig_address_2['address'])],\n+            \"redeemscript\": multisig.redeem_script,\n+            \"keys\": multisig.privkeys[0:2],\n             \"watchonly\": True\n         }])\n         assert_equal(result[0]['success'], False)\n@@ -565,32 +591,30 @@ def run_test(self):\n         assert_equal(address_assert['ismine'], True)\n \n         # P2WSH multisig address without scripts or keys\n-        sig_address_1 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n-        sig_address_2 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n-        multi_sig_script = self.nodes[0].addmultisigaddress(2, [sig_address_1['pubkey'], sig_address_2['pubkey']], \"\", \"bech32\")\n+        multisig = self.get_multisig()\n         self.log.info(\"Should import a p2wsh multisig as watch only without respective redeem script and private keys\")\n         result = self.nodes[1].importmulti([{\n             \"scriptPubKey\": {\n-                \"address\": multi_sig_script['address']\n+                \"address\": multisig.p2wsh_addr\n             },\n             \"timestamp\": \"now\"\n         }])\n         assert_equal(result[0]['success'], True)\n-        address_assert = self.nodes[1].getaddressinfo(multi_sig_script['address'])\n+        address_assert = self.nodes[1].getaddressinfo(multisig.p2sh_addr)\n         assert_equal(address_assert['solvable'], False)\n \n         # Same P2WSH multisig address as above, but now with witnessscript + private keys\n-        self.log.info(\"Should import a p2wsh with respective redeem script and private keys\")\n+        self.log.info(\"Should import a p2wsh with respective witness script and private keys\")\n         result = self.nodes[1].importmulti([{\n             \"scriptPubKey\": {\n-                \"address\": multi_sig_script['address']\n+                \"address\": multisig.p2wsh_addr\n             },\n             \"timestamp\": \"now\",\n-            \"witnessscript\": multi_sig_script['redeemScript'],\n-            \"keys\": [self.nodes[0].dumpprivkey(sig_address_1['address']), self.nodes[0].dumpprivkey(sig_address_2['address'])]\n+            \"witnessscript\": multisig.redeem_script,\n+            \"keys\": multisig.privkeys\n         }])\n         assert_equal(result[0]['success'], True)\n-        address_assert = self.nodes[1].getaddressinfo(multi_sig_script['address'])\n+        address_assert = self.nodes[1].getaddressinfo(multisig.p2sh_addr)\n         assert_equal(address_assert['solvable'], True)\n         assert_equal(address_assert['ismine'], True)\n         assert_equal(address_assert['sigsrequired'], 2)\n@@ -642,22 +666,19 @@ def run_test(self):\n         assert_equal(address_assert['solvable'], True)\n         assert_equal(address_assert['ismine'], True)\n \n-        # P2SH-P2WSH 1-of-1 multisig + redeemscript with no private key\n-        sig_address_1 = self.nodes[0].getaddressinfo(self.nodes[0].getnewaddress())\n-        multi_sig_script = self.nodes[0].addmultisigaddress(1, [sig_address_1['pubkey']], \"\", \"p2sh-segwit\")\n-        scripthash = sha256(hex_str_to_bytes(multi_sig_script['redeemScript']))\n-        redeem_script = CScript([OP_0, scripthash])\n+        # P2SH-P2WSH multisig + redeemscript with no private key\n+        multisig = self.get_multisig()\n         self.log.info(\"Should import a p2sh-p2wsh with respective redeem script but no private key\")\n         result = self.nodes[1].importmulti([{\n             \"scriptPubKey\": {\n-                \"address\": multi_sig_script['address']\n+                \"address\": multisig.p2sh_p2wsh_addr\n             },\n             \"timestamp\": \"now\",\n-            \"redeemscript\": bytes_to_hex_str(redeem_script),\n-            \"witnessscript\": multi_sig_script['redeemScript']\n+            \"redeemscript\": multisig.p2wsh_script,\n+            \"witnessscript\": multisig.redeem_script,\n         }])\n         assert_equal(result[0]['success'], True)\n-        address_assert = self.nodes[1].getaddressinfo(multi_sig_script['address'])\n+        address_assert = self.nodes[1].getaddressinfo(multisig.p2sh_addr)\n         assert_equal(address_assert['solvable'], True)\n \n if __name__ == '__main__':"
      }
    ]
  },
  {
    "sha": "fd3a02c381ee136e54579b5a2e3466c016101515",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmZDNhMDJjMzgxZWUxMzZlNTQ1NzliNWEyZTM0NjZjMDE2MTAxNTE1",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-12-06T14:52:38Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-12-10T20:19:08Z"
      },
      "message": "[tests] add test_importmulti method to wallet_import.py\n\nAdds a new test_importmulti method for testing the\nimportmulti RPC method.",
      "tree": {
        "sha": "08e1d02d8a3fdcd7927fb71841de805bc60b83be",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/08e1d02d8a3fdcd7927fb71841de805bc60b83be"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fd3a02c381ee136e54579b5a2e3466c016101515",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fd3a02c381ee136e54579b5a2e3466c016101515",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fd3a02c381ee136e54579b5a2e3466c016101515",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fd3a02c381ee136e54579b5a2e3466c016101515/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "08a4a0f70f545e114bc35dc76056282cb04bf013",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/08a4a0f70f545e114bc35dc76056282cb04bf013",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/08a4a0f70f545e114bc35dc76056282cb04bf013"
      }
    ],
    "stats": {
      "total": 425,
      "additions": 162,
      "deletions": 263
    },
    "files": [
      {
        "sha": "d5ff1d2f25786fc9deb5d79d19df8be796a08c71",
        "filename": "test/functional/wallet_importmulti.py",
        "status": "modified",
        "additions": 162,
        "deletions": 263,
        "changes": 425,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fd3a02c381ee136e54579b5a2e3466c016101515/test/functional/wallet_importmulti.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fd3a02c381ee136e54579b5a2e3466c016101515/test/functional/wallet_importmulti.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_importmulti.py?ref=fd3a02c381ee136e54579b5a2e3466c016101515",
        "patch": "@@ -108,6 +108,14 @@ def get_multisig(self):\n                         CScript([OP_HASH160, witness_script, OP_EQUAL]).hex(),  # p2sh-p2wsh\n                         script_to_p2sh_p2wsh(script_code))  # p2sh-p2wsh addr\n \n+    def test_importmulti(self, req, success, error_code=None, error_message=None):\n+        \"\"\"Run importmulti and assert success\"\"\"\n+        result = self.nodes[1].importmulti([req])\n+        assert_equal(result[0]['success'], success)\n+        if error_code is not None:\n+            assert_equal(result[0]['error']['code'], error_code)\n+            assert_equal(result[0]['error']['message'], error_message)\n+\n     def run_test(self):\n         self.log.info(\"Mining blocks...\")\n         self.nodes[0].generate(1)\n@@ -133,13 +141,9 @@ def run_test(self):\n         self.log.info(\"Should import an address\")\n         key = self.get_key()\n         address = key.p2pkh_addr\n-        result = self.nodes[1].importmulti([{\n-            \"scriptPubKey\": {\n-                \"address\": address\n-            },\n-            \"timestamp\": \"now\",\n-        }])\n-        assert_equal(result[0]['success'], True)\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": address},\n+                               \"timestamp\": \"now\"},\n+                              True)\n         address_assert = self.nodes[1].getaddressinfo(address)\n         assert_equal(address_assert['iswatchonly'], True)\n         assert_equal(address_assert['ismine'], False)\n@@ -149,25 +153,19 @@ def run_test(self):\n         watchonly_timestamp = timestamp\n \n         self.log.info(\"Should not import an invalid address\")\n-        result = self.nodes[1].importmulti([{\n-            \"scriptPubKey\": {\n-                \"address\": \"not valid address\",\n-            },\n-            \"timestamp\": \"now\",\n-        }])\n-        assert_equal(result[0]['success'], False)\n-        assert_equal(result[0]['error']['code'], -5)\n-        assert_equal(result[0]['error']['message'], 'Invalid address')\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": \"not valid address\"},\n+                               \"timestamp\": \"now\"},\n+                              False,\n+                              error_code=-5,\n+                              error_message='Invalid address')\n \n         # ScriptPubKey + internal\n         self.log.info(\"Should import a scriptPubKey with internal flag\")\n         key = self.get_key()\n-        result = self.nodes[1].importmulti([{\n-            \"scriptPubKey\": key.p2pkh_script,\n-            \"timestamp\": \"now\",\n-            \"internal\": True\n-        }])\n-        assert_equal(result[0]['success'], True)\n+        self.test_importmulti({\"scriptPubKey\": key.p2pkh_script,\n+                               \"timestamp\": \"now\",\n+                               \"internal\": True},\n+                              True)\n         address_assert = self.nodes[1].getaddressinfo(key.p2pkh_addr)\n         assert_equal(address_assert['iswatchonly'], True)\n         assert_equal(address_assert['ismine'], False)\n@@ -177,28 +175,24 @@ def run_test(self):\n         # ScriptPubKey + internal + label\n         self.log.info(\"Should not allow a label to be specified when internal is true\")\n         key = self.get_key()\n-        result = self.nodes[1].importmulti([{\n-            \"scriptPubKey\": key.p2pkh_script,\n-            \"timestamp\": \"now\",\n-            \"internal\": True,\n-            \"label\": \"Example label\"\n-        }])\n-        assert_equal(result[0]['success'], False)\n-        assert_equal(result[0]['error']['code'], -8)\n-        assert_equal(result[0]['error']['message'], 'Internal addresses should not have a label')\n+        self.test_importmulti({\"scriptPubKey\": key.p2pkh_script,\n+                               \"timestamp\": \"now\",\n+                               \"internal\": True,\n+                               \"label\": \"Example label\"},\n+                              False,\n+                              error_code=-8,\n+                              error_message='Internal addresses should not have a label')\n \n         # Nonstandard scriptPubKey + !internal\n         self.log.info(\"Should not import a nonstandard scriptPubKey without internal flag\")\n         nonstandardScriptPubKey = key.p2pkh_script + bytes_to_hex_str(CScript([OP_NOP]))\n         key = self.get_key()\n         address = key.p2pkh_addr\n-        result = self.nodes[1].importmulti([{\n-            \"scriptPubKey\": nonstandardScriptPubKey,\n-            \"timestamp\": \"now\",\n-        }])\n-        assert_equal(result[0]['success'], False)\n-        assert_equal(result[0]['error']['code'], -8)\n-        assert_equal(result[0]['error']['message'], 'Internal must be set to true for nonstandard scriptPubKey imports.')\n+        self.test_importmulti({\"scriptPubKey\": nonstandardScriptPubKey,\n+                               \"timestamp\": \"now\"},\n+                              False,\n+                              error_code=-8,\n+                              error_message='Internal must be set to true for nonstandard scriptPubKey imports.')\n         address_assert = self.nodes[1].getaddressinfo(address)\n         assert_equal(address_assert['iswatchonly'], False)\n         assert_equal(address_assert['ismine'], False)\n@@ -208,15 +202,11 @@ def run_test(self):\n         self.log.info(\"Should import an address with public key\")\n         key = self.get_key()\n         address = key.p2pkh_addr\n-        result = self.nodes[1].importmulti([{\n-            \"scriptPubKey\": {\n-                \"address\": address\n-            },\n-            \"timestamp\": \"now\",\n-            \"pubkeys\": [key.pubkey],\n-            \"internal\": False\n-        }])\n-        assert_equal(result[0]['success'], True)\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": address},\n+                               \"timestamp\": \"now\",\n+                               \"pubkeys\": [key.pubkey],\n+                               \"internal\": False},\n+                              True)\n         address_assert = self.nodes[1].getaddressinfo(address)\n         assert_equal(address_assert['iswatchonly'], True)\n         assert_equal(address_assert['ismine'], False)\n@@ -226,14 +216,11 @@ def run_test(self):\n         self.log.info(\"Should import a scriptPubKey with internal and with public key\")\n         key = self.get_key()\n         address = key.p2pkh_addr\n-        request = [{\n-            \"scriptPubKey\": key.p2pkh_script,\n-            \"timestamp\": \"now\",\n-            \"pubkeys\": [key.pubkey],\n-            \"internal\": True\n-        }]\n-        result = self.nodes[1].importmulti(requests=request)\n-        assert_equal(result[0]['success'], True)\n+        self.test_importmulti({\"scriptPubKey\": key.p2pkh_script,\n+                               \"timestamp\": \"now\",\n+                               \"pubkeys\": [key.pubkey],\n+                               \"internal\": True},\n+                              True)\n         address_assert = self.nodes[1].getaddressinfo(address)\n         assert_equal(address_assert['iswatchonly'], True)\n         assert_equal(address_assert['ismine'], False)\n@@ -243,15 +230,12 @@ def run_test(self):\n         self.log.info(\"Should not import a nonstandard scriptPubKey without internal and with public key\")\n         key = self.get_key()\n         address = key.p2pkh_addr\n-        request = [{\n-            \"scriptPubKey\": nonstandardScriptPubKey,\n-            \"timestamp\": \"now\",\n-            \"pubkeys\": [key.pubkey]\n-        }]\n-        result = self.nodes[1].importmulti(requests=request)\n-        assert_equal(result[0]['success'], False)\n-        assert_equal(result[0]['error']['code'], -8)\n-        assert_equal(result[0]['error']['message'], 'Internal must be set to true for nonstandard scriptPubKey imports.')\n+        self.test_importmulti({\"scriptPubKey\": nonstandardScriptPubKey,\n+                               \"timestamp\": \"now\",\n+                               \"pubkeys\": [key.pubkey]},\n+                              False,\n+                              error_code=-8,\n+                              error_message='Internal must be set to true for nonstandard scriptPubKey imports.')\n         address_assert = self.nodes[1].getaddressinfo(address)\n         assert_equal(address_assert['iswatchonly'], False)\n         assert_equal(address_assert['ismine'], False)\n@@ -261,46 +245,34 @@ def run_test(self):\n         self.log.info(\"Should import an address with private key\")\n         key = self.get_key()\n         address = key.p2pkh_addr\n-        result = self.nodes[1].importmulti([{\n-            \"scriptPubKey\": {\n-                \"address\": address\n-            },\n-            \"timestamp\": \"now\",\n-            \"keys\": [key.privkey]\n-        }])\n-        assert_equal(result[0]['success'], True)\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": address},\n+                               \"timestamp\": \"now\",\n+                               \"keys\": [key.privkey]},\n+                              True)\n         address_assert = self.nodes[1].getaddressinfo(address)\n         assert_equal(address_assert['iswatchonly'], False)\n         assert_equal(address_assert['ismine'], True)\n         assert_equal(address_assert['timestamp'], timestamp)\n \n         self.log.info(\"Should not import an address with private key if is already imported\")\n-        result = self.nodes[1].importmulti([{\n-            \"scriptPubKey\": {\n-                \"address\": address\n-            },\n-            \"timestamp\": \"now\",\n-            \"keys\": [key.privkey]\n-        }])\n-        assert_equal(result[0]['success'], False)\n-        assert_equal(result[0]['error']['code'], -4)\n-        assert_equal(result[0]['error']['message'], 'The wallet already contains the private key for this address or script')\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": address},\n+                               \"timestamp\": \"now\",\n+                               \"keys\": [key.privkey]},\n+                              False,\n+                              error_code=-4,\n+                              error_message='The wallet already contains the private key for this address or script')\n \n         # Address + Private key + watchonly\n         self.log.info(\"Should not import an address with private key and with watchonly\")\n         key = self.get_key()\n         address = key.p2pkh_addr\n-        result = self.nodes[1].importmulti([{\n-            \"scriptPubKey\": {\n-                \"address\": address\n-            },\n-            \"timestamp\": \"now\",\n-            \"keys\": [key.privkey],\n-            \"watchonly\": True\n-        }])\n-        assert_equal(result[0]['success'], False)\n-        assert_equal(result[0]['error']['code'], -8)\n-        assert_equal(result[0]['error']['message'], 'Watch-only addresses should not include private keys')\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": address},\n+                               \"timestamp\": \"now\",\n+                               \"keys\": [key.privkey],\n+                               \"watchonly\": True},\n+                              False,\n+                              error_code=-8,\n+                              error_message='Watch-only addresses should not include private keys')\n         address_assert = self.nodes[1].getaddressinfo(address)\n         assert_equal(address_assert['iswatchonly'], False)\n         assert_equal(address_assert['ismine'], False)\n@@ -310,13 +282,11 @@ def run_test(self):\n         self.log.info(\"Should import a scriptPubKey with internal and with private key\")\n         key = self.get_key()\n         address = key.p2pkh_addr\n-        result = self.nodes[1].importmulti([{\n-            \"scriptPubKey\": key.p2pkh_script,\n-            \"timestamp\": \"now\",\n-            \"keys\": [key.privkey],\n-            \"internal\": True\n-        }])\n-        assert_equal(result[0]['success'], True)\n+        self.test_importmulti({\"scriptPubKey\": key.p2pkh_script,\n+                               \"timestamp\": \"now\",\n+                               \"keys\": [key.privkey],\n+                               \"internal\": True},\n+                              True)\n         address_assert = self.nodes[1].getaddressinfo(address)\n         assert_equal(address_assert['iswatchonly'], False)\n         assert_equal(address_assert['ismine'], True)\n@@ -326,14 +296,12 @@ def run_test(self):\n         self.log.info(\"Should not import a nonstandard scriptPubKey without internal and with private key\")\n         key = self.get_key()\n         address = key.p2pkh_addr\n-        result = self.nodes[1].importmulti([{\n-            \"scriptPubKey\": nonstandardScriptPubKey,\n-            \"timestamp\": \"now\",\n-            \"keys\": [key.privkey]\n-        }])\n-        assert_equal(result[0]['success'], False)\n-        assert_equal(result[0]['error']['code'], -8)\n-        assert_equal(result[0]['error']['message'], 'Internal must be set to true for nonstandard scriptPubKey imports.')\n+        self.test_importmulti({\"scriptPubKey\": nonstandardScriptPubKey,\n+                               \"timestamp\": \"now\",\n+                               \"keys\": [key.privkey]},\n+                              False,\n+                              error_code=-8,\n+                              error_message='Internal must be set to true for nonstandard scriptPubKey imports.')\n         address_assert = self.nodes[1].getaddressinfo(address)\n         assert_equal(address_assert['iswatchonly'], False)\n         assert_equal(address_assert['ismine'], False)\n@@ -347,13 +315,9 @@ def run_test(self):\n         timestamp = self.nodes[1].getblock(self.nodes[1].getbestblockhash())['mediantime']\n \n         self.log.info(\"Should import a p2sh\")\n-        result = self.nodes[1].importmulti([{\n-            \"scriptPubKey\": {\n-                \"address\": multisig.p2sh_addr\n-            },\n-            \"timestamp\": \"now\",\n-        }])\n-        assert_equal(result[0]['success'], True)\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": multisig.p2sh_addr},\n+                               \"timestamp\": \"now\"},\n+                              True)\n         address_assert = self.nodes[1].getaddressinfo(multisig.p2sh_addr)\n         assert_equal(address_assert['isscript'], True)\n         assert_equal(address_assert['iswatchonly'], True)\n@@ -370,14 +334,10 @@ def run_test(self):\n         timestamp = self.nodes[1].getblock(self.nodes[1].getbestblockhash())['mediantime']\n \n         self.log.info(\"Should import a p2sh with respective redeem script\")\n-        result = self.nodes[1].importmulti([{\n-            \"scriptPubKey\": {\n-                \"address\": multisig.p2sh_addr\n-            },\n-            \"timestamp\": \"now\",\n-            \"redeemscript\": multisig.redeem_script\n-        }])\n-        assert_equal(result[0]['success'], True)\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": multisig.p2sh_addr},\n+                               \"timestamp\": \"now\",\n+                               \"redeemscript\": multisig.redeem_script},\n+                              True)\n         address_assert = self.nodes[1].getaddressinfo(multisig.p2sh_addr)\n         assert_equal(address_assert['timestamp'], timestamp)\n \n@@ -393,15 +353,11 @@ def run_test(self):\n         timestamp = self.nodes[1].getblock(self.nodes[1].getbestblockhash())['mediantime']\n \n         self.log.info(\"Should import a p2sh with respective redeem script and private keys\")\n-        result = self.nodes[1].importmulti([{\n-            \"scriptPubKey\": {\n-                \"address\": multisig.p2sh_addr\n-            },\n-            \"timestamp\": \"now\",\n-            \"redeemscript\": multisig.redeem_script,\n-            \"keys\": multisig.privkeys[0:2]\n-        }])\n-        assert_equal(result[0]['success'], True)\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": multisig.p2sh_addr},\n+                               \"timestamp\": \"now\",\n+                               \"redeemscript\": multisig.redeem_script,\n+                               \"keys\": multisig.privkeys[0:2]},\n+                              True)\n         address_assert = self.nodes[1].getaddressinfo(multisig.p2sh_addr)\n         assert_equal(address_assert['timestamp'], timestamp)\n \n@@ -417,34 +373,26 @@ def run_test(self):\n         timestamp = self.nodes[1].getblock(self.nodes[1].getbestblockhash())['mediantime']\n \n         self.log.info(\"Should import a p2sh with respective redeem script and private keys\")\n-        result = self.nodes[1].importmulti([{\n-            \"scriptPubKey\": {\n-                \"address\": multisig.p2sh_addr\n-            },\n-            \"timestamp\": \"now\",\n-            \"redeemscript\": multisig.redeem_script,\n-            \"keys\": multisig.privkeys[0:2],\n-            \"watchonly\": True\n-        }])\n-        assert_equal(result[0]['success'], False)\n-        assert_equal(result[0]['error']['code'], -8)\n-        assert_equal(result[0]['error']['message'], 'Watch-only addresses should not include private keys')\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": multisig.p2sh_addr},\n+                               \"timestamp\": \"now\",\n+                               \"redeemscript\": multisig.redeem_script,\n+                               \"keys\": multisig.privkeys[0:2],\n+                               \"watchonly\": True},\n+                              False,\n+                              error_code=-8,\n+                              error_message='Watch-only addresses should not include private keys')\n \n         # Address + Public key + !Internal + Wrong pubkey\n         self.log.info(\"Should not import an address with a wrong public key\")\n         key = self.get_key()\n         address = key.p2pkh_addr\n         wrong_key = self.get_key().pubkey\n-        result = self.nodes[1].importmulti([{\n-            \"scriptPubKey\": {\n-                \"address\": address\n-            },\n-            \"timestamp\": \"now\",\n-            \"pubkeys\": [wrong_key]\n-        }])\n-        assert_equal(result[0]['success'], False)\n-        assert_equal(result[0]['error']['code'], -5)\n-        assert_equal(result[0]['error']['message'], 'Key does not match address destination')\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": address},\n+                               \"timestamp\": \"now\",\n+                               \"pubkeys\": [wrong_key]},\n+                              False,\n+                              error_code=-5,\n+                              error_message='Key does not match address destination')\n         address_assert = self.nodes[1].getaddressinfo(address)\n         assert_equal(address_assert['iswatchonly'], False)\n         assert_equal(address_assert['ismine'], False)\n@@ -455,16 +403,13 @@ def run_test(self):\n         key = self.get_key()\n         address = key.p2pkh_addr\n         wrong_key = self.get_key().pubkey\n-        request = [{\n-            \"scriptPubKey\": key.p2pkh_script,\n-            \"timestamp\": \"now\",\n-            \"pubkeys\": [wrong_key],\n-            \"internal\": True\n-        }]\n-        result = self.nodes[1].importmulti(request)\n-        assert_equal(result[0]['success'], False)\n-        assert_equal(result[0]['error']['code'], -5)\n-        assert_equal(result[0]['error']['message'], 'Key does not match address destination')\n+        self.test_importmulti({\"scriptPubKey\": key.p2pkh_script,\n+                               \"timestamp\": \"now\",\n+                               \"pubkeys\": [wrong_key],\n+                               \"internal\": True},\n+                              False,\n+                              error_code=-5,\n+                              error_message='Key does not match address destination')\n         address_assert = self.nodes[1].getaddressinfo(address)\n         assert_equal(address_assert['iswatchonly'], False)\n         assert_equal(address_assert['ismine'], False)\n@@ -475,16 +420,12 @@ def run_test(self):\n         key = self.get_key()\n         address = key.p2pkh_addr\n         wrong_privkey = self.get_key().privkey\n-        result = self.nodes[1].importmulti([{\n-            \"scriptPubKey\": {\n-                \"address\": address\n-            },\n-            \"timestamp\": \"now\",\n-            \"keys\": [wrong_privkey]\n-        }])\n-        assert_equal(result[0]['success'], False)\n-        assert_equal(result[0]['error']['code'], -5)\n-        assert_equal(result[0]['error']['message'], 'Key does not match address destination')\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": address},\n+                               \"timestamp\": \"now\",\n+                               \"keys\": [wrong_privkey]},\n+                              False,\n+                              error_code=-5,\n+                              error_message='Key does not match address destination')\n         address_assert = self.nodes[1].getaddressinfo(address)\n         assert_equal(address_assert['iswatchonly'], False)\n         assert_equal(address_assert['ismine'], False)\n@@ -495,15 +436,13 @@ def run_test(self):\n         key = self.get_key()\n         address = key.p2pkh_addr\n         wrong_privkey = self.get_key().privkey\n-        result = self.nodes[1].importmulti([{\n-            \"scriptPubKey\": key.p2pkh_script,\n-            \"timestamp\": \"now\",\n-            \"keys\": [wrong_privkey],\n-            \"internal\": True\n-        }])\n-        assert_equal(result[0]['success'], False)\n-        assert_equal(result[0]['error']['code'], -5)\n-        assert_equal(result[0]['error']['message'], 'Key does not match address destination')\n+        self.test_importmulti({\"scriptPubKey\": key.p2pkh_script,\n+                               \"timestamp\": \"now\",\n+                               \"keys\": [wrong_privkey],\n+                               \"internal\": True},\n+                              False,\n+                              error_code=-5,\n+                              error_message='Key does not match address destination')\n         address_assert = self.nodes[1].getaddressinfo(address)\n         assert_equal(address_assert['iswatchonly'], False)\n         assert_equal(address_assert['ismine'], False)\n@@ -512,13 +451,9 @@ def run_test(self):\n         # Importing existing watch only address with new timestamp should replace saved timestamp.\n         assert_greater_than(timestamp, watchonly_timestamp)\n         self.log.info(\"Should replace previously saved watch only timestamp.\")\n-        result = self.nodes[1].importmulti([{\n-            \"scriptPubKey\": {\n-                \"address\": watchonly_address,\n-            },\n-            \"timestamp\": \"now\",\n-        }])\n-        assert_equal(result[0]['success'], True)\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": watchonly_address},\n+                               \"timestamp\": \"now\"},\n+                              True)\n         address_assert = self.nodes[1].getaddressinfo(watchonly_address)\n         assert_equal(address_assert['iswatchonly'], True)\n         assert_equal(address_assert['ismine'], False)\n@@ -547,13 +482,9 @@ def run_test(self):\n         self.log.info(\"Should import a P2WPKH address as watch only\")\n         key = self.get_key()\n         address = key.p2wpkh_addr\n-        result = self.nodes[1].importmulti([{\n-            \"scriptPubKey\": {\n-                \"address\": address\n-            },\n-            \"timestamp\": \"now\",\n-        }])\n-        assert_equal(result[0]['success'], True)\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": address},\n+                               \"timestamp\": \"now\"},\n+                              True)\n         address_assert = self.nodes[1].getaddressinfo(address)\n         assert_equal(address_assert['iswatchonly'], True)\n         assert_equal(address_assert['solvable'], False)\n@@ -562,14 +493,10 @@ def run_test(self):\n         self.log.info(\"Should import a P2WPKH address and public key as solvable but not spendable\")\n         key = self.get_key()\n         address = key.p2wpkh_addr\n-        result = self.nodes[1].importmulti([{\n-            \"scriptPubKey\": {\n-                \"address\": address\n-            },\n-            \"timestamp\": \"now\",\n-            \"pubkeys\": [key.pubkey]\n-        }])\n-        assert_equal(result[0]['success'], True)\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": address},\n+                               \"timestamp\": \"now\",\n+                               \"pubkeys\": [key.pubkey]},\n+                              True)\n         address_assert = self.nodes[1].getaddressinfo(address)\n         assert_equal(address_assert['ismine'], False)\n         assert_equal(address_assert['solvable'], True)\n@@ -578,42 +505,30 @@ def run_test(self):\n         self.log.info(\"Should import a P2WPKH address with key\")\n         key = self.get_key()\n         address = key.p2wpkh_addr\n-        result = self.nodes[1].importmulti([{\n-            \"scriptPubKey\": {\n-                \"address\": address\n-            },\n-            \"timestamp\": \"now\",\n-            \"keys\": [key.privkey]\n-        }])\n-        assert_equal(result[0]['success'], True)\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": address},\n+                               \"timestamp\": \"now\",\n+                               \"keys\": [key.privkey]},\n+                              True)\n         address_assert = self.nodes[1].getaddressinfo(address)\n         assert_equal(address_assert['iswatchonly'], False)\n         assert_equal(address_assert['ismine'], True)\n \n         # P2WSH multisig address without scripts or keys\n         multisig = self.get_multisig()\n         self.log.info(\"Should import a p2wsh multisig as watch only without respective redeem script and private keys\")\n-        result = self.nodes[1].importmulti([{\n-            \"scriptPubKey\": {\n-                \"address\": multisig.p2wsh_addr\n-            },\n-            \"timestamp\": \"now\"\n-        }])\n-        assert_equal(result[0]['success'], True)\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": multisig.p2wsh_addr},\n+                               \"timestamp\": \"now\"},\n+                              True)\n         address_assert = self.nodes[1].getaddressinfo(multisig.p2sh_addr)\n         assert_equal(address_assert['solvable'], False)\n \n         # Same P2WSH multisig address as above, but now with witnessscript + private keys\n         self.log.info(\"Should import a p2wsh with respective witness script and private keys\")\n-        result = self.nodes[1].importmulti([{\n-            \"scriptPubKey\": {\n-                \"address\": multisig.p2wsh_addr\n-            },\n-            \"timestamp\": \"now\",\n-            \"witnessscript\": multisig.redeem_script,\n-            \"keys\": multisig.privkeys\n-        }])\n-        assert_equal(result[0]['success'], True)\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": multisig.p2wsh_addr},\n+                               \"timestamp\": \"now\",\n+                               \"witnessscript\": multisig.redeem_script,\n+                               \"keys\": multisig.privkeys},\n+                              True)\n         address_assert = self.nodes[1].getaddressinfo(multisig.p2sh_addr)\n         assert_equal(address_assert['solvable'], True)\n         assert_equal(address_assert['ismine'], True)\n@@ -623,28 +538,20 @@ def run_test(self):\n         key = self.get_key()\n         address = key.p2sh_p2wpkh_addr\n         self.log.info(\"Should import a p2sh-p2wpkh without redeem script or keys\")\n-        result = self.nodes[1].importmulti([{\n-            \"scriptPubKey\": {\n-                \"address\": address\n-            },\n-            \"timestamp\": \"now\"\n-        }])\n-        assert_equal(result[0]['success'], True)\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": address},\n+                               \"timestamp\": \"now\"},\n+                              True)\n         address_assert = self.nodes[1].getaddressinfo(address)\n         assert_equal(address_assert['solvable'], False)\n         assert_equal(address_assert['ismine'], False)\n \n         # P2SH-P2WPKH address + redeemscript + public key with no private key\n         self.log.info(\"Should import a p2sh-p2wpkh with respective redeem script and pubkey as solvable\")\n-        result = self.nodes[1].importmulti([{\n-            \"scriptPubKey\": {\n-                \"address\": address\n-            },\n-            \"timestamp\": \"now\",\n-            \"redeemscript\": key.p2sh_p2wpkh_redeem_script,\n-            \"pubkeys\": [key.pubkey]\n-        }])\n-        assert_equal(result[0]['success'], True)\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": address},\n+                               \"timestamp\": \"now\",\n+                               \"redeemscript\": key.p2sh_p2wpkh_redeem_script,\n+                               \"pubkeys\": [key.pubkey]},\n+                              True)\n         address_assert = self.nodes[1].getaddressinfo(address)\n         assert_equal(address_assert['solvable'], True)\n         assert_equal(address_assert['ismine'], False)\n@@ -653,31 +560,23 @@ def run_test(self):\n         key = self.get_key()\n         address = key.p2sh_p2wpkh_addr\n         self.log.info(\"Should import a p2sh-p2wpkh with respective redeem script and private keys\")\n-        result = self.nodes[1].importmulti([{\n-            \"scriptPubKey\": {\n-                \"address\": address\n-            },\n-            \"timestamp\": \"now\",\n-            \"redeemscript\": key.p2sh_p2wpkh_redeem_script,\n-            \"keys\": [key.privkey]\n-        }])\n-        assert_equal(result[0]['success'], True)\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": address},\n+                               \"timestamp\": \"now\",\n+                               \"redeemscript\": key.p2sh_p2wpkh_redeem_script,\n+                               \"keys\": [key.privkey]},\n+                              True)\n         address_assert = self.nodes[1].getaddressinfo(address)\n         assert_equal(address_assert['solvable'], True)\n         assert_equal(address_assert['ismine'], True)\n \n         # P2SH-P2WSH multisig + redeemscript with no private key\n         multisig = self.get_multisig()\n         self.log.info(\"Should import a p2sh-p2wsh with respective redeem script but no private key\")\n-        result = self.nodes[1].importmulti([{\n-            \"scriptPubKey\": {\n-                \"address\": multisig.p2sh_p2wsh_addr\n-            },\n-            \"timestamp\": \"now\",\n-            \"redeemscript\": multisig.p2wsh_script,\n-            \"witnessscript\": multisig.redeem_script,\n-        }])\n-        assert_equal(result[0]['success'], True)\n+        self.test_importmulti({\"scriptPubKey\": {\"address\": multisig.p2sh_p2wsh_addr},\n+                               \"timestamp\": \"now\",\n+                               \"redeemscript\": multisig.p2wsh_script,\n+                               \"witnessscript\": multisig.redeem_script},\n+                              True)\n         address_assert = self.nodes[1].getaddressinfo(multisig.p2sh_addr)\n         assert_equal(address_assert['solvable'], True)\n "
      }
    ]
  },
  {
    "sha": "fbdba40594d549c76aaf15401fe994ac5cfc4f73",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYmRiYTQwNTk0ZDU0OWM3NmFhZjE1NDAxZmU5OTRhYzVjZmM0Zjcz",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-12-06T15:20:11Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-12-10T20:35:36Z"
      },
      "message": "[tests] add test_address method to wallet_import.py\n\nAdds a new test_address method for testing the\nimported addresses.",
      "tree": {
        "sha": "c8a1e165697b0a9a3c54e324859c84bd93b7ac14",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c8a1e165697b0a9a3c54e324859c84bd93b7ac14"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fbdba40594d549c76aaf15401fe994ac5cfc4f73",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fbdba40594d549c76aaf15401fe994ac5cfc4f73",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fbdba40594d549c76aaf15401fe994ac5cfc4f73",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fbdba40594d549c76aaf15401fe994ac5cfc4f73/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fd3a02c381ee136e54579b5a2e3466c016101515",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fd3a02c381ee136e54579b5a2e3466c016101515",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fd3a02c381ee136e54579b5a2e3466c016101515"
      }
    ],
    "stats": {
      "total": 209,
      "additions": 109,
      "deletions": 100
    },
    "files": [
      {
        "sha": "cb44cddf832dc9edd1509c7f2caa72dd0fd66494",
        "filename": "test/functional/wallet_importmulti.py",
        "status": "modified",
        "additions": 109,
        "deletions": 100,
        "changes": 209,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fbdba40594d549c76aaf15401fe994ac5cfc4f73/test/functional/wallet_importmulti.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fbdba40594d549c76aaf15401fe994ac5cfc4f73/test/functional/wallet_importmulti.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_importmulti.py?ref=fbdba40594d549c76aaf15401fe994ac5cfc4f73",
        "patch": "@@ -116,6 +116,16 @@ def test_importmulti(self, req, success, error_code=None, error_message=None):\n             assert_equal(result[0]['error']['code'], error_code)\n             assert_equal(result[0]['error']['message'], error_message)\n \n+    def test_address(self, address, **kwargs):\n+        \"\"\"Get address info for `address` and test whether the returned values are as expected.\"\"\"\n+        addr_info = self.nodes[1].getaddressinfo(address)\n+        for key, value in kwargs.items():\n+            if value is None:\n+                if key in addr_info.keys():\n+                    raise AssertionError(\"key {} unexpectedly returned in getaddressinfo.\".format(key))\n+            elif addr_info[key] != value:\n+                raise AssertionError(\"key {} value {} did not match expected value {}\".format(key, addr_info[key], value))\n+\n     def run_test(self):\n         self.log.info(\"Mining blocks...\")\n         self.nodes[0].generate(1)\n@@ -144,11 +154,11 @@ def run_test(self):\n         self.test_importmulti({\"scriptPubKey\": {\"address\": address},\n                                \"timestamp\": \"now\"},\n                               True)\n-        address_assert = self.nodes[1].getaddressinfo(address)\n-        assert_equal(address_assert['iswatchonly'], True)\n-        assert_equal(address_assert['ismine'], False)\n-        assert_equal(address_assert['timestamp'], timestamp)\n-        assert_equal(address_assert['ischange'], False)\n+        self.test_address(address,\n+                          iswatchonly=True,\n+                          ismine=False,\n+                          timestamp=timestamp,\n+                          ischange=False)\n         watchonly_address = address\n         watchonly_timestamp = timestamp\n \n@@ -166,11 +176,11 @@ def run_test(self):\n                                \"timestamp\": \"now\",\n                                \"internal\": True},\n                               True)\n-        address_assert = self.nodes[1].getaddressinfo(key.p2pkh_addr)\n-        assert_equal(address_assert['iswatchonly'], True)\n-        assert_equal(address_assert['ismine'], False)\n-        assert_equal(address_assert['timestamp'], timestamp)\n-        assert_equal(address_assert['ischange'], True)\n+        self.test_address(key.p2pkh_addr,\n+                          iswatchonly=True,\n+                          ismine=False,\n+                          timestamp=timestamp,\n+                          ischange=True)\n \n         # ScriptPubKey + internal + label\n         self.log.info(\"Should not allow a label to be specified when internal is true\")\n@@ -193,10 +203,10 @@ def run_test(self):\n                               False,\n                               error_code=-8,\n                               error_message='Internal must be set to true for nonstandard scriptPubKey imports.')\n-        address_assert = self.nodes[1].getaddressinfo(address)\n-        assert_equal(address_assert['iswatchonly'], False)\n-        assert_equal(address_assert['ismine'], False)\n-        assert_equal('timestamp' in address_assert, False)\n+        self.test_address(address,\n+                          iswatchonly=False,\n+                          ismine=False,\n+                          timestamp=None)\n \n         # Address + Public key + !Internal(explicit)\n         self.log.info(\"Should import an address with public key\")\n@@ -207,10 +217,10 @@ def run_test(self):\n                                \"pubkeys\": [key.pubkey],\n                                \"internal\": False},\n                               True)\n-        address_assert = self.nodes[1].getaddressinfo(address)\n-        assert_equal(address_assert['iswatchonly'], True)\n-        assert_equal(address_assert['ismine'], False)\n-        assert_equal(address_assert['timestamp'], timestamp)\n+        self.test_address(address,\n+                          iswatchonly=True,\n+                          ismine=False,\n+                          timestamp=timestamp)\n \n         # ScriptPubKey + Public key + internal\n         self.log.info(\"Should import a scriptPubKey with internal and with public key\")\n@@ -221,10 +231,10 @@ def run_test(self):\n                                \"pubkeys\": [key.pubkey],\n                                \"internal\": True},\n                               True)\n-        address_assert = self.nodes[1].getaddressinfo(address)\n-        assert_equal(address_assert['iswatchonly'], True)\n-        assert_equal(address_assert['ismine'], False)\n-        assert_equal(address_assert['timestamp'], timestamp)\n+        self.test_address(address,\n+                          iswatchonly=True,\n+                          ismine=False,\n+                          timestamp=timestamp)\n \n         # Nonstandard scriptPubKey + Public key + !internal\n         self.log.info(\"Should not import a nonstandard scriptPubKey without internal and with public key\")\n@@ -236,10 +246,10 @@ def run_test(self):\n                               False,\n                               error_code=-8,\n                               error_message='Internal must be set to true for nonstandard scriptPubKey imports.')\n-        address_assert = self.nodes[1].getaddressinfo(address)\n-        assert_equal(address_assert['iswatchonly'], False)\n-        assert_equal(address_assert['ismine'], False)\n-        assert_equal('timestamp' in address_assert, False)\n+        self.test_address(address,\n+                          iswatchonly=False,\n+                          ismine=False,\n+                          timestamp=None)\n \n         # Address + Private key + !watchonly\n         self.log.info(\"Should import an address with private key\")\n@@ -249,10 +259,10 @@ def run_test(self):\n                                \"timestamp\": \"now\",\n                                \"keys\": [key.privkey]},\n                               True)\n-        address_assert = self.nodes[1].getaddressinfo(address)\n-        assert_equal(address_assert['iswatchonly'], False)\n-        assert_equal(address_assert['ismine'], True)\n-        assert_equal(address_assert['timestamp'], timestamp)\n+        self.test_address(address,\n+                          iswatchonly=False,\n+                          ismine=True,\n+                          timestamp=timestamp)\n \n         self.log.info(\"Should not import an address with private key if is already imported\")\n         self.test_importmulti({\"scriptPubKey\": {\"address\": address},\n@@ -273,10 +283,10 @@ def run_test(self):\n                               False,\n                               error_code=-8,\n                               error_message='Watch-only addresses should not include private keys')\n-        address_assert = self.nodes[1].getaddressinfo(address)\n-        assert_equal(address_assert['iswatchonly'], False)\n-        assert_equal(address_assert['ismine'], False)\n-        assert_equal('timestamp' in address_assert, False)\n+        self.test_address(address,\n+                          iswatchonly=False,\n+                          ismine=False,\n+                          timestamp=None)\n \n         # ScriptPubKey + Private key + internal\n         self.log.info(\"Should import a scriptPubKey with internal and with private key\")\n@@ -287,10 +297,10 @@ def run_test(self):\n                                \"keys\": [key.privkey],\n                                \"internal\": True},\n                               True)\n-        address_assert = self.nodes[1].getaddressinfo(address)\n-        assert_equal(address_assert['iswatchonly'], False)\n-        assert_equal(address_assert['ismine'], True)\n-        assert_equal(address_assert['timestamp'], timestamp)\n+        self.test_address(address,\n+                          iswatchonly=False,\n+                          ismine=True,\n+                          timestamp=timestamp)\n \n         # Nonstandard scriptPubKey + Private key + !internal\n         self.log.info(\"Should not import a nonstandard scriptPubKey without internal and with private key\")\n@@ -302,10 +312,10 @@ def run_test(self):\n                               False,\n                               error_code=-8,\n                               error_message='Internal must be set to true for nonstandard scriptPubKey imports.')\n-        address_assert = self.nodes[1].getaddressinfo(address)\n-        assert_equal(address_assert['iswatchonly'], False)\n-        assert_equal(address_assert['ismine'], False)\n-        assert_equal('timestamp' in address_assert, False)\n+        self.test_address(address,\n+                          iswatchonly=False,\n+                          ismine=False,\n+                          timestamp=None)\n \n         # P2SH address\n         multisig = self.get_multisig()\n@@ -318,10 +328,10 @@ def run_test(self):\n         self.test_importmulti({\"scriptPubKey\": {\"address\": multisig.p2sh_addr},\n                                \"timestamp\": \"now\"},\n                               True)\n-        address_assert = self.nodes[1].getaddressinfo(multisig.p2sh_addr)\n-        assert_equal(address_assert['isscript'], True)\n-        assert_equal(address_assert['iswatchonly'], True)\n-        assert_equal(address_assert['timestamp'], timestamp)\n+        self.test_address(multisig.p2sh_addr,\n+                          isscript=True,\n+                          iswatchonly=True,\n+                          timestamp=timestamp)\n         p2shunspent = self.nodes[1].listunspent(0, 999999, [multisig.p2sh_addr])[0]\n         assert_equal(p2shunspent['spendable'], False)\n         assert_equal(p2shunspent['solvable'], False)\n@@ -338,8 +348,7 @@ def run_test(self):\n                                \"timestamp\": \"now\",\n                                \"redeemscript\": multisig.redeem_script},\n                               True)\n-        address_assert = self.nodes[1].getaddressinfo(multisig.p2sh_addr)\n-        assert_equal(address_assert['timestamp'], timestamp)\n+        self.test_address(multisig.p2sh_addr, timestamp=timestamp)\n \n         p2shunspent = self.nodes[1].listunspent(0, 999999, [multisig.p2sh_addr])[0]\n         assert_equal(p2shunspent['spendable'], False)\n@@ -358,8 +367,8 @@ def run_test(self):\n                                \"redeemscript\": multisig.redeem_script,\n                                \"keys\": multisig.privkeys[0:2]},\n                               True)\n-        address_assert = self.nodes[1].getaddressinfo(multisig.p2sh_addr)\n-        assert_equal(address_assert['timestamp'], timestamp)\n+        self.test_address(multisig.p2sh_addr,\n+                          timestamp=timestamp)\n \n         p2shunspent = self.nodes[1].listunspent(0, 999999, [multisig.p2sh_addr])[0]\n         assert_equal(p2shunspent['spendable'], False)\n@@ -393,10 +402,10 @@ def run_test(self):\n                               False,\n                               error_code=-5,\n                               error_message='Key does not match address destination')\n-        address_assert = self.nodes[1].getaddressinfo(address)\n-        assert_equal(address_assert['iswatchonly'], False)\n-        assert_equal(address_assert['ismine'], False)\n-        assert_equal('timestamp' in address_assert, False)\n+        self.test_address(address,\n+                          iswatchonly=False,\n+                          ismine=False,\n+                          timestamp=None)\n \n         # ScriptPubKey + Public key + internal + Wrong pubkey\n         self.log.info(\"Should not import a scriptPubKey with internal and with a wrong public key\")\n@@ -410,10 +419,10 @@ def run_test(self):\n                               False,\n                               error_code=-5,\n                               error_message='Key does not match address destination')\n-        address_assert = self.nodes[1].getaddressinfo(address)\n-        assert_equal(address_assert['iswatchonly'], False)\n-        assert_equal(address_assert['ismine'], False)\n-        assert_equal('timestamp' in address_assert, False)\n+        self.test_address(address,\n+                          iswatchonly=False,\n+                          ismine=False,\n+                          timestamp=None)\n \n         # Address + Private key + !watchonly + Wrong private key\n         self.log.info(\"Should not import an address with a wrong private key\")\n@@ -426,10 +435,10 @@ def run_test(self):\n                               False,\n                               error_code=-5,\n                               error_message='Key does not match address destination')\n-        address_assert = self.nodes[1].getaddressinfo(address)\n-        assert_equal(address_assert['iswatchonly'], False)\n-        assert_equal(address_assert['ismine'], False)\n-        assert_equal('timestamp' in address_assert, False)\n+        self.test_address(address,\n+                          iswatchonly=False,\n+                          ismine=False,\n+                          timestamp=None)\n \n         # ScriptPubKey + Private key + internal + Wrong private key\n         self.log.info(\"Should not import a scriptPubKey with internal and with a wrong private key\")\n@@ -443,30 +452,30 @@ def run_test(self):\n                               False,\n                               error_code=-5,\n                               error_message='Key does not match address destination')\n-        address_assert = self.nodes[1].getaddressinfo(address)\n-        assert_equal(address_assert['iswatchonly'], False)\n-        assert_equal(address_assert['ismine'], False)\n-        assert_equal('timestamp' in address_assert, False)\n+        self.test_address(address,\n+                          iswatchonly=False,\n+                          ismine=False,\n+                          timestamp=None)\n \n         # Importing existing watch only address with new timestamp should replace saved timestamp.\n         assert_greater_than(timestamp, watchonly_timestamp)\n         self.log.info(\"Should replace previously saved watch only timestamp.\")\n         self.test_importmulti({\"scriptPubKey\": {\"address\": watchonly_address},\n                                \"timestamp\": \"now\"},\n                               True)\n-        address_assert = self.nodes[1].getaddressinfo(watchonly_address)\n-        assert_equal(address_assert['iswatchonly'], True)\n-        assert_equal(address_assert['ismine'], False)\n-        assert_equal(address_assert['timestamp'], timestamp)\n+        self.test_address(watchonly_address,\n+                          iswatchonly=True,\n+                          ismine=False,\n+                          timestamp=timestamp)\n         watchonly_timestamp = timestamp\n \n         # restart nodes to check for proper serialization/deserialization of watch only address\n         self.stop_nodes()\n         self.start_nodes()\n-        address_assert = self.nodes[1].getaddressinfo(watchonly_address)\n-        assert_equal(address_assert['iswatchonly'], True)\n-        assert_equal(address_assert['ismine'], False)\n-        assert_equal(address_assert['timestamp'], watchonly_timestamp)\n+        self.test_address(watchonly_address,\n+                          iswatchonly=True,\n+                          ismine=False,\n+                          timestamp=watchonly_timestamp)\n \n         # Bad or missing timestamps\n         self.log.info(\"Should throw on invalid or missing timestamp values\")\n@@ -485,9 +494,9 @@ def run_test(self):\n         self.test_importmulti({\"scriptPubKey\": {\"address\": address},\n                                \"timestamp\": \"now\"},\n                               True)\n-        address_assert = self.nodes[1].getaddressinfo(address)\n-        assert_equal(address_assert['iswatchonly'], True)\n-        assert_equal(address_assert['solvable'], False)\n+        self.test_address(address,\n+                          iswatchonly=True,\n+                          solvable=False)\n \n         # Import P2WPKH address with public key but no private key\n         self.log.info(\"Should import a P2WPKH address and public key as solvable but not spendable\")\n@@ -497,9 +506,9 @@ def run_test(self):\n                                \"timestamp\": \"now\",\n                                \"pubkeys\": [key.pubkey]},\n                               True)\n-        address_assert = self.nodes[1].getaddressinfo(address)\n-        assert_equal(address_assert['ismine'], False)\n-        assert_equal(address_assert['solvable'], True)\n+        self.test_address(address,\n+                          ismine=False,\n+                          solvable=True)\n \n         # Import P2WPKH address with key and check it is spendable\n         self.log.info(\"Should import a P2WPKH address with key\")\n@@ -509,18 +518,18 @@ def run_test(self):\n                                \"timestamp\": \"now\",\n                                \"keys\": [key.privkey]},\n                               True)\n-        address_assert = self.nodes[1].getaddressinfo(address)\n-        assert_equal(address_assert['iswatchonly'], False)\n-        assert_equal(address_assert['ismine'], True)\n+        self.test_address(address,\n+                          iswatchonly=False,\n+                          ismine=True)\n \n         # P2WSH multisig address without scripts or keys\n         multisig = self.get_multisig()\n         self.log.info(\"Should import a p2wsh multisig as watch only without respective redeem script and private keys\")\n         self.test_importmulti({\"scriptPubKey\": {\"address\": multisig.p2wsh_addr},\n                                \"timestamp\": \"now\"},\n                               True)\n-        address_assert = self.nodes[1].getaddressinfo(multisig.p2sh_addr)\n-        assert_equal(address_assert['solvable'], False)\n+        self.test_address(multisig.p2sh_addr,\n+                          solvable=False)\n \n         # Same P2WSH multisig address as above, but now with witnessscript + private keys\n         self.log.info(\"Should import a p2wsh with respective witness script and private keys\")\n@@ -529,10 +538,10 @@ def run_test(self):\n                                \"witnessscript\": multisig.redeem_script,\n                                \"keys\": multisig.privkeys},\n                               True)\n-        address_assert = self.nodes[1].getaddressinfo(multisig.p2sh_addr)\n-        assert_equal(address_assert['solvable'], True)\n-        assert_equal(address_assert['ismine'], True)\n-        assert_equal(address_assert['sigsrequired'], 2)\n+        self.test_address(multisig.p2sh_addr,\n+                          solvable=True,\n+                          ismine=True,\n+                          sigsrequired=2)\n \n         # P2SH-P2WPKH address with no redeemscript or public or private key\n         key = self.get_key()\n@@ -541,9 +550,9 @@ def run_test(self):\n         self.test_importmulti({\"scriptPubKey\": {\"address\": address},\n                                \"timestamp\": \"now\"},\n                               True)\n-        address_assert = self.nodes[1].getaddressinfo(address)\n-        assert_equal(address_assert['solvable'], False)\n-        assert_equal(address_assert['ismine'], False)\n+        self.test_address(address,\n+                          solvable=False,\n+                          ismine=False)\n \n         # P2SH-P2WPKH address + redeemscript + public key with no private key\n         self.log.info(\"Should import a p2sh-p2wpkh with respective redeem script and pubkey as solvable\")\n@@ -552,9 +561,9 @@ def run_test(self):\n                                \"redeemscript\": key.p2sh_p2wpkh_redeem_script,\n                                \"pubkeys\": [key.pubkey]},\n                               True)\n-        address_assert = self.nodes[1].getaddressinfo(address)\n-        assert_equal(address_assert['solvable'], True)\n-        assert_equal(address_assert['ismine'], False)\n+        self.test_address(address,\n+                          solvable=True,\n+                          ismine=False)\n \n         # P2SH-P2WPKH address + redeemscript + private key\n         key = self.get_key()\n@@ -565,9 +574,9 @@ def run_test(self):\n                                \"redeemscript\": key.p2sh_p2wpkh_redeem_script,\n                                \"keys\": [key.privkey]},\n                               True)\n-        address_assert = self.nodes[1].getaddressinfo(address)\n-        assert_equal(address_assert['solvable'], True)\n-        assert_equal(address_assert['ismine'], True)\n+        self.test_address(address,\n+                          solvable=True,\n+                          ismine=True)\n \n         # P2SH-P2WSH multisig + redeemscript with no private key\n         multisig = self.get_multisig()\n@@ -577,8 +586,8 @@ def run_test(self):\n                                \"redeemscript\": multisig.p2wsh_script,\n                                \"witnessscript\": multisig.redeem_script},\n                               True)\n-        address_assert = self.nodes[1].getaddressinfo(multisig.p2sh_addr)\n-        assert_equal(address_assert['solvable'], True)\n+        self.test_address(address,\n+                          solvable=True)\n \n if __name__ == '__main__':\n     ImportMultiTest().main()"
      }
    ]
  },
  {
    "sha": "ee3b21dccbeb0f9d4e99de869dbfaf625c159c7f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplZTNiMjFkY2NiZWIwZjlkNGU5OWRlODY5ZGJmYWY2MjVjMTU5Yzdm",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-12-06T18:29:32Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-12-10T20:35:38Z"
      },
      "message": "[tests] Add docstring for wallet_importmulti.py\n\nAdds a docstring describing the new importmulti test.",
      "tree": {
        "sha": "e45484726a1c783ec9ccee30f5449515b2690061",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e45484726a1c783ec9ccee30f5449515b2690061"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ee3b21dccbeb0f9d4e99de869dbfaf625c159c7f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ee3b21dccbeb0f9d4e99de869dbfaf625c159c7f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ee3b21dccbeb0f9d4e99de869dbfaf625c159c7f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ee3b21dccbeb0f9d4e99de869dbfaf625c159c7f/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fbdba40594d549c76aaf15401fe994ac5cfc4f73",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fbdba40594d549c76aaf15401fe994ac5cfc4f73",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fbdba40594d549c76aaf15401fe994ac5cfc4f73"
      }
    ],
    "stats": {
      "total": 13,
      "additions": 12,
      "deletions": 1
    },
    "files": [
      {
        "sha": "a163f7018c2f215d545164cdefad546402b41402",
        "filename": "test/functional/wallet_importmulti.py",
        "status": "modified",
        "additions": 12,
        "deletions": 1,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ee3b21dccbeb0f9d4e99de869dbfaf625c159c7f/test/functional/wallet_importmulti.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ee3b21dccbeb0f9d4e99de869dbfaf625c159c7f/test/functional/wallet_importmulti.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_importmulti.py?ref=ee3b21dccbeb0f9d4e99de869dbfaf625c159c7f",
        "patch": "@@ -2,7 +2,18 @@\n # Copyright (c) 2014-2018 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\"\"\"Test the importmulti RPC.\"\"\"\n+\"\"\"Test the importmulti RPC.\n+\n+Test importmulti by generating keys on node0, importing the scriptPubKeys and\n+addresses on node1 and then testing the address info for the different address\n+variants.\n+\n+- `get_key()` and `get_multisig()` are called to generate keys on node0 and\n+  return the privkeys, pubkeys and all variants of scriptPubKey and address.\n+- `test_importmulti()` is called to send an importmulti call to node1, test\n+  success, and (if unsuccessful) test the error code and error message returned.\n+- `test_address()` is called to call getaddressinfo for an address on node1\n+  and test the values returned.\"\"\"\n from collections import namedtuple\n \n from test_framework.address import ("
      }
    ]
  }
]