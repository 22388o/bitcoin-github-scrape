[
  {
    "sha": "e80c640d789d4e2ccb5e2b131502d51fed2c176a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplODBjNjQwZDc4OWQ0ZTJjY2I1ZTJiMTMxNTAyZDUxZmVkMmMxNzZh",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-11-30T18:29:38Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-04-02T17:45:58Z"
      },
      "message": "[tests] Remove bip9-softforks.py\n\nbip9-sofforks.py was intended to be a generic test for versionbits\ndeployments. However, it only tests CSV activation and was not updated\nto test segwit activation. CSV activation is tested by\nbip68-112-113-p2p.py, so this test is duplicated effort.\n\nRather than try to update it to use the BitcoinTestFramework, just\nremove it.",
      "tree": {
        "sha": "1e6a69956b1ab9535569cffef01f98636de5b6f4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1e6a69956b1ab9535569cffef01f98636de5b6f4"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e80c640d789d4e2ccb5e2b131502d51fed2c176a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e80c640d789d4e2ccb5e2b131502d51fed2c176a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e80c640d789d4e2ccb5e2b131502d51fed2c176a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e80c640d789d4e2ccb5e2b131502d51fed2c176a/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "18815b4bfb20c9c1112e547217662529d81e4393",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/18815b4bfb20c9c1112e547217662529d81e4393",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/18815b4bfb20c9c1112e547217662529d81e4393"
      }
    ],
    "stats": {
      "total": 284,
      "additions": 0,
      "deletions": 284
    },
    "files": [
      {
        "sha": "ac6176e976e377df783f2efdecfe8ba4ac388244",
        "filename": "test/functional/feature_bip9_softforks.py",
        "status": "removed",
        "additions": 0,
        "deletions": 283,
        "changes": 283,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/18815b4bfb20c9c1112e547217662529d81e4393/test/functional/feature_bip9_softforks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/18815b4bfb20c9c1112e547217662529d81e4393/test/functional/feature_bip9_softforks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_bip9_softforks.py?ref=18815b4bfb20c9c1112e547217662529d81e4393",
        "patch": "@@ -1,283 +0,0 @@\n-#!/usr/bin/env python3\n-# Copyright (c) 2015-2017 The Bitcoin Core developers\n-# Distributed under the MIT software license, see the accompanying\n-# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\"\"\"Test BIP 9 soft forks.\n-\n-Connect to a single node.\n-regtest lock-in with 108/144 block signalling\n-activation after a further 144 blocks\n-mine 2 block and save coinbases for later use\n-mine 141 blocks to transition from DEFINED to STARTED\n-mine 100 blocks signalling readiness and 44 not in order to fail to change state this period\n-mine 108 blocks signalling readiness and 36 blocks not signalling readiness (STARTED->LOCKED_IN)\n-mine a further 143 blocks (LOCKED_IN)\n-test that enforcement has not triggered (which triggers ACTIVE)\n-test that enforcement has triggered\n-\"\"\"\n-from io import BytesIO\n-import shutil\n-import time\n-import itertools\n-\n-from test_framework.test_framework import ComparisonTestFramework\n-from test_framework.util import *\n-from test_framework.mininode import CTransaction, network_thread_start\n-from test_framework.blocktools import create_coinbase, create_block\n-from test_framework.comptool import TestInstance, TestManager\n-from test_framework.script import CScript, OP_1NEGATE, OP_CHECKSEQUENCEVERIFY, OP_DROP\n-\n-class BIP9SoftForksTest(ComparisonTestFramework):\n-    def set_test_params(self):\n-        self.num_nodes = 1\n-        self.extra_args = [['-whitelist=127.0.0.1']]\n-        self.setup_clean_chain = True\n-\n-    def run_test(self):\n-        self.test = TestManager(self, self.options.tmpdir)\n-        self.test.add_all_connections(self.nodes)\n-        network_thread_start()\n-        self.test.run()\n-\n-    def create_transaction(self, node, coinbase, to_address, amount):\n-        from_txid = node.getblock(coinbase)['tx'][0]\n-        inputs = [{ \"txid\" : from_txid, \"vout\" : 0}]\n-        outputs = { to_address : amount }\n-        rawtx = node.createrawtransaction(inputs, outputs)\n-        tx = CTransaction()\n-        f = BytesIO(hex_str_to_bytes(rawtx))\n-        tx.deserialize(f)\n-        tx.nVersion = 2\n-        return tx\n-\n-    def sign_transaction(self, node, tx):\n-        signresult = node.signrawtransactionwithwallet(bytes_to_hex_str(tx.serialize()))\n-        tx = CTransaction()\n-        f = BytesIO(hex_str_to_bytes(signresult['hex']))\n-        tx.deserialize(f)\n-        return tx\n-\n-    def generate_blocks(self, number, version, test_blocks = []):\n-        for i in range(number):\n-            block = create_block(self.tip, create_coinbase(self.height), self.last_block_time + 1)\n-            block.nVersion = version\n-            block.rehash()\n-            block.solve()\n-            test_blocks.append([block, True])\n-            self.last_block_time += 1\n-            self.tip = block.sha256\n-            self.height += 1\n-        return test_blocks\n-\n-    def get_bip9_status(self, key):\n-        info = self.nodes[0].getblockchaininfo()\n-        return info['bip9_softforks'][key]\n-\n-    def test_BIP(self, bipName, activated_version, invalidate, invalidatePostSignature, bitno):\n-        assert_equal(self.get_bip9_status(bipName)['status'], 'defined')\n-        assert_equal(self.get_bip9_status(bipName)['since'], 0)\n-\n-        # generate some coins for later\n-        self.coinbase_blocks = self.nodes[0].generate(2)\n-        self.height = 3  # height of the next block to build\n-        self.tip = int(\"0x\" + self.nodes[0].getbestblockhash(), 0)\n-        self.nodeaddress = self.nodes[0].getnewaddress()\n-        self.last_block_time = int(time.time())\n-\n-        assert_equal(self.get_bip9_status(bipName)['status'], 'defined')\n-        assert_equal(self.get_bip9_status(bipName)['since'], 0)\n-        tmpl = self.nodes[0].getblocktemplate({})\n-        assert(bipName not in tmpl['rules'])\n-        assert(bipName not in tmpl['vbavailable'])\n-        assert_equal(tmpl['vbrequired'], 0)\n-        assert_equal(tmpl['version'], 0x20000000)\n-\n-        # Test 1\n-        # Advance from DEFINED to STARTED\n-        test_blocks = self.generate_blocks(141, 4)\n-        yield TestInstance(test_blocks, sync_every_block=False)\n-\n-        assert_equal(self.get_bip9_status(bipName)['status'], 'started')\n-        assert_equal(self.get_bip9_status(bipName)['since'], 144)\n-        assert_equal(self.get_bip9_status(bipName)['statistics']['elapsed'], 0)\n-        assert_equal(self.get_bip9_status(bipName)['statistics']['count'], 0)\n-        tmpl = self.nodes[0].getblocktemplate({})\n-        assert(bipName not in tmpl['rules'])\n-        assert_equal(tmpl['vbavailable'][bipName], bitno)\n-        assert_equal(tmpl['vbrequired'], 0)\n-        assert(tmpl['version'] & activated_version)\n-\n-        # Test 1-A\n-        # check stats after max number of \"signalling not\" blocks such that LOCKED_IN still possible this period\n-        test_blocks = self.generate_blocks(36, 4, test_blocks) # 0x00000004 (signalling not)\n-        test_blocks = self.generate_blocks(10, activated_version) # 0x20000001 (signalling ready)\n-        yield TestInstance(test_blocks, sync_every_block=False)\n-\n-        assert_equal(self.get_bip9_status(bipName)['statistics']['elapsed'], 46)\n-        assert_equal(self.get_bip9_status(bipName)['statistics']['count'], 10)\n-        assert_equal(self.get_bip9_status(bipName)['statistics']['possible'], True)\n-\n-        # Test 1-B\n-        # check stats after one additional \"signalling not\" block --  LOCKED_IN no longer possible this period\n-        test_blocks = self.generate_blocks(1, 4, test_blocks) # 0x00000004 (signalling not)\n-        yield TestInstance(test_blocks, sync_every_block=False)\n-\n-        assert_equal(self.get_bip9_status(bipName)['statistics']['elapsed'], 47)\n-        assert_equal(self.get_bip9_status(bipName)['statistics']['count'], 10)\n-        assert_equal(self.get_bip9_status(bipName)['statistics']['possible'], False)\n-\n-        # Test 1-C\n-        # finish period with \"ready\" blocks, but soft fork will still fail to advance to LOCKED_IN\n-        test_blocks = self.generate_blocks(97, activated_version) # 0x20000001 (signalling ready)\n-        yield TestInstance(test_blocks, sync_every_block=False)\n-\n-        assert_equal(self.get_bip9_status(bipName)['statistics']['elapsed'], 0)\n-        assert_equal(self.get_bip9_status(bipName)['statistics']['count'], 0)\n-        assert_equal(self.get_bip9_status(bipName)['statistics']['possible'], True)\n-        assert_equal(self.get_bip9_status(bipName)['status'], 'started')\n-\n-        # Test 2\n-        # Fail to achieve LOCKED_IN 100 out of 144 signal bit 1\n-        # using a variety of bits to simulate multiple parallel softforks\n-        test_blocks = self.generate_blocks(50, activated_version) # 0x20000001 (signalling ready)\n-        test_blocks = self.generate_blocks(20, 4, test_blocks) # 0x00000004 (signalling not)\n-        test_blocks = self.generate_blocks(50, activated_version, test_blocks) # 0x20000101 (signalling ready)\n-        test_blocks = self.generate_blocks(24, 4, test_blocks) # 0x20010000 (signalling not)\n-        yield TestInstance(test_blocks, sync_every_block=False)\n-\n-        assert_equal(self.get_bip9_status(bipName)['status'], 'started')\n-        assert_equal(self.get_bip9_status(bipName)['since'], 144)\n-        assert_equal(self.get_bip9_status(bipName)['statistics']['elapsed'], 0)\n-        assert_equal(self.get_bip9_status(bipName)['statistics']['count'], 0)\n-        tmpl = self.nodes[0].getblocktemplate({})\n-        assert(bipName not in tmpl['rules'])\n-        assert_equal(tmpl['vbavailable'][bipName], bitno)\n-        assert_equal(tmpl['vbrequired'], 0)\n-        assert(tmpl['version'] & activated_version)\n-\n-        # Test 3\n-        # 108 out of 144 signal bit 1 to achieve LOCKED_IN\n-        # using a variety of bits to simulate multiple parallel softforks\n-        test_blocks = self.generate_blocks(57, activated_version) # 0x20000001 (signalling ready)\n-        test_blocks = self.generate_blocks(26, 4, test_blocks) # 0x00000004 (signalling not)\n-        test_blocks = self.generate_blocks(50, activated_version, test_blocks) # 0x20000101 (signalling ready)\n-        test_blocks = self.generate_blocks(10, 4, test_blocks) # 0x20010000 (signalling not)\n-        yield TestInstance(test_blocks, sync_every_block=False)\n-\n-        # check counting stats and \"possible\" flag before last block of this period achieves LOCKED_IN...\n-        assert_equal(self.get_bip9_status(bipName)['statistics']['elapsed'], 143)\n-        assert_equal(self.get_bip9_status(bipName)['statistics']['count'], 107)\n-        assert_equal(self.get_bip9_status(bipName)['statistics']['possible'], True)\n-        assert_equal(self.get_bip9_status(bipName)['status'], 'started')\n-\n-        # ...continue with Test 3\n-        test_blocks = self.generate_blocks(1, activated_version) # 0x20000001 (signalling ready)\n-        yield TestInstance(test_blocks, sync_every_block=False)\n-\n-        assert_equal(self.get_bip9_status(bipName)['status'], 'locked_in')\n-        assert_equal(self.get_bip9_status(bipName)['since'], 576)\n-        tmpl = self.nodes[0].getblocktemplate({})\n-        assert(bipName not in tmpl['rules'])\n-\n-        # Test 4\n-        # 143 more version 536870913 blocks (waiting period-1)\n-        test_blocks = self.generate_blocks(143, 4)\n-        yield TestInstance(test_blocks, sync_every_block=False)\n-\n-        assert_equal(self.get_bip9_status(bipName)['status'], 'locked_in')\n-        assert_equal(self.get_bip9_status(bipName)['since'], 576)\n-        tmpl = self.nodes[0].getblocktemplate({})\n-        assert(bipName not in tmpl['rules'])\n-\n-        # Test 5\n-        # Check that the new rule is enforced\n-        spendtx = self.create_transaction(self.nodes[0],\n-                self.coinbase_blocks[0], self.nodeaddress, 1.0)\n-        invalidate(spendtx)\n-        spendtx = self.sign_transaction(self.nodes[0], spendtx)\n-        spendtx.rehash()\n-        invalidatePostSignature(spendtx)\n-        spendtx.rehash()\n-        block = create_block(self.tip, create_coinbase(self.height), self.last_block_time + 1)\n-        block.nVersion = activated_version\n-        block.vtx.append(spendtx)\n-        block.hashMerkleRoot = block.calc_merkle_root()\n-        block.rehash()\n-        block.solve()\n-\n-        self.last_block_time += 1\n-        self.tip = block.sha256\n-        self.height += 1\n-        yield TestInstance([[block, True]])\n-\n-        assert_equal(self.get_bip9_status(bipName)['status'], 'active')\n-        assert_equal(self.get_bip9_status(bipName)['since'], 720)\n-        tmpl = self.nodes[0].getblocktemplate({})\n-        assert(bipName in tmpl['rules'])\n-        assert(bipName not in tmpl['vbavailable'])\n-        assert_equal(tmpl['vbrequired'], 0)\n-        assert(not (tmpl['version'] & (1 << bitno)))\n-\n-        # Test 6\n-        # Check that the new sequence lock rules are enforced\n-        spendtx = self.create_transaction(self.nodes[0],\n-                self.coinbase_blocks[1], self.nodeaddress, 1.0)\n-        invalidate(spendtx)\n-        spendtx = self.sign_transaction(self.nodes[0], spendtx)\n-        spendtx.rehash()\n-        invalidatePostSignature(spendtx)\n-        spendtx.rehash()\n-\n-        block = create_block(self.tip, create_coinbase(self.height), self.last_block_time + 1)\n-        block.nVersion = 5\n-        block.vtx.append(spendtx)\n-        block.hashMerkleRoot = block.calc_merkle_root()\n-        block.rehash()\n-        block.solve()\n-        self.last_block_time += 1\n-        yield TestInstance([[block, False]])\n-\n-        # Restart all\n-        self.test.clear_all_connections()\n-        self.stop_nodes()\n-        self.nodes = []\n-        shutil.rmtree(get_datadir_path(self.options.tmpdir, 0))\n-        self.setup_chain()\n-        self.setup_network()\n-        self.test.add_all_connections(self.nodes)\n-        network_thread_start()\n-        self.test.p2p_connections[0].wait_for_verack()\n-\n-    def get_tests(self):\n-        for test in itertools.chain(\n-                self.test_BIP('csv', 0x20000001, self.sequence_lock_invalidate, self.donothing, 0),\n-                self.test_BIP('csv', 0x20000001, self.mtp_invalidate, self.donothing, 0),\n-                self.test_BIP('csv', 0x20000001, self.donothing, self.csv_invalidate, 0)\n-        ):\n-            yield test\n-\n-    def donothing(self, tx):\n-        return\n-\n-    def csv_invalidate(self, tx):\n-        \"\"\"Modify the signature in vin 0 of the tx to fail CSV\n-        Prepends -1 CSV DROP in the scriptSig itself.\n-        \"\"\"\n-        tx.vin[0].scriptSig = CScript([OP_1NEGATE, OP_CHECKSEQUENCEVERIFY, OP_DROP] +\n-                                      list(CScript(tx.vin[0].scriptSig)))\n-\n-    def sequence_lock_invalidate(self, tx):\n-        \"\"\"Modify the nSequence to make it fails once sequence lock rule is\n-        activated (high timespan).\n-        \"\"\"\n-        tx.vin[0].nSequence = 0x00FFFFFF\n-        tx.nLockTime = 0\n-\n-    def mtp_invalidate(self, tx):\n-        \"\"\"Modify the nLockTime to make it fails once MTP rule is activated.\"\"\"\n-        # Disable Sequence lock, Activate nLockTime\n-        tx.vin[0].nSequence = 0x90FFFFFF\n-        tx.nLockTime = self.last_block_time\n-\n-if __name__ == '__main__':\n-    BIP9SoftForksTest().main()"
      },
      {
        "sha": "518c16b5f143f16ae6c7fd4881db8c4c3ac9c8e6",
        "filename": "test/functional/test_runner.py",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e80c640d789d4e2ccb5e2b131502d51fed2c176a/test/functional/test_runner.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e80c640d789d4e2ccb5e2b131502d51fed2c176a/test/functional/test_runner.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_runner.py?ref=e80c640d789d4e2ccb5e2b131502d51fed2c176a",
        "patch": "@@ -159,7 +159,6 @@\n     'mining_getblocktemplate_longpoll.py',\n     'p2p_timeouts.py',\n     # vv Tests less than 60s vv\n-    'feature_bip9_softforks.py',\n     'p2p_feefilter.py',\n     'rpc_bind.py',\n     # vv Tests less than 30s vv"
      }
    ]
  },
  {
    "sha": "9c92c8c82716d0c35b638142a1125d07b3f240a8",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5YzkyYzhjODI3MTZkMGMzNWI2MzgxNDJhMTEyNWQwN2IzZjI0MGE4",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2017-12-01T18:10:23Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-04-02T18:04:07Z"
      },
      "message": "[tests] Remove Comparison Test Framework",
      "tree": {
        "sha": "541a8b1af344dac9f315e89f828de16bf1bac941",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/541a8b1af344dac9f315e89f828de16bf1bac941"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9c92c8c82716d0c35b638142a1125d07b3f240a8",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9c92c8c82716d0c35b638142a1125d07b3f240a8",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9c92c8c82716d0c35b638142a1125d07b3f240a8",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9c92c8c82716d0c35b638142a1125d07b3f240a8/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e80c640d789d4e2ccb5e2b131502d51fed2c176a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e80c640d789d4e2ccb5e2b131502d51fed2c176a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e80c640d789d4e2ccb5e2b131502d51fed2c176a"
      }
    ],
    "stats": {
      "total": 638,
      "additions": 0,
      "deletions": 638
    },
    "files": [
      {
        "sha": "21050cc2fa5dfa626718bb2dbd1f53fc279ffba4",
        "filename": "test/functional/README.md",
        "status": "modified",
        "additions": 0,
        "deletions": 52,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9c92c8c82716d0c35b638142a1125d07b3f240a8/test/functional/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9c92c8c82716d0c35b638142a1125d07b3f240a8/test/functional/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/README.md?ref=9c92c8c82716d0c35b638142a1125d07b3f240a8",
        "patch": "@@ -89,52 +89,6 @@ thread.)\n - Can be used to write tests where specific P2P protocol behavior is tested.\n Examples tests are `p2p_unrequested_blocks.py`, `p2p_compactblocks.py`.\n \n-#### Comptool\n-\n-- Comptool is a Testing framework for writing tests that compare the block/tx acceptance\n-behavior of a bitcoind against 1 or more other bitcoind instances. It should not be used\n-to write static tests with known outcomes, since that type of test is easier to write and\n-maintain using the standard BitcoinTestFramework.\n-\n-- Set the `num_nodes` variable (defined in `ComparisonTestFramework`) to start up\n-1 or more nodes.  If using 1 node, then `--testbinary` can be used as a command line\n-option to change the bitcoind binary used by the test.  If using 2 or more nodes,\n-then `--refbinary` can be optionally used to change the bitcoind that will be used\n-on nodes 2 and up.\n-\n-- Implement a (generator) function called `get_tests()` which yields `TestInstance`s.\n-Each `TestInstance` consists of:\n-  - A list of `[object, outcome, hash]` entries\n-    * `object` is a `CBlock`, `CTransaction`, or\n-    `CBlockHeader`.  `CBlock`'s and `CTransaction`'s are tested for\n-    acceptance.  `CBlockHeader`s can be used so that the test runner can deliver\n-    complete headers-chains when requested from the bitcoind, to allow writing\n-    tests where blocks can be delivered out of order but still processed by\n-    headers-first bitcoind's.\n-    * `outcome` is `True`, `False`, or `None`.  If `True`\n-    or `False`, the tip is compared with the expected tip -- either the\n-    block passed in, or the hash specified as the optional 3rd entry.  If\n-    `None` is specified, then the test will compare all the bitcoind's\n-    being tested to see if they all agree on what the best tip is.\n-    * `hash` is the block hash of the tip to compare against. Optional to\n-    specify; if left out then the hash of the block passed in will be used as\n-    the expected tip.  This allows for specifying an expected tip while testing\n-    the handling of either invalid blocks or blocks delivered out of order,\n-    which complete a longer chain.\n-  - `sync_every_block`: `True/False`.  If `False`, then all blocks\n-    are inv'ed together, and the test runner waits until the node receives the\n-    last one, and tests only the last block for tip acceptance using the\n-    outcome and specified tip.  If `True`, then each block is tested in\n-    sequence and synced (this is slower when processing many blocks).\n-  - `sync_every_transaction`: `True/False`.  Analogous to\n-    `sync_every_block`, except if the outcome on the last tx is \"None\",\n-    then the contents of the entire mempool are compared across all bitcoind\n-    connections.  If `True` or `False`, then only the last tx's\n-    acceptance is tested against the given outcome.\n-\n-- For examples of tests written in this framework, see\n-  `p2p_invalid_block.py` and `feature_block.py`.\n-\n ### test-framework modules\n \n #### [test_framework/authproxy.py](test_framework/authproxy.py)\n@@ -149,15 +103,9 @@ Generally useful functions.\n #### [test_framework/mininode.py](test_framework/mininode.py)\n Basic code to support P2P connectivity to a bitcoind.\n \n-#### [test_framework/comptool.py](test_framework/comptool.py)\n-Framework for comparison-tool style, P2P tests.\n-\n #### [test_framework/script.py](test_framework/script.py)\n Utilities for manipulating transaction scripts (originally from python-bitcoinlib)\n \n-#### [test_framework/blockstore.py](test_framework/blockstore.py)\n-Implements disk-backed block and tx storage.\n-\n #### [test_framework/key.py](test_framework/key.py)\n Wrapper around OpenSSL EC_Key (originally from python-bitcoinlib)\n "
      },
      {
        "sha": "6073285a6cfa514e900e4e13f24ae17683c9969b",
        "filename": "test/functional/test_framework/blockstore.py",
        "status": "removed",
        "additions": 0,
        "deletions": 160,
        "changes": 160,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e80c640d789d4e2ccb5e2b131502d51fed2c176a/test/functional/test_framework/blockstore.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e80c640d789d4e2ccb5e2b131502d51fed2c176a/test/functional/test_framework/blockstore.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/blockstore.py?ref=e80c640d789d4e2ccb5e2b131502d51fed2c176a",
        "patch": "@@ -1,160 +0,0 @@\n-#!/usr/bin/env python3\n-# Copyright (c) 2015-2017 The Bitcoin Core developers\n-# Distributed under the MIT software license, see the accompanying\n-# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\"\"\"BlockStore and TxStore helper classes.\"\"\"\n-\n-from .mininode import *\n-from io import BytesIO\n-import dbm.dumb as dbmd\n-\n-logger = logging.getLogger(\"TestFramework.blockstore\")\n-\n-class BlockStore():\n-    \"\"\"BlockStore helper class.\n-\n-    BlockStore keeps a map of blocks and implements helper functions for\n-    responding to getheaders and getdata, and for constructing a getheaders\n-    message.\n-    \"\"\"\n-\n-    def __init__(self, datadir):\n-        self.blockDB = dbmd.open(datadir + \"/blocks\", 'c')\n-        self.currentBlock = 0\n-        self.headers_map = dict()\n-\n-    def close(self):\n-        self.blockDB.close()\n-\n-    def erase(self, blockhash):\n-        del self.blockDB[repr(blockhash)]\n-\n-    # lookup an entry and return the item as raw bytes\n-    def get(self, blockhash):\n-        value = None\n-        try:\n-            value = self.blockDB[repr(blockhash)]\n-        except KeyError:\n-            return None\n-        return value\n-\n-    # lookup an entry and return it as a CBlock\n-    def get_block(self, blockhash):\n-        ret = None\n-        serialized_block = self.get(blockhash)\n-        if serialized_block is not None:\n-            f = BytesIO(serialized_block)\n-            ret = CBlock()\n-            ret.deserialize(f)\n-            ret.calc_sha256()\n-        return ret\n-\n-    def get_header(self, blockhash):\n-        try:\n-            return self.headers_map[blockhash]\n-        except KeyError:\n-            return None\n-\n-    # Note: this pulls full blocks out of the database just to retrieve\n-    # the headers -- perhaps we could keep a separate data structure\n-    # to avoid this overhead.\n-    def headers_for(self, locator, hash_stop, current_tip=None):\n-        if current_tip is None:\n-            current_tip = self.currentBlock\n-        current_block_header = self.get_header(current_tip)\n-        if current_block_header is None:\n-            return None\n-\n-        response = msg_headers()\n-        headersList = [ current_block_header ]\n-        maxheaders = 2000\n-        while (headersList[0].sha256 not in locator.vHave):\n-            prevBlockHash = headersList[0].hashPrevBlock\n-            prevBlockHeader = self.get_header(prevBlockHash)\n-            if prevBlockHeader is not None:\n-                headersList.insert(0, prevBlockHeader)\n-            else:\n-                break\n-        headersList = headersList[:maxheaders] # truncate if we have too many\n-        hashList = [x.sha256 for x in headersList]\n-        index = len(headersList)\n-        if (hash_stop in hashList):\n-            index = hashList.index(hash_stop)+1\n-        response.headers = headersList[:index]\n-        return response\n-\n-    def add_block(self, block):\n-        block.calc_sha256()\n-        try:\n-            self.blockDB[repr(block.sha256)] = bytes(block.serialize())\n-        except TypeError:\n-            logger.exception(\"Unexpected error\")\n-        self.currentBlock = block.sha256\n-        self.headers_map[block.sha256] = CBlockHeader(block)\n-\n-    def add_header(self, header):\n-        self.headers_map[header.sha256] = header\n-\n-    # lookup the hashes in \"inv\", and return p2p messages for delivering\n-    # blocks found.\n-    def get_blocks(self, inv):\n-        responses = []\n-        for i in inv:\n-            if (i.type == 2 or i.type == (2 | (1 << 30))): # MSG_BLOCK or MSG_WITNESS_BLOCK\n-                data = self.get(i.hash)\n-                if data is not None:\n-                    # Use msg_generic to avoid re-serialization\n-                    responses.append(msg_generic(b\"block\", data))\n-        return responses\n-\n-    def get_locator(self, current_tip=None):\n-        if current_tip is None:\n-            current_tip = self.currentBlock\n-        r = []\n-        counter = 0\n-        step = 1\n-        lastBlock = self.get_block(current_tip)\n-        while lastBlock is not None:\n-            r.append(lastBlock.hashPrevBlock)\n-            for i in range(step):\n-                lastBlock = self.get_block(lastBlock.hashPrevBlock)\n-                if lastBlock is None:\n-                    break\n-            counter += 1\n-            if counter > 10:\n-                step *= 2\n-        locator = CBlockLocator()\n-        locator.vHave = r\n-        return locator\n-\n-class TxStore():\n-    def __init__(self, datadir):\n-        self.txDB = dbmd.open(datadir + \"/transactions\", 'c')\n-\n-    def close(self):\n-        self.txDB.close()\n-\n-    # lookup an entry and return the item as raw bytes\n-    def get(self, txhash):\n-        value = None\n-        try:\n-            value = self.txDB[repr(txhash)]\n-        except KeyError:\n-            return None\n-        return value\n-\n-    def add_transaction(self, tx):\n-        tx.calc_sha256()\n-        try:\n-            self.txDB[repr(tx.sha256)] = bytes(tx.serialize())\n-        except TypeError:\n-            logger.exception(\"Unexpected error\")\n-\n-    def get_transactions(self, inv):\n-        responses = []\n-        for i in inv:\n-            if (i.type == 1 or i.type == (1 | (1 << 30))): # MSG_TX or MSG_WITNESS_TX\n-                tx = self.get(i.hash)\n-                if tx is not None:\n-                    responses.append(msg_generic(b\"tx\", tx))\n-        return responses"
      },
      {
        "sha": "e0ca78e5d166685e88dc9193e4beec90129b6703",
        "filename": "test/functional/test_framework/comptool.py",
        "status": "removed",
        "additions": 0,
        "deletions": 397,
        "changes": 397,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e80c640d789d4e2ccb5e2b131502d51fed2c176a/test/functional/test_framework/comptool.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e80c640d789d4e2ccb5e2b131502d51fed2c176a/test/functional/test_framework/comptool.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/comptool.py?ref=e80c640d789d4e2ccb5e2b131502d51fed2c176a",
        "patch": "@@ -1,397 +0,0 @@\n-#!/usr/bin/env python3\n-# Copyright (c) 2015-2017 The Bitcoin Core developers\n-# Distributed under the MIT software license, see the accompanying\n-# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\"\"\"Compare two or more bitcoinds to each other.\n-\n-To use, create a class that implements get_tests(), and pass it in\n-as the test generator to TestManager.  get_tests() should be a python\n-generator that returns TestInstance objects.  See below for definition.\n-\n-TestP2PConn behaves as follows:\n-    Configure with a BlockStore and TxStore\n-    on_inv: log the message but don't request\n-    on_headers: log the chain tip\n-    on_pong: update ping response map (for synchronization)\n-    on_getheaders: provide headers via BlockStore\n-    on_getdata: provide blocks via BlockStore\n-\"\"\"\n-\n-from .mininode import *\n-from .blockstore import BlockStore, TxStore\n-from .util import p2p_port, wait_until\n-\n-import logging\n-\n-logger=logging.getLogger(\"TestFramework.comptool\")\n-\n-global mininode_lock\n-\n-class RejectResult():\n-    \"\"\"Outcome that expects rejection of a transaction or block.\"\"\"\n-    def __init__(self, code, reason=b''):\n-        self.code = code\n-        self.reason = reason\n-    def match(self, other):\n-        if self.code != other.code:\n-            return False\n-        return other.reason.startswith(self.reason)\n-    def __repr__(self):\n-        return '%i:%s' % (self.code,self.reason or '*')\n-\n-class TestP2PConn(P2PInterface):\n-\n-    def __init__(self, block_store, tx_store):\n-        super().__init__()\n-        self.bestblockhash = None\n-        self.block_store = block_store\n-        self.block_request_map = {}\n-        self.tx_store = tx_store\n-        self.tx_request_map = {}\n-        self.block_reject_map = {}\n-        self.tx_reject_map = {}\n-\n-        # When the pingmap is non-empty we're waiting for \n-        # a response\n-        self.pingMap = {} \n-        self.lastInv = []\n-        self.closed = False\n-\n-    def on_close(self):\n-        self.closed = True\n-\n-    def on_headers(self, message):\n-        if len(message.headers) > 0:\n-            best_header = message.headers[-1]\n-            best_header.calc_sha256()\n-            self.bestblockhash = best_header.sha256\n-\n-    def on_getheaders(self, message):\n-        response = self.block_store.headers_for(message.locator, message.hashstop)\n-        if response is not None:\n-            self.send_message(response)\n-\n-    def on_getdata(self, message):\n-        [self.send_message(r) for r in self.block_store.get_blocks(message.inv)]\n-        [self.send_message(r) for r in self.tx_store.get_transactions(message.inv)]\n-\n-        for i in message.inv:\n-            if i.type == 1 or i.type == 1 | (1 << 30): # MSG_TX or MSG_WITNESS_TX\n-                self.tx_request_map[i.hash] = True\n-            elif i.type == 2 or i.type == 2 | (1 << 30): # MSG_BLOCK or MSG_WITNESS_BLOCK\n-                self.block_request_map[i.hash] = True\n-\n-    def on_inv(self, message):\n-        self.lastInv = [x.hash for x in message.inv]\n-\n-    def on_pong(self, message):\n-        try:\n-            del self.pingMap[message.nonce]\n-        except KeyError:\n-            raise AssertionError(\"Got pong for unknown ping [%s]\" % repr(message))\n-\n-    def on_reject(self, message):\n-        if message.message == b'tx':\n-            self.tx_reject_map[message.data] = RejectResult(message.code, message.reason)\n-        if message.message == b'block':\n-            self.block_reject_map[message.data] = RejectResult(message.code, message.reason)\n-\n-    def send_inv(self, obj):\n-        mtype = 2 if isinstance(obj, CBlock) else 1\n-        self.send_message(msg_inv([CInv(mtype, obj.sha256)]))\n-\n-    def send_getheaders(self):\n-        # We ask for headers from their last tip.\n-        m = msg_getheaders()\n-        m.locator = self.block_store.get_locator(self.bestblockhash)\n-        self.send_message(m)\n-\n-    def send_header(self, header):\n-        m = msg_headers()\n-        m.headers.append(header)\n-        self.send_message(m)\n-\n-    # This assumes BIP31\n-    def send_ping(self, nonce):\n-        self.pingMap[nonce] = True\n-        self.send_message(msg_ping(nonce))\n-\n-    def received_ping_response(self, nonce):\n-        return nonce not in self.pingMap\n-\n-    def send_mempool(self):\n-        self.lastInv = []\n-        self.send_message(msg_mempool())\n-\n-# TestInstance:\n-#\n-# Instances of these are generated by the test generator, and fed into the\n-# comptool.\n-#\n-# \"blocks_and_transactions\" should be an array of\n-#    [obj, True/False/None, hash/None]:\n-#  - obj is either a CBlock, CBlockHeader, or a CTransaction, and\n-#  - the second value indicates whether the object should be accepted\n-#    into the blockchain or mempool (for tests where we expect a certain\n-#    answer), or \"None\" if we don't expect a certain answer and are just\n-#    comparing the behavior of the nodes being tested.\n-#  - the third value is the hash to test the tip against (if None or omitted,\n-#    use the hash of the block)\n-#  - NOTE: if a block header, no test is performed; instead the header is\n-#    just added to the block_store.  This is to facilitate block delivery\n-#    when communicating with headers-first clients (when withholding an\n-#    intermediate block).\n-# sync_every_block: if True, then each block will be inv'ed, synced, and\n-#    nodes will be tested based on the outcome for the block.  If False,\n-#    then inv's accumulate until all blocks are processed (or max inv size\n-#    is reached) and then sent out in one inv message.  Then the final block\n-#    will be synced across all connections, and the outcome of the final \n-#    block will be tested.\n-# sync_every_tx: analogous to behavior for sync_every_block, except if outcome\n-#    on the final tx is None, then contents of entire mempool are compared\n-#    across all connections.  (If outcome of final tx is specified as true\n-#    or false, then only the last tx is tested against outcome.)\n-\n-class TestInstance():\n-    def __init__(self, objects=None, sync_every_block=True, sync_every_tx=False):\n-        self.blocks_and_transactions = objects if objects else []\n-        self.sync_every_block = sync_every_block\n-        self.sync_every_tx = sync_every_tx\n-\n-class TestManager():\n-\n-    def __init__(self, testgen, datadir):\n-        self.test_generator = testgen\n-        self.p2p_connections= []\n-        self.block_store    = BlockStore(datadir)\n-        self.tx_store       = TxStore(datadir)\n-        self.ping_counter   = 1\n-\n-    def add_all_connections(self, nodes):\n-        for i in range(len(nodes)):\n-            # Create a p2p connection to each node\n-            node = TestP2PConn(self.block_store, self.tx_store)\n-            node.peer_connect('127.0.0.1', p2p_port(i))\n-            self.p2p_connections.append(node)\n-\n-    def clear_all_connections(self):\n-        self.p2p_connections = []\n-\n-    def wait_for_disconnections(self):\n-        def disconnected():\n-            return all(node.closed for node in self.p2p_connections)\n-        wait_until(disconnected, timeout=10, lock=mininode_lock)\n-\n-    def wait_for_verack(self):\n-        return all(node.wait_for_verack() for node in self.p2p_connections)\n-\n-    def wait_for_pings(self, counter):\n-        def received_pongs():\n-            return all(node.received_ping_response(counter) for node in self.p2p_connections)\n-        wait_until(received_pongs, lock=mininode_lock)\n-\n-    # sync_blocks: Wait for all connections to request the blockhash given\n-    # then send get_headers to find out the tip of each node, and synchronize\n-    # the response by using a ping (and waiting for pong with same nonce).\n-    def sync_blocks(self, blockhash, num_blocks):\n-        def blocks_requested():\n-            return all(\n-                blockhash in node.block_request_map and node.block_request_map[blockhash]\n-                for node in self.p2p_connections\n-            )\n-\n-        # --> error if not requested\n-        wait_until(blocks_requested, attempts=20*num_blocks, lock=mininode_lock)\n-\n-        # Send getheaders message\n-        [ c.send_getheaders() for c in self.p2p_connections ]\n-\n-        # Send ping and wait for response -- synchronization hack\n-        [ c.send_ping(self.ping_counter) for c in self.p2p_connections ]\n-        self.wait_for_pings(self.ping_counter)\n-        self.ping_counter += 1\n-\n-    # Analogous to sync_block (see above)\n-    def sync_transaction(self, txhash, num_events):\n-        # Wait for nodes to request transaction (50ms sleep * 20 tries * num_events)\n-        def transaction_requested():\n-            return all(\n-                txhash in node.tx_request_map and node.tx_request_map[txhash]\n-                for node in self.p2p_connections\n-            )\n-\n-        # --> error if not requested\n-        wait_until(transaction_requested, attempts=20*num_events, lock=mininode_lock)\n-\n-        # Get the mempool\n-        [ c.send_mempool() for c in self.p2p_connections ]\n-\n-        # Send ping and wait for response -- synchronization hack\n-        [ c.send_ping(self.ping_counter) for c in self.p2p_connections ]\n-        self.wait_for_pings(self.ping_counter)\n-        self.ping_counter += 1\n-\n-        # Sort inv responses from each node\n-        with mininode_lock:\n-            [ c.lastInv.sort() for c in self.p2p_connections ]\n-\n-    # Verify that the tip of each connection all agree with each other, and\n-    # with the expected outcome (if given)\n-    def check_results(self, blockhash, outcome):\n-        with mininode_lock:\n-            for c in self.p2p_connections:\n-                if outcome is None:\n-                    if c.bestblockhash != self.p2p_connections[0].bestblockhash:\n-                        return False\n-                elif isinstance(outcome, RejectResult): # Check that block was rejected w/ code\n-                    if c.bestblockhash == blockhash:\n-                        return False\n-                    if blockhash not in c.block_reject_map:\n-                        logger.error('Block not in reject map: %064x' % (blockhash))\n-                        return False\n-                    if not outcome.match(c.block_reject_map[blockhash]):\n-                        logger.error('Block rejected with %s instead of expected %s: %064x' % (c.block_reject_map[blockhash], outcome, blockhash))\n-                        return False\n-                elif ((c.bestblockhash == blockhash) != outcome):\n-                    return False\n-            return True\n-\n-    # Either check that the mempools all agree with each other, or that\n-    # txhash's presence in the mempool matches the outcome specified.\n-    # This is somewhat of a strange comparison, in that we're either comparing\n-    # a particular tx to an outcome, or the entire mempools altogether;\n-    # perhaps it would be useful to add the ability to check explicitly that\n-    # a particular tx's existence in the mempool is the same across all nodes.\n-    def check_mempool(self, txhash, outcome):\n-        with mininode_lock:\n-            for c in self.p2p_connections:\n-                if outcome is None:\n-                    # Make sure the mempools agree with each other\n-                    if c.lastInv != self.p2p_connections[0].lastInv:\n-                        return False\n-                elif isinstance(outcome, RejectResult): # Check that tx was rejected w/ code\n-                    if txhash in c.lastInv:\n-                        return False\n-                    if txhash not in c.tx_reject_map:\n-                        logger.error('Tx not in reject map: %064x' % (txhash))\n-                        return False\n-                    if not outcome.match(c.tx_reject_map[txhash]):\n-                        logger.error('Tx rejected with %s instead of expected %s: %064x' % (c.tx_reject_map[txhash], outcome, txhash))\n-                        return False\n-                elif ((txhash in c.lastInv) != outcome):\n-                    return False\n-            return True\n-\n-    def run(self):\n-        # Wait until verack is received\n-        self.wait_for_verack()\n-\n-        test_number = 0\n-        tests = self.test_generator.get_tests()\n-        for test_instance in tests:\n-            test_number += 1\n-            logger.info(\"Running test %d: %s line %s\" % (test_number, tests.gi_code.co_filename, tests.gi_frame.f_lineno))\n-            # We use these variables to keep track of the last block\n-            # and last transaction in the tests, which are used\n-            # if we're not syncing on every block or every tx.\n-            [ block, block_outcome, tip ] = [ None, None, None ]\n-            [ tx, tx_outcome ] = [ None, None ]\n-            invqueue = []\n-\n-            for test_obj in test_instance.blocks_and_transactions:\n-                b_or_t = test_obj[0]\n-                outcome = test_obj[1]\n-                # Determine if we're dealing with a block or tx\n-                if isinstance(b_or_t, CBlock):  # Block test runner\n-                    block = b_or_t\n-                    block_outcome = outcome\n-                    tip = block.sha256\n-                    # each test_obj can have an optional third argument\n-                    # to specify the tip we should compare with\n-                    # (default is to use the block being tested)\n-                    if len(test_obj) >= 3:\n-                        tip = test_obj[2]\n-\n-                    # Add to shared block_store, set as current block\n-                    # If there was an open getdata request for the block\n-                    # previously, and we didn't have an entry in the\n-                    # block_store, then immediately deliver, because the\n-                    # node wouldn't send another getdata request while\n-                    # the earlier one is outstanding.\n-                    first_block_with_hash = True\n-                    if self.block_store.get(block.sha256) is not None:\n-                        first_block_with_hash = False\n-                    with mininode_lock:\n-                        self.block_store.add_block(block)\n-                        for c in self.p2p_connections:\n-                            if first_block_with_hash and block.sha256 in c.block_request_map and c.block_request_map[block.sha256] == True:\n-                                # There was a previous request for this block hash\n-                                # Most likely, we delivered a header for this block\n-                                # but never had the block to respond to the getdata\n-                                c.send_message(msg_block(block))\n-                            else:\n-                                c.block_request_map[block.sha256] = False\n-                    # Either send inv's to each node and sync, or add\n-                    # to invqueue for later inv'ing.\n-                    if (test_instance.sync_every_block):\n-                        # if we expect success, send inv and sync every block\n-                        # if we expect failure, just push the block and see what happens.\n-                        if outcome == True:\n-                            [ c.send_inv(block) for c in self.p2p_connections ]\n-                            self.sync_blocks(block.sha256, 1)\n-                        else:\n-                            [ c.send_message(msg_block(block)) for c in self.p2p_connections ]\n-                            [ c.send_ping(self.ping_counter) for c in self.p2p_connections ]\n-                            self.wait_for_pings(self.ping_counter)\n-                            self.ping_counter += 1\n-                        if (not self.check_results(tip, outcome)):\n-                            raise AssertionError(\"Test failed at test %d\" % test_number)\n-                    else:\n-                        invqueue.append(CInv(2, block.sha256))\n-                elif isinstance(b_or_t, CBlockHeader):\n-                    block_header = b_or_t\n-                    self.block_store.add_header(block_header)\n-                    [ c.send_header(block_header) for c in self.p2p_connections ]\n-\n-                else:  # Tx test runner\n-                    assert(isinstance(b_or_t, CTransaction))\n-                    tx = b_or_t\n-                    tx_outcome = outcome\n-                    # Add to shared tx store and clear map entry\n-                    with mininode_lock:\n-                        self.tx_store.add_transaction(tx)\n-                        for c in self.p2p_connections:\n-                            c.tx_request_map[tx.sha256] = False\n-                    # Again, either inv to all nodes or save for later\n-                    if (test_instance.sync_every_tx):\n-                        [ c.send_inv(tx) for c in self.p2p_connections ]\n-                        self.sync_transaction(tx.sha256, 1)\n-                        if (not self.check_mempool(tx.sha256, outcome)):\n-                            raise AssertionError(\"Test failed at test %d\" % test_number)\n-                    else:\n-                        invqueue.append(CInv(1, tx.sha256))\n-                # Ensure we're not overflowing the inv queue\n-                if len(invqueue) == MAX_INV_SZ:\n-                    [ c.send_message(msg_inv(invqueue)) for c in self.p2p_connections ]\n-                    invqueue = []\n-\n-            # Do final sync if we weren't syncing on every block or every tx.\n-            if (not test_instance.sync_every_block and block is not None):\n-                if len(invqueue) > 0:\n-                    [ c.send_message(msg_inv(invqueue)) for c in self.p2p_connections ]\n-                    invqueue = []\n-                self.sync_blocks(block.sha256, len(test_instance.blocks_and_transactions))\n-                if (not self.check_results(tip, block_outcome)):\n-                    raise AssertionError(\"Block test failed at test %d\" % test_number)\n-            if (not test_instance.sync_every_tx and tx is not None):\n-                if len(invqueue) > 0:\n-                    [ c.send_message(msg_inv(invqueue)) for c in self.p2p_connections ]\n-                    invqueue = []\n-                self.sync_transaction(tx.sha256, len(test_instance.blocks_and_transactions))\n-                if (not self.check_mempool(tx.sha256, tx_outcome)):\n-                    raise AssertionError(\"Mempool test failed at test %d\" % test_number)\n-\n-        [ c.disconnect_node() for c in self.p2p_connections ]\n-        self.wait_for_disconnections()\n-        self.block_store.close()\n-        self.tx_store.close()"
      },
      {
        "sha": "543643f2731d3620292bbb9d61eb4c4c40c9b868",
        "filename": "test/functional/test_framework/test_framework.py",
        "status": "modified",
        "additions": 0,
        "deletions": 29,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9c92c8c82716d0c35b638142a1125d07b3f240a8/test/functional/test_framework/test_framework.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9c92c8c82716d0c35b638142a1125d07b3f240a8/test/functional/test_framework/test_framework.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/test_framework.py?ref=9c92c8c82716d0c35b638142a1125d07b3f240a8",
        "patch": "@@ -432,35 +432,6 @@ def _initialize_chain_clean(self):\n         for i in range(self.num_nodes):\n             initialize_datadir(self.options.tmpdir, i)\n \n-class ComparisonTestFramework(BitcoinTestFramework):\n-    \"\"\"Test framework for doing p2p comparison testing\n-\n-    Sets up some bitcoind binaries:\n-    - 1 binary: test binary\n-    - 2 binaries: 1 test binary, 1 ref binary\n-    - n>2 binaries: 1 test binary, n-1 ref binaries\"\"\"\n-\n-    def set_test_params(self):\n-        self.num_nodes = 2\n-        self.setup_clean_chain = True\n-\n-    def add_options(self, parser):\n-        parser.add_option(\"--testbinary\", dest=\"testbinary\",\n-                          default=os.getenv(\"BITCOIND\", \"bitcoind\"),\n-                          help=\"bitcoind binary to test\")\n-        parser.add_option(\"--refbinary\", dest=\"refbinary\",\n-                          default=os.getenv(\"BITCOIND\", \"bitcoind\"),\n-                          help=\"bitcoind binary to use for reference nodes (if any)\")\n-\n-    def setup_network(self):\n-        extra_args = [['-whitelist=127.0.0.1']] * self.num_nodes\n-        if hasattr(self, \"extra_args\"):\n-            extra_args = self.extra_args\n-        self.add_nodes(self.num_nodes, extra_args,\n-                       binary=[self.options.testbinary] +\n-                       [self.options.refbinary] * (self.num_nodes - 1))\n-        self.start_nodes()\n-\n class SkipTest(Exception):\n     \"\"\"This exception is raised to skip a test\"\"\"\n     def __init__(self, message):"
      }
    ]
  }
]