DrahtBot,2020-06-08 00:08:21,"<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* #19259 (tests: Add fuzzing harness for LoadMempool(...) and DumpMempool(...) by practicalswift)\n* #19203 (net: Add regres",https://github.com/bitcoin/bitcoin/pull/19143#issuecomment-640300639,640300639,
practicalswift,2020-07-15 00:58:53,"> Combined fuzzing coverage for only the fuzzers in _this_ branch: https://crypt-iq.github.io/pr19143_cov/src/\n> \n> Each fuzzer was run for about 24 hours. I used a variation of libFuzzer and AFL.\n\nWow, that's some thorough testing! Thanks a lot!\n\n> There seems to be some missing coverage in `CBlockPolicyEstimator::Write` & `CBlockPolicyEstimator::Read`. That could probably be fixed by",https://github.com/bitcoin/bitcoin/pull/19143#issuecomment-658485369,658485369,
Crypt-iQ,2020-07-16 14:45:28,Can confirm that the new `policy_estimator_io` fuzzer is significantly faster with libfuzzer (600-700 exec/s on one core) and hits checks in `Read` & `Write` that it otherwise doesn't hit in the `policy_estimator` fuzzer due to being slower. Also tried with AFL but was very slow since I forgot to compile with persistent mode :/. Will review the latest set of changes now. Coverage for just the `pol,https://github.com/bitcoin/bitcoin/pull/19143#issuecomment-659460159,659460159,
Crypt-iQ,2020-07-18 02:33:57,Tested ACK ad6c348,https://github.com/bitcoin/bitcoin/pull/19143#issuecomment-660410612,660410612,
Crypt-iQ,2020-07-10 22:58:07,I don't understand the need for the call to `ConsumeBool()`. Isn't `size` necessarily equal to `random_bytes.size()`?,https://github.com/bitcoin/bitcoin/pull/19143#discussion_r453112343,453112343,src/test/fuzz/util.h
MarcoFalke,2020-07-11 10:18:29,"If the m_fuzzed_data_provider is empty it should give out less bytes, so `size` would be larger. `ConsumeBool` would return false in that case and this condition would evaluate to `size`.\n\nSo it seems `n` can simply be replaced by `size`",https://github.com/bitcoin/bitcoin/pull/19143#discussion_r453180452,453180452,src/test/fuzz/util.h
Crypt-iQ,2020-07-11 10:50:18,Oh I didn't think about that edge case. Don't you mean the condition should evaluate to `random_bytes.size()` if `ConsumeBool()` is false. So `n` replaced by `random_bytes.size()` instead?,https://github.com/bitcoin/bitcoin/pull/19143#discussion_r453183002,453183002,src/test/fuzz/util.h
MarcoFalke,2020-07-11 10:51:11,Ah right off-by-one :man_facepalming: ,https://github.com/bitcoin/bitcoin/pull/19143#discussion_r453183062,453183062,src/test/fuzz/util.h
Crypt-iQ,2020-07-14 20:13:41,Why did you leave out `SetPos` when calling `CBufferedFile` functions?,https://github.com/bitcoin/bitcoin/pull/19143#discussion_r454616440,454616440,src/test/fuzz/buffered_file.cpp
practicalswift,2020-07-15 00:11:44,Good catch! Now fuzzing also `SetPos` :),https://github.com/bitcoin/bitcoin/pull/19143#discussion_r454715644,454715644,src/test/fuzz/buffered_file.cpp
practicalswift,2020-07-15 01:25:16,Now simply using `random_bytes.size()`. I think I was trying to be too clever :)  Please re-review :),https://github.com/bitcoin/bitcoin/pull/19143#discussion_r454735593,454735593,src/test/fuzz/util.h
Crypt-iQ,2020-07-15 02:23:14,`new_offset` should be `fuzzed_file->m_offset`,https://github.com/bitcoin/bitcoin/pull/19143#discussion_r454751328,454751328,src/test/fuzz/util.h
Crypt-iQ,2020-07-15 08:17:58,"Could return early at the top of the function `#ifndef _GNU_SOURCE`, then you wouldn't need these macros here?",https://github.com/bitcoin/bitcoin/pull/19143#discussion_r454875264,454875264,src/test/fuzz/util.h
Crypt-iQ,2020-07-15 08:33:22,"Is this gated by `ConsumeBool()` to test the behavior that, if this isn't hit, `fclose()` is called automatically in the destructor?",https://github.com/bitcoin/bitcoin/pull/19143#discussion_r454884408,454884408,src/test/fuzz/autofile.cpp
Crypt-iQ,2020-07-15 08:40:11,Should this be set back to `false` upon successful call to `SetPos`?,https://github.com/bitcoin/bitcoin/pull/19143#discussion_r454888506,454888506,src/test/fuzz/buffered_file.cpp
Crypt-iQ,2020-07-15 08:48:37,"Since `block_policy_estimator` is declared static, it shouldn't matter if the `Read` call fails because the `Write` call could still succeed so I don't think it needs to be gated.",https://github.com/bitcoin/bitcoin/pull/19143#discussion_r454893815,454893815,src/test/fuzz/policy_estimator_io.cpp
practicalswift,2020-07-15 11:25:47,This is intentional actually: I want exactly the same input bytes to be consumed by an `open()` call regardless of `fopencookie` being available or not.,https://github.com/bitcoin/bitcoin/pull/19143#discussion_r454980370,454980370,src/test/fuzz/util.h
practicalswift,2020-07-15 11:27:03,"Yes it is, but I want the fuzzer to also exercise the `release()` code path here, and it isn't called in the destructor :)",https://github.com/bitcoin/bitcoin/pull/19143#discussion_r454980944,454980944,src/test/fuzz/autofile.cpp
practicalswift,2020-07-15 11:29:21,Unfortunately I think a single failed `SetPos` call is sufficient to set a subsequent `FindByte` call into an infinite loop. A successful `SetPos` won't necessarily undo the harm of a prior failed `SetPos` call :),https://github.com/bitcoin/bitcoin/pull/19143#discussion_r454982020,454982020,src/test/fuzz/buffered_file.cpp
practicalswift,2020-07-15 11:33:42,"The thinking here is that a successful `Read` will ""reset"" (to some extent) the state of `block_policy_estimator`. Without the check we might be calling `Write(â€¦)` on `block_policy_estimator` that is populated from a successful `Read` in a previous run: that would introduce unnecessary coverage instability.\n\nMore specifically this is the case I'm guarding against:\n\n```\nrun n:\n  block_p",https://github.com/bitcoin/bitcoin/pull/19143#discussion_r454984243,454984243,src/test/fuzz/policy_estimator_io.cpp
practicalswift,2020-07-15 11:42:51,"Oh, nice catch! Thanks for noticing: now fixed!",https://github.com/bitcoin/bitcoin/pull/19143#discussion_r454988740,454988740,src/test/fuzz/util.h
Crypt-iQ,2020-07-15 11:42:56,Ok this makes much more sense. Otherwise it's not always possible to get the same coverage I think? Different machines on different runs may not hit the same `Read`->`Write`->`Read(false)` calls.,https://github.com/bitcoin/bitcoin/pull/19143#discussion_r454988782,454988782,src/test/fuzz/policy_estimator_io.cpp
practicalswift,2020-07-15 11:50:44,"@Crypt-iQ Exactly! We want to have ""coverage stability"": a given input should result in the same coverage for a single run regardless of what has happened in previous runs. Achieving 100% coverage stability is not always possible. It might be due to architectural reasons (globals is a typical example), or it might be due to performance reasons (re-using an object might be required to get decent pe",https://github.com/bitcoin/bitcoin/pull/19143#discussion_r454992886,454992886,src/test/fuzz/policy_estimator_io.cpp
