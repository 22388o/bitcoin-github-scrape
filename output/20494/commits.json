[
  {
    "sha": "12bd0fc9d70333c54c83ebb08c734272dbd330c2",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxMmJkMGZjOWQ3MDMzM2M1NGM4M2ViYjA4YzczNDI3MmRiZDMzMGMy",
    "commit": {
      "author": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2020-11-24T15:13:23Z"
      },
      "committer": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2020-11-24T15:13:23Z"
      },
      "message": "Move NodeImpl from interfaces/node.cpp to node/interfaces.cpp",
      "tree": {
        "sha": "325d5091ba8759fd2cfb2c8340139c72dbcdb8fd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/325d5091ba8759fd2cfb2c8340139c72dbcdb8fd"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/12bd0fc9d70333c54c83ebb08c734272dbd330c2",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/12bd0fc9d70333c54c83ebb08c734272dbd330c2",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/12bd0fc9d70333c54c83ebb08c734272dbd330c2",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/12bd0fc9d70333c54c83ebb08c734272dbd330c2/comments",
    "author": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "31c9987976af8ac5ad40091256ac41a2ccb078cd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/31c9987976af8ac5ad40091256ac41a2ccb078cd",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/31c9987976af8ac5ad40091256ac41a2ccb078cd"
      }
    ],
    "stats": {
      "total": 17,
      "additions": 11,
      "deletions": 6
    },
    "files": [
      {
        "sha": "dee2bc77fde46e62b680fc1721140f21605437db",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/12bd0fc9d70333c54c83ebb08c734272dbd330c2/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/12bd0fc9d70333c54c83ebb08c734272dbd330c2/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=12bd0fc9d70333c54c83ebb08c734272dbd330c2",
        "patch": "@@ -300,13 +300,13 @@ libbitcoin_server_a_SOURCES = \\\n   index/txindex.cpp \\\n   init.cpp \\\n   interfaces/chain.cpp \\\n-  interfaces/node.cpp \\\n   miner.cpp \\\n   net.cpp \\\n   net_processing.cpp \\\n   node/coin.cpp \\\n   node/coinstats.cpp \\\n   node/context.cpp \\\n+  node/interfaces.cpp \\\n   node/psbt.cpp \\\n   node/transaction.cpp \\\n   node/ui_interface.cpp \\"
      },
      {
        "sha": "74098eba96531560f4853b0955ad0a15ff94fb91",
        "filename": "src/node/interfaces.cpp",
        "status": "renamed",
        "additions": 10,
        "deletions": 5,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/12bd0fc9d70333c54c83ebb08c734272dbd330c2/src/node/interfaces.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/12bd0fc9d70333c54c83ebb08c734272dbd330c2/src/node/interfaces.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/interfaces.cpp?ref=12bd0fc9d70333c54c83ebb08c734272dbd330c2",
        "patch": "@@ -42,9 +42,14 @@\n \n #include <boost/signals2/signal.hpp>\n \n-namespace interfaces {\n-namespace {\n+using interfaces::BlockTip;\n+using interfaces::Handler;\n+using interfaces::MakeHandler;\n+using interfaces::Node;\n+using interfaces::WalletClient;\n \n+namespace node {\n+namespace {\n class NodeImpl : public Node\n {\n public:\n@@ -295,9 +300,9 @@ class NodeImpl : public Node\n     NodeContext* m_context{nullptr};\n     util::Ref m_context_ref;\n };\n-\n } // namespace\n+} // namespace node\n \n-std::unique_ptr<Node> MakeNode(NodeContext* context) { return MakeUnique<NodeImpl>(context); }\n-\n+namespace interfaces {\n+std::unique_ptr<Node> MakeNode(NodeContext* context) { return MakeUnique<node::NodeImpl>(context); }\n } // namespace interfaces",
        "previous_filename": "src/interfaces/node.cpp"
      }
    ]
  },
  {
    "sha": "2a26771d8161d30be1853a35acfee588cce03634",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyYTI2NzcxZDgxNjFkMzBiZTE4NTNhMzVhY2ZlZTU4OGNjZTAzNjM0",
    "commit": {
      "author": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2020-11-24T15:13:23Z"
      },
      "committer": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2020-11-24T15:13:23Z"
      },
      "message": "Move ChainImpl from interfaces/chain.cpp to node/interfaces.cpp\n\nNo changes to ChainImpl or any related classes (review with `git diff --color-moved=dimmed_zebra`)",
      "tree": {
        "sha": "f82ddb9210278cb06e8bbd87183c9ed94cf8c764",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f82ddb9210278cb06e8bbd87183c9ed94cf8c764"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2a26771d8161d30be1853a35acfee588cce03634",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2a26771d8161d30be1853a35acfee588cce03634",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2a26771d8161d30be1853a35acfee588cce03634",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2a26771d8161d30be1853a35acfee588cce03634/comments",
    "author": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "12bd0fc9d70333c54c83ebb08c734272dbd330c2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/12bd0fc9d70333c54c83ebb08c734272dbd330c2",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/12bd0fc9d70333c54c83ebb08c734272dbd330c2"
      }
    ],
    "stats": {
      "total": 813,
      "additions": 390,
      "deletions": 423
    },
    "files": [
      {
        "sha": "639b9c89add8682f9d33e51a23e88e7281563058",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2a26771d8161d30be1853a35acfee588cce03634/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2a26771d8161d30be1853a35acfee588cce03634/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=2a26771d8161d30be1853a35acfee588cce03634",
        "patch": "@@ -299,7 +299,6 @@ libbitcoin_server_a_SOURCES = \\\n   index/blockfilterindex.cpp \\\n   index/txindex.cpp \\\n   init.cpp \\\n-  interfaces/chain.cpp \\\n   miner.cpp \\\n   net.cpp \\\n   net_processing.cpp \\"
      },
      {
        "sha": "4c5ebe66fc92d0a3ff94899a86dfec31780fce70",
        "filename": "src/interfaces/chain.cpp",
        "status": "removed",
        "additions": 0,
        "deletions": 417,
        "changes": 417,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/12bd0fc9d70333c54c83ebb08c734272dbd330c2/src/interfaces/chain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/12bd0fc9d70333c54c83ebb08c734272dbd330c2/src/interfaces/chain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/chain.cpp?ref=12bd0fc9d70333c54c83ebb08c734272dbd330c2",
        "patch": "@@ -1,417 +0,0 @@\n-// Copyright (c) 2018-2020 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#include <interfaces/chain.h>\n-\n-#include <chain.h>\n-#include <chainparams.h>\n-#include <interfaces/handler.h>\n-#include <interfaces/wallet.h>\n-#include <net.h>\n-#include <net_processing.h>\n-#include <node/coin.h>\n-#include <node/context.h>\n-#include <node/transaction.h>\n-#include <node/ui_interface.h>\n-#include <policy/fees.h>\n-#include <policy/policy.h>\n-#include <policy/rbf.h>\n-#include <policy/settings.h>\n-#include <primitives/block.h>\n-#include <primitives/transaction.h>\n-#include <rpc/protocol.h>\n-#include <rpc/server.h>\n-#include <shutdown.h>\n-#include <sync.h>\n-#include <timedata.h>\n-#include <txmempool.h>\n-#include <uint256.h>\n-#include <univalue.h>\n-#include <util/system.h>\n-#include <validation.h>\n-#include <validationinterface.h>\n-\n-#include <memory>\n-#include <utility>\n-\n-namespace interfaces {\n-namespace {\n-\n-bool FillBlock(const CBlockIndex* index, const FoundBlock& block, UniqueLock<RecursiveMutex>& lock)\n-{\n-    if (!index) return false;\n-    if (block.m_hash) *block.m_hash = index->GetBlockHash();\n-    if (block.m_height) *block.m_height = index->nHeight;\n-    if (block.m_time) *block.m_time = index->GetBlockTime();\n-    if (block.m_max_time) *block.m_max_time = index->GetBlockTimeMax();\n-    if (block.m_mtp_time) *block.m_mtp_time = index->GetMedianTimePast();\n-    if (block.m_data) {\n-        REVERSE_LOCK(lock);\n-        if (!ReadBlockFromDisk(*block.m_data, index, Params().GetConsensus())) block.m_data->SetNull();\n-    }\n-    return true;\n-}\n-\n-class NotificationsProxy : public CValidationInterface\n-{\n-public:\n-    explicit NotificationsProxy(std::shared_ptr<Chain::Notifications> notifications)\n-        : m_notifications(std::move(notifications)) {}\n-    virtual ~NotificationsProxy() = default;\n-    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t mempool_sequence) override\n-    {\n-        m_notifications->transactionAddedToMempool(tx, mempool_sequence);\n-    }\n-    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t mempool_sequence) override\n-    {\n-        m_notifications->transactionRemovedFromMempool(tx, reason, mempool_sequence);\n-    }\n-    void BlockConnected(const std::shared_ptr<const CBlock>& block, const CBlockIndex* index) override\n-    {\n-        m_notifications->blockConnected(*block, index->nHeight);\n-    }\n-    void BlockDisconnected(const std::shared_ptr<const CBlock>& block, const CBlockIndex* index) override\n-    {\n-        m_notifications->blockDisconnected(*block, index->nHeight);\n-    }\n-    void UpdatedBlockTip(const CBlockIndex* index, const CBlockIndex* fork_index, bool is_ibd) override\n-    {\n-        m_notifications->updatedBlockTip();\n-    }\n-    void ChainStateFlushed(const CBlockLocator& locator) override { m_notifications->chainStateFlushed(locator); }\n-    std::shared_ptr<Chain::Notifications> m_notifications;\n-};\n-\n-class NotificationsHandlerImpl : public Handler\n-{\n-public:\n-    explicit NotificationsHandlerImpl(std::shared_ptr<Chain::Notifications> notifications)\n-        : m_proxy(std::make_shared<NotificationsProxy>(std::move(notifications)))\n-    {\n-        RegisterSharedValidationInterface(m_proxy);\n-    }\n-    ~NotificationsHandlerImpl() override { disconnect(); }\n-    void disconnect() override\n-    {\n-        if (m_proxy) {\n-            UnregisterSharedValidationInterface(m_proxy);\n-            m_proxy.reset();\n-        }\n-    }\n-    std::shared_ptr<NotificationsProxy> m_proxy;\n-};\n-\n-class RpcHandlerImpl : public Handler\n-{\n-public:\n-    explicit RpcHandlerImpl(const CRPCCommand& command) : m_command(command), m_wrapped_command(&command)\n-    {\n-        m_command.actor = [this](const JSONRPCRequest& request, UniValue& result, bool last_handler) {\n-            if (!m_wrapped_command) return false;\n-            try {\n-                return m_wrapped_command->actor(request, result, last_handler);\n-            } catch (const UniValue& e) {\n-                // If this is not the last handler and a wallet not found\n-                // exception was thrown, return false so the next handler can\n-                // try to handle the request. Otherwise, reraise the exception.\n-                if (!last_handler) {\n-                    const UniValue& code = e[\"code\"];\n-                    if (code.isNum() && code.get_int() == RPC_WALLET_NOT_FOUND) {\n-                        return false;\n-                    }\n-                }\n-                throw;\n-            }\n-        };\n-        ::tableRPC.appendCommand(m_command.name, &m_command);\n-    }\n-\n-    void disconnect() final\n-    {\n-        if (m_wrapped_command) {\n-            m_wrapped_command = nullptr;\n-            ::tableRPC.removeCommand(m_command.name, &m_command);\n-        }\n-    }\n-\n-    ~RpcHandlerImpl() override { disconnect(); }\n-\n-    CRPCCommand m_command;\n-    const CRPCCommand* m_wrapped_command;\n-};\n-\n-class ChainImpl : public Chain\n-{\n-public:\n-    explicit ChainImpl(NodeContext& node) : m_node(node) {}\n-    Optional<int> getHeight() override\n-    {\n-        LOCK(::cs_main);\n-        int height = ::ChainActive().Height();\n-        if (height >= 0) {\n-            return height;\n-        }\n-        return nullopt;\n-    }\n-    Optional<int> getBlockHeight(const uint256& hash) override\n-    {\n-        LOCK(::cs_main);\n-        CBlockIndex* block = LookupBlockIndex(hash);\n-        if (block && ::ChainActive().Contains(block)) {\n-            return block->nHeight;\n-        }\n-        return nullopt;\n-    }\n-    uint256 getBlockHash(int height) override\n-    {\n-        LOCK(::cs_main);\n-        CBlockIndex* block = ::ChainActive()[height];\n-        assert(block);\n-        return block->GetBlockHash();\n-    }\n-    bool haveBlockOnDisk(int height) override\n-    {\n-        LOCK(cs_main);\n-        CBlockIndex* block = ::ChainActive()[height];\n-        return block && ((block->nStatus & BLOCK_HAVE_DATA) != 0) && block->nTx > 0;\n-    }\n-    Optional<int> findFirstBlockWithTimeAndHeight(int64_t time, int height, uint256* hash) override\n-    {\n-        LOCK(cs_main);\n-        CBlockIndex* block = ::ChainActive().FindEarliestAtLeast(time, height);\n-        if (block) {\n-            if (hash) *hash = block->GetBlockHash();\n-            return block->nHeight;\n-        }\n-        return nullopt;\n-    }\n-    CBlockLocator getTipLocator() override\n-    {\n-        LOCK(cs_main);\n-        return ::ChainActive().GetLocator();\n-    }\n-    bool checkFinalTx(const CTransaction& tx) override\n-    {\n-        LOCK(cs_main);\n-        return CheckFinalTx(tx);\n-    }\n-    Optional<int> findLocatorFork(const CBlockLocator& locator) override\n-    {\n-        LOCK(cs_main);\n-        if (CBlockIndex* fork = FindForkInGlobalIndex(::ChainActive(), locator)) {\n-            return fork->nHeight;\n-        }\n-        return nullopt;\n-    }\n-    bool findBlock(const uint256& hash, const FoundBlock& block) override\n-    {\n-        WAIT_LOCK(cs_main, lock);\n-        return FillBlock(LookupBlockIndex(hash), block, lock);\n-    }\n-    bool findFirstBlockWithTimeAndHeight(int64_t min_time, int min_height, const FoundBlock& block) override\n-    {\n-        WAIT_LOCK(cs_main, lock);\n-        return FillBlock(ChainActive().FindEarliestAtLeast(min_time, min_height), block, lock);\n-    }\n-    bool findNextBlock(const uint256& block_hash, int block_height, const FoundBlock& next, bool* reorg) override {\n-        WAIT_LOCK(cs_main, lock);\n-        CBlockIndex* block = ChainActive()[block_height];\n-        if (block && block->GetBlockHash() != block_hash) block = nullptr;\n-        if (reorg) *reorg = !block;\n-        return FillBlock(block ? ChainActive()[block_height + 1] : nullptr, next, lock);\n-    }\n-    bool findAncestorByHeight(const uint256& block_hash, int ancestor_height, const FoundBlock& ancestor_out) override\n-    {\n-        WAIT_LOCK(cs_main, lock);\n-        if (const CBlockIndex* block = LookupBlockIndex(block_hash)) {\n-            if (const CBlockIndex* ancestor = block->GetAncestor(ancestor_height)) {\n-                return FillBlock(ancestor, ancestor_out, lock);\n-            }\n-        }\n-        return FillBlock(nullptr, ancestor_out, lock);\n-    }\n-    bool findAncestorByHash(const uint256& block_hash, const uint256& ancestor_hash, const FoundBlock& ancestor_out) override\n-    {\n-        WAIT_LOCK(cs_main, lock);\n-        const CBlockIndex* block = LookupBlockIndex(block_hash);\n-        const CBlockIndex* ancestor = LookupBlockIndex(ancestor_hash);\n-        if (block && ancestor && block->GetAncestor(ancestor->nHeight) != ancestor) ancestor = nullptr;\n-        return FillBlock(ancestor, ancestor_out, lock);\n-    }\n-    bool findCommonAncestor(const uint256& block_hash1, const uint256& block_hash2, const FoundBlock& ancestor_out, const FoundBlock& block1_out, const FoundBlock& block2_out) override\n-    {\n-        WAIT_LOCK(cs_main, lock);\n-        const CBlockIndex* block1 = LookupBlockIndex(block_hash1);\n-        const CBlockIndex* block2 = LookupBlockIndex(block_hash2);\n-        const CBlockIndex* ancestor = block1 && block2 ? LastCommonAncestor(block1, block2) : nullptr;\n-        // Using & instead of && below to avoid short circuiting and leaving\n-        // output uninitialized.\n-        return FillBlock(ancestor, ancestor_out, lock) & FillBlock(block1, block1_out, lock) & FillBlock(block2, block2_out, lock);\n-    }\n-    void findCoins(std::map<COutPoint, Coin>& coins) override { return FindCoins(m_node, coins); }\n-    double guessVerificationProgress(const uint256& block_hash) override\n-    {\n-        LOCK(cs_main);\n-        return GuessVerificationProgress(Params().TxData(), LookupBlockIndex(block_hash));\n-    }\n-    bool hasBlocks(const uint256& block_hash, int min_height, Optional<int> max_height) override\n-    {\n-        // hasBlocks returns true if all ancestors of block_hash in specified\n-        // range have block data (are not pruned), false if any ancestors in\n-        // specified range are missing data.\n-        //\n-        // For simplicity and robustness, min_height and max_height are only\n-        // used to limit the range, and passing min_height that's too low or\n-        // max_height that's too high will not crash or change the result.\n-        LOCK(::cs_main);\n-        if (CBlockIndex* block = LookupBlockIndex(block_hash)) {\n-            if (max_height && block->nHeight >= *max_height) block = block->GetAncestor(*max_height);\n-            for (; block->nStatus & BLOCK_HAVE_DATA; block = block->pprev) {\n-                // Check pprev to not segfault if min_height is too low\n-                if (block->nHeight <= min_height || !block->pprev) return true;\n-            }\n-        }\n-        return false;\n-    }\n-    RBFTransactionState isRBFOptIn(const CTransaction& tx) override\n-    {\n-        if (!m_node.mempool) return IsRBFOptInEmptyMempool(tx);\n-        LOCK(m_node.mempool->cs);\n-        return IsRBFOptIn(tx, *m_node.mempool);\n-    }\n-    bool hasDescendantsInMempool(const uint256& txid) override\n-    {\n-        if (!m_node.mempool) return false;\n-        LOCK(m_node.mempool->cs);\n-        auto it = m_node.mempool->GetIter(txid);\n-        return it && (*it)->GetCountWithDescendants() > 1;\n-    }\n-    bool broadcastTransaction(const CTransactionRef& tx,\n-        const CAmount& max_tx_fee,\n-        bool relay,\n-        std::string& err_string) override\n-    {\n-        const TransactionError err = BroadcastTransaction(m_node, tx, err_string, max_tx_fee, relay, /*wait_callback*/ false);\n-        // Chain clients only care about failures to accept the tx to the mempool. Disregard non-mempool related failures.\n-        // Note: this will need to be updated if BroadcastTransactions() is updated to return other non-mempool failures\n-        // that Chain clients do not need to know about.\n-        return TransactionError::OK == err;\n-    }\n-    void getTransactionAncestry(const uint256& txid, size_t& ancestors, size_t& descendants) override\n-    {\n-        ancestors = descendants = 0;\n-        if (!m_node.mempool) return;\n-        m_node.mempool->GetTransactionAncestry(txid, ancestors, descendants);\n-    }\n-    void getPackageLimits(unsigned int& limit_ancestor_count, unsigned int& limit_descendant_count) override\n-    {\n-        limit_ancestor_count = gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT);\n-        limit_descendant_count = gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT);\n-    }\n-    bool checkChainLimits(const CTransactionRef& tx) override\n-    {\n-        if (!m_node.mempool) return true;\n-        LockPoints lp;\n-        CTxMemPoolEntry entry(tx, 0, 0, 0, false, 0, lp);\n-        CTxMemPool::setEntries ancestors;\n-        auto limit_ancestor_count = gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT);\n-        auto limit_ancestor_size = gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT) * 1000;\n-        auto limit_descendant_count = gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT);\n-        auto limit_descendant_size = gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT) * 1000;\n-        std::string unused_error_string;\n-        LOCK(m_node.mempool->cs);\n-        return m_node.mempool->CalculateMemPoolAncestors(\n-            entry, ancestors, limit_ancestor_count, limit_ancestor_size,\n-            limit_descendant_count, limit_descendant_size, unused_error_string);\n-    }\n-    CFeeRate estimateSmartFee(int num_blocks, bool conservative, FeeCalculation* calc) override\n-    {\n-        return ::feeEstimator.estimateSmartFee(num_blocks, calc, conservative);\n-    }\n-    unsigned int estimateMaxBlocks() override\n-    {\n-        return ::feeEstimator.HighestTargetTracked(FeeEstimateHorizon::LONG_HALFLIFE);\n-    }\n-    CFeeRate mempoolMinFee() override\n-    {\n-        if (!m_node.mempool) return {};\n-        return m_node.mempool->GetMinFee(gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n-    }\n-    CFeeRate relayMinFee() override { return ::minRelayTxFee; }\n-    CFeeRate relayIncrementalFee() override { return ::incrementalRelayFee; }\n-    CFeeRate relayDustFee() override { return ::dustRelayFee; }\n-    bool havePruned() override\n-    {\n-        LOCK(cs_main);\n-        return ::fHavePruned;\n-    }\n-    bool isReadyToBroadcast() override { return !::fImporting && !::fReindex && !isInitialBlockDownload(); }\n-    bool isInitialBlockDownload() override { return ::ChainstateActive().IsInitialBlockDownload(); }\n-    bool shutdownRequested() override { return ShutdownRequested(); }\n-    int64_t getAdjustedTime() override { return GetAdjustedTime(); }\n-    void initMessage(const std::string& message) override { ::uiInterface.InitMessage(message); }\n-    void initWarning(const bilingual_str& message) override { InitWarning(message); }\n-    void initError(const bilingual_str& message) override { InitError(message); }\n-    void showProgress(const std::string& title, int progress, bool resume_possible) override\n-    {\n-        ::uiInterface.ShowProgress(title, progress, resume_possible);\n-    }\n-    std::unique_ptr<Handler> handleNotifications(std::shared_ptr<Notifications> notifications) override\n-    {\n-        return MakeUnique<NotificationsHandlerImpl>(std::move(notifications));\n-    }\n-    void waitForNotificationsIfTipChanged(const uint256& old_tip) override\n-    {\n-        if (!old_tip.IsNull()) {\n-            LOCK(::cs_main);\n-            if (old_tip == ::ChainActive().Tip()->GetBlockHash()) return;\n-        }\n-        SyncWithValidationInterfaceQueue();\n-    }\n-    std::unique_ptr<Handler> handleRpc(const CRPCCommand& command) override\n-    {\n-        return MakeUnique<RpcHandlerImpl>(command);\n-    }\n-    bool rpcEnableDeprecated(const std::string& method) override { return IsDeprecatedRPCEnabled(method); }\n-    void rpcRunLater(const std::string& name, std::function<void()> fn, int64_t seconds) override\n-    {\n-        RPCRunLater(name, std::move(fn), seconds);\n-    }\n-    int rpcSerializationFlags() override { return RPCSerializationFlags(); }\n-    util::SettingsValue getRwSetting(const std::string& name) override\n-    {\n-        util::SettingsValue result;\n-        gArgs.LockSettings([&](const util::Settings& settings) {\n-            if (const util::SettingsValue* value = util::FindKey(settings.rw_settings, name)) {\n-                result = *value;\n-            }\n-        });\n-        return result;\n-    }\n-    bool updateRwSetting(const std::string& name, const util::SettingsValue& value) override\n-    {\n-        gArgs.LockSettings([&](util::Settings& settings) {\n-            if (value.isNull()) {\n-                settings.rw_settings.erase(name);\n-            } else {\n-                settings.rw_settings[name] = value;\n-            }\n-        });\n-        return gArgs.WriteSettingsFile();\n-    }\n-    void requestMempoolTransactions(Notifications& notifications) override\n-    {\n-        if (!m_node.mempool) return;\n-        LOCK2(::cs_main, m_node.mempool->cs);\n-        for (const CTxMemPoolEntry& entry : m_node.mempool->mapTx) {\n-            notifications.transactionAddedToMempool(entry.GetSharedTx(), 0 /* mempool_sequence */);\n-        }\n-    }\n-    NodeContext& m_node;\n-};\n-} // namespace\n-\n-std::unique_ptr<Chain> MakeChain(NodeContext& node) { return MakeUnique<ChainImpl>(node); }\n-\n-} // namespace interfaces"
      },
      {
        "sha": "77a5957a568e1ed1aabd60cd75b00e3915b65095",
        "filename": "src/node/interfaces.cpp",
        "status": "modified",
        "additions": 390,
        "deletions": 5,
        "changes": 395,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2a26771d8161d30be1853a35acfee588cce03634/src/node/interfaces.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2a26771d8161d30be1853a35acfee588cce03634/src/node/interfaces.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/interfaces.cpp?ref=2a26771d8161d30be1853a35acfee588cce03634",
        "patch": "@@ -2,47 +2,58 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#include <interfaces/node.h>\n-\n #include <addrdb.h>\n #include <banman.h>\n+#include <boost/signals2/signal.hpp>\n #include <chain.h>\n #include <chainparams.h>\n #include <init.h>\n #include <interfaces/chain.h>\n #include <interfaces/handler.h>\n+#include <interfaces/node.h>\n #include <interfaces/wallet.h>\n #include <net.h>\n #include <net_processing.h>\n #include <netaddress.h>\n #include <netbase.h>\n+#include <node/coin.h>\n #include <node/context.h>\n+#include <node/transaction.h>\n #include <node/ui_interface.h>\n #include <policy/feerate.h>\n #include <policy/fees.h>\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n #include <policy/settings.h>\n #include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <rpc/protocol.h>\n #include <rpc/server.h>\n #include <shutdown.h>\n #include <support/allocators/secure.h>\n #include <sync.h>\n+#include <timedata.h>\n #include <txmempool.h>\n+#include <uint256.h>\n+#include <univalue.h>\n #include <util/check.h>\n #include <util/ref.h>\n #include <util/system.h>\n #include <util/translation.h>\n #include <validation.h>\n+#include <validationinterface.h>\n #include <warnings.h>\n \n #if defined(HAVE_CONFIG_H)\n #include <config/bitcoin-config.h>\n #endif\n \n-#include <univalue.h>\n-\n-#include <boost/signals2/signal.hpp>\n+#include <memory>\n+#include <utility>\n \n using interfaces::BlockTip;\n+using interfaces::Chain;\n+using interfaces::FoundBlock;\n using interfaces::Handler;\n using interfaces::MakeHandler;\n using interfaces::Node;\n@@ -300,9 +311,383 @@ class NodeImpl : public Node\n     NodeContext* m_context{nullptr};\n     util::Ref m_context_ref;\n };\n+\n+bool FillBlock(const CBlockIndex* index, const FoundBlock& block, UniqueLock<RecursiveMutex>& lock)\n+{\n+    if (!index) return false;\n+    if (block.m_hash) *block.m_hash = index->GetBlockHash();\n+    if (block.m_height) *block.m_height = index->nHeight;\n+    if (block.m_time) *block.m_time = index->GetBlockTime();\n+    if (block.m_max_time) *block.m_max_time = index->GetBlockTimeMax();\n+    if (block.m_mtp_time) *block.m_mtp_time = index->GetMedianTimePast();\n+    if (block.m_data) {\n+        REVERSE_LOCK(lock);\n+        if (!ReadBlockFromDisk(*block.m_data, index, Params().GetConsensus())) block.m_data->SetNull();\n+    }\n+    return true;\n+}\n+\n+class NotificationsProxy : public CValidationInterface\n+{\n+public:\n+    explicit NotificationsProxy(std::shared_ptr<Chain::Notifications> notifications)\n+        : m_notifications(std::move(notifications)) {}\n+    virtual ~NotificationsProxy() = default;\n+    void TransactionAddedToMempool(const CTransactionRef& tx, uint64_t mempool_sequence) override\n+    {\n+        m_notifications->transactionAddedToMempool(tx, mempool_sequence);\n+    }\n+    void TransactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t mempool_sequence) override\n+    {\n+        m_notifications->transactionRemovedFromMempool(tx, reason, mempool_sequence);\n+    }\n+    void BlockConnected(const std::shared_ptr<const CBlock>& block, const CBlockIndex* index) override\n+    {\n+        m_notifications->blockConnected(*block, index->nHeight);\n+    }\n+    void BlockDisconnected(const std::shared_ptr<const CBlock>& block, const CBlockIndex* index) override\n+    {\n+        m_notifications->blockDisconnected(*block, index->nHeight);\n+    }\n+    void UpdatedBlockTip(const CBlockIndex* index, const CBlockIndex* fork_index, bool is_ibd) override\n+    {\n+        m_notifications->updatedBlockTip();\n+    }\n+    void ChainStateFlushed(const CBlockLocator& locator) override { m_notifications->chainStateFlushed(locator); }\n+    std::shared_ptr<Chain::Notifications> m_notifications;\n+};\n+\n+class NotificationsHandlerImpl : public Handler\n+{\n+public:\n+    explicit NotificationsHandlerImpl(std::shared_ptr<Chain::Notifications> notifications)\n+        : m_proxy(std::make_shared<NotificationsProxy>(std::move(notifications)))\n+    {\n+        RegisterSharedValidationInterface(m_proxy);\n+    }\n+    ~NotificationsHandlerImpl() override { disconnect(); }\n+    void disconnect() override\n+    {\n+        if (m_proxy) {\n+            UnregisterSharedValidationInterface(m_proxy);\n+            m_proxy.reset();\n+        }\n+    }\n+    std::shared_ptr<NotificationsProxy> m_proxy;\n+};\n+\n+class RpcHandlerImpl : public Handler\n+{\n+public:\n+    explicit RpcHandlerImpl(const CRPCCommand& command) : m_command(command), m_wrapped_command(&command)\n+    {\n+        m_command.actor = [this](const JSONRPCRequest& request, UniValue& result, bool last_handler) {\n+            if (!m_wrapped_command) return false;\n+            try {\n+                return m_wrapped_command->actor(request, result, last_handler);\n+            } catch (const UniValue& e) {\n+                // If this is not the last handler and a wallet not found\n+                // exception was thrown, return false so the next handler can\n+                // try to handle the request. Otherwise, reraise the exception.\n+                if (!last_handler) {\n+                    const UniValue& code = e[\"code\"];\n+                    if (code.isNum() && code.get_int() == RPC_WALLET_NOT_FOUND) {\n+                        return false;\n+                    }\n+                }\n+                throw;\n+            }\n+        };\n+        ::tableRPC.appendCommand(m_command.name, &m_command);\n+    }\n+\n+    void disconnect() final\n+    {\n+        if (m_wrapped_command) {\n+            m_wrapped_command = nullptr;\n+            ::tableRPC.removeCommand(m_command.name, &m_command);\n+        }\n+    }\n+\n+    ~RpcHandlerImpl() override { disconnect(); }\n+\n+    CRPCCommand m_command;\n+    const CRPCCommand* m_wrapped_command;\n+};\n+\n+class ChainImpl : public Chain\n+{\n+public:\n+    explicit ChainImpl(NodeContext& node) : m_node(node) {}\n+    Optional<int> getHeight() override\n+    {\n+        LOCK(::cs_main);\n+        int height = ::ChainActive().Height();\n+        if (height >= 0) {\n+            return height;\n+        }\n+        return nullopt;\n+    }\n+    Optional<int> getBlockHeight(const uint256& hash) override\n+    {\n+        LOCK(::cs_main);\n+        CBlockIndex* block = LookupBlockIndex(hash);\n+        if (block && ::ChainActive().Contains(block)) {\n+            return block->nHeight;\n+        }\n+        return nullopt;\n+    }\n+    uint256 getBlockHash(int height) override\n+    {\n+        LOCK(::cs_main);\n+        CBlockIndex* block = ::ChainActive()[height];\n+        assert(block);\n+        return block->GetBlockHash();\n+    }\n+    bool haveBlockOnDisk(int height) override\n+    {\n+        LOCK(cs_main);\n+        CBlockIndex* block = ::ChainActive()[height];\n+        return block && ((block->nStatus & BLOCK_HAVE_DATA) != 0) && block->nTx > 0;\n+    }\n+    Optional<int> findFirstBlockWithTimeAndHeight(int64_t time, int height, uint256* hash) override\n+    {\n+        LOCK(cs_main);\n+        CBlockIndex* block = ::ChainActive().FindEarliestAtLeast(time, height);\n+        if (block) {\n+            if (hash) *hash = block->GetBlockHash();\n+            return block->nHeight;\n+        }\n+        return nullopt;\n+    }\n+    CBlockLocator getTipLocator() override\n+    {\n+        LOCK(cs_main);\n+        return ::ChainActive().GetLocator();\n+    }\n+    bool checkFinalTx(const CTransaction& tx) override\n+    {\n+        LOCK(cs_main);\n+        return CheckFinalTx(tx);\n+    }\n+    Optional<int> findLocatorFork(const CBlockLocator& locator) override\n+    {\n+        LOCK(cs_main);\n+        if (CBlockIndex* fork = FindForkInGlobalIndex(::ChainActive(), locator)) {\n+            return fork->nHeight;\n+        }\n+        return nullopt;\n+    }\n+    bool findBlock(const uint256& hash, const FoundBlock& block) override\n+    {\n+        WAIT_LOCK(cs_main, lock);\n+        return FillBlock(LookupBlockIndex(hash), block, lock);\n+    }\n+    bool findFirstBlockWithTimeAndHeight(int64_t min_time, int min_height, const FoundBlock& block) override\n+    {\n+        WAIT_LOCK(cs_main, lock);\n+        return FillBlock(ChainActive().FindEarliestAtLeast(min_time, min_height), block, lock);\n+    }\n+    bool findNextBlock(const uint256& block_hash, int block_height, const FoundBlock& next, bool* reorg) override {\n+        WAIT_LOCK(cs_main, lock);\n+        CBlockIndex* block = ChainActive()[block_height];\n+        if (block && block->GetBlockHash() != block_hash) block = nullptr;\n+        if (reorg) *reorg = !block;\n+        return FillBlock(block ? ChainActive()[block_height + 1] : nullptr, next, lock);\n+    }\n+    bool findAncestorByHeight(const uint256& block_hash, int ancestor_height, const FoundBlock& ancestor_out) override\n+    {\n+        WAIT_LOCK(cs_main, lock);\n+        if (const CBlockIndex* block = LookupBlockIndex(block_hash)) {\n+            if (const CBlockIndex* ancestor = block->GetAncestor(ancestor_height)) {\n+                return FillBlock(ancestor, ancestor_out, lock);\n+            }\n+        }\n+        return FillBlock(nullptr, ancestor_out, lock);\n+    }\n+    bool findAncestorByHash(const uint256& block_hash, const uint256& ancestor_hash, const FoundBlock& ancestor_out) override\n+    {\n+        WAIT_LOCK(cs_main, lock);\n+        const CBlockIndex* block = LookupBlockIndex(block_hash);\n+        const CBlockIndex* ancestor = LookupBlockIndex(ancestor_hash);\n+        if (block && ancestor && block->GetAncestor(ancestor->nHeight) != ancestor) ancestor = nullptr;\n+        return FillBlock(ancestor, ancestor_out, lock);\n+    }\n+    bool findCommonAncestor(const uint256& block_hash1, const uint256& block_hash2, const FoundBlock& ancestor_out, const FoundBlock& block1_out, const FoundBlock& block2_out) override\n+    {\n+        WAIT_LOCK(cs_main, lock);\n+        const CBlockIndex* block1 = LookupBlockIndex(block_hash1);\n+        const CBlockIndex* block2 = LookupBlockIndex(block_hash2);\n+        const CBlockIndex* ancestor = block1 && block2 ? LastCommonAncestor(block1, block2) : nullptr;\n+        // Using & instead of && below to avoid short circuiting and leaving\n+        // output uninitialized.\n+        return FillBlock(ancestor, ancestor_out, lock) & FillBlock(block1, block1_out, lock) & FillBlock(block2, block2_out, lock);\n+    }\n+    void findCoins(std::map<COutPoint, Coin>& coins) override { return FindCoins(m_node, coins); }\n+    double guessVerificationProgress(const uint256& block_hash) override\n+    {\n+        LOCK(cs_main);\n+        return GuessVerificationProgress(Params().TxData(), LookupBlockIndex(block_hash));\n+    }\n+    bool hasBlocks(const uint256& block_hash, int min_height, Optional<int> max_height) override\n+    {\n+        // hasBlocks returns true if all ancestors of block_hash in specified\n+        // range have block data (are not pruned), false if any ancestors in\n+        // specified range are missing data.\n+        //\n+        // For simplicity and robustness, min_height and max_height are only\n+        // used to limit the range, and passing min_height that's too low or\n+        // max_height that's too high will not crash or change the result.\n+        LOCK(::cs_main);\n+        if (CBlockIndex* block = LookupBlockIndex(block_hash)) {\n+            if (max_height && block->nHeight >= *max_height) block = block->GetAncestor(*max_height);\n+            for (; block->nStatus & BLOCK_HAVE_DATA; block = block->pprev) {\n+                // Check pprev to not segfault if min_height is too low\n+                if (block->nHeight <= min_height || !block->pprev) return true;\n+            }\n+        }\n+        return false;\n+    }\n+    RBFTransactionState isRBFOptIn(const CTransaction& tx) override\n+    {\n+        if (!m_node.mempool) return IsRBFOptInEmptyMempool(tx);\n+        LOCK(m_node.mempool->cs);\n+        return IsRBFOptIn(tx, *m_node.mempool);\n+    }\n+    bool hasDescendantsInMempool(const uint256& txid) override\n+    {\n+        if (!m_node.mempool) return false;\n+        LOCK(m_node.mempool->cs);\n+        auto it = m_node.mempool->GetIter(txid);\n+        return it && (*it)->GetCountWithDescendants() > 1;\n+    }\n+    bool broadcastTransaction(const CTransactionRef& tx,\n+        const CAmount& max_tx_fee,\n+        bool relay,\n+        std::string& err_string) override\n+    {\n+        const TransactionError err = BroadcastTransaction(m_node, tx, err_string, max_tx_fee, relay, /*wait_callback*/ false);\n+        // Chain clients only care about failures to accept the tx to the mempool. Disregard non-mempool related failures.\n+        // Note: this will need to be updated if BroadcastTransactions() is updated to return other non-mempool failures\n+        // that Chain clients do not need to know about.\n+        return TransactionError::OK == err;\n+    }\n+    void getTransactionAncestry(const uint256& txid, size_t& ancestors, size_t& descendants) override\n+    {\n+        ancestors = descendants = 0;\n+        if (!m_node.mempool) return;\n+        m_node.mempool->GetTransactionAncestry(txid, ancestors, descendants);\n+    }\n+    void getPackageLimits(unsigned int& limit_ancestor_count, unsigned int& limit_descendant_count) override\n+    {\n+        limit_ancestor_count = gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT);\n+        limit_descendant_count = gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT);\n+    }\n+    bool checkChainLimits(const CTransactionRef& tx) override\n+    {\n+        if (!m_node.mempool) return true;\n+        LockPoints lp;\n+        CTxMemPoolEntry entry(tx, 0, 0, 0, false, 0, lp);\n+        CTxMemPool::setEntries ancestors;\n+        auto limit_ancestor_count = gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT);\n+        auto limit_ancestor_size = gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT) * 1000;\n+        auto limit_descendant_count = gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT);\n+        auto limit_descendant_size = gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT) * 1000;\n+        std::string unused_error_string;\n+        LOCK(m_node.mempool->cs);\n+        return m_node.mempool->CalculateMemPoolAncestors(\n+            entry, ancestors, limit_ancestor_count, limit_ancestor_size,\n+            limit_descendant_count, limit_descendant_size, unused_error_string);\n+    }\n+    CFeeRate estimateSmartFee(int num_blocks, bool conservative, FeeCalculation* calc) override\n+    {\n+        return ::feeEstimator.estimateSmartFee(num_blocks, calc, conservative);\n+    }\n+    unsigned int estimateMaxBlocks() override\n+    {\n+        return ::feeEstimator.HighestTargetTracked(FeeEstimateHorizon::LONG_HALFLIFE);\n+    }\n+    CFeeRate mempoolMinFee() override\n+    {\n+        if (!m_node.mempool) return {};\n+        return m_node.mempool->GetMinFee(gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    }\n+    CFeeRate relayMinFee() override { return ::minRelayTxFee; }\n+    CFeeRate relayIncrementalFee() override { return ::incrementalRelayFee; }\n+    CFeeRate relayDustFee() override { return ::dustRelayFee; }\n+    bool havePruned() override\n+    {\n+        LOCK(cs_main);\n+        return ::fHavePruned;\n+    }\n+    bool isReadyToBroadcast() override { return !::fImporting && !::fReindex && !isInitialBlockDownload(); }\n+    bool isInitialBlockDownload() override { return ::ChainstateActive().IsInitialBlockDownload(); }\n+    bool shutdownRequested() override { return ShutdownRequested(); }\n+    int64_t getAdjustedTime() override { return GetAdjustedTime(); }\n+    void initMessage(const std::string& message) override { ::uiInterface.InitMessage(message); }\n+    void initWarning(const bilingual_str& message) override { InitWarning(message); }\n+    void initError(const bilingual_str& message) override { InitError(message); }\n+    void showProgress(const std::string& title, int progress, bool resume_possible) override\n+    {\n+        ::uiInterface.ShowProgress(title, progress, resume_possible);\n+    }\n+    std::unique_ptr<Handler> handleNotifications(std::shared_ptr<Notifications> notifications) override\n+    {\n+        return MakeUnique<NotificationsHandlerImpl>(std::move(notifications));\n+    }\n+    void waitForNotificationsIfTipChanged(const uint256& old_tip) override\n+    {\n+        if (!old_tip.IsNull()) {\n+            LOCK(::cs_main);\n+            if (old_tip == ::ChainActive().Tip()->GetBlockHash()) return;\n+        }\n+        SyncWithValidationInterfaceQueue();\n+    }\n+    std::unique_ptr<Handler> handleRpc(const CRPCCommand& command) override\n+    {\n+        return MakeUnique<RpcHandlerImpl>(command);\n+    }\n+    bool rpcEnableDeprecated(const std::string& method) override { return IsDeprecatedRPCEnabled(method); }\n+    void rpcRunLater(const std::string& name, std::function<void()> fn, int64_t seconds) override\n+    {\n+        RPCRunLater(name, std::move(fn), seconds);\n+    }\n+    int rpcSerializationFlags() override { return RPCSerializationFlags(); }\n+    util::SettingsValue getRwSetting(const std::string& name) override\n+    {\n+        util::SettingsValue result;\n+        gArgs.LockSettings([&](const util::Settings& settings) {\n+            if (const util::SettingsValue* value = util::FindKey(settings.rw_settings, name)) {\n+                result = *value;\n+            }\n+        });\n+        return result;\n+    }\n+    bool updateRwSetting(const std::string& name, const util::SettingsValue& value) override\n+    {\n+        gArgs.LockSettings([&](util::Settings& settings) {\n+            if (value.isNull()) {\n+                settings.rw_settings.erase(name);\n+            } else {\n+                settings.rw_settings[name] = value;\n+            }\n+        });\n+        return gArgs.WriteSettingsFile();\n+    }\n+    void requestMempoolTransactions(Notifications& notifications) override\n+    {\n+        if (!m_node.mempool) return;\n+        LOCK2(::cs_main, m_node.mempool->cs);\n+        for (const CTxMemPoolEntry& entry : m_node.mempool->mapTx) {\n+            notifications.transactionAddedToMempool(entry.GetSharedTx(), 0 /* mempool_sequence */);\n+        }\n+    }\n+    NodeContext& m_node;\n+};\n } // namespace\n } // namespace node\n \n namespace interfaces {\n std::unique_ptr<Node> MakeNode(NodeContext* context) { return MakeUnique<node::NodeImpl>(context); }\n+std::unique_ptr<Chain> MakeChain(NodeContext& context) { return MakeUnique<node::ChainImpl>(context); }\n } // namespace interfaces"
      }
    ]
  },
  {
    "sha": "629a9299b2a7241a3fa7d597cb34abcbe1af9255",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2MjlhOTI5OWIyYTcyNDFhM2ZhN2Q1OTdjYjM0YWJjYmUxYWY5MjU1",
    "commit": {
      "author": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2020-11-24T15:20:16Z"
      },
      "committer": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2020-11-24T15:20:16Z"
      },
      "message": "Move WalletImpl from interfaces/wallet.cpp to wallet/interfaces.cpp",
      "tree": {
        "sha": "f3d1e9436dab40f1d7eecbabde4f5d93d91e33cb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f3d1e9436dab40f1d7eecbabde4f5d93d91e33cb"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/629a9299b2a7241a3fa7d597cb34abcbe1af9255",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/629a9299b2a7241a3fa7d597cb34abcbe1af9255",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/629a9299b2a7241a3fa7d597cb34abcbe1af9255",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/629a9299b2a7241a3fa7d597cb34abcbe1af9255/comments",
    "author": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2a26771d8161d30be1853a35acfee588cce03634",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2a26771d8161d30be1853a35acfee588cce03634",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2a26771d8161d30be1853a35acfee588cce03634"
      }
    ],
    "stats": {
      "total": 27,
      "additions": 20,
      "deletions": 7
    },
    "files": [
      {
        "sha": "9f61670447c5e40c6e278bb8d0ad4eeb7711d5f7",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/629a9299b2a7241a3fa7d597cb34abcbe1af9255/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/629a9299b2a7241a3fa7d597cb34abcbe1af9255/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=629a9299b2a7241a3fa7d597cb34abcbe1af9255",
        "patch": "@@ -358,13 +358,13 @@ endif\n libbitcoin_wallet_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) $(SQLITE_CFLAGS)\n libbitcoin_wallet_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n libbitcoin_wallet_a_SOURCES = \\\n-  interfaces/wallet.cpp \\\n   wallet/coincontrol.cpp \\\n   wallet/context.cpp \\\n   wallet/crypter.cpp \\\n   wallet/db.cpp \\\n   wallet/feebumper.cpp \\\n   wallet/fees.cpp \\\n+  wallet/interfaces.cpp \\\n   wallet/load.cpp \\\n   wallet/rpcdump.cpp \\\n   wallet/rpcwallet.cpp \\"
      },
      {
        "sha": "3fbba9ab9214dc710f781d74e4477480bc3bed4d",
        "filename": "src/wallet/interfaces.cpp",
        "status": "renamed",
        "additions": 19,
        "deletions": 6,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/629a9299b2a7241a3fa7d597cb34abcbe1af9255/src/wallet/interfaces.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/629a9299b2a7241a3fa7d597cb34abcbe1af9255/src/wallet/interfaces.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/interfaces.cpp?ref=629a9299b2a7241a3fa7d597cb34abcbe1af9255",
        "patch": "@@ -31,9 +31,22 @@\n #include <utility>\n #include <vector>\n \n-namespace interfaces {\n-namespace {\n+using interfaces::Chain;\n+using interfaces::FoundBlock;\n+using interfaces::Handler;\n+using interfaces::MakeHandler;\n+using interfaces::Wallet;\n+using interfaces::WalletAddress;\n+using interfaces::WalletBalances;\n+using interfaces::WalletClient;\n+using interfaces::WalletOrderForm;\n+using interfaces::WalletTx;\n+using interfaces::WalletTxOut;\n+using interfaces::WalletTxStatus;\n+using interfaces::WalletValueMap;\n \n+namespace wallet {\n+namespace {\n //! Construct wallet tx struct.\n WalletTx MakeWalletTx(CWallet& wallet, const CWalletTx& wtx)\n {\n@@ -561,14 +574,14 @@ class WalletClientImpl : public WalletClient\n     std::vector<std::unique_ptr<Handler>> m_rpc_handlers;\n     std::list<CRPCCommand> m_rpc_commands;\n };\n-\n } // namespace\n+} // namespace wallet\n \n-std::unique_ptr<Wallet> MakeWallet(const std::shared_ptr<CWallet>& wallet) { return wallet ? MakeUnique<WalletImpl>(wallet) : nullptr; }\n+namespace interfaces {\n+std::unique_ptr<Wallet> MakeWallet(const std::shared_ptr<CWallet>& wallet) { return wallet ? MakeUnique<wallet::WalletImpl>(wallet) : nullptr; }\n \n std::unique_ptr<WalletClient> MakeWalletClient(Chain& chain, ArgsManager& args)\n {\n-    return MakeUnique<WalletClientImpl>(chain, args);\n+    return MakeUnique<wallet::WalletClientImpl>(chain, args);\n }\n-\n } // namespace interfaces",
        "previous_filename": "src/interfaces/wallet.cpp"
      }
    ]
  }
]