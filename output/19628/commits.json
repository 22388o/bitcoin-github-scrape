[
  {
    "sha": "1ea57ad67406b3aaaef5254bc2fa7e4134f3a6df",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxZWE1N2FkNjc0MDZiM2FhYWVmNTI1NGJjMmZhN2U0MTM0ZjNhNmRm",
    "commit": {
      "author": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2020-08-24T19:03:31Z"
      },
      "committer": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2020-08-24T19:50:59Z"
      },
      "message": "net: don't accept non-left-contiguous netmasks\n\nA netmask that contains 1-bits after 0-bits (the 1-bits are not\ncontiguous on the left side) is invalid [1] [2].\n\nThe code before this PR used to parse and accept such\nnon-left-contiguous netmasks. However, a coming change that will alter\n`CNetAddr::ip` to have flexible size would make juggling with such\nnetmasks more difficult, thus drop support for those.\n\n[1] https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#Subnet_masks\n[2] https://tools.ietf.org/html/rfc4632#section-5.1",
      "tree": {
        "sha": "6c79a8f12caca034006db2e2320ce2339411ff0c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6c79a8f12caca034006db2e2320ce2339411ff0c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1ea57ad67406b3aaaef5254bc2fa7e4134f3a6df",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQQzBAABCAAdFiEE5k2NRWFNsHVF2czBVN8G9ktVy78FAl9EGiMACgkQVN8G9ktV\ny7+1Ch/7ByUx8hxdgV8Ol7TLsInolXyy2lKKFvvPBo+JUYAc6njlfB6SkiooaCYZ\n1+0XE3n/l5AnLlzQ/cxIKL2BA2jSl5atYOr3WVKmqf11RG2ebayfMwcdsxwCGDg9\nHKdysROdTwbiKs9AsXecIwy9GYLewrXVcKgVTGoRMKDDWJ66NgLXhGDav2lFMXj1\nP387qXGjUeLHwxtpkGckCx7Mn13RzinV4x1Pu4oZdnnh7ovohGf2DifL14W2p4li\nEHIUnOZNxiuUGHR/8a0fhHlWSITcOsdCYwMnXmncbaokQllsaZMGgKmvf14a14w2\n7cFJml0CBKcB+pazNytJLDu/L9qR6V6jlMfBkDYeJ3jVyiMnp4jPmMb+9QUPdSny\nK10yyitz+fQwyNU8woICsVwP6jzJGAD4mZaKsraH6qtnwmzqsm8KGWUanUuALHCX\n/t5nqeLwL3jn2ySRZVhP2L8wUvNCWblXku5VL8NrQEDi1aqy8m2N2tkiROpE2K0K\neT4OfX9JxRXQLPfPW3C2fW+nm/e8GIeZOz57hnrHtjj3cesM+2nJnYoDm7HLStdx\nUsCSCjkqgUrp+jihgjBbgAW7mgiSM3n+50rlkl89SxAWnnreeFuOmtVbyNMiFnRA\nTFyIT1iWg+B/zbfQjRq7LRMU+/83c+DPaEP5s6bh/rZQIhv15O/3RrVmYd8OK7qK\naD3IC615kWztItUOPZY3PqyuLGIpedZHujUDK/rg73wk6a/kByeFiBTb18Sf+RVN\nmEUos43FSJPt7P/mBEL0Ob3V7GNRa8yUsJzdK7Bt8+3Hg/fmb0zOyNdGMyY9OIcx\nyURinCm4cKTdP4hG6z98FiHazQz7+lwS0usNhp+vQE+dTXrsbImStFEk6Q1BO5Od\nGQFrnigu6msepiWIaHc9HGqsBZWEElijTainzDJzTXIAeIYydoJTGjjvb4+bQ5uF\nkz7E6YQh6qNFFeKMNLAD4yyeZ5GnT55JWeBI+vevEDVByD6ERRPyw5QhyDV08Dgl\n9lYUM7AavXlHRkv0Z+3KbzKUvHROHwryTwWq+DVAD+SVS2sdKw0FJcfqxvds9WFm\noxmbeVph6B77EcmYSJwwO/wXgsGaBeZXAq94Yox1vzaFHfmTLAj9PiFwj1IKbQO/\n5hXHZXAh0yJUvqTDp4ZzSBg88sLtr/r5oAF9ScZXVtHQIXZWtF5q2gKmbLblNiGZ\n4O/+pI+BISt/FC648wG4iNDqJRXi73lzJiXWUUnCHKrSrCRYe3CMV3zcBv/AYYCj\n3sCoJTlboQcL5lJ2H0pW+HYMsfTNQTBLJQeXzpCN+jAXjy8r/CkgSgPOpjj70cyP\n+wpnYLtz6WuUYNubTd11zwm4oRJ9qQ==\n=Xpbp\n-----END PGP SIGNATURE-----",
        "payload": "tree 6c79a8f12caca034006db2e2320ce2339411ff0c\nparent cb1ee1551cf39905ccb67e3d07b0e3aaaca18ce3\nauthor Vasil Dimov <vd@FreeBSD.org> 1598295811 +0200\ncommitter Vasil Dimov <vd@FreeBSD.org> 1598298659 +0200\n\nnet: don't accept non-left-contiguous netmasks\n\nA netmask that contains 1-bits after 0-bits (the 1-bits are not\ncontiguous on the left side) is invalid [1] [2].\n\nThe code before this PR used to parse and accept such\nnon-left-contiguous netmasks. However, a coming change that will alter\n`CNetAddr::ip` to have flexible size would make juggling with such\nnetmasks more difficult, thus drop support for those.\n\n[1] https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#Subnet_masks\n[2] https://tools.ietf.org/html/rfc4632#section-5.1\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1ea57ad67406b3aaaef5254bc2fa7e4134f3a6df",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1ea57ad67406b3aaaef5254bc2fa7e4134f3a6df",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1ea57ad67406b3aaaef5254bc2fa7e4134f3a6df/comments",
    "author": {
      "login": "vasild",
      "id": 266751,
      "node_id": "MDQ6VXNlcjI2Njc1MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vasild",
      "html_url": "https://github.com/vasild",
      "followers_url": "https://api.github.com/users/vasild/followers",
      "following_url": "https://api.github.com/users/vasild/following{/other_user}",
      "gists_url": "https://api.github.com/users/vasild/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vasild/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
      "organizations_url": "https://api.github.com/users/vasild/orgs",
      "repos_url": "https://api.github.com/users/vasild/repos",
      "events_url": "https://api.github.com/users/vasild/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vasild/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "vasild",
      "id": 266751,
      "node_id": "MDQ6VXNlcjI2Njc1MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vasild",
      "html_url": "https://github.com/vasild",
      "followers_url": "https://api.github.com/users/vasild/followers",
      "following_url": "https://api.github.com/users/vasild/following{/other_user}",
      "gists_url": "https://api.github.com/users/vasild/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vasild/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
      "organizations_url": "https://api.github.com/users/vasild/orgs",
      "repos_url": "https://api.github.com/users/vasild/repos",
      "events_url": "https://api.github.com/users/vasild/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vasild/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "cb1ee1551cf39905ccb67e3d07b0e3aaaca18ce3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cb1ee1551cf39905ccb67e3d07b0e3aaaca18ce3",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/cb1ee1551cf39905ccb67e3d07b0e3aaaca18ce3"
      }
    ],
    "stats": {
      "total": 104,
      "additions": 49,
      "deletions": 55
    },
    "files": [
      {
        "sha": "b018a6f67f41a1ea4b3de8848e6b46b98f74514d",
        "filename": "doc/release-notes.md",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ea57ad67406b3aaaef5254bc2fa7e4134f3a6df/doc/release-notes.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ea57ad67406b3aaaef5254bc2fa7e4134f3a6df/doc/release-notes.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes.md?ref=1ea57ad67406b3aaaef5254bc2fa7e4134f3a6df",
        "patch": "@@ -135,6 +135,10 @@ Updated settings\n   in future releases. Refer to the help of the affected settings `-whitebind`\n   and `-whitelist` for more details. (#19191)\n \n+- Netmasks that contain 1-bits after 0-bits (the 1-bits are not contiguous on\n+  the left side, e.g. 255.0.255.255) are no longer accepted. They are invalid\n+  according to RFC 4632.\n+\n Changes to Wallet or GUI related settings can be found in the GUI or Wallet  section below.\n \n Tools and Utilities"
      },
      {
        "sha": "87f6ce010ebdb37a7f9a64dd84301ca53e8e3a4b",
        "filename": "src/netaddress.cpp",
        "status": "modified",
        "additions": 40,
        "deletions": 52,
        "changes": 92,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ea57ad67406b3aaaef5254bc2fa7e4134f3a6df/src/netaddress.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ea57ad67406b3aaaef5254bc2fa7e4134f3a6df/src/netaddress.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.cpp?ref=1ea57ad67406b3aaaef5254bc2fa7e4134f3a6df",
        "patch": "@@ -789,9 +789,41 @@ CSubNet::CSubNet(const CNetAddr &addr, int32_t mask)\n         network.ip[x] &= netmask[x];\n }\n \n+/**\n+ * @returns The number of 1-bits in the prefix of the specified subnet mask. If\n+ *          the specified subnet mask is not a valid one, -1.\n+ */\n+static inline int NetmaskBits(uint8_t x)\n+{\n+    switch(x) {\n+    case 0x00: return 0;\n+    case 0x80: return 1;\n+    case 0xc0: return 2;\n+    case 0xe0: return 3;\n+    case 0xf0: return 4;\n+    case 0xf8: return 5;\n+    case 0xfc: return 6;\n+    case 0xfe: return 7;\n+    case 0xff: return 8;\n+    default: return -1;\n+    }\n+}\n+\n CSubNet::CSubNet(const CNetAddr &addr, const CNetAddr &mask)\n {\n     valid = true;\n+    // Check if `mask` contains 1-bits after 0-bits (which is an invalid netmask).\n+    bool zeros_found = false;\n+    for (size_t i = mask.IsIPv4() ? 12 : 0; i < sizeof(mask.ip); ++i) {\n+        const int num_bits = NetmaskBits(mask.ip[i]);\n+        if (num_bits == -1 || (zeros_found && num_bits != 0)) {\n+            valid = false;\n+            return;\n+        }\n+        if (num_bits < 8) {\n+            zeros_found = true;\n+        }\n+    }\n     network = addr;\n     // Default to /32 (IPv4) or /128 (IPv6), i.e. match single address\n     memset(netmask, 255, sizeof(netmask));\n@@ -828,62 +860,18 @@ bool CSubNet::Match(const CNetAddr &addr) const\n     return true;\n }\n \n-/**\n- * @returns The number of 1-bits in the prefix of the specified subnet mask. If\n- *          the specified subnet mask is not a valid one, -1.\n- */\n-static inline int NetmaskBits(uint8_t x)\n-{\n-    switch(x) {\n-    case 0x00: return 0;\n-    case 0x80: return 1;\n-    case 0xc0: return 2;\n-    case 0xe0: return 3;\n-    case 0xf0: return 4;\n-    case 0xf8: return 5;\n-    case 0xfc: return 6;\n-    case 0xfe: return 7;\n-    case 0xff: return 8;\n-    default: return -1;\n-    }\n-}\n-\n std::string CSubNet::ToString() const\n {\n-    /* Parse binary 1{n}0{N-n} to see if mask can be represented as /n */\n-    int cidr = 0;\n-    bool valid_cidr = true;\n-    int n = network.IsIPv4() ? 12 : 0;\n-    for (; n < 16 && netmask[n] == 0xff; ++n)\n-        cidr += 8;\n-    if (n < 16) {\n-        int bits = NetmaskBits(netmask[n]);\n-        if (bits < 0)\n-            valid_cidr = false;\n-        else\n-            cidr += bits;\n-        ++n;\n-    }\n-    for (; n < 16 && valid_cidr; ++n)\n-        if (netmask[n] != 0x00)\n-            valid_cidr = false;\n-\n-    /* Format output */\n-    std::string strNetmask;\n-    if (valid_cidr) {\n-        strNetmask = strprintf(\"%u\", cidr);\n-    } else {\n-        if (network.IsIPv4())\n-            strNetmask = strprintf(\"%u.%u.%u.%u\", netmask[12], netmask[13], netmask[14], netmask[15]);\n-        else\n-            strNetmask = strprintf(\"%x:%x:%x:%x:%x:%x:%x:%x\",\n-                             netmask[0] << 8 | netmask[1], netmask[2] << 8 | netmask[3],\n-                             netmask[4] << 8 | netmask[5], netmask[6] << 8 | netmask[7],\n-                             netmask[8] << 8 | netmask[9], netmask[10] << 8 | netmask[11],\n-                             netmask[12] << 8 | netmask[13], netmask[14] << 8 | netmask[15]);\n+    uint8_t cidr = 0;\n+\n+    for (size_t i = network.IsIPv4() ? 12 : 0; i < sizeof(netmask); ++i) {\n+        if (netmask[i] == 0x00) {\n+            break;\n+        }\n+        cidr += NetmaskBits(netmask[i]);\n     }\n \n-    return network.ToString() + \"/\" + strNetmask;\n+    return network.ToString() + strprintf(\"/%u\", cidr);\n }\n \n bool CSubNet::IsValid() const"
      },
      {
        "sha": "8041c2e3ed219214c8a94a8ff256ab974171695d",
        "filename": "src/test/netbase_tests.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 3,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1ea57ad67406b3aaaef5254bc2fa7e4134f3a6df/src/test/netbase_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1ea57ad67406b3aaaef5254bc2fa7e4134f3a6df/src/test/netbase_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/netbase_tests.cpp?ref=1ea57ad67406b3aaaef5254bc2fa7e4134f3a6df",
        "patch": "@@ -290,11 +290,13 @@ BOOST_AUTO_TEST_CASE(subnet_test)\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"1::/16\");\n     subnet = ResolveSubNet(\"1:2:3:4:5:6:7:8/0000:0000:0000:0000:0000:0000:0000:0000\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"::/0\");\n+    // Invalid netmasks (with 1-bits after 0-bits)\n     subnet = ResolveSubNet(\"1.2.3.4/255.255.232.0\");\n-    BOOST_CHECK_EQUAL(subnet.ToString(), \"1.2.0.0/255.255.232.0\");\n+    BOOST_CHECK(!subnet.IsValid());\n+    subnet = ResolveSubNet(\"1.2.3.4/255.0.255.255\");\n+    BOOST_CHECK(!subnet.IsValid());\n     subnet = ResolveSubNet(\"1:2:3:4:5:6:7:8/ffff:ffff:ffff:fffe:ffff:ffff:ffff:ff0f\");\n-    BOOST_CHECK_EQUAL(subnet.ToString(), \"1:2:3:4:5:6:7:8/ffff:ffff:ffff:fffe:ffff:ffff:ffff:ff0f\");\n-\n+    BOOST_CHECK(!subnet.IsValid());\n }\n \n BOOST_AUTO_TEST_CASE(netbase_getgroup)"
      }
    ]
  },
  {
    "sha": "102867c587f5f7954232fb8ed8e85cda78bb4d32",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxMDI4NjdjNTg3ZjVmNzk1NDIzMmZiOGVkOGU4NWNkYTc4YmI0ZDMy",
    "commit": {
      "author": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2020-08-24T19:34:26Z"
      },
      "committer": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2020-08-24T19:50:59Z"
      },
      "message": "net: change CNetAddr::ip to have flexible size\n\nBefore this change `CNetAddr::ip` was a fixed-size array of 16 bytes,\nnot being able to store larger addresses (e.g. TORv3) and encoded\nsmaller ones as 16-byte IPv6 addresses.\n\nChange its type to `prevector`, so that it can hold larger addresses and\ndo not disguise non-IPv6 addresses as IPv6. So the IPv4 address\n`1.2.3.4` is now encoded as `01020304` instead of\n`00000000000000000000FFFF01020304`.\n\nRename `CNetAddr::ip` to `CNetAddr::m_addr` because it is not an \"IP\" or\n\"IP address\" (TOR addresses are not IP addresses).\n\nIn order to preserve backward compatibility with serialization (where\ne.g. `1.2.3.4` is serialized as `00000000000000000000FFFF01020304`)\nintroduce `CNetAddr` dedicated legacy serialize/unserialize methods.\n\nAdjust `CSubNet` accordingly. Still use `CSubNet::netmask[]` of fixed 16\nbytes, but use the first 4 for IPv4 (not the last 4). Only allow\nsubnetting for IPv4 and IPv6.\n\nCo-authored-by: Carl Dong <contact@carldong.me>",
      "tree": {
        "sha": "4c9aea8c2b43541d4bfd2ddd23a3ddebd22c3346",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4c9aea8c2b43541d4bfd2ddd23a3ddebd22c3346"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/102867c587f5f7954232fb8ed8e85cda78bb4d32",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQQzBAABCAAdFiEE5k2NRWFNsHVF2czBVN8G9ktVy78FAl9EGiMACgkQVN8G9ktV\ny78GgR/+LexKqci7ocjlLVBbozGIkM0CJaoUqizKXtGoatc/uhy1aPo2Ts5Ijt2A\nR7T9/chOQ1Sl+wBQVGObgyWtQcJD0Z66HpTpb2Pu+BVpjbwhuhHGk4KXFk3uXFQV\nOWvgYHRj3pnGkAv7hJ8k55tr5f+h50lXS0RQK22fyUfyle5noZ/ehAFSpicdl04a\nTiECKnJsYjTsdG43nKsDYuJfXo9aPG6IYMZT7jmsmffEYAP/CzMjZG1zGY96ld1e\n0tBp4cJlaebLonf48KpEJt2lAb8zRVCtPYqVBY4bUHt472gadBqUsxRxQSuhA0aV\nDXltEn4JACtcymxwX78N1++/nO5pjJvwLdqVxFdAX9roThH7F2rSy+K3Nzc/+HPZ\nZKGWWfQC7rr1R8i6E9qS6YAvlROsL1fvDNRjJxvWXjAeWtyByJlaWUqlIiaT/ojZ\nkPYF4I7H8Rn1dtUu3Lw2HlQ5u2VC7a3DiDQ5LV7VOFeYsWLpy+oRc8uncZhmydO7\nh4CLgZaTGNdPCyIMUqe2pMVS0GFiTtHoUpDXYgvjEeTI17ny83biyp/XXWgVXwfs\nBkydXCBce+glgfQTtau0SjwAVu0A+Aah6TNV+Fy65SkxnsIF/gY7R9cnZBx0njS8\ncJZAqj7DXq7HVlIN98IQgURCaU/KyMKY9ai6gYVA9W4w22D9xk6hAc04YKEevleN\nKoQeQStXKjzZ9D84inulvBZr0Vx6dvKNdklUcZ9XQ0STA4n+jcBWCbo5zC/fXnSt\nwBxZVE79ym3dEnpU8NepAoclGYuimjpLMgLY+zrE5Ib9MMGHmdfgRltUbudGZxu5\nPYH+95hxvjJUrhY0+c4gQb3B2RmfbuiUZMtSQDVDgZEMnbL7rXfpssx5dTmB9HuY\n0ZfCxjsayZFb831ffeijGChtTh5thkKNo+xhoQJ/xMjnFaqGS3Zy7frY427Vgx6F\n0mjM55X5kAPMxAkhR7hjh6yGuxBg1DyMfiLPg1ryvBkylrnkixtdyPFXyohGv9Em\nut6REHOH/hIL91auo91CPIikeGEy8coyWmC34KZPOf3YA0EtNTSKxOF+zAwtQL19\nzy+jrtVdG9nFcOqHG1/Ye0qHEv24zEKg9tpua5+wgsKB5sxkmui6LWIAfBjmUxHx\nTclAwyVXPgW2hEkns7khP1pLg4WjPH2JcHP01QfBVWJ54cTnvCxlPDYnalDX86Ku\nk4/rv9FpNahdmGaxapmXcqNIRMavTbF8O43xvQPqLHrKrD0oXqIs2KKnzSq7F2hb\ntn4mhtoTVfJWLq+KmllX41lqAfpcKdQCPsnNOrnHYRCRoRfB64uoWDf00+Dg7w2E\nqueRij764aU/wsdKz/A9K48CoscGRQ==\n=WCGo\n-----END PGP SIGNATURE-----",
        "payload": "tree 4c9aea8c2b43541d4bfd2ddd23a3ddebd22c3346\nparent 1ea57ad67406b3aaaef5254bc2fa7e4134f3a6df\nauthor Vasil Dimov <vd@FreeBSD.org> 1598297666 +0200\ncommitter Vasil Dimov <vd@FreeBSD.org> 1598298659 +0200\n\nnet: change CNetAddr::ip to have flexible size\n\nBefore this change `CNetAddr::ip` was a fixed-size array of 16 bytes,\nnot being able to store larger addresses (e.g. TORv3) and encoded\nsmaller ones as 16-byte IPv6 addresses.\n\nChange its type to `prevector`, so that it can hold larger addresses and\ndo not disguise non-IPv6 addresses as IPv6. So the IPv4 address\n`1.2.3.4` is now encoded as `01020304` instead of\n`00000000000000000000FFFF01020304`.\n\nRename `CNetAddr::ip` to `CNetAddr::m_addr` because it is not an \"IP\" or\n\"IP address\" (TOR addresses are not IP addresses).\n\nIn order to preserve backward compatibility with serialization (where\ne.g. `1.2.3.4` is serialized as `00000000000000000000FFFF01020304`)\nintroduce `CNetAddr` dedicated legacy serialize/unserialize methods.\n\nAdjust `CSubNet` accordingly. Still use `CSubNet::netmask[]` of fixed 16\nbytes, but use the first 4 for IPv4 (not the last 4). Only allow\nsubnetting for IPv4 and IPv6.\n\nCo-authored-by: Carl Dong <contact@carldong.me>\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/102867c587f5f7954232fb8ed8e85cda78bb4d32",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/102867c587f5f7954232fb8ed8e85cda78bb4d32",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/102867c587f5f7954232fb8ed8e85cda78bb4d32/comments",
    "author": {
      "login": "vasild",
      "id": 266751,
      "node_id": "MDQ6VXNlcjI2Njc1MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vasild",
      "html_url": "https://github.com/vasild",
      "followers_url": "https://api.github.com/users/vasild/followers",
      "following_url": "https://api.github.com/users/vasild/following{/other_user}",
      "gists_url": "https://api.github.com/users/vasild/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vasild/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
      "organizations_url": "https://api.github.com/users/vasild/orgs",
      "repos_url": "https://api.github.com/users/vasild/repos",
      "events_url": "https://api.github.com/users/vasild/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vasild/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "vasild",
      "id": 266751,
      "node_id": "MDQ6VXNlcjI2Njc1MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vasild",
      "html_url": "https://github.com/vasild",
      "followers_url": "https://api.github.com/users/vasild/followers",
      "following_url": "https://api.github.com/users/vasild/following{/other_user}",
      "gists_url": "https://api.github.com/users/vasild/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vasild/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
      "organizations_url": "https://api.github.com/users/vasild/orgs",
      "repos_url": "https://api.github.com/users/vasild/repos",
      "events_url": "https://api.github.com/users/vasild/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vasild/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1ea57ad67406b3aaaef5254bc2fa7e4134f3a6df",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1ea57ad67406b3aaaef5254bc2fa7e4134f3a6df",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1ea57ad67406b3aaaef5254bc2fa7e4134f3a6df"
      }
    ],
    "stats": {
      "total": 665,
      "additions": 450,
      "deletions": 215
    },
    "files": [
      {
        "sha": "cb874e5e314c2c51585449447913cb903c1396a0",
        "filename": "src/netaddress.cpp",
        "status": "modified",
        "additions": 198,
        "deletions": 183,
        "changes": 381,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/102867c587f5f7954232fb8ed8e85cda78bb4d32/src/netaddress.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/102867c587f5f7954232fb8ed8e85cda78bb4d32/src/netaddress.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.cpp?ref=102867c587f5f7954232fb8ed8e85cda78bb4d32",
        "patch": "@@ -3,79 +3,90 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#include <cstdint>\n #include <netaddress.h>\n #include <hash.h>\n #include <util/strencodings.h>\n #include <util/asmap.h>\n #include <tinyformat.h>\n \n-static const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };\n-static const unsigned char pchOnionCat[] = {0xFD,0x87,0xD8,0x7E,0xEB,0x43};\n+#include <algorithm>\n+#include <array>\n+#include <cstdint>\n+#include <iterator>\n+#include <tuple>\n \n-// 0xFD + sha256(\"bitcoin\")[0:5]\n-static const unsigned char g_internal_prefix[] = { 0xFD, 0x6B, 0x88, 0xC0, 0x87, 0x24 };\n+constexpr size_t CNetAddr::V1_SERIALIZATION_SIZE;\n \n /**\n  * Construct an unspecified IPv6 network address (::/128).\n  *\n  * @note This address is considered invalid by CNetAddr::IsValid()\n  */\n-CNetAddr::CNetAddr()\n-{\n-    memset(ip, 0, sizeof(ip));\n-}\n+CNetAddr::CNetAddr() {}\n \n void CNetAddr::SetIP(const CNetAddr& ipIn)\n {\n+    // Size check.\n+    switch (ipIn.m_net) {\n+    case NET_IPV4:\n+        assert(ipIn.m_addr.size() == ADDR_IPV4_SIZE);\n+        break;\n+    case NET_IPV6:\n+        assert(ipIn.m_addr.size() == ADDR_IPV6_SIZE);\n+        break;\n+    case NET_ONION:\n+        assert(ipIn.m_addr.size() == ADDR_TORV2_SIZE);\n+        break;\n+    case NET_INTERNAL:\n+        assert(ipIn.m_addr.size() == ADDR_INTERNAL_SIZE);\n+        break;\n+    case NET_UNROUTABLE:\n+    case NET_MAX:\n+        assert(false);\n+    } // no default case, so the compiler can warn about missing cases\n+\n     m_net = ipIn.m_net;\n-    memcpy(ip, ipIn.ip, sizeof(ip));\n+    m_addr = ipIn.m_addr;\n+}\n+\n+template <typename T1, size_t PREFIX_LEN>\n+inline bool HasPrefix(const T1& obj, const std::array<uint8_t, PREFIX_LEN>& prefix)\n+{\n+    return obj.size() >= PREFIX_LEN &&\n+           std::equal(std::begin(prefix), std::end(prefix), std::begin(obj));\n }\n \n-void CNetAddr::SetLegacyIPv6(const uint8_t ipv6[16])\n+void CNetAddr::SetLegacyIPv6(Span<const uint8_t> ipv6)\n {\n-    if (memcmp(ipv6, pchIPv4, sizeof(pchIPv4)) == 0) {\n+    assert(ipv6.size() == ADDR_IPV6_SIZE);\n+\n+    size_t skip{0};\n+\n+    if (HasPrefix(ipv6, IPV4_IN_IPV6_PREFIX)) {\n+        // IPv4-in-IPv6\n         m_net = NET_IPV4;\n-    } else if (memcmp(ipv6, pchOnionCat, sizeof(pchOnionCat)) == 0) {\n+        skip = sizeof(IPV4_IN_IPV6_PREFIX);\n+    } else if (HasPrefix(ipv6, TORV2_IN_IPV6_PREFIX)) {\n+        // TORv2-in-IPv6\n         m_net = NET_ONION;\n-    } else if (memcmp(ipv6, g_internal_prefix, sizeof(g_internal_prefix)) == 0) {\n+        skip = sizeof(TORV2_IN_IPV6_PREFIX);\n+    } else if (HasPrefix(ipv6, INTERNAL_IN_IPV6_PREFIX)) {\n+        // Internal-in-IPv6\n         m_net = NET_INTERNAL;\n+        skip = sizeof(INTERNAL_IN_IPV6_PREFIX);\n     } else {\n+        // IPv6\n         m_net = NET_IPV6;\n     }\n-    memcpy(ip, ipv6, 16);\n-}\n \n-void CNetAddr::SetRaw(Network network, const uint8_t *ip_in)\n-{\n-    switch(network)\n-    {\n-        case NET_IPV4:\n-            m_net = NET_IPV4;\n-            memcpy(ip, pchIPv4, 12);\n-            memcpy(ip+12, ip_in, 4);\n-            break;\n-        case NET_IPV6:\n-            SetLegacyIPv6(ip_in);\n-            break;\n-        default:\n-            assert(!\"invalid network\");\n-    }\n+    m_addr.assign(ipv6.begin() + skip, ipv6.end());\n }\n \n /**\n- * Try to make this a dummy address that maps the specified name into IPv6 like\n- * so: (0xFD + %sha256(\"bitcoin\")[0:5]) + %sha256(name)[0:10]. Such dummy\n- * addresses have a prefix of fd6b:88c0:8724::/48 and are guaranteed to not be\n- * publicly routable as it falls under RFC4193's fc00::/7 subnet allocated to\n- * unique-local addresses.\n- *\n- * CAddrMan uses these fake addresses to keep track of which DNS seeds were\n- * used.\n- *\n+ * Create an \"internal\" address that represents a name or FQDN. CAddrMan uses\n+ * these fake addresses to keep track of which DNS seeds were used.\n  * @returns Whether or not the operation was successful.\n- *\n- * @see CNetAddr::IsInternal(), CNetAddr::IsRFC4193()\n+ * @see NET_INTERNAL, INTERNAL_IN_IPV6_PREFIX, CNetAddr::IsInternal(), CNetAddr::IsRFC4193()\n  */\n bool CNetAddr::SetInternal(const std::string &name)\n {\n@@ -85,60 +96,50 @@ bool CNetAddr::SetInternal(const std::string &name)\n     m_net = NET_INTERNAL;\n     unsigned char hash[32] = {};\n     CSHA256().Write((const unsigned char*)name.data(), name.size()).Finalize(hash);\n-    memcpy(ip, g_internal_prefix, sizeof(g_internal_prefix));\n-    memcpy(ip + sizeof(g_internal_prefix), hash, sizeof(ip) - sizeof(g_internal_prefix));\n+    m_addr.assign(hash, hash + ADDR_INTERNAL_SIZE);\n     return true;\n }\n \n /**\n- * Try to make this a dummy address that maps the specified onion address into\n- * IPv6 using OnionCat's range and encoding. Such dummy addresses have a prefix\n- * of fd87:d87e:eb43::/48 and are guaranteed to not be publicly routable as they\n- * fall under RFC4193's fc00::/7 subnet allocated to unique-local addresses.\n+ * Parse a TORv2 address and set this object to it.\n  *\n  * @returns Whether or not the operation was successful.\n  *\n- * @see CNetAddr::IsTor(), CNetAddr::IsRFC4193()\n+ * @see CNetAddr::IsTor()\n  */\n bool CNetAddr::SetSpecial(const std::string &strName)\n {\n     if (strName.size()>6 && strName.substr(strName.size() - 6, 6) == \".onion\") {\n         std::vector<unsigned char> vchAddr = DecodeBase32(strName.substr(0, strName.size() - 6).c_str());\n-        if (vchAddr.size() != 16-sizeof(pchOnionCat))\n+        if (vchAddr.size() != ADDR_TORV2_SIZE) {\n             return false;\n+        }\n         m_net = NET_ONION;\n-        memcpy(ip, pchOnionCat, sizeof(pchOnionCat));\n-        for (unsigned int i=0; i<16-sizeof(pchOnionCat); i++)\n-            ip[i + sizeof(pchOnionCat)] = vchAddr[i];\n+        m_addr.assign(vchAddr.begin(), vchAddr.end());\n         return true;\n     }\n     return false;\n }\n \n CNetAddr::CNetAddr(const struct in_addr& ipv4Addr)\n {\n-    SetRaw(NET_IPV4, (const uint8_t*)&ipv4Addr);\n+    m_net = NET_IPV4;\n+    const uint8_t* ptr = reinterpret_cast<const uint8_t*>(&ipv4Addr);\n+    m_addr.assign(ptr, ptr + ADDR_IPV4_SIZE);\n }\n \n CNetAddr::CNetAddr(const struct in6_addr& ipv6Addr, const uint32_t scope)\n {\n-    SetRaw(NET_IPV6, (const uint8_t*)&ipv6Addr);\n+    SetLegacyIPv6(Span<const uint8_t>(reinterpret_cast<const uint8_t*>(&ipv6Addr), sizeof(ipv6Addr)));\n     scopeId = scope;\n }\n \n-unsigned int CNetAddr::GetByte(int n) const\n-{\n-    return ip[15-n];\n-}\n-\n bool CNetAddr::IsBindAny() const\n {\n-    const int cmplen = IsIPv4() ? 4 : 16;\n-    for (int i = 0; i < cmplen; ++i) {\n-        if (GetByte(i)) return false;\n+    if (!IsIPv4() && !IsIPv6()) {\n+        return false;\n     }\n-\n-    return true;\n+    return std::all_of(m_addr.begin(), m_addr.end(), [](uint8_t b) { return b == 0; });\n }\n \n bool CNetAddr::IsIPv4() const { return m_net == NET_IPV4; }\n@@ -148,88 +149,88 @@ bool CNetAddr::IsIPv6() const { return m_net == NET_IPV6; }\n bool CNetAddr::IsRFC1918() const\n {\n     return IsIPv4() && (\n-        GetByte(3) == 10 ||\n-        (GetByte(3) == 192 && GetByte(2) == 168) ||\n-        (GetByte(3) == 172 && (GetByte(2) >= 16 && GetByte(2) <= 31)));\n+        m_addr[0] == 10 ||\n+        (m_addr[0] == 192 && m_addr[1] == 168) ||\n+        (m_addr[0] == 172 && m_addr[1] >= 16 && m_addr[1] <= 31));\n }\n \n bool CNetAddr::IsRFC2544() const\n {\n-    return IsIPv4() && GetByte(3) == 198 && (GetByte(2) == 18 || GetByte(2) == 19);\n+    return IsIPv4() && m_addr[0] == 198 && (m_addr[1] == 18 || m_addr[1] == 19);\n }\n \n bool CNetAddr::IsRFC3927() const\n {\n-    return IsIPv4() && (GetByte(3) == 169 && GetByte(2) == 254);\n+    return IsIPv4() && HasPrefix(m_addr, std::array<uint8_t, 2>{169, 254});\n }\n \n bool CNetAddr::IsRFC6598() const\n {\n-    return IsIPv4() && GetByte(3) == 100 && GetByte(2) >= 64 && GetByte(2) <= 127;\n+    return IsIPv4() && m_addr[0] == 100 && m_addr[1] >= 64 && m_addr[1] <= 127;\n }\n \n bool CNetAddr::IsRFC5737() const\n {\n-    return IsIPv4() && ((GetByte(3) == 192 && GetByte(2) == 0 && GetByte(1) == 2) ||\n-        (GetByte(3) == 198 && GetByte(2) == 51 && GetByte(1) == 100) ||\n-        (GetByte(3) == 203 && GetByte(2) == 0 && GetByte(1) == 113));\n+    return IsIPv4() && (HasPrefix(m_addr, std::array<uint8_t, 3>{192, 0, 2}) ||\n+                        HasPrefix(m_addr, std::array<uint8_t, 3>{198, 51, 100}) ||\n+                        HasPrefix(m_addr, std::array<uint8_t, 3>{203, 0, 113}));\n }\n \n bool CNetAddr::IsRFC3849() const\n {\n-    return IsIPv6() && GetByte(15) == 0x20 && GetByte(14) == 0x01 &&\n-           GetByte(13) == 0x0D && GetByte(12) == 0xB8;\n+    return IsIPv6() && HasPrefix(m_addr, std::array<uint8_t, 4>{0x20, 0x01, 0x0D, 0xB8});\n }\n \n bool CNetAddr::IsRFC3964() const\n {\n-    return IsIPv6() && GetByte(15) == 0x20 && GetByte(14) == 0x02;\n+    return IsIPv6() && HasPrefix(m_addr, std::array<uint8_t, 2>{0x20, 0x02});\n }\n \n bool CNetAddr::IsRFC6052() const\n {\n-    static const unsigned char pchRFC6052[] = {0,0x64,0xFF,0x9B,0,0,0,0,0,0,0,0};\n-    return IsIPv6() && memcmp(ip, pchRFC6052, sizeof(pchRFC6052)) == 0;\n+    return IsIPv6() &&\n+           HasPrefix(m_addr, std::array<uint8_t, 12>{0x00, 0x64, 0xFF, 0x9B, 0x00, 0x00,\n+                                                     0x00, 0x00, 0x00, 0x00, 0x00, 0x00});\n }\n \n bool CNetAddr::IsRFC4380() const\n {\n-    return IsIPv6() && GetByte(15) == 0x20 && GetByte(14) == 0x01 && GetByte(13) == 0 &&\n-           GetByte(12) == 0;\n+    return IsIPv6() && HasPrefix(m_addr, std::array<uint8_t, 4>{0x20, 0x01, 0x00, 0x00});\n }\n \n bool CNetAddr::IsRFC4862() const\n {\n-    static const unsigned char pchRFC4862[] = {0xFE,0x80,0,0,0,0,0,0};\n-    return IsIPv6() && memcmp(ip, pchRFC4862, sizeof(pchRFC4862)) == 0;\n+    return IsIPv6() && HasPrefix(m_addr, std::array<uint8_t, 8>{0xFE, 0x80, 0x00, 0x00,\n+                                                                0x00, 0x00, 0x00, 0x00});\n }\n \n bool CNetAddr::IsRFC4193() const\n {\n-    return IsIPv6() && (GetByte(15) & 0xFE) == 0xFC;\n+    return IsIPv6() && (m_addr[0] & 0xFE) == 0xFC;\n }\n \n bool CNetAddr::IsRFC6145() const\n {\n-    static const unsigned char pchRFC6145[] = {0,0,0,0,0,0,0,0,0xFF,0xFF,0,0};\n-    return IsIPv6() && memcmp(ip, pchRFC6145, sizeof(pchRFC6145)) == 0;\n+    return IsIPv6() &&\n+           HasPrefix(m_addr, std::array<uint8_t, 12>{0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+                                                     0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00});\n }\n \n bool CNetAddr::IsRFC4843() const\n {\n-    return IsIPv6() && GetByte(15) == 0x20 && GetByte(14) == 0x01 &&\n-           GetByte(13) == 0x00 && (GetByte(12) & 0xF0) == 0x10;\n+    return IsIPv6() && HasPrefix(m_addr, std::array<uint8_t, 3>{0x20, 0x01, 0x00}) &&\n+           (m_addr[3] & 0xF0) == 0x10;\n }\n \n bool CNetAddr::IsRFC7343() const\n {\n-    return IsIPv6() && GetByte(15) == 0x20 && GetByte(14) == 0x01 &&\n-           GetByte(13) == 0x00 && (GetByte(12) & 0xF0) == 0x20;\n+    return IsIPv6() && HasPrefix(m_addr, std::array<uint8_t, 3>{0x20, 0x01, 0x00}) &&\n+           (m_addr[3] & 0xF0) == 0x20;\n }\n \n bool CNetAddr::IsHeNet() const\n {\n-    return (GetByte(15) == 0x20 && GetByte(14) == 0x01 && GetByte(13) == 0x04 && GetByte(12) == 0x70);\n+    return IsIPv6() && HasPrefix(m_addr, std::array<uint8_t, 4>{0x20, 0x01, 0x04, 0x70});\n }\n \n /**\n@@ -243,13 +244,15 @@ bool CNetAddr::IsTor() const { return m_net == NET_ONION; }\n bool CNetAddr::IsLocal() const\n {\n     // IPv4 loopback (127.0.0.0/8 or 0.0.0.0/8)\n-    if (IsIPv4() && (GetByte(3) == 127 || GetByte(3) == 0))\n+    if (IsIPv4() && (m_addr[0] == 127 || m_addr[0] == 0)) {\n         return true;\n+    }\n \n     // IPv6 loopback (::1/128)\n     static const unsigned char pchLocal[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1};\n-    if (IsIPv6() && memcmp(ip, pchLocal, 16) == 0)\n+    if (IsIPv6() && memcmp(m_addr.data(), pchLocal, sizeof(pchLocal)) == 0) {\n         return true;\n+    }\n \n     return false;\n }\n@@ -272,13 +275,16 @@ bool CNetAddr::IsValid() const\n     // header20 vectorlen3 addr26 addr26 addr26 header20 vectorlen3 addr26 addr26 addr26...\n     // so if the first length field is garbled, it reads the second batch\n     // of addr misaligned by 3 bytes.\n-    if (IsIPv6() && memcmp(ip, pchIPv4+3, sizeof(pchIPv4)-3) == 0)\n+    if (IsIPv6() && memcmp(m_addr.data(), IPV4_IN_IPV6_PREFIX.data() + 3,\n+                           sizeof(IPV4_IN_IPV6_PREFIX) - 3) == 0) {\n         return false;\n+    }\n \n     // unspecified IPv6 address (::/128)\n     unsigned char ipNone6[16] = {};\n-    if (IsIPv6() && memcmp(ip, ipNone6, 16) == 0)\n+    if (IsIPv6() && memcmp(m_addr.data(), ipNone6, sizeof(ipNone6)) == 0) {\n         return false;\n+    }\n \n     // documentation IPv6 address\n     if (IsRFC3849())\n@@ -287,17 +293,11 @@ bool CNetAddr::IsValid() const\n     if (IsInternal())\n         return false;\n \n-    if (IsIPv4())\n-    {\n-        // INADDR_NONE\n-        uint32_t ipNone = INADDR_NONE;\n-        if (memcmp(ip+12, &ipNone, 4) == 0)\n-            return false;\n-\n-        // 0\n-        ipNone = 0;\n-        if (memcmp(ip+12, &ipNone, 4) == 0)\n+    if (IsIPv4()) {\n+        const uint32_t addr = ReadBE32(m_addr.data());\n+        if (addr == INADDR_ANY || addr == INADDR_NONE) {\n             return false;\n+        }\n     }\n \n     return true;\n@@ -318,7 +318,7 @@ bool CNetAddr::IsRoutable() const\n }\n \n /**\n- * @returns Whether or not this is a dummy address that maps a name into IPv6.\n+ * @returns Whether or not this is a dummy address that represents a name.\n  *\n  * @see CNetAddr::SetInternal(const std::string &)\n  */\n@@ -341,9 +341,9 @@ enum Network CNetAddr::GetNetwork() const\n std::string CNetAddr::ToStringIP() const\n {\n     if (IsTor())\n-        return EncodeBase32(&ip[6], 10) + \".onion\";\n+        return EncodeBase32(m_addr.data(), m_addr.size()) + \".onion\";\n     if (IsInternal())\n-        return EncodeBase32(ip + sizeof(g_internal_prefix), sizeof(ip) - sizeof(g_internal_prefix)) + \".internal\";\n+        return EncodeBase32(m_addr.data(), m_addr.size()) + \".internal\";\n     CService serv(*this, 0);\n     struct sockaddr_storage sockaddr;\n     socklen_t socklen = sizeof(sockaddr);\n@@ -353,13 +353,13 @@ std::string CNetAddr::ToStringIP() const\n             return std::string(name);\n     }\n     if (IsIPv4())\n-        return strprintf(\"%u.%u.%u.%u\", GetByte(3), GetByte(2), GetByte(1), GetByte(0));\n-    else\n-        return strprintf(\"%x:%x:%x:%x:%x:%x:%x:%x\",\n-                         GetByte(15) << 8 | GetByte(14), GetByte(13) << 8 | GetByte(12),\n-                         GetByte(11) << 8 | GetByte(10), GetByte(9) << 8 | GetByte(8),\n-                         GetByte(7) << 8 | GetByte(6), GetByte(5) << 8 | GetByte(4),\n-                         GetByte(3) << 8 | GetByte(2), GetByte(1) << 8 | GetByte(0));\n+        return strprintf(\"%u.%u.%u.%u\", m_addr[0], m_addr[1], m_addr[2], m_addr[3]);\n+    assert(IsIPv6());\n+    return strprintf(\"%x:%x:%x:%x:%x:%x:%x:%x\",\n+                     m_addr[0] << 8 | m_addr[1], m_addr[2] << 8 | m_addr[3],\n+                     m_addr[4] << 8 | m_addr[5], m_addr[6] << 8 | m_addr[7],\n+                     m_addr[8] << 8 | m_addr[9], m_addr[10] << 8 | m_addr[11],\n+                     m_addr[12] << 8 | m_addr[13], m_addr[14] << 8 | m_addr[15]);\n }\n \n std::string CNetAddr::ToString() const\n@@ -369,12 +369,12 @@ std::string CNetAddr::ToString() const\n \n bool operator==(const CNetAddr& a, const CNetAddr& b)\n {\n-    return a.m_net == b.m_net && memcmp(a.ip, b.ip, 16) == 0;\n+    return a.m_net == b.m_net && a.m_addr == b.m_addr;\n }\n \n bool operator<(const CNetAddr& a, const CNetAddr& b)\n {\n-    return a.m_net < b.m_net || (a.m_net == b.m_net && memcmp(a.ip, b.ip, 16) < 0);\n+    return std::tie(a.m_net, a.m_addr) < std::tie(b.m_net, b.m_addr);\n }\n \n /**\n@@ -391,7 +391,8 @@ bool CNetAddr::GetInAddr(struct in_addr* pipv4Addr) const\n {\n     if (!IsIPv4())\n         return false;\n-    memcpy(pipv4Addr, ip+12, 4);\n+    assert(sizeof(*pipv4Addr) == m_addr.size());\n+    memcpy(pipv4Addr, m_addr.data(), m_addr.size());\n     return true;\n }\n \n@@ -410,7 +411,8 @@ bool CNetAddr::GetIn6Addr(struct in6_addr* pipv6Addr) const\n     if (!IsIPv6()) {\n         return false;\n     }\n-    memcpy(pipv6Addr, ip, 16);\n+    assert(sizeof(*pipv6Addr) == m_addr.size());\n+    memcpy(pipv6Addr, m_addr.data(), m_addr.size());\n     return true;\n }\n \n@@ -421,15 +423,17 @@ bool CNetAddr::HasLinkedIPv4() const\n \n uint32_t CNetAddr::GetLinkedIPv4() const\n {\n-    if (IsIPv4() || IsRFC6145() || IsRFC6052()) {\n-        // IPv4, mapped IPv4, SIIT translated IPv4: the IPv4 address is the last 4 bytes of the address\n-        return ReadBE32(ip + 12);\n+    if (IsIPv4()) {\n+        return ReadBE32(m_addr.data());\n+    } else if (IsRFC6052() || IsRFC6145()) {\n+        // mapped IPv4, SIIT translated IPv4: the IPv4 address is the last 4 bytes of the address\n+        return ReadBE32(MakeSpan(m_addr).last(ADDR_IPV4_SIZE).data());\n     } else if (IsRFC3964()) {\n         // 6to4 tunneled IPv4: the IPv4 address is in bytes 2-6\n-        return ReadBE32(ip + 2);\n+        return ReadBE32(MakeSpan(m_addr).subspan(2, ADDR_IPV4_SIZE).data());\n     } else if (IsRFC4380()) {\n         // Teredo tunneled IPv4: the IPv4 address is in the last 4 bytes of the address, but bitflipped\n-        return ~ReadBE32(ip + 12);\n+        return ~ReadBE32(MakeSpan(m_addr).last(ADDR_IPV4_SIZE).data());\n     }\n     assert(false);\n }\n@@ -458,10 +462,10 @@ uint32_t CNetAddr::GetMappedAS(const std::vector<bool> &asmap) const {\n     }\n     std::vector<bool> ip_bits(128);\n     if (HasLinkedIPv4()) {\n-        // For lookup, treat as if it was just an IPv4 address (pchIPv4 prefix + IPv4 bits)\n+        // For lookup, treat as if it was just an IPv4 address (IPV4_IN_IPV6_PREFIX + IPv4 bits)\n         for (int8_t byte_i = 0; byte_i < 12; ++byte_i) {\n             for (uint8_t bit_i = 0; bit_i < 8; ++bit_i) {\n-                ip_bits[byte_i * 8 + bit_i] = (pchIPv4[byte_i] >> (7 - bit_i)) & 1;\n+                ip_bits[byte_i * 8 + bit_i] = (IPV4_IN_IPV6_PREFIX[byte_i] >> (7 - bit_i)) & 1;\n             }\n         }\n         uint32_t ipv4 = GetLinkedIPv4();\n@@ -470,8 +474,9 @@ uint32_t CNetAddr::GetMappedAS(const std::vector<bool> &asmap) const {\n         }\n     } else {\n         // Use all 128 bits of the IPv6 address otherwise\n+        assert(IsIPv6());\n         for (int8_t byte_i = 0; byte_i < 16; ++byte_i) {\n-            uint8_t cur_byte = GetByte(15 - byte_i);\n+            uint8_t cur_byte = m_addr[byte_i];\n             for (uint8_t bit_i = 0; bit_i < 8; ++bit_i) {\n                 ip_bits[byte_i * 8 + bit_i] = (cur_byte >> (7 - bit_i)) & 1;\n             }\n@@ -507,27 +512,22 @@ std::vector<unsigned char> CNetAddr::GetGroup(const std::vector<bool> &asmap) co\n     }\n \n     vchRet.push_back(net_class);\n-    int nStartByte = 0;\n-    int nBits = 16;\n+    int nBits{0};\n \n     if (IsLocal()) {\n         // all local addresses belong to the same group\n-        nBits = 0;\n     } else if (IsInternal()) {\n         // all internal-usage addresses get their own group\n-        nStartByte = sizeof(g_internal_prefix);\n-        nBits = (sizeof(ip) - sizeof(g_internal_prefix)) * 8;\n+        nBits = ADDR_INTERNAL_SIZE * 8;\n     } else if (!IsRoutable()) {\n         // all other unroutable addresses belong to the same group\n-        nBits = 0;\n     } else if (HasLinkedIPv4()) {\n         // IPv4 addresses (and mapped IPv4 addresses) use /16 groups\n         uint32_t ipv4 = GetLinkedIPv4();\n         vchRet.push_back((ipv4 >> 24) & 0xFF);\n         vchRet.push_back((ipv4 >> 16) & 0xFF);\n         return vchRet;\n     } else if (IsTor()) {\n-        nStartByte = 6;\n         nBits = 4;\n     } else if (IsHeNet()) {\n         // for he.net, use /36 groups\n@@ -537,23 +537,29 @@ std::vector<unsigned char> CNetAddr::GetGroup(const std::vector<bool> &asmap) co\n         nBits = 32;\n     }\n \n-    // push our ip onto vchRet byte by byte...\n-    while (nBits >= 8)\n-    {\n-        vchRet.push_back(GetByte(15 - nStartByte));\n-        nStartByte++;\n-        nBits -= 8;\n-    }\n+    // Push our address onto vchRet.\n+    const size_t num_bytes = nBits / 8;\n+    vchRet.insert(vchRet.end(), m_addr.begin(), m_addr.begin() + num_bytes);\n+    nBits %= 8;\n     // ...for the last byte, push nBits and for the rest of the byte push 1's\n-    if (nBits > 0)\n-        vchRet.push_back(GetByte(15 - nStartByte) | ((1 << (8 - nBits)) - 1));\n+    if (nBits > 0) {\n+        assert(num_bytes < m_addr.size());\n+        vchRet.push_back(m_addr[num_bytes] | ((1 << (8 - nBits)) - 1));\n+    }\n \n     return vchRet;\n }\n \n+std::vector<unsigned char> CNetAddr::GetAddrBytes() const\n+{\n+    uint8_t serialized[V1_SERIALIZATION_SIZE];\n+    SerializeV1Array(serialized);\n+    return {std::begin(serialized), std::end(serialized)};\n+}\n+\n uint64_t CNetAddr::GetHash() const\n {\n-    uint256 hash = Hash(ip);\n+    uint256 hash = Hash(m_addr);\n     uint64_t nRet;\n     memcpy(&nRet, &hash, sizeof(nRet));\n     return nRet;\n@@ -764,29 +770,25 @@ CSubNet::CSubNet():\n     memset(netmask, 0, sizeof(netmask));\n }\n \n-CSubNet::CSubNet(const CNetAddr &addr, int32_t mask)\n+CSubNet::CSubNet(const CNetAddr& addr, uint8_t mask) : CSubNet()\n {\n-    valid = true;\n+    valid = (addr.IsIPv4() && mask <= ADDR_IPV4_SIZE * 8) ||\n+            (addr.IsIPv6() && mask <= ADDR_IPV6_SIZE * 8);\n+    if (!valid) {\n+        return;\n+    }\n+\n+    assert(mask <= sizeof(netmask) * 8);\n+\n     network = addr;\n-    // Default to /32 (IPv4) or /128 (IPv6), i.e. match single address\n-    memset(netmask, 255, sizeof(netmask));\n-\n-    // IPv4 addresses start at offset 12, and first 12 bytes must match, so just offset n\n-    const int astartofs = network.IsIPv4() ? 12 : 0;\n-\n-    int32_t n = mask;\n-    if(n >= 0 && n <= (128 - astartofs*8)) // Only valid if in range of bits of address\n-    {\n-        n += astartofs*8;\n-        // Clear bits [n..127]\n-        for (; n < 128; ++n)\n-            netmask[n>>3] &= ~(1<<(7-(n&7)));\n-    } else\n-        valid = false;\n \n-    // Normalize network according to netmask\n-    for(int x=0; x<16; ++x)\n-        network.ip[x] &= netmask[x];\n+    uint8_t n = mask;\n+    for (size_t i = 0; i < network.m_addr.size(); ++i) {\n+        const uint8_t bits = n < 8 ? n : 8;\n+        netmask[i] = (uint8_t)((uint8_t)0xFF << (8 - bits)); // Set first bits.\n+        network.m_addr[i] &= netmask[i]; // Normalize network according to netmask.\n+        n -= bits;\n+    }\n }\n \n /**\n@@ -809,13 +811,16 @@ static inline int NetmaskBits(uint8_t x)\n     }\n }\n \n-CSubNet::CSubNet(const CNetAddr &addr, const CNetAddr &mask)\n+CSubNet::CSubNet(const CNetAddr& addr, const CNetAddr& mask) : CSubNet()\n {\n-    valid = true;\n+    valid = (addr.IsIPv4() || addr.IsIPv6()) && addr.m_net == mask.m_net;\n+    if (!valid) {\n+        return;\n+    }\n     // Check if `mask` contains 1-bits after 0-bits (which is an invalid netmask).\n     bool zeros_found = false;\n-    for (size_t i = mask.IsIPv4() ? 12 : 0; i < sizeof(mask.ip); ++i) {\n-        const int num_bits = NetmaskBits(mask.ip[i]);\n+    for (auto b : mask.m_addr) {\n+        const int num_bits = NetmaskBits(b);\n         if (num_bits == -1 || (zeros_found && num_bits != 0)) {\n             valid = false;\n             return;\n@@ -824,25 +829,30 @@ CSubNet::CSubNet(const CNetAddr &addr, const CNetAddr &mask)\n             zeros_found = true;\n         }\n     }\n-    network = addr;\n-    // Default to /32 (IPv4) or /128 (IPv6), i.e. match single address\n-    memset(netmask, 255, sizeof(netmask));\n \n-    // IPv4 addresses start at offset 12, and first 12 bytes must match, so just offset n\n-    const int astartofs = network.IsIPv4() ? 12 : 0;\n+    assert(mask.m_addr.size() <= sizeof(netmask));\n+\n+    memcpy(netmask, mask.m_addr.data(), mask.m_addr.size());\n \n-    for(int x=astartofs; x<16; ++x)\n-        netmask[x] = mask.ip[x];\n+    network = addr;\n \n     // Normalize network according to netmask\n-    for(int x=0; x<16; ++x)\n-        network.ip[x] &= netmask[x];\n+    for (size_t x = 0; x < network.m_addr.size(); ++x) {\n+        network.m_addr[x] &= netmask[x];\n+    }\n }\n \n-CSubNet::CSubNet(const CNetAddr &addr):\n-    valid(addr.IsValid())\n+CSubNet::CSubNet(const CNetAddr& addr) : CSubNet()\n {\n-    memset(netmask, 255, sizeof(netmask));\n+    valid = addr.IsIPv4() || addr.IsIPv6();\n+    if (!valid) {\n+        return;\n+    }\n+\n+    assert(addr.m_addr.size() <= sizeof(netmask));\n+\n+    memset(netmask, 0xFF, addr.m_addr.size());\n+\n     network = addr;\n }\n \n@@ -854,17 +864,22 @@ bool CSubNet::Match(const CNetAddr &addr) const\n {\n     if (!valid || !addr.IsValid() || network.m_net != addr.m_net)\n         return false;\n-    for(int x=0; x<16; ++x)\n-        if ((addr.ip[x] & netmask[x]) != network.ip[x])\n+    assert(network.m_addr.size() == addr.m_addr.size());\n+    for (size_t x = 0; x < addr.m_addr.size(); ++x) {\n+        if ((addr.m_addr[x] & netmask[x]) != network.m_addr[x]) {\n             return false;\n+        }\n+    }\n     return true;\n }\n \n std::string CSubNet::ToString() const\n {\n+    assert(network.m_addr.size() <= sizeof(netmask));\n+\n     uint8_t cidr = 0;\n \n-    for (size_t i = network.IsIPv4() ? 12 : 0; i < sizeof(netmask); ++i) {\n+    for (size_t i = 0; i < network.m_addr.size(); ++i) {\n         if (netmask[i] == 0x00) {\n             break;\n         }"
      },
      {
        "sha": "d00f5a6f556007805f0458db17817a25479b667b",
        "filename": "src/netaddress.h",
        "status": "modified",
        "additions": 134,
        "deletions": 22,
        "changes": 156,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/102867c587f5f7954232fb8ed8e85cda78bb4d32/src/netaddress.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/102867c587f5f7954232fb8ed8e85cda78bb4d32/src/netaddress.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.h?ref=102867c587f5f7954232fb8ed8e85cda78bb4d32",
        "patch": "@@ -9,9 +9,12 @@\n #include <config/bitcoin-config.h>\n #endif\n \n+#include <attributes.h>\n #include <compat.h>\n+#include <prevector.h>\n #include <serialize.h>\n \n+#include <array>\n #include <cstdint>\n #include <string>\n #include <vector>\n@@ -39,28 +42,66 @@ enum Network\n     /// TORv2\n     NET_ONION,\n \n-    /// A set of dummy addresses that map a name to an IPv6 address. These\n-    /// addresses belong to RFC4193's fc00::/7 subnet (unique-local addresses).\n-    /// We use them to map a string or FQDN to an IPv6 address in CAddrMan to\n-    /// keep track of which DNS seeds were used.\n+    /// A set of addresses that represent the hash of a string or FQDN. We use\n+    /// them in CAddrMan to keep track of which DNS seeds were used.\n     NET_INTERNAL,\n \n     /// Dummy value to indicate the number of NET_* constants.\n     NET_MAX,\n };\n \n+/// Prefix of an IPv6 address when it contains an embedded IPv4 address.\n+/// Used when (un)serializing addresses in ADDRv1 format (pre-BIP155).\n+static const std::array<uint8_t, 12> IPV4_IN_IPV6_PREFIX{\n+    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF\n+};\n+\n+/// Prefix of an IPv6 address when it contains an embedded TORv2 address.\n+/// Used when (un)serializing addresses in ADDRv1 format (pre-BIP155).\n+/// Such dummy IPv6 addresses are guaranteed to not be publicly routable as they\n+/// fall under RFC4193's fc00::/7 subnet allocated to unique-local addresses.\n+static const std::array<uint8_t, 6> TORV2_IN_IPV6_PREFIX{\n+    0xFD, 0x87, 0xD8, 0x7E, 0xEB, 0x43\n+};\n+\n+/// Prefix of an IPv6 address when it contains an embedded \"internal\" address.\n+/// Used when (un)serializing addresses in ADDRv1 format (pre-BIP155).\n+/// The prefix comes from 0xFD + SHA256(\"bitcoin\")[0:5].\n+/// Such dummy IPv6 addresses are guaranteed to not be publicly routable as they\n+/// fall under RFC4193's fc00::/7 subnet allocated to unique-local addresses.\n+static const std::array<uint8_t, 6> INTERNAL_IN_IPV6_PREFIX{\n+    0xFD, 0x6B, 0x88, 0xC0, 0x87, 0x24 // 0xFD + sha256(\"bitcoin\")[0:5].\n+};\n+\n+/// Size of IPv4 address (in bytes).\n+static constexpr size_t ADDR_IPV4_SIZE = 4;\n+\n+/// Size of IPv6 address (in bytes).\n+static constexpr size_t ADDR_IPV6_SIZE = 16;\n+\n+/// Size of TORv2 address (in bytes).\n+static constexpr size_t ADDR_TORV2_SIZE = 10;\n+\n+/// Size of \"internal\" (NET_INTERNAL) address (in bytes).\n+static constexpr size_t ADDR_INTERNAL_SIZE = 10;\n+\n /**\n  * Network address.\n  */\n class CNetAddr\n {\n     protected:\n+        /**\n+         * Raw representation of the network address.\n+         * In network byte order (big endian) for IPv4 and IPv6.\n+         */\n+        prevector<ADDR_IPV6_SIZE, uint8_t> m_addr{ADDR_IPV6_SIZE, 0x0};\n+\n         /**\n          * Network to which this address belongs.\n          */\n         Network m_net{NET_IPV6};\n \n-        unsigned char ip[16]; // in network byte order\n         uint32_t scopeId{0}; // for scoped/link-local ipv6 addresses\n \n     public:\n@@ -74,13 +115,7 @@ class CNetAddr\n          * (e.g. IPv4) disguised as IPv6. This encoding is used in the legacy\n          * `addr` encoding.\n          */\n-        void SetLegacyIPv6(const uint8_t ipv6[16]);\n-\n-        /**\n-         * Set raw IPv4 or IPv6 address (in network byte order)\n-         * @note Only NET_IPV4 and NET_IPV6 are allowed for network.\n-         */\n-        void SetRaw(Network network, const uint8_t *data);\n+        void SetLegacyIPv6(Span<const uint8_t> ipv6);\n \n         bool SetInternal(const std::string& name);\n \n@@ -111,7 +146,6 @@ class CNetAddr\n         enum Network GetNetwork() const;\n         std::string ToString() const;\n         std::string ToStringIP() const;\n-        unsigned int GetByte(int n) const;\n         uint64_t GetHash() const;\n         bool GetInAddr(struct in_addr* pipv4Addr) const;\n         uint32_t GetNetClass() const;\n@@ -127,7 +161,7 @@ class CNetAddr\n         uint32_t GetMappedAS(const std::vector<bool> &asmap) const;\n \n         std::vector<unsigned char> GetGroup(const std::vector<bool> &asmap) const;\n-        std::vector<unsigned char> GetAddrBytes() const { return {std::begin(ip), std::end(ip)}; }\n+        std::vector<unsigned char> GetAddrBytes() const;\n         int GetReachabilityFrom(const CNetAddr *paddrPartner = nullptr) const;\n \n         explicit CNetAddr(const struct in6_addr& pipv6Addr, const uint32_t scope = 0);\n@@ -143,7 +177,7 @@ class CNetAddr\n         template <typename Stream>\n         void Serialize(Stream& s) const\n         {\n-            s << ip;\n+            SerializeV1Stream(s);\n         }\n \n         /**\n@@ -152,14 +186,92 @@ class CNetAddr\n         template <typename Stream>\n         void Unserialize(Stream& s)\n         {\n-            unsigned char ip_temp[sizeof(ip)];\n-            s >> ip_temp;\n+            UnserializeV1Stream(s);\n+        }\n+\n+        friend class CSubNet;\n+\n+    private:\n+        /**\n+         * Size of CNetAddr when serialized as ADDRv1 (pre-BIP155) (in bytes).\n+         */\n+        static constexpr size_t V1_SERIALIZATION_SIZE = ADDR_IPV6_SIZE;\n+\n+        /**\n+         * Serialize in pre-ADDRv2/BIP155 format to an array.\n+         * Some addresses (e.g. TORv3) cannot be serialized in pre-BIP155 format.\n+         */\n+        void SerializeV1Array(uint8_t (&arr)[V1_SERIALIZATION_SIZE]) const\n+        {\n+            size_t prefix_size;\n+\n+            switch (m_net) {\n+            case NET_IPV6:\n+                assert(m_addr.size() == sizeof(arr));\n+                memcpy(arr, m_addr.data(), m_addr.size());\n+                return;\n+            case NET_IPV4:\n+                prefix_size = sizeof(IPV4_IN_IPV6_PREFIX);\n+                assert(prefix_size + m_addr.size() == sizeof(arr));\n+                memcpy(arr, IPV4_IN_IPV6_PREFIX.data(), prefix_size);\n+                memcpy(arr + prefix_size, m_addr.data(), m_addr.size());\n+                return;\n+            case NET_ONION:\n+                prefix_size = sizeof(TORV2_IN_IPV6_PREFIX);\n+                assert(prefix_size + m_addr.size() == sizeof(arr));\n+                memcpy(arr, TORV2_IN_IPV6_PREFIX.data(), prefix_size);\n+                memcpy(arr + prefix_size, m_addr.data(), m_addr.size());\n+                return;\n+            case NET_INTERNAL:\n+                prefix_size = sizeof(INTERNAL_IN_IPV6_PREFIX);\n+                assert(prefix_size + m_addr.size() == sizeof(arr));\n+                memcpy(arr, INTERNAL_IN_IPV6_PREFIX.data(), prefix_size);\n+                memcpy(arr + prefix_size, m_addr.data(), m_addr.size());\n+                return;\n+            case NET_UNROUTABLE:\n+            case NET_MAX:\n+                assert(false);\n+            } // no default case, so the compiler can warn about missing cases\n+\n+            assert(false);\n+        }\n+\n+        /**\n+         * Serialize in pre-ADDRv2/BIP155 format to a stream.\n+         * Some addresses (e.g. TORv3) cannot be serialized in pre-BIP155 format.\n+         */\n+        template <typename Stream>\n+        void SerializeV1Stream(Stream& s) const\n+        {\n+            uint8_t serialized[V1_SERIALIZATION_SIZE];\n+\n+            SerializeV1Array(serialized);\n+\n+            s << serialized;\n+        }\n+\n+        /**\n+         * Unserialize from a pre-ADDRv2/BIP155 format from an array.\n+         */\n+        void UnserializeV1Array(uint8_t (&arr)[V1_SERIALIZATION_SIZE])\n+        {\n             // Use SetLegacyIPv6() so that m_net is set correctly. For example\n             // ::FFFF:0102:0304 should be set as m_net=NET_IPV4 (1.2.3.4).\n-            SetLegacyIPv6(ip_temp);\n+            SetLegacyIPv6(arr);\n         }\n \n-        friend class CSubNet;\n+        /**\n+         * Unserialize from a pre-ADDRv2/BIP155 format from a stream.\n+         */\n+        template <typename Stream>\n+        void UnserializeV1Stream(Stream& s)\n+        {\n+            uint8_t serialized[V1_SERIALIZATION_SIZE];\n+\n+            s >> serialized;\n+\n+            UnserializeV1Array(serialized);\n+        }\n };\n \n class CSubNet\n@@ -174,11 +286,11 @@ class CSubNet\n \n     public:\n         CSubNet();\n-        CSubNet(const CNetAddr &addr, int32_t mask);\n-        CSubNet(const CNetAddr &addr, const CNetAddr &mask);\n+        CSubNet(const CNetAddr& addr, uint8_t mask);\n+        CSubNet(const CNetAddr& addr, const CNetAddr& mask);\n \n         //constructor for single ip subnet (<ipv4>/32 or <ipv6>/128)\n-        explicit CSubNet(const CNetAddr &addr);\n+        explicit CSubNet(const CNetAddr& addr);\n \n         bool Match(const CNetAddr &addr) const;\n "
      },
      {
        "sha": "0273839017c07afd2aae2297c5c3d8fed9617642",
        "filename": "src/netbase.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/102867c587f5f7954232fb8ed8e85cda78bb4d32/src/netbase.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/102867c587f5f7954232fb8ed8e85cda78bb4d32/src/netbase.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.cpp?ref=102867c587f5f7954232fb8ed8e85cda78bb4d32",
        "patch": "@@ -13,6 +13,7 @@\n \n #include <atomic>\n #include <cstdint>\n+#include <limits>\n \n #ifndef WIN32\n #include <fcntl.h>\n@@ -838,8 +839,8 @@ bool LookupSubNet(const std::string& strSubnet, CSubNet& ret)\n         if (slash != strSubnet.npos)\n         {\n             std::string strNetmask = strSubnet.substr(slash + 1);\n-            int32_t n;\n-            if (ParseInt32(strNetmask, &n)) {\n+            uint8_t n;\n+            if (ParseUInt8(strNetmask, &n)) {\n                 // If valid number, assume CIDR variable-length subnet masking\n                 ret = CSubNet(network, n);\n                 return ret.IsValid();"
      },
      {
        "sha": "e3aefa18a330322c880ef843a59868b1f0c2a6aa",
        "filename": "src/test/fuzz/asmap.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 2,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/102867c587f5f7954232fb8ed8e85cda78bb4d32/src/test/fuzz/asmap.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/102867c587f5f7954232fb8ed8e85cda78bb4d32/src/test/fuzz/asmap.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/asmap.cpp?ref=102867c587f5f7954232fb8ed8e85cda78bb4d32",
        "patch": "@@ -33,7 +33,7 @@ void test_one_input(const std::vector<uint8_t>& buffer)\n     if (buffer.size() < 1 + 3 + 4) return;\n     int asmap_size = 3 + (buffer[0] & 127);\n     bool ipv6 = buffer[0] & 128;\n-    int addr_size = ipv6 ? 16 : 4;\n+    const size_t addr_size = ipv6 ? ADDR_IPV6_SIZE : ADDR_IPV4_SIZE;\n     if (buffer.size() < size_t(1 + asmap_size + addr_size)) return;\n     std::vector<bool> asmap = ipv6 ? IPV6_PREFIX_ASMAP : IPV4_PREFIX_ASMAP;\n     asmap.reserve(asmap.size() + 8 * asmap_size);\n@@ -43,7 +43,17 @@ void test_one_input(const std::vector<uint8_t>& buffer)\n         }\n     }\n     if (!SanityCheckASMap(asmap)) return;\n+\n+    const uint8_t* addr_data = buffer.data() + 1 + asmap_size;\n     CNetAddr net_addr;\n-    net_addr.SetRaw(ipv6 ? NET_IPV6 : NET_IPV4, buffer.data() + 1 + asmap_size);\n+    if (ipv6) {\n+        assert(addr_size == ADDR_IPV6_SIZE);\n+        net_addr.SetLegacyIPv6(Span<const uint8_t>(addr_data, addr_size));\n+    } else {\n+        assert(addr_size == ADDR_IPV4_SIZE);\n+        in_addr ipv4;\n+        memcpy(&ipv4, addr_data, addr_size);\n+        net_addr.SetIP(CNetAddr{ipv4});\n+    }\n     (void)net_addr.GetMappedAS(asmap);\n }"
      },
      {
        "sha": "8252f3872664196720ac9ff147716603f170382f",
        "filename": "src/test/fuzz/netaddress.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 4,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/102867c587f5f7954232fb8ed8e85cda78bb4d32/src/test/fuzz/netaddress.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/102867c587f5f7954232fb8ed8e85cda78bb4d32/src/test/fuzz/netaddress.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/netaddress.cpp?ref=102867c587f5f7954232fb8ed8e85cda78bb4d32",
        "patch": "@@ -17,9 +17,6 @@ void test_one_input(const std::vector<uint8_t>& buffer)\n     FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n \n     const CNetAddr net_addr = ConsumeNetAddr(fuzzed_data_provider);\n-    for (int i = 0; i < 15; ++i) {\n-        (void)net_addr.GetByte(i);\n-    }\n     (void)net_addr.GetHash();\n     (void)net_addr.GetNetClass();\n     if (net_addr.GetNetwork() == Network::NET_IPV4) {\n@@ -78,7 +75,7 @@ void test_one_input(const std::vector<uint8_t>& buffer)\n     (void)net_addr.ToString();\n     (void)net_addr.ToStringIP();\n \n-    const CSubNet sub_net{net_addr, fuzzed_data_provider.ConsumeIntegral<int32_t>()};\n+    const CSubNet sub_net{net_addr, fuzzed_data_provider.ConsumeIntegral<uint8_t>()};\n     (void)sub_net.IsValid();\n     (void)sub_net.ToString();\n "
      },
      {
        "sha": "ed6093a8a83eb165882630797e2798b9df1a3dce",
        "filename": "src/test/fuzz/util.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/102867c587f5f7954232fb8ed8e85cda78bb4d32/src/test/fuzz/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/102867c587f5f7954232fb8ed8e85cda78bb4d32/src/test/fuzz/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/util.h?ref=102867c587f5f7954232fb8ed8e85cda78bb4d32",
        "patch": "@@ -257,7 +257,7 @@ CNetAddr ConsumeNetAddr(FuzzedDataProvider& fuzzed_data_provider) noexcept\n \n CSubNet ConsumeSubNet(FuzzedDataProvider& fuzzed_data_provider) noexcept\n {\n-    return {ConsumeNetAddr(fuzzed_data_provider), fuzzed_data_provider.ConsumeIntegral<int32_t>()};\n+    return {ConsumeNetAddr(fuzzed_data_provider), fuzzed_data_provider.ConsumeIntegral<uint8_t>()};\n }\n \n void InitializeFuzzingContext(const std::string& chain_name = CBaseChainParams::REGTEST)"
      },
      {
        "sha": "2a3585d1042f441b0639c5a7fa8afe169a764e5f",
        "filename": "src/test/net_tests.cpp",
        "status": "modified",
        "additions": 74,
        "deletions": 0,
        "changes": 74,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/102867c587f5f7954232fb8ed8e85cda78bb4d32/src/test/net_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/102867c587f5f7954232fb8ed8e85cda78bb4d32/src/test/net_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/net_tests.cpp?ref=102867c587f5f7954232fb8ed8e85cda78bb4d32",
        "patch": "@@ -13,8 +13,10 @@\n #include <streams.h>\n #include <test/util/setup_common.h>\n #include <util/memory.h>\n+#include <util/strencodings.h>\n #include <util/string.h>\n #include <util/system.h>\n+#include <version.h>\n \n #include <boost/test/unit_test.hpp>\n \n@@ -193,6 +195,78 @@ BOOST_AUTO_TEST_CASE(cnode_simple_test)\n     BOOST_CHECK(pnode2->fFeeler == false);\n }\n \n+BOOST_AUTO_TEST_CASE(cnetaddr_basic)\n+{\n+    CNetAddr addr;\n+\n+    // IPv4, INADDR_ANY\n+    BOOST_REQUIRE(LookupHost(\"0.0.0.0\", addr, false));\n+    BOOST_REQUIRE(!addr.IsValid());\n+    BOOST_REQUIRE(addr.IsIPv4());\n+\n+    BOOST_CHECK(addr.IsBindAny());\n+    BOOST_CHECK_EQUAL(addr.ToString(), \"0.0.0.0\");\n+\n+    // IPv4, INADDR_NONE\n+    BOOST_REQUIRE(LookupHost(\"255.255.255.255\", addr, false));\n+    BOOST_REQUIRE(!addr.IsValid());\n+    BOOST_REQUIRE(addr.IsIPv4());\n+\n+    BOOST_CHECK(!addr.IsBindAny());\n+    BOOST_CHECK_EQUAL(addr.ToString(), \"255.255.255.255\");\n+\n+    // IPv4, casual\n+    BOOST_REQUIRE(LookupHost(\"12.34.56.78\", addr, false));\n+    BOOST_REQUIRE(addr.IsValid());\n+    BOOST_REQUIRE(addr.IsIPv4());\n+\n+    BOOST_CHECK(!addr.IsBindAny());\n+    BOOST_CHECK_EQUAL(addr.ToString(), \"12.34.56.78\");\n+\n+    // IPv6, in6addr_any\n+    BOOST_REQUIRE(LookupHost(\"::\", addr, false));\n+    BOOST_REQUIRE(!addr.IsValid());\n+    BOOST_REQUIRE(addr.IsIPv6());\n+\n+    BOOST_CHECK(addr.IsBindAny());\n+    BOOST_CHECK_EQUAL(addr.ToString(), \"::\");\n+\n+    // IPv6, casual\n+    BOOST_REQUIRE(LookupHost(\"1122:3344:5566:7788:9900:aabb:ccdd:eeff\", addr, false));\n+    BOOST_REQUIRE(addr.IsValid());\n+    BOOST_REQUIRE(addr.IsIPv6());\n+\n+    BOOST_CHECK(!addr.IsBindAny());\n+    BOOST_CHECK_EQUAL(addr.ToString(), \"1122:3344:5566:7788:9900:aabb:ccdd:eeff\");\n+\n+    // TORv2\n+    addr.SetSpecial(\"6hzph5hv6337r6p2.onion\");\n+    BOOST_REQUIRE(addr.IsValid());\n+    BOOST_REQUIRE(addr.IsTor());\n+\n+    BOOST_CHECK(!addr.IsBindAny());\n+    BOOST_CHECK_EQUAL(addr.ToString(), \"6hzph5hv6337r6p2.onion\");\n+\n+    // Internal\n+    addr.SetInternal(\"esffpp\");\n+    BOOST_REQUIRE(!addr.IsValid()); // \"internal\" is considered invalid\n+    BOOST_REQUIRE(addr.IsInternal());\n+\n+    BOOST_CHECK(!addr.IsBindAny());\n+    BOOST_CHECK_EQUAL(addr.ToString(), \"esffpvrt3wpeaygy.internal\");\n+}\n+\n+BOOST_AUTO_TEST_CASE(cnetaddr_serialize)\n+{\n+    CNetAddr addr;\n+    CDataStream s(SER_NETWORK, PROTOCOL_VERSION);\n+\n+    addr.SetInternal(\"a\");\n+    s << addr;\n+    BOOST_CHECK_EQUAL(HexStr(s), \"fd6b88c08724ca978112ca1bbdcafac2\");\n+    s.clear();\n+}\n+\n // prior to PR #14728, this test triggers an undefined behavior\n BOOST_AUTO_TEST_CASE(ipv4_peer_with_ipv6_addrMe_test)\n {"
      },
      {
        "sha": "6681c92bb52073397930a3cae966ac7dafea9a2d",
        "filename": "src/test/netbase_tests.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 1,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/102867c587f5f7954232fb8ed8e85cda78bb4d32/src/test/netbase_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/102867c587f5f7954232fb8ed8e85cda78bb4d32/src/test/netbase_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/netbase_tests.cpp?ref=102867c587f5f7954232fb8ed8e85cda78bb4d32",
        "patch": "@@ -185,6 +185,7 @@ BOOST_AUTO_TEST_CASE(subnet_test)\n     BOOST_CHECK(!ResolveSubNet(\"1.2.3.0/-1\").IsValid());\n     BOOST_CHECK(ResolveSubNet(\"1.2.3.0/32\").IsValid());\n     BOOST_CHECK(!ResolveSubNet(\"1.2.3.0/33\").IsValid());\n+    BOOST_CHECK(!ResolveSubNet(\"1.2.3.0/300\").IsValid());\n     BOOST_CHECK(ResolveSubNet(\"1:2:3:4:5:6:7:8/0\").IsValid());\n     BOOST_CHECK(ResolveSubNet(\"1:2:3:4:5:6:7:8/33\").IsValid());\n     BOOST_CHECK(!ResolveSubNet(\"1:2:3:4:5:6:7:8/-1\").IsValid());\n@@ -216,6 +217,11 @@ BOOST_AUTO_TEST_CASE(subnet_test)\n     BOOST_CHECK(CSubNet(ResolveIP(\"1:2:3:4:5:6:7:8\")).Match(ResolveIP(\"1:2:3:4:5:6:7:8\")));\n     BOOST_CHECK(!CSubNet(ResolveIP(\"1:2:3:4:5:6:7:8\")).Match(ResolveIP(\"1:2:3:4:5:6:7:9\")));\n     BOOST_CHECK(CSubNet(ResolveIP(\"1:2:3:4:5:6:7:8\")).ToString() == \"1:2:3:4:5:6:7:8/128\");\n+    // IPv4 address with IPv6 netmask or the other way around.\n+    BOOST_CHECK(!CSubNet(ResolveIP(\"1.1.1.1\"), ResolveIP(\"ffff::\")).IsValid());\n+    BOOST_CHECK(!CSubNet(ResolveIP(\"::1\"), ResolveIP(\"255.0.0.0\")).IsValid());\n+    // Can't subnet TOR (or any other non-IPv4 and non-IPv6 network).\n+    BOOST_CHECK(!CSubNet(ResolveIP(\"5wyqrzbvrdsumnok.onion\"), ResolveIP(\"255.0.0.0\")).IsValid());\n \n     subnet = ResolveSubNet(\"1.2.3.4/255.255.255.255\");\n     BOOST_CHECK_EQUAL(subnet.ToString(), \"1.2.3.4/32\");\n@@ -430,7 +436,8 @@ BOOST_AUTO_TEST_CASE(netbase_dont_resolve_strings_with_embedded_nul_characters)\n     BOOST_CHECK(!LookupSubNet(std::string(\"1.2.3.0/24\\0\", 11), ret));\n     BOOST_CHECK(!LookupSubNet(std::string(\"1.2.3.0/24\\0example.com\", 22), ret));\n     BOOST_CHECK(!LookupSubNet(std::string(\"1.2.3.0/24\\0example.com\\0\", 23), ret));\n-    BOOST_CHECK(LookupSubNet(std::string(\"5wyqrzbvrdsumnok.onion\", 22), ret));\n+    // We only do subnetting for IPv4 and IPv6\n+    BOOST_CHECK(!LookupSubNet(std::string(\"5wyqrzbvrdsumnok.onion\", 22), ret));\n     BOOST_CHECK(!LookupSubNet(std::string(\"5wyqrzbvrdsumnok.onion\\0\", 23), ret));\n     BOOST_CHECK(!LookupSubNet(std::string(\"5wyqrzbvrdsumnok.onion\\0example.com\", 34), ret));\n     BOOST_CHECK(!LookupSubNet(std::string(\"5wyqrzbvrdsumnok.onion\\0example.com\\0\", 35), ret));"
      },
      {
        "sha": "44f9c708ba47e3f66a4431a0719bc8c760847f30",
        "filename": "src/util/strencodings.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/102867c587f5f7954232fb8ed8e85cda78bb4d32/src/util/strencodings.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/102867c587f5f7954232fb8ed8e85cda78bb4d32/src/util/strencodings.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/strencodings.cpp?ref=102867c587f5f7954232fb8ed8e85cda78bb4d32",
        "patch": "@@ -318,6 +318,18 @@ bool ParseInt64(const std::string& str, int64_t *out)\n         n <= std::numeric_limits<int64_t>::max();\n }\n \n+bool ParseUInt8(const std::string& str, uint8_t *out)\n+{\n+    uint32_t u32;\n+    if (!ParseUInt32(str, &u32) || u32 > std::numeric_limits<uint8_t>::max()) {\n+        return false;\n+    }\n+    if (out != nullptr) {\n+        *out = static_cast<uint8_t>(u32);\n+    }\n+    return true;\n+}\n+\n bool ParseUInt32(const std::string& str, uint32_t *out)\n {\n     if (!ParsePrechecks(str))"
      },
      {
        "sha": "8415e4bd6aeb3cc6c766cbfceffe3f636ed55113",
        "filename": "src/util/strencodings.h",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/102867c587f5f7954232fb8ed8e85cda78bb4d32/src/util/strencodings.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/102867c587f5f7954232fb8ed8e85cda78bb4d32/src/util/strencodings.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/strencodings.h?ref=102867c587f5f7954232fb8ed8e85cda78bb4d32",
        "patch": "@@ -99,6 +99,13 @@ NODISCARD bool ParseInt32(const std::string& str, int32_t *out);\n  */\n NODISCARD bool ParseInt64(const std::string& str, int64_t *out);\n \n+/**\n+ * Convert decimal string to unsigned 8-bit integer with strict parse error feedback.\n+ * @returns true if the entire string could be parsed as valid integer,\n+ *   false if not the entire string could be parsed or when overflow or underflow occurred.\n+ */\n+NODISCARD bool ParseUInt8(const std::string& str, uint8_t *out);\n+\n /**\n  * Convert decimal string to unsigned 32-bit integer with strict parse error feedback.\n  * @returns true if the entire string could be parsed as valid integer,"
      }
    ]
  }
]