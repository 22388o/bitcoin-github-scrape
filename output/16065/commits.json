[
  {
    "sha": "b7a3beccd0ef6a49b0f57a0c499afde6b02d1500",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiN2EzYmVjY2QwZWY2YTQ5YjBmNTdhMGM0OTlhZmRlNmIwMmQxNTAw",
    "commit": {
      "author": {
        "name": "Jo\u00e3o Barbosa",
        "email": "joao.paulo.barbosa@gmail.com",
        "date": "2019-05-21T12:26:24Z"
      },
      "committer": {
        "name": "Jo\u00e3o Barbosa",
        "email": "joao.paulo.barbosa@gmail.com",
        "date": "2019-05-21T13:10:24Z"
      },
      "message": "refactor: Reuse block hash in AddToBlockIndex",
      "tree": {
        "sha": "f6ffb7daadfcdf189fc376f81bce79a7d3f606cc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f6ffb7daadfcdf189fc376f81bce79a7d3f606cc"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b7a3beccd0ef6a49b0f57a0c499afde6b02d1500",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b7a3beccd0ef6a49b0f57a0c499afde6b02d1500",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b7a3beccd0ef6a49b0f57a0c499afde6b02d1500",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b7a3beccd0ef6a49b0f57a0c499afde6b02d1500/comments",
    "author": {
      "login": "promag",
      "id": 3534524,
      "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/promag",
      "html_url": "https://github.com/promag",
      "followers_url": "https://api.github.com/users/promag/followers",
      "following_url": "https://api.github.com/users/promag/following{/other_user}",
      "gists_url": "https://api.github.com/users/promag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/promag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
      "organizations_url": "https://api.github.com/users/promag/orgs",
      "repos_url": "https://api.github.com/users/promag/repos",
      "events_url": "https://api.github.com/users/promag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/promag/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "promag",
      "id": 3534524,
      "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/promag",
      "html_url": "https://github.com/promag",
      "followers_url": "https://api.github.com/users/promag/followers",
      "following_url": "https://api.github.com/users/promag/following{/other_user}",
      "gists_url": "https://api.github.com/users/promag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/promag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
      "organizations_url": "https://api.github.com/users/promag/orgs",
      "repos_url": "https://api.github.com/users/promag/repos",
      "events_url": "https://api.github.com/users/promag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/promag/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "3001cc61cf11e016c403ce83c9cbcfd3efcbcfd9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3001cc61cf11e016c403ce83c9cbcfd3efcbcfd9",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3001cc61cf11e016c403ce83c9cbcfd3efcbcfd9"
      }
    ],
    "stats": {
      "total": 11,
      "additions": 5,
      "deletions": 6
    },
    "files": [
      {
        "sha": "edb9b2bb7a3c500b1d973a07ac5135b1fc49d84c",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 6,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b7a3beccd0ef6a49b0f57a0c499afde6b02d1500/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b7a3beccd0ef6a49b0f57a0c499afde6b02d1500/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=b7a3beccd0ef6a49b0f57a0c499afde6b02d1500",
        "patch": "@@ -200,7 +200,7 @@ class CChainState {\n     bool ActivateBestChainStep(CValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexMostWork, const std::shared_ptr<const CBlock>& pblock, bool& fInvalidFound, ConnectTrace& connectTrace) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n     bool ConnectTip(CValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexNew, const std::shared_ptr<const CBlock>& pblock, ConnectTrace& connectTrace, DisconnectedBlockTransactions &disconnectpool) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n-    CBlockIndex* AddToBlockIndex(const CBlockHeader& block) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    CBlockIndex* AddToBlockIndex(const uint256& hash, const CBlockHeader& block) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n     /** Create a new block index entry for a given block hash */\n     CBlockIndex* InsertBlockIndex(const uint256& hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n     /**\n@@ -2929,12 +2929,11 @@ void ResetBlockFailureFlags(CBlockIndex *pindex) {\n     return g_chainstate.ResetBlockFailureFlags(pindex);\n }\n \n-CBlockIndex* CChainState::AddToBlockIndex(const CBlockHeader& block)\n+CBlockIndex* CChainState::AddToBlockIndex(const uint256& hash, const CBlockHeader& block)\n {\n     AssertLockHeld(cs_main);\n \n     // Check for duplicate\n-    uint256 hash = block.GetHash();\n     BlockMap::iterator it = mapBlockIndex.find(hash);\n     if (it != mapBlockIndex.end())\n         return it->second;\n@@ -3379,7 +3378,7 @@ bool CChainState::AcceptBlockHeader(const CBlockHeader& block, CValidationState&\n {\n     AssertLockHeld(cs_main);\n     // Check for duplicate\n-    uint256 hash = block.GetHash();\n+    const uint256 hash = block.GetHash();\n     BlockMap::iterator miSelf = mapBlockIndex.find(hash);\n     CBlockIndex *pindex = nullptr;\n     if (hash != chainparams.GetConsensus().hashGenesisBlock) {\n@@ -3446,7 +3445,7 @@ bool CChainState::AcceptBlockHeader(const CBlockHeader& block, CValidationState&\n         }\n     }\n     if (pindex == nullptr)\n-        pindex = AddToBlockIndex(block);\n+        pindex = AddToBlockIndex(hash, block);\n \n     if (ppindex)\n         *ppindex = pindex;\n@@ -4394,7 +4393,7 @@ bool CChainState::LoadGenesisBlock(const CChainParams& chainparams)\n         FlatFilePos blockPos = SaveBlockToDisk(block, 0, chainparams, nullptr);\n         if (blockPos.IsNull())\n             return error(\"%s: writing genesis block to disk failed\", __func__);\n-        CBlockIndex *pindex = AddToBlockIndex(block);\n+        CBlockIndex *pindex = AddToBlockIndex(block.GetHash(), block);\n         ReceivedBlockTransactions(block, pindex, blockPos, chainparams.GetConsensus());\n     } catch (const std::runtime_error& e) {\n         return error(\"%s: failed to write genesis block: %s\", __func__, e.what());"
      }
    ]
  },
  {
    "sha": "9f834d78d8a46d2cdf966261d6b414c1576cc0e7",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5ZjgzNGQ3OGQ4YTQ2ZDJjZGY5NjYyNjFkNmI0MTRjMTU3NmNjMGU3",
    "commit": {
      "author": {
        "name": "Jo\u00e3o Barbosa",
        "email": "joao.paulo.barbosa@gmail.com",
        "date": "2019-05-21T21:46:59Z"
      },
      "committer": {
        "name": "Jo\u00e3o Barbosa",
        "email": "joao.paulo.barbosa@gmail.com",
        "date": "2019-05-21T21:46:59Z"
      },
      "message": "fixup: Add BlockHeaderHashed",
      "tree": {
        "sha": "b200a36d2eca4e9e956b3d3887e5ab7901858b55",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b200a36d2eca4e9e956b3d3887e5ab7901858b55"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9f834d78d8a46d2cdf966261d6b414c1576cc0e7",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9f834d78d8a46d2cdf966261d6b414c1576cc0e7",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9f834d78d8a46d2cdf966261d6b414c1576cc0e7",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9f834d78d8a46d2cdf966261d6b414c1576cc0e7/comments",
    "author": {
      "login": "promag",
      "id": 3534524,
      "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/promag",
      "html_url": "https://github.com/promag",
      "followers_url": "https://api.github.com/users/promag/followers",
      "following_url": "https://api.github.com/users/promag/following{/other_user}",
      "gists_url": "https://api.github.com/users/promag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/promag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
      "organizations_url": "https://api.github.com/users/promag/orgs",
      "repos_url": "https://api.github.com/users/promag/repos",
      "events_url": "https://api.github.com/users/promag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/promag/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "promag",
      "id": 3534524,
      "node_id": "MDQ6VXNlcjM1MzQ1MjQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3534524?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/promag",
      "html_url": "https://github.com/promag",
      "followers_url": "https://api.github.com/users/promag/followers",
      "following_url": "https://api.github.com/users/promag/following{/other_user}",
      "gists_url": "https://api.github.com/users/promag/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/promag/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/promag/subscriptions",
      "organizations_url": "https://api.github.com/users/promag/orgs",
      "repos_url": "https://api.github.com/users/promag/repos",
      "events_url": "https://api.github.com/users/promag/events{/privacy}",
      "received_events_url": "https://api.github.com/users/promag/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b7a3beccd0ef6a49b0f57a0c499afde6b02d1500",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b7a3beccd0ef6a49b0f57a0c499afde6b02d1500",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b7a3beccd0ef6a49b0f57a0c499afde6b02d1500"
      }
    ],
    "stats": {
      "total": 50,
      "additions": 30,
      "deletions": 20
    },
    "files": [
      {
        "sha": "f432c4256c2ed164f92f50c50aefb757555f1bd7",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 30,
        "deletions": 20,
        "changes": 50,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9f834d78d8a46d2cdf966261d6b414c1576cc0e7/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9f834d78d8a46d2cdf966261d6b414c1576cc0e7/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=9f834d78d8a46d2cdf966261d6b414c1576cc0e7",
        "patch": "@@ -60,6 +60,17 @@\n #define MICRO 0.000001\n #define MILLI 0.001\n \n+struct BlockHeaderHashed\n+{\n+    const CBlockHeader& header;\n+    const uint256 hash;\n+    BlockHeaderHashed(const CBlockHeader& header)\n+        : header(header)\n+        , hash(header.GetHash()) {}\n+    BlockHeaderHashed(const BlockHeaderHashed&) = delete;\n+    BlockHeaderHashed& operator=(const BlockHeaderHashed&) = delete;\n+};\n+\n /**\n  * Global state\n  */\n@@ -172,7 +183,7 @@ class CChainState {\n      * If a block header hasn't already been seen, call CheckBlockHeader on it, ensure\n      * that it doesn't descend from an invalid block, and then add it to mapBlockIndex.\n      */\n-    bool AcceptBlockHeader(const CBlockHeader& block, CValidationState& state, const CChainParams& chainparams, CBlockIndex** ppindex) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    bool AcceptBlockHeader(const BlockHeaderHashed& block, CValidationState& state, const CChainParams& chainparams, CBlockIndex** ppindex) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n     bool AcceptBlock(const std::shared_ptr<const CBlock>& pblock, CValidationState& state, const CChainParams& chainparams, CBlockIndex** ppindex, bool fRequested, const FlatFilePos* dbp, bool* fNewBlock) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n     // Block (dis)connection on a given view:\n@@ -200,7 +211,7 @@ class CChainState {\n     bool ActivateBestChainStep(CValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexMostWork, const std::shared_ptr<const CBlock>& pblock, bool& fInvalidFound, ConnectTrace& connectTrace) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n     bool ConnectTip(CValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexNew, const std::shared_ptr<const CBlock>& pblock, ConnectTrace& connectTrace, DisconnectedBlockTransactions &disconnectpool) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n-    CBlockIndex* AddToBlockIndex(const uint256& hash, const CBlockHeader& block) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    CBlockIndex* AddToBlockIndex(const BlockHeaderHashed& block) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n     /** Create a new block index entry for a given block hash */\n     CBlockIndex* InsertBlockIndex(const uint256& hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n     /**\n@@ -2929,24 +2940,24 @@ void ResetBlockFailureFlags(CBlockIndex *pindex) {\n     return g_chainstate.ResetBlockFailureFlags(pindex);\n }\n \n-CBlockIndex* CChainState::AddToBlockIndex(const uint256& hash, const CBlockHeader& block)\n+CBlockIndex* CChainState::AddToBlockIndex(const BlockHeaderHashed& block)\n {\n     AssertLockHeld(cs_main);\n \n     // Check for duplicate\n-    BlockMap::iterator it = mapBlockIndex.find(hash);\n+    BlockMap::iterator it = mapBlockIndex.find(block.hash);\n     if (it != mapBlockIndex.end())\n         return it->second;\n \n     // Construct new block index object\n-    CBlockIndex* pindexNew = new CBlockIndex(block);\n+    CBlockIndex* pindexNew = new CBlockIndex(block.header);\n     // We assign the sequence id to blocks only when the full data is available,\n     // to avoid miners withholding blocks but broadcasting headers, to get a\n     // competitive advantage.\n     pindexNew->nSequenceId = 0;\n-    BlockMap::iterator mi = mapBlockIndex.insert(std::make_pair(hash, pindexNew)).first;\n+    BlockMap::iterator mi = mapBlockIndex.insert(std::make_pair(block.hash, pindexNew)).first;\n     pindexNew->phashBlock = &((*mi).first);\n-    BlockMap::iterator miPrev = mapBlockIndex.find(block.hashPrevBlock);\n+    BlockMap::iterator miPrev = mapBlockIndex.find(block.header.hashPrevBlock);\n     if (miPrev != mapBlockIndex.end())\n     {\n         pindexNew->pprev = (*miPrev).second;\n@@ -3082,10 +3093,10 @@ static bool FindUndoPos(CValidationState &state, int nFile, FlatFilePos &pos, un\n     return true;\n }\n \n-static bool CheckBlockHeader(const CBlockHeader& block, CValidationState& state, const Consensus::Params& consensusParams, bool fCheckPOW = true)\n+static bool CheckBlockHeader(const BlockHeaderHashed& block, CValidationState& state, const Consensus::Params& consensusParams, bool fCheckPOW = true)\n {\n     // Check proof of work matches claimed amount\n-    if (fCheckPOW && !CheckProofOfWork(block.GetHash(), block.nBits, consensusParams))\n+    if (fCheckPOW && !CheckProofOfWork(block.hash, block.header.nBits, consensusParams))\n         return state.Invalid(ValidationInvalidReason::BLOCK_INVALID_HEADER, false, REJECT_INVALID, \"high-hash\", \"proof of work failed\");\n \n     return true;\n@@ -3374,37 +3385,36 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n     return true;\n }\n \n-bool CChainState::AcceptBlockHeader(const CBlockHeader& block, CValidationState& state, const CChainParams& chainparams, CBlockIndex** ppindex)\n+bool CChainState::AcceptBlockHeader(const BlockHeaderHashed& block, CValidationState& state, const CChainParams& chainparams, CBlockIndex** ppindex)\n {\n     AssertLockHeld(cs_main);\n     // Check for duplicate\n-    const uint256 hash = block.GetHash();\n-    BlockMap::iterator miSelf = mapBlockIndex.find(hash);\n+    BlockMap::iterator miSelf = mapBlockIndex.find(block.hash);\n     CBlockIndex *pindex = nullptr;\n-    if (hash != chainparams.GetConsensus().hashGenesisBlock) {\n+    if (block.hash != chainparams.GetConsensus().hashGenesisBlock) {\n         if (miSelf != mapBlockIndex.end()) {\n             // Block header is already known.\n             pindex = miSelf->second;\n             if (ppindex)\n                 *ppindex = pindex;\n             if (pindex->nStatus & BLOCK_FAILED_MASK)\n-                return state.Invalid(ValidationInvalidReason::CACHED_INVALID, error(\"%s: block %s is marked invalid\", __func__, hash.ToString()), 0, \"duplicate\");\n+                return state.Invalid(ValidationInvalidReason::CACHED_INVALID, error(\"%s: block %s is marked invalid\", __func__, block.hash.ToString()), 0, \"duplicate\");\n             return true;\n         }\n \n         if (!CheckBlockHeader(block, state, chainparams.GetConsensus()))\n-            return error(\"%s: Consensus::CheckBlockHeader: %s, %s\", __func__, hash.ToString(), FormatStateMessage(state));\n+            return error(\"%s: Consensus::CheckBlockHeader: %s, %s\", __func__, block.hash.ToString(), FormatStateMessage(state));\n \n         // Get prev block index\n         CBlockIndex* pindexPrev = nullptr;\n-        BlockMap::iterator mi = mapBlockIndex.find(block.hashPrevBlock);\n+        BlockMap::iterator mi = mapBlockIndex.find(block.header.hashPrevBlock);\n         if (mi == mapBlockIndex.end())\n             return state.Invalid(ValidationInvalidReason::BLOCK_MISSING_PREV, error(\"%s: prev block not found\", __func__), 0, \"prev-blk-not-found\");\n         pindexPrev = (*mi).second;\n         if (pindexPrev->nStatus & BLOCK_FAILED_MASK)\n             return state.Invalid(ValidationInvalidReason::BLOCK_INVALID_PREV, error(\"%s: prev block invalid\", __func__), REJECT_INVALID, \"bad-prevblk\");\n-        if (!ContextualCheckBlockHeader(block, state, chainparams, pindexPrev, GetAdjustedTime()))\n-            return error(\"%s: Consensus::ContextualCheckBlockHeader: %s, %s\", __func__, hash.ToString(), FormatStateMessage(state));\n+        if (!ContextualCheckBlockHeader(block.header, state, chainparams, pindexPrev, GetAdjustedTime()))\n+            return error(\"%s: Consensus::ContextualCheckBlockHeader: %s, %s\", __func__, block.hash.ToString(), FormatStateMessage(state));\n \n         /* Determine if this block descends from any block which has been found\n          * invalid (m_failed_blocks), then mark pindexPrev and any blocks between\n@@ -3445,7 +3455,7 @@ bool CChainState::AcceptBlockHeader(const CBlockHeader& block, CValidationState&\n         }\n     }\n     if (pindex == nullptr)\n-        pindex = AddToBlockIndex(hash, block);\n+        pindex = AddToBlockIndex(block);\n \n     if (ppindex)\n         *ppindex = pindex;\n@@ -4393,7 +4403,7 @@ bool CChainState::LoadGenesisBlock(const CChainParams& chainparams)\n         FlatFilePos blockPos = SaveBlockToDisk(block, 0, chainparams, nullptr);\n         if (blockPos.IsNull())\n             return error(\"%s: writing genesis block to disk failed\", __func__);\n-        CBlockIndex *pindex = AddToBlockIndex(block.GetHash(), block);\n+        CBlockIndex *pindex = AddToBlockIndex(block);\n         ReceivedBlockTransactions(block, pindex, blockPos, chainparams.GetConsensus());\n     } catch (const std::runtime_error& e) {\n         return error(\"%s: failed to write genesis block: %s\", __func__, e.what());"
      }
    ]
  }
]