laanwj,2017-05-17T08:14:03Z,Thanks for the improvements; I still have to review the unescaping loop in detail but overall it looks good to me.,https://github.com/bitcoin/bitcoin/pull/10408#issuecomment-302018877,302018877,
laanwj,2017-05-18T17:58:02Z,utACK 49a199b,https://github.com/bitcoin/bitcoin/pull/10408#issuecomment-302490985,302490985,
laanwj,2017-05-17T08:09:07Z,Wouldn't the fread already return `<=0` in the case of an error? (making it necessary to move the check outside of the loop),https://github.com/bitcoin/bitcoin/pull/10408#discussion_r116934975,116934975,src/torcontrol.cpp
str4d,2017-05-17T12:06:54Z,"No, there is [no such guarantee](http://www.cplusplus.com/reference/cstdio/fread/#return):\n\n> If [the return value] differs from the _count_ parameter, either a reading error occurred or the _end-of-file_ was reached while reading. In both cases, the proper indicator is set, which can be checked with ferror and feof, respectively.\n\nSo it is entirely possible for `fread` to return a number ",https://github.com/bitcoin/bitcoin/pull/10408#discussion_r116981511,116981511,src/torcontrol.cpp
str4d,2017-05-17T12:22:13Z,"The reason we added this check was the possibility that a read error could occur at byte 33, resulting in 32 bytes of a larger file being returned and used as the cookie (which checks for exact length), in violation of `control-spec`. Thus we only need to defend against the case where `fread` returns a value greater than zero on error; since the buffer is larger than the cookie size, the only rema",https://github.com/bitcoin/bitcoin/pull/10408#discussion_r116984200,116984200,src/torcontrol.cpp
laanwj,2017-05-17T17:29:44Z,"Interesting, I didn't know that, I though that only the EOF (or interrupted by signal) case would cause it to return a smaller amount larger or equal to zero (which according to the manual page is the case for `read`, but apparently not `fread`). ",https://github.com/bitcoin/bitcoin/pull/10408#discussion_r117063812,117063812,src/torcontrol.cpp
