[
  {
    "sha": "e587bc3fd9ed7eb1aa787859748f37dd387f9cec",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplNTg3YmMzZmQ5ZWQ3ZWIxYWE3ODc4NTk3NDhmMzdkZDM4N2Y5Y2Vj",
    "commit": {
      "author": {
        "name": "Alex Morcos",
        "email": "morcos@chaincode.com",
        "date": "2015-11-14T22:04:15Z"
      },
      "committer": {
        "name": "Alex Morcos",
        "email": "morcos@chaincode.com",
        "date": "2015-11-17T01:41:32Z"
      },
      "message": "Implement helper class for CTxMemPoolEntry constructor\n\nThis is only for unit tests.",
      "tree": {
        "sha": "64af57efb50d03f9fc81f00dcf261d293cdfd803",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/64af57efb50d03f9fc81f00dcf261d293cdfd803"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e587bc3fd9ed7eb1aa787859748f37dd387f9cec",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e587bc3fd9ed7eb1aa787859748f37dd387f9cec",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e587bc3fd9ed7eb1aa787859748f37dd387f9cec",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e587bc3fd9ed7eb1aa787859748f37dd387f9cec/comments",
    "author": {
      "login": "morcos",
      "id": 4360349,
      "node_id": "MDQ6VXNlcjQzNjAzNDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4360349?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morcos",
      "html_url": "https://github.com/morcos",
      "followers_url": "https://api.github.com/users/morcos/followers",
      "following_url": "https://api.github.com/users/morcos/following{/other_user}",
      "gists_url": "https://api.github.com/users/morcos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morcos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
      "organizations_url": "https://api.github.com/users/morcos/orgs",
      "repos_url": "https://api.github.com/users/morcos/repos",
      "events_url": "https://api.github.com/users/morcos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morcos/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "morcos",
      "id": 4360349,
      "node_id": "MDQ6VXNlcjQzNjAzNDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4360349?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morcos",
      "html_url": "https://github.com/morcos",
      "followers_url": "https://api.github.com/users/morcos/followers",
      "following_url": "https://api.github.com/users/morcos/following{/other_user}",
      "gists_url": "https://api.github.com/users/morcos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morcos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
      "organizations_url": "https://api.github.com/users/morcos/orgs",
      "repos_url": "https://api.github.com/users/morcos/repos",
      "events_url": "https://api.github.com/users/morcos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morcos/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "87ee0e2dbc1201a5104d524ace32c0134ead019f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/87ee0e2dbc1201a5104d524ace32c0134ead019f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/87ee0e2dbc1201a5104d524ace32c0134ead019f"
      }
    ],
    "stats": {
      "total": 136,
      "additions": 89,
      "deletions": 47
    },
    "files": [
      {
        "sha": "896e1237ed3894a847e018fe8af4343cf51b3b4f",
        "filename": "src/test/mempool_tests.cpp",
        "status": "modified",
        "additions": 37,
        "deletions": 32,
        "changes": 69,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e587bc3fd9ed7eb1aa787859748f37dd387f9cec/src/test/mempool_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e587bc3fd9ed7eb1aa787859748f37dd387f9cec/src/test/mempool_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/mempool_tests.cpp?ref=e587bc3fd9ed7eb1aa787859748f37dd387f9cec",
        "patch": "@@ -17,6 +17,7 @@ BOOST_AUTO_TEST_CASE(MempoolRemoveTest)\n {\n     // Test CTxMemPool::remove functionality\n \n+    TestMemPoolEntryHelper entry;\n     // Parent transaction with three children,\n     // and three grand-children:\n     CMutableTransaction txParent;\n@@ -60,17 +61,17 @@ BOOST_AUTO_TEST_CASE(MempoolRemoveTest)\n     BOOST_CHECK_EQUAL(removed.size(), 0);\n \n     // Just the parent:\n-    testPool.addUnchecked(txParent.GetHash(), CTxMemPoolEntry(txParent, 0, 0, 0.0, 1));\n+    testPool.addUnchecked(txParent.GetHash(), entry.FromTx(txParent));\n     testPool.remove(txParent, removed, true);\n     BOOST_CHECK_EQUAL(removed.size(), 1);\n     removed.clear();\n     \n     // Parent, children, grandchildren:\n-    testPool.addUnchecked(txParent.GetHash(), CTxMemPoolEntry(txParent, 0, 0, 0.0, 1));\n+    testPool.addUnchecked(txParent.GetHash(), entry.FromTx(txParent));\n     for (int i = 0; i < 3; i++)\n     {\n-        testPool.addUnchecked(txChild[i].GetHash(), CTxMemPoolEntry(txChild[i], 0, 0, 0.0, 1));\n-        testPool.addUnchecked(txGrandChild[i].GetHash(), CTxMemPoolEntry(txGrandChild[i], 0, 0, 0.0, 1));\n+        testPool.addUnchecked(txChild[i].GetHash(), entry.FromTx(txChild[i]));\n+        testPool.addUnchecked(txGrandChild[i].GetHash(), entry.FromTx(txGrandChild[i]));\n     }\n     // Remove Child[0], GrandChild[0] should be removed:\n     testPool.remove(txChild[0], removed, true);\n@@ -90,8 +91,8 @@ BOOST_AUTO_TEST_CASE(MempoolRemoveTest)\n     // Add children and grandchildren, but NOT the parent (simulate the parent being in a block)\n     for (int i = 0; i < 3; i++)\n     {\n-        testPool.addUnchecked(txChild[i].GetHash(), CTxMemPoolEntry(txChild[i], 0, 0, 0.0, 1));\n-        testPool.addUnchecked(txGrandChild[i].GetHash(), CTxMemPoolEntry(txGrandChild[i], 0, 0, 0.0, 1));\n+        testPool.addUnchecked(txChild[i].GetHash(), entry.FromTx(txChild[i]));\n+        testPool.addUnchecked(txGrandChild[i].GetHash(), entry.FromTx(txGrandChild[i]));\n     }\n     // Now remove the parent, as might happen if a block-re-org occurs but the parent cannot be\n     // put into the mempool (maybe because it is non-standard):\n@@ -114,41 +115,45 @@ void CheckSort(CTxMemPool &pool, std::vector<std::string> &sortedOrder)\n BOOST_AUTO_TEST_CASE(MempoolIndexingTest)\n {\n     CTxMemPool pool(CFeeRate(0));\n+    TestMemPoolEntryHelper entry;\n+    entry.hadNoDependencies = true;\n \n     /* 3rd highest fee */\n     CMutableTransaction tx1 = CMutableTransaction();\n     tx1.vout.resize(1);\n     tx1.vout[0].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n     tx1.vout[0].nValue = 10 * COIN;\n-    pool.addUnchecked(tx1.GetHash(), CTxMemPoolEntry(tx1, 10000LL, 0, 10.0, 1, true));\n+    pool.addUnchecked(tx1.GetHash(), entry.Fee(10000LL).Priority(10.0).FromTx(tx1));\n \n     /* highest fee */\n     CMutableTransaction tx2 = CMutableTransaction();\n     tx2.vout.resize(1);\n     tx2.vout[0].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n     tx2.vout[0].nValue = 2 * COIN;\n-    pool.addUnchecked(tx2.GetHash(), CTxMemPoolEntry(tx2, 20000LL, 0, 9.0, 1, true));\n+    pool.addUnchecked(tx2.GetHash(), entry.Fee(20000LL).Priority(9.0).FromTx(tx2));\n \n     /* lowest fee */\n     CMutableTransaction tx3 = CMutableTransaction();\n     tx3.vout.resize(1);\n     tx3.vout[0].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n     tx3.vout[0].nValue = 5 * COIN;\n-    pool.addUnchecked(tx3.GetHash(), CTxMemPoolEntry(tx3, 0LL, 0, 100.0, 1, true));\n+    pool.addUnchecked(tx3.GetHash(), entry.Fee(0LL).Priority(100.0).FromTx(tx3));\n \n     /* 2nd highest fee */\n     CMutableTransaction tx4 = CMutableTransaction();\n     tx4.vout.resize(1);\n     tx4.vout[0].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n     tx4.vout[0].nValue = 6 * COIN;\n-    pool.addUnchecked(tx4.GetHash(), CTxMemPoolEntry(tx4, 15000LL, 0, 1.0, 1, true));\n+    pool.addUnchecked(tx4.GetHash(), entry.Fee(15000LL).Priority(1.0).FromTx(tx4));\n \n     /* equal fee rate to tx1, but newer */\n     CMutableTransaction tx5 = CMutableTransaction();\n     tx5.vout.resize(1);\n     tx5.vout[0].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n     tx5.vout[0].nValue = 11 * COIN;\n-    pool.addUnchecked(tx5.GetHash(), CTxMemPoolEntry(tx5, 10000LL, 1, 10.0, 1, true));\n+    entry.nTime = 1;\n+    entry.dPriority = 10.0;\n+    pool.addUnchecked(tx5.GetHash(), entry.Fee(10000LL).FromTx(tx5));\n     BOOST_CHECK_EQUAL(pool.size(), 5);\n \n     std::vector<std::string> sortedOrder;\n@@ -166,7 +171,7 @@ BOOST_AUTO_TEST_CASE(MempoolIndexingTest)\n     tx6.vout.resize(1);\n     tx6.vout[0].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n     tx6.vout[0].nValue = 20 * COIN;\n-    pool.addUnchecked(tx6.GetHash(), CTxMemPoolEntry(tx6, 0LL, 1, 10.0, 1, true));\n+    pool.addUnchecked(tx6.GetHash(), entry.Fee(0LL).FromTx(tx6));\n     BOOST_CHECK_EQUAL(pool.size(), 6);\n     // Check that at this point, tx6 is sorted low\n     sortedOrder.insert(sortedOrder.begin(), tx6.GetHash().ToString());\n@@ -186,11 +191,10 @@ BOOST_AUTO_TEST_CASE(MempoolIndexingTest)\n \n     CTxMemPool::setEntries setAncestorsCalculated;\n     std::string dummy;\n-    CTxMemPoolEntry entry7(tx7, 2000000LL, 1, 10.0, 1, true);\n-    BOOST_CHECK_EQUAL(pool.CalculateMemPoolAncestors(entry7, setAncestorsCalculated, 100, 1000000, 1000, 1000000, dummy), true);\n+    BOOST_CHECK_EQUAL(pool.CalculateMemPoolAncestors(entry.Fee(2000000LL).FromTx(tx7), setAncestorsCalculated, 100, 1000000, 1000, 1000000, dummy), true);\n     BOOST_CHECK(setAncestorsCalculated == setAncestors);\n \n-    pool.addUnchecked(tx7.GetHash(), CTxMemPoolEntry(tx7, 2000000LL, 1, 10.0, 1, true), setAncestors);\n+    pool.addUnchecked(tx7.GetHash(), entry.FromTx(tx7), setAncestors);\n     BOOST_CHECK_EQUAL(pool.size(), 7);\n \n     // Now tx6 should be sorted higher (high fee child): tx7, tx6, tx2, ...\n@@ -208,7 +212,7 @@ BOOST_AUTO_TEST_CASE(MempoolIndexingTest)\n     tx8.vout[0].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n     tx8.vout[0].nValue = 10 * COIN;\n     setAncestors.insert(pool.mapTx.find(tx7.GetHash()));\n-    pool.addUnchecked(tx8.GetHash(), CTxMemPoolEntry(tx8, 0LL, 2, 10.0, 1, true), setAncestors);\n+    pool.addUnchecked(tx8.GetHash(), entry.Fee(0LL).Time(2).FromTx(tx8), setAncestors);\n \n     // Now tx8 should be sorted low, but tx6/tx both high\n     sortedOrder.insert(sortedOrder.begin(), tx8.GetHash().ToString());\n@@ -222,7 +226,7 @@ BOOST_AUTO_TEST_CASE(MempoolIndexingTest)\n     tx9.vout.resize(1);\n     tx9.vout[0].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n     tx9.vout[0].nValue = 1 * COIN;\n-    pool.addUnchecked(tx9.GetHash(), CTxMemPoolEntry(tx9, 0LL, 3, 10.0, 1, true), setAncestors);\n+    pool.addUnchecked(tx9.GetHash(), entry.Fee(0LL).Time(3).FromTx(tx9), setAncestors);\n \n     // tx9 should be sorted low\n     BOOST_CHECK_EQUAL(pool.size(), 9);\n@@ -245,11 +249,10 @@ BOOST_AUTO_TEST_CASE(MempoolIndexingTest)\n     tx10.vout[0].nValue = 10 * COIN;\n \n     setAncestorsCalculated.clear();\n-    CTxMemPoolEntry entry10(tx10, 200000LL, 4, 10.0, 1, true);\n-    BOOST_CHECK_EQUAL(pool.CalculateMemPoolAncestors(entry10, setAncestorsCalculated, 100, 1000000, 1000, 1000000, dummy), true);\n+    BOOST_CHECK_EQUAL(pool.CalculateMemPoolAncestors(entry.Fee(200000LL).Time(4).FromTx(tx10), setAncestorsCalculated, 100, 1000000, 1000, 1000000, dummy), true);\n     BOOST_CHECK(setAncestorsCalculated == setAncestors);\n \n-    pool.addUnchecked(tx10.GetHash(), CTxMemPoolEntry(tx10, 200000LL, 4, 10.0, 1, true), setAncestors);\n+    pool.addUnchecked(tx10.GetHash(), entry.FromTx(tx10), setAncestors);\n \n     /**\n      *  tx8 and tx9 should both now be sorted higher\n@@ -284,22 +287,24 @@ BOOST_AUTO_TEST_CASE(MempoolIndexingTest)\n BOOST_AUTO_TEST_CASE(MempoolSizeLimitTest)\n {\n     CTxMemPool pool(CFeeRate(1000));\n+    TestMemPoolEntryHelper entry;\n+    entry.dPriority = 10.0;\n \n     CMutableTransaction tx1 = CMutableTransaction();\n     tx1.vin.resize(1);\n     tx1.vin[0].scriptSig = CScript() << OP_1;\n     tx1.vout.resize(1);\n     tx1.vout[0].scriptPubKey = CScript() << OP_1 << OP_EQUAL;\n     tx1.vout[0].nValue = 10 * COIN;\n-    pool.addUnchecked(tx1.GetHash(), CTxMemPoolEntry(tx1, 10000LL, 0, 10.0, 1, pool.HasNoInputsOf(tx1)));\n+    pool.addUnchecked(tx1.GetHash(), entry.Fee(10000LL).FromTx(tx1, &pool));\n \n     CMutableTransaction tx2 = CMutableTransaction();\n     tx2.vin.resize(1);\n     tx2.vin[0].scriptSig = CScript() << OP_2;\n     tx2.vout.resize(1);\n     tx2.vout[0].scriptPubKey = CScript() << OP_2 << OP_EQUAL;\n     tx2.vout[0].nValue = 10 * COIN;\n-    pool.addUnchecked(tx2.GetHash(), CTxMemPoolEntry(tx2, 5000LL, 0, 10.0, 1, pool.HasNoInputsOf(tx2)));\n+    pool.addUnchecked(tx2.GetHash(), entry.Fee(5000LL).FromTx(tx2, &pool));\n \n     pool.TrimToSize(pool.DynamicMemoryUsage()); // should do nothing\n     BOOST_CHECK(pool.exists(tx1.GetHash()));\n@@ -309,15 +314,15 @@ BOOST_AUTO_TEST_CASE(MempoolSizeLimitTest)\n     BOOST_CHECK(pool.exists(tx1.GetHash()));\n     BOOST_CHECK(!pool.exists(tx2.GetHash()));\n \n-    pool.addUnchecked(tx2.GetHash(), CTxMemPoolEntry(tx2, 5000LL, 0, 10.0, 1, pool.HasNoInputsOf(tx2)));\n+    pool.addUnchecked(tx2.GetHash(), entry.FromTx(tx2, &pool));\n     CMutableTransaction tx3 = CMutableTransaction();\n     tx3.vin.resize(1);\n     tx3.vin[0].prevout = COutPoint(tx2.GetHash(), 0);\n     tx3.vin[0].scriptSig = CScript() << OP_2;\n     tx3.vout.resize(1);\n     tx3.vout[0].scriptPubKey = CScript() << OP_3 << OP_EQUAL;\n     tx3.vout[0].nValue = 10 * COIN;\n-    pool.addUnchecked(tx3.GetHash(), CTxMemPoolEntry(tx3, 20000LL, 0, 10.0, 1, pool.HasNoInputsOf(tx3)));\n+    pool.addUnchecked(tx3.GetHash(), entry.Fee(20000LL).FromTx(tx3, &pool));\n \n     pool.TrimToSize(pool.DynamicMemoryUsage() * 3 / 4); // tx3 should pay for tx2 (CPFP)\n     BOOST_CHECK(!pool.exists(tx1.GetHash()));\n@@ -380,10 +385,10 @@ BOOST_AUTO_TEST_CASE(MempoolSizeLimitTest)\n     tx7.vout[1].scriptPubKey = CScript() << OP_7 << OP_EQUAL;\n     tx7.vout[1].nValue = 10 * COIN;\n \n-    pool.addUnchecked(tx4.GetHash(), CTxMemPoolEntry(tx4, 7000LL, 0, 10.0, 1, pool.HasNoInputsOf(tx4)));\n-    pool.addUnchecked(tx5.GetHash(), CTxMemPoolEntry(tx5, 1000LL, 0, 10.0, 1, pool.HasNoInputsOf(tx5)));\n-    pool.addUnchecked(tx6.GetHash(), CTxMemPoolEntry(tx6, 1100LL, 0, 10.0, 1, pool.HasNoInputsOf(tx6)));\n-    pool.addUnchecked(tx7.GetHash(), CTxMemPoolEntry(tx7, 9000LL, 0, 10.0, 1, pool.HasNoInputsOf(tx7)));\n+    pool.addUnchecked(tx4.GetHash(), entry.Fee(7000LL).FromTx(tx4, &pool));\n+    pool.addUnchecked(tx5.GetHash(), entry.Fee(1000LL).FromTx(tx5, &pool));\n+    pool.addUnchecked(tx6.GetHash(), entry.Fee(1100LL).FromTx(tx6, &pool));\n+    pool.addUnchecked(tx7.GetHash(), entry.Fee(9000LL).FromTx(tx7, &pool));\n \n     // we only require this remove, at max, 2 txn, because its not clear what we're really optimizing for aside from that\n     pool.TrimToSize(pool.DynamicMemoryUsage() - 1);\n@@ -392,17 +397,17 @@ BOOST_AUTO_TEST_CASE(MempoolSizeLimitTest)\n     BOOST_CHECK(!pool.exists(tx7.GetHash()));\n \n     if (!pool.exists(tx5.GetHash()))\n-        pool.addUnchecked(tx5.GetHash(), CTxMemPoolEntry(tx5, 1000LL, 0, 10.0, 1, pool.HasNoInputsOf(tx5)));\n-    pool.addUnchecked(tx7.GetHash(), CTxMemPoolEntry(tx7, 9000LL, 0, 10.0, 1, pool.HasNoInputsOf(tx7)));\n+        pool.addUnchecked(tx5.GetHash(), entry.Fee(1000LL).FromTx(tx5, &pool));\n+    pool.addUnchecked(tx7.GetHash(), entry.Fee(9000LL).FromTx(tx7, &pool));\n \n     pool.TrimToSize(pool.DynamicMemoryUsage() / 2); // should maximize mempool size by only removing 5/7\n     BOOST_CHECK(pool.exists(tx4.GetHash()));\n     BOOST_CHECK(!pool.exists(tx5.GetHash()));\n     BOOST_CHECK(pool.exists(tx6.GetHash()));\n     BOOST_CHECK(!pool.exists(tx7.GetHash()));\n \n-    pool.addUnchecked(tx5.GetHash(), CTxMemPoolEntry(tx5, 1000LL, 0, 10.0, 1, pool.HasNoInputsOf(tx5)));\n-    pool.addUnchecked(tx7.GetHash(), CTxMemPoolEntry(tx7, 9000LL, 0, 10.0, 1, pool.HasNoInputsOf(tx7)));\n+    pool.addUnchecked(tx5.GetHash(), entry.Fee(1000LL).FromTx(tx5, &pool));\n+    pool.addUnchecked(tx7.GetHash(), entry.Fee(9000LL).FromTx(tx7, &pool));\n \n     std::vector<CTransaction> vtx;\n     std::list<CTransaction> conflicts;"
      },
      {
        "sha": "dc20e34634ba1bb274e6d6a194c3c9b7b005f1db",
        "filename": "src/test/miner_tests.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 12,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e587bc3fd9ed7eb1aa787859748f37dd387f9cec/src/test/miner_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e587bc3fd9ed7eb1aa787859748f37dd387f9cec/src/test/miner_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/miner_tests.cpp?ref=e587bc3fd9ed7eb1aa787859748f37dd387f9cec",
        "patch": "@@ -65,6 +65,10 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     CMutableTransaction tx,tx2;\n     CScript script;\n     uint256 hash;\n+    TestMemPoolEntryHelper entry;\n+    entry.nFee = 11;\n+    entry.dPriority = 111.0;\n+    entry.nHeight = 11;\n \n     LOCK(cs_main);\n     fCheckpointsEnabled = false;\n@@ -114,7 +118,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     {\n         tx.vout[0].nValue -= 1000000;\n         hash = tx.GetHash();\n-        mempool.addUnchecked(hash, CTxMemPoolEntry(tx, 11, GetTime(), 111.0, 11));\n+        mempool.addUnchecked(hash, entry.Time(GetTime()).FromTx(tx));\n         tx.vin[0].prevout.hash = hash;\n     }\n     BOOST_CHECK(pblocktemplate = CreateNewBlock(chainparams, scriptPubKey));\n@@ -134,7 +138,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     {\n         tx.vout[0].nValue -= 10000000;\n         hash = tx.GetHash();\n-        mempool.addUnchecked(hash, CTxMemPoolEntry(tx, 11, GetTime(), 111.0, 11));\n+        mempool.addUnchecked(hash, entry.Time(GetTime()).FromTx(tx));\n         tx.vin[0].prevout.hash = hash;\n     }\n     BOOST_CHECK(pblocktemplate = CreateNewBlock(chainparams, scriptPubKey));\n@@ -143,7 +147,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n \n     // orphan in mempool\n     hash = tx.GetHash();\n-    mempool.addUnchecked(hash, CTxMemPoolEntry(tx, 11, GetTime(), 111.0, 11));\n+    mempool.addUnchecked(hash, entry.Time(GetTime()).FromTx(tx));\n     BOOST_CHECK(pblocktemplate = CreateNewBlock(chainparams, scriptPubKey));\n     delete pblocktemplate;\n     mempool.clear();\n@@ -153,15 +157,15 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     tx.vin[0].prevout.hash = txFirst[1]->GetHash();\n     tx.vout[0].nValue = 4900000000LL;\n     hash = tx.GetHash();\n-    mempool.addUnchecked(hash, CTxMemPoolEntry(tx, 11, GetTime(), 111.0, 11));\n+    mempool.addUnchecked(hash, entry.Time(GetTime()).FromTx(tx));\n     tx.vin[0].prevout.hash = hash;\n     tx.vin.resize(2);\n     tx.vin[1].scriptSig = CScript() << OP_1;\n     tx.vin[1].prevout.hash = txFirst[0]->GetHash();\n     tx.vin[1].prevout.n = 0;\n     tx.vout[0].nValue = 5900000000LL;\n     hash = tx.GetHash();\n-    mempool.addUnchecked(hash, CTxMemPoolEntry(tx, 11, GetTime(), 111.0, 11));\n+    mempool.addUnchecked(hash, entry.Time(GetTime()).FromTx(tx));\n     BOOST_CHECK(pblocktemplate = CreateNewBlock(chainparams, scriptPubKey));\n     delete pblocktemplate;\n     mempool.clear();\n@@ -172,7 +176,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     tx.vin[0].scriptSig = CScript() << OP_0 << OP_1;\n     tx.vout[0].nValue = 0;\n     hash = tx.GetHash();\n-    mempool.addUnchecked(hash, CTxMemPoolEntry(tx, 11, GetTime(), 111.0, 11));\n+    mempool.addUnchecked(hash, entry.Time(GetTime()).FromTx(tx));\n     BOOST_CHECK(pblocktemplate = CreateNewBlock(chainparams, scriptPubKey));\n     delete pblocktemplate;\n     mempool.clear();\n@@ -185,12 +189,12 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     script = CScript() << OP_0;\n     tx.vout[0].scriptPubKey = GetScriptForDestination(CScriptID(script));\n     hash = tx.GetHash();\n-    mempool.addUnchecked(hash, CTxMemPoolEntry(tx, 11, GetTime(), 111.0, 11));\n+    mempool.addUnchecked(hash, entry.Time(GetTime()).FromTx(tx));\n     tx.vin[0].prevout.hash = hash;\n     tx.vin[0].scriptSig = CScript() << (std::vector<unsigned char>)script;\n     tx.vout[0].nValue -= 1000000;\n     hash = tx.GetHash();\n-    mempool.addUnchecked(hash, CTxMemPoolEntry(tx, 11, GetTime(), 111.0, 11));\n+    mempool.addUnchecked(hash, entry.Time(GetTime()).FromTx(tx));\n     BOOST_CHECK(pblocktemplate = CreateNewBlock(chainparams, scriptPubKey));\n     delete pblocktemplate;\n     mempool.clear();\n@@ -201,10 +205,10 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     tx.vout[0].nValue = 4900000000LL;\n     tx.vout[0].scriptPubKey = CScript() << OP_1;\n     hash = tx.GetHash();\n-    mempool.addUnchecked(hash, CTxMemPoolEntry(tx, 11, GetTime(), 111.0, 11));\n+    mempool.addUnchecked(hash, entry.Time(GetTime()).FromTx(tx));\n     tx.vout[0].scriptPubKey = CScript() << OP_2;\n     hash = tx.GetHash();\n-    mempool.addUnchecked(hash, CTxMemPoolEntry(tx, 11, GetTime(), 111.0, 11));\n+    mempool.addUnchecked(hash, entry.Time(GetTime()).FromTx(tx));\n     BOOST_CHECK(pblocktemplate = CreateNewBlock(chainparams, scriptPubKey));\n     delete pblocktemplate;\n     mempool.clear();\n@@ -230,7 +234,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     tx.vout[0].scriptPubKey = CScript() << OP_1;\n     tx.nLockTime = chainActive.Tip()->nHeight+1;\n     hash = tx.GetHash();\n-    mempool.addUnchecked(hash, CTxMemPoolEntry(tx, 11, GetTime(), 111.0, 11));\n+    mempool.addUnchecked(hash, entry.Time(GetTime()).FromTx(tx));\n     BOOST_CHECK(!CheckFinalTx(tx, LOCKTIME_MEDIAN_TIME_PAST));\n \n     // time locked\n@@ -244,7 +248,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     tx2.vout[0].scriptPubKey = CScript() << OP_1;\n     tx2.nLockTime = chainActive.Tip()->GetMedianTimePast()+1;\n     hash = tx2.GetHash();\n-    mempool.addUnchecked(hash, CTxMemPoolEntry(tx2, 11, GetTime(), 111.0, 11));\n+    mempool.addUnchecked(hash, entry.Time(GetTime()).FromTx(tx2));\n     BOOST_CHECK(!CheckFinalTx(tx2, LOCKTIME_MEDIAN_TIME_PAST));\n \n     BOOST_CHECK(pblocktemplate = CreateNewBlock(chainparams, scriptPubKey));"
      },
      {
        "sha": "c4f6660f6aed9c237013a4d6d5b89b2a9faa1796",
        "filename": "src/test/policyestimator_tests.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e587bc3fd9ed7eb1aa787859748f37dd387f9cec/src/test/policyestimator_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e587bc3fd9ed7eb1aa787859748f37dd387f9cec/src/test/policyestimator_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/policyestimator_tests.cpp?ref=e587bc3fd9ed7eb1aa787859748f37dd387f9cec",
        "patch": "@@ -16,6 +16,7 @@ BOOST_FIXTURE_TEST_SUITE(policyestimator_tests, BasicTestingSetup)\n BOOST_AUTO_TEST_CASE(BlockPolicyEstimates)\n {\n     CTxMemPool mpool(CFeeRate(1000));\n+    TestMemPoolEntryHelper entry;\n     CAmount basefee(2000);\n     double basepri = 1e6;\n     CAmount deltaFee(100);\n@@ -63,7 +64,7 @@ BOOST_AUTO_TEST_CASE(BlockPolicyEstimates)\n             for (int k = 0; k < 5; k++) { // add 4 fee txs for every priority tx\n                 tx.vin[0].prevout.n = 10000*blocknum+100*j+k; // make transaction unique\n                 uint256 hash = tx.GetHash();\n-                mpool.addUnchecked(hash, CTxMemPoolEntry(tx, feeV[k/4][j], GetTime(), priV[k/4][j], blocknum, mpool.HasNoInputsOf(tx)));\n+                mpool.addUnchecked(hash, entry.Fee(feeV[k/4][j]).Time(GetTime()).Priority(priV[k/4][j]).Height(blocknum).FromTx(tx, &mpool));\n                 txHashes[j].push_back(hash);\n             }\n         }\n@@ -132,7 +133,7 @@ BOOST_AUTO_TEST_CASE(BlockPolicyEstimates)\n             for (int k = 0; k < 5; k++) { // add 4 fee txs for every priority tx\n                 tx.vin[0].prevout.n = 10000*blocknum+100*j+k;\n                 uint256 hash = tx.GetHash();\n-                mpool.addUnchecked(hash, CTxMemPoolEntry(tx, feeV[k/4][j], GetTime(), priV[k/4][j], blocknum, mpool.HasNoInputsOf(tx)));\n+                mpool.addUnchecked(hash, entry.Fee(feeV[k/4][j]).Time(GetTime()).Priority(priV[k/4][j]).Height(blocknum).FromTx(tx, &mpool));\n                 txHashes[j].push_back(hash);\n             }\n         }\n@@ -168,7 +169,7 @@ BOOST_AUTO_TEST_CASE(BlockPolicyEstimates)\n             for (int k = 0; k < 5; k++) { // add 4 fee txs for every priority tx\n                 tx.vin[0].prevout.n = 10000*blocknum+100*j+k;\n                 uint256 hash = tx.GetHash();\n-                mpool.addUnchecked(hash, CTxMemPoolEntry(tx, feeV[k/4][j], GetTime(), priV[k/4][j], blocknum, mpool.HasNoInputsOf(tx)));\n+                mpool.addUnchecked(hash, entry.Fee(feeV[k/4][j]).Time(GetTime()).Priority(priV[k/4][j]).Height(blocknum).FromTx(tx, &mpool));\n                 CTransaction btx;\n                 if (mpool.lookup(hash, btx))\n                     block.push_back(btx);"
      },
      {
        "sha": "9a3517a27b467f104aafe8f0e1b4f612d2d64a90",
        "filename": "src/test/test_bitcoin.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e587bc3fd9ed7eb1aa787859748f37dd387f9cec/src/test/test_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e587bc3fd9ed7eb1aa787859748f37dd387f9cec/src/test/test_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.cpp?ref=e587bc3fd9ed7eb1aa787859748f37dd387f9cec",
        "patch": "@@ -15,6 +15,7 @@\n #include \"pubkey.h\"\n #include \"random.h\"\n #include \"txdb.h\"\n+#include \"txmempool.h\"\n #include \"ui_interface.h\"\n #include \"util.h\"\n #ifdef ENABLE_WALLET\n@@ -140,6 +141,12 @@ TestChain100Setup::~TestChain100Setup()\n {\n }\n \n+\n+CTxMemPoolEntry TestMemPoolEntryHelper::FromTx(CMutableTransaction &tx, CTxMemPool *pool) {\n+    return CTxMemPoolEntry(tx, nFee, nTime, dPriority, nHeight,\n+                           pool ? pool->HasNoInputsOf(tx) : hadNoDependencies);\n+}\n+\n void Shutdown(void* parg)\n {\n   exit(0);"
      },
      {
        "sha": "815b2274117c78d7e26ade9269a6e8ded39fe589",
        "filename": "src/test/test_bitcoin.h",
        "status": "modified",
        "additions": 25,
        "deletions": 0,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e587bc3fd9ed7eb1aa787859748f37dd387f9cec/src/test/test_bitcoin.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e587bc3fd9ed7eb1aa787859748f37dd387f9cec/src/test/test_bitcoin.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.h?ref=e587bc3fd9ed7eb1aa787859748f37dd387f9cec",
        "patch": "@@ -54,4 +54,29 @@ struct TestChain100Setup : public TestingSetup {\n     CKey coinbaseKey; // private/public key needed to spend coinbase transactions\n };\n \n+class CTxMemPoolEntry;\n+class CTxMemPool;\n+\n+struct TestMemPoolEntryHelper\n+{\n+    // Default values\n+    CAmount nFee;\n+    int64_t nTime;\n+    double dPriority;\n+    unsigned int nHeight;\n+    bool hadNoDependencies;\n+\n+    TestMemPoolEntryHelper() :\n+        nFee(0), nTime(0), dPriority(0.0), nHeight(1),\n+        hadNoDependencies(false) { }\n+\n+    CTxMemPoolEntry FromTx(CMutableTransaction &tx, CTxMemPool *pool = NULL);\n+\n+    // Change the default value\n+    TestMemPoolEntryHelper &Fee(CAmount _fee) { nFee = _fee; return *this; }\n+    TestMemPoolEntryHelper &Time(int64_t _time) { nTime = _time; return *this; }\n+    TestMemPoolEntryHelper &Priority(double _priority) { dPriority = _priority; return *this; }\n+    TestMemPoolEntryHelper &Height(unsigned int _height) { nHeight = _height; return *this; }\n+    TestMemPoolEntryHelper &HadNoDependencies(bool _hnd) { hadNoDependencies = _hnd; return *this; }\n+};\n #endif"
      }
    ]
  }
]