gmaxwell,2016-05-22T10:04:18Z,utACK\n,https://github.com/bitcoin/bitcoin/pull/8086#issuecomment-220824169,220824169,
TheBlueMatt,2016-05-23T02:37:19Z,"This is one of those things where having a cryptographic hash function probably isnt /critical/, but is really preferable. Is the speed of SHA256 really slow enough to matter here afer you accepted a new TCP connection (and all associated OS overhead of doing so)?\n",https://github.com/bitcoin/bitcoin/pull/8086#issuecomment-220875999,220875999,
pstratem,2016-05-23T04:11:26Z,nACK\n\nThis really does need to be a cryptographic hash function.\n\nThe performance overhead of opening the connection is almost certainly many many times the cost of this comparison.\n,https://github.com/bitcoin/bitcoin/pull/8086#issuecomment-220883912,220883912,
gmaxwell,2016-05-23T05:19:31Z,"Siphash is a cryptographic function with all the properties we would desire here: https://eprint.iacr.org/2014/722\n\nIt is generally suitable any place a cryptographic hash would be used where the small output size wouldn't be an issue.  This is a fine example of such a location, similar to hash tables where the table's smallness makes a larger hash output irrelevant, with only a few hundred peer",https://github.com/bitcoin/bitcoin/pull/8086#issuecomment-220889430,220889430,
TheBlueMatt,2016-05-23T06:13:27Z,"In principal, yes, SipHash was designed to be effectively a cryptographic hash with small output size, but I don't want to fall into the trap of calling something a cryptographic hash when it has only had one or two cryptanalyses published. If we care about the performance difference here, I'd say it's fine, but I'm not sure that we do?\n\nOn May 22, 2016 10:19:47 PM PDT, Gregory Maxwell notificat",https://github.com/bitcoin/bitcoin/pull/8086#issuecomment-220895178,220895178,
gmaxwell,2016-05-23T06:45:17Z,"Keep in mind that the input is also very small, and the keyspace is very large. It's likely that this function is nearly a keyed permutation for inputs this small.\n\nAs far as performance, with 125 peers and sha256 here it will take about 2,632,000 cycles to run the hashes here. That is about 2ms cpu per inbound connection. It's not negligible.\n\n(Though sipa should perhaps change it to run the ",https://github.com/bitcoin/bitcoin/pull/8086#issuecomment-220899300,220899300,
pstratem,2016-05-23T07:20:56Z,@gmaxwell I'll do a fix that still uses SHA256\n,https://github.com/bitcoin/bitcoin/pull/8086#issuecomment-220904801,220904801,
gmaxwell,2016-05-23T09:18:04Z,"Please walk me through the attack you're imagining here.   There are 16 bits of network groups for IPv4, 32 bits for IPv6. In both cases many of the possible values aren't routable on the internet..  Each node has it's own 128-bit secret random seed.  The node prefers to keep four hosts based on how their netgroup is ordered by a salted hash.  The attacker does X and achieves Y.  Help me out with ",https://github.com/bitcoin/bitcoin/pull/8086#issuecomment-220928715,220928715,
pstratem,2016-05-23T10:05:55Z,@gmaxwell I don't know but with #8088 the performance difference is going to be basically not measurable.\n\nIt's now reduced to the difference between a single SHA256 vs SipHash and comparison between 256 bits vs 64 bits.\n,https://github.com/bitcoin/bitcoin/pull/8086#issuecomment-220939354,220939354,
gmaxwell,2016-05-24T18:18:28Z,"Come one guys, you can't throw up a bunch of stop signs for security then fail to actually walk me through your security analysis.  We want security but not security cargo cult.\n\nBeyond performance there is a consistency point here, we should use the same cryptographic hash-function in all the cases where we need some non-normative small hash, unless there is a good reason not to. If there is a ",https://github.com/bitcoin/bitcoin/pull/8086#issuecomment-221358510,221358510,
pstratem,2016-05-24T18:56:50Z,@gmaxwell If this fails it potentially harms the partition resistance of the network.\n\nIf the other uses of SipHash fail they at worst are a denial of service attack (which existed before SipHash).\n\nGiven the extremely small performance difference compared to the enormous cost of accepting a new connection I just don't see the (admittedly small) risk being justified.\n,https://github.com/bitcoin/bitcoin/pull/8086#issuecomment-221369117,221369117,
TheBlueMatt,2016-05-24T19:11:55Z,"If there is no performance difference, why change it? Might as well use a stronger hash anywhere we can if its free.\n",https://github.com/bitcoin/bitcoin/pull/8086#issuecomment-221373159,221373159,
gmaxwell,2016-05-24T19:40:31Z,"Again, please actually specify the attack.  I gave you a template, fill it out.\n\n> If the other uses of SipHash fail they at worst are a denial of service attack\n\nThe usage in addrman is functionally identical to this. \n\n> if there is no performance difference\n\nin this PR it's a pretty substantial performance difference (it's about 2ms per connection), though performance can be achieved in",https://github.com/bitcoin/bitcoin/pull/8086#issuecomment-221379952,221379952,
sipa,2016-05-25T13:46:53Z,"I think you're all exaggerating:\n- @pstratem @TheBlueMatt SipHash is more than sufficient in this case (hell, multiplying the vchGroup (interpreted as a number) by a random odd 64-bit integer likely already results in a sufficiently unpredictable permutation).\n- @gmaxwell After caching at the CNode level, performance of the hash function is irrelevant. I think SipHash is more appropriate, but SH",https://github.com/bitcoin/bitcoin/pull/8086#issuecomment-221581063,221581063,
theuni,2016-05-26T16:20:59Z,"@sipa Roger. Seems CalculateKeyedNetGroup isn't being called, though. I assume it's meant to be called from CNode's ctor?\n",https://github.com/bitcoin/bitcoin/pull/8086#issuecomment-221921035,221921035,
sipa,2016-05-26T16:57:56Z,"@theuni Nice catch, it got lost in code movement. I've turned nKeyedNetGroup into a const as well, initialized in the ctor.\n",https://github.com/bitcoin/bitcoin/pull/8086#issuecomment-221930880,221930880,
theuni,2016-05-27T16:16:17Z,"utACK (excluding the siphash impl itself, which i'm not qualified to review) either way. I don't see the harm in siphash (see previous disclaimer, though), since the input is at most 32bits anyway. But I agree with @sipa that the hash type shouldn't make much difference anyway once cached.\n",https://github.com/bitcoin/bitcoin/pull/8086#issuecomment-222189286,222189286,
sipa,2016-05-28T23:35:12Z,"@theuni Even if you don't think you're the right person to review the SipHash code, you're certainly able to review its tests (the values in the unit test come from another implementation).\n",https://github.com/bitcoin/bitcoin/pull/8086#issuecomment-222334570,222334570,
laanwj,2016-06-08T13:09:34Z,"I've ported the SIPhash test to python using https://github.com/majek/pysiphash , source is here: https://gist.github.com/laanwj/b292fedecf6029fc5307968b965e3366\n\nHowever I get mismatching results:\n\n```\nOK b''\nOK b'00'\nMismatch for b'01020304050607': 15dd418547d24915 versus 93f5f5799a932462\nMismatch for b'08090a0b0c0d0e0f': 242272d800a348b4 versus 3f2acc7f57c29bdb\nMismatch for b'1011': 63",https://github.com/bitcoin/bitcoin/pull/8086#issuecomment-224583330,224583330,
laanwj,2016-06-08T13:12:07Z,"Oh, found the issue: I assumed .Finalize would finalize and reset the hasher. It just returns the current hash value, allowing further calls to continue. When I pass through the previous value, it works fine. Updated https://gist.github.com/laanwj/b292fedecf6029fc5307968b965e3366\n\nutACK 8884830\n",https://github.com/bitcoin/bitcoin/pull/8086#issuecomment-224584015,224584015,
sipa,2016-06-08T13:55:05Z,Superseded by #8173.\n,https://github.com/bitcoin/bitcoin/pull/8086#issuecomment-224596184,224596184,
TheBlueMatt,2016-05-23T00:25:45Z,Should probably note somewhere that the two Write methods are partially-mutually-exclusive per-object.\n,https://github.com/bitcoin/bitcoin/pull/8086#discussion_r64159533,64159533,src/hash.h
theuni,2016-05-27T15:18:27Z,includes still needed?\n,https://github.com/bitcoin/bitcoin/pull/8086#discussion_r64921049,64921049,src/net.h
sipa,2016-05-28T23:34:07Z,Fixed.\n,https://github.com/bitcoin/bitcoin/pull/8086#discussion_r64995710,64995710,src/net.h
laanwj,2016-06-07T13:16:25Z,"This code is not thread-safe - does it matter?\n\nOtherwise maybe make this a static instance of a structure with the initialization code in the constructor, and [C++11 semantics](http://stackoverflow.com/questions/8102125/is-local-static-variable-initialization-thread-safe-in-c11)  will make sure it will only get initialized once in a thread-safe way.\n",https://github.com/bitcoin/bitcoin/pull/8086#discussion_r66067649,66067649,src/net.cpp
sipa,2016-06-07T14:34:55Z,"It doesn't matter (the old code wasn't thread safe either), but better use good practices, and using static initializers is trivial. Fixed.\n",https://github.com/bitcoin/bitcoin/pull/8086#discussion_r66082428,66082428,src/net.cpp
