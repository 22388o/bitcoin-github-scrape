[
  {
    "sha": "c555400ca134991e39d5e3a565fcd2215abe56f6",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjNTU1NDAwY2ExMzQ5OTFlMzlkNWUzYTU2NWZjZDIyMTVhYmU1NmY2",
    "commit": {
      "author": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2012-07-12T18:22:32Z"
      },
      "committer": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2012-07-26T18:24:19Z"
      },
      "message": "When creating new blocks, sort 'paid' area by fee-per-kb\n\nModify CreateNewBlock so that instead of processing all transactions\nin priority order, process the first 27K of transactions in\npriority order and then process the rest in fee-per-kilobyte\norder.\n\nThis is the first, minimal step towards better a better fee-handling\nsystem for both miners and end-users; this patch should be easy\nto backport to the old versions of Bitcoin, and accomplishes the\nmost important goal-- allow users to \"buy their way in\" to blocks\nusing transaction fees.",
      "tree": {
        "sha": "aa7732ac591c53f222e755ec5fc636bf6d417e63",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/aa7732ac591c53f222e755ec5fc636bf6d417e63"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c555400ca134991e39d5e3a565fcd2215abe56f6",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c555400ca134991e39d5e3a565fcd2215abe56f6",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c555400ca134991e39d5e3a565fcd2215abe56f6",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c555400ca134991e39d5e3a565fcd2215abe56f6/comments",
    "author": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "29c8fb0d9330fc3c001fd228c30c8f2c44886d11",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/29c8fb0d9330fc3c001fd228c30c8f2c44886d11",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/29c8fb0d9330fc3c001fd228c30c8f2c44886d11"
      }
    ],
    "stats": {
      "total": 145,
      "additions": 114,
      "deletions": 31
    },
    "files": [
      {
        "sha": "35230095a82dc79fc553b8c208108de5e745fecb",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c555400ca134991e39d5e3a565fcd2215abe56f6/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c555400ca134991e39d5e3a565fcd2215abe56f6/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=c555400ca134991e39d5e3a565fcd2215abe56f6",
        "patch": "@@ -279,6 +279,11 @@ std::string HelpMessage()\n         \"  -checkblocks=<n>       \" + _(\"How many blocks to check at startup (default: 2500, 0 = all)\") + \"\\n\" +\n         \"  -checklevel=<n>        \" + _(\"How thorough the block verification is (0-6, default: 1)\") + \"\\n\" +\n         \"  -loadblock=<file>      \" + _(\"Imports blocks from external blk000?.dat file\") + \"\\n\" +\n+        _(\"\\nBlock creation options:\\n\") +\n+        \"  -blockminsize=<n>      \"   + _(\"Minimum size, in bytes (default: 0)\\n\") +\n+        \"  -blockmaxsize=<n>      \"   + _(\"Maximum size, in bytes (default: 250000)\\n\") +\n+        \"  -blockprioritysize=<n> \"   + _(\"Maximum bytes of high-priority/low-fee transactions (default: 27000)\\n\") +\n+\n         \"  -?                     \" + _(\"This help message\") + \"\\n\";\n \n     strUsage += string() +"
      },
      {
        "sha": "7973e63831ee2b206659cfebd3e8fad23a8e77f9",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 109,
        "deletions": 31,
        "changes": 140,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c555400ca134991e39d5e3a565fcd2215abe56f6/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c555400ca134991e39d5e3a565fcd2215abe56f6/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=c555400ca134991e39d5e3a565fcd2215abe56f6",
        "patch": "@@ -3312,16 +3312,18 @@ class COrphan\n     CTransaction* ptx;\n     set<uint256> setDependsOn;\n     double dPriority;\n+    double dFeePerKb;\n \n     COrphan(CTransaction* ptxIn)\n     {\n         ptx = ptxIn;\n-        dPriority = 0;\n+        dPriority = dFeePerKb = 0;\n     }\n \n     void print() const\n     {\n-        printf(\"COrphan(hash=%s, dPriority=%.1f)\\n\", ptx->GetHash().ToString().substr(0,10).c_str(), dPriority);\n+        printf(\"COrphan(hash=%s, dPriority=%.1f, dFeePerKb=%.1f)\\n\",\n+               ptx->GetHash().ToString().substr(0,10).c_str(), dPriority, dFeePerKb);\n         BOOST_FOREACH(uint256 hash, setDependsOn)\n             printf(\"   setDependsOn %s\\n\", hash.ToString().substr(0,10).c_str());\n     }\n@@ -3331,6 +3333,30 @@ class COrphan\n uint64 nLastBlockTx = 0;\n uint64 nLastBlockSize = 0;\n \n+// We want to sort transactions by priority and fee, so:\n+typedef boost::tuple<double, double, CTransaction*> TxPriority;\n+class TxPriorityCompare\n+{\n+    bool byFee;\n+public:\n+    TxPriorityCompare(bool _byFee) : byFee(_byFee) { }\n+    bool operator()(const TxPriority& a, const TxPriority& b)\n+    {\n+        if (byFee)\n+        {\n+            if (a.get<1>() == b.get<1>())\n+                return a.get<0>() < b.get<0>();\n+            return a.get<1>() < b.get<1>();\n+        }\n+        else\n+        {\n+            if (a.get<0>() == b.get<0>())\n+                return a.get<1>() < b.get<1>();\n+            return a.get<0>() < b.get<0>();\n+        }\n+    }\n+};\n+\n const char* pszDummy = \"\\0\\0\";\n CScript scriptDummy(std::vector<unsigned char>(pszDummy, pszDummy + sizeof(pszDummy)));\n \n@@ -3353,6 +3379,30 @@ CBlock* CreateNewBlock(CReserveKey& reservekey)\n     // Add our coinbase tx as first transaction\n     pblock->vtx.push_back(txNew);\n \n+    // Largest block you're willing to create:\n+    unsigned int nBlockMaxSize = GetArg(\"-blockmaxsize\", MAX_BLOCK_SIZE_GEN/2);\n+    // Limit to betweeen 1K and MAX_BLOCK_SIZE-1K for sanity:\n+    nBlockMaxSize = std::max((unsigned int)1000, std::min((unsigned int)(MAX_BLOCK_SIZE-1000), nBlockMaxSize));\n+\n+    // How much of the block should be dedicated to high-priority transactions,\n+    // included regardless of the fees they pay\n+    unsigned int nBlockPrioritySize = GetArg(\"-blockprioritysize\", 27000);\n+    nBlockPrioritySize = std::min(nBlockMaxSize, nBlockPrioritySize);\n+\n+    // Minimum block size you want to create; block will be filled with free transactions\n+    // until there are no more or the block reaches this size:\n+    unsigned int nBlockMinSize = GetArg(\"-blockminsize\", 0);\n+    nBlockMinSize = std::min(nBlockMaxSize, nBlockMinSize);\n+\n+    // Fee-per-kilobyte amount considered the same as \"free\"\n+    // Be careful setting this: if you set it to zero then\n+    // a transaction spammer can cheaply fill blocks using\n+    // 1-satoshi-fee transactions. It should be set above the real\n+    // cost to you of processing a transaction.\n+    int64 nMinTxFee = MIN_TX_FEE;\n+    if (mapArgs.count(\"-mintxfee\"))\n+        ParseMoney(mapArgs[\"-mintxfee\"], nMinTxFee);\n+\n     // Collect memory pool transactions into the block\n     int64 nFees = 0;\n     {\n@@ -3362,7 +3412,10 @@ CBlock* CreateNewBlock(CReserveKey& reservekey)\n         // Priority order to process transactions\n         list<COrphan> vOrphan; // list memory doesn't move\n         map<uint256, vector<COrphan*> > mapDependers;\n-        multimap<double, CTransaction*> mapPriority;\n+\n+        // This vector will be sorted into a priority queue:\n+        vector<TxPriority> vecPriority;\n+        vecPriority.reserve(mempool.mapTx.size());\n         for (map<uint256, CTransaction>::iterator mi = mempool.mapTx.begin(); mi != mempool.mapTx.end(); ++mi)\n         {\n             CTransaction& tx = (*mi).second;\n@@ -3371,6 +3424,7 @@ CBlock* CreateNewBlock(CReserveKey& reservekey)\n \n             COrphan* porphan = NULL;\n             double dPriority = 0;\n+            int64 nTotalIn = 0;\n             BOOST_FOREACH(const CTxIn& txin, tx.vin)\n             {\n                 // Read prev transaction\n@@ -3387,61 +3441,77 @@ CBlock* CreateNewBlock(CReserveKey& reservekey)\n                     }\n                     mapDependers[txin.prevout.hash].push_back(porphan);\n                     porphan->setDependsOn.insert(txin.prevout.hash);\n+                    nTotalIn += mempool.mapTx[txin.prevout.hash].vout[txin.prevout.n].nValue;\n                     continue;\n                 }\n                 int64 nValueIn = txPrev.vout[txin.prevout.n].nValue;\n+                nTotalIn += nValueIn;\n \n-                // Read block header\n                 int nConf = txindex.GetDepthInMainChain();\n-\n                 dPriority += (double)nValueIn * nConf;\n-\n-                if (fDebug && GetBoolArg(\"-printpriority\"))\n-                    printf(\"priority     nValueIn=%-12\"PRI64d\" nConf=%-5d dPriority=%-20.1f\\n\", nValueIn, nConf, dPriority);\n             }\n \n             // Priority is sum(valuein * age) / txsize\n-            dPriority /= ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);\n+            unsigned int nTxSize = ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);\n+            dPriority /= nTxSize;\n \n-            if (porphan)\n-                porphan->dPriority = dPriority;\n-            else\n-                mapPriority.insert(make_pair(-dPriority, &(*mi).second));\n+            // This is a more accurate fee-per-kilobyte than is used by the client code, because the\n+            // client code rounds up the size to the nearest 1K. That's good, because it gives an\n+            // incentive to create smaller transactions.\n+            double dFeePerKb =  double(nTotalIn-tx.GetValueOut()) / (double(nTxSize)/1000.0);\n \n-            if (fDebug && GetBoolArg(\"-printpriority\"))\n+            if (porphan)\n             {\n-                printf(\"priority %-20.1f %s\\n%s\", dPriority, tx.GetHash().ToString().substr(0,10).c_str(), tx.ToString().c_str());\n-                if (porphan)\n-                    porphan->print();\n-                printf(\"\\n\");\n+                porphan->dPriority = dPriority;\n+                porphan->dFeePerKb = dFeePerKb;\n             }\n+            else\n+                vecPriority.push_back(TxPriority(dPriority, dFeePerKb, &(*mi).second));\n         }\n \n         // Collect transactions into block\n         map<uint256, CTxIndex> mapTestPool;\n         uint64 nBlockSize = 1000;\n         uint64 nBlockTx = 0;\n         int nBlockSigOps = 100;\n-        while (!mapPriority.empty())\n+        bool fSortedByFee = (nBlockPrioritySize <= 0);\n+\n+        TxPriorityCompare comparer(fSortedByFee);\n+        std::make_heap(vecPriority.begin(), vecPriority.end(), comparer);\n+\n+        while (!vecPriority.empty())\n         {\n-            // Take highest priority transaction off priority queue\n-            double dPriority = -(*mapPriority.begin()).first;\n-            CTransaction& tx = *(*mapPriority.begin()).second;\n-            mapPriority.erase(mapPriority.begin());\n+            // Take highest priority transaction off the priority queue:\n+            double dPriority = vecPriority.front().get<0>();\n+            double dFeePerKb = vecPriority.front().get<1>();\n+            CTransaction& tx = *(vecPriority.front().get<2>());\n+\n+            std::pop_heap(vecPriority.begin(), vecPriority.end(), comparer);\n+            vecPriority.pop_back();\n \n             // Size limits\n             unsigned int nTxSize = ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);\n-            if (nBlockSize + nTxSize >= MAX_BLOCK_SIZE_GEN)\n+            if (nBlockSize + nTxSize >= nBlockMaxSize)\n                 continue;\n \n             // Legacy limits on sigOps:\n             unsigned int nTxSigOps = tx.GetLegacySigOpCount();\n             if (nBlockSigOps + nTxSigOps >= MAX_BLOCK_SIGOPS)\n                 continue;\n \n-            // Transaction fee required depends on block size\n-            bool fAllowFree = (nBlockSize + nTxSize < 4000 || CTransaction::AllowFree(dPriority));\n-            int64 nMinFee = tx.GetMinFee(nBlockSize, fAllowFree, GMF_BLOCK);\n+            // Skip free transactions if we're past the minimum block size:\n+            if (fSortedByFee && (dFeePerKb < nMinTxFee) && (nBlockSize + nTxSize >= nBlockMinSize))\n+                continue;\n+\n+            // Prioritize by fee once past the priority size or we run out of high-priority\n+            // transactions:\n+            if (!fSortedByFee &&\n+                ((nBlockSize + nTxSize >= nBlockPrioritySize) || (dPriority < COIN * 144 / 250)))\n+            {\n+                fSortedByFee = true;\n+                comparer = TxPriorityCompare(fSortedByFee);\n+                std::make_heap(vecPriority.begin(), vecPriority.end(), comparer);\n+            }\n \n             // Connecting shouldn't fail due to dependency on other memory pool transactions\n             // because we're already processing them in order of dependency\n@@ -3452,8 +3522,6 @@ CBlock* CreateNewBlock(CReserveKey& reservekey)\n                 continue;\n \n             int64 nTxFees = tx.GetValueIn(mapInputs)-tx.GetValueOut();\n-            if (nTxFees < nMinFee)\n-                continue;\n \n             nTxSigOps += tx.GetP2SHSigOpCount(mapInputs);\n             if (nBlockSigOps + nTxSigOps >= MAX_BLOCK_SIGOPS)\n@@ -3471,6 +3539,12 @@ CBlock* CreateNewBlock(CReserveKey& reservekey)\n             nBlockSigOps += nTxSigOps;\n             nFees += nTxFees;\n \n+            if (fDebug && GetBoolArg(\"-printpriority\"))\n+            {\n+                printf(\"priority %.1f feeperkb %.1f txid %s\\n\",\n+                       dPriority, dFeePerKb, tx.GetHash().ToString().c_str());\n+            }\n+\n             // Add transactions that depend on this one to the priority queue\n             uint256 hash = tx.GetHash();\n             if (mapDependers.count(hash))\n@@ -3481,7 +3555,10 @@ CBlock* CreateNewBlock(CReserveKey& reservekey)\n                     {\n                         porphan->setDependsOn.erase(hash);\n                         if (porphan->setDependsOn.empty())\n-                            mapPriority.insert(make_pair(-porphan->dPriority, porphan->ptx));\n+                        {\n+                            vecPriority.push_back(TxPriority(porphan->dPriority, porphan->dFeePerKb, porphan->ptx));\n+                            std::push_heap(vecPriority.begin(), vecPriority.end(), comparer);\n+                        }\n                     }\n                 }\n             }\n@@ -3654,7 +3731,8 @@ void static BitcoinMiner(CWallet *pwallet)\n             return;\n         IncrementExtraNonce(pblock.get(), pindexPrev, nExtraNonce);\n \n-        printf(\"Running BitcoinMiner with %d transactions in block\\n\", pblock->vtx.size());\n+        printf(\"Running BitcoinMiner with %d transactions in block (%u bytes)\\n\", pblock->vtx.size(),\n+               ::GetSerializeSize(*pblock, SER_NETWORK, PROTOCOL_VERSION));\n \n \n         //"
      }
    ]
  },
  {
    "sha": "e0e54740b10e28dac2fe7aa9b461e956452e9649",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplMGU1NDc0MGIxMGUyOGRhYzJmZTdhYTliNDYxZTk1NjQ1MmU5NjQ5",
    "commit": {
      "author": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2012-07-26T19:29:59Z"
      },
      "committer": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2012-07-26T19:29:59Z"
      },
      "message": "Handle should-never-happen case of orphan in mempool",
      "tree": {
        "sha": "11f5133cd35c7a55f347e0a67883d242b923d3e5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/11f5133cd35c7a55f347e0a67883d242b923d3e5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e0e54740b10e28dac2fe7aa9b461e956452e9649",
      "comment_count": 2,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e0e54740b10e28dac2fe7aa9b461e956452e9649",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e0e54740b10e28dac2fe7aa9b461e956452e9649",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e0e54740b10e28dac2fe7aa9b461e956452e9649/comments",
    "author": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c555400ca134991e39d5e3a565fcd2215abe56f6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c555400ca134991e39d5e3a565fcd2215abe56f6",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c555400ca134991e39d5e3a565fcd2215abe56f6"
      }
    ],
    "stats": {
      "total": 15,
      "additions": 15,
      "deletions": 0
    },
    "files": [
      {
        "sha": "98eff597fcfc9f2d7548e7e1d0791130686e6ca6",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e0e54740b10e28dac2fe7aa9b461e956452e9649/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e0e54740b10e28dac2fe7aa9b461e956452e9649/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=e0e54740b10e28dac2fe7aa9b461e956452e9649",
        "patch": "@@ -3425,13 +3425,27 @@ CBlock* CreateNewBlock(CReserveKey& reservekey)\n             COrphan* porphan = NULL;\n             double dPriority = 0;\n             int64 nTotalIn = 0;\n+            bool fMissingInputs = false;\n             BOOST_FOREACH(const CTxIn& txin, tx.vin)\n             {\n                 // Read prev transaction\n                 CTransaction txPrev;\n                 CTxIndex txindex;\n                 if (!txPrev.ReadFromDisk(txdb, txin.prevout, txindex))\n                 {\n+                    // This should never happen; all transactions in the memory\n+                    // pool should connect to either transactions in the chain\n+                    // or other transactions in the memory pool.\n+                    if (!mempool.mapTx.count(txin.prevout.hash))\n+                    {\n+                        printf(\"ERROR: mempool transaction missing input\\n\");\n+                        if (fDebug) assert(\"mempool transaction missing input\" == 0);\n+                        fMissingInputs = true;\n+                        if (porphan)\n+                            vOrphan.pop_back();\n+                        break;\n+                    }\n+\n                     // Has to wait for dependencies\n                     if (!porphan)\n                     {\n@@ -3450,6 +3464,7 @@ CBlock* CreateNewBlock(CReserveKey& reservekey)\n                 int nConf = txindex.GetDepthInMainChain();\n                 dPriority += (double)nValueIn * nConf;\n             }\n+            if (fMissingInputs) continue;\n \n             // Priority is sum(valuein * age) / txsize\n             unsigned int nTxSize = ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);"
      }
    ]
  }
]