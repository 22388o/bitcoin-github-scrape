[
  {
    "sha": "137d0685a45d4a02f5773652130704ad135e63f7",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxMzdkMDY4NWE0NWQ0YTAyZjU3NzM2NTIxMzA3MDRhZDEzNWU2M2Y3",
    "commit": {
      "author": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2012-01-20T22:07:40Z"
      },
      "committer": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2012-01-20T22:07:40Z"
      },
      "message": "Simplify counting of P2SH sigops to match BIP 16 (thanks to Matt Corallo for prompting this).\n\nThis also removes an un-needed sigops-per-byte check when accepting transactions to the memory pool (un-needed assuming only standard transactions are being accepted). And it only counts P2SH sigops after the switchover date.",
      "tree": {
        "sha": "b28518fa3c67aebea8e9720a24661b6747fe524f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b28518fa3c67aebea8e9720a24661b6747fe524f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/137d0685a45d4a02f5773652130704ad135e63f7",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/137d0685a45d4a02f5773652130704ad135e63f7",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/137d0685a45d4a02f5773652130704ad135e63f7",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/137d0685a45d4a02f5773652130704ad135e63f7/comments",
    "author": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1240a1b0a82e0e944a6fdcf6ff26001e1bd68904",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1240a1b0a82e0e944a6fdcf6ff26001e1bd68904",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1240a1b0a82e0e944a6fdcf6ff26001e1bd68904"
      }
    ],
    "stats": {
      "total": 105,
      "additions": 53,
      "deletions": 52
    },
    "files": [
      {
        "sha": "18d3c2f0ea8b36d739a8b39843ea17acededd20a",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 35,
        "deletions": 43,
        "changes": 78,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/137d0685a45d4a02f5773652130704ad135e63f7/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/137d0685a45d4a02f5773652130704ad135e63f7/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=137d0685a45d4a02f5773652130704ad135e63f7",
        "patch": "@@ -503,20 +503,17 @@ bool CTransaction::AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs, bool* pfMi\n         if (!AreInputsStandard(mapInputs))\n             return error(\"AcceptToMemoryPool() : nonstandard transaction input\");\n \n+        // Note: if you modify this code to accept non-standard transactions, then\n+        // you should add code here to check that the transaction does a\n+        // reasonable number of ECDSA signature verifications.\n+\n         int64 nFees = GetValueIn(mapInputs)-GetValueOut();\n-        int nSigOps = GetSigOpCount(mapInputs);\n         unsigned int nSize = ::GetSerializeSize(*this, SER_NETWORK);\n \n         // Don't accept it if it can't get into a block\n         if (nFees < GetMinFee(1000, true, GMF_RELAY))\n             return error(\"AcceptToMemoryPool() : not enough fees\");\n \n-        // Checking ECDSA signatures is a CPU bottleneck, so to avoid denial-of-service\n-        // attacks disallow transactions with more than one SigOp per 65 bytes.\n-        // 65 bytes because that is the minimum size of an ECDSA signature\n-        if (nSigOps > nSize / 65 || nSize < 100)\n-            return error(\"AcceptToMemoryPool() : transaction with out-of-bounds SigOpCount\");\n-\n         // Continuously rate-limit free transactions\n         // This mitigates 'penny-flooding' -- sending thousands of free transactions just to\n         // be annoying or make other's transactions take longer to confirm.\n@@ -1013,22 +1010,24 @@ int64 CTransaction::GetValueIn(const MapPrevTx& inputs) const\n \n }\n \n-int CTransaction::GetSigOpCount(const MapPrevTx& inputs) const\n+int CTransaction::GetP2SHSigOpCount(const MapPrevTx& inputs) const\n {\n     if (IsCoinBase())\n         return 0;\n \n     int nSigOps = 0;\n     for (int i = 0; i < vin.size(); i++)\n     {\n-        nSigOps += GetOutputFor(vin[i], inputs).scriptPubKey.GetSigOpCount(vin[i].scriptSig);\n+        const CTxOut& prevout = GetOutputFor(vin[i], inputs);\n+        if (prevout.scriptPubKey.IsPayToScriptHash())\n+            nSigOps += prevout.scriptPubKey.GetSigOpCount(vin[i].scriptSig);\n     }\n     return nSigOps;\n }\n \n bool CTransaction::ConnectInputs(MapPrevTx inputs,\n                                  map<uint256, CTxIndex>& mapTestPool, const CDiskTxPos& posThisTx,\n-                                 const CBlockIndex* pindexBlock, bool fBlock, bool fMiner)\n+                                 const CBlockIndex* pindexBlock, bool fBlock, bool fMiner, bool fStrictPayToScriptHash)\n {\n     // Take over previous transactions' spent pointers\n     // fBlock is true when this is called from AcceptBlock when a new best-block is added to the blockchain\n@@ -1065,20 +1064,6 @@ bool CTransaction::ConnectInputs(MapPrevTx inputs,\n             if (!MoneyRange(txPrev.vout[prevout.n].nValue) || !MoneyRange(nValueIn))\n                 return DoS(100, error(\"ConnectInputs() : txin values out of range\"));\n \n-            bool fStrictPayToScriptHash = true;\n-            if (fBlock)\n-            {\n-                // To avoid being on the short end of a block-chain split,\n-                // don't do secondary validation of pay-to-script-hash transactions\n-                // until blocks with timestamps after paytoscripthashtime:\n-                int64 nEvalSwitchTime = GetArg(\"paytoscripthashtime\", 1329264000); // Feb 15, 2012\n-                fStrictPayToScriptHash = (pindexBlock->nTime >= nEvalSwitchTime);\n-            }\n-            // if !fBlock, then always be strict-- don't accept\n-            // invalid-under-new-rules pay-to-script-hash transactions into\n-            // our memory pool (don't relay them, don't include them\n-            // in blocks we mine).\n-\n             // Skip ECDSA signature verification when connecting blocks (fBlock=true)\n             // before the last blockchain checkpoint. This is safe because block merkle hashes are\n             // still computed and checked, and any change will be caught at the next checkpoint.\n@@ -1189,6 +1174,12 @@ bool CBlock::ConnectBlock(CTxDB& txdb, CBlockIndex* pindex)\n     if (!CheckBlock())\n         return false;\n \n+    // To avoid being on the short end of a block-chain split,\n+    // don't do secondary validation of pay-to-script-hash transactions\n+    // until blocks with timestamps after paytoscripthashtime:\n+    int64 nEvalSwitchTime = GetArg(\"-paytoscripthashtime\", 1329264000); // Feb 15, 2012\n+    bool fStrictPayToScriptHash = (pindex->nTime >= nEvalSwitchTime);\n+\n     //// issue here: it doesn't know the version\n     unsigned int nTxPos = pindex->nBlockPos + ::GetSerializeSize(CBlock(), SER_DISK) - 1 + GetSizeOfCompactSize(vtx.size());\n \n@@ -1197,6 +1188,10 @@ bool CBlock::ConnectBlock(CTxDB& txdb, CBlockIndex* pindex)\n     int nSigOps = 0;\n     BOOST_FOREACH(CTransaction& tx, vtx)\n     {\n+        nSigOps += tx.GetLegacySigOpCount();\n+        if (nSigOps > MAX_BLOCK_SIGOPS)\n+            return DoS(100, error(\"ConnectBlock() : too many sigops\"));\n+\n         CDiskTxPos posThisTx(pindex->nFile, pindex->nBlockPos, nTxPos);\n         nTxPos += ::GetSerializeSize(tx, SER_DISK);\n \n@@ -1206,17 +1201,19 @@ bool CBlock::ConnectBlock(CTxDB& txdb, CBlockIndex* pindex)\n             if (!tx.FetchInputs(txdb, mapQueuedChanges, true, false, mapInputs))\n                 return false;\n \n-            int nTxOps = tx.GetSigOpCount(mapInputs);\n-            nSigOps += nTxOps;\n-            if (nSigOps > MAX_BLOCK_SIGOPS)\n-                return DoS(100, error(\"ConnectBlock() : too many sigops\"));\n-            // There is a different MAX_BLOCK_SIGOPS check in AcceptBlock();\n-            // a block must satisfy both to make it into the best-chain\n-            // (AcceptBlock() is always called before ConnectBlock())\n+            if (fStrictPayToScriptHash)\n+            {\n+                // Add in sigops done by pay-to-script-hash inputs;\n+                // this is to prevent a \"rogue miner\" from creating\n+                // an incredibly-expensive-to-validate block.\n+                nSigOps += tx.GetP2SHSigOpCount(mapInputs);\n+                if (nSigOps > MAX_BLOCK_SIGOPS)\n+                    return DoS(100, error(\"ConnectBlock() : too many sigops\"));\n+            }\n \n             nFees += tx.GetValueIn(mapInputs)-tx.GetValueOut();\n \n-            if (!tx.ConnectInputs(mapInputs, mapQueuedChanges, posThisTx, pindex, true, false))\n+            if (!tx.ConnectInputs(mapInputs, mapQueuedChanges, posThisTx, pindex, true, false, fStrictPayToScriptHash))\n                 return false;\n         }\n \n@@ -1500,9 +1497,6 @@ bool CBlock::CheckBlock() const\n         if (!tx.CheckTransaction())\n             return DoS(tx.nDoS, error(\"CheckBlock() : CheckTransaction failed\"));\n \n-    // Pre-pay-to-script-hash (before version 0.6), this is how sigops\n-    // were counted; there is another check in ConnectBlock when\n-    // transaction inputs are fetched to count pay-to-script-hash sigops:\n     int nSigOps = 0;\n     BOOST_FOREACH(const CTransaction& tx, vtx)\n     {\n@@ -3036,8 +3030,7 @@ CBlock* CreateNewBlock(CReserveKey& reservekey)\n         map<uint256, CTxIndex> mapTestPool;\n         uint64 nBlockSize = 1000;\n         uint64 nBlockTx = 0;\n-        int nBlockSigOps1 = 100; // pre-0.6 count of sigOps\n-        int nBlockSigOps2 = 100; // post-0.6 count of sigOps\n+        int nBlockSigOps = 100;\n         while (!mapPriority.empty())\n         {\n             // Take highest priority transaction off priority queue\n@@ -3051,8 +3044,8 @@ CBlock* CreateNewBlock(CReserveKey& reservekey)\n                 continue;\n \n             // Legacy limits on sigOps:\n-            int nTxSigOps1 = tx.GetLegacySigOpCount();\n-            if (nBlockSigOps1 + nTxSigOps1 >= MAX_BLOCK_SIGOPS)\n+            int nTxSigOps = tx.GetLegacySigOpCount();\n+            if (nBlockSigOps + nTxSigOps >= MAX_BLOCK_SIGOPS)\n                 continue;\n \n             // Transaction fee required depends on block size\n@@ -3070,8 +3063,8 @@ CBlock* CreateNewBlock(CReserveKey& reservekey)\n             if (nFees < nMinFee)\n                 continue;\n \n-            int nTxSigOps2 = tx.GetSigOpCount(mapInputs);\n-            if (nBlockSigOps2 + nTxSigOps2 >= MAX_BLOCK_SIGOPS)\n+            nTxSigOps += tx.GetP2SHSigOpCount(mapInputs);\n+            if (nBlockSigOps + nTxSigOps >= MAX_BLOCK_SIGOPS)\n                 continue;\n \n             if (!tx.ConnectInputs(mapInputs, mapTestPoolTmp, CDiskTxPos(1,1,1), pindexPrev, false, true))\n@@ -3083,8 +3076,7 @@ CBlock* CreateNewBlock(CReserveKey& reservekey)\n             pblock->vtx.push_back(tx);\n             nBlockSize += nTxSize;\n             ++nBlockTx;\n-            nBlockSigOps1 += nTxSigOps1;\n-            nBlockSigOps2 += nTxSigOps2;\n+            nBlockSigOps += nTxSigOps;\n \n             // Add transactions that depend on this one to the priority queue\n             uint256 hash = tx.GetHash();"
      },
      {
        "sha": "6db9fc80532f618e5044e691b3bfd7eb5c5a4242",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/137d0685a45d4a02f5773652130704ad135e63f7/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/137d0685a45d4a02f5773652130704ad135e63f7/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=137d0685a45d4a02f5773652130704ad135e63f7",
        "patch": "@@ -528,14 +528,13 @@ class CTransaction\n     */\n     int GetLegacySigOpCount() const;\n \n-    /** Count ECDSA signature operations the new (0.6-and-later) way\n-        This is a better measure of how expensive it is to process this transaction.\n+    /** Count ECDSA signature operations in pay-to-script-hash inputs.\n \n         @param[in] mapInputs\tMap of previous transactions that have outputs we're spending\n         @return maximum number of sigops required to validate this transaction's inputs\n         @see CTransaction::FetchInputs\n      */\n-    int GetSigOpCount(const MapPrevTx& mapInputs) const;\n+    int GetP2SHSigOpCount(const MapPrevTx& mapInputs) const;\n \n     /** Amount of bitcoins spent by this transaction.\n         @return sum of all outputs (note: does not include fees)\n@@ -698,11 +697,12 @@ class CTransaction\n         @param[in] pindexBlock\n         @param[in] fBlock\ttrue if called from ConnectBlock\n         @param[in] fMiner\ttrue if called from CreateNewBlock\n+        @param[in] fStrictPayToScriptHash\ttrue if fully validating p2sh transactions\n         @return Returns true if all checks succeed\n      */\n     bool ConnectInputs(MapPrevTx inputs,\n                        std::map<uint256, CTxIndex>& mapTestPool, const CDiskTxPos& posThisTx,\n-                       const CBlockIndex* pindexBlock, bool fBlock, bool fMiner);\n+                       const CBlockIndex* pindexBlock, bool fBlock, bool fMiner, bool fStrictPayToScriptHash=true);\n     bool ClientConnectInputs();\n     bool CheckTransaction() const;\n     bool AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs=true, bool* pfMissingInputs=NULL);"
      },
      {
        "sha": "c782e0c6c1e2d98d0498a8156dd5dba70b423b14",
        "filename": "src/test/script_P2SH_tests.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 3,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/137d0685a45d4a02f5773652130704ad135e63f7/src/test/script_P2SH_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/137d0685a45d4a02f5773652130704ad135e63f7/src/test/script_P2SH_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_P2SH_tests.cpp?ref=137d0685a45d4a02f5773652130704ad135e63f7",
        "patch": "@@ -255,7 +255,7 @@ BOOST_AUTO_TEST_CASE(AreInputsStandard)\n     }\n \n     CTransaction txFrom;\n-    txFrom.vout.resize(5);\n+    txFrom.vout.resize(6);\n \n     // First three are standard:\n     CScript pay1; pay1.SetBitcoinAddress(key[0].GetPubKey());\n@@ -267,12 +267,18 @@ BOOST_AUTO_TEST_CASE(AreInputsStandard)\n     txFrom.vout[1].scriptPubKey = pay1;\n     txFrom.vout[2].scriptPubKey = pay1of3;\n \n-    // Last two non-standard:\n+    // Last three non-standard:\n     CScript empty;\n     keystore.AddCScript(empty);\n     txFrom.vout[3].scriptPubKey = empty;\n     // Can't use SetPayToScriptHash, it checks for the empty Script. So:\n     txFrom.vout[4].scriptPubKey << OP_HASH160 << Hash160(empty) << OP_EQUAL;\n+    CScript oneOfEleven;\n+    oneOfEleven << OP_1;\n+    for (int i = 0; i < 11; i++)\n+        oneOfEleven << key[0].GetPubKey();\n+    oneOfEleven << OP_11 << OP_CHECKMULTISIG;\n+    txFrom.vout[5].scriptPubKey.SetPayToScriptHash(oneOfEleven);\n \n     mapInputs[txFrom.GetHash()] = make_pair(CTxIndex(), txFrom);\n \n@@ -292,16 +298,21 @@ BOOST_AUTO_TEST_CASE(AreInputsStandard)\n     BOOST_CHECK(SignSignature(keystore, txFrom, txTo, 2));\n \n     BOOST_CHECK(txTo.AreInputsStandard(mapInputs));\n+    BOOST_CHECK_EQUAL(txTo.GetP2SHSigOpCount(mapInputs), 1);\n \n     CTransaction txToNonStd;\n     txToNonStd.vout.resize(1);\n     txToNonStd.vout[0].scriptPubKey.SetBitcoinAddress(key[1].GetPubKey());\n-    txToNonStd.vin.resize(1);\n+    txToNonStd.vin.resize(2);\n     txToNonStd.vin[0].prevout.n = 4;\n     txToNonStd.vin[0].prevout.hash = txFrom.GetHash();\n     txToNonStd.vin[0].scriptSig << Serialize(empty);\n+    txToNonStd.vin[1].prevout.n = 5;\n+    txToNonStd.vin[1].prevout.hash = txFrom.GetHash();\n+    txToNonStd.vin[1].scriptSig << OP_0 << Serialize(oneOfEleven);\n \n     BOOST_CHECK(!txToNonStd.AreInputsStandard(mapInputs));\n+    BOOST_CHECK_EQUAL(txToNonStd.GetP2SHSigOpCount(mapInputs), 11);\n \n     txToNonStd.vin[0].scriptSig.clear();\n     BOOST_CHECK(!txToNonStd.AreInputsStandard(mapInputs));"
      },
      {
        "sha": "592fe3f81a3f7b60c834fb4ac1d279b7a8270fdb",
        "filename": "src/test/transaction_tests.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/137d0685a45d4a02f5773652130704ad135e63f7/src/test/transaction_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/137d0685a45d4a02f5773652130704ad135e63f7/src/test/transaction_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/transaction_tests.cpp?ref=137d0685a45d4a02f5773652130704ad135e63f7",
        "patch": "@@ -78,7 +78,6 @@ BOOST_AUTO_TEST_CASE(test_Get)\n     t1.vout[0].scriptPubKey << OP_1;\n \n     BOOST_CHECK(t1.AreInputsStandard(dummyInputs));\n-    BOOST_CHECK_EQUAL(t1.GetSigOpCount(dummyInputs), 3);\n     BOOST_CHECK_EQUAL(t1.GetValueIn(dummyInputs), (50+21+22)*CENT);\n }\n \n@@ -103,7 +102,6 @@ BOOST_AUTO_TEST_CASE(test_GetThrow)\n     t1.vout[0].scriptPubKey << OP_1;\n \n     BOOST_CHECK_THROW(t1.AreInputsStandard(missingInputs), runtime_error);\n-    BOOST_CHECK_THROW(t1.GetSigOpCount(missingInputs), runtime_error);\n     BOOST_CHECK_THROW(t1.GetValueIn(missingInputs), runtime_error);\n }\n "
      }
    ]
  }
]