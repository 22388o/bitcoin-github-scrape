[
  {
    "sha": "0425c6409000aeb3270ba8f9c30d2746c5c5b784",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowNDI1YzY0MDkwMDBhZWIzMjcwYmE4ZjljMzBkMjc0NmM1YzViNzg0",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2018-09-25T23:53:04Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "j@rubin.io",
        "date": "2018-11-29T07:53:05Z"
      },
      "message": "Add Probabalistic Checker for Duplicate Inputs\n\nFix hash computations to get unique bits\n\nUse less error-prone code for bitset\n\nrevert tx_verify.* to master\n\nAdd probabalistic duplicate detector to CheckBlock\n\nClean up the implementation of fast deduplication checking\n\nSmall clean up of comment & code layout for Duplicate Input checking\n\nMake duplicate checker also check for longchain validity\n\nCleanup the DuplicateInputs interface to CheckInputInvariants and remove some redundant checks\n\nChange test reasons to match new behavior\n\nSwitch to PCG generator",
      "tree": {
        "sha": "0a5d80b854470868a6ea593fa55602a8b119d3fe",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0a5d80b854470868a6ea593fa55602a8b119d3fe"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0425c6409000aeb3270ba8f9c30d2746c5c5b784",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0425c6409000aeb3270ba8f9c30d2746c5c5b784",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0425c6409000aeb3270ba8f9c30d2746c5c5b784",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0425c6409000aeb3270ba8f9c30d2746c5c5b784/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "60b20c869f8df9a81b5080ebcbe8c9cf4e6b9d77",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/60b20c869f8df9a81b5080ebcbe8c9cf4e6b9d77",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/60b20c869f8df9a81b5080ebcbe8c9cf4e6b9d77"
      }
    ],
    "stats": {
      "total": 255,
      "additions": 241,
      "deletions": 14
    },
    "files": [
      {
        "sha": "e8ef3add390498830b507f586e441d0b0e595654",
        "filename": "src/consensus/tx_verify.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 4,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0425c6409000aeb3270ba8f9c30d2746c5c5b784/src/consensus/tx_verify.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0425c6409000aeb3270ba8f9c30d2746c5c5b784/src/consensus/tx_verify.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/tx_verify.cpp?ref=0425c6409000aeb3270ba8f9c30d2746c5c5b784",
        "patch": "@@ -156,7 +156,7 @@ int64_t GetTransactionSigOpCost(const CTransaction& tx, const CCoinsViewCache& i\n     return nSigOps;\n }\n \n-bool CheckTransaction(const CTransaction& tx, CValidationState &state, bool fCheckDuplicateInputs)\n+bool CheckTransaction(const CTransaction& tx, CValidationState& state, bool fCheckDuplicateInputs, bool fCheckNullInputs)\n {\n     // Basic checks that don't depend on any context\n     if (tx.vin.empty())\n@@ -194,9 +194,7 @@ bool CheckTransaction(const CTransaction& tx, CValidationState &state, bool fChe\n     {\n         if (tx.vin[0].scriptSig.size() < 2 || tx.vin[0].scriptSig.size() > 100)\n             return state.DoS(100, false, REJECT_INVALID, \"bad-cb-length\");\n-    }\n-    else\n-    {\n+    } else if (fCheckNullInputs) {\n         for (const auto& txin : tx.vin)\n             if (txin.prevout.IsNull())\n                 return state.DoS(10, false, REJECT_INVALID, \"bad-txns-prevout-null\");"
      },
      {
        "sha": "9a2febf9072f24411c56cb662be9769df01c0957",
        "filename": "src/consensus/tx_verify.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0425c6409000aeb3270ba8f9c30d2746c5c5b784/src/consensus/tx_verify.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0425c6409000aeb3270ba8f9c30d2746c5c5b784/src/consensus/tx_verify.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/tx_verify.h?ref=0425c6409000aeb3270ba8f9c30d2746c5c5b784",
        "patch": "@@ -18,7 +18,7 @@ class CValidationState;\n /** Transaction validation functions */\n \n /** Context-independent validity checks */\n-bool CheckTransaction(const CTransaction& tx, CValidationState& state, bool fCheckDuplicateInputs=true);\n+bool CheckTransaction(const CTransaction& tx, CValidationState& state, bool fCheckDuplicateInputs = true, bool fCheckNullInputs = true);\n \n namespace Consensus {\n /**"
      },
      {
        "sha": "2136ca946df19adeeaaa28476bda9fe438c26659",
        "filename": "src/test/miner_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0425c6409000aeb3270ba8f9c30d2746c5c5b784/src/test/miner_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0425c6409000aeb3270ba8f9c30d2746c5c5b784/src/test/miner_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/miner_tests.cpp?ref=0425c6409000aeb3270ba8f9c30d2746c5c5b784",
        "patch": "@@ -363,7 +363,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     tx.vout[0].scriptPubKey = CScript() << OP_2;\n     hash = tx.GetHash();\n     mempool.addUnchecked(entry.Fee(HIGHFEE).Time(GetTime()).SpendsCoinbase(true).FromTx(tx));\n-    BOOST_CHECK_EXCEPTION(AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey), std::runtime_error, HasReason(\"bad-txns-inputs-missingorspent\"));\n+    BOOST_CHECK_EXCEPTION(AssemblerForTest(chainparams).CreateNewBlock(scriptPubKey), std::runtime_error, HasReason(\"bad-txns-inputs-duplicate\"));\n     mempool.clear();\n \n     // subsidy changing"
      },
      {
        "sha": "d7ec7519aa53309342bdefdaa9e1604fb5518ce3",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 234,
        "deletions": 5,
        "changes": 239,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0425c6409000aeb3270ba8f9c30d2746c5c5b784/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0425c6409000aeb3270ba8f9c30d2746c5c5b784/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=0425c6409000aeb3270ba8f9c30d2746c5c5b784",
        "patch": "@@ -3075,6 +3075,232 @@ static bool CheckBlockHeader(const CBlockHeader& block, CValidationState& state,\n     return true;\n }\n \n+/* CheckInputInvariants checks for three criticial invariants for the inputs in a block:\n+ * 1) No Duplicate Inputs\n+ * 2) Only one Coinbase (implied by 1)\n+ * 3) No Null Inputs other than coinbase (implied by 1 and 5)\n+ * 4) All long-chains are in order\n+ *\n+ * It does not check\n+ * 5) First txn is coinbase\n+ */\n+static bool CheckInputInvariants(const CBlock& block, CValidationState& state)\n+{\n+    /* This duplication checking algorithm uses a probabilistic filter to check\n+     * for collisions efficiently.  This is faster than the naive construction,\n+     * using a set, which requires more allocation and comparisons of uint256s.\n+     *\n+     * First we create a bitset table with 1<<21 elements. This is around 300\n+     * KB, so we construct it on the heap. We also create 8 pseudo-random\n+     * functions based on PCG. Each PCG function considers looks at 64 bits of\n+     * the prevout's hash, and the increment is xor'd with the index. Although\n+     * each hash is not dependent on the entire hash, a single 64-bit collision\n+     * would be expected with 4-billion UTXOS, and even then that would not\n+     * trigger a collision in this algorithm directly as there are 3 other\n+     * 64-bit hashes to collide.\n+     *\n+     *\n+     * Then, we iterate through the inputs one by one in order, hashing them using\n+     * our PCG hash functions.\n+     *\n+     * We then check if all 8 hashes are set in the table yet. If they are, we\n+     * do a linear scan through the inputs to see if it was a true collision,\n+     * and reject the txn.\n+     *\n+     * Otherwise, we set the 8 bits corresponding to the hashes and continue.\n+     *\n+     * ------------------------------------------------------------------------\n+     * Analysis\n+     * ------------------------------------------------------------------------\n+     * From the perspective of the N+1st prevout, assuming the transaction does\n+     * not double spend:\n+     *\n+     * Up to N*8 hashes have been set in the table already (potentially fewer if\n+     * collisions)\n+     *\n+     * For each of the 8 hashes h_1...h_8, P(bit set in table for h_i) =\n+     * (N*8)/1<<21\n+     *\n+     * Each of these probabilities is independent\n+     *\n+     * Therefore the total probability of a false collision on all bits is:\n+     * ((N*8)/2**21)**8\n+     *\n+     * The cost of a false collision is to do N comparisons.\n+     *\n+     * Therefore, the expression for the expected number of comparisons is:\n+     *\n+     * Sum[i*( i*8 / 2**21)**8, {i, 0, M}]\n+     *\n+     * Based on an input being at least 41 bytes, and a block being 1M bytes\n+     * max, there are a maximum of 24390 inputs, so M = 24390\n+     *\n+     * The total expected number of direct comparisons for M=24930 is therefore\n+     * 0.33 with this algorithm.\n+     *\n+     * The worst case for this algorithm from a denial of service perspective\n+     * with an invalid block would be to do a transaction where the last two\n+     * elements are a collision. In this case, the scan would require to scan all\n+     * N elements to find the conflict.\n+     *\n+     * ------------------------------------------------------------------------\n+     *  Extensions\n+     * ------------------------------------------------------------------------\n+     *\n+     * - Single Coinbase / Null Input Check\n+     *     Note that the first element checked is the coinbase transaction,\n+     *     whose input is null. Therefore, any subsequent null input would be a\n+     *     collision with that null, enabling us to not null check every\n+     *     subsequent entry. This has 0 overhead.\n+     * - Long Chain Check\n+     *     We also scan for the presence of the outputs of a transaction in the\n+     *     table as we go (without insertion), which detects an out-of-order\n+     *     spend in a long-chain within a block.\n+     *\n+     *     The worst case behavior for a block under this additional scan is for\n+     *     all inputs to be spent and then all outputs to be created. Any other\n+     *     pattern of inputs and outputs would be strictly less work. A minimal\n+     *     output is 9 bytes -- there are at most 1e6/9 outputs. Thus, we can\n+     *     model it as:\n+     *\n+     *     Max[((1-x)*1e6/9)(x*1e6/41)*(8*x*(1e6/41) / 2**21)**8 +\n+     *         Sum[ i*( i*8 / 2**21)**8, {i, 0, x*1e6/41}], {x, 0, 1}]\n+     *\n+     *     That is:\n+     *       The most amount of work for a given fraction x of block space devoted to\n+     *       inputs, which is the expected amount of work for checking a table with\n+     *       x*1e6/41 entries (1-x)*1e6/9 additional times plus the expected  work\n+     *       for deduplicating just the inputs.\n+     *\n+     *     This expression is at most ~0.7 expected comparisons worst case, which is\n+     *     still perfectly acceptable.\n+     */\n+\n+\n+    const auto pcg = [](uint64_t start, uint64_t inc) {\n+        uint64_t nxt = (inc | 1) + (start * 6364136223846793005ULL);\n+        uint32_t x = (nxt ^ (nxt >> 18)) >> 27;\n+        uint32_t r = nxt >> 59;\n+        return (x >> r) | (x << (31 & (-r)));\n+\n+    };\n+    const uint64_t k1 = GetRand(std::numeric_limits<uint64_t>::max());\n+    const uint64_t k2 = GetRand(std::numeric_limits<uint64_t>::max());\n+    const uint64_t k3 = GetRand(std::numeric_limits<uint64_t>::max());\n+    const uint64_t k4 = GetRand(std::numeric_limits<uint64_t>::max());\n+    const uint64_t k5 = GetRand(std::numeric_limits<uint64_t>::max());\n+    const uint64_t k6 = GetRand(std::numeric_limits<uint64_t>::max());\n+    const uint64_t k7 = GetRand(std::numeric_limits<uint64_t>::max());\n+    const uint64_t k8 = GetRand(std::numeric_limits<uint64_t>::max());\n+    struct pos {\n+        uint32_t a : 21;\n+        uint32_t b : 21;\n+        uint32_t c : 21;\n+        bool empty_1 : 1;\n+        uint32_t d : 21;\n+        uint32_t e : 21;\n+        uint32_t f : 21;\n+        bool empty_2 : 1;\n+        uint32_t g : 21;\n+        uint32_t h : 21;\n+        uint32_t unused : 22;\n+    };\n+    auto hasher = [k1, k2, k3, k4, k5, k6, k7, k8, pcg](const COutPoint& out) {\n+        return pos{\n+            pcg(out.hash.GetUint64(0) ^ k1, 1 | ((((uint64_t)out.n) << 1) ^ k1)),\n+            pcg(out.hash.GetUint64(0) ^ k2, 1 | ((((uint64_t)out.n) << 1) ^ k2)),\n+            pcg(out.hash.GetUint64(1) ^ k3, 1 | ((((uint64_t)out.n) << 1) ^ k3)),\n+            false,\n+            pcg(out.hash.GetUint64(1) ^ k4, 1 | ((((uint64_t)out.n) << 1) ^ k4)),\n+            pcg(out.hash.GetUint64(2) ^ k5, 1 | ((((uint64_t)out.n) << 1) ^ k5)),\n+            pcg(out.hash.GetUint64(2) ^ k6, 1 | ((((uint64_t)out.n) << 1) ^ k6)),\n+            false,\n+            pcg(out.hash.GetUint64(3) ^ k7, 1 | ((((uint64_t)out.n) << 1) ^ k7)),\n+            pcg(out.hash.GetUint64(3) ^ k8, 1 | ((((uint64_t)out.n) << 1) ^ k8)),\n+            0,\n+        };\n+    };\n+\n+    std::unique_ptr<std::bitset<1 << 21>> pTable = MakeUnique<std::bitset<1 << 21>>();\n+    auto& table = *pTable.get();\n+    for (auto txit = block.vtx.cbegin(); txit != block.vtx.cend(); ++txit) {\n+        const auto& tx = **txit;\n+        // Check that the outpoints being created by this transaction have\n+        // not been spent by an earlier transaction (causing an invalid\n+        // longchain). We can check this before inserting this transaction's\n+        // inputs because it would cause a sha256 hash cycle for it to\n+        // conflict.\n+        COutPoint outpoint{tx.GetHash(), 0};\n+        for (size_t n = 0; n < tx.vout.size(); ++n) {\n+            outpoint.n = n;\n+            const auto hash = hasher(outpoint);\n+            if (table[hash.a] && table[hash.b] &&\n+                table[hash.c] && table[hash.d] &&\n+                table[hash.e] && table[hash.f] &&\n+                table[hash.g] && table[hash.h]) {\n+                for (auto txit2 = block.vtx.cbegin(); txit2 != txit; ++txit2) {\n+                    const auto& tx2 = **txit2;\n+                    auto elem = std::find_if(tx2.vin.cbegin(), tx2.vin.cend(),\n+                        [&](const CTxIn& x) { return x.prevout == outpoint; });\n+                    if (elem != tx2.vin.cend()) {\n+                        return state.DoS(100, false, REJECT_INVALID, \"bad-txns-longchain-ord\");\n+                    }\n+                }\n+            }\n+        }\n+        // Now check that none of this transaction's inputs are a double\n+        // spend of a previous input in the block.\n+        for (auto txinit = tx.vin.cbegin(); txinit != tx.vin.cend(); ++txinit) {\n+            const COutPoint& prevout = txinit->prevout;\n+            const auto hash = hasher(prevout);\n+            if (!table[hash.a] || !table[hash.b] ||\n+                !table[hash.c] || !table[hash.d] ||\n+                !table[hash.e] || !table[hash.f] ||\n+                !table[hash.g] || !table[hash.h]) {\n+                table[hash.a] = true;\n+                table[hash.b] = true;\n+                table[hash.c] = true;\n+                table[hash.d] = true;\n+                table[hash.e] = true;\n+                table[hash.f] = true;\n+                table[hash.g] = true;\n+                table[hash.h] = true;\n+            } else {\n+                // These are kept just to emulate some of the previous error\n+                // messages (some of the time). They can eventually be\n+                // eliminated.\n+                if (tx.IsCoinBase()) {\n+                    return state.DoS(100, false, REJECT_INVALID, \"bad-cb-multiple\", false, \"more than one coinbase\");\n+                }\n+                if (prevout.IsNull()) {\n+                    return state.DoS(10, false, REJECT_INVALID, \"bad-txns-prevout-null\");\n+                }\n+                // If we have a potential collision, perform expensive check over\n+                // all prior transactions, starting with the current transaction.\n+\n+                // Check current transaction up to the input txinit\n+                auto match = std::find_if(tx.vin.begin(), txinit,\n+                    [&](const CTxIn& x) { return x.prevout == prevout; });\n+                // If the iterator outputs anything except for txinit, then we have found a conflict\n+                if (match != txinit) {\n+                    return state.DoS(100, false, REJECT_INVALID, \"bad-txns-inputs-duplicate\");\n+                }\n+                // Check prior transaction's inputs for conflict\n+                for (auto txit2 = block.vtx.cbegin(); txit2 != txit; ++txit2) {\n+                    const auto& tx2 = **txit2;\n+                    match = std::find_if(tx2.vin.cbegin(), tx2.vin.cend(),\n+                        [&](const CTxIn& x) { return x.prevout == prevout; });\n+                    if (match != tx2.vin.cend()) {\n+                        return state.DoS(100, false, REJECT_INVALID, \"bad-txns-inputs-duplicate\");\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    return true;\n+}\n+\n bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::Params& consensusParams, bool fCheckPOW, bool fCheckMerkleRoot)\n {\n     // These are checks that are independent of context.\n@@ -3111,16 +3337,19 @@ bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::P\n     if (block.vtx.empty() || block.vtx.size() * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT || ::GetSerializeSize(block, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT)\n         return state.DoS(100, false, REJECT_INVALID, \"bad-blk-length\", false, \"size limits failed\");\n \n-    // First transaction must be coinbase, the rest must not be\n+    // First transaction must be coinbase\n     if (block.vtx.empty() || !block.vtx[0]->IsCoinBase())\n         return state.DoS(100, false, REJECT_INVALID, \"bad-cb-missing\", false, \"first tx is not coinbase\");\n-    for (unsigned int i = 1; i < block.vtx.size(); i++)\n-        if (block.vtx[i]->IsCoinBase())\n-            return state.DoS(100, false, REJECT_INVALID, \"bad-cb-multiple\", false, \"more than one coinbase\");\n+\n+    // Check transactions for duplicate inputs, longchain order, no null inputs, singular coinbase\n+    if (!CheckInputInvariants(block, state))\n+        return false;\n+\n \n     // Check transactions\n+    //\n     for (const auto& tx : block.vtx)\n-        if (!CheckTransaction(*tx, state, true))\n+        if (!CheckTransaction(*tx, state, false, false))\n             return state.Invalid(false, state.GetRejectCode(), state.GetRejectReason(),\n                                  strprintf(\"Transaction check failed (tx hash %s) %s\", tx->GetHash().ToString(), state.GetDebugMessage()));\n "
      },
      {
        "sha": "b9d81f2eb018e1c26475e4b7ff2d1b072437a2cc",
        "filename": "test/functional/feature_block.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0425c6409000aeb3270ba8f9c30d2746c5c5b784/test/functional/feature_block.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0425c6409000aeb3270ba8f9c30d2746c5c5b784/test/functional/feature_block.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_block.py?ref=0425c6409000aeb3270ba8f9c30d2746c5c5b784",
        "patch": "@@ -395,7 +395,7 @@ def run_test(self):\n         txout_b37 = b37.vtx[1]\n         tx = self.create_and_sign_transaction(out[11], 0)\n         b37 = self.update_block(37, [tx])\n-        self.sync_blocks([b37], success=False, reject_reason='bad-txns-inputs-missingorspent', reconnect=True)\n+        self.sync_blocks([b37], success=False, reject_reason='bad-txns-inputs-duplicate', reconnect=True)\n \n         # attempt to spend b37's first non-coinbase tx, at which point b37 was still considered valid\n         self.move_tip(35)\n@@ -866,7 +866,7 @@ def run_test(self):\n         tx1 = self.create_and_sign_transaction(out[20], out[20].vout[0].nValue)\n         tx2 = self.create_and_sign_transaction(tx1, 1)\n         b66 = self.update_block(66, [tx2, tx1])\n-        self.sync_blocks([b66], success=False, reject_reason='bad-txns-inputs-missingorspent', reconnect=True)\n+        self.sync_blocks([b66], success=False, reject_reason='bad-txns-longchain-ord', reconnect=True)\n \n         # Attempt to double-spend a transaction created in a block\n         #\n@@ -881,7 +881,7 @@ def run_test(self):\n         tx2 = self.create_and_sign_transaction(tx1, 1)\n         tx3 = self.create_and_sign_transaction(tx1, 2)\n         b67 = self.update_block(67, [tx1, tx2, tx3])\n-        self.sync_blocks([b67], success=False, reject_reason='bad-txns-inputs-missingorspent', reconnect=True)\n+        self.sync_blocks([b67], success=False, reject_reason='bad-txns-inputs-duplicate', reconnect=True)\n \n         # More tests of block subsidy\n         #"
      }
    ]
  }
]