[
  {
    "sha": "85e058b19145b5068f2f71a90c1182bf2a93c473",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4NWUwNThiMTkxNDViNTA2OGYyZjcxYTkwYzExODJiZjJhOTNjNDcz",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-06-03T11:33:16Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-06-03T11:39:55Z"
      },
      "message": "[net processing] Remove unnecessary hash arg from MarkBlockAsInFlight()\n\nMarkBlockAsInFlight is always called with a non-null pindex. Just get the block hash\nfrom that pindex inside the function.",
      "tree": {
        "sha": "724e788d18dfb3e8863046b5b2941818520272aa",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/724e788d18dfb3e8863046b5b2941818520272aa"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/85e058b19145b5068f2f71a90c1182bf2a93c473",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/85e058b19145b5068f2f71a90c1182bf2a93c473",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/85e058b19145b5068f2f71a90c1182bf2a93c473",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/85e058b19145b5068f2f71a90c1182bf2a93c473/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a9435e34457e0bfebd22e574fe63428537948aeb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a9435e34457e0bfebd22e574fe63428537948aeb",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a9435e34457e0bfebd22e574fe63428537948aeb"
      }
    ],
    "stats": {
      "total": 15,
      "additions": 9,
      "deletions": 6
    },
    "files": [
      {
        "sha": "9a6c62a81f7ea259aad84ef14070cb1ad7384f40",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 6,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/85e058b19145b5068f2f71a90c1182bf2a93c473/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/85e058b19145b5068f2f71a90c1182bf2a93c473/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=85e058b19145b5068f2f71a90c1182bf2a93c473",
        "patch": "@@ -472,7 +472,7 @@ class PeerManagerImpl final : public PeerManager\n      * Returns false, still setting pit, if the block was already in flight from the same peer\n      * pit will only be valid as long as the same cs_main lock is being held\n      */\n-    bool MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const CBlockIndex* pindex = nullptr, std::list<QueuedBlock>::iterator** pit = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    bool MarkBlockAsInFlight(NodeId nodeid, const CBlockIndex* pindex, std::list<QueuedBlock>::iterator** pit = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n     bool TipMayBeStale() EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n@@ -782,8 +782,11 @@ bool PeerManagerImpl::MarkBlockAsReceived(const uint256& hash)\n     return false;\n }\n \n-bool PeerManagerImpl::MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const CBlockIndex* pindex, std::list<QueuedBlock>::iterator** pit)\n+bool PeerManagerImpl::MarkBlockAsInFlight(NodeId nodeid, const CBlockIndex* pindex, std::list<QueuedBlock>::iterator** pit)\n {\n+    assert(pindex);\n+    const uint256& hash{pindex->GetBlockHash()};\n+\n     CNodeState *state = State(nodeid);\n     assert(state != nullptr);\n \n@@ -807,7 +810,7 @@ bool PeerManagerImpl::MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, co\n         // We're starting a block download (batch) from this peer.\n         state->m_downloading_since = GetTime<std::chrono::microseconds>();\n     }\n-    if (state->nBlocksInFlightValidHeaders == 1 && pindex != nullptr) {\n+    if (state->nBlocksInFlightValidHeaders == 1) {\n         nPeersWithValidatedDownloads++;\n     }\n     itInFlight = mapBlocksInFlight.insert(std::make_pair(hash, std::make_pair(nodeid, it))).first;\n@@ -2081,7 +2084,7 @@ void PeerManagerImpl::ProcessHeadersMessage(CNode& pfrom, const Peer& peer,\n                     }\n                     uint32_t nFetchFlags = GetFetchFlags(pfrom);\n                     vGetData.push_back(CInv(MSG_BLOCK | nFetchFlags, pindex->GetBlockHash()));\n-                    MarkBlockAsInFlight(pfrom.GetId(), pindex->GetBlockHash(), pindex);\n+                    MarkBlockAsInFlight(pfrom.GetId(), pindex);\n                     LogPrint(BCLog::NET, \"Requesting block %s from  peer=%d\\n\",\n                             pindex->GetBlockHash().ToString(), pfrom.GetId());\n                 }\n@@ -3384,7 +3387,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             if ((!fAlreadyInFlight && nodestate->nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) ||\n                  (fAlreadyInFlight && blockInFlightIt->second.first == pfrom.GetId())) {\n                 std::list<QueuedBlock>::iterator* queuedBlockIt = nullptr;\n-                if (!MarkBlockAsInFlight(pfrom.GetId(), pindex->GetBlockHash(), pindex, &queuedBlockIt)) {\n+                if (!MarkBlockAsInFlight(pfrom.GetId(), pindex, &queuedBlockIt)) {\n                     if (!(*queuedBlockIt)->partialBlock)\n                         (*queuedBlockIt)->partialBlock.reset(new PartiallyDownloadedBlock(&m_mempool));\n                     else {\n@@ -4767,7 +4770,7 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n             for (const CBlockIndex *pindex : vToDownload) {\n                 uint32_t nFetchFlags = GetFetchFlags(*pto);\n                 vGetData.push_back(CInv(MSG_BLOCK | nFetchFlags, pindex->GetBlockHash()));\n-                MarkBlockAsInFlight(pto->GetId(), pindex->GetBlockHash(), pindex);\n+                MarkBlockAsInFlight(pto->GetId(), pindex);\n                 LogPrint(BCLog::NET, \"Requesting block %s (%d) peer=%d\\n\", pindex->GetBlockHash().ToString(),\n                     pindex->nHeight, pto->GetId());\n             }"
      }
    ]
  },
  {
    "sha": "b4e29f2436943c131dd25b123d13a25ce09bab58",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiNGUyOWYyNDM2OTQzYzEzMWRkMjViMTIzZDEzYTI1Y2UwOWJhYjU4",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-06-03T11:38:44Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-06-03T11:39:56Z"
      },
      "message": "[net processing] Remove QueuedBlock.fValidatedHeaders\n\nSince headers-first syncing, we only ever request a block if we've already validated its headers.\nTherefore QueuedBlock.fValidatedHeaders is always set to true. Remove it.",
      "tree": {
        "sha": "7651dd4b84b97eb287ac042acb275d7626aad69a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7651dd4b84b97eb287ac042acb275d7626aad69a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b4e29f2436943c131dd25b123d13a25ce09bab58",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b4e29f2436943c131dd25b123d13a25ce09bab58",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b4e29f2436943c131dd25b123d13a25ce09bab58",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b4e29f2436943c131dd25b123d13a25ce09bab58/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "85e058b19145b5068f2f71a90c1182bf2a93c473",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/85e058b19145b5068f2f71a90c1182bf2a93c473",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/85e058b19145b5068f2f71a90c1182bf2a93c473"
      }
    ],
    "stats": {
      "total": 16,
      "additions": 9,
      "deletions": 7
    },
    "files": [
      {
        "sha": "bb60222e5f9809ed792e52a5bf2942b10f8d5b9a",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 7,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b4e29f2436943c131dd25b123d13a25ce09bab58/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b4e29f2436943c131dd25b123d13a25ce09bab58/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=b4e29f2436943c131dd25b123d13a25ce09bab58",
        "patch": "@@ -159,10 +159,12 @@ static constexpr size_t MAX_ADDR_TO_SEND{1000};\n namespace {\n /** Blocks that are in flight, and that are in the queue to be downloaded. */\n struct QueuedBlock {\n+    /** Block hash */\n     uint256 hash;\n-    const CBlockIndex* pindex;                               //!< Optional.\n-    bool fValidatedHeaders;                                  //!< Whether this block has validated headers at the time of request.\n-    std::unique_ptr<PartiallyDownloadedBlock> partialBlock;  //!< Optional, used for CMPCTBLOCK downloads\n+    /** BlockIndex. We must have this since we only request blocks when we've already validated the header. */\n+    const CBlockIndex* pindex;\n+    /** Optional, used for CMPCTBLOCK downloads */\n+    std::unique_ptr<PartiallyDownloadedBlock> partialBlock;\n };\n \n /**\n@@ -764,8 +766,8 @@ bool PeerManagerImpl::MarkBlockAsReceived(const uint256& hash)\n     if (itInFlight != mapBlocksInFlight.end()) {\n         CNodeState *state = State(itInFlight->second.first);\n         assert(state != nullptr);\n-        state->nBlocksInFlightValidHeaders -= itInFlight->second.second->fValidatedHeaders;\n-        if (state->nBlocksInFlightValidHeaders == 0 && itInFlight->second.second->fValidatedHeaders) {\n+        state->nBlocksInFlightValidHeaders -= 1;\n+        if (state->nBlocksInFlightValidHeaders == 0) {\n             // Last validated block on the queue was received.\n             nPeersWithValidatedDownloads--;\n         }\n@@ -803,9 +805,9 @@ bool PeerManagerImpl::MarkBlockAsInFlight(NodeId nodeid, const CBlockIndex* pind\n     MarkBlockAsReceived(hash);\n \n     std::list<QueuedBlock>::iterator it = state->vBlocksInFlight.insert(state->vBlocksInFlight.end(),\n-            {hash, pindex, pindex != nullptr, std::unique_ptr<PartiallyDownloadedBlock>(pit ? new PartiallyDownloadedBlock(&m_mempool) : nullptr)});\n+            {hash, pindex, std::unique_ptr<PartiallyDownloadedBlock>(pit ? new PartiallyDownloadedBlock(&m_mempool) : nullptr)});\n     state->nBlocksInFlight++;\n-    state->nBlocksInFlightValidHeaders += it->fValidatedHeaders;\n+    state->nBlocksInFlightValidHeaders += 1;\n     if (state->nBlocksInFlight == 1) {\n         // We're starting a block download (batch) from this peer.\n         state->m_downloading_since = GetTime<std::chrono::microseconds>();"
      }
    ]
  },
  {
    "sha": "b03de9c7538d85b12929a62b9ec966fd3910e660",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiMDNkZTljNzUzOGQ4NWIxMjkyOWE2MmI5ZWM5NjZmZDM5MTBlNjYw",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-06-03T11:45:15Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-06-03T11:45:15Z"
      },
      "message": "[net processing] Remove CNodeState.nBlocksInFlightValidHeaders\n\nnBlocksInFlightValidHeaders always has the same value as nBlocksInFlight, since we only download\nblocks with valid headers.",
      "tree": {
        "sha": "ea5bdebe9a9e8d80cc6b0f6f4c28fad2be2e56d3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ea5bdebe9a9e8d80cc6b0f6f4c28fad2be2e56d3"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b03de9c7538d85b12929a62b9ec966fd3910e660",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b03de9c7538d85b12929a62b9ec966fd3910e660",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b03de9c7538d85b12929a62b9ec966fd3910e660",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b03de9c7538d85b12929a62b9ec966fd3910e660/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b4e29f2436943c131dd25b123d13a25ce09bab58",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b4e29f2436943c131dd25b123d13a25ce09bab58",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b4e29f2436943c131dd25b123d13a25ce09bab58"
      }
    ],
    "stats": {
      "total": 17,
      "additions": 6,
      "deletions": 11
    },
    "files": [
      {
        "sha": "07cfd6f4e635caa84afc657a5b5577d2761f779d",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 11,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b03de9c7538d85b12929a62b9ec966fd3910e660/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b03de9c7538d85b12929a62b9ec966fd3910e660/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=b03de9c7538d85b12929a62b9ec966fd3910e660",
        "patch": "@@ -629,7 +629,6 @@ struct CNodeState {\n     //! When the first entry in vBlocksInFlight started downloading. Don't care when vBlocksInFlight is empty.\n     std::chrono::microseconds m_downloading_since{0us};\n     int nBlocksInFlight{0};\n-    int nBlocksInFlightValidHeaders{0};\n     //! Whether we consider this a preferred download peer.\n     bool fPreferredDownload{false};\n     //! Whether this peer wants invs or headers (when possible) for block announcements.\n@@ -766,17 +765,16 @@ bool PeerManagerImpl::MarkBlockAsReceived(const uint256& hash)\n     if (itInFlight != mapBlocksInFlight.end()) {\n         CNodeState *state = State(itInFlight->second.first);\n         assert(state != nullptr);\n-        state->nBlocksInFlightValidHeaders -= 1;\n-        if (state->nBlocksInFlightValidHeaders == 0) {\n-            // Last validated block on the queue was received.\n-            nPeersWithValidatedDownloads--;\n-        }\n         if (state->vBlocksInFlight.begin() == itInFlight->second.second) {\n             // First block on the queue was received, update the start download time for the next one\n             state->m_downloading_since = std::max(state->m_downloading_since, GetTime<std::chrono::microseconds>());\n         }\n         state->vBlocksInFlight.erase(itInFlight->second.second);\n         state->nBlocksInFlight--;\n+        if (state->nBlocksInFlight == 0) {\n+            // Last validated block on the queue was received.\n+            nPeersWithValidatedDownloads--;\n+        }\n         state->m_stalling_since = 0us;\n         mapBlocksInFlight.erase(itInFlight);\n         return true;\n@@ -807,12 +805,9 @@ bool PeerManagerImpl::MarkBlockAsInFlight(NodeId nodeid, const CBlockIndex* pind\n     std::list<QueuedBlock>::iterator it = state->vBlocksInFlight.insert(state->vBlocksInFlight.end(),\n             {hash, pindex, std::unique_ptr<PartiallyDownloadedBlock>(pit ? new PartiallyDownloadedBlock(&m_mempool) : nullptr)});\n     state->nBlocksInFlight++;\n-    state->nBlocksInFlightValidHeaders += 1;\n     if (state->nBlocksInFlight == 1) {\n         // We're starting a block download (batch) from this peer.\n         state->m_downloading_since = GetTime<std::chrono::microseconds>();\n-    }\n-    if (state->nBlocksInFlightValidHeaders == 1) {\n         nPeersWithValidatedDownloads++;\n     }\n     itInFlight = mapBlocksInFlight.insert(std::make_pair(hash, std::make_pair(nodeid, it))).first;\n@@ -1139,7 +1134,7 @@ void PeerManagerImpl::FinalizeNode(const CNode& node)\n     WITH_LOCK(g_cs_orphans, m_orphanage.EraseForPeer(nodeid));\n     m_txrequest.DisconnectedPeer(nodeid);\n     nPreferredDownload -= state->fPreferredDownload;\n-    nPeersWithValidatedDownloads -= (state->nBlocksInFlightValidHeaders != 0);\n+    nPeersWithValidatedDownloads -= (state->nBlocksInFlight != 0);\n     assert(nPeersWithValidatedDownloads >= 0);\n     m_outbound_peers_with_protect_from_disconnect -= state->m_chain_sync.m_protect;\n     assert(m_outbound_peers_with_protect_from_disconnect >= 0);\n@@ -4717,7 +4712,7 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n         // to unreasonably increase our timeout.\n         if (state.vBlocksInFlight.size() > 0) {\n             QueuedBlock &queuedBlock = state.vBlocksInFlight.front();\n-            int nOtherPeersWithValidatedDownloads = nPeersWithValidatedDownloads - (state.nBlocksInFlightValidHeaders > 0);\n+            int nOtherPeersWithValidatedDownloads = nPeersWithValidatedDownloads - 1;\n             if (current_time > state.m_downloading_since + std::chrono::seconds{consensusParams.nPowTargetSpacing} * (BLOCK_DOWNLOAD_TIMEOUT_BASE + BLOCK_DOWNLOAD_TIMEOUT_PER_PEER * nOtherPeersWithValidatedDownloads)) {\n                 LogPrintf(\"Timeout downloading block %s from peer=%d, disconnecting\\n\", queuedBlock.hash.ToString(), pto->GetId());\n                 pto->fDisconnect = true;"
      }
    ]
  },
  {
    "sha": "156a19ee6a22789adedcb6ab067c2eca2d3bfdfe",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxNTZhMTllZTZhMjI3ODlhZGVkY2I2YWIwNjdjMmVjYTJkM2JmZGZl",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-06-03T11:49:27Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-06-03T11:49:27Z"
      },
      "message": "scripted-diff: rename nPeersWithValidatedDownloads\n\n-BEGIN VERIFY SCRIPT-\nren() { sed -i \"s:\\<$1\\>:$2:g\" $(git grep -l \"\\<$1\\>\" ./src ./test); }\n\nren nPeersWithValidatedDownloads  m_peers_downloading_from\n-END VERIFY SCRIPT-",
      "tree": {
        "sha": "d8d66cb9fb99b152a355f485993d2b6a700eb564",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d8d66cb9fb99b152a355f485993d2b6a700eb564"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/156a19ee6a22789adedcb6ab067c2eca2d3bfdfe",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/156a19ee6a22789adedcb6ab067c2eca2d3bfdfe",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/156a19ee6a22789adedcb6ab067c2eca2d3bfdfe",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/156a19ee6a22789adedcb6ab067c2eca2d3bfdfe/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b03de9c7538d85b12929a62b9ec966fd3910e660",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b03de9c7538d85b12929a62b9ec966fd3910e660",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b03de9c7538d85b12929a62b9ec966fd3910e660"
      }
    ],
    "stats": {
      "total": 14,
      "additions": 7,
      "deletions": 7
    },
    "files": [
      {
        "sha": "ed579b2c07ee72ccb3431e2b3a6377390a120fbb",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/156a19ee6a22789adedcb6ab067c2eca2d3bfdfe/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/156a19ee6a22789adedcb6ab067c2eca2d3bfdfe/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=156a19ee6a22789adedcb6ab067c2eca2d3bfdfe",
        "patch": "@@ -514,7 +514,7 @@ class PeerManagerImpl final : public PeerManager\n     std::list<NodeId> lNodesAnnouncingHeaderAndIDs GUARDED_BY(cs_main);\n \n     /** Number of peers from which we're downloading blocks. */\n-    int nPeersWithValidatedDownloads GUARDED_BY(cs_main) = 0;\n+    int m_peers_downloading_from GUARDED_BY(cs_main) = 0;\n \n     /** Storage for orphan information */\n     TxOrphanage m_orphanage;\n@@ -773,7 +773,7 @@ bool PeerManagerImpl::MarkBlockAsReceived(const uint256& hash)\n         state->nBlocksInFlight--;\n         if (state->nBlocksInFlight == 0) {\n             // Last validated block on the queue was received.\n-            nPeersWithValidatedDownloads--;\n+            m_peers_downloading_from--;\n         }\n         state->m_stalling_since = 0us;\n         mapBlocksInFlight.erase(itInFlight);\n@@ -808,7 +808,7 @@ bool PeerManagerImpl::MarkBlockAsInFlight(NodeId nodeid, const CBlockIndex* pind\n     if (state->nBlocksInFlight == 1) {\n         // We're starting a block download (batch) from this peer.\n         state->m_downloading_since = GetTime<std::chrono::microseconds>();\n-        nPeersWithValidatedDownloads++;\n+        m_peers_downloading_from++;\n     }\n     itInFlight = mapBlocksInFlight.insert(std::make_pair(hash, std::make_pair(nodeid, it))).first;\n     if (pit)\n@@ -1134,8 +1134,8 @@ void PeerManagerImpl::FinalizeNode(const CNode& node)\n     WITH_LOCK(g_cs_orphans, m_orphanage.EraseForPeer(nodeid));\n     m_txrequest.DisconnectedPeer(nodeid);\n     nPreferredDownload -= state->fPreferredDownload;\n-    nPeersWithValidatedDownloads -= (state->nBlocksInFlight != 0);\n-    assert(nPeersWithValidatedDownloads >= 0);\n+    m_peers_downloading_from -= (state->nBlocksInFlight != 0);\n+    assert(m_peers_downloading_from >= 0);\n     m_outbound_peers_with_protect_from_disconnect -= state->m_chain_sync.m_protect;\n     assert(m_outbound_peers_with_protect_from_disconnect >= 0);\n     m_wtxid_relay_peers -= state->m_wtxid_relay;\n@@ -1147,7 +1147,7 @@ void PeerManagerImpl::FinalizeNode(const CNode& node)\n         // Do a consistency check after the last peer is removed.\n         assert(mapBlocksInFlight.empty());\n         assert(nPreferredDownload == 0);\n-        assert(nPeersWithValidatedDownloads == 0);\n+        assert(m_peers_downloading_from == 0);\n         assert(m_outbound_peers_with_protect_from_disconnect == 0);\n         assert(m_wtxid_relay_peers == 0);\n         assert(m_txrequest.Size() == 0);\n@@ -4712,7 +4712,7 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n         // to unreasonably increase our timeout.\n         if (state.vBlocksInFlight.size() > 0) {\n             QueuedBlock &queuedBlock = state.vBlocksInFlight.front();\n-            int nOtherPeersWithValidatedDownloads = nPeersWithValidatedDownloads - 1;\n+            int nOtherPeersWithValidatedDownloads = m_peers_downloading_from - 1;\n             if (current_time > state.m_downloading_since + std::chrono::seconds{consensusParams.nPowTargetSpacing} * (BLOCK_DOWNLOAD_TIMEOUT_BASE + BLOCK_DOWNLOAD_TIMEOUT_PER_PEER * nOtherPeersWithValidatedDownloads)) {\n                 LogPrintf(\"Timeout downloading block %s from peer=%d, disconnecting\\n\", queuedBlock.hash.ToString(), pto->GetId());\n                 pto->fDisconnect = true;"
      }
    ]
  },
  {
    "sha": "4e90d2dd0e91e7eb560f2c1b430f13c7a047804f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0ZTkwZDJkZDBlOTFlN2ViNTYwZjJjMWI0MzBmMTNjN2EwNDc4MDRm",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-06-03T11:57:43Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-06-03T11:57:43Z"
      },
      "message": "[net processing] Remove QueuedBlock.hash\n\nIt's redundant with CBlockIndex::GetBlockHash()",
      "tree": {
        "sha": "aaa4d11f53f8fee0cfbd7dfed3ee51d470379bf6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/aaa4d11f53f8fee0cfbd7dfed3ee51d470379bf6"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4e90d2dd0e91e7eb560f2c1b430f13c7a047804f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4e90d2dd0e91e7eb560f2c1b430f13c7a047804f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4e90d2dd0e91e7eb560f2c1b430f13c7a047804f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4e90d2dd0e91e7eb560f2c1b430f13c7a047804f/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "156a19ee6a22789adedcb6ab067c2eca2d3bfdfe",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/156a19ee6a22789adedcb6ab067c2eca2d3bfdfe",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/156a19ee6a22789adedcb6ab067c2eca2d3bfdfe"
      }
    ],
    "stats": {
      "total": 8,
      "additions": 3,
      "deletions": 5
    },
    "files": [
      {
        "sha": "be09bde39f0c71f386be7af378276f132286ad3b",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 5,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4e90d2dd0e91e7eb560f2c1b430f13c7a047804f/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4e90d2dd0e91e7eb560f2c1b430f13c7a047804f/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=4e90d2dd0e91e7eb560f2c1b430f13c7a047804f",
        "patch": "@@ -159,8 +159,6 @@ static constexpr size_t MAX_ADDR_TO_SEND{1000};\n namespace {\n /** Blocks that are in flight, and that are in the queue to be downloaded. */\n struct QueuedBlock {\n-    /** Block hash */\n-    uint256 hash;\n     /** BlockIndex. We must have this since we only request blocks when we've already validated the header. */\n     const CBlockIndex* pindex;\n     /** Optional, used for CMPCTBLOCK downloads */\n@@ -803,7 +801,7 @@ bool PeerManagerImpl::MarkBlockAsInFlight(NodeId nodeid, const CBlockIndex* pind\n     MarkBlockAsReceived(hash);\n \n     std::list<QueuedBlock>::iterator it = state->vBlocksInFlight.insert(state->vBlocksInFlight.end(),\n-            {hash, pindex, std::unique_ptr<PartiallyDownloadedBlock>(pit ? new PartiallyDownloadedBlock(&m_mempool) : nullptr)});\n+            {pindex, std::unique_ptr<PartiallyDownloadedBlock>(pit ? new PartiallyDownloadedBlock(&m_mempool) : nullptr)});\n     state->nBlocksInFlight++;\n     if (state->nBlocksInFlight == 1) {\n         // We're starting a block download (batch) from this peer.\n@@ -1129,7 +1127,7 @@ void PeerManagerImpl::FinalizeNode(const CNode& node)\n         nSyncStarted--;\n \n     for (const QueuedBlock& entry : state->vBlocksInFlight) {\n-        mapBlocksInFlight.erase(entry.hash);\n+        mapBlocksInFlight.erase(entry.pindex->GetBlockHash());\n     }\n     WITH_LOCK(g_cs_orphans, m_orphanage.EraseForPeer(nodeid));\n     m_txrequest.DisconnectedPeer(nodeid);\n@@ -4714,7 +4712,7 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n             QueuedBlock &queuedBlock = state.vBlocksInFlight.front();\n             int nOtherPeersWithValidatedDownloads = m_peers_downloading_from - 1;\n             if (current_time > state.m_downloading_since + std::chrono::seconds{consensusParams.nPowTargetSpacing} * (BLOCK_DOWNLOAD_TIMEOUT_BASE + BLOCK_DOWNLOAD_TIMEOUT_PER_PEER * nOtherPeersWithValidatedDownloads)) {\n-                LogPrintf(\"Timeout downloading block %s from peer=%d, disconnecting\\n\", queuedBlock.hash.ToString(), pto->GetId());\n+                LogPrintf(\"Timeout downloading block %s from peer=%d, disconnecting\\n\", queuedBlock.pindex->GetBlockHash().ToString(), pto->GetId());\n                 pto->fDisconnect = true;\n                 return true;\n             }"
      }
    ]
  },
  {
    "sha": "62993507336be06490b202b3955d4830a99e9e34",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2Mjk5MzUwNzMzNmJlMDY0OTBiMjAyYjM5NTVkNDgzMGE5OWU5ZTM0",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-06-03T12:11:22Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-06-03T13:57:26Z"
      },
      "message": "[net processing] Add IsBlockRequested() function\n\nMarkBlockAsReceived() should not be used for both removing the block\nfrom mapBlocksInFlight and checking whether it was in the map.",
      "tree": {
        "sha": "c49e847e8f10aac87051b269098ad89fda60b9dc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c49e847e8f10aac87051b269098ad89fda60b9dc"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/62993507336be06490b202b3955d4830a99e9e34",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/62993507336be06490b202b3955d4830a99e9e34",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/62993507336be06490b202b3955d4830a99e9e34",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/62993507336be06490b202b3955d4830a99e9e34/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4e90d2dd0e91e7eb560f2c1b430f13c7a047804f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4e90d2dd0e91e7eb560f2c1b430f13c7a047804f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4e90d2dd0e91e7eb560f2c1b430f13c7a047804f"
      }
    ],
    "stats": {
      "total": 32,
      "additions": 20,
      "deletions": 12
    },
    "files": [
      {
        "sha": "0cfb91e353f8d3783e592678a430f88d217d7f96",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 12,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/62993507336be06490b202b3955d4830a99e9e34/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/62993507336be06490b202b3955d4830a99e9e34/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=62993507336be06490b202b3955d4830a99e9e34",
        "patch": "@@ -463,10 +463,14 @@ class PeerManagerImpl final : public PeerManager\n     Mutex m_recent_confirmed_transactions_mutex;\n     std::unique_ptr<CRollingBloomFilter> m_recent_confirmed_transactions GUARDED_BY(m_recent_confirmed_transactions_mutex);\n \n-    /* Returns a bool indicating whether we requested this block.\n-     * Also used if a block was /not/ received and timed out or started with another peer\n+    /** Have we requested this block from a peer */\n+    bool IsBlockRequested(const uint256& hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+\n+    /** Remove this block from our tracked requested blocks. Called if:\n+     *  - the block has been recieved from a peer\n+     *  - the request for the block has timed out\n      */\n-    bool MarkBlockAsReceived(const uint256& hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    void MarkBlockAsReceived(const uint256& hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n     /* Mark a block as in flight\n      * Returns false, still setting pit, if the block was already in flight from the same peer\n@@ -757,7 +761,12 @@ static void UpdatePreferredDownload(const CNode& node, CNodeState* state) EXCLUS\n     nPreferredDownload += state->fPreferredDownload;\n }\n \n-bool PeerManagerImpl::MarkBlockAsReceived(const uint256& hash)\n+bool PeerManagerImpl::IsBlockRequested(const uint256& hash)\n+{\n+    return mapBlocksInFlight.find(hash) != mapBlocksInFlight.end();\n+}\n+\n+void PeerManagerImpl::MarkBlockAsReceived(const uint256& hash)\n {\n     std::map<uint256, std::pair<NodeId, std::list<QueuedBlock>::iterator> >::iterator itInFlight = mapBlocksInFlight.find(hash);\n     if (itInFlight != mapBlocksInFlight.end()) {\n@@ -775,9 +784,7 @@ bool PeerManagerImpl::MarkBlockAsReceived(const uint256& hash)\n         }\n         state->m_stalling_since = 0us;\n         mapBlocksInFlight.erase(itInFlight);\n-        return true;\n     }\n-    return false;\n }\n \n bool PeerManagerImpl::MarkBlockAsInFlight(NodeId nodeid, const CBlockIndex* pindex, std::list<QueuedBlock>::iterator** pit)\n@@ -976,7 +983,7 @@ void PeerManagerImpl::FindNextBlocksToDownload(NodeId nodeid, unsigned int count\n             if (pindex->nStatus & BLOCK_HAVE_DATA || m_chainman.ActiveChain().Contains(pindex)) {\n                 if (pindex->HaveTxsDownloaded())\n                     state->pindexLastCommonBlock = pindex;\n-            } else if (mapBlocksInFlight.count(pindex->GetBlockHash()) == 0) {\n+            } else if (!IsBlockRequested(pindex->GetBlockHash())) {\n                 // The block is not already downloaded, and not yet in flight.\n                 if (pindex->nHeight > nWindowEnd) {\n                     // We reached the end of the window.\n@@ -2054,7 +2061,7 @@ void PeerManagerImpl::ProcessHeadersMessage(CNode& pfrom, const Peer& peer,\n             // Calculate all the blocks we'd need to switch to pindexLast, up to a limit.\n             while (pindexWalk && !m_chainman.ActiveChain().Contains(pindexWalk) && vToFetch.size() <= MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n                 if (!(pindexWalk->nStatus & BLOCK_HAVE_DATA) &&\n-                        !mapBlocksInFlight.count(pindexWalk->GetBlockHash()) &&\n+                        !IsBlockRequested(pindexWalk->GetBlockHash()) &&\n                         (!IsWitnessEnabled(pindexWalk->pprev, m_chainparams.GetConsensus()) || State(pfrom.GetId())->fHaveWitness)) {\n                     // We don't have this block, and it's not yet in flight.\n                     vToFetch.push_back(pindexWalk);\n@@ -2825,7 +2832,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                 LogPrint(BCLog::NET, \"got inv: %s  %s peer=%d\\n\", inv.ToString(), fAlreadyHave ? \"have\" : \"new\", pfrom.GetId());\n \n                 UpdateBlockAvailability(pfrom.GetId(), inv.hash);\n-                if (!fAlreadyHave && !fImporting && !fReindex && !mapBlocksInFlight.count(inv.hash)) {\n+                if (!fAlreadyHave && !fImporting && !fReindex && !IsBlockRequested(inv.hash)) {\n                     // Headers-first is the primary method of announcement on\n                     // the network. If a node fell back to sending blocks by inv,\n                     // it's probably for a re-org. The final block hash\n@@ -3613,9 +3620,10 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         const uint256 hash(pblock->GetHash());\n         {\n             LOCK(cs_main);\n-            // Also always process if we requested the block explicitly, as we may\n-            // need it even though it is not a candidate for a new best tip.\n-            forceProcessing |= MarkBlockAsReceived(hash);\n+            // Always process the block if we requested it, since we may\n+            // need it even when it's not a candidate for a new best tip.\n+            forceProcessing = IsBlockRequested(hash);\n+            MarkBlockAsReceived(hash);\n             // mapBlockSource is only used for punishing peers and setting\n             // which peers send us compact blocks, so the race between here and\n             // cs_main in ProcessNewBlock is fine."
      }
    ]
  },
  {
    "sha": "2c45f832e87acd11fbd144cc0bb8e49816933c70",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyYzQ1ZjgzMmU4N2FjZDExZmJkMTQ0Y2MwYmI4ZTQ5ODE2OTMzYzcw",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-06-03T12:55:31Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-06-03T13:57:37Z"
      },
      "message": "[net processing] Tidy up MarkBlockAsReceived()",
      "tree": {
        "sha": "9051ef2803bea2418df97339d8910053ac018750",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9051ef2803bea2418df97339d8910053ac018750"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2c45f832e87acd11fbd144cc0bb8e49816933c70",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2c45f832e87acd11fbd144cc0bb8e49816933c70",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2c45f832e87acd11fbd144cc0bb8e49816933c70",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2c45f832e87acd11fbd144cc0bb8e49816933c70/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "62993507336be06490b202b3955d4830a99e9e34",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/62993507336be06490b202b3955d4830a99e9e34",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/62993507336be06490b202b3955d4830a99e9e34"
      }
    ],
    "stats": {
      "total": 38,
      "additions": 22,
      "deletions": 16
    },
    "files": [
      {
        "sha": "b016bab7105809ce4a052472a1fbd2423a774145",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 22,
        "deletions": 16,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2c45f832e87acd11fbd144cc0bb8e49816933c70/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2c45f832e87acd11fbd144cc0bb8e49816933c70/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=2c45f832e87acd11fbd144cc0bb8e49816933c70",
        "patch": "@@ -768,23 +768,29 @@ bool PeerManagerImpl::IsBlockRequested(const uint256& hash)\n \n void PeerManagerImpl::MarkBlockAsReceived(const uint256& hash)\n {\n-    std::map<uint256, std::pair<NodeId, std::list<QueuedBlock>::iterator> >::iterator itInFlight = mapBlocksInFlight.find(hash);\n-    if (itInFlight != mapBlocksInFlight.end()) {\n-        CNodeState *state = State(itInFlight->second.first);\n-        assert(state != nullptr);\n-        if (state->vBlocksInFlight.begin() == itInFlight->second.second) {\n-            // First block on the queue was received, update the start download time for the next one\n-            state->m_downloading_since = std::max(state->m_downloading_since, GetTime<std::chrono::microseconds>());\n-        }\n-        state->vBlocksInFlight.erase(itInFlight->second.second);\n-        state->nBlocksInFlight--;\n-        if (state->nBlocksInFlight == 0) {\n-            // Last validated block on the queue was received.\n-            m_peers_downloading_from--;\n-        }\n-        state->m_stalling_since = 0us;\n-        mapBlocksInFlight.erase(itInFlight);\n+    auto it = mapBlocksInFlight.find(hash);\n+    if (it == mapBlocksInFlight.end()) {\n+        // Block was not requested\n+        return;\n+    }\n+\n+    auto [node_id, list_it] = it->second;\n+    CNodeState *state = State(node_id);\n+    assert(state != nullptr);\n+\n+    if (state->vBlocksInFlight.begin() == list_it) {\n+        // First block on the queue was received, update the start download time for the next one\n+        state->m_downloading_since = std::max(state->m_downloading_since, GetTime<std::chrono::microseconds>());\n+    }\n+    state->vBlocksInFlight.erase(list_it);\n+\n+    state->nBlocksInFlight--;\n+    if (state->nBlocksInFlight == 0) {\n+        // Last validated block on the queue was received.\n+        m_peers_downloading_from--;\n     }\n+    state->m_stalling_since = 0us;\n+    mapBlocksInFlight.erase(it);\n }\n \n bool PeerManagerImpl::MarkBlockAsInFlight(NodeId nodeid, const CBlockIndex* pindex, std::list<QueuedBlock>::iterator** pit)"
      }
    ]
  },
  {
    "sha": "2f4ad6b7efa408b8a858e87499bf6cfcdf936d73",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyZjRhZDZiN2VmYTQwOGI4YTg1OGU4NzQ5OWJmNmNmY2RmOTM2ZDcz",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-06-03T11:49:27Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-06-03T13:57:37Z"
      },
      "message": "scripted-diff: rename MarkBlockAs functions\n\n-BEGIN VERIFY SCRIPT-\nren() { sed -i \"s:\\<$1\\>:$2:g\" $(git grep -l \"\\<$1\\>\" ./src ./test); }\n\nren  MarkBlockAsInFlight BlockRequested\nren  MarkBlockAsReceived RemoveBlockRequest\n-END VERIFY SCRIPT-",
      "tree": {
        "sha": "e8263af5886d26baca11c220b6308baf0e9ef6d2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e8263af5886d26baca11c220b6308baf0e9ef6d2"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2f4ad6b7efa408b8a858e87499bf6cfcdf936d73",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2f4ad6b7efa408b8a858e87499bf6cfcdf936d73",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2f4ad6b7efa408b8a858e87499bf6cfcdf936d73",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2f4ad6b7efa408b8a858e87499bf6cfcdf936d73/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2c45f832e87acd11fbd144cc0bb8e49816933c70",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2c45f832e87acd11fbd144cc0bb8e49816933c70",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2c45f832e87acd11fbd144cc0bb8e49816933c70"
      }
    ],
    "stats": {
      "total": 26,
      "additions": 13,
      "deletions": 13
    },
    "files": [
      {
        "sha": "c5a389f228abf83b338fa1c73ca3b3bf2d7e580e",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 13,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2f4ad6b7efa408b8a858e87499bf6cfcdf936d73/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2f4ad6b7efa408b8a858e87499bf6cfcdf936d73/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=2f4ad6b7efa408b8a858e87499bf6cfcdf936d73",
        "patch": "@@ -470,13 +470,13 @@ class PeerManagerImpl final : public PeerManager\n      *  - the block has been recieved from a peer\n      *  - the request for the block has timed out\n      */\n-    void MarkBlockAsReceived(const uint256& hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    void RemoveBlockRequest(const uint256& hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n     /* Mark a block as in flight\n      * Returns false, still setting pit, if the block was already in flight from the same peer\n      * pit will only be valid as long as the same cs_main lock is being held\n      */\n-    bool MarkBlockAsInFlight(NodeId nodeid, const CBlockIndex* pindex, std::list<QueuedBlock>::iterator** pit = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    bool BlockRequested(NodeId nodeid, const CBlockIndex* pindex, std::list<QueuedBlock>::iterator** pit = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n     bool TipMayBeStale() EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n@@ -766,7 +766,7 @@ bool PeerManagerImpl::IsBlockRequested(const uint256& hash)\n     return mapBlocksInFlight.find(hash) != mapBlocksInFlight.end();\n }\n \n-void PeerManagerImpl::MarkBlockAsReceived(const uint256& hash)\n+void PeerManagerImpl::RemoveBlockRequest(const uint256& hash)\n {\n     auto it = mapBlocksInFlight.find(hash);\n     if (it == mapBlocksInFlight.end()) {\n@@ -793,7 +793,7 @@ void PeerManagerImpl::MarkBlockAsReceived(const uint256& hash)\n     mapBlocksInFlight.erase(it);\n }\n \n-bool PeerManagerImpl::MarkBlockAsInFlight(NodeId nodeid, const CBlockIndex* pindex, std::list<QueuedBlock>::iterator** pit)\n+bool PeerManagerImpl::BlockRequested(NodeId nodeid, const CBlockIndex* pindex, std::list<QueuedBlock>::iterator** pit)\n {\n     assert(pindex);\n     const uint256& hash{pindex->GetBlockHash()};\n@@ -811,7 +811,7 @@ bool PeerManagerImpl::MarkBlockAsInFlight(NodeId nodeid, const CBlockIndex* pind\n     }\n \n     // Make sure it's not listed somewhere already.\n-    MarkBlockAsReceived(hash);\n+    RemoveBlockRequest(hash);\n \n     std::list<QueuedBlock>::iterator it = state->vBlocksInFlight.insert(state->vBlocksInFlight.end(),\n             {pindex, std::unique_ptr<PartiallyDownloadedBlock>(pit ? new PartiallyDownloadedBlock(&m_mempool) : nullptr)});\n@@ -2092,7 +2092,7 @@ void PeerManagerImpl::ProcessHeadersMessage(CNode& pfrom, const Peer& peer,\n                     }\n                     uint32_t nFetchFlags = GetFetchFlags(pfrom);\n                     vGetData.push_back(CInv(MSG_BLOCK | nFetchFlags, pindex->GetBlockHash()));\n-                    MarkBlockAsInFlight(pfrom.GetId(), pindex);\n+                    BlockRequested(pfrom.GetId(), pindex);\n                     LogPrint(BCLog::NET, \"Requesting block %s from  peer=%d\\n\",\n                             pindex->GetBlockHash().ToString(), pfrom.GetId());\n                 }\n@@ -3395,7 +3395,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             if ((!fAlreadyInFlight && nodestate->nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) ||\n                  (fAlreadyInFlight && blockInFlightIt->second.first == pfrom.GetId())) {\n                 std::list<QueuedBlock>::iterator* queuedBlockIt = nullptr;\n-                if (!MarkBlockAsInFlight(pfrom.GetId(), pindex, &queuedBlockIt)) {\n+                if (!BlockRequested(pfrom.GetId(), pindex, &queuedBlockIt)) {\n                     if (!(*queuedBlockIt)->partialBlock)\n                         (*queuedBlockIt)->partialBlock.reset(new PartiallyDownloadedBlock(&m_mempool));\n                     else {\n@@ -3408,7 +3408,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                 PartiallyDownloadedBlock& partialBlock = *(*queuedBlockIt)->partialBlock;\n                 ReadStatus status = partialBlock.InitData(cmpctblock, vExtraTxnForCompact);\n                 if (status == READ_STATUS_INVALID) {\n-                    MarkBlockAsReceived(pindex->GetBlockHash()); // Reset in-flight state in case Misbehaving does not result in a disconnect\n+                    RemoveBlockRequest(pindex->GetBlockHash()); // Reset in-flight state in case Misbehaving does not result in a disconnect\n                     Misbehaving(pfrom.GetId(), 100, \"invalid compact block\");\n                     return;\n                 } else if (status == READ_STATUS_FAILED) {\n@@ -3503,7 +3503,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                 // process from some other peer.  We do this after calling\n                 // ProcessNewBlock so that a malleated cmpctblock announcement\n                 // can't be used to interfere with block relay.\n-                MarkBlockAsReceived(pblock->GetHash());\n+                RemoveBlockRequest(pblock->GetHash());\n             }\n         }\n         return;\n@@ -3535,7 +3535,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             PartiallyDownloadedBlock& partialBlock = *it->second.second->partialBlock;\n             ReadStatus status = partialBlock.FillBlock(*pblock, resp.txn);\n             if (status == READ_STATUS_INVALID) {\n-                MarkBlockAsReceived(resp.blockhash); // Reset in-flight state in case Misbehaving does not result in a disconnect\n+                RemoveBlockRequest(resp.blockhash); // Reset in-flight state in case Misbehaving does not result in a disconnect\n                 Misbehaving(pfrom.GetId(), 100, \"invalid compact block/non-matching block transactions\");\n                 return;\n             } else if (status == READ_STATUS_FAILED) {\n@@ -3561,7 +3561,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                 // though the block was successfully read, and rely on the\n                 // handling in ProcessNewBlock to ensure the block index is\n                 // updated, etc.\n-                MarkBlockAsReceived(resp.blockhash); // it is now an empty pointer\n+                RemoveBlockRequest(resp.blockhash); // it is now an empty pointer\n                 fBlockRead = true;\n                 // mapBlockSource is used for potentially punishing peers and\n                 // updating which peers send us compact blocks, so the race\n@@ -3629,7 +3629,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             // Always process the block if we requested it, since we may\n             // need it even when it's not a candidate for a new best tip.\n             forceProcessing = IsBlockRequested(hash);\n-            MarkBlockAsReceived(hash);\n+            RemoveBlockRequest(hash);\n             // mapBlockSource is only used for punishing peers and setting\n             // which peers send us compact blocks, so the race between here and\n             // cs_main in ProcessNewBlock is fine.\n@@ -4779,7 +4779,7 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n             for (const CBlockIndex *pindex : vToDownload) {\n                 uint32_t nFetchFlags = GetFetchFlags(*pto);\n                 vGetData.push_back(CInv(MSG_BLOCK | nFetchFlags, pindex->GetBlockHash()));\n-                MarkBlockAsInFlight(pto->GetId(), pindex);\n+                BlockRequested(pto->GetId(), pindex);\n                 LogPrint(BCLog::NET, \"Requesting block %s (%d) peer=%d\\n\", pindex->GetBlockHash().ToString(),\n                     pindex->nHeight, pto->GetId());\n             }"
      }
    ]
  }
]