[
  {
    "sha": "5de2b18c67a987451502b9e08c257e2f472aae34",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1ZGUyYjE4YzY3YTk4NzQ1MTUwMmI5ZTA4YzI1N2UyZjQ3MmFhZTM0",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-03-28T17:37:45Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-03-28T19:46:54Z"
      },
      "message": "[contrib] fixup security-check.py Python3 support",
      "tree": {
        "sha": "df95d2c400ad2559181c3caec906e93853839905",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/df95d2c400ad2559181c3caec906e93853839905"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5de2b18c67a987451502b9e08c257e2f472aae34",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5de2b18c67a987451502b9e08c257e2f472aae34",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5de2b18c67a987451502b9e08c257e2f472aae34",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5de2b18c67a987451502b9e08c257e2f472aae34/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "624bee96597c1d59018e58131b8285c0b332700d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/624bee96597c1d59018e58131b8285c0b332700d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/624bee96597c1d59018e58131b8285c0b332700d"
      }
    ],
    "stats": {
      "total": 44,
      "additions": 22,
      "deletions": 22
    },
    "files": [
      {
        "sha": "0f2099953f8ad47cb95eb8c066ae4d169ed82bd6",
        "filename": "contrib/devtools/security-check.py",
        "status": "modified",
        "additions": 22,
        "deletions": 22,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5de2b18c67a987451502b9e08c257e2f472aae34/contrib/devtools/security-check.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5de2b18c67a987451502b9e08c257e2f472aae34/contrib/devtools/security-check.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/security-check.py?ref=5de2b18c67a987451502b9e08c257e2f472aae34",
        "patch": "@@ -20,38 +20,38 @@ def check_ELF_PIE(executable):\n     '''\n     Check for position independent executable (PIE), allowing for address space randomization.\n     '''\n-    p = subprocess.Popen([READELF_CMD, '-h', '-W', executable], stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)\n+    p = subprocess.Popen([READELF_CMD, '-h', '-W', executable], stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE, universal_newlines=True)\n     (stdout, stderr) = p.communicate()\n     if p.returncode:\n         raise IOError('Error opening file')\n \n     ok = False\n-    for line in stdout.split(b'\\n'):\n+    for line in stdout.splitlines():\n         line = line.split()\n-        if len(line)>=2 and line[0] == b'Type:' and line[1] == b'DYN':\n+        if len(line)>=2 and line[0] == 'Type:' and line[1] == 'DYN':\n             ok = True\n     return ok\n \n def get_ELF_program_headers(executable):\n     '''Return type and flags for ELF program headers'''\n-    p = subprocess.Popen([READELF_CMD, '-l', '-W', executable], stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)\n+    p = subprocess.Popen([READELF_CMD, '-l', '-W', executable], stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE, universal_newlines=True)\n     (stdout, stderr) = p.communicate()\n     if p.returncode:\n         raise IOError('Error opening file')\n     in_headers = False\n     count = 0\n     headers = []\n-    for line in stdout.split(b'\\n'):\n-        if line.startswith(b'Program Headers:'):\n+    for line in stdout.splitlines():\n+        if line.startswith('Program Headers:'):\n             in_headers = True\n-        if line == b'':\n+        if line == '':\n             in_headers = False\n         if in_headers:\n             if count == 1: # header line\n-                ofs_typ = line.find(b'Type')\n-                ofs_offset = line.find(b'Offset')\n-                ofs_flags = line.find(b'Flg')\n-                ofs_align = line.find(b'Align')\n+                ofs_typ = line.find('Type')\n+                ofs_offset = line.find('Offset')\n+                ofs_flags = line.find('Flg')\n+                ofs_align = line.find('Align')\n                 if ofs_typ == -1 or ofs_offset == -1 or ofs_flags == -1 or ofs_align  == -1:\n                     raise ValueError('Cannot parse elfread -lW output')\n             elif count > 1:\n@@ -68,9 +68,9 @@ def check_ELF_NX(executable):\n     have_wx = False\n     have_gnu_stack = False\n     for (typ, flags) in get_ELF_program_headers(executable):\n-        if typ == b'GNU_STACK':\n+        if typ == 'GNU_STACK':\n             have_gnu_stack = True\n-        if b'W' in flags and b'E' in flags: # section is both writable and executable\n+        if 'W' in flags and 'E' in flags: # section is both writable and executable\n             have_wx = True\n     return have_gnu_stack and not have_wx\n \n@@ -87,31 +87,31 @@ def check_ELF_RELRO(executable):\n         # However, the dynamic linker need to write to this area so these are RW.\n         # Glibc itself takes care of mprotecting this area R after relocations are finished.\n         # See also http://permalink.gmane.org/gmane.comp.gnu.binutils/71347\n-        if typ == b'GNU_RELRO':\n+        if typ == 'GNU_RELRO':\n             have_gnu_relro = True\n \n     have_bindnow = False\n-    p = subprocess.Popen([READELF_CMD, '-d', '-W', executable], stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)\n+    p = subprocess.Popen([READELF_CMD, '-d', '-W', executable], stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE, universal_newlines=True)\n     (stdout, stderr) = p.communicate()\n     if p.returncode:\n         raise IOError('Error opening file')\n-    for line in stdout.split(b'\\n'):\n+    for line in stdout.splitlines():\n         tokens = line.split()\n-        if len(tokens)>1 and tokens[1] == b'(BIND_NOW)' or (len(tokens)>2 and tokens[1] == b'(FLAGS)' and b'BIND_NOW' in tokens[2]):\n+        if len(tokens)>1 and tokens[1] == '(BIND_NOW)' or (len(tokens)>2 and tokens[1] == '(FLAGS)' and 'BIND_NOW' in tokens[2]):\n             have_bindnow = True\n     return have_gnu_relro and have_bindnow\n \n def check_ELF_Canary(executable):\n     '''\n     Check for use of stack canary\n     '''\n-    p = subprocess.Popen([READELF_CMD, '--dyn-syms', '-W', executable], stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)\n+    p = subprocess.Popen([READELF_CMD, '--dyn-syms', '-W', executable], stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE, universal_newlines=True)\n     (stdout, stderr) = p.communicate()\n     if p.returncode:\n         raise IOError('Error opening file')\n     ok = False\n-    for line in stdout.split(b'\\n'):\n-        if b'__stack_chk_fail' in line:\n+    for line in stdout.splitlines():\n+        if '__stack_chk_fail' in line:\n             ok = True\n     return ok\n \n@@ -121,13 +121,13 @@ def get_PE_dll_characteristics(executable):\n     Returns a tuple (arch,bits) where arch is 'i386:x86-64' or 'i386'\n     and bits is the DllCharacteristics value.\n     '''\n-    p = subprocess.Popen([OBJDUMP_CMD, '-x',  executable], stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)\n+    p = subprocess.Popen([OBJDUMP_CMD, '-x',  executable], stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE, universal_newlines=True)\n     (stdout, stderr) = p.communicate()\n     if p.returncode:\n         raise IOError('Error opening file')\n     arch = ''\n     bits = 0\n-    for line in stdout.split('\\n'):\n+    for line in stdout.splitlines():\n         tokens = line.split()\n         if len(tokens)>=2 and tokens[0] == 'architecture:':\n             arch = tokens[1].rstrip(',')"
      }
    ]
  },
  {
    "sha": "f50975b13667c002ebad871b140bcea4f09d0742",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmNTA5NzViMTM2NjdjMDAyZWJhZDg3MWIxNDBiY2VhNGYwOWQwNzQy",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-03-28T20:58:42Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2018-03-28T20:58:42Z"
      },
      "message": "[contrib] fixup symbol-check.py Python3 support",
      "tree": {
        "sha": "91b45f949e6f4b75d48577b5a1e7d85a63da9ade",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/91b45f949e6f4b75d48577b5a1e7d85a63da9ade"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f50975b13667c002ebad871b140bcea4f09d0742",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f50975b13667c002ebad871b140bcea4f09d0742",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f50975b13667c002ebad871b140bcea4f09d0742",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f50975b13667c002ebad871b140bcea4f09d0742/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5de2b18c67a987451502b9e08c257e2f472aae34",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5de2b18c67a987451502b9e08c257e2f472aae34",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5de2b18c67a987451502b9e08c257e2f472aae34"
      }
    ],
    "stats": {
      "total": 66,
      "additions": 33,
      "deletions": 33
    },
    "files": [
      {
        "sha": "3a67319eaa81783ad3afdd65650e899b39a5781c",
        "filename": "contrib/devtools/symbol-check.py",
        "status": "modified",
        "additions": 33,
        "deletions": 33,
        "changes": 66,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f50975b13667c002ebad871b140bcea4f09d0742/contrib/devtools/symbol-check.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f50975b13667c002ebad871b140bcea4f09d0742/contrib/devtools/symbol-check.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/symbol-check.py?ref=f50975b13667c002ebad871b140bcea4f09d0742",
        "patch": "@@ -46,28 +46,28 @@\n \n # Ignore symbols that are exported as part of every executable\n IGNORE_EXPORTS = {\n-b'_edata', b'_end', b'_init', b'__bss_start', b'_fini', b'_IO_stdin_used'\n+'_edata', '_end', '_init', '__bss_start', '_fini', '_IO_stdin_used'\n }\n READELF_CMD = os.getenv('READELF', '/usr/bin/readelf')\n CPPFILT_CMD = os.getenv('CPPFILT', '/usr/bin/c++filt')\n # Allowed NEEDED libraries\n ALLOWED_LIBRARIES = {\n # bitcoind and bitcoin-qt\n-b'libgcc_s.so.1', # GCC base support\n-b'libc.so.6', # C library\n-b'libpthread.so.0', # threading\n-b'libanl.so.1', # DNS resolve\n-b'libm.so.6', # math library\n-b'librt.so.1', # real-time (clock)\n-b'ld-linux-x86-64.so.2', # 64-bit dynamic linker\n-b'ld-linux.so.2', # 32-bit dynamic linker\n+'libgcc_s.so.1', # GCC base support\n+'libc.so.6', # C library\n+'libpthread.so.0', # threading\n+'libanl.so.1', # DNS resolve\n+'libm.so.6', # math library\n+'librt.so.1', # real-time (clock)\n+'ld-linux-x86-64.so.2', # 64-bit dynamic linker\n+'ld-linux.so.2', # 32-bit dynamic linker\n # bitcoin-qt only\n-b'libX11-xcb.so.1', # part of X11\n-b'libX11.so.6', # part of X11\n-b'libxcb.so.1', # part of X11\n-b'libfontconfig.so.1', # font support\n-b'libfreetype.so.6', # font parsing\n-b'libdl.so.2' # programming interface to dynamic linker\n+'libX11-xcb.so.1', # part of X11\n+'libX11.so.6', # part of X11\n+'libxcb.so.1', # part of X11\n+'libfontconfig.so.1', # font support\n+'libfreetype.so.6', # font parsing\n+'libdl.so.2' # programming interface to dynamic linker\n }\n \n class CPPFilt(object):\n@@ -77,10 +77,10 @@ class CPPFilt(object):\n     Use a pipe to the 'c++filt' command.\n     '''\n     def __init__(self):\n-        self.proc = subprocess.Popen(CPPFILT_CMD, stdin=subprocess.PIPE, stdout=subprocess.PIPE)\n+        self.proc = subprocess.Popen(CPPFILT_CMD, stdin=subprocess.PIPE, stdout=subprocess.PIPE, universal_newlines=True)\n \n     def __call__(self, mangled):\n-        self.proc.stdin.write(mangled + b'\\n')\n+        self.proc.stdin.write(mangled + '\\n')\n         self.proc.stdin.flush()\n         return self.proc.stdout.readline().rstrip()\n \n@@ -94,43 +94,43 @@ def read_symbols(executable, imports=True):\n     Parse an ELF executable and return a list of (symbol,version) tuples\n     for dynamic, imported symbols.\n     '''\n-    p = subprocess.Popen([READELF_CMD, '--dyn-syms', '-W', executable], stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)\n+    p = subprocess.Popen([READELF_CMD, '--dyn-syms', '-W', executable], stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE, universal_newlines=True)\n     (stdout, stderr) = p.communicate()\n     if p.returncode:\n         raise IOError('Could not read symbols for %s: %s' % (executable, stderr.strip()))\n     syms = []\n-    for line in stdout.split(b'\\n'):\n+    for line in stdout.splitlines():\n         line = line.split()\n-        if len(line)>7 and re.match(b'[0-9]+:$', line[0]):\n-            (sym, _, version) = line[7].partition(b'@')\n-            is_import = line[6] == b'UND'\n-            if version.startswith(b'@'):\n+        if len(line)>7 and re.match('[0-9]+:$', line[0]):\n+            (sym, _, version) = line[7].partition('@')\n+            is_import = line[6] == 'UND'\n+            if version.startswith('@'):\n                 version = version[1:]\n             if is_import == imports:\n                 syms.append((sym, version))\n     return syms\n \n def check_version(max_versions, version):\n-    if b'_' in version:\n-        (lib, _, ver) = version.rpartition(b'_')\n+    if '_' in version:\n+        (lib, _, ver) = version.rpartition('_')\n     else:\n         lib = version\n         ver = '0'\n-    ver = tuple([int(x) for x in ver.split(b'.')])\n+    ver = tuple([int(x) for x in ver.split('.')])\n     if not lib in max_versions:\n         return False\n     return ver <= max_versions[lib]\n \n def read_libraries(filename):\n-    p = subprocess.Popen([READELF_CMD, '-d', '-W', filename], stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)\n+    p = subprocess.Popen([READELF_CMD, '-d', '-W', filename], stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE, universal_newlines=True)\n     (stdout, stderr) = p.communicate()\n     if p.returncode:\n         raise IOError('Error opening file')\n     libraries = []\n-    for line in stdout.split(b'\\n'):\n+    for line in stdout.splitlines():\n         tokens = line.split()\n-        if len(tokens)>2 and tokens[1] == b'(NEEDED)':\n-            match = re.match(b'^Shared library: \\[(.*)\\]$', b' '.join(tokens[2:]))\n+        if len(tokens)>2 and tokens[1] == '(NEEDED)':\n+            match = re.match('^Shared library: \\[(.*)\\]$', ' '.join(tokens[2:]))\n             if match:\n                 libraries.append(match.group(1))\n             else:\n@@ -144,18 +144,18 @@ def read_libraries(filename):\n         # Check imported symbols\n         for sym,version in read_symbols(filename, True):\n             if version and not check_version(MAX_VERSIONS, version):\n-                print('%s: symbol %s from unsupported version %s' % (filename, cppfilt(sym).decode('utf-8'), version.decode('utf-8')))\n+                print('%s: symbol %s from unsupported version %s' % (filename, cppfilt(sym), version))\n                 retval = 1\n         # Check exported symbols\n         for sym,version in read_symbols(filename, False):\n             if sym in IGNORE_EXPORTS:\n                 continue\n-            print('%s: export of symbol %s not allowed' % (filename, cppfilt(sym).decode('utf-8')))\n+            print('%s: export of symbol %s not allowed' % (filename, cppfilt(sym)))\n             retval = 1\n         # Check dependency libraries\n         for library_name in read_libraries(filename):\n             if library_name not in ALLOWED_LIBRARIES:\n-                print('%s: NEEDED library %s is not allowed' % (filename, library_name.decode('utf-8')))\n+                print('%s: NEEDED library %s is not allowed' % (filename, library_name))\n                 retval = 1\n \n     sys.exit(retval)"
      }
    ]
  }
]