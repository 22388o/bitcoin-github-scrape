[
  {
    "sha": "76e96e19f21e4eb63c9fc00e43f60a322d1e9344",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3NmU5NmUxOWYyMWU0ZWI2M2M5ZmMwMGU0M2Y2MGEzMjJkMWU5MzQ0",
    "commit": {
      "author": {
        "name": "Cozz Lovan",
        "email": "cozzlovan@yahoo.com",
        "date": "2014-10-05T20:30:01Z"
      },
      "committer": {
        "name": "Cozz Lovan",
        "email": "cozzlovan@yahoo.com",
        "date": "2015-05-18T11:22:27Z"
      },
      "message": "txoutsbyaddress index",
      "tree": {
        "sha": "dcfd8a38e846013f2fe1b7a5c56ba2f89fb4da22",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/dcfd8a38e846013f2fe1b7a5c56ba2f89fb4da22"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/76e96e19f21e4eb63c9fc00e43f60a322d1e9344",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/76e96e19f21e4eb63c9fc00e43f60a322d1e9344",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/76e96e19f21e4eb63c9fc00e43f60a322d1e9344",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/76e96e19f21e4eb63c9fc00e43f60a322d1e9344/comments",
    "author": {
      "login": "cozz",
      "id": 2814559,
      "node_id": "MDQ6VXNlcjI4MTQ1NTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2814559?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cozz",
      "html_url": "https://github.com/cozz",
      "followers_url": "https://api.github.com/users/cozz/followers",
      "following_url": "https://api.github.com/users/cozz/following{/other_user}",
      "gists_url": "https://api.github.com/users/cozz/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cozz/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cozz/subscriptions",
      "organizations_url": "https://api.github.com/users/cozz/orgs",
      "repos_url": "https://api.github.com/users/cozz/repos",
      "events_url": "https://api.github.com/users/cozz/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cozz/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "cozz",
      "id": 2814559,
      "node_id": "MDQ6VXNlcjI4MTQ1NTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2814559?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cozz",
      "html_url": "https://github.com/cozz",
      "followers_url": "https://api.github.com/users/cozz/followers",
      "following_url": "https://api.github.com/users/cozz/following{/other_user}",
      "gists_url": "https://api.github.com/users/cozz/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cozz/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cozz/subscriptions",
      "organizations_url": "https://api.github.com/users/cozz/orgs",
      "repos_url": "https://api.github.com/users/cozz/repos",
      "events_url": "https://api.github.com/users/cozz/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cozz/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "26e08a16a6fb64b535d10f5d459183092deefa50",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/26e08a16a6fb64b535d10f5d459183092deefa50",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/26e08a16a6fb64b535d10f5d459183092deefa50"
      }
    ],
    "stats": {
      "total": 890,
      "additions": 868,
      "deletions": 22
    },
    "files": [
      {
        "sha": "40c21f77413b72d239ccfb481004e9a30aa09274",
        "filename": "qa/rpc-tests/txoutsbyaddress.sh",
        "status": "added",
        "additions": 163,
        "deletions": 0,
        "changes": 163,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/76e96e19f21e4eb63c9fc00e43f60a322d1e9344/qa/rpc-tests/txoutsbyaddress.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/76e96e19f21e4eb63c9fc00e43f60a322d1e9344/qa/rpc-tests/txoutsbyaddress.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/txoutsbyaddress.sh?ref=76e96e19f21e4eb63c9fc00e43f60a322d1e9344",
        "patch": "@@ -0,0 +1,163 @@\n+#!/usr/bin/env bash\n+# Copyright (c) 2013-2014 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+# Test -txoutsbyaddressindex\n+\n+if [ $# -lt 1 ]; then\n+        echo \"Usage: $0 path_to_binaries\"\n+        echo \"e.g. $0 ../../src\"\n+        exit 1\n+fi\n+\n+set -f\n+\n+BITCOIND=${1}/bitcoind\n+CLI=${1}/bitcoin-cli\n+\n+DIR=\"${BASH_SOURCE%/*}\"\n+SENDANDWAIT=\"${DIR}/send.sh\"\n+if [[ ! -d \"$DIR\" ]]; then DIR=\"$PWD\"; fi\n+. \"$DIR/util.sh\"\n+\n+D=$(mktemp -d test.XXXXX)\n+\n+D1=${D}/node1\n+CreateDataDir \"$D1\" port=11000 rpcport=11001\n+B1ARGS=\"-datadir=$D1\"\n+$BITCOIND $B1ARGS -txoutsbyaddressindex -sendfreetransactions=1 &\n+B1PID=$!\n+\n+D2=${D}/node2\n+CreateDataDir \"$D2\" port=11010 rpcport=11011\n+B2ARGS=\"-datadir=$D2\"\n+$BITCOIND $B2ARGS -sendfreetransactions=1 &\n+B2PID=$!\n+\n+D3=${D}/node3\n+CreateDataDir \"$D3\" port=11020 rpcport=11021\n+B3ARGS=\"-datadir=$D3\"\n+$BITCOIND $B3ARGS -sendfreetransactions=1 &\n+B3PID=$!\n+\n+# Wait until all three nodes are at the same block number\n+function WaitBlocks {\n+    while :\n+    do\n+        sleep 1\n+        declare -i BLOCKS1=$( GetBlocks $B1ARGS )\n+        declare -i BLOCKS2=$( GetBlocks $B2ARGS )\n+        declare -i BLOCKS3=$( GetBlocks $B3ARGS )\n+        if (( BLOCKS1 == BLOCKS2 && BLOCKS2 == BLOCKS3 ))\n+        then\n+            break\n+        fi\n+    done\n+}\n+\n+function WaitBlocks2 {\n+    while :\n+    do\n+        sleep 1\n+        declare -i BLOCKS1=$( GetBlocks $B1ARGS )\n+        declare -i BLOCKS2=$( GetBlocks $B2ARGS )\n+        if (( BLOCKS1 == BLOCKS2 ))\n+        then\n+            break\n+        fi\n+    done\n+}\n+\n+function CleanUp {\n+$CLI $B3ARGS stop > /dev/null 2>&1\n+wait $B3PID\n+$CLI $B2ARGS stop > /dev/null 2>&1\n+wait $B2PID\n+$CLI $B1ARGS stop > /dev/null 2>&1\n+wait $B1PID\n+\n+rm -rf $D\n+}\n+\n+function ErrorAndExit {\n+echo \"$@\" 1>&2;\n+CleanUp\n+exit 1\n+}\n+\n+echo \"Generating test blockchain...\"\n+\n+# mining\n+$CLI $B2ARGS addnode \"127.0.0.1:11000\" \"onetry\"\n+$CLI $B3ARGS addnode \"127.0.0.1:11000\" \"onetry\"\n+$CLI $B1ARGS generate 101\n+WaitBlocks\n+CheckBalance \"$B1ARGS\" 50\n+\n+# TX1: send from node1 to node2\n+# - check if txout from tx1 is there\n+address=$($CLI $B2ARGS getnewaddress)\n+txid1=$($CLI $B1ARGS sendtoaddress $address 10)\n+$CLI $B1ARGS generate 1\n+WaitBlocks\n+CheckBalance \"$B1ARGS\" 90\n+CheckBalance \"$B2ARGS\" 10\n+txouts=$($CLI $B1ARGS gettxoutsbyaddress 1 \"[\\\"\"\"$address\"\"\\\"]\")\n+txid=$(ExtractKey \"txid\" \"$txouts\")\n+if [ -z \"$txid\" ] || [ $txid != $txid1 ] ; then\n+   ErrorAndExit \"wrong txid1: $txid != $txid1\"\n+fi\n+\n+# stop node 3\n+$CLI $B3ARGS stop > /dev/null 2>&1\n+wait $B3PID\n+\n+# TX2: send from node2 to node1\n+# - check if txout from tx1 is gone\n+# - check if txout from tx2 is there\n+address2=$($CLI $B1ARGS getnewaddress)\n+txid2=$($CLI $B2ARGS sendtoaddress $address2 5)\n+$CLI $B2ARGS generate 1\n+WaitBlocks2\n+CheckBalance \"$B1ARGS\" 145\n+txouts=$($CLI $B1ARGS gettxoutsbyaddress 1 \"[\\\"\"\"$address\"\"\\\"]\")\n+txid=$(ExtractKey \"txid\" \"$txouts\")\n+if [ ! -z \"$txid\" ] ; then\n+   ErrorAndExit \"txid not empty: $txid\"\n+fi\n+txouts=$($CLI $B1ARGS gettxoutsbyaddress 1 \"[\\\"\"\"$address2\"\"\\\"]\")\n+txid=$(ExtractKey \"txid\" \"$txouts\")\n+if [ -z \"$txid\" ] || [ $txid != $txid2 ] ; then\n+   ErrorAndExit \"wrong txid2: $txid != $txid2\"\n+fi\n+\n+# start node 3\n+$BITCOIND $B3ARGS &\n+B3PID=$!\n+\n+# mine 10 blocks alone to have the longest chain\n+$CLI $B3ARGS generate 10\n+$CLI $B1ARGS addnode \"127.0.0.1:11020\" \"onetry\"\n+$CLI $B2ARGS addnode \"127.0.0.1:11020\" \"onetry\"\n+$CLI $B3ARGS generate 1\n+WaitBlocks\n+\n+# TX2 must be reverted\n+# - check if txout from tx1 is there again\n+# - check if txout from tx2 is gone\n+CheckBalance \"$B1ARGS\" 640\n+txouts=$($CLI $B1ARGS gettxoutsbyaddress 1 \"[\\\"\"\"$address\"\"\\\"]\")\n+txid=$(ExtractKey \"txid\" \"$txouts\")\n+if [ -z \"$txid\" ] || [ $txid != $txid1 ] ; then\n+   ErrorAndExit \"wrong txid1 : $txid != $txid1\"\n+fi\n+txouts=$($CLI $B1ARGS gettxoutsbyaddress 1 \"[\\\"\"\"$address2\"\"\\\"]\")\n+txid=$(ExtractKey \"txid\" \"$txouts\")\n+if [ ! -z \"$txid\" ] ; then\n+   ErrorAndExit \"txid is not empty: $txid\"\n+fi\n+\n+echo \"Tests successful, cleaning up\"\n+CleanUp\n+exit 0"
      },
      {
        "sha": "8f5f2215d9813bf592e523c521ffce807337cc1d",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/76e96e19f21e4eb63c9fc00e43f60a322d1e9344/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/76e96e19f21e4eb63c9fc00e43f60a322d1e9344/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=76e96e19f21e4eb63c9fc00e43f60a322d1e9344",
        "patch": "@@ -85,6 +85,7 @@ BITCOIN_CORE_H = \\\n   clientversion.h \\\n   coincontrol.h \\\n   coins.h \\\n+  coinsbyscript.h \\\n   compat.h \\\n   compat/byteswap.h \\\n   compat/endian.h \\\n@@ -248,6 +249,7 @@ libbitcoin_common_a_SOURCES = \\\n   base58.cpp \\\n   chainparams.cpp \\\n   coins.cpp \\\n+  coinsbyscript.cpp \\\n   compressor.cpp \\\n   core_read.cpp \\\n   core_write.cpp \\"
      },
      {
        "sha": "51cfb59d608fe7fc7a52bbe711867a3d6d0c797a",
        "filename": "src/coins.h",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/76e96e19f21e4eb63c9fc00e43f60a322d1e9344/src/coins.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/76e96e19f21e4eb63c9fc00e43f60a322d1e9344/src/coins.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coins.h?ref=76e96e19f21e4eb63c9fc00e43f60a322d1e9344",
        "patch": "@@ -303,11 +303,13 @@ struct CCoinsStats\n     uint256 hashBlock;\n     uint64_t nTransactions;\n     uint64_t nTransactionOutputs;\n+    uint64_t nAddresses;\n+    uint64_t nAddressesOutputs; // equal nTransactionOutputs (if addressindex is enabled)\n     uint64_t nSerializedSize;\n     uint256 hashSerialized;\n     CAmount nTotalAmount;\n \n-    CCoinsStats() : nHeight(0), nTransactions(0), nTransactionOutputs(0), nSerializedSize(0), nTotalAmount(0) {}\n+    CCoinsStats() : nHeight(0), nTransactions(0), nTransactionOutputs(0), nAddresses(0), nAddressesOutputs(0), nSerializedSize(0), nTotalAmount(0) {}\n };\n \n "
      },
      {
        "sha": "92ad633494d3f2cb01bbc978d4907b0d4588de25",
        "filename": "src/coinsbyscript.cpp",
        "status": "added",
        "additions": 50,
        "deletions": 0,
        "changes": 50,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/76e96e19f21e4eb63c9fc00e43f60a322d1e9344/src/coinsbyscript.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/76e96e19f21e4eb63c9fc00e43f60a322d1e9344/src/coinsbyscript.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coinsbyscript.cpp?ref=76e96e19f21e4eb63c9fc00e43f60a322d1e9344",
        "patch": "@@ -0,0 +1,50 @@\n+// Copyright (c) 2014 The Bitcoin developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"coinsbyscript.h\"\n+#include \"txdb.h\"\n+#include \"hash.h\"\n+\n+#include <assert.h>\n+\n+CCoinsViewByScript::CCoinsViewByScript(CCoinsViewDB* viewIn) : base(viewIn) { }\n+\n+bool CCoinsViewByScript::GetCoinsByScript(const CScript &script, CCoinsByScript &coins) {\n+    const uint160 key = CCoinsViewByScript::getKey(script);\n+    if (cacheCoinsByScript.count(key)) {\n+        coins = cacheCoinsByScript[key];\n+        return true;\n+    }\n+    if (base->GetCoinsByHashOfScript(key, coins)) {\n+        cacheCoinsByScript[key] = coins;\n+        return true;\n+    }\n+    return false;\n+}\n+\n+CCoinsMapByScript::iterator CCoinsViewByScript::FetchCoinsByScript(const CScript &script, bool fRequireExisting) {\n+    const uint160 key = CCoinsViewByScript::getKey(script);\n+    CCoinsMapByScript::iterator it = cacheCoinsByScript.find(key);\n+    if (it != cacheCoinsByScript.end())\n+        return it;\n+    CCoinsByScript tmp;\n+    if (!base->GetCoinsByHashOfScript(key, tmp))\n+    {\n+        if (fRequireExisting)\n+            return cacheCoinsByScript.end();\n+    }\n+    CCoinsMapByScript::iterator ret = cacheCoinsByScript.insert(it, std::make_pair(key, CCoinsByScript()));\n+    tmp.swap(ret->second);\n+    return ret;\n+}\n+\n+CCoinsByScript &CCoinsViewByScript::GetCoinsByScript(const CScript &script, bool fRequireExisting) {\n+    CCoinsMapByScript::iterator it = FetchCoinsByScript(script, fRequireExisting);\n+    assert(it != cacheCoinsByScript.end());\n+    return it->second;\n+}\n+\n+uint160 CCoinsViewByScript::getKey(const CScript &script) {\n+    return Hash160(script);\n+}"
      },
      {
        "sha": "013d26983a110c6416d83b58bb67b12575c98d9d",
        "filename": "src/coinsbyscript.h",
        "status": "added",
        "additions": 63,
        "deletions": 0,
        "changes": 63,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/76e96e19f21e4eb63c9fc00e43f60a322d1e9344/src/coinsbyscript.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/76e96e19f21e4eb63c9fc00e43f60a322d1e9344/src/coinsbyscript.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coinsbyscript.h?ref=76e96e19f21e4eb63c9fc00e43f60a322d1e9344",
        "patch": "@@ -0,0 +1,63 @@\n+// Copyright (c) 2014 The Bitcoin developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_COINSBYSCRIPT_H\n+#define BITCOIN_COINSBYSCRIPT_H\n+\n+#include \"coins.h\"\n+#include \"primitives/transaction.h\"\n+#include \"serialize.h\"\n+#include \"uint256.h\"\n+\n+class CCoinsViewDB;\n+class CScript;\n+\n+class CCoinsByScript\n+{\n+public:\n+    // unspent transaction outputs\n+    std::set<COutPoint> setCoins;\n+\n+    // empty constructor\n+    CCoinsByScript() { }\n+\n+    bool IsEmpty() const {\n+        return (setCoins.empty());\n+    }\n+\n+    void swap(CCoinsByScript &to) {\n+        to.setCoins.swap(setCoins);\n+    }\n+\n+    ADD_SERIALIZE_METHODS;\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        READWRITE(setCoins);\n+    }\n+};\n+\n+typedef std::map<uint160, CCoinsByScript> CCoinsMapByScript; // uint160 = hash of script\n+\n+/** Adds a memory cache for coins by address */\n+class CCoinsViewByScript\n+{\n+private:\n+    CCoinsViewDB *base;\n+\n+public:\n+    CCoinsMapByScript cacheCoinsByScript; // accessed also from CCoinsViewDB in txdb.cpp\n+    CCoinsViewByScript(CCoinsViewDB* baseIn);\n+\n+    bool GetCoinsByScript(const CScript &script, CCoinsByScript &coins);\n+\n+    // Return a modifiable reference to a CCoinsByScript.\n+    CCoinsByScript &GetCoinsByScript(const CScript &script, bool fRequireExisting = true);\n+\n+    static uint160 getKey(const CScript &script); // we use the hash of the script as key in the database\n+\n+private:\n+    CCoinsMapByScript::iterator FetchCoinsByScript(const CScript &script, bool fRequireExisting);\n+};\n+\n+#endif // BITCOIN_COINSBYSCRIPT_H"
      },
      {
        "sha": "869a209b73dbb36bf4f529893a09efc0befd2f60",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 59,
        "deletions": 1,
        "changes": 60,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/76e96e19f21e4eb63c9fc00e43f60a322d1e9344/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/76e96e19f21e4eb63c9fc00e43f60a322d1e9344/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=76e96e19f21e4eb63c9fc00e43f60a322d1e9344",
        "patch": "@@ -180,6 +180,8 @@ void Shutdown()\n         pcoinscatcher = NULL;\n         delete pcoinsdbview;\n         pcoinsdbview = NULL;\n+        delete pcoinsByScript;\n+        pcoinsByScript = NULL;\n         delete pblocktree;\n         pblocktree = NULL;\n     }\n@@ -285,7 +287,8 @@ std::string HelpMessage(HelpMessageMode mode)\n     strUsage += HelpMessageOpt(\"-sysperms\", _(\"Create new files with system default permissions, instead of umask 077 (only effective with disabled wallet functionality)\"));\n #endif\n     strUsage += HelpMessageOpt(\"-txindex\", strprintf(_(\"Maintain a full transaction index, used by the getrawtransaction rpc call (default: %u)\"), 0));\n-\n+    strUsage += HelpMessageOpt(\"-txoutsbyaddressindex\", strprintf(_(\"Maintain an address to unspent outputs index (rpc: gettxoutsbyaddress). The index is built on first use. (default: %u)\"), 0));\n+    \n     strUsage += HelpMessageGroup(_(\"Connection options:\"));\n     strUsage += HelpMessageOpt(\"-addnode=<ip>\", _(\"Add a node to connect to and attempt to keep the connection open\"));\n     strUsage += HelpMessageOpt(\"-banscore=<n>\", strprintf(_(\"Threshold for disconnecting misbehaving peers (default: %u)\"), 100));\n@@ -1133,6 +1136,61 @@ bool AppInit2(boost::thread_group& threadGroup, CScheduler& scheduler)\n                     break;\n                 }\n \n+                // Check -txoutsbyaddressindex\n+                pcoinsdbview->ReadFlag(\"txoutsbyaddressindex\", fTxOutsByAddressIndex);\n+                if (mapArgs.count(\"-txoutsbyaddressindex\"))\n+                {\n+                    if (GetBoolArg(\"-txoutsbyaddressindex\", false))\n+                    {\n+                        // build index\n+                        if (!fTxOutsByAddressIndex)\n+                        {\n+                            if (!pcoinsdbview->DeleteAllCoinsByScript())\n+                            {\n+                                strLoadError = _(\"Error deleting txoutsbyaddressindex\");\n+                                break;\n+                            }\n+                            if (!pcoinsdbview->GenerateAllCoinsByScript())\n+                            {\n+                                strLoadError = _(\"Error building txoutsbyaddressindex\");\n+                                break;\n+                            }\n+                            CCoinsStats stats;\n+                            if (!pcoinsdbview->GetStats(stats))\n+                            {\n+                                strLoadError = _(\"Error GetStats for txoutsbyaddressindex\");\n+                                break;\n+                            }\n+                            if (stats.nTransactionOutputs != stats.nAddressesOutputs)\n+                            {\n+                                strLoadError = _(\"Error compare stats for txoutsbyaddressindex\");\n+                                break;\n+                            }\n+                            pcoinsdbview->WriteFlag(\"txoutsbyaddressindex\", true);\n+                            fTxOutsByAddressIndex = true;\n+                        }\n+                    }\n+                    else\n+                    {\n+                        if (fTxOutsByAddressIndex)\n+                        {\n+                            // remove index\n+                            pcoinsdbview->DeleteAllCoinsByScript();\n+                            pcoinsdbview->WriteFlag(\"txoutsbyaddressindex\", false);\n+                            fTxOutsByAddressIndex = false;\n+                        }\n+                    }\n+                }\n+                else if (fTxOutsByAddressIndex)\n+                    return InitError(_(\"You need to provide -txoutsbyaddressindex. Do -txoutsbyaddressindex=0 to delete the index.\"));\n+\n+                // Init -txoutsbyaddressindex\n+                if (fTxOutsByAddressIndex)\n+                {\n+                    pcoinsByScript = new CCoinsViewByScript(pcoinsdbview);\n+                    pcoinsdbview->SetCoinsViewByScript(pcoinsByScript);\n+                }\n+\n                 uiInterface.InitMessage(_(\"Verifying blocks...\"));\n                 if (fHavePruned && GetArg(\"-checkblocks\", 288) > MIN_BLOCKS_TO_KEEP) {\n                     LogPrintf(\"Prune: pruned datadir may not have more than %d blocks; -checkblocks=%d may fail\\n\","
      },
      {
        "sha": "b5aad1e2ccb268cafc6b7dc9a88276a21fabb6b7",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 71,
        "deletions": 11,
        "changes": 82,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/76e96e19f21e4eb63c9fc00e43f60a322d1e9344/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/76e96e19f21e4eb63c9fc00e43f60a322d1e9344/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=76e96e19f21e4eb63c9fc00e43f60a322d1e9344",
        "patch": "@@ -52,6 +52,7 @@ int nScriptCheckThreads = 0;\n bool fImporting = false;\n bool fReindex = false;\n bool fTxIndex = false;\n+bool fTxOutsByAddressIndex = false;\n bool fHavePruned = false;\n bool fPruneMode = false;\n bool fIsBareMultisigStd = true;\n@@ -63,7 +64,7 @@ uint64_t nPruneTarget = 0;\n /** Fees smaller than this (in satoshi) are considered zero fee (for relaying and mining) */\n CFeeRate minRelayTxFee = CFeeRate(1000);\n \n-CTxMemPool mempool(::minRelayTxFee);\n+CTxMemPool mempool(::minRelayTxFee, fTxOutsByAddressIndex);\n \n struct COrphanTx {\n     CTransaction tx;\n@@ -499,6 +500,7 @@ CBlockIndex* FindForkInGlobalIndex(const CChain& chain, const CBlockLocator& loc\n }\n \n CCoinsViewCache *pcoinsTip = NULL;\n+CCoinsViewByScript *pcoinsByScript = NULL;\n CBlockTreeDB *pblocktree = NULL;\n \n //////////////////////////////////////////////////////////////////////////////\n@@ -1587,7 +1589,7 @@ static bool ApplyTxInUndo(const CTxInUndo& undo, CCoinsViewCache& view, const CO\n     return fClean;\n }\n \n-bool DisconnectBlock(CBlock& block, CValidationState& state, CBlockIndex* pindex, CCoinsViewCache& view, bool* pfClean)\n+bool DisconnectBlock(CBlock& block, CValidationState& state, CBlockIndex* pindex, CCoinsViewCache& view, CBlockUndo& blockUndo, bool* pfClean)\n {\n     assert(pindex->GetBlockHash() == view.GetBestBlock());\n \n@@ -1596,7 +1598,6 @@ bool DisconnectBlock(CBlock& block, CValidationState& state, CBlockIndex* pindex\n \n     bool fClean = true;\n \n-    CBlockUndo blockUndo;\n     CDiskBlockPos pos = pindex->GetUndoPos();\n     if (pos.IsNull())\n         return error(\"DisconnectBlock(): no undo data available\");\n@@ -1693,7 +1694,7 @@ static int64_t nTimeIndex = 0;\n static int64_t nTimeCallbacks = 0;\n static int64_t nTimeTotal = 0;\n \n-bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pindex, CCoinsViewCache& view, bool fJustCheck)\n+bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pindex, CCoinsViewCache& view, CBlockUndo& blockundo, bool fJustCheck)\n {\n     const CChainParams& chainparams = Params();\n     AssertLockHeld(cs_main);\n@@ -1750,8 +1751,6 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin\n         flags |= SCRIPT_VERIFY_DERSIG;\n     }\n \n-    CBlockUndo blockundo;\n-\n     CCheckQueueControl<CScriptCheck> control(fScriptChecks && nScriptCheckThreads ? &scriptcheckqueue : NULL);\n \n     int64_t nTimeStart = GetTimeMicros();\n@@ -1983,6 +1982,60 @@ void PruneAndFlush() {\n     FlushStateToDisk(state, FLUSH_STATE_NONE);\n }\n \n+void static UpdateAddressIndex(const CTxOut& txout, const COutPoint& outpoint, bool fInsert)\n+{\n+    if (!txout.IsNull() && !txout.scriptPubKey.IsUnspendable())\n+    {\n+        CCoinsByScript &coinsByScript = pcoinsByScript->GetCoinsByScript(txout.scriptPubKey, !fInsert);\n+        if (fInsert)\n+            coinsByScript.setCoins.insert(outpoint);\n+        else\n+            coinsByScript.setCoins.erase(outpoint);\n+    }\n+}\n+\n+void static UpdateAddressIndex(CBlock& block, CBlockUndo& blockundo, bool fConnect)\n+{\n+    if (!fTxOutsByAddressIndex)\n+        return;\n+\n+    assert(block.vtx.size() > 0);\n+    unsigned int i = 0;\n+    if (!fConnect)\n+        i = block.vtx.size() - 1; // iterate backwards\n+\n+    while (true)\n+    {\n+        const CTransaction &tx = block.vtx[i];\n+\n+        if (i > 0)\n+        {\n+            for (unsigned int j = 0; j < tx.vin.size(); j++)\n+                UpdateAddressIndex(blockundo.vtxundo[i-1].vprevout[j].txout, tx.vin[j].prevout, !fConnect);\n+        }\n+\n+        for (unsigned int j = 0; j < tx.vout.size(); j++)\n+        {\n+            CTxOut& txout = const_cast<CTxOut&>(tx.vout[j]);\n+            const COutPoint outpoint(tx.GetHash(),((uint32_t)j));\n+            UpdateAddressIndex(txout, outpoint, fConnect);\n+        }\n+\n+        if (fConnect)\n+        {\n+            if (i == block.vtx.size() - 1)\n+                break;\n+            i++;\n+        }\n+        else\n+        {\n+            if (i == 0)\n+                break;\n+            i--;\n+        }\n+    }\n+}\n+\n /** Update chainActive and related internal data structures. */\n void static UpdateTip(CBlockIndex *pindexNew) {\n     const CChainParams& chainParams = Params();\n@@ -2035,10 +2088,12 @@ bool static DisconnectTip(CValidationState &state) {\n     // Apply the block atomically to the chain state.\n     int64_t nStart = GetTimeMicros();\n     {\n+        CBlockUndo blockUndo;\n         CCoinsViewCache view(pcoinsTip);\n-        if (!DisconnectBlock(block, state, pindexDelete, view))\n+        if (!DisconnectBlock(block, state, pindexDelete, view, blockUndo))\n             return error(\"DisconnectTip(): DisconnectBlock %s failed\", pindexDelete->GetBlockHash().ToString());\n         assert(view.Flush());\n+        UpdateAddressIndex(block, blockUndo, false);\n     }\n     LogPrint(\"bench\", \"- Disconnect block: %.2fms\\n\", (GetTimeMicros() - nStart) * 0.001);\n     // Write the chain state to disk, if necessary.\n@@ -2090,9 +2145,10 @@ bool static ConnectTip(CValidationState &state, CBlockIndex *pindexNew, CBlock *\n     int64_t nTime3;\n     LogPrint(\"bench\", \"  - Load block from disk: %.2fms [%.2fs]\\n\", (nTime2 - nTime1) * 0.001, nTimeReadFromDisk * 0.000001);\n     {\n+        CBlockUndo blockundo;\n         CCoinsViewCache view(pcoinsTip);\n         CInv inv(MSG_BLOCK, pindexNew->GetBlockHash());\n-        bool rv = ConnectBlock(*pblock, state, pindexNew, view);\n+        bool rv = ConnectBlock(*pblock, state, pindexNew, view, blockundo);\n         GetMainSignals().BlockChecked(*pblock, state);\n         if (!rv) {\n             if (state.IsInvalid())\n@@ -2103,6 +2159,7 @@ bool static ConnectTip(CValidationState &state, CBlockIndex *pindexNew, CBlock *\n         nTime3 = GetTimeMicros(); nTimeConnectTotal += nTime3 - nTime2;\n         LogPrint(\"bench\", \"  - Connect total: %.2fms [%.2fs]\\n\", (nTime3 - nTime2) * 0.001, nTimeConnectTotal * 0.000001);\n         assert(view.Flush());\n+        UpdateAddressIndex(*pblock, blockundo, true);\n     }\n     int64_t nTime4 = GetTimeMicros(); nTimeFlush += nTime4 - nTime3;\n     LogPrint(\"bench\", \"  - Flush: %.2fms [%.2fs]\\n\", (nTime4 - nTime3) * 0.001, nTimeFlush * 0.000001);\n@@ -2850,6 +2907,7 @@ bool TestBlockValidity(CValidationState &state, const CBlock& block, CBlockIndex\n     assert(pindexPrev == chainActive.Tip());\n \n     CCoinsViewCache viewNew(pcoinsTip);\n+    CBlockUndo blockundo;\n     CBlockIndex indexDummy(block);\n     indexDummy.pprev = pindexPrev;\n     indexDummy.nHeight = pindexPrev->nHeight + 1;\n@@ -2861,7 +2919,7 @@ bool TestBlockValidity(CValidationState &state, const CBlock& block, CBlockIndex\n         return false;\n     if (!ContextualCheckBlock(block, state, pindexPrev))\n         return false;\n-    if (!ConnectBlock(block, state, &indexDummy, viewNew, true))\n+    if (!ConnectBlock(block, state, &indexDummy, viewNew, blockundo, true))\n         return false;\n     assert(state.IsValid());\n \n@@ -3221,7 +3279,8 @@ bool CVerifyDB::VerifyDB(CCoinsView *coinsview, int nCheckLevel, int nCheckDepth\n         // check level 3: check for inconsistencies during memory-only disconnect of tip blocks\n         if (nCheckLevel >= 3 && pindex == pindexState && (coins.DynamicMemoryUsage() + pcoinsTip->DynamicMemoryUsage()) <= nCoinCacheUsage) {\n             bool fClean = true;\n-            if (!DisconnectBlock(block, state, pindex, coins, &fClean))\n+            CBlockUndo undo;\n+            if (!DisconnectBlock(block, state, pindex, coins, undo, &fClean))\n                 return error(\"VerifyDB(): *** irrecoverable inconsistency in block data at %d, hash=%s\", pindex->nHeight, pindex->GetBlockHash().ToString());\n             pindexState = pindex->pprev;\n             if (!fClean) {\n@@ -3244,9 +3303,10 @@ bool CVerifyDB::VerifyDB(CCoinsView *coinsview, int nCheckLevel, int nCheckDepth\n             uiInterface.ShowProgress(_(\"Verifying blocks...\"), std::max(1, std::min(99, 100 - (int)(((double)(chainActive.Height() - pindex->nHeight)) / (double)nCheckDepth * 50))));\n             pindex = chainActive.Next(pindex);\n             CBlock block;\n+            CBlockUndo undo;\n             if (!ReadBlockFromDisk(block, pindex))\n                 return error(\"VerifyDB(): *** ReadBlockFromDisk failed at %d, hash=%s\", pindex->nHeight, pindex->GetBlockHash().ToString());\n-            if (!ConnectBlock(block, state, pindex, coins))\n+            if (!ConnectBlock(block, state, pindex, coins, undo))\n                 return error(\"VerifyDB(): *** found unconnectable block at %d, hash=%s\", pindex->nHeight, pindex->GetBlockHash().ToString());\n         }\n     }"
      },
      {
        "sha": "1144076693a6d16b4a508657f10e7cc71df51feb",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 8,
        "deletions": 2,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/76e96e19f21e4eb63c9fc00e43f60a322d1e9344/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/76e96e19f21e4eb63c9fc00e43f60a322d1e9344/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=76e96e19f21e4eb63c9fc00e43f60a322d1e9344",
        "patch": "@@ -14,6 +14,7 @@\n #include \"chain.h\"\n #include \"chainparams.h\"\n #include \"coins.h\"\n+#include \"coinsbyscript.h\"\n #include \"consensus/consensus.h\"\n #include \"net.h\"\n #include \"primitives/block.h\"\n@@ -39,6 +40,7 @@\n \n class CBlockIndex;\n class CBlockTreeDB;\n+class CBlockUndo;\n class CBloomFilter;\n class CInv;\n class CScriptCheck;\n@@ -118,6 +120,7 @@ extern bool fImporting;\n extern bool fReindex;\n extern int nScriptCheckThreads;\n extern bool fTxIndex;\n+extern bool fTxOutsByAddressIndex;\n extern bool fIsBareMultisigStd;\n extern bool fCheckBlockIndex;\n extern bool fCheckpointsEnabled;\n@@ -383,10 +386,10 @@ bool ReadBlockFromDisk(CBlock& block, const CBlockIndex* pindex);\n  *  In case pfClean is provided, operation will try to be tolerant about errors, and *pfClean\n  *  will be true if no problems were found. Otherwise, the return value will be false in case\n  *  of problems. Note that in any case, coins may be modified. */\n-bool DisconnectBlock(CBlock& block, CValidationState& state, CBlockIndex* pindex, CCoinsViewCache& coins, bool* pfClean = NULL);\n+bool DisconnectBlock(CBlock& block, CValidationState& state, CBlockIndex* pindex, CCoinsViewCache& coins, CBlockUndo& blockUndo, bool* pfClean = NULL);\n \n /** Apply the effects of this block (with given index) on the UTXO set represented by coins */\n-bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pindex, CCoinsViewCache& coins, bool fJustCheck = false);\n+bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pindex, CCoinsViewCache& coins, CBlockUndo& blockundo, bool fJustCheck = false);\n \n /** Context-independent validity checks */\n bool CheckBlockHeader(const CBlockHeader& block, CValidationState& state, bool fCheckPOW = true);\n@@ -545,6 +548,9 @@ extern CChain chainActive;\n /** Global variable that points to the active CCoinsView (protected by cs_main) */\n extern CCoinsViewCache *pcoinsTip;\n \n+/** Only used if -txoutsbyaddressindex */\n+extern CCoinsViewByScript *pcoinsByScript;\n+\n /** Global variable that points to the active block tree (protected by cs_main) */\n extern CBlockTreeDB *pblocktree;\n "
      },
      {
        "sha": "346e5605e9b76432b6ab09d03ed28f7e77b9cc6b",
        "filename": "src/rpcblockchain.cpp",
        "status": "modified",
        "additions": 168,
        "deletions": 0,
        "changes": 168,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/76e96e19f21e4eb63c9fc00e43f60a322d1e9344/src/rpcblockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/76e96e19f21e4eb63c9fc00e43f60a322d1e9344/src/rpcblockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcblockchain.cpp?ref=76e96e19f21e4eb63c9fc00e43f60a322d1e9344",
        "patch": "@@ -3,6 +3,7 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n+#include \"base58.h\"\n #include \"checkpoints.h\"\n #include \"main.h\"\n #include \"rpcserver.h\"\n@@ -11,6 +12,7 @@\n \n #include <stdint.h>\n \n+#include <boost/assign/list_of.hpp>\n #include \"json/json_spirit_value.h\"\n \n using namespace json_spirit;\n@@ -329,6 +331,8 @@ Value gettxoutsetinfo(const Array& params, bool fHelp)\n             \"  \\\"bestblock\\\": \\\"hex\\\",   (string) the best block hash hex\\n\"\n             \"  \\\"transactions\\\": n,      (numeric) The number of transactions\\n\"\n             \"  \\\"txouts\\\": n,            (numeric) The number of output transactions\\n\"\n+            \"  \\\"addresses\\\": n,         (numeric) The number of addresses and scripts. Only if -txoutsbyaddressindex=1\\n\"\n+            \"  \\\"txoutsbyaddress\\\": n,   (numeric) The number of output transactions. Only if -txoutsbyaddressindex=1\\n\"\n             \"  \\\"bytes_serialized\\\": n,  (numeric) The serialized size\\n\"\n             \"  \\\"hash_serialized\\\": \\\"hash\\\",   (string) The serialized hash\\n\"\n             \"  \\\"total_amount\\\": x.xxx          (numeric) The total amount\\n\"\n@@ -349,6 +353,8 @@ Value gettxoutsetinfo(const Array& params, bool fHelp)\n         ret.push_back(Pair(\"bestblock\", stats.hashBlock.GetHex()));\n         ret.push_back(Pair(\"transactions\", (int64_t)stats.nTransactions));\n         ret.push_back(Pair(\"txouts\", (int64_t)stats.nTransactionOutputs));\n+        ret.push_back(Pair(\"addresses\", (int64_t)stats.nAddresses));\n+        ret.push_back(Pair(\"txoutsbyaddress\", (int64_t)stats.nAddressesOutputs));\n         ret.push_back(Pair(\"bytes_serialized\", (int64_t)stats.nSerializedSize));\n         ret.push_back(Pair(\"hash_serialized\", stats.hashSerialized.GetHex()));\n         ret.push_back(Pair(\"total_amount\", ValueFromAmount(stats.nTotalAmount)));\n@@ -436,6 +442,168 @@ Value gettxout(const Array& params, bool fHelp)\n     return ret;\n }\n \n+Value gettxoutsbyaddress(const Array& params, bool fHelp)\n+{\n+    if (fHelp || params.size() < 2 || params.size() > 4)\n+        throw runtime_error(\n+            \"gettxoutsbyaddress ( minconf [\\\"address\\\",...] count from )\\n\"\n+            \"\\nReturns a list of unspent transaction outputs by address (or script).\\n\"\n+            \"The list is ordered by confirmations in descending order.\\n\"\n+            \"Note that passing minconf=0 will include the mempool.\\n\"\n+            \"\\nTo use this function, you must start bitcoin with the -txoutsbyaddressindex parameter.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. minconf          (numeric) Minimum confirmations\\n\"\n+            \"2. \\\"addresses\\\"    (string) A json array of bitcoin addresses (or scripts)\\n\"\n+            \"    [\\n\"\n+            \"      \\\"address\\\"   (string) bitcoin address (or script)\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+            \"3. count            (numeric, optional, default=999999999) The number of outputs to return\\n\"\n+            \"4. from             (numeric, optional, default=0) The number of outputs to skip\\n\"\n+            \"\\nResult\\n\"\n+            \"[                   (array of json object)\\n\"\n+            \"  {\\n\"\n+            \"    \\\"confirmations\\\" : n,        (numeric) The number of confirmations\\n\"\n+            \"    \\\"txid\\\" : \\\"txid\\\",          (string)  The transaction id \\n\"\n+            \"    \\\"vout\\\" : n,                 (numeric) The vout value\\n\"\n+            \"    \\\"value\\\" : x.xxx,            (numeric) The transaction value in btc\\n\"\n+            \"    \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"       \\\"asm\\\" : \\\"code\\\",        (string) \\n\"\n+            \"       \\\"hex\\\" : \\\"hex\\\",         (string) \\n\"\n+            \"       \\\"reqSigs\\\" : n,           (numeric) Number of required signatures\\n\"\n+            \"       \\\"type\\\" : \\\"pubkeyhash\\\", (string) The type, eg pubkeyhash\\n\"\n+            \"       \\\"addresses\\\" : [          (array of string) array of bitcoin addresses\\n\"\n+            \"          \\\"bitcoinaddress\\\"      (string) bitcoin address\\n\"\n+            \"          ,...\\n\"\n+            \"       ]\\n\"\n+            \"    },\\n\"\n+            \"    \\\"version\\\" : n,              (numeric) The transaction version\\n\"\n+            \"    \\\"coinbase\\\" : true|false     (boolean) Coinbase or not\\n\"\n+            \"    \\\"bestblockhash\\\" : \\\"hash\\\", (string)  The block hash of the best block\\n\"\n+            \"    \\\"bestblockheight\\\" : n,      (numeric) The block height of the best block\\n\"\n+            \"    \\\"bestblocktime\\\" : n,        (numeric) The block time of the best block\\n\"\n+            \"    \\\"blockhash\\\" : \\\"hash\\\",     (string)  The block hash of the block the tx is in (only if confirmations > 0)\\n\"\n+            \"    \\\"blockheight\\\" : n,          (numeric) The block height of the block the tx is in (only if confirmations > 0)\\n\"\n+            \"    \\\"blocktime\\\" : ttt,          (numeric) The block time in seconds since 1.1.1970 GMT (only if confirmations > 0)\\n\"\n+            \"  }\\n\"\n+            \"  ,...\\n\"\n+            \"]\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"gettxoutsbyaddress\", \"6 \\\"[\\\\\\\"1PGFqEzfmQch1gKD3ra4k18PNj3tTUUSqg\\\\\\\",\\\\\\\"1LtvqCaApEdUGFkpKMM4MstjcaL4dKg8SP\\\\\\\"]\\\"\")\n+            + \"\\nAs a json rpc call\\n\"\n+            + HelpExampleRpc(\"gettxoutsbyaddress\", \"6, \\\"[\\\\\\\"1PGFqEzfmQch1gKD3ra4k18PNj3tTUUSqg\\\\\\\",\\\\\\\"1LtvqCaApEdUGFkpKMM4MstjcaL4dKg8SP\\\\\\\"]\\\"\")\n+        );\n+\n+    if (!fTxOutsByAddressIndex)\n+        throw JSONRPCError(RPC_METHOD_NOT_FOUND, \"To use this function, you must start bitcoin with the -txoutsbyaddressindex parameter.\");\n+\n+    RPCTypeCheck(params, boost::assign::list_of(int_type)(array_type)(int_type)(int_type));\n+\n+    vector<Object> vObjects;\n+    vector<pair<int, unsigned int> > vSort;\n+    int nMinDepth = params[0].get_int();\n+    Array inputs = params[1].get_array();\n+\n+    int nCount = 999999999;\n+    if (params.size() > 2)\n+        nCount = params[2].get_int();\n+    int nFrom = 0;\n+    if (params.size() > 3)\n+        nFrom = params[3].get_int();\n+\n+    if (nMinDepth < 0)\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Negative minconf\");\n+    if (nCount < 0)\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Negative count\");\n+    if (nFrom < 0)\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Negative from\");\n+\n+    BOOST_FOREACH(Value& input, inputs) {\n+        CScript script;\n+        CBitcoinAddress address(input.get_str());\n+        if (address.IsValid()) {\n+            script = GetScriptForDestination(address.Get());\n+        } else if (IsHex(input.get_str())) {\n+            std::vector<unsigned char> data(ParseHex(input.get_str()));\n+            script = CScript(data.begin(), data.end());\n+        } else {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid Bitcoin address or script: \" + input.get_str());\n+        }\n+\n+        CCoinsByScript coinsByScript;\n+        pcoinsByScript->GetCoinsByScript(script, coinsByScript);\n+\n+        if (nMinDepth == 0)\n+            mempool.GetCoinsByScript(script, coinsByScript);\n+\n+        BOOST_FOREACH(const COutPoint &outpoint, coinsByScript.setCoins)\n+        {\n+            CCoins coins;\n+            if (nMinDepth == 0)\n+            {\n+                LOCK(mempool.cs);\n+                CCoinsViewMemPool view(pcoinsTip, mempool);\n+                if (!view.GetCoins(outpoint.hash, coins))\n+                    continue;\n+                mempool.pruneSpent(outpoint.hash, coins); // TODO: this should be done by the CCoinsViewMemPool\n+            }\n+            else if (!pcoinsTip->GetCoins(outpoint.hash, coins))\n+                continue;\n+\n+            if (outpoint.n < coins.vout.size() && !coins.vout[outpoint.n].IsNull() && !coins.vout[outpoint.n].scriptPubKey.IsUnspendable())\n+            {\n+                // should not happen\n+                if ((unsigned int)coins.nHeight != MEMPOOL_HEIGHT && (!chainActive[coins.nHeight] || !chainActive[coins.nHeight]->phashBlock))\n+                    throw JSONRPCError(RPC_INTERNAL_ERROR, \"Internal Error: !chainActive[coins.nHeight]\");\n+\n+                BlockMap::iterator it = mapBlockIndex.find(pcoinsTip->GetBestBlock());\n+                CBlockIndex *pindex = it->second;\n+\n+                int nConfirmations = 0;\n+                if ((unsigned int)coins.nHeight != MEMPOOL_HEIGHT)\n+                    nConfirmations = pindex->nHeight - coins.nHeight + 1;\n+                if (nConfirmations < nMinDepth)\n+                    continue;\n+\n+                Object oScriptPubKey;\n+                ScriptPubKeyToJSON(coins.vout[outpoint.n].scriptPubKey, oScriptPubKey, true);\n+\n+                Object o;\n+                o.push_back(Pair(\"confirmations\", nConfirmations));\n+                o.push_back(Pair(\"txid\", outpoint.hash.GetHex()));\n+                o.push_back(Pair(\"vout\", (int)outpoint.n));\n+                o.push_back(Pair(\"value\", ValueFromAmount(coins.vout[outpoint.n].nValue)));\n+                o.push_back(Pair(\"scriptPubKey\", oScriptPubKey));\n+                o.push_back(Pair(\"version\", coins.nVersion));\n+                o.push_back(Pair(\"coinbase\", coins.fCoinBase));\n+                o.push_back(Pair(\"bestblockhash\", pindex->GetBlockHash().GetHex()));\n+                o.push_back(Pair(\"bestblockheight\", pindex->nHeight));\n+                o.push_back(Pair(\"bestblocktime\", pindex->GetBlockTime()));\n+                if ((unsigned int)coins.nHeight != MEMPOOL_HEIGHT)\n+                {\n+                    o.push_back(Pair(\"blockhash\", chainActive[coins.nHeight]->GetBlockHash().GetHex()));\n+                    o.push_back(Pair(\"blockheight\", coins.nHeight));\n+                    o.push_back(Pair(\"blocktime\", chainActive[coins.nHeight]->GetBlockTime()));\n+                }\n+                vObjects.push_back(o);\n+                vSort.push_back(make_pair(coins.nHeight, (unsigned int)vObjects.size() - 1));\n+            }\n+        }\n+    }\n+\n+    Array results;\n+    sort(vSort.begin(), vSort.end());\n+    for (unsigned int i = (unsigned int)nFrom; i < vSort.size(); i++)\n+    {\n+        if (i == (unsigned int)nCount + (unsigned int)nFrom)\n+            break;\n+\n+        results.push_back(vObjects[vSort[i].second]);\n+    }\n+\n+    return results;\n+}\n+\n Value verifychain(const Array& params, bool fHelp)\n {\n     if (fHelp || params.size() > 2)"
      },
      {
        "sha": "e484e4296eb9b18975784fa7b7fcfe633dcd5930",
        "filename": "src/rpcclient.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/76e96e19f21e4eb63c9fc00e43f60a322d1e9344/src/rpcclient.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/76e96e19f21e4eb63c9fc00e43f60a322d1e9344/src/rpcclient.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcclient.cpp?ref=76e96e19f21e4eb63c9fc00e43f60a322d1e9344",
        "patch": "@@ -79,6 +79,10 @@ static const CRPCConvertParam vRPCConvertParams[] =\n     { \"gettxout\", 1 },\n     { \"gettxout\", 2 },\n     { \"gettxoutproof\", 0 },\n+    { \"gettxoutsbyaddress\", 0 },\n+    { \"gettxoutsbyaddress\", 1 },\n+    { \"gettxoutsbyaddress\", 2 },\n+    { \"gettxoutsbyaddress\", 3 },\n     { \"lockunspent\", 0 },\n     { \"lockunspent\", 1 },\n     { \"importprivkey\", 2 },"
      },
      {
        "sha": "5402e4f44dbcb88c05f837f1e1be157d5446ebbb",
        "filename": "src/rpcserver.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/76e96e19f21e4eb63c9fc00e43f60a322d1e9344/src/rpcserver.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/76e96e19f21e4eb63c9fc00e43f60a322d1e9344/src/rpcserver.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcserver.cpp?ref=76e96e19f21e4eb63c9fc00e43f60a322d1e9344",
        "patch": "@@ -293,6 +293,7 @@ static const CRPCCommand vRPCCommands[] =\n     { \"blockchain\",         \"getmempoolinfo\",         &getmempoolinfo,         true  },\n     { \"blockchain\",         \"getrawmempool\",          &getrawmempool,          true  },\n     { \"blockchain\",         \"gettxout\",               &gettxout,               true  },\n+    { \"blockchain\",         \"gettxoutsbyaddress\",     &gettxoutsbyaddress,     true  },\n     { \"blockchain\",         \"gettxoutproof\",          &gettxoutproof,          true  },\n     { \"blockchain\",         \"verifytxoutproof\",       &verifytxoutproof,       true  },\n     { \"blockchain\",         \"gettxoutsetinfo\",        &gettxoutsetinfo,        true  },"
      },
      {
        "sha": "f59f897d54b42f375db83435562a9e562ef01abd",
        "filename": "src/rpcserver.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/76e96e19f21e4eb63c9fc00e43f60a322d1e9344/src/rpcserver.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/76e96e19f21e4eb63c9fc00e43f60a322d1e9344/src/rpcserver.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcserver.h?ref=76e96e19f21e4eb63c9fc00e43f60a322d1e9344",
        "patch": "@@ -231,6 +231,7 @@ extern json_spirit::Value getblockhash(const json_spirit::Array& params, bool fH\n extern json_spirit::Value getblock(const json_spirit::Array& params, bool fHelp);\n extern json_spirit::Value gettxoutsetinfo(const json_spirit::Array& params, bool fHelp);\n extern json_spirit::Value gettxout(const json_spirit::Array& params, bool fHelp);\n+extern json_spirit::Value gettxoutsbyaddress(const json_spirit::Array& params, bool fHelp);\n extern json_spirit::Value verifychain(const json_spirit::Array& params, bool fHelp);\n extern json_spirit::Value getchaintips(const json_spirit::Array& params, bool fHelp);\n extern json_spirit::Value invalidateblock(const json_spirit::Array& params, bool fHelp);"
      },
      {
        "sha": "ce05a413302b89e493917ab4a4bfb275edd04158",
        "filename": "src/test/mempool_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/76e96e19f21e4eb63c9fc00e43f60a322d1e9344/src/test/mempool_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/76e96e19f21e4eb63c9fc00e43f60a322d1e9344/src/test/mempool_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/mempool_tests.cpp?ref=76e96e19f21e4eb63c9fc00e43f60a322d1e9344",
        "patch": "@@ -51,8 +51,8 @@ BOOST_AUTO_TEST_CASE(MempoolRemoveTest)\n         txGrandChild[i].vout[0].nValue = 11000LL;\n     }\n \n-\n-    CTxMemPool testPool(CFeeRate(0));\n+    bool fTxOutsByAddressIndex = false;\n+    CTxMemPool testPool(CFeeRate(0), fTxOutsByAddressIndex);\n     std::list<CTransaction> removed;\n \n     // Nothing in pool, remove should do nothing:"
      },
      {
        "sha": "8e801fb196104650b28666d49e08a8d4aaf6a0fc",
        "filename": "src/test/policyestimator_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/76e96e19f21e4eb63c9fc00e43f60a322d1e9344/src/test/policyestimator_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/76e96e19f21e4eb63c9fc00e43f60a322d1e9344/src/test/policyestimator_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/policyestimator_tests.cpp?ref=76e96e19f21e4eb63c9fc00e43f60a322d1e9344",
        "patch": "@@ -15,7 +15,8 @@ BOOST_FIXTURE_TEST_SUITE(policyestimator_tests, BasicTestingSetup)\n \n BOOST_AUTO_TEST_CASE(BlockPolicyEstimates)\n {\n-    CTxMemPool mpool(CFeeRate(1000));\n+    bool fTxOutsByAddressIndex = false;\n+    CTxMemPool mpool(CFeeRate(1000), fTxOutsByAddressIndex);\n     CAmount basefee(2000);\n     double basepri = 1e6;\n     CAmount deltaFee(100);"
      },
      {
        "sha": "04835e4d5a93e08f7d00387305be5f9e90218fa8",
        "filename": "src/txdb.cpp",
        "status": "modified",
        "additions": 219,
        "deletions": 1,
        "changes": 220,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/76e96e19f21e4eb63c9fc00e43f60a322d1e9344/src/txdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/76e96e19f21e4eb63c9fc00e43f60a322d1e9344/src/txdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.cpp?ref=76e96e19f21e4eb63c9fc00e43f60a322d1e9344",
        "patch": "@@ -10,6 +10,7 @@\n #include \"main.h\"\n #include \"pow.h\"\n #include \"uint256.h\"\n+#include \"ui_interface.h\"\n \n #include <stdint.h>\n \n@@ -35,17 +36,33 @@ void static BatchWriteCoins(CLevelDBBatch &batch, const uint256 &hash, const CCo\n         batch.Write(make_pair(DB_COINS, hash), coins);\n }\n \n+void static BatchWriteCoins(CLevelDBBatch &batch, const uint160 &hash, const CCoinsByScript &coins) {\n+    if (coins.IsEmpty())\n+        batch.Erase(make_pair('d', hash));\n+    else\n+        batch.Write(make_pair('d', hash), coins);\n+}\n+\n void static BatchWriteHashBestChain(CLevelDBBatch &batch, const uint256 &hash) {\n     batch.Write(DB_BEST_BLOCK, hash);\n }\n \n CCoinsViewDB::CCoinsViewDB(size_t nCacheSize, bool fMemory, bool fWipe) : db(GetDataDir() / \"chainstate\", nCacheSize, fMemory, fWipe) {\n+    pcoinsViewByScript = NULL;\n+}\n+\n+void CCoinsViewDB::SetCoinsViewByScript(CCoinsViewByScript* pcoinsViewByScriptIn) {\n+    pcoinsViewByScript = pcoinsViewByScriptIn;\n }\n \n bool CCoinsViewDB::GetCoins(const uint256 &txid, CCoins &coins) const {\n     return db.Read(make_pair(DB_COINS, txid), coins);\n }\n \n+bool CCoinsViewDB::GetCoinsByHashOfScript(const uint160 &hash, CCoinsByScript &coins) const {\n+    return db.Read(make_pair('d', hash), coins);\n+}\n+\n bool CCoinsViewDB::HaveCoins(const uint256 &txid) const {\n     return db.Exists(make_pair(DB_COINS, txid));\n }\n@@ -70,13 +87,34 @@ bool CCoinsViewDB::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) {\n         CCoinsMap::iterator itOld = it++;\n         mapCoins.erase(itOld);\n     }\n+    if (pcoinsViewByScript) // only if -txoutsbyaddressindex\n+    {\n+        for (CCoinsMapByScript::iterator it = pcoinsViewByScript->cacheCoinsByScript.begin(); it != pcoinsViewByScript->cacheCoinsByScript.end();) {\n+            BatchWriteCoins(batch, it->first, it->second);\n+            CCoinsMapByScript::iterator itOld = it++;\n+            pcoinsViewByScript->cacheCoinsByScript.erase(itOld);\n+        }\n+        pcoinsViewByScript->cacheCoinsByScript.clear();\n+    }\n     if (!hashBlock.IsNull())\n         BatchWriteHashBestChain(batch, hashBlock);\n \n     LogPrint(\"coindb\", \"Committing %u changed transactions (out of %u) to coin database...\\n\", (unsigned int)changed, (unsigned int)count);\n     return db.WriteBatch(batch);\n }\n \n+bool CCoinsViewDB::WriteFlag(const std::string &name, bool fValue) {\n+    return db.Write(std::make_pair('F', name), fValue ? '1' : '0');\n+}\n+\n+bool CCoinsViewDB::ReadFlag(const std::string &name, bool &fValue) {\n+    char ch;\n+    if (!db.Read(std::make_pair('F', name), ch))\n+        return false;\n+    fValue = ch == '1';\n+    return true;\n+}\n+\n CBlockTreeDB::CBlockTreeDB(size_t nCacheSize, bool fMemory, bool fWipe) : CLevelDBWrapper(GetDataDir() / \"blocks\" / \"index\", nCacheSize, fMemory, fWipe) {\n }\n \n@@ -101,6 +139,9 @@ bool CBlockTreeDB::ReadLastBlockFile(int &nFile) {\n }\n \n bool CCoinsViewDB::GetStats(CCoinsStats &stats) const {\n+    int64_t nTotalCount = GetPrefixCount('c') + GetPrefixCount('d');\n+    uiInterface.ShowProgress(_(\"Calculating index stats...\"), 0);\n+\n     /* It seems that there are no \"const iterators\" for LevelDB.  Since we\n        only need read operations on it, use a const-cast to get around\n        that restriction.  */\n@@ -111,14 +152,20 @@ bool CCoinsViewDB::GetStats(CCoinsStats &stats) const {\n     stats.hashBlock = GetBestBlock();\n     ss << stats.hashBlock;\n     CAmount nTotalAmount = 0;\n+    int64_t progress = 0;\n     while (pcursor->Valid()) {\n         boost::this_thread::interruption_point();\n         try {\n             leveldb::Slice slKey = pcursor->key();\n             CDataStream ssKey(slKey.data(), slKey.data()+slKey.size(), SER_DISK, CLIENT_VERSION);\n             char chType;\n             ssKey >> chType;\n+\n+            if (progress % 1000 == 0 && nTotalCount > 0)\n+                uiInterface.ShowProgress(_(\"Calculating index stats...\"), std::max(1, std::min(99, (int)(((double)(progress)) / (double)nTotalCount * 100))));\n+\n             if (chType == DB_COINS) {\n+                progress++;\n                 leveldb::Slice slValue = pcursor->value();\n                 CDataStream ssValue(slValue.data(), slValue.data()+slValue.size(), SER_DISK, CLIENT_VERSION);\n                 CCoins coins;\n@@ -142,14 +189,185 @@ bool CCoinsViewDB::GetStats(CCoinsStats &stats) const {\n                 stats.nSerializedSize += 32 + slValue.size();\n                 ss << VARINT(0);\n             }\n+            if (chType == 'd') {\n+                progress++;\n+                leveldb::Slice slValue = pcursor->value();\n+                CDataStream ssValue(slValue.data(), slValue.data()+slValue.size(), SER_DISK, CLIENT_VERSION);\n+                CCoinsByScript coinsByScript;\n+                ssValue >> coinsByScript;\n+                stats.nAddresses++;\n+                stats.nAddressesOutputs += coinsByScript.setCoins.size();\n+            }\n             pcursor->Next();\n         } catch (const std::exception& e) {\n+            uiInterface.ShowProgress(_(\"Calculating index stats...\"), 100);\n             return error(\"%s: Deserialize or I/O error - %s\", __func__, e.what());\n         }\n     }\n-    stats.nHeight = mapBlockIndex.find(GetBestBlock())->second->nHeight;\n+    if (mapBlockIndex.count(GetBestBlock()))\n+        stats.nHeight = mapBlockIndex.find(GetBestBlock())->second->nHeight;\n     stats.hashSerialized = ss.GetHash();\n     stats.nTotalAmount = nTotalAmount;\n+    uiInterface.ShowProgress(_(\"Calculating index stats...\"), 100);\n+    return true;\n+}\n+int64_t CCoinsViewDB::GetPrefixCount(char prefix) const\n+{\n+    boost::scoped_ptr<leveldb::Iterator> pcursor(const_cast<CLevelDBWrapper*>(&db)->NewIterator());\n+    CDataStream ssKeySet(SER_DISK, CLIENT_VERSION);\n+    ssKeySet << prefix;\n+    pcursor->Seek(ssKeySet.str());\n+\n+    int64_t i = 0;\n+    while (pcursor->Valid()) {\n+        boost::this_thread::interruption_point();\n+        try {\n+            leveldb::Slice slKey = pcursor->key();\n+            CDataStream ssKey(slKey.data(), slKey.data()+slKey.size(), SER_DISK, CLIENT_VERSION);\n+            char chType;\n+            ssKey >> chType;\n+            if (chType != prefix)\n+                break;\n+            i++;\n+            pcursor->Next();\n+        } catch (std::exception &e) {\n+            return 0;\n+        }\n+    }\n+    return i;\n+}\n+\n+bool CCoinsViewDB::DeleteAllCoinsByScript()\n+{\n+    boost::scoped_ptr<leveldb::Iterator> pcursor(const_cast<CLevelDBWrapper*>(&db)->NewIterator());\n+    CDataStream ssKeySet(SER_DISK, CLIENT_VERSION);\n+    ssKeySet << 'd';\n+    pcursor->Seek(ssKeySet.str());\n+\n+    std::vector<uint160> v;\n+    int64_t i = 0;\n+    while (pcursor->Valid()) {\n+        boost::this_thread::interruption_point();\n+        try {\n+            leveldb::Slice slKey = pcursor->key();\n+            CDataStream ssKey(slKey.data(), slKey.data()+slKey.size(), SER_DISK, CLIENT_VERSION);\n+            char chType;\n+            ssKey >> chType;\n+            if (chType != 'd')\n+                break;\n+\n+            uint160 scripthash;\n+            ssKey >> scripthash;\n+            v.push_back(scripthash);\n+            if (v.size() >= 10000)\n+            {\n+                i += v.size();\n+                CLevelDBBatch batch;\n+                CCoinsByScript empty;\n+                BOOST_FOREACH(const uint160& hash, v)\n+                    BatchWriteCoins(batch, hash, empty); // delete\n+                db.WriteBatch(batch);\n+                v.clear();\n+            }\n+\n+            pcursor->Next();\n+        } catch (std::exception &e) {\n+            return error(\"%s : Deserialize or I/O error - %s\", __func__, e.what());\n+        }\n+    }\n+    if (!v.empty())\n+    {\n+        i += v.size();\n+        CLevelDBBatch batch;\n+        CCoinsByScript empty;\n+        BOOST_FOREACH(const uint160& hash, v)\n+            BatchWriteCoins(batch, hash, empty); // delete\n+        db.WriteBatch(batch);\n+    }\n+    if (i > 0)\n+        LogPrintf(\"Address index with %d addresses successfully deleted.\\n\", i);\n+\n+    return true;\n+}\n+\n+bool CCoinsViewDB::GenerateAllCoinsByScript()\n+{\n+    LogPrintf(\"Building address index for -txoutsbyaddressindex. Be patient...\\n\");\n+    int64_t nTxCount = GetPrefixCount('c');\n+\n+    boost::scoped_ptr<leveldb::Iterator> pcursor(const_cast<CLevelDBWrapper*>(&db)->NewIterator());\n+    CDataStream ssKeySet(SER_DISK, CLIENT_VERSION);\n+    ssKeySet << 'c';\n+    pcursor->Seek(ssKeySet.str());\n+\n+    CCoinsMapByScript mapCoinsByScript;\n+    int64_t i = 0;\n+    int64_t progress = 0;\n+    while (pcursor->Valid()) {\n+        boost::this_thread::interruption_point();\n+        try {\n+            leveldb::Slice slKey = pcursor->key();\n+            CDataStream ssKey(slKey.data(), slKey.data()+slKey.size(), SER_DISK, CLIENT_VERSION);\n+            char chType;\n+            ssKey >> chType;\n+            if (chType != 'c')\n+                break;\n+\n+            if (progress % 1000 == 0 && nTxCount > 0)\n+                uiInterface.ShowProgress(_(\"Building address index...\"), (int)(((double)progress / (double)nTxCount) * (double)100));\n+            progress++;\n+\n+            leveldb::Slice slValue = pcursor->value();\n+            CDataStream ssValue(slValue.data(), slValue.data()+slValue.size(), SER_DISK, CLIENT_VERSION);\n+            CCoins coins;\n+            ssValue >> coins;\n+            uint256 txhash;\n+            ssKey >> txhash;\n+\n+            for (unsigned int j = 0; j < coins.vout.size(); j++)\n+            {\n+                if (coins.vout[j].IsNull() || coins.vout[j].scriptPubKey.IsUnspendable())\n+                    continue;\n+\n+                const uint160 key = CCoinsViewByScript::getKey(coins.vout[j].scriptPubKey);\n+                if (!mapCoinsByScript.count(key))\n+                {\n+                    CCoinsByScript coinsByScript;\n+                    GetCoinsByHashOfScript(key, coinsByScript);\n+                    mapCoinsByScript.insert(make_pair(key, coinsByScript));\n+                }\n+                mapCoinsByScript[key].setCoins.insert(COutPoint(txhash, (uint32_t)j));\n+                i++;\n+            }\n+\n+            if (mapCoinsByScript.size() >= 10000)\n+            {\n+                CLevelDBBatch batch;\n+                for (CCoinsMapByScript::iterator it = mapCoinsByScript.begin(); it != mapCoinsByScript.end();) {\n+                    BatchWriteCoins(batch, it->first, it->second);\n+                    CCoinsMapByScript::iterator itOld = it++;\n+                    mapCoinsByScript.erase(itOld);\n+                }\n+                db.WriteBatch(batch);\n+                mapCoinsByScript.clear();\n+            }\n+\n+            pcursor->Next();\n+        } catch (std::exception &e) {\n+            return error(\"%s : Deserialize or I/O error - %s\", __func__, e.what());\n+        }\n+    }\n+    if (!mapCoinsByScript.empty())\n+    {\n+       CLevelDBBatch batch;\n+       for (CCoinsMapByScript::iterator it = mapCoinsByScript.begin(); it != mapCoinsByScript.end();) {\n+           BatchWriteCoins(batch, it->first, it->second);\n+           CCoinsMapByScript::iterator itOld = it++;\n+           mapCoinsByScript.erase(itOld);\n+       }\n+       db.WriteBatch(batch);\n+    }\n+    LogPrintf(\"Address index with %d outputs successfully built.\\n\", i);\n     return true;\n }\n "
      },
      {
        "sha": "e76d4a7c0dfdf1a2000283103e9c70d54fbf08c0",
        "filename": "src/txdb.h",
        "status": "modified",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/76e96e19f21e4eb63c9fc00e43f60a322d1e9344/src/txdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/76e96e19f21e4eb63c9fc00e43f60a322d1e9344/src/txdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.h?ref=76e96e19f21e4eb63c9fc00e43f60a322d1e9344",
        "patch": "@@ -7,6 +7,7 @@\n #define BITCOIN_TXDB_H\n \n #include \"coins.h\"\n+#include \"coinsbyscript.h\"\n #include \"leveldbwrapper.h\"\n \n #include <map>\n@@ -29,16 +30,25 @@ static const int64_t nMinDbCache = 4;\n /** CCoinsView backed by the LevelDB coin database (chainstate/) */\n class CCoinsViewDB : public CCoinsView\n {\n+private:\n+    CCoinsViewByScript* pcoinsViewByScript;\n protected:\n     CLevelDBWrapper db;\n public:\n     CCoinsViewDB(size_t nCacheSize, bool fMemory = false, bool fWipe = false);\n \n     bool GetCoins(const uint256 &txid, CCoins &coins) const;\n+    bool GetCoinsByHashOfScript(const uint160 &hash, CCoinsByScript &coins) const;\n     bool HaveCoins(const uint256 &txid) const;\n     uint256 GetBestBlock() const;\n     bool BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock);\n+    bool WriteFlag(const std::string &name, bool fValue);\n+    bool ReadFlag(const std::string &name, bool &fValue);\n     bool GetStats(CCoinsStats &stats) const;\n+    int64_t GetPrefixCount(char prefix) const;\n+    bool DeleteAllCoinsByScript();   // removes txoutsbyaddressindex\n+    bool GenerateAllCoinsByScript(); // creates txoutsbyaddressindex\n+    void SetCoinsViewByScript(CCoinsViewByScript* pcoinsViewByScriptIn);\n };\n \n /** Access to the block database (blocks/index/) */"
      },
      {
        "sha": "6678b9f84a294d613c98ec522e4bb7039e8850ec",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 37,
        "deletions": 2,
        "changes": 39,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/76e96e19f21e4eb63c9fc00e43f60a322d1e9344/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/76e96e19f21e4eb63c9fc00e43f60a322d1e9344/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=76e96e19f21e4eb63c9fc00e43f60a322d1e9344",
        "patch": "@@ -46,8 +46,9 @@ CTxMemPoolEntry::GetPriority(unsigned int currentHeight) const\n     return dResult;\n }\n \n-CTxMemPool::CTxMemPool(const CFeeRate& _minRelayFee) :\n-    nTransactionsUpdated(0)\n+CTxMemPool::CTxMemPool(const CFeeRate& _minRelayFee, const bool& _fTxOutsByAddressIndex) :\n+    nTransactionsUpdated(0),\n+    fTxOutsByAddressIndex(_fTxOutsByAddressIndex)\n {\n     // Sanity checks off by default for performance, because otherwise\n     // accepting transactions becomes O(N^2) where N is the number\n@@ -81,6 +82,17 @@ unsigned int CTxMemPool::GetTransactionsUpdated() const\n     return nTransactionsUpdated;\n }\n \n+void CTxMemPool::GetCoinsByScript(const CScript& script, CCoinsByScript& coinsByScript) const\n+{\n+    LOCK(cs);\n+    CCoinsMapByScript::const_iterator it = mapCoinsByScript.find(CCoinsViewByScript::getKey(script));\n+    if (it != mapCoinsByScript.end())\n+    {\n+        BOOST_FOREACH(const COutPoint &outpoint, it->second.setCoins)\n+            coinsByScript.setCoins.insert(outpoint);\n+    }\n+}\n+\n void CTxMemPool::AddTransactionsUpdated(unsigned int n)\n {\n     LOCK(cs);\n@@ -102,6 +114,11 @@ bool CTxMemPool::addUnchecked(const uint256& hash, const CTxMemPoolEntry &entry,\n     totalTxSize += entry.GetTxSize();\n     minerPolicyEstimator->processTransaction(entry, fCurrentEstimate);\n \n+    if (fTxOutsByAddressIndex)\n+        for (unsigned int i = 0; i < tx.vout.size(); i++)\n+            if (!tx.vout[i].IsNull() && !tx.vout[i].scriptPubKey.IsUnspendable())\n+                mapCoinsByScript[CCoinsViewByScript::getKey(tx.vout[i].scriptPubKey)].setCoins.insert(COutPoint(hash, (uint32_t)i));\n+\n     return true;\n }\n \n@@ -111,6 +128,24 @@ void CTxMemPool::remove(const CTransaction &origTx, std::list<CTransaction>& rem\n     // Remove transaction from memory pool\n     {\n         LOCK(cs);\n+\n+        if (fTxOutsByAddressIndex)\n+        {\n+            for (unsigned int i = 0; i < origTx.vout.size(); i++)\n+            {\n+                if (origTx.vout[i].IsNull() || origTx.vout[i].scriptPubKey.IsUnspendable())\n+                    continue;\n+\n+                CCoinsMapByScript::iterator it = mapCoinsByScript.find(CCoinsViewByScript::getKey(origTx.vout[i].scriptPubKey));\n+                if (it != mapCoinsByScript.end())\n+                {\n+                    it->second.setCoins.erase(COutPoint(origTx.GetHash(), (uint32_t)i));\n+                    if (it->second.setCoins.empty())\n+                        mapCoinsByScript.erase(it);\n+                }\n+            }\n+        }\n+\n         std::deque<uint256> txToRemove;\n         txToRemove.push_back(origTx.GetHash());\n         if (fRecursive && !mapTx.count(origTx.GetHash())) {"
      },
      {
        "sha": "cf5804fd1534b81c6a4b82ee261daae679cca366",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 5,
        "deletions": 1,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/76e96e19f21e4eb63c9fc00e43f60a322d1e9344/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/76e96e19f21e4eb63c9fc00e43f60a322d1e9344/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=76e96e19f21e4eb63c9fc00e43f60a322d1e9344",
        "patch": "@@ -10,6 +10,7 @@\n \n #include \"amount.h\"\n #include \"coins.h\"\n+#include \"coinsbyscript.h\"\n #include \"primitives/transaction.h\"\n #include \"sync.h\"\n \n@@ -93,14 +94,16 @@ class CTxMemPool\n     CBlockPolicyEstimator* minerPolicyEstimator;\n \n     uint64_t totalTxSize; //! sum of all mempool tx' byte sizes\n+    const bool& fTxOutsByAddressIndex;\n+    CCoinsMapByScript mapCoinsByScript; // only used if -txoutsbyaddressindex\n \n public:\n     mutable CCriticalSection cs;\n     std::map<uint256, CTxMemPoolEntry> mapTx;\n     std::map<COutPoint, CInPoint> mapNextTx;\n     std::map<uint256, std::pair<double, CAmount> > mapDeltas;\n \n-    CTxMemPool(const CFeeRate& _minRelayFee);\n+    CTxMemPool(const CFeeRate& _minRelayFee, const bool& _fTxOutsByAddressIndex);\n     ~CTxMemPool();\n \n     /**\n@@ -123,6 +126,7 @@ class CTxMemPool\n     void pruneSpent(const uint256& hash, CCoins &coins);\n     unsigned int GetTransactionsUpdated() const;\n     void AddTransactionsUpdated(unsigned int n);\n+    void GetCoinsByScript(const CScript& script, CCoinsByScript& coinsByScript) const;\n     /**\n      * Check that none of this transactions inputs are in the mempool, and thus\n      * the tx is not dependent on other mempool transactions to be included in a block."
      }
    ]
  }
]