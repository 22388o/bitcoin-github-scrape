[
  {
    "sha": "67f232b5d874b501c114bced5d764db7f4f5ce99",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2N2YyMzJiNWQ4NzRiNTAxYzExNGJjZWQ1ZDc2NGRiN2Y0ZjVjZTk5",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-06-09T20:39:09Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-06-09T20:39:09Z"
      },
      "message": "Squashed 'src/secp256k1/' changes from b19c000063..2ed54da18a\n\n2ed54da18a Merge #755: Recovery signing: add to constant time test, and eliminate non ct operators\n28609507e7 Add tests for the cmov implementations\n73596a85a2 Add ecdsa_sign_recoverable to the ctime tests\n2876af4f8d Split ecdsa_sign logic into a new function and use it from ecdsa_sign and recovery\n5e1c885efb Merge #754: Fix uninit values passed into cmov\nf79a7adcf5 Add valgrind uninit check to cmovs output\n05d315affe Merge #752: autoconf: Use \":\" instead of \"dnl\" as a noop\na39c2b09de Fixed UB(arithmetics on uninit values) in cmovs\n3a6fd7f636 Merge #750: Add macOS to the CI\n5e8747ae2a autoconf: Use \":\" instead of \"dnl\" as a noop\n71757da5cc Explictly pass SECP256K1_BENCH_ITERS to the benchmarks in travis.sh\n99bd661d71 Replace travis_wait with a loop printing \"\\a\" to stdout every minute\nbc818b160c Bump travis Ubuntu from xenial(16.04) to bionic(18.04)\n0c5ff9066e Add macOS support to travis\nb6807d91d8 Move travis script into a standalone sh file\nf39f99be0e Merge #701: Make ec_ arithmetic more consistent and add documentation\n39198a03ea Merge #732: Retry if r is zero during signing\n59a8de8f64 Merge #742: Fix typo in ecmult_const_impl.h\n4e284655d9 Fix typo in ecmult_const_impl.h\nf862b4ca13 Merge #740: Make recovery/main_impl.h non-executable\nffef45c98a Make recovery/main_impl.h non-executable\n2361b3719a Merge #735: build: fix OpenSSL EC detection on macOS\n3b7d26b23c build: add SECP_TEST_INCLUDES to bench_verify CPPFLAGS\n84b5fc5bc3 build: fix OpenSSL EC detection on macOS\n37ed51a7ea Make ecdsa_sig_sign constant-time again after reverting 25e3cfb\n93d343bfc5 Revert \"ecdsa_impl: replace scalar if-checks with VERIFY_CHECKs in ecdsa_sig_sign\"\n7e3952ae82 Clarify documentation of tweak functions.\n89853a0f2e Make tweak function documentation more consistent.\n41fc785602 Make ec_privkey functions aliases for ec_seckey_negate, ec_seckey_tweak_add and ec_seckey_mul\n22911ee6da Rename private key to secret key in public API (with the exception of function names)\n5a73f14d6c Mention that value is unspecified for In/Out parameters if the function returns 0\nf03df0e6d7 Define valid ECDSA keys in the documentation of seckey_verify\n5894e1f1df Return 0 if the given seckey is invalid in privkey_negate, privkey_tweak_add and privkey_tweak_mul\n8f814cddb9 Add test for boundary conditions of scalar_set_b32 with respect to overflows\n3fec982608 Use scalar_set_b32_seckey in ecdsa_sign, pubkey_create and seckey_verify\n9ab2cbe0eb Add scalar_set_b32_seckey which does the same as scalar_set_b32 and also returns whether it's a valid secret key\n4f27e344c6 Merge #728: Suppress a harmless variable-time optimization by clang in memczero\n01993878bb Add test for memczero()\n52a03512c1 Suppress a harmless variable-time optimization by clang in memczero\n8f78e208ad Merge #722: Context isn't freed in the ECDH benchmark\ned1b91171a Merge #700: Allow overriding default flags\n85b35afa76 Add running benchmarks regularly and under valgrind in travis\nca4906b02e Pass num of iters to benchmarks as variable, and define envvar\n02dd5f1bbb free the ctx at the end of bench_ecdh\ne9fccd4de1 Merge #708: Constant-time behaviour test using valgrind memtest.\n08fb6c4926 Run valgrind_ctime_test in travis\n3d2302257f Constant-time behaviour test using valgrind memtest.\n96d8ccbd16 Merge #710: Eliminate harmless non-constant time operations on secret data.\n0585b8b2ee Merge #718: Clarify that a secp256k1_ecdh_hash_function must return 0 or 1\n7b50483ad7 Adds a declassify operation to aid constant-time analysis.\n34a67c773b Eliminate harmless non-constant time operations on secret data.\nca739cba23 Compile with optimization flag -O2 by default instead of -O3\neb45ef3384 Clarify that a secp256k1_ecdh_hash_function must return 0 or 1\n856a01d6ad Merge #714: doc: document the length requirements of output parameter.\nd72b9e2483 Merge #682: Remove Java Native Interface\n4b48a43106 doc: document the length requirements of output parameter.\n1b4d256e2e Merge #713: Docstrings\ndabfea7e21 field: extend docstring of secp256k1_fe_normalize\ndc7d8fd9e2 scalar: extend docstring of secp256k1_scalar_set_b32\n074ab582dd Merge #704: README: add a section for test coverage\nacb7f97eb8 README: add a section for test coverage\n227a4f2d07 Merge #709: Remove secret-dependant non-constant time operation in ecmult_const.\nd567b779fe Clarify comments about use of rzr on ge functions and abs function.\n2241ae6d14 Remove secret-dependant non-constant time operation in ecmult_const.\n642cd062bd Remove Java Native Interface\n83fb1bcef4 Remove -O2 from default CFLAGS because this would override the -O3 flag (see AC_PROG_CC in the Autoconf manual)\necba8138ec Append instead of Prepend user-CFLAGS to default CFLAGS allowing the user to override default variables\n613c34cd86 Remove test in configure.ac because it doesn't have an effect\nf45d897101 Merge #703: Overhaul README.md\n2e759ec753 Overhaul README.md\nd644dda5c9 Merge #689: Remove \"except in benchmarks\" exception for fp math\nbde2a32286 Convert bench.h to fixed-point math\n387d723c3f Merge #679: Add SECURITY.md\n0db61d25c9 Merge #685: Fix issue where travis does not show the ./tests seed\u2026\na0771d15e6 Explicitly disable buffering for stderr in tests\nfb424fbba2 Make travis show the ./tests seed by removing stdout buffering and always cat tests.log after a travis run.\n22a6031184 Merge #690: Add valgrind check to travis\n544002c008 Merge #678: Preventing compiler optimizations in benchmarks without a memory fence\ndd98cc988f travis: Added a valgrind test without endro and enabled recovery+ecdh\nb4c1382a87 Add valgrind check to travis\n0c774d89e6 Merge #688: Fix ASM setting in travis\n5c5f71eea5 Fix ASM setting in travis\ne2625f8a98 Merge #684: Make no-float policy explicit\nbae1bea3c4 Make no-float policy explicit\n78c3836341 Add SECURITY.md\n362bb25608 Modified bench_scalar_split so it won't get optimized out\n73a30c6b58 Added accumulators and checks on benchmarks so they won't get optimized out\n770b3dcd6f Merge #677: Remove note about heap allocation in secp256k1_ecmult_odd_multiples_table_storage_var\nb76142ff25 Remove note about heap allocation in secp256k1_ecmult_odd_multiples_table_storage_var which was removed in 47045270fa90f81205d989f7107769bce1e71c4d\n137d304a6b Merge #647: Increase robustness against UB in secp256k1_scalar_cadd_bit\n0d9540b13f Merge #664: Remove mention of ec_privkey_export because it doesn't exist\n59782c68b4 Remove mention of ec_privkey_export because it doesn't exist\n96cd94e385 Merge #337: variable sized precomputed table for signing\ndcb2e3b3ff variable signing precompute table\nb4bff99028 Merge #661: Make ./configure string consistent\na467047e11 Make ./configure string consistent\ne729cc7f5a Merge #657: Fix a nit in the recovery tests\nb64a2e2597 Fix a nit in the recovery tests\ne028aa33d3 Merge #650: secp256k1/src/tests.c:  Properly handle sscanf return value\nf1e11d363d Merge #654: Fix typo (\u221e)\nef83281c3a Merge pull request #656 from real-or-random/patch-1\n556caad2ca Fix typo in docs for _context_set_illegal_callback\n0d82732a9a Improve VERIFY_CHECK of overflow in secp256k1_scalar_cadd_bit. This added check ensures that any curve order overflow doesn't go undetected due a uint32_t overflow.\n786dfb49f5 Merge #583: JNI: fix use sig array\ne95f8ab098 Merge #644: Avoid optimizing out a verify_check\n384f55606a Merge #652: README.md: update instruction to run tests\nee56accd47 Merge #651: Fix typo in secp256k1_preallocated.h\n7b9b117230 Merge #640: scalar_impl.h: fix includes\nd99bec2e21 Merge #655: jni: Use only Guava for hex encoding and decoding\n2abcf951af jni: Use only Guava for hex encoding and decoding\n271582b3b7 Fix typo\nce6d438266 README.md: update instruction to run tests\nb1e68cb8e6 Fix typo in secp256k1_preallocated.h\na11c76c59a secp256k1/src/tests.c:  Properly handle sscanf return value\n8fe63e5654 Increase robustness against UB. Thanks to elichai2 who noted that the literal '1' is a signed integer, and that shifting a signed 32-bit integer by 31 bits causes an overflow and yields undefined behaviour. While 'scalar_low_impl''s 'secp256k1_scalar_cadd_bit' is only used for testing purposes and currently the 'bit' parameter is only 0 or 1, it is better to avoid undefined behaviour in case the used domain of 'secp256k1_scalar_cadd_bit' expands.\n94ae7cbf83 Moved a dereference so the null check will be before the dereferencing\n2cb73b1064 scalar_impl.h: fix includes\nfa33017135 Merge #634: Add a descriptive comment for secp256k1_ecmult_const.\nee9e68cd30 Add a descriptive comment for secp256k1_ecmult_const.\nd0d738d32d Merge #631: typo in comment for secp256k1_ec_pubkey_tweak_mul ()\n6914c25276 typo in comment for secp256k1_ec_pubkey_tweak_mul ()\ne541a90ef6 Merge #629: Avoid calling _is_zero when _set_b32 fails.\nf34b0c3f35 Merge #630: Note intention of timing sidechannel freeness.\n8d1563b0ff Note intention of timing sidechannel freeness.\n1669bb2865 Merge #628: Fix ability to compile tests without -DVERIFY.\necc94abcc8 Merge #627: Guard memcmp in tests against mixed size inputs.\n544435fc90 Merge #578: Avoid implementation-defined and undefined behavior when dealing with sizes\n143dc6e9ee Merge #595: Allow to use external default callbacks\ne49f7991c2 Add missing #(un)defines to base-config.h\n77defd2c3b Add secp256k1_ prefix to default callback functions\n908bdce64e Include stdio.h and stdlib.h explicitly in secp256k1.c\n5db782e655 Allow usage of external default callbacks\n6095a863fa Replace CHECKs for no_precomp ctx by ARG_CHECKs without a return\ncd473e02c3 Avoid calling secp256k1_*_is_zero when secp256k1_*_set_b32 fails.\n6c36de7a33 Merge #600: scratch space: use single allocation\n98836b11f0 scratch: replace frames with \"checkpoint\" system\n7623cf2b97 scratch: save a couple bytes of unnecessarily-allocated memory\na7a164f2c6 scratch: rename `max_size` to `size`, document that extra will actually be allocated\n5a4bc0bb95 scratch: unify allocations\nc2b028a281 scratch space: thread `error_callback` into all scratch space functions\n0be1a4ae62 scratch: add magic bytes to beginning of structure\n92a48a764d scratch space: use single allocation\n40839e21b9 Merge #592: Use trivial algorithm in ecmult_multi if scratch space is small\ndcf392027b Fix ability to compile tests without -DVERIFY.\na484e0008b Merge #566: Enable context creation in preallocated memory\n0522caac8f Explain caller's obligations for preallocated memory\n238305fdbb Move _preallocated functions to separate header\n695feb6fbd Export _preallocated functions\n814cc78d71 Add tests for contexts in preallocated memory\nba12dd08da Check arguments of _preallocated functions\n5feadde462 Support cloning a context into preallocated memory\nc4fd5dab45 Switch to a single malloc call\nef020de16f Add size constants for preallocated memory\n1bf7c056ba Prepare for manual memory management in preallocated memory\n248bffb052 Guard memcmp in tests against mixed size inputs.\n36698dcfee Merge #596: Make WINDOW_G configurable\na61a93ff50 Clean up ./configure help strings\n2842dc523e Make WINDOW_G configurable\n1a02d6ce51 Merge #626: Revert \"Merge #620: Install headers automatically\"\n662918cb29 Revert \"Merge #620: Install headers automatically\"\n14c7dbd444 Simplify control flow in DER parsing\nec8f20babd Avoid out-of-bound pointers and integer overflows in size comparisons\n01ee1b3b3c Parse DER-enconded length into a size_t instead of an int\n912680ed86 Merge #561: Respect LDFLAGS and #undef STATIC_PRECOMPUTATION if using basic config\n91fae3ace0 Merge #620: Install headers automatically\n5df77a0eda Merge #533: Make sure we're not using an uninitialized variable in secp256k1_wnaf_const(...)\n975e51e0d9 Merge #617: Pass scalar by reference in secp256k1_wnaf_const()\n735fbde04e Merge #619: Clear a copied secret key after negation\n16e86150d0 Install headers automatically\n069870d92a Clear a copied secret key after negation\n8979ec0d9a Pass scalar by reference in secp256k1_wnaf_const()\n84a808598b Merge #612: Allow field_10x26_arm.s to compile for ARMv7 architecture\nd4d270a59c Allow field_10x26_arm.s to compile for ARMv7 architecture\n248f046611 Make sure we're not using an uninitialized variable in secp256k1_wnaf_const(...)\n9ab96f7b12 Use trivial algorithm in ecmult_multi if scratch space is small\ndbed75d969 Undefine `STATIC_PRECOMPUTATION` if using the basic config\n310111e093 Keep LDFLAGS if `--coverage`\n74e2dbd68e JNI: fix use sig array\n3cb057f842 Fix possible integer overflow in DER parsing\n\ngit-subtree-dir: src/secp256k1\ngit-subtree-split: 2ed54da18add295668ec71c91534b640d2cc029b",
      "tree": {
        "sha": "8ea0c31c64dfe0dd8f6f775c444cd22ef94d17cc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8ea0c31c64dfe0dd8f6f775c444cd22ef94d17cc"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/67f232b5d874b501c114bced5d764db7f4f5ce99",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/67f232b5d874b501c114bced5d764db7f4f5ce99",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/67f232b5d874b501c114bced5d764db7f4f5ce99",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/67f232b5d874b501c114bced5d764db7f4f5ce99/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "54245985fb3c89d72e285c4db39d38ed2f5fb0de",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/54245985fb3c89d72e285c4db39d38ed2f5fb0de",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/54245985fb3c89d72e285c4db39d38ed2f5fb0de"
      }
    ],
    "stats": {
      "total": 4828,
      "additions": 2392,
      "deletions": 2436
    },
    "files": [
      {
        "sha": "cb4331aa90a2a212fc1473dc8fea50354554fd2a",
        "filename": ".gitignore",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67f232b5d874b501c114bced5d764db7f4f5ce99/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67f232b5d874b501c114bced5d764db7f4f5ce99/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.gitignore?ref=67f232b5d874b501c114bced5d764db7f4f5ce99",
        "patch": "@@ -9,6 +9,7 @@ bench_internal\n tests\n exhaustive_tests\n gen_context\n+valgrind_ctime_test\n *.exe\n *.so\n *.a"
      },
      {
        "sha": "a6ad6fb27eaa488229c25748c21928518adc2c02",
        "filename": ".travis.yml",
        "status": "modified",
        "additions": 56,
        "deletions": 16,
        "changes": 72,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67f232b5d874b501c114bced5d764db7f4f5ce99/.travis.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67f232b5d874b501c114bced5d764db7f4f5ce99/.travis.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.travis.yml?ref=67f232b5d874b501c114bced5d764db7f4f5ce99",
        "patch": "@@ -1,18 +1,23 @@\n language: c\n-os: linux\n+os:\n+  - linux\n+  - osx\n+\n+dist: bionic\n+# Valgrind currently supports upto macOS 10.13, the latest xcode of that version is 10.1\n+osx_image: xcode10.1\n addons:\n   apt:\n-    packages: libgmp-dev\n+    packages:\n+      - libgmp-dev\n+      - valgrind\n+      - libtool-bin\n compiler:\n   - clang\n   - gcc\n-cache:\n-  directories:\n-  - src/java/guava/\n env:\n   global:\n-    - FIELD=auto  BIGNUM=auto  SCALAR=auto  ENDOMORPHISM=no  STATICPRECOMPUTATION=yes  ASM=no  BUILD=check  EXTRAFLAGS=  HOST=  ECDH=no  RECOVERY=no  EXPERIMENTAL=no  JNI=no\n-    - GUAVA_URL=https://search.maven.org/remotecontent?filepath=com/google/guava/guava/18.0/guava-18.0.jar GUAVA_JAR=src/java/guava/guava-18.0.jar\n+    - FIELD=auto  BIGNUM=auto  SCALAR=auto  ENDOMORPHISM=no  STATICPRECOMPUTATION=yes  ECMULTGENPRECISION=auto  ASM=no  BUILD=check  EXTRAFLAGS=  HOST=  ECDH=no  RECOVERY=no  EXPERIMENTAL=no CTIMETEST=yes BENCH=yes ITERS=2\n   matrix:\n     - SCALAR=32bit    RECOVERY=yes\n     - SCALAR=32bit    FIELD=32bit       ECDH=yes  EXPERIMENTAL=yes\n@@ -26,43 +31,78 @@ env:\n     - BIGNUM=no\n     - BIGNUM=no       ENDOMORPHISM=yes RECOVERY=yes EXPERIMENTAL=yes\n     - BIGNUM=no       STATICPRECOMPUTATION=no\n-    - BUILD=distcheck\n-    - EXTRAFLAGS=CPPFLAGS=-DDETERMINISTIC\n-    - EXTRAFLAGS=CFLAGS=-O0\n-    - BUILD=check-java JNI=yes ECDH=yes EXPERIMENTAL=yes\n+    - BUILD=distcheck CTIMETEST= BENCH=\n+    - CPPFLAGS=-DDETERMINISTIC\n+    - CFLAGS=-O0 CTIMETEST=\n+    - ECMULTGENPRECISION=2\n+    - ECMULTGENPRECISION=8\n+    - VALGRIND=yes ENDOMORPHISM=yes BIGNUM=no ASM=x86_64 EXPERIMENTAL=yes ECDH=yes  RECOVERY=yes EXTRAFLAGS=\"--disable-openssl-tests\" CPPFLAGS=-DVALGRIND BUILD=\n+    - VALGRIND=yes                  BIGNUM=no ASM=x86_64 EXPERIMENTAL=yes ECDH=yes  RECOVERY=yes EXTRAFLAGS=\"--disable-openssl-tests\" CPPFLAGS=-DVALGRIND BUILD=\n matrix:\n   fast_finish: true\n   include:\n     - compiler: clang\n+      os: linux\n       env: HOST=i686-linux-gnu ENDOMORPHISM=yes\n       addons:\n         apt:\n           packages:\n             - gcc-multilib\n             - libgmp-dev:i386\n+            - valgrind\n+            - libtool-bin\n+            - libc6-dbg:i386\n     - compiler: clang\n       env: HOST=i686-linux-gnu\n+      os: linux\n       addons:\n         apt:\n           packages:\n             - gcc-multilib\n+            - valgrind\n+            - libtool-bin\n+            - libc6-dbg:i386\n     - compiler: gcc\n       env: HOST=i686-linux-gnu ENDOMORPHISM=yes\n+      os: linux\n       addons:\n         apt:\n           packages:\n             - gcc-multilib\n+            - valgrind\n+            - libtool-bin\n+            - libc6-dbg:i386\n     - compiler: gcc\n+      os: linux\n       env: HOST=i686-linux-gnu\n       addons:\n         apt:\n           packages:\n             - gcc-multilib\n             - libgmp-dev:i386\n-before_install: mkdir -p `dirname $GUAVA_JAR`\n-install: if [ ! -f $GUAVA_JAR ]; then wget $GUAVA_URL -O $GUAVA_JAR; fi\n+            - valgrind\n+            - libtool-bin\n+            - libc6-dbg:i386\n+\n+# We use this to install macOS dependencies instead of the built in `homebrew` plugin,\n+# because in xcode earlier than 11 they have a bug requiring updating the system which overall takes ~8 minutes.\n+# https://travis-ci.community/t/macos-build-fails-because-of-homebrew-bundle-unknown-command/7296\n+before_install:\n+ - if [ \"${TRAVIS_OS_NAME}\" = \"osx\" ]; then HOMEBREW_NO_AUTO_UPDATE=1 brew install gmp valgrind gcc@9; fi\n+\n before_script: ./autogen.sh\n+\n+# travis auto terminates jobs that go for 10 minutes without printing to stdout, but travis_wait doesn't work well with forking programs like valgrind (https://docs.travis-ci.com/user/common-build-problems/#build-times-out-because-no-output-was-received https://github.com/bitcoin-core/secp256k1/pull/750#issuecomment-623476860)\n script:\n- - if [ -n \"$HOST\" ]; then export USE_HOST=\"--host=$HOST\"; fi\n- - if [ \"x$HOST\" = \"xi686-linux-gnu\" ]; then export CC=\"$CC -m32\"; fi\n- - ./configure --enable-experimental=$EXPERIMENTAL --enable-endomorphism=$ENDOMORPHISM --with-field=$FIELD --with-bignum=$BIGNUM --with-scalar=$SCALAR --enable-ecmult-static-precomputation=$STATICPRECOMPUTATION --enable-module-ecdh=$ECDH --enable-module-recovery=$RECOVERY --enable-jni=$JNI $EXTRAFLAGS $USE_HOST && make -j2 $BUILD\n+  - function keep_alive() { while true; do echo -en \"\\a\"; sleep 60; done }\n+  - keep_alive &\n+  - ./contrib/travis.sh\n+  - kill %keep_alive\n+\n+after_script:\n+    - cat ./tests.log\n+    - cat ./exhaustive_tests.log\n+    - cat ./valgrind_ctime_test.log\n+    - cat ./bench.log\n+    - $CC --version\n+    - valgrind --version"
      },
      {
        "sha": "d8c1c79e8cba096b83a9362ce8e62ed04e9a8ad2",
        "filename": "Makefile.am",
        "status": "modified",
        "additions": 17,
        "deletions": 45,
        "changes": 62,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67f232b5d874b501c114bced5d764db7f4f5ce99/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67f232b5d874b501c114bced5d764db7f4f5ce99/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/Makefile.am?ref=67f232b5d874b501c114bced5d764db7f4f5ce99",
        "patch": "@@ -1,13 +1,8 @@\n ACLOCAL_AMFLAGS = -I build-aux/m4\n \n lib_LTLIBRARIES = libsecp256k1.la\n-if USE_JNI\n-JNI_LIB = libsecp256k1_jni.la\n-noinst_LTLIBRARIES = $(JNI_LIB)\n-else\n-JNI_LIB =\n-endif\n include_HEADERS = include/secp256k1.h\n+include_HEADERS += include/secp256k1_preallocated.h\n noinst_HEADERS =\n noinst_HEADERS += src/scalar.h\n noinst_HEADERS += src/scalar_4x64.h\n@@ -39,8 +34,6 @@ noinst_HEADERS += src/field_5x52.h\n noinst_HEADERS += src/field_5x52_impl.h\n noinst_HEADERS += src/field_5x52_int128_impl.h\n noinst_HEADERS += src/field_5x52_asm_impl.h\n-noinst_HEADERS += src/java/org_bitcoin_NativeSecp256k1.h\n-noinst_HEADERS += src/java/org_bitcoin_Secp256k1Context.h\n noinst_HEADERS += src/util.h\n noinst_HEADERS += src/scratch.h\n noinst_HEADERS += src/scratch_impl.h\n@@ -74,16 +67,19 @@ endif\n \n libsecp256k1_la_SOURCES = src/secp256k1.c\n libsecp256k1_la_CPPFLAGS = -DSECP256K1_BUILD -I$(top_srcdir)/include -I$(top_srcdir)/src $(SECP_INCLUDES)\n-libsecp256k1_la_LIBADD = $(JNI_LIB) $(SECP_LIBS) $(COMMON_LIB)\n+libsecp256k1_la_LIBADD = $(SECP_LIBS) $(COMMON_LIB)\n \n-libsecp256k1_jni_la_SOURCES  = src/java/org_bitcoin_NativeSecp256k1.c src/java/org_bitcoin_Secp256k1Context.c\n-libsecp256k1_jni_la_CPPFLAGS = -DSECP256K1_BUILD $(JNI_INCLUDES)\n+if VALGRIND_ENABLED\n+libsecp256k1_la_CPPFLAGS += -DVALGRIND\n+endif\n \n noinst_PROGRAMS =\n if USE_BENCHMARK\n noinst_PROGRAMS += bench_verify bench_sign bench_internal bench_ecmult\n bench_verify_SOURCES = src/bench_verify.c\n bench_verify_LDADD = libsecp256k1.la $(SECP_LIBS) $(SECP_TEST_LIBS) $(COMMON_LIB)\n+# SECP_TEST_INCLUDES are only used here for CRYPTO_CPPFLAGS\n+bench_verify_CPPFLAGS = -DSECP256K1_BUILD $(SECP_TEST_INCLUDES)\n bench_sign_SOURCES = src/bench_sign.c\n bench_sign_LDADD = libsecp256k1.la $(SECP_LIBS) $(SECP_TEST_LIBS) $(COMMON_LIB)\n bench_internal_SOURCES = src/bench_internal.c\n@@ -99,6 +95,12 @@ if USE_TESTS\n noinst_PROGRAMS += tests\n tests_SOURCES = src/tests.c\n tests_CPPFLAGS = -DSECP256K1_BUILD -I$(top_srcdir)/src -I$(top_srcdir)/include $(SECP_INCLUDES) $(SECP_TEST_INCLUDES)\n+if VALGRIND_ENABLED\n+tests_CPPFLAGS += -DVALGRIND\n+noinst_PROGRAMS += valgrind_ctime_test\n+valgrind_ctime_test_SOURCES = src/valgrind_ctime_test.c\n+valgrind_ctime_test_LDADD = libsecp256k1.la $(SECP_LIBS) $(SECP_TEST_LIBS) $(COMMON_LIB)\n+endif\n if !ENABLE_COVERAGE\n tests_CPPFLAGS += -DVERIFY\n endif\n@@ -119,42 +121,12 @@ exhaustive_tests_LDFLAGS = -static\n TESTS += exhaustive_tests\n endif\n \n-JAVAROOT=src/java\n-JAVAORG=org/bitcoin\n-JAVA_GUAVA=$(srcdir)/$(JAVAROOT)/guava/guava-18.0.jar\n-CLASSPATH_ENV=CLASSPATH=$(JAVA_GUAVA)\n-JAVA_FILES= \\\n-  $(JAVAROOT)/$(JAVAORG)/NativeSecp256k1.java \\\n-  $(JAVAROOT)/$(JAVAORG)/NativeSecp256k1Test.java \\\n-  $(JAVAROOT)/$(JAVAORG)/NativeSecp256k1Util.java \\\n-  $(JAVAROOT)/$(JAVAORG)/Secp256k1Context.java\n-\n-if USE_JNI\n-\n-$(JAVA_GUAVA):\n-\t@echo Guava is missing. Fetch it via: \\\n-\twget https://search.maven.org/remotecontent?filepath=com/google/guava/guava/18.0/guava-18.0.jar -O $(@)\n-\t@false\n-\n-.stamp-java: $(JAVA_FILES)\n-\t@echo   Compiling $^\n-\t$(AM_V_at)$(CLASSPATH_ENV) javac $^\n-\t@touch $@\n-\n-if USE_TESTS\n-\n-check-java: libsecp256k1.la $(JAVA_GUAVA) .stamp-java\n-\t$(AM_V_at)java -Djava.library.path=\"./:./src:./src/.libs:.libs/\" -cp \"$(JAVA_GUAVA):$(JAVAROOT)\" $(JAVAORG)/NativeSecp256k1Test\n-\n-endif\n-endif\n-\n if USE_ECMULT_STATIC_PRECOMPUTATION\n-CPPFLAGS_FOR_BUILD +=-I$(top_srcdir)\n+CPPFLAGS_FOR_BUILD +=-I$(top_srcdir) -I$(builddir)/src\n \n gen_context_OBJECTS = gen_context.o\n gen_context_BIN = gen_context$(BUILD_EXEEXT)\n-gen_%.o: src/gen_%.c\n+gen_%.o: src/gen_%.c src/libsecp256k1-config.h\n \t$(CC_FOR_BUILD) $(CPPFLAGS_FOR_BUILD) $(CFLAGS_FOR_BUILD) -c $< -o $@\n \n $(gen_context_BIN): $(gen_context_OBJECTS)\n@@ -168,10 +140,10 @@ $(bench_ecmult_OBJECTS): src/ecmult_static_context.h\n src/ecmult_static_context.h: $(gen_context_BIN)\n \t./$(gen_context_BIN)\n \n-CLEANFILES = $(gen_context_BIN) src/ecmult_static_context.h $(JAVAROOT)/$(JAVAORG)/*.class .stamp-java\n+CLEANFILES = $(gen_context_BIN) src/ecmult_static_context.h\n endif\n \n-EXTRA_DIST = autogen.sh src/gen_context.c src/basic-config.h $(JAVA_FILES)\n+EXTRA_DIST = autogen.sh src/gen_context.c src/basic-config.h\n \n if ENABLE_MODULE_ECDH\n include src/modules/ecdh/Makefile.am.include"
      },
      {
        "sha": "434178b372839b56a3b4b0dee2568ea57c05142c",
        "filename": "README.md",
        "status": "modified",
        "additions": 54,
        "deletions": 11,
        "changes": 65,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67f232b5d874b501c114bced5d764db7f4f5ce99/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67f232b5d874b501c114bced5d764db7f4f5ce99/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/README.md?ref=67f232b5d874b501c114bced5d764db7f4f5ce99",
        "patch": "@@ -3,17 +3,22 @@ libsecp256k1\n \n [![Build Status](https://travis-ci.org/bitcoin-core/secp256k1.svg?branch=master)](https://travis-ci.org/bitcoin-core/secp256k1)\n \n-Optimized C library for EC operations on curve secp256k1.\n+Optimized C library for ECDSA signatures and secret/public key operations on curve secp256k1.\n \n-This library is a work in progress and is being used to research best practices. Use at your own risk.\n+This library is intended to be the highest quality publicly available library for cryptography on the secp256k1 curve. However, the primary focus of its development has been for usage in the Bitcoin system and usage unlike Bitcoin's may be less well tested, verified, or suffer from a less well thought out interface. Correct usage requires some care and consideration that the library is fit for your application's purpose.\n \n Features:\n * secp256k1 ECDSA signing/verification and key generation.\n-* Adding/multiplying private/public keys.\n-* Serialization/parsing of private keys, public keys, signatures.\n-* Constant time, constant memory access signing and pubkey generation.\n-* Derandomized DSA (via RFC6979 or with a caller provided function.)\n+* Additive and multiplicative tweaking of secret/public keys.\n+* Serialization/parsing of secret keys, public keys, signatures.\n+* Constant time, constant memory access signing and public key generation.\n+* Derandomized ECDSA (via RFC6979 or with a caller provided function.)\n * Very efficient implementation.\n+* Suitable for embedded systems.\n+* Optional module for public key recovery.\n+* Optional module for ECDH key exchange (experimental).\n+\n+Experimental features have not received enough scrutiny to satisfy the standard of quality of this library but are made available for testing and review by the community. The APIs of these features should not be considered stable.\n \n Implementation details\n ----------------------\n@@ -23,11 +28,12 @@ Implementation details\n   * Extensive testing infrastructure.\n   * Structured to facilitate review and analysis.\n   * Intended to be portable to any system with a C89 compiler and uint64_t support.\n+  * No use of floating types.\n   * Expose only higher level interfaces to minimize the API surface and improve application security. (\"Be difficult to use insecurely.\")\n * Field operations\n   * Optimized implementation of arithmetic modulo the curve's field size (2^256 - 0x1000003D1).\n     * Using 5 52-bit limbs (including hand-optimized assembly for x86_64, by Diederik Huys).\n-    * Using 10 26-bit limbs.\n+    * Using 10 26-bit limbs (including hand-optimized assembly for 32-bit ARM, by Wladimir J. van der Laan).\n   * Field inverses and square roots using a sliding window over blocks of 1s (by Peter Dettman).\n * Scalar operations\n   * Optimized implementation without data-dependent branches of arithmetic modulo the curve's order.\n@@ -45,9 +51,11 @@ Implementation details\n   * Optionally (off by default) use secp256k1's efficiently-computable endomorphism to split the P multiplicand into 2 half-sized ones.\n * Point multiplication for signing\n   * Use a precomputed table of multiples of powers of 16 multiplied with the generator, so general multiplication becomes a series of additions.\n-  * Access the table with branch-free conditional moves so memory access is uniform.\n-  * No data-dependent branches\n-  * The precomputed tables add and eventually subtract points for which no known scalar (private key) is known, preventing even an attacker with control over the private key used to control the data internally.\n+  * Intended to be completely free of timing sidechannels for secret-key operations (on reasonable hardware/toolchains)\n+    * Access the table with branch-free conditional moves so memory access is uniform.\n+    * No data-dependent branches\n+  * Optional runtime blinding which attempts to frustrate differential power analysis.\n+  * The precomputed tables add and eventually subtract points for which no known scalar (secret key) is known, preventing even an attacker with control over the secret key used to control the data internally.\n \n Build steps\n -----------\n@@ -57,5 +65,40 @@ libsecp256k1 is built using autotools:\n     $ ./autogen.sh\n     $ ./configure\n     $ make\n-    $ ./tests\n+    $ make check\n     $ sudo make install  # optional\n+\n+Exhaustive tests\n+-----------\n+\n+    $ ./exhaustive_tests\n+\n+With valgrind, you might need to increase the max stack size:\n+\n+    $ valgrind --max-stackframe=2500000 ./exhaustive_tests\n+\n+Test coverage\n+-----------\n+\n+This library aims to have full coverage of the reachable lines and branches.\n+\n+To create a test coverage report, configure with `--enable-coverage` (use of GCC is necessary):\n+\n+    $ ./configure --enable-coverage\n+\n+Run the tests:\n+\n+    $ make check\n+\n+To create a report, `gcovr` is recommended, as it includes branch coverage reporting:\n+\n+    $ gcovr --exclude 'src/bench*' --print-summary\n+\n+To create a HTML report with coloured and annotated source code:\n+\n+    $ gcovr --exclude 'src/bench*' --html --html-details -o coverage.html\n+\n+Reporting a vulnerability\n+------------\n+\n+See [SECURITY.md](SECURITY.md)"
      },
      {
        "sha": "0e4d588030274e4a31c773e74dc196637f612259",
        "filename": "SECURITY.md",
        "status": "added",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67f232b5d874b501c114bced5d764db7f4f5ce99/SECURITY.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67f232b5d874b501c114bced5d764db7f4f5ce99/SECURITY.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/SECURITY.md?ref=67f232b5d874b501c114bced5d764db7f4f5ce99",
        "patch": "@@ -0,0 +1,15 @@\n+# Security Policy\n+\n+## Reporting a Vulnerability\n+\n+To report security issues send an email to secp256k1-security@bitcoincore.org (not for support).\n+\n+The following keys may be used to communicate sensitive information to developers:\n+\n+| Name | Fingerprint |\n+|------|-------------|\n+| Pieter Wuille | 133E AC17 9436 F14A 5CF1  B794 860F EB80 4E66 9320 |\n+| Andrew Poelstra | 699A 63EF C17A D3A9 A34C  FFC0 7AD0 A91C 40BD 0091 |\n+| Tim Ruffing | 09E0 3F87 1092 E40E 106E  902B 33BC 86AB 80FF 5516 |\n+\n+You can import a key by running the following command with that individual\u2019s fingerprint: `gpg --recv-keys \"<fingerprint>\"` Ensure that you put quotes around fingerprints containing spaces."
      },
      {
        "sha": "cdc78d87d48b09d45830e47a70f59219c3fee2ce",
        "filename": "build-aux/m4/ax_jni_include_dir.m4",
        "status": "removed",
        "additions": 0,
        "deletions": 145,
        "changes": 145,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54245985fb3c89d72e285c4db39d38ed2f5fb0de/build-aux/m4/ax_jni_include_dir.m4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54245985fb3c89d72e285c4db39d38ed2f5fb0de/build-aux/m4/ax_jni_include_dir.m4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build-aux/m4/ax_jni_include_dir.m4?ref=54245985fb3c89d72e285c4db39d38ed2f5fb0de",
        "patch": "@@ -1,145 +0,0 @@\n-# ===========================================================================\n-#    https://www.gnu.org/software/autoconf-archive/ax_jni_include_dir.html\n-# ===========================================================================\n-#\n-# SYNOPSIS\n-#\n-#   AX_JNI_INCLUDE_DIR\n-#\n-# DESCRIPTION\n-#\n-#   AX_JNI_INCLUDE_DIR finds include directories needed for compiling\n-#   programs using the JNI interface.\n-#\n-#   JNI include directories are usually in the Java distribution. This is\n-#   deduced from the value of $JAVA_HOME, $JAVAC, or the path to \"javac\", in\n-#   that order. When this macro completes, a list of directories is left in\n-#   the variable JNI_INCLUDE_DIRS.\n-#\n-#   Example usage follows:\n-#\n-#     AX_JNI_INCLUDE_DIR\n-#\n-#     for JNI_INCLUDE_DIR in $JNI_INCLUDE_DIRS\n-#     do\n-#             CPPFLAGS=\"$CPPFLAGS -I$JNI_INCLUDE_DIR\"\n-#     done\n-#\n-#   If you want to force a specific compiler:\n-#\n-#   - at the configure.in level, set JAVAC=yourcompiler before calling\n-#   AX_JNI_INCLUDE_DIR\n-#\n-#   - at the configure level, setenv JAVAC\n-#\n-#   Note: This macro can work with the autoconf M4 macros for Java programs.\n-#   This particular macro is not part of the original set of macros.\n-#\n-# LICENSE\n-#\n-#   Copyright (c) 2008 Don Anderson <dda@sleepycat.com>\n-#\n-#   Copying and distribution of this file, with or without modification, are\n-#   permitted in any medium without royalty provided the copyright notice\n-#   and this notice are preserved. This file is offered as-is, without any\n-#   warranty.\n-\n-#serial 14\n-\n-AU_ALIAS([AC_JNI_INCLUDE_DIR], [AX_JNI_INCLUDE_DIR])\n-AC_DEFUN([AX_JNI_INCLUDE_DIR],[\n-\n-JNI_INCLUDE_DIRS=\"\"\n-\n-if test \"x$JAVA_HOME\" != x; then\n-\t_JTOPDIR=\"$JAVA_HOME\"\n-else\n-\tif test \"x$JAVAC\" = x; then\n-\t\tJAVAC=javac\n-\tfi\n-\tAC_PATH_PROG([_ACJNI_JAVAC], [$JAVAC], [no])\n-\tif test \"x$_ACJNI_JAVAC\" = xno; then\n-\t\tAC_MSG_WARN([cannot find JDK; try setting \\$JAVAC or \\$JAVA_HOME])\n-\tfi\n-\t_ACJNI_FOLLOW_SYMLINKS(\"$_ACJNI_JAVAC\")\n-\t_JTOPDIR=`echo \"$_ACJNI_FOLLOWED\" | sed -e 's://*:/:g' -e 's:/[[^/]]*$::'`\n-fi\n-\n-case \"$host_os\" in\n-        darwin*)        # Apple Java headers are inside the Xcode bundle.\n-            macos_version=$(sw_vers -productVersion | sed -n -e 's/^@<:@0-9@:>@*.\\(@<:@0-9@:>@*\\).@<:@0-9@:>@*/\\1/p')\n-            if @<:@ \"$macos_version\" -gt \"7\" @:>@; then\n-                _JTOPDIR=\"$(xcrun --show-sdk-path)/System/Library/Frameworks/JavaVM.framework\"\n-                _JINC=\"$_JTOPDIR/Headers\"\n-            else\n-                _JTOPDIR=\"/System/Library/Frameworks/JavaVM.framework\"\n-                _JINC=\"$_JTOPDIR/Headers\"\n-            fi\n-            ;;\n-        *) _JINC=\"$_JTOPDIR/include\";;\n-esac\n-_AS_ECHO_LOG([_JTOPDIR=$_JTOPDIR])\n-_AS_ECHO_LOG([_JINC=$_JINC])\n-\n-# On Mac OS X 10.6.4, jni.h is a symlink:\n-# /System/Library/Frameworks/JavaVM.framework/Versions/Current/Headers/jni.h\n-# -> ../../CurrentJDK/Headers/jni.h.\n-AC_CACHE_CHECK(jni headers, ac_cv_jni_header_path,\n-[\n-  if test -f \"$_JINC/jni.h\"; then\n-    ac_cv_jni_header_path=\"$_JINC\"\n-    JNI_INCLUDE_DIRS=\"$JNI_INCLUDE_DIRS $ac_cv_jni_header_path\"\n-  else\n-    _JTOPDIR=`echo \"$_JTOPDIR\" | sed -e 's:/[[^/]]*$::'`\n-    if test -f \"$_JTOPDIR/include/jni.h\"; then\n-      ac_cv_jni_header_path=\"$_JTOPDIR/include\"\n-      JNI_INCLUDE_DIRS=\"$JNI_INCLUDE_DIRS $ac_cv_jni_header_path\"\n-    else\n-      ac_cv_jni_header_path=none\n-    fi\n-  fi\n-])\n-\n-# get the likely subdirectories for system specific java includes\n-case \"$host_os\" in\n-bsdi*)          _JNI_INC_SUBDIRS=\"bsdos\";;\n-freebsd*)       _JNI_INC_SUBDIRS=\"freebsd\";;\n-darwin*)        _JNI_INC_SUBDIRS=\"darwin\";;\n-linux*)         _JNI_INC_SUBDIRS=\"linux genunix\";;\n-osf*)           _JNI_INC_SUBDIRS=\"alpha\";;\n-solaris*)       _JNI_INC_SUBDIRS=\"solaris\";;\n-mingw*)\t\t_JNI_INC_SUBDIRS=\"win32\";;\n-cygwin*)\t_JNI_INC_SUBDIRS=\"win32\";;\n-*)              _JNI_INC_SUBDIRS=\"genunix\";;\n-esac\n-\n-if test \"x$ac_cv_jni_header_path\" != \"xnone\"; then\n-  # add any subdirectories that are present\n-  for JINCSUBDIR in $_JNI_INC_SUBDIRS\n-  do\n-    if test -d \"$_JTOPDIR/include/$JINCSUBDIR\"; then\n-         JNI_INCLUDE_DIRS=\"$JNI_INCLUDE_DIRS $_JTOPDIR/include/$JINCSUBDIR\"\n-    fi\n-  done\n-fi\n-])\n-\n-# _ACJNI_FOLLOW_SYMLINKS <path>\n-# Follows symbolic links on <path>,\n-# finally setting variable _ACJNI_FOLLOWED\n-# ----------------------------------------\n-AC_DEFUN([_ACJNI_FOLLOW_SYMLINKS],[\n-# find the include directory relative to the javac executable\n-_cur=\"$1\"\n-while ls -ld \"$_cur\" 2>/dev/null | grep \" -> \" >/dev/null; do\n-        AC_MSG_CHECKING([symlink for $_cur])\n-        _slink=`ls -ld \"$_cur\" | sed 's/.* -> //'`\n-        case \"$_slink\" in\n-        /*) _cur=\"$_slink\";;\n-        # 'X' avoids triggering unwanted echo options.\n-        *) _cur=`echo \"X$_cur\" | sed -e 's/^X//' -e 's:[[^/]]*$::'`\"$_slink\";;\n-        esac\n-        AC_MSG_RESULT([$_cur])\n-done\n-_ACJNI_FOLLOWED=\"$_cur\"\n-])# _ACJNI"
      },
      {
        "sha": "1b2b71e6abaffd62323cf3f6f7ec903af5b82421",
        "filename": "build-aux/m4/bitcoin_secp.m4",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67f232b5d874b501c114bced5d764db7f4f5ce99/build-aux/m4/bitcoin_secp.m4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67f232b5d874b501c114bced5d764db7f4f5ce99/build-aux/m4/bitcoin_secp.m4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build-aux/m4/bitcoin_secp.m4?ref=67f232b5d874b501c114bced5d764db7f4f5ce99",
        "patch": "@@ -38,6 +38,8 @@ AC_DEFUN([SECP_OPENSSL_CHECK],[\n   fi\n if test x\"$has_libcrypto\" = x\"yes\" && test x\"$has_openssl_ec\" = x; then\n   AC_MSG_CHECKING(for EC functions in libcrypto)\n+  CPPFLAGS_TEMP=\"$CPPFLAGS\"\n+  CPPFLAGS=\"$CRYPTO_CPPFLAGS $CPPFLAGS\"\n   AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n     #include <openssl/ec.h>\n     #include <openssl/ecdsa.h>\n@@ -51,6 +53,7 @@ if test x\"$has_libcrypto\" = x\"yes\" && test x\"$has_openssl_ec\" = x; then\n     ECDSA_SIG_free(sig_openssl);\n   ]])],[has_openssl_ec=yes],[has_openssl_ec=no])\n   AC_MSG_RESULT([$has_openssl_ec])\n+  CPPFLAGS=\"$CPPFLAGS_TEMP\"\n fi\n ])\n "
      },
      {
        "sha": "6021b760b517cfc72899ee8b49f1ecfc88f9f1a8",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 114,
        "deletions": 72,
        "changes": 186,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67f232b5d874b501c114bced5d764db7f4f5ce99/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67f232b5d874b501c114bced5d764db7f4f5ce99/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=67f232b5d874b501c114bced5d764db7f4f5ce99",
        "patch": "@@ -7,6 +7,11 @@ AH_TOP([#ifndef LIBSECP256K1_CONFIG_H])\n AH_TOP([#define LIBSECP256K1_CONFIG_H])\n AH_BOTTOM([#endif /*LIBSECP256K1_CONFIG_H*/])\n AM_INIT_AUTOMAKE([foreign subdir-objects])\n+\n+# Set -g if CFLAGS are not already set, which matches the default autoconf\n+# behavior (see PROG_CC in the Autoconf manual) with the exception that we don't\n+# set -O2 here because we set it in any case (see further down).\n+: ${CFLAGS=\"-g\"}\n LT_INIT\n \n dnl make the compilation flags quiet unless V=1 is used\n@@ -19,10 +24,6 @@ AC_PATH_TOOL(RANLIB, ranlib)\n AC_PATH_TOOL(STRIP, strip)\n AX_PROG_CC_FOR_BUILD\n \n-if test \"x$CFLAGS\" = \"x\"; then\n-  CFLAGS=\"-g\"\n-fi\n-\n AM_PROG_CC_C_O\n \n AC_PROG_CC_C89\n@@ -45,6 +46,7 @@ case $host_os in\n          if test x$openssl_prefix != x; then\n            PKG_CONFIG_PATH=\"$openssl_prefix/lib/pkgconfig:$PKG_CONFIG_PATH\"\n            export PKG_CONFIG_PATH\n+           CRYPTO_CPPFLAGS=\"-I$openssl_prefix/include\"\n          fi\n          if test x$gmp_prefix != x; then\n            GMP_CPPFLAGS=\"-I$gmp_prefix/include\"\n@@ -63,11 +65,11 @@ case $host_os in\n    ;;\n esac\n \n-CFLAGS=\"$CFLAGS -W\"\n+CFLAGS=\"-W $CFLAGS\"\n \n warn_CFLAGS=\"-std=c89 -pedantic -Wall -Wextra -Wcast-align -Wnested-externs -Wshadow -Wstrict-prototypes -Wno-unused-function -Wno-long-long -Wno-overlength-strings\"\n saved_CFLAGS=\"$CFLAGS\"\n-CFLAGS=\"$CFLAGS $warn_CFLAGS\"\n+CFLAGS=\"$warn_CFLAGS $CFLAGS\"\n AC_MSG_CHECKING([if ${CC} supports ${warn_CFLAGS}])\n AC_COMPILE_IFELSE([AC_LANG_SOURCE([[char foo;]])],\n     [ AC_MSG_RESULT([yes]) ],\n@@ -76,7 +78,7 @@ AC_COMPILE_IFELSE([AC_LANG_SOURCE([[char foo;]])],\n     ])\n \n saved_CFLAGS=\"$CFLAGS\"\n-CFLAGS=\"$CFLAGS -fvisibility=hidden\"\n+CFLAGS=\"-fvisibility=hidden $CFLAGS\"\n AC_MSG_CHECKING([if ${CC} supports -fvisibility=hidden])\n AC_COMPILE_IFELSE([AC_LANG_SOURCE([[char foo;]])],\n     [ AC_MSG_RESULT([yes]) ],\n@@ -85,42 +87,42 @@ AC_COMPILE_IFELSE([AC_LANG_SOURCE([[char foo;]])],\n     ])\n \n AC_ARG_ENABLE(benchmark,\n-    AS_HELP_STRING([--enable-benchmark],[compile benchmark (default is yes)]),\n+    AS_HELP_STRING([--enable-benchmark],[compile benchmark [default=yes]]),\n     [use_benchmark=$enableval],\n     [use_benchmark=yes])\n \n AC_ARG_ENABLE(coverage,\n-    AS_HELP_STRING([--enable-coverage],[enable compiler flags to support kcov coverage analysis]),\n+    AS_HELP_STRING([--enable-coverage],[enable compiler flags to support kcov coverage analysis [default=no]]),\n     [enable_coverage=$enableval],\n     [enable_coverage=no])\n \n AC_ARG_ENABLE(tests,\n-    AS_HELP_STRING([--enable-tests],[compile tests (default is yes)]),\n+    AS_HELP_STRING([--enable-tests],[compile tests [default=yes]]),\n     [use_tests=$enableval],\n     [use_tests=yes])\n \n AC_ARG_ENABLE(openssl_tests,\n-    AS_HELP_STRING([--enable-openssl-tests],[enable OpenSSL tests, if OpenSSL is available (default is auto)]),\n+    AS_HELP_STRING([--enable-openssl-tests],[enable OpenSSL tests [default=auto]]),\n     [enable_openssl_tests=$enableval],\n     [enable_openssl_tests=auto])\n \n AC_ARG_ENABLE(experimental,\n-    AS_HELP_STRING([--enable-experimental],[allow experimental configure options (default is no)]),\n+    AS_HELP_STRING([--enable-experimental],[allow experimental configure options [default=no]]),\n     [use_experimental=$enableval],\n     [use_experimental=no])\n \n AC_ARG_ENABLE(exhaustive_tests,\n-    AS_HELP_STRING([--enable-exhaustive-tests],[compile exhaustive tests (default is yes)]),\n+    AS_HELP_STRING([--enable-exhaustive-tests],[compile exhaustive tests [default=yes]]),\n     [use_exhaustive_tests=$enableval],\n     [use_exhaustive_tests=yes])\n \n AC_ARG_ENABLE(endomorphism,\n-    AS_HELP_STRING([--enable-endomorphism],[enable endomorphism (default is no)]),\n+    AS_HELP_STRING([--enable-endomorphism],[enable endomorphism [default=no]]),\n     [use_endomorphism=$enableval],\n     [use_endomorphism=no])\n \n AC_ARG_ENABLE(ecmult_static_precomputation,\n-    AS_HELP_STRING([--enable-ecmult-static-precomputation],[enable precomputed ecmult table for signing (default is yes)]),\n+    AS_HELP_STRING([--enable-ecmult-static-precomputation],[enable precomputed ecmult table for signing [default=auto]]),\n     [use_ecmult_static_precomputation=$enableval],\n     [use_ecmult_static_precomputation=auto])\n \n@@ -130,35 +132,55 @@ AC_ARG_ENABLE(module_ecdh,\n     [enable_module_ecdh=no])\n \n AC_ARG_ENABLE(module_recovery,\n-    AS_HELP_STRING([--enable-module-recovery],[enable ECDSA pubkey recovery module (default is no)]),\n+    AS_HELP_STRING([--enable-module-recovery],[enable ECDSA pubkey recovery module [default=no]]),\n     [enable_module_recovery=$enableval],\n     [enable_module_recovery=no])\n \n-AC_ARG_ENABLE(jni,\n-    AS_HELP_STRING([--enable-jni],[enable libsecp256k1_jni (default is no)]),\n-    [use_jni=$enableval],\n-    [use_jni=no])\n+AC_ARG_ENABLE(external_default_callbacks,\n+    AS_HELP_STRING([--enable-external-default-callbacks],[enable external default callback functions [default=no]]),\n+    [use_external_default_callbacks=$enableval],\n+    [use_external_default_callbacks=no])\n \n AC_ARG_WITH([field], [AS_HELP_STRING([--with-field=64bit|32bit|auto],\n-[Specify Field Implementation. Default is auto])],[req_field=$withval], [req_field=auto])\n+[finite field implementation to use [default=auto]])],[req_field=$withval], [req_field=auto])\n \n AC_ARG_WITH([bignum], [AS_HELP_STRING([--with-bignum=gmp|no|auto],\n-[Specify Bignum Implementation. Default is auto])],[req_bignum=$withval], [req_bignum=auto])\n+[bignum implementation to use [default=auto]])],[req_bignum=$withval], [req_bignum=auto])\n \n AC_ARG_WITH([scalar], [AS_HELP_STRING([--with-scalar=64bit|32bit|auto],\n-[Specify scalar implementation. Default is auto])],[req_scalar=$withval], [req_scalar=auto])\n-\n-AC_ARG_WITH([asm], [AS_HELP_STRING([--with-asm=x86_64|arm|no|auto]\n-[Specify assembly optimizations to use. Default is auto (experimental: arm)])],[req_asm=$withval], [req_asm=auto])\n+[scalar implementation to use [default=auto]])],[req_scalar=$withval], [req_scalar=auto])\n+\n+AC_ARG_WITH([asm], [AS_HELP_STRING([--with-asm=x86_64|arm|no|auto],\n+[assembly optimizations to use\u00a0(experimental: arm) [default=auto]])],[req_asm=$withval], [req_asm=auto])\n+\n+AC_ARG_WITH([ecmult-window], [AS_HELP_STRING([--with-ecmult-window=SIZE|auto],\n+[window size for ecmult precomputation for verification, specified as integer in range [2..24].]\n+[Larger values result in possibly better performance at the cost of an exponentially larger precomputed table.]\n+[The table will store 2^(SIZE-2) * 64 bytes of data but can be larger in memory due to platform-specific padding and alignment.]\n+[If the endomorphism optimization is enabled, two tables of this size are used instead of only one.]\n+[\"auto\" is a reasonable setting for desktop machines (currently 15). [default=auto]]\n+)],\n+[req_ecmult_window=$withval], [req_ecmult_window=auto])\n+\n+AC_ARG_WITH([ecmult-gen-precision], [AS_HELP_STRING([--with-ecmult-gen-precision=2|4|8|auto],\n+[Precision bits to tune the precomputed table size for signing.]\n+[The size of the table is 32kB for 2 bits, 64kB for 4 bits, 512kB for 8 bits of precision.]\n+[A larger table size usually results in possible faster signing.]\n+[\"auto\" is a reasonable setting for desktop machines (currently 4). [default=auto]]\n+)],\n+[req_ecmult_gen_precision=$withval], [req_ecmult_gen_precision=auto])\n \n AC_CHECK_TYPES([__int128])\n \n+AC_CHECK_HEADER([valgrind/memcheck.h], [enable_valgrind=yes], [enable_valgrind=no], [])\n+AM_CONDITIONAL([VALGRIND_ENABLED],[test \"$enable_valgrind\" = \"yes\"])\n+\n if test x\"$enable_coverage\" = x\"yes\"; then\n     AC_DEFINE(COVERAGE, 1, [Define this symbol to compile out all VERIFY code])\n-    CFLAGS=\"$CFLAGS -O0 --coverage\"\n-    LDFLAGS=\"--coverage\"\n+    CFLAGS=\"-O0 --coverage $CFLAGS\"\n+    LDFLAGS=\"--coverage $LDFLAGS\"\n else\n-    CFLAGS=\"$CFLAGS -O3\"\n+    CFLAGS=\"-O2 $CFLAGS\"\n fi\n \n if test x\"$use_ecmult_static_precomputation\" != x\"no\"; then\n@@ -176,7 +198,7 @@ if test x\"$use_ecmult_static_precomputation\" != x\"no\"; then\n \n   warn_CFLAGS_FOR_BUILD=\"-Wall -Wextra -Wno-unused-function\"\n   saved_CFLAGS=\"$CFLAGS\"\n-  CFLAGS=\"$CFLAGS $warn_CFLAGS_FOR_BUILD\"\n+  CFLAGS=\"$warn_CFLAGS_FOR_BUILD $CFLAGS\"\n   AC_MSG_CHECKING([if native ${CC_FOR_BUILD} supports ${warn_CFLAGS_FOR_BUILD}])\n   AC_COMPILE_IFELSE([AC_LANG_SOURCE([[char foo;]])],\n       [ AC_MSG_RESULT([yes]) ],\n@@ -188,7 +210,7 @@ if test x\"$use_ecmult_static_precomputation\" != x\"no\"; then\n   AC_RUN_IFELSE(\n     [AC_LANG_PROGRAM([], [])],\n     [working_native_cc=yes],\n-    [working_native_cc=no],[dnl])\n+    [working_native_cc=no],[:])\n \n   CFLAGS_FOR_BUILD=\"$CFLAGS\"\n \n@@ -387,12 +409,50 @@ case $set_scalar in\n   ;;\n esac\n \n+#set ecmult window size\n+if test x\"$req_ecmult_window\" = x\"auto\"; then\n+  set_ecmult_window=15\n+else\n+  set_ecmult_window=$req_ecmult_window\n+fi\n+\n+error_window_size=['window size for ecmult precomputation not an integer in range [2..24] or \"auto\"']\n+case $set_ecmult_window in\n+''|*[[!0-9]]*)\n+  # no valid integer\n+  AC_MSG_ERROR($error_window_size)\n+  ;;\n+*)\n+  if test \"$set_ecmult_window\" -lt 2 -o \"$set_ecmult_window\" -gt 24 ; then\n+    # not in range\n+    AC_MSG_ERROR($error_window_size)\n+  fi\n+  AC_DEFINE_UNQUOTED(ECMULT_WINDOW_SIZE, $set_ecmult_window, [Set window size for ecmult precomputation])\n+  ;;\n+esac\n+\n+#set ecmult gen precision\n+if test x\"$req_ecmult_gen_precision\" = x\"auto\"; then\n+  set_ecmult_gen_precision=4\n+else\n+  set_ecmult_gen_precision=$req_ecmult_gen_precision\n+fi\n+\n+case $set_ecmult_gen_precision in\n+2|4|8)\n+  AC_DEFINE_UNQUOTED(ECMULT_GEN_PREC_BITS, $set_ecmult_gen_precision, [Set ecmult gen precision bits])\n+  ;;\n+*)\n+  AC_MSG_ERROR(['ecmult gen precision not 2, 4, 8 or \"auto\"'])\n+  ;;\n+esac\n+\n if test x\"$use_tests\" = x\"yes\"; then\n   SECP_OPENSSL_CHECK\n   if test x\"$has_openssl_ec\" = x\"yes\"; then\n     if test x\"$enable_openssl_tests\" != x\"no\"; then\n       AC_DEFINE(ENABLE_OPENSSL_TESTS, 1, [Define this symbol if OpenSSL EC functions are available])\n-      SECP_TEST_INCLUDES=\"$SSL_CFLAGS $CRYPTO_CFLAGS\"\n+      SECP_TEST_INCLUDES=\"$SSL_CFLAGS $CRYPTO_CFLAGS $CRYPTO_CPPFLAGS\"\n       SECP_TEST_LIBS=\"$CRYPTO_LIBS\"\n \n       case $host in\n@@ -412,29 +472,6 @@ else\n   fi\n fi\n \n-if test x\"$use_jni\" != x\"no\"; then\n-  AX_JNI_INCLUDE_DIR\n-  have_jni_dependencies=yes\n-  if test x\"$enable_module_ecdh\" = x\"no\"; then\n-    have_jni_dependencies=no\n-  fi\n-  if test \"x$JNI_INCLUDE_DIRS\" = \"x\"; then\n-    have_jni_dependencies=no\n-  fi\n-  if test \"x$have_jni_dependencies\" = \"xno\"; then\n-    if test x\"$use_jni\" = x\"yes\"; then\n-      AC_MSG_ERROR([jni support explicitly requested but headers/dependencies were not found. Enable ECDH and try again.])\n-    fi\n-    AC_MSG_WARN([jni headers/dependencies not found. jni support disabled])\n-    use_jni=no\n-  else\n-    use_jni=yes\n-    for JNI_INCLUDE_DIR in $JNI_INCLUDE_DIRS; do\n-      JNI_INCLUDES=\"$JNI_INCLUDES -I$JNI_INCLUDE_DIR\"\n-    done\n-  fi\n-fi\n-\n if test x\"$set_bignum\" = x\"gmp\"; then\n   SECP_LIBS=\"$SECP_LIBS $GMP_LIBS\"\n   SECP_INCLUDES=\"$SECP_INCLUDES $GMP_CPPFLAGS\"\n@@ -462,6 +499,10 @@ if test x\"$use_external_asm\" = x\"yes\"; then\n   AC_DEFINE(USE_EXTERNAL_ASM, 1, [Define this symbol if an external (non-inline) assembly implementation is used])\n fi\n \n+if test x\"$use_external_default_callbacks\" = x\"yes\"; then\n+  AC_DEFINE(USE_EXTERNAL_DEFAULT_CALLBACKS, 1, [Define this symbol if an external implementation of the default callbacks is used])\n+fi\n+\n if test x\"$enable_experimental\" = x\"yes\"; then\n   AC_MSG_NOTICE([******])\n   AC_MSG_NOTICE([WARNING: experimental build])\n@@ -479,7 +520,6 @@ fi\n \n AC_CONFIG_HEADERS([src/libsecp256k1-config.h])\n AC_CONFIG_FILES([Makefile libsecp256k1.pc])\n-AC_SUBST(JNI_INCLUDES)\n AC_SUBST(SECP_INCLUDES)\n AC_SUBST(SECP_LIBS)\n AC_SUBST(SECP_TEST_LIBS)\n@@ -491,7 +531,6 @@ AM_CONDITIONAL([USE_BENCHMARK], [test x\"$use_benchmark\" = x\"yes\"])\n AM_CONDITIONAL([USE_ECMULT_STATIC_PRECOMPUTATION], [test x\"$set_precomp\" = x\"yes\"])\n AM_CONDITIONAL([ENABLE_MODULE_ECDH], [test x\"$enable_module_ecdh\" = x\"yes\"])\n AM_CONDITIONAL([ENABLE_MODULE_RECOVERY], [test x\"$enable_module_recovery\" = x\"yes\"])\n-AM_CONDITIONAL([USE_JNI], [test x\"$use_jni\" = x\"yes\"])\n AM_CONDITIONAL([USE_EXTERNAL_ASM], [test x\"$use_external_asm\" = x\"yes\"])\n AM_CONDITIONAL([USE_ASM_ARM], [test x\"$set_asm\" = x\"arm\"])\n \n@@ -504,21 +543,24 @@ AC_OUTPUT\n \n echo\n echo \"Build Options:\"\n-echo \"  with endomorphism   = $use_endomorphism\"\n-echo \"  with ecmult precomp = $set_precomp\"\n-echo \"  with jni            = $use_jni\"\n-echo \"  with benchmarks     = $use_benchmark\"\n-echo \"  with coverage       = $enable_coverage\"\n-echo \"  module ecdh         = $enable_module_ecdh\"\n-echo \"  module recovery     = $enable_module_recovery\"\n+echo \"  with endomorphism       = $use_endomorphism\"\n+echo \"  with ecmult precomp     = $set_precomp\"\n+echo \"  with external callbacks = $use_external_default_callbacks\"\n+echo \"  with benchmarks         = $use_benchmark\"\n+echo \"  with coverage           = $enable_coverage\"\n+echo \"  module ecdh             = $enable_module_ecdh\"\n+echo \"  module recovery         = $enable_module_recovery\"\n echo\n-echo \"  asm                 = $set_asm\"\n-echo \"  bignum              = $set_bignum\"\n-echo \"  field               = $set_field\"\n-echo \"  scalar              = $set_scalar\"\n+echo \"  asm                     = $set_asm\"\n+echo \"  bignum                  = $set_bignum\"\n+echo \"  field                   = $set_field\"\n+echo \"  scalar                  = $set_scalar\"\n+echo \"  ecmult window size      = $set_ecmult_window\"\n+echo \"  ecmult gen prec. bits   = $set_ecmult_gen_precision\"\n echo\n-echo \"  CC                  = $CC\"\n-echo \"  CFLAGS              = $CFLAGS\"\n-echo \"  CPPFLAGS            = $CPPFLAGS\"\n-echo \"  LDFLAGS             = $LDFLAGS\"\n+echo \"  valgrind                = $enable_valgrind\"\n+echo \"  CC                      = $CC\"\n+echo \"  CFLAGS                  = $CFLAGS\"\n+echo \"  CPPFLAGS                = $CPPFLAGS\"\n+echo \"  LDFLAGS                 = $LDFLAGS\"\n echo"
      },
      {
        "sha": "e177a0562dd2d2525a095c1dc3922b0ad5241ca5",
        "filename": "contrib/lax_der_parsing.c",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67f232b5d874b501c114bced5d764db7f4f5ce99/contrib/lax_der_parsing.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67f232b5d874b501c114bced5d764db7f4f5ce99/contrib/lax_der_parsing.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/lax_der_parsing.c?ref=67f232b5d874b501c114bced5d764db7f4f5ce99",
        "patch": "@@ -32,7 +32,7 @@ int ecdsa_signature_parse_der_lax(const secp256k1_context* ctx, secp256k1_ecdsa_\n     lenbyte = input[pos++];\n     if (lenbyte & 0x80) {\n         lenbyte -= 0x80;\n-        if (pos + lenbyte > inputlen) {\n+        if (lenbyte > inputlen - pos) {\n             return 0;\n         }\n         pos += lenbyte;\n@@ -51,7 +51,7 @@ int ecdsa_signature_parse_der_lax(const secp256k1_context* ctx, secp256k1_ecdsa_\n     lenbyte = input[pos++];\n     if (lenbyte & 0x80) {\n         lenbyte -= 0x80;\n-        if (pos + lenbyte > inputlen) {\n+        if (lenbyte > inputlen - pos) {\n             return 0;\n         }\n         while (lenbyte > 0 && input[pos] == 0) {\n@@ -89,7 +89,7 @@ int ecdsa_signature_parse_der_lax(const secp256k1_context* ctx, secp256k1_ecdsa_\n     lenbyte = input[pos++];\n     if (lenbyte & 0x80) {\n         lenbyte -= 0x80;\n-        if (pos + lenbyte > inputlen) {\n+        if (lenbyte > inputlen - pos) {\n             return 0;\n         }\n         while (lenbyte > 0 && input[pos] == 0) {"
      },
      {
        "sha": "3909d16a279dcee9d7d1b255f78baf8286b82d82",
        "filename": "contrib/travis.sh",
        "status": "added",
        "additions": 65,
        "deletions": 0,
        "changes": 65,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67f232b5d874b501c114bced5d764db7f4f5ce99/contrib/travis.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67f232b5d874b501c114bced5d764db7f4f5ce99/contrib/travis.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/travis.sh?ref=67f232b5d874b501c114bced5d764db7f4f5ce99",
        "patch": "@@ -0,0 +1,65 @@\n+#!/bin/sh\n+\n+set -e\n+set -x\n+\n+if [ -n \"$HOST\" ]\n+then\n+    export USE_HOST=\"--host=$HOST\"\n+fi\n+if [ \"$HOST\" = \"i686-linux-gnu\" ]\n+then\n+    export CC=\"$CC -m32\"\n+fi\n+if [ \"$TRAVIS_OS_NAME\" = \"osx\" ] && [ \"$TRAVIS_COMPILER\" = \"gcc\" ]\n+then\n+    export CC=\"gcc-9\"\n+fi\n+\n+./configure \\\n+    --enable-experimental=\"$EXPERIMENTAL\" --enable-endomorphism=\"$ENDOMORPHISM\" \\\n+    --with-field=\"$FIELD\" --with-bignum=\"$BIGNUM\" --with-asm=\"$ASM\" --with-scalar=\"$SCALAR\" \\\n+    --enable-ecmult-static-precomputation=\"$STATICPRECOMPUTATION\" --with-ecmult-gen-precision=\"$ECMULTGENPRECISION\" \\\n+    --enable-module-ecdh=\"$ECDH\" --enable-module-recovery=\"$RECOVERY\" \"$EXTRAFLAGS\" \"$USE_HOST\"\n+\n+if [ -n \"$BUILD\" ]\n+then\n+    make -j2 \"$BUILD\"\n+fi\n+if [ -n \"$VALGRIND\" ]\n+then\n+    make -j2\n+    # the `--error-exitcode` is required to make the test fail if valgrind found errors, otherwise it'll return 0 (http://valgrind.org/docs/manual/manual-core.html)\n+    valgrind --error-exitcode=42 ./tests 16\n+    valgrind --error-exitcode=42 ./exhaustive_tests\n+fi\n+if [ -n \"$BENCH\" ]\n+then\n+    if [ -n \"$VALGRIND\" ]\n+    then\n+        # Using the local `libtool` because on macOS the system's libtool has nothing to do with GNU libtool\n+        EXEC='./libtool --mode=execute valgrind --error-exitcode=42'\n+    else\n+        EXEC=\n+    fi\n+    # This limits the iterations in the benchmarks below to ITER(set in .travis.yml) iterations.\n+    export SECP256K1_BENCH_ITERS=\"$ITERS\"\n+    {\n+        $EXEC ./bench_ecmult\n+        $EXEC ./bench_internal\n+        $EXEC ./bench_sign\n+        $EXEC ./bench_verify\n+    } >> bench.log 2>&1\n+    if [ \"$RECOVERY\" = \"yes\" ]\n+    then\n+        $EXEC ./bench_recover >> bench.log 2>&1\n+    fi\n+    if [ \"$ECDH\" = \"yes\" ]\n+    then\n+        $EXEC ./bench_ecdh >> bench.log 2>&1\n+    fi\n+fi\n+if [ -n \"$CTIMETEST\" ]\n+then\n+    ./libtool --mode=execute valgrind --error-exitcode=42 ./valgrind_ctime_test > valgrind_ctime_test.log 2>&1\n+fi"
      },
      {
        "sha": "2ba2dca388150280773063aa7ed20235ee34d7fa",
        "filename": "include/secp256k1.h",
        "status": "modified",
        "additions": 150,
        "deletions": 52,
        "changes": 202,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67f232b5d874b501c114bced5d764db7f4f5ce99/include/secp256k1.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67f232b5d874b501c114bced5d764db7f4f5ce99/include/secp256k1.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/include/secp256k1.h?ref=67f232b5d874b501c114bced5d764db7f4f5ce99",
        "patch": "@@ -14,7 +14,7 @@ extern \"C\" {\n  * 2. Array lengths always immediately the follow the argument whose length\n  *    they describe, even if this violates rule 1.\n  * 3. Within the OUT/OUTIN/IN groups, pointers to data that is typically generated\n- *    later go first. This means: signatures, public nonces, private nonces,\n+ *    later go first. This means: signatures, public nonces, secret nonces,\n  *    messages, public keys, secret keys, tweaks.\n  * 4. Arguments that are not data pointers go last, from more complex to less\n  *    complex: function pointers, algorithm names, messages, void pointers,\n@@ -33,9 +33,10 @@ extern \"C\" {\n  *  verification).\n  *\n  *  A constructed context can safely be used from multiple threads\n- *  simultaneously, but API call that take a non-const pointer to a context\n+ *  simultaneously, but API calls that take a non-const pointer to a context\n  *  need exclusive access to it. In particular this is the case for\n- *  secp256k1_context_destroy and secp256k1_context_randomize.\n+ *  secp256k1_context_destroy, secp256k1_context_preallocated_destroy,\n+ *  and secp256k1_context_randomize.\n  *\n  *  Regarding randomization, either do it once at creation time (in which case\n  *  you do not need any locking for the other calls), or use a read-write lock.\n@@ -161,14 +162,17 @@ typedef int (*secp256k1_nonce_function)(\n /** The higher bits contain the actual data. Do not use directly. */\n #define SECP256K1_FLAGS_BIT_CONTEXT_VERIFY (1 << 8)\n #define SECP256K1_FLAGS_BIT_CONTEXT_SIGN (1 << 9)\n+#define SECP256K1_FLAGS_BIT_CONTEXT_DECLASSIFY (1 << 10)\n #define SECP256K1_FLAGS_BIT_COMPRESSION (1 << 8)\n \n-/** Flags to pass to secp256k1_context_create. */\n+/** Flags to pass to secp256k1_context_create, secp256k1_context_preallocated_size, and\n+ *  secp256k1_context_preallocated_create. */\n #define SECP256K1_CONTEXT_VERIFY (SECP256K1_FLAGS_TYPE_CONTEXT | SECP256K1_FLAGS_BIT_CONTEXT_VERIFY)\n #define SECP256K1_CONTEXT_SIGN (SECP256K1_FLAGS_TYPE_CONTEXT | SECP256K1_FLAGS_BIT_CONTEXT_SIGN)\n+#define SECP256K1_CONTEXT_DECLASSIFY (SECP256K1_FLAGS_TYPE_CONTEXT | SECP256K1_FLAGS_BIT_CONTEXT_DECLASSIFY)\n #define SECP256K1_CONTEXT_NONE (SECP256K1_FLAGS_TYPE_CONTEXT)\n \n-/** Flag to pass to secp256k1_ec_pubkey_serialize and secp256k1_ec_privkey_export. */\n+/** Flag to pass to secp256k1_ec_pubkey_serialize. */\n #define SECP256K1_EC_COMPRESSED (SECP256K1_FLAGS_TYPE_COMPRESSION | SECP256K1_FLAGS_BIT_COMPRESSION)\n #define SECP256K1_EC_UNCOMPRESSED (SECP256K1_FLAGS_TYPE_COMPRESSION)\n \n@@ -186,7 +190,11 @@ typedef int (*secp256k1_nonce_function)(\n  */\n SECP256K1_API extern const secp256k1_context *secp256k1_context_no_precomp;\n \n-/** Create a secp256k1 context object.\n+/** Create a secp256k1 context object (in dynamically allocated memory).\n+ *\n+ *  This function uses malloc to allocate memory. It is guaranteed that malloc is\n+ *  called at most once for every call of this function. If you need to avoid dynamic\n+ *  memory allocation entirely, see the functions in secp256k1_preallocated.h.\n  *\n  *  Returns: a newly created context object.\n  *  In:      flags: which parts of the context to initialize.\n@@ -197,7 +205,11 @@ SECP256K1_API secp256k1_context* secp256k1_context_create(\n     unsigned int flags\n ) SECP256K1_WARN_UNUSED_RESULT;\n \n-/** Copies a secp256k1 context object.\n+/** Copy a secp256k1 context object (into dynamically allocated memory).\n+ *\n+ *  This function uses malloc to allocate memory. It is guaranteed that malloc is\n+ *  called at most once for every call of this function. If you need to avoid dynamic\n+ *  memory allocation entirely, see the functions in secp256k1_preallocated.h.\n  *\n  *  Returns: a newly created context object.\n  *  Args:    ctx: an existing context to copy (cannot be NULL)\n@@ -206,10 +218,18 @@ SECP256K1_API secp256k1_context* secp256k1_context_clone(\n     const secp256k1_context* ctx\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_WARN_UNUSED_RESULT;\n \n-/** Destroy a secp256k1 context object.\n+/** Destroy a secp256k1 context object (created in dynamically allocated memory).\n  *\n  *  The context pointer may not be used afterwards.\n- *  Args:   ctx: an existing context to destroy (cannot be NULL)\n+ *\n+ *  The context to destroy must have been created using secp256k1_context_create\n+ *  or secp256k1_context_clone. If the context has instead been created using\n+ *  secp256k1_context_preallocated_create or secp256k1_context_preallocated_clone, the\n+ *  behaviour is undefined. In that case, secp256k1_context_preallocated_destroy must\n+ *  be used instead.\n+ *\n+ *  Args:   ctx: an existing context to destroy, constructed using\n+ *               secp256k1_context_create or secp256k1_context_clone\n  */\n SECP256K1_API void secp256k1_context_destroy(\n     secp256k1_context* ctx\n@@ -229,11 +249,28 @@ SECP256K1_API void secp256k1_context_destroy(\n  *  to cause a crash, though its return value and output arguments are\n  *  undefined.\n  *\n+ *  When this function has not been called (or called with fn==NULL), then the\n+ *  default handler will be used.\u00a0The library provides a default handler which\n+ *  writes the message to stderr and calls abort. This default handler can be\n+ *  replaced at link time if the preprocessor macro\n+ *  USE_EXTERNAL_DEFAULT_CALLBACKS is defined, which is the case if the build\n+ *  has been configured with --enable-external-default-callbacks. Then the\n+ *  following two symbols must be provided to link against:\n+ *   - void secp256k1_default_illegal_callback_fn(const char* message, void* data);\n+ *   - void secp256k1_default_error_callback_fn(const char* message, void* data);\n+ *  The library can call these default handlers even before a proper callback data\n+ *  pointer could have been set using secp256k1_context_set_illegal_callback or\n+ *  secp256k1_context_set_error_callback, e.g., when the creation of a context\n+ *  fails. In this case, the corresponding default handler will be called with\n+ *  the data pointer argument set to NULL.\n+ *\n  *  Args: ctx:  an existing context object (cannot be NULL)\n  *  In:   fun:  a pointer to a function to call when an illegal argument is\n- *              passed to the API, taking a message and an opaque pointer\n- *              (NULL restores a default handler that calls abort).\n+ *              passed to the API, taking a message and an opaque pointer.\n+ *              (NULL restores the default handler.)\n  *        data: the opaque pointer to pass to fun above.\n+ *\n+ *  See also secp256k1_context_set_error_callback.\n  */\n SECP256K1_API void secp256k1_context_set_illegal_callback(\n     secp256k1_context* ctx,\n@@ -253,9 +290,12 @@ SECP256K1_API void secp256k1_context_set_illegal_callback(\n  *\n  *  Args: ctx:  an existing context object (cannot be NULL)\n  *  In:   fun:  a pointer to a function to call when an internal error occurs,\n- *              taking a message and an opaque pointer (NULL restores a default\n- *              handler that calls abort).\n+ *              taking a message and an opaque pointer (NULL restores the\n+ *              default handler, see secp256k1_context_set_illegal_callback\n+ *              for details).\n  *        data: the opaque pointer to pass to fun above.\n+ *\n+ *  See also secp256k1_context_set_illegal_callback.\n  */\n SECP256K1_API void secp256k1_context_set_error_callback(\n     secp256k1_context* ctx,\n@@ -267,21 +307,24 @@ SECP256K1_API void secp256k1_context_set_error_callback(\n  *\n  *  Returns: a newly created scratch space.\n  *  Args: ctx:  an existing context object (cannot be NULL)\n- *  In:   max_size: maximum amount of memory to allocate\n+ *  In:   size: amount of memory to be available as scratch space. Some extra\n+ *              (<100 bytes) will be allocated for extra accounting.\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT secp256k1_scratch_space* secp256k1_scratch_space_create(\n     const secp256k1_context* ctx,\n-    size_t max_size\n+    size_t size\n ) SECP256K1_ARG_NONNULL(1);\n \n /** Destroy a secp256k1 scratch space.\n  *\n  *  The pointer may not be used afterwards.\n- *  Args:   scratch: space to destroy\n+ *  Args:       ctx: a secp256k1 context object.\n+ *          scratch: space to destroy\n  */\n SECP256K1_API void secp256k1_scratch_space_destroy(\n+    const secp256k1_context* ctx,\n     secp256k1_scratch_space* scratch\n-);\n+) SECP256K1_ARG_NONNULL(1);\n \n /** Parse a variable-length public key into the pubkey object.\n  *\n@@ -488,7 +531,7 @@ SECP256K1_API extern const secp256k1_nonce_function secp256k1_nonce_function_def\n /** Create an ECDSA signature.\n  *\n  *  Returns: 1: signature created\n- *           0: the nonce generation function failed, or the private key was invalid.\n+ *           0: the nonce generation function failed, or the secret key was invalid.\n  *  Args:    ctx:    pointer to a context object, initialized for signing (cannot be NULL)\n  *  Out:     sig:    pointer to an array where the signature will be placed (cannot be NULL)\n  *  In:      msg32:  the 32-byte message hash being signed (cannot be NULL)\n@@ -509,6 +552,11 @@ SECP256K1_API int secp256k1_ecdsa_sign(\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n /** Verify an ECDSA secret key.\n+ *\n+ *  A secret key is valid if it is not 0 and less than the secp256k1 curve order\n+ *  when interpreted as an integer (most significant byte first). The\n+ *  probability of choosing a 32-byte string uniformly at random which is an\n+ *  invalid secret key is negligible.\n  *\n  *  Returns: 1: secret key is valid\n  *           0: secret key is invalid\n@@ -526,20 +574,32 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_seckey_verify(\n  *           0: secret was invalid, try again\n  *  Args:   ctx:        pointer to a context object, initialized for signing (cannot be NULL)\n  *  Out:    pubkey:     pointer to the created public key (cannot be NULL)\n- *  In:     seckey:     pointer to a 32-byte private key (cannot be NULL)\n+ *  In:     seckey:     pointer to a 32-byte secret key (cannot be NULL)\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_create(\n     const secp256k1_context* ctx,\n     secp256k1_pubkey *pubkey,\n     const unsigned char *seckey\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n-/** Negates a private key in place.\n+/** Negates a secret key in place.\n  *\n- *  Returns: 1 always\n- *  Args:   ctx:        pointer to a context object\n- *  In/Out: seckey:     pointer to the 32-byte private key to be negated (cannot be NULL)\n+ *  Returns: 0 if the given secret key is invalid according to\n+ *           secp256k1_ec_seckey_verify. 1 otherwise\n+ *  Args:   ctx:    pointer to a context object\n+ *  In/Out: seckey: pointer to the 32-byte secret key to be negated. If the\n+ *                  secret key is invalid according to\n+ *                  secp256k1_ec_seckey_verify, this function returns 0 and\n+ *                  seckey will be set to some unspecified value. (cannot be\n+ *                  NULL)\n  */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_seckey_negate(\n+    const secp256k1_context* ctx,\n+    unsigned char *seckey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2);\n+\n+/** Same as secp256k1_ec_seckey_negate, but DEPRECATED. Will be removed in\n+ *  future versions. */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_privkey_negate(\n     const secp256k1_context* ctx,\n     unsigned char *seckey\n@@ -556,57 +616,93 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_negate(\n     secp256k1_pubkey *pubkey\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2);\n \n-/** Tweak a private key by adding tweak to it.\n- * Returns: 0 if the tweak was out of range (chance of around 1 in 2^128 for\n- *          uniformly random 32-byte arrays, or if the resulting private key\n- *          would be invalid (only when the tweak is the complement of the\n- *          private key). 1 otherwise.\n- * Args:    ctx:    pointer to a context object (cannot be NULL).\n- * In/Out:  seckey: pointer to a 32-byte private key.\n- * In:      tweak:  pointer to a 32-byte tweak.\n- */\n+/** Tweak a secret key by adding tweak to it.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting secret key would be\n+ *           invalid (only when the tweak is the negation of the secret key). 1\n+ *           otherwise.\n+ *  Args:    ctx:   pointer to a context object (cannot be NULL).\n+ *  In/Out: seckey: pointer to a 32-byte secret key. If the secret key is\n+ *                  invalid according to secp256k1_ec_seckey_verify, this\n+ *                  function returns 0. seckey will be set to some unspecified\n+ *                  value if this function returns 0. (cannot be NULL)\n+ *  In:      tweak: pointer to a 32-byte tweak. If the tweak is invalid according to\n+ *                  secp256k1_ec_seckey_verify, this function returns 0. For\n+ *                  uniformly random 32-byte arrays the chance of being invalid\n+ *                  is negligible (around 1 in 2^128) (cannot be NULL).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_seckey_tweak_add(\n+    const secp256k1_context* ctx,\n+    unsigned char *seckey,\n+    const unsigned char *tweak\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Same as secp256k1_ec_seckey_tweak_add, but DEPRECATED. Will be removed in\n+ *  future versions. */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_privkey_tweak_add(\n     const secp256k1_context* ctx,\n     unsigned char *seckey,\n     const unsigned char *tweak\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n /** Tweak a public key by adding tweak times the generator to it.\n- * Returns: 0 if the tweak was out of range (chance of around 1 in 2^128 for\n- *          uniformly random 32-byte arrays, or if the resulting public key\n- *          would be invalid (only when the tweak is the complement of the\n- *          corresponding private key). 1 otherwise.\n- * Args:    ctx:    pointer to a context object initialized for validation\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:    ctx:   pointer to a context object initialized for validation\n  *                  (cannot be NULL).\n- * In/Out:  pubkey: pointer to a public key object.\n- * In:      tweak:  pointer to a 32-byte tweak.\n+ *  In/Out: pubkey: pointer to a public key object. pubkey will be set to an\n+ *                  invalid value if this function returns 0 (cannot be NULL).\n+ *  In:      tweak: pointer to a 32-byte tweak. If the tweak is invalid according to\n+ *                  secp256k1_ec_seckey_verify, this function returns 0. For\n+ *                  uniformly random 32-byte arrays the chance of being invalid\n+ *                  is negligible (around 1 in 2^128) (cannot be NULL).\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_tweak_add(\n     const secp256k1_context* ctx,\n     secp256k1_pubkey *pubkey,\n     const unsigned char *tweak\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n-/** Tweak a private key by multiplying it by a tweak.\n- * Returns: 0 if the tweak was out of range (chance of around 1 in 2^128 for\n- *          uniformly random 32-byte arrays, or equal to zero. 1 otherwise.\n- * Args:   ctx:    pointer to a context object (cannot be NULL).\n- * In/Out: seckey: pointer to a 32-byte private key.\n- * In:     tweak:  pointer to a 32-byte tweak.\n+/** Tweak a secret key by multiplying it by a tweak.\n+ *\n+ *  Returns: 0 if the arguments are invalid. 1 otherwise.\n+ *  Args:   ctx:    pointer to a context object (cannot be NULL).\n+ *  In/Out: seckey: pointer to a 32-byte secret key. If the secret key is\n+ *                  invalid according to secp256k1_ec_seckey_verify, this\n+ *                  function returns 0. seckey will be set to some unspecified\n+ *                  value if this function returns 0. (cannot be NULL)\n+ *  In:      tweak: pointer to a 32-byte tweak. If the tweak is invalid according to\n+ *                  secp256k1_ec_seckey_verify, this function returns 0. For\n+ *                  uniformly random 32-byte arrays the chance of being invalid\n+ *                  is negligible (around 1 in 2^128) (cannot be NULL).\n  */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_seckey_tweak_mul(\n+    const secp256k1_context* ctx,\n+    unsigned char *seckey,\n+    const unsigned char *tweak\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Same as secp256k1_ec_seckey_tweak_mul, but DEPRECATED. Will be removed in\n+ *  future versions. */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_privkey_tweak_mul(\n     const secp256k1_context* ctx,\n     unsigned char *seckey,\n     const unsigned char *tweak\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n /** Tweak a public key by multiplying it by a tweak value.\n- * Returns: 0 if the tweak was out of range (chance of around 1 in 2^128 for\n- *          uniformly random 32-byte arrays, or equal to zero. 1 otherwise.\n- * Args:    ctx:    pointer to a context object initialized for validation\n- *                 (cannot be NULL).\n- * In/Out:  pubkey: pointer to a public key obkect.\n- * In:      tweak:  pointer to a 32-byte tweak.\n+ *\n+ *  Returns: 0 if the arguments are invalid. 1 otherwise.\n+ *  Args:    ctx:   pointer to a context object initialized for validation\n+ *                  (cannot be NULL).\n+ *  In/Out: pubkey: pointer to a public key object. pubkey will be set to an\n+ *                  invalid value if this function returns 0 (cannot be NULL).\n+ *  In:      tweak: pointer to a 32-byte tweak. If the tweak is invalid according to\n+ *                  secp256k1_ec_seckey_verify, this function returns 0. For\n+ *                  uniformly random 32-byte arrays the chance of being invalid\n+ *                  is negligible (around 1 in 2^128) (cannot be NULL).\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_tweak_mul(\n     const secp256k1_context* ctx,\n@@ -636,14 +732,16 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_tweak_mul(\n  * contexts not initialized for signing; then it will have no effect and return 1.\n  *\n  * You should call this after secp256k1_context_create or\n- * secp256k1_context_clone, and may call this repeatedly afterwards.\n+ * secp256k1_context_clone (and secp256k1_context_preallocated_create or\n+ * secp256k1_context_clone, resp.), and you may call this repeatedly afterwards.\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_context_randomize(\n     secp256k1_context* ctx,\n     const unsigned char *seed32\n ) SECP256K1_ARG_NONNULL(1);\n \n /** Add a number of public keys together.\n+ *\n  *  Returns: 1: the sum of the public keys is valid.\n  *           0: the sum of the public keys is not valid.\n  *  Args:   ctx:        pointer to a context object"
      },
      {
        "sha": "4058e9c0436dd430f8cbe8c6a8b63be2a8c5dbc1",
        "filename": "include/secp256k1_ecdh.h",
        "status": "modified",
        "additions": 22,
        "deletions": 15,
        "changes": 37,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67f232b5d874b501c114bced5d764db7f4f5ce99/include/secp256k1_ecdh.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67f232b5d874b501c114bced5d764db7f4f5ce99/include/secp256k1_ecdh.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/include/secp256k1_ecdh.h?ref=67f232b5d874b501c114bced5d764db7f4f5ce99",
        "patch": "@@ -7,43 +7,50 @@\n extern \"C\" {\n #endif\n \n-/** A pointer to a function that applies hash function to a point\n+/** A pointer to a function that hashes an EC point to obtain an ECDH secret\n  *\n- *  Returns: 1 if a point was successfully hashed. 0 will cause ecdh to fail\n- *  Out:    output:     pointer to an array to be filled by the function\n- *  In:     x:          pointer to a 32-byte x coordinate\n- *          y:          pointer to a 32-byte y coordinate\n- *          data:       Arbitrary data pointer that is passed through\n+ *  Returns: 1 if the point was successfully hashed.\n+ *           0 will cause secp256k1_ecdh to fail and return 0.\n+ *           Other return values are not allowed, and the behaviour of\n+ *           secp256k1_ecdh is undefined for other return values.\n+ *  Out:     output:     pointer to an array to be filled by the function\n+ *  In:      x32:        pointer to a 32-byte x coordinate\n+ *           y32:        pointer to a 32-byte y coordinate\n+ *           data:       arbitrary data pointer that is passed through\n  */\n typedef int (*secp256k1_ecdh_hash_function)(\n   unsigned char *output,\n-  const unsigned char *x,\n-  const unsigned char *y,\n+  const unsigned char *x32,\n+  const unsigned char *y32,\n   void *data\n );\n \n-/** An implementation of SHA256 hash function that applies to compressed public key. */\n+/** An implementation of SHA256 hash function that applies to compressed public key.\n+ * Populates the output parameter with 32 bytes. */\n SECP256K1_API extern const secp256k1_ecdh_hash_function secp256k1_ecdh_hash_function_sha256;\n \n-/** A default ecdh hash function (currently equal to secp256k1_ecdh_hash_function_sha256). */\n+/** A default ECDH hash function (currently equal to secp256k1_ecdh_hash_function_sha256).\n+ * Populates the output parameter with 32 bytes. */\n SECP256K1_API extern const secp256k1_ecdh_hash_function secp256k1_ecdh_hash_function_default;\n \n /** Compute an EC Diffie-Hellman secret in constant time\n+ *\n  *  Returns: 1: exponentiation was successful\n- *           0: scalar was invalid (zero or overflow)\n+ *           0: scalar was invalid (zero or overflow) or hashfp returned 0\n  *  Args:    ctx:        pointer to a context object (cannot be NULL)\n- *  Out:     output:     pointer to an array to be filled by the function\n+ *  Out:     output:     pointer to an array to be filled by hashfp\n  *  In:      pubkey:     a pointer to a secp256k1_pubkey containing an\n  *                       initialized public key\n- *           privkey:    a 32-byte scalar with which to multiply the point\n+ *           seckey:     a 32-byte scalar with which to multiply the point\n  *           hashfp:     pointer to a hash function. If NULL, secp256k1_ecdh_hash_function_sha256 is used\n- *           data:       Arbitrary data pointer that is passed through\n+ *                       (in which case, 32 bytes will be written to output)\n+ *           data:       arbitrary data pointer that is passed through to hashfp\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ecdh(\n   const secp256k1_context* ctx,\n   unsigned char *output,\n   const secp256k1_pubkey *pubkey,\n-  const unsigned char *privkey,\n+  const unsigned char *seckey,\n   secp256k1_ecdh_hash_function hashfp,\n   void *data\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);"
      },
      {
        "sha": "a9ae15d5ae8d80264c5dd1e44b17ccf81a2456a4",
        "filename": "include/secp256k1_preallocated.h",
        "status": "added",
        "additions": 128,
        "deletions": 0,
        "changes": 128,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67f232b5d874b501c114bced5d764db7f4f5ce99/include/secp256k1_preallocated.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67f232b5d874b501c114bced5d764db7f4f5ce99/include/secp256k1_preallocated.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/include/secp256k1_preallocated.h?ref=67f232b5d874b501c114bced5d764db7f4f5ce99",
        "patch": "@@ -0,0 +1,128 @@\n+#ifndef SECP256K1_PREALLOCATED_H\n+#define SECP256K1_PREALLOCATED_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* The module provided by this header file is intended for settings in which it\n+ * is not possible or desirable to rely on dynamic memory allocation. It provides\n+ * functions for creating, cloning, and destroying secp256k1 context objects in a\n+ * contiguous fixed-size block of memory provided by the caller.\n+ *\n+ * Context objects created by functions in this module can be used like contexts\n+ * objects created by functions in secp256k1.h, i.e., they can be passed to any\n+ * API function that expects a context object (see secp256k1.h for details). The\n+ * only exception is that context objects created by functions in this module\n+ * must be destroyed using secp256k1_context_preallocated_destroy (in this\n+ * module) instead of secp256k1_context_destroy (in secp256k1.h).\n+ *\n+ * It is guaranteed that functions in this module will not call malloc or its\n+ * friends realloc, calloc, and free.\n+ */\n+\n+/** Determine the memory size of a secp256k1 context object to be created in\n+ *  caller-provided memory.\n+ *\n+ *  The purpose of this function is to determine how much memory must be provided\n+ *  to secp256k1_context_preallocated_create.\n+ *\n+ *  Returns: the required size of the caller-provided memory block\n+ *  In:      flags:    which parts of the context to initialize.\n+ */\n+SECP256K1_API size_t secp256k1_context_preallocated_size(\n+    unsigned int flags\n+) SECP256K1_WARN_UNUSED_RESULT;\n+\n+/** Create a secp256k1 context object in caller-provided memory.\n+ *\n+ *  The caller must provide a pointer to a rewritable contiguous block of memory\n+ *  of size at least secp256k1_context_preallocated_size(flags) bytes, suitably\n+ *  aligned to hold an object of any type.\n+ *\n+ *  The block of memory is exclusively owned by the created context object during\n+ *  the lifetime of this context object, which begins with the call to this\n+ *  function and ends when a call to secp256k1_context_preallocated_destroy\n+ *  (which destroys the context object again) returns. During the lifetime of the\n+ *  context object, the caller is obligated not to access this block of memory,\n+ *  i.e., the caller may not read or write the memory, e.g., by copying the memory\n+ *  contents to a different location or trying to create a second context object\n+ *  in the memory. In simpler words, the prealloc pointer (or any pointer derived\n+ *  from it) should not be used during the lifetime of the context object.\n+ *\n+ *  Returns: a newly created context object.\n+ *  In:      prealloc: a pointer to a rewritable contiguous block of memory of\n+ *                     size at least secp256k1_context_preallocated_size(flags)\n+ *                     bytes, as detailed above (cannot be NULL)\n+ *           flags:    which parts of the context to initialize.\n+ *\n+ *  See also secp256k1_context_randomize (in secp256k1.h)\n+ *  and secp256k1_context_preallocated_destroy.\n+ */\n+SECP256K1_API secp256k1_context* secp256k1_context_preallocated_create(\n+    void* prealloc,\n+    unsigned int flags\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_WARN_UNUSED_RESULT;\n+\n+/** Determine the memory size of a secp256k1 context object to be copied into\n+ *  caller-provided memory.\n+ *\n+ *  Returns: the required size of the caller-provided memory block.\n+ *  In:      ctx: an existing context to copy (cannot be NULL)\n+ */\n+SECP256K1_API size_t secp256k1_context_preallocated_clone_size(\n+    const secp256k1_context* ctx\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_WARN_UNUSED_RESULT;\n+\n+/** Copy a secp256k1 context object into caller-provided memory.\n+ *\n+ *  The caller must provide a pointer to a rewritable contiguous block of memory\n+ *  of size at least secp256k1_context_preallocated_size(flags) bytes, suitably\n+ *  aligned to hold an object of any type.\n+ *\n+ *  The block of memory is exclusively owned by the created context object during\n+ *  the lifetime of this context object, see the description of\n+ *  secp256k1_context_preallocated_create for details.\n+ *\n+ *  Returns: a newly created context object.\n+ *  Args:    ctx:      an existing context to copy (cannot be NULL)\n+ *  In:      prealloc: a pointer to a rewritable contiguous block of memory of\n+ *                     size at least secp256k1_context_preallocated_size(flags)\n+ *                     bytes, as detailed above (cannot be NULL)\n+ */\n+SECP256K1_API secp256k1_context* secp256k1_context_preallocated_clone(\n+    const secp256k1_context* ctx,\n+    void* prealloc\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_WARN_UNUSED_RESULT;\n+\n+/** Destroy a secp256k1 context object that has been created in\n+ *  caller-provided memory.\n+ *\n+ *  The context pointer may not be used afterwards.\n+ *\n+ *  The context to destroy must have been created using\n+ *  secp256k1_context_preallocated_create or secp256k1_context_preallocated_clone.\n+ *  If the context has instead been created using secp256k1_context_create or\n+ *  secp256k1_context_clone, the behaviour is undefined. In that case,\n+ *  secp256k1_context_destroy must be used instead.\n+ *\n+ *  If required, it is the responsibility of the caller to deallocate the block\n+ *  of memory properly after this function returns, e.g., by calling free on the\n+ *  preallocated pointer given to secp256k1_context_preallocated_create or\n+ *  secp256k1_context_preallocated_clone.\n+ *\n+ *  Args:   ctx: an existing context to destroy, constructed using\n+ *               secp256k1_context_preallocated_create or\n+ *               secp256k1_context_preallocated_clone (cannot be NULL)\n+ */\n+SECP256K1_API void secp256k1_context_preallocated_destroy(\n+    secp256k1_context* ctx\n+);\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif /* SECP256K1_PREALLOCATED_H */"
      },
      {
        "sha": "f8ccaecd3dfb188b8f73b00ea107b911703f6b58",
        "filename": "include/secp256k1_recovery.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67f232b5d874b501c114bced5d764db7f4f5ce99/include/secp256k1_recovery.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67f232b5d874b501c114bced5d764db7f4f5ce99/include/secp256k1_recovery.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/include/secp256k1_recovery.h?ref=67f232b5d874b501c114bced5d764db7f4f5ce99",
        "patch": "@@ -70,7 +70,7 @@ SECP256K1_API int secp256k1_ecdsa_recoverable_signature_serialize_compact(\n /** Create a recoverable ECDSA signature.\n  *\n  *  Returns: 1: signature created\n- *           0: the nonce generation function failed, or the private key was invalid.\n+ *           0: the nonce generation function failed, or the secret key was invalid.\n  *  Args:    ctx:    pointer to a context object, initialized for signing (cannot be NULL)\n  *  Out:     sig:    pointer to an array where the signature will be placed (cannot be NULL)\n  *  In:      msg32:  the 32-byte message hash being signed (cannot be NULL)"
      },
      {
        "sha": "9a5bd06721778da61e34ca16dcc60a10b0d20a36",
        "filename": "src/asm/field_10x26_arm.s",
        "status": "modified",
        "additions": 0,
        "deletions": 6,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67f232b5d874b501c114bced5d764db7f4f5ce99/src/asm/field_10x26_arm.s",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67f232b5d874b501c114bced5d764db7f4f5ce99/src/asm/field_10x26_arm.s",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/asm/field_10x26_arm.s?ref=67f232b5d874b501c114bced5d764db7f4f5ce99",
        "patch": "@@ -16,15 +16,9 @@ Note:\n */\n \n \t.syntax unified\n-\t.arch armv7-a\n \t@ eabi attributes - see readelf -A\n-\t.eabi_attribute 8, 1  @ Tag_ARM_ISA_use = yes\n-\t.eabi_attribute 9, 0  @ Tag_Thumb_ISA_use = no\n-\t.eabi_attribute 10, 0 @ Tag_FP_arch = none\n \t.eabi_attribute 24, 1 @ Tag_ABI_align_needed = 8-byte\n \t.eabi_attribute 25, 1 @ Tag_ABI_align_preserved = 8-byte, except leaf SP\n-\t.eabi_attribute 30, 2 @ Tag_ABI_optimization_goals = Aggressive Speed\n-\t.eabi_attribute 34, 1 @ Tag_CPU_unaligned_access = v6\n \t.text\n \n \t@ Field constants"
      },
      {
        "sha": "e9be39d4ca4d4eaacceef15c605a2a3fd8bb2813",
        "filename": "src/basic-config.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67f232b5d874b501c114bced5d764db7f4f5ce99/src/basic-config.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67f232b5d874b501c114bced5d764db7f4f5ce99/src/basic-config.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/basic-config.h?ref=67f232b5d874b501c114bced5d764db7f4f5ce99",
        "patch": "@@ -10,7 +10,10 @@\n #ifdef USE_BASIC_CONFIG\n \n #undef USE_ASM_X86_64\n+#undef USE_ECMULT_STATIC_PRECOMPUTATION\n #undef USE_ENDOMORPHISM\n+#undef USE_EXTERNAL_ASM\n+#undef USE_EXTERNAL_DEFAULT_CALLBACKS\n #undef USE_FIELD_10X26\n #undef USE_FIELD_5X52\n #undef USE_FIELD_INV_BUILTIN\n@@ -21,12 +24,14 @@\n #undef USE_SCALAR_8X32\n #undef USE_SCALAR_INV_BUILTIN\n #undef USE_SCALAR_INV_NUM\n+#undef ECMULT_WINDOW_SIZE\n \n #define USE_NUM_NONE 1\n #define USE_FIELD_INV_BUILTIN 1\n #define USE_SCALAR_INV_BUILTIN 1\n #define USE_FIELD_10X26 1\n #define USE_SCALAR_8X32 1\n+#define ECMULT_WINDOW_SIZE 15\n \n #endif /* USE_BASIC_CONFIG */\n "
      },
      {
        "sha": "9bfed903e04e4ec589277cd96b390e840aa2b015",
        "filename": "src/bench.h",
        "status": "modified",
        "additions": 74,
        "deletions": 23,
        "changes": 97,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67f232b5d874b501c114bced5d764db7f4f5ce99/src/bench.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67f232b5d874b501c114bced5d764db7f4f5ce99/src/bench.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench.h?ref=67f232b5d874b501c114bced5d764db7f4f5ce99",
        "patch": "@@ -7,45 +7,87 @@\n #ifndef SECP256K1_BENCH_H\n #define SECP256K1_BENCH_H\n \n+#include <stdint.h>\n #include <stdio.h>\n #include <string.h>\n-#include <math.h>\n #include \"sys/time.h\"\n \n-static double gettimedouble(void) {\n+static int64_t gettime_i64(void) {\n     struct timeval tv;\n     gettimeofday(&tv, NULL);\n-    return tv.tv_usec * 0.000001 + tv.tv_sec;\n+    return (int64_t)tv.tv_usec + (int64_t)tv.tv_sec * 1000000LL;\n }\n \n-void print_number(double x) {\n-    double y = x;\n-    int c = 0;\n-    if (y < 0.0) {\n-        y = -y;\n+#define FP_EXP (6)\n+#define FP_MULT (1000000LL)\n+\n+/* Format fixed point number. */\n+void print_number(const int64_t x) {\n+    int64_t x_abs, y;\n+    int c, i, rounding;\n+    size_t ptr;\n+    char buffer[30];\n+\n+    if (x == INT64_MIN) {\n+        /* Prevent UB. */\n+        printf(\"ERR\");\n+        return;\n     }\n-    while (y > 0 && y < 100.0) {\n-        y *= 10.0;\n+    x_abs = x < 0 ? -x : x;\n+\n+    /* Determine how many decimals we want to show (more than FP_EXP makes no\n+     * sense). */\n+    y = x_abs;\n+    c = 0;\n+    while (y > 0LL && y < 100LL * FP_MULT && c < FP_EXP) {\n+        y *= 10LL;\n         c++;\n     }\n-    printf(\"%.*f\", c, x);\n+\n+    /* Round to 'c' decimals. */\n+    y = x_abs;\n+    rounding = 0;\n+    for (i = c; i < FP_EXP; ++i) {\n+        rounding = (y % 10) >= 5;\n+        y /= 10;\n+    }\n+    y += rounding;\n+\n+    /* Format and print the number. */\n+    ptr = sizeof(buffer) - 1;\n+    buffer[ptr] = 0;\n+    if (c != 0) {\n+        for (i = 0; i < c; ++i) {\n+            buffer[--ptr] = '0' + (y % 10);\n+            y /= 10;\n+        }\n+        buffer[--ptr] = '.';\n+    }\n+    do {\n+        buffer[--ptr] = '0' + (y % 10);\n+        y /= 10;\n+    } while (y != 0);\n+    if (x < 0) {\n+        buffer[--ptr] = '-';\n+    }\n+    printf(\"%s\", &buffer[ptr]);\n }\n \n-void run_benchmark(char *name, void (*benchmark)(void*), void (*setup)(void*), void (*teardown)(void*), void* data, int count, int iter) {\n+void run_benchmark(char *name, void (*benchmark)(void*, int), void (*setup)(void*), void (*teardown)(void*, int), void* data, int count, int iter) {\n     int i;\n-    double min = HUGE_VAL;\n-    double sum = 0.0;\n-    double max = 0.0;\n+    int64_t min = INT64_MAX;\n+    int64_t sum = 0;\n+    int64_t max = 0;\n     for (i = 0; i < count; i++) {\n-        double begin, total;\n+        int64_t begin, total;\n         if (setup != NULL) {\n             setup(data);\n         }\n-        begin = gettimedouble();\n-        benchmark(data);\n-        total = gettimedouble() - begin;\n+        begin = gettime_i64();\n+        benchmark(data, iter);\n+        total = gettime_i64() - begin;\n         if (teardown != NULL) {\n-            teardown(data);\n+            teardown(data, iter);\n         }\n         if (total < min) {\n             min = total;\n@@ -56,11 +98,11 @@ void run_benchmark(char *name, void (*benchmark)(void*), void (*setup)(void*), v\n         sum += total;\n     }\n     printf(\"%s: min \", name);\n-    print_number(min * 1000000.0 / iter);\n+    print_number(min * FP_MULT / iter);\n     printf(\"us / avg \");\n-    print_number((sum / count) * 1000000.0 / iter);\n+    print_number(((sum * FP_MULT) / count) / iter);\n     printf(\"us / max \");\n-    print_number(max * 1000000.0 / iter);\n+    print_number(max * FP_MULT / iter);\n     printf(\"us\\n\");\n }\n \n@@ -79,4 +121,13 @@ int have_flag(int argc, char** argv, char *flag) {\n     return 0;\n }\n \n+int get_iters(int default_iters) {\n+    char* env = getenv(\"SECP256K1_BENCH_ITERS\");\n+    if (env) {\n+        return strtol(env, NULL, 0);\n+    } else {\n+        return default_iters;\n+    }\n+}\n+\n #endif /* SECP256K1_BENCH_H */"
      },
      {
        "sha": "f099d33884bcfbb2f4fe4c5e27e0342f3e3a1b47",
        "filename": "src/bench_ecdh.c",
        "status": "modified",
        "additions": 10,
        "deletions": 5,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67f232b5d874b501c114bced5d764db7f4f5ce99/src/bench_ecdh.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67f232b5d874b501c114bced5d764db7f4f5ce99/src/bench_ecdh.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench_ecdh.c?ref=67f232b5d874b501c114bced5d764db7f4f5ce99",
        "patch": "@@ -28,27 +28,32 @@ static void bench_ecdh_setup(void* arg) {\n         0xa2, 0xba, 0xd1, 0x84, 0xf8, 0x83, 0xc6, 0x9f\n     };\n \n-    /* create a context with no capabilities */\n-    data->ctx = secp256k1_context_create(SECP256K1_FLAGS_TYPE_CONTEXT);\n     for (i = 0; i < 32; i++) {\n         data->scalar[i] = i + 1;\n     }\n     CHECK(secp256k1_ec_pubkey_parse(data->ctx, &data->point, point, sizeof(point)) == 1);\n }\n \n-static void bench_ecdh(void* arg) {\n+static void bench_ecdh(void* arg, int iters) {\n     int i;\n     unsigned char res[32];\n     bench_ecdh_data *data = (bench_ecdh_data*)arg;\n \n-    for (i = 0; i < 20000; i++) {\n+    for (i = 0; i < iters; i++) {\n         CHECK(secp256k1_ecdh(data->ctx, res, &data->point, data->scalar, NULL, NULL) == 1);\n     }\n }\n \n int main(void) {\n     bench_ecdh_data data;\n \n-    run_benchmark(\"ecdh\", bench_ecdh, bench_ecdh_setup, NULL, &data, 10, 20000);\n+    int iters = get_iters(20000);\n+\n+    /* create a context with no capabilities */\n+    data.ctx = secp256k1_context_create(SECP256K1_FLAGS_TYPE_CONTEXT);\n+\n+    run_benchmark(\"ecdh\", bench_ecdh, bench_ecdh_setup, NULL, &data, 10, iters);\n+\n+    secp256k1_context_destroy(data.ctx);\n     return 0;\n }"
      },
      {
        "sha": "facd07ef31b3eeff19a9adc3e9cceb4c69f800b6",
        "filename": "src/bench_ecmult.c",
        "status": "modified",
        "additions": 28,
        "deletions": 21,
        "changes": 49,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67f232b5d874b501c114bced5d764db7f4f5ce99/src/bench_ecmult.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67f232b5d874b501c114bced5d764db7f4f5ce99/src/bench_ecmult.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench_ecmult.c?ref=67f232b5d874b501c114bced5d764db7f4f5ce99",
        "patch": "@@ -18,7 +18,6 @@\n #include \"secp256k1.c\"\n \n #define POINTS 32768\n-#define ITERS 10000\n \n typedef struct {\n     /* Setup once in advance */\n@@ -55,16 +54,16 @@ static int bench_callback(secp256k1_scalar* sc, secp256k1_ge* ge, size_t idx, vo\n     return 1;\n }\n \n-static void bench_ecmult(void* arg) {\n+static void bench_ecmult(void* arg, int iters) {\n     bench_data* data = (bench_data*)arg;\n \n-    size_t count = data->count;\n     int includes_g = data->includes_g;\n-    size_t iters = 1 + ITERS / count;\n-    size_t iter;\n+    int iter;\n+    int count = data->count;\n+    iters = iters / data->count;\n \n     for (iter = 0; iter < iters; ++iter) {\n-        data->ecmult_multi(&data->ctx->ecmult_ctx, data->scratch, &data->output[iter], data->includes_g ? &data->scalars[data->offset1] : NULL, bench_callback, arg, count - includes_g);\n+        data->ecmult_multi(&data->ctx->error_callback, &data->ctx->ecmult_ctx, data->scratch, &data->output[iter], data->includes_g ? &data->scalars[data->offset1] : NULL, bench_callback, arg, count - includes_g);\n         data->offset1 = (data->offset1 + count) % POINTS;\n         data->offset2 = (data->offset2 + count - 1) % POINTS;\n     }\n@@ -76,10 +75,10 @@ static void bench_ecmult_setup(void* arg) {\n     data->offset2 = (data->count * 0x7f6f537b + 0x6a1a8f49) % POINTS;\n }\n \n-static void bench_ecmult_teardown(void* arg) {\n+static void bench_ecmult_teardown(void* arg, int iters) {\n     bench_data* data = (bench_data*)arg;\n-    size_t iters = 1 + ITERS / data->count;\n-    size_t iter;\n+    int iter;\n+    iters = iters / data->count;\n     /* Verify the results in teardown, to avoid doing comparisons while benchmarking. */\n     for (iter = 0; iter < iters; ++iter) {\n         secp256k1_gej tmp;\n@@ -104,10 +103,10 @@ static void generate_scalar(uint32_t num, secp256k1_scalar* scalar) {\n     CHECK(!overflow);\n }\n \n-static void run_test(bench_data* data, size_t count, int includes_g) {\n+static void run_test(bench_data* data, size_t count, int includes_g, int num_iters) {\n     char str[32];\n     static const secp256k1_scalar zero = SECP256K1_SCALAR_CONST(0, 0, 0, 0, 0, 0, 0, 0);\n-    size_t iters = 1 + ITERS / count;\n+    size_t iters = 1 + num_iters / count;\n     size_t iter;\n \n     data->count = count;\n@@ -130,7 +129,7 @@ static void run_test(bench_data* data, size_t count, int includes_g) {\n \n     /* Run the benchmark. */\n     sprintf(str, includes_g ? \"ecmult_%ig\" : \"ecmult_%i\", (int)count);\n-    run_benchmark(str, bench_ecmult, bench_ecmult_setup, bench_ecmult_teardown, data, 10, count * (1 + ITERS / count));\n+    run_benchmark(str, bench_ecmult, bench_ecmult_setup, bench_ecmult_teardown, data, 10, count * iters);\n }\n \n int main(int argc, char **argv) {\n@@ -139,6 +138,8 @@ int main(int argc, char **argv) {\n     secp256k1_gej* pubkeys_gej;\n     size_t scratch_size;\n \n+    int iters = get_iters(10000);\n+\n     data.ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n     scratch_size = secp256k1_strauss_scratch_size(POINTS) + STRAUSS_SCRATCH_OBJECTS*16;\n     data.scratch = secp256k1_scratch_space_create(data.ctx, scratch_size);\n@@ -154,7 +155,7 @@ int main(int argc, char **argv) {\n         } else if(have_flag(argc, argv, \"simple\")) {\n             printf(\"Using simple algorithm:\\n\");\n             data.ecmult_multi = secp256k1_ecmult_multi_var;\n-            secp256k1_scratch_space_destroy(data.scratch);\n+            secp256k1_scratch_space_destroy(data.ctx, data.scratch);\n             data.scratch = NULL;\n         } else {\n             fprintf(stderr, \"%s: unrecognized argument '%s'.\\n\", argv[0], argv[1]);\n@@ -167,8 +168,8 @@ int main(int argc, char **argv) {\n     data.scalars = malloc(sizeof(secp256k1_scalar) * POINTS);\n     data.seckeys = malloc(sizeof(secp256k1_scalar) * POINTS);\n     data.pubkeys = malloc(sizeof(secp256k1_ge) * POINTS);\n-    data.expected_output = malloc(sizeof(secp256k1_gej) * (ITERS + 1));\n-    data.output = malloc(sizeof(secp256k1_gej) * (ITERS + 1));\n+    data.expected_output = malloc(sizeof(secp256k1_gej) * (iters + 1));\n+    data.output = malloc(sizeof(secp256k1_gej) * (iters + 1));\n \n     /* Generate a set of scalars, and private/public keypairs. */\n     pubkeys_gej = malloc(sizeof(secp256k1_gej) * POINTS);\n@@ -185,18 +186,24 @@ int main(int argc, char **argv) {\n     free(pubkeys_gej);\n \n     for (i = 1; i <= 8; ++i) {\n-        run_test(&data, i, 1);\n+        run_test(&data, i, 1, iters);\n     }\n \n-    for (p = 0; p <= 11; ++p) {\n-        for (i = 9; i <= 16; ++i) {\n-            run_test(&data, i << p, 1);\n+    /* This is disabled with low count of iterations because the loop runs 77 times even with iters=1\n+    * and the higher it goes the longer the computation takes(more points)\n+    * So we don't run this benchmark with low iterations to prevent slow down */\n+     if (iters > 2) {\n+        for (p = 0; p <= 11; ++p) {\n+            for (i = 9; i <= 16; ++i) {\n+                run_test(&data, i << p, 1, iters);\n+            }\n         }\n     }\n-    secp256k1_context_destroy(data.ctx);\n+\n     if (data.scratch != NULL) {\n-        secp256k1_scratch_space_destroy(data.scratch);\n+        secp256k1_scratch_space_destroy(data.ctx, data.scratch);\n     }\n+    secp256k1_context_destroy(data.ctx);\n     free(data.scalars);\n     free(data.pubkeys);\n     free(data.seckeys);"
      },
      {
        "sha": "20759127d3c9f12faa96856f9152edb7487a6c64",
        "filename": "src/bench_internal.c",
        "status": "modified",
        "additions": 113,
        "deletions": 101,
        "changes": 214,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67f232b5d874b501c114bced5d764db7f4f5ce99/src/bench_internal.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67f232b5d874b501c114bced5d764db7f4f5ce99/src/bench_internal.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench_internal.c?ref=67f232b5d874b501c114bced5d764db7f4f5ce99",
        "patch": "@@ -56,314 +56,326 @@ void bench_setup(void* arg) {\n     memcpy(data->data + 32, init_y, 32);\n }\n \n-void bench_scalar_add(void* arg) {\n-    int i;\n+void bench_scalar_add(void* arg, int iters) {\n+    int i, j = 0;\n     bench_inv *data = (bench_inv*)arg;\n \n-    for (i = 0; i < 2000000; i++) {\n-        secp256k1_scalar_add(&data->scalar_x, &data->scalar_x, &data->scalar_y);\n+    for (i = 0; i < iters; i++) {\n+        j += secp256k1_scalar_add(&data->scalar_x, &data->scalar_x, &data->scalar_y);\n     }\n+    CHECK(j <= iters);\n }\n \n-void bench_scalar_negate(void* arg) {\n+void bench_scalar_negate(void* arg, int iters) {\n     int i;\n     bench_inv *data = (bench_inv*)arg;\n \n-    for (i = 0; i < 2000000; i++) {\n+    for (i = 0; i < iters; i++) {\n         secp256k1_scalar_negate(&data->scalar_x, &data->scalar_x);\n     }\n }\n \n-void bench_scalar_sqr(void* arg) {\n+void bench_scalar_sqr(void* arg, int iters) {\n     int i;\n     bench_inv *data = (bench_inv*)arg;\n \n-    for (i = 0; i < 200000; i++) {\n+    for (i = 0; i < iters; i++) {\n         secp256k1_scalar_sqr(&data->scalar_x, &data->scalar_x);\n     }\n }\n \n-void bench_scalar_mul(void* arg) {\n+void bench_scalar_mul(void* arg, int iters) {\n     int i;\n     bench_inv *data = (bench_inv*)arg;\n \n-    for (i = 0; i < 200000; i++) {\n+    for (i = 0; i < iters; i++) {\n         secp256k1_scalar_mul(&data->scalar_x, &data->scalar_x, &data->scalar_y);\n     }\n }\n \n #ifdef USE_ENDOMORPHISM\n-void bench_scalar_split(void* arg) {\n-    int i;\n+void bench_scalar_split(void* arg, int iters) {\n+    int i, j = 0;\n     bench_inv *data = (bench_inv*)arg;\n \n-    for (i = 0; i < 20000; i++) {\n-        secp256k1_scalar l, r;\n-        secp256k1_scalar_split_lambda(&l, &r, &data->scalar_x);\n-        secp256k1_scalar_add(&data->scalar_x, &data->scalar_x, &data->scalar_y);\n+    for (i = 0; i < iters; i++) {\n+        secp256k1_scalar_split_lambda(&data->scalar_x, &data->scalar_y, &data->scalar_x);\n+        j += secp256k1_scalar_add(&data->scalar_x, &data->scalar_x, &data->scalar_y);\n     }\n+    CHECK(j <= iters);\n }\n #endif\n \n-void bench_scalar_inverse(void* arg) {\n-    int i;\n+void bench_scalar_inverse(void* arg, int iters) {\n+    int i, j = 0;\n     bench_inv *data = (bench_inv*)arg;\n \n-    for (i = 0; i < 2000; i++) {\n+    for (i = 0; i < iters; i++) {\n         secp256k1_scalar_inverse(&data->scalar_x, &data->scalar_x);\n-        secp256k1_scalar_add(&data->scalar_x, &data->scalar_x, &data->scalar_y);\n+        j += secp256k1_scalar_add(&data->scalar_x, &data->scalar_x, &data->scalar_y);\n     }\n+    CHECK(j <= iters);\n }\n \n-void bench_scalar_inverse_var(void* arg) {\n-    int i;\n+void bench_scalar_inverse_var(void* arg, int iters) {\n+    int i, j = 0;\n     bench_inv *data = (bench_inv*)arg;\n \n-    for (i = 0; i < 2000; i++) {\n+    for (i = 0; i < iters; i++) {\n         secp256k1_scalar_inverse_var(&data->scalar_x, &data->scalar_x);\n-        secp256k1_scalar_add(&data->scalar_x, &data->scalar_x, &data->scalar_y);\n+        j += secp256k1_scalar_add(&data->scalar_x, &data->scalar_x, &data->scalar_y);\n     }\n+    CHECK(j <= iters);\n }\n \n-void bench_field_normalize(void* arg) {\n+void bench_field_normalize(void* arg, int iters) {\n     int i;\n     bench_inv *data = (bench_inv*)arg;\n \n-    for (i = 0; i < 2000000; i++) {\n+    for (i = 0; i < iters; i++) {\n         secp256k1_fe_normalize(&data->fe_x);\n     }\n }\n \n-void bench_field_normalize_weak(void* arg) {\n+void bench_field_normalize_weak(void* arg, int iters) {\n     int i;\n     bench_inv *data = (bench_inv*)arg;\n \n-    for (i = 0; i < 2000000; i++) {\n+    for (i = 0; i < iters; i++) {\n         secp256k1_fe_normalize_weak(&data->fe_x);\n     }\n }\n \n-void bench_field_mul(void* arg) {\n+void bench_field_mul(void* arg, int iters) {\n     int i;\n     bench_inv *data = (bench_inv*)arg;\n \n-    for (i = 0; i < 200000; i++) {\n+    for (i = 0; i < iters; i++) {\n         secp256k1_fe_mul(&data->fe_x, &data->fe_x, &data->fe_y);\n     }\n }\n \n-void bench_field_sqr(void* arg) {\n+void bench_field_sqr(void* arg, int iters) {\n     int i;\n     bench_inv *data = (bench_inv*)arg;\n \n-    for (i = 0; i < 200000; i++) {\n+    for (i = 0; i < iters; i++) {\n         secp256k1_fe_sqr(&data->fe_x, &data->fe_x);\n     }\n }\n \n-void bench_field_inverse(void* arg) {\n+void bench_field_inverse(void* arg, int iters) {\n     int i;\n     bench_inv *data = (bench_inv*)arg;\n \n-    for (i = 0; i < 20000; i++) {\n+    for (i = 0; i < iters; i++) {\n         secp256k1_fe_inv(&data->fe_x, &data->fe_x);\n         secp256k1_fe_add(&data->fe_x, &data->fe_y);\n     }\n }\n \n-void bench_field_inverse_var(void* arg) {\n+void bench_field_inverse_var(void* arg, int iters) {\n     int i;\n     bench_inv *data = (bench_inv*)arg;\n \n-    for (i = 0; i < 20000; i++) {\n+    for (i = 0; i < iters; i++) {\n         secp256k1_fe_inv_var(&data->fe_x, &data->fe_x);\n         secp256k1_fe_add(&data->fe_x, &data->fe_y);\n     }\n }\n \n-void bench_field_sqrt(void* arg) {\n-    int i;\n+void bench_field_sqrt(void* arg, int iters) {\n+    int i, j = 0;\n     bench_inv *data = (bench_inv*)arg;\n     secp256k1_fe t;\n \n-    for (i = 0; i < 20000; i++) {\n+    for (i = 0; i < iters; i++) {\n         t = data->fe_x;\n-        secp256k1_fe_sqrt(&data->fe_x, &t);\n+        j += secp256k1_fe_sqrt(&data->fe_x, &t);\n         secp256k1_fe_add(&data->fe_x, &data->fe_y);\n     }\n+    CHECK(j <= iters);\n }\n \n-void bench_group_double_var(void* arg) {\n+void bench_group_double_var(void* arg, int iters) {\n     int i;\n     bench_inv *data = (bench_inv*)arg;\n \n-    for (i = 0; i < 200000; i++) {\n+    for (i = 0; i < iters; i++) {\n         secp256k1_gej_double_var(&data->gej_x, &data->gej_x, NULL);\n     }\n }\n \n-void bench_group_add_var(void* arg) {\n+void bench_group_add_var(void* arg, int iters) {\n     int i;\n     bench_inv *data = (bench_inv*)arg;\n \n-    for (i = 0; i < 200000; i++) {\n+    for (i = 0; i < iters; i++) {\n         secp256k1_gej_add_var(&data->gej_x, &data->gej_x, &data->gej_y, NULL);\n     }\n }\n \n-void bench_group_add_affine(void* arg) {\n+void bench_group_add_affine(void* arg, int iters) {\n     int i;\n     bench_inv *data = (bench_inv*)arg;\n \n-    for (i = 0; i < 200000; i++) {\n+    for (i = 0; i < iters; i++) {\n         secp256k1_gej_add_ge(&data->gej_x, &data->gej_x, &data->ge_y);\n     }\n }\n \n-void bench_group_add_affine_var(void* arg) {\n+void bench_group_add_affine_var(void* arg, int iters) {\n     int i;\n     bench_inv *data = (bench_inv*)arg;\n \n-    for (i = 0; i < 200000; i++) {\n+    for (i = 0; i < iters; i++) {\n         secp256k1_gej_add_ge_var(&data->gej_x, &data->gej_x, &data->ge_y, NULL);\n     }\n }\n \n-void bench_group_jacobi_var(void* arg) {\n-    int i;\n+void bench_group_jacobi_var(void* arg, int iters) {\n+    int i, j = 0;\n     bench_inv *data = (bench_inv*)arg;\n \n-    for (i = 0; i < 20000; i++) {\n-        secp256k1_gej_has_quad_y_var(&data->gej_x);\n+    for (i = 0; i < iters; i++) {\n+        j += secp256k1_gej_has_quad_y_var(&data->gej_x);\n     }\n+    CHECK(j == iters);\n }\n \n-void bench_ecmult_wnaf(void* arg) {\n-    int i;\n+void bench_ecmult_wnaf(void* arg, int iters) {\n+    int i, bits = 0, overflow = 0;\n     bench_inv *data = (bench_inv*)arg;\n \n-    for (i = 0; i < 20000; i++) {\n-        secp256k1_ecmult_wnaf(data->wnaf, 256, &data->scalar_x, WINDOW_A);\n-        secp256k1_scalar_add(&data->scalar_x, &data->scalar_x, &data->scalar_y);\n+    for (i = 0; i < iters; i++) {\n+        bits += secp256k1_ecmult_wnaf(data->wnaf, 256, &data->scalar_x, WINDOW_A);\n+        overflow += secp256k1_scalar_add(&data->scalar_x, &data->scalar_x, &data->scalar_y);\n     }\n+    CHECK(overflow >= 0);\n+    CHECK(bits <= 256*iters);\n }\n \n-void bench_wnaf_const(void* arg) {\n-    int i;\n+void bench_wnaf_const(void* arg, int iters) {\n+    int i, bits = 0, overflow = 0;\n     bench_inv *data = (bench_inv*)arg;\n \n-    for (i = 0; i < 20000; i++) {\n-        secp256k1_wnaf_const(data->wnaf, data->scalar_x, WINDOW_A, 256);\n-        secp256k1_scalar_add(&data->scalar_x, &data->scalar_x, &data->scalar_y);\n+    for (i = 0; i < iters; i++) {\n+        bits += secp256k1_wnaf_const(data->wnaf, &data->scalar_x, WINDOW_A, 256);\n+        overflow += secp256k1_scalar_add(&data->scalar_x, &data->scalar_x, &data->scalar_y);\n     }\n+    CHECK(overflow >= 0);\n+    CHECK(bits <= 256*iters);\n }\n \n \n-void bench_sha256(void* arg) {\n+void bench_sha256(void* arg, int iters) {\n     int i;\n     bench_inv *data = (bench_inv*)arg;\n     secp256k1_sha256 sha;\n \n-    for (i = 0; i < 20000; i++) {\n+    for (i = 0; i < iters; i++) {\n         secp256k1_sha256_initialize(&sha);\n         secp256k1_sha256_write(&sha, data->data, 32);\n         secp256k1_sha256_finalize(&sha, data->data);\n     }\n }\n \n-void bench_hmac_sha256(void* arg) {\n+void bench_hmac_sha256(void* arg, int iters) {\n     int i;\n     bench_inv *data = (bench_inv*)arg;\n     secp256k1_hmac_sha256 hmac;\n \n-    for (i = 0; i < 20000; i++) {\n+    for (i = 0; i < iters; i++) {\n         secp256k1_hmac_sha256_initialize(&hmac, data->data, 32);\n         secp256k1_hmac_sha256_write(&hmac, data->data, 32);\n         secp256k1_hmac_sha256_finalize(&hmac, data->data);\n     }\n }\n \n-void bench_rfc6979_hmac_sha256(void* arg) {\n+void bench_rfc6979_hmac_sha256(void* arg, int iters) {\n     int i;\n     bench_inv *data = (bench_inv*)arg;\n     secp256k1_rfc6979_hmac_sha256 rng;\n \n-    for (i = 0; i < 20000; i++) {\n+    for (i = 0; i < iters; i++) {\n         secp256k1_rfc6979_hmac_sha256_initialize(&rng, data->data, 64);\n         secp256k1_rfc6979_hmac_sha256_generate(&rng, data->data, 32);\n     }\n }\n \n-void bench_context_verify(void* arg) {\n+void bench_context_verify(void* arg, int iters) {\n     int i;\n     (void)arg;\n-    for (i = 0; i < 20; i++) {\n+    for (i = 0; i < iters; i++) {\n         secp256k1_context_destroy(secp256k1_context_create(SECP256K1_CONTEXT_VERIFY));\n     }\n }\n \n-void bench_context_sign(void* arg) {\n+void bench_context_sign(void* arg, int iters) {\n     int i;\n     (void)arg;\n-    for (i = 0; i < 200; i++) {\n+    for (i = 0; i < iters; i++) {\n         secp256k1_context_destroy(secp256k1_context_create(SECP256K1_CONTEXT_SIGN));\n     }\n }\n \n #ifndef USE_NUM_NONE\n-void bench_num_jacobi(void* arg) {\n-    int i;\n+void bench_num_jacobi(void* arg, int iters) {\n+    int i, j = 0;\n     bench_inv *data = (bench_inv*)arg;\n     secp256k1_num nx, norder;\n \n     secp256k1_scalar_get_num(&nx, &data->scalar_x);\n     secp256k1_scalar_order_get_num(&norder);\n     secp256k1_scalar_get_num(&norder, &data->scalar_y);\n \n-    for (i = 0; i < 200000; i++) {\n-        secp256k1_num_jacobi(&nx, &norder);\n+    for (i = 0; i < iters; i++) {\n+        j += secp256k1_num_jacobi(&nx, &norder);\n     }\n+    CHECK(j <= iters);\n }\n #endif\n \n int main(int argc, char **argv) {\n     bench_inv data;\n-    if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"add\")) run_benchmark(\"scalar_add\", bench_scalar_add, bench_setup, NULL, &data, 10, 2000000);\n-    if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"negate\")) run_benchmark(\"scalar_negate\", bench_scalar_negate, bench_setup, NULL, &data, 10, 2000000);\n-    if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"sqr\")) run_benchmark(\"scalar_sqr\", bench_scalar_sqr, bench_setup, NULL, &data, 10, 200000);\n-    if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"mul\")) run_benchmark(\"scalar_mul\", bench_scalar_mul, bench_setup, NULL, &data, 10, 200000);\n+    int iters = get_iters(20000);\n+\n+    if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"add\")) run_benchmark(\"scalar_add\", bench_scalar_add, bench_setup, NULL, &data, 10, iters*100);\n+    if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"negate\")) run_benchmark(\"scalar_negate\", bench_scalar_negate, bench_setup, NULL, &data, 10, iters*100);\n+    if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"sqr\")) run_benchmark(\"scalar_sqr\", bench_scalar_sqr, bench_setup, NULL, &data, 10, iters*10);\n+    if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"mul\")) run_benchmark(\"scalar_mul\", bench_scalar_mul, bench_setup, NULL, &data, 10, iters*10);\n #ifdef USE_ENDOMORPHISM\n-    if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"split\")) run_benchmark(\"scalar_split\", bench_scalar_split, bench_setup, NULL, &data, 10, 20000);\n+    if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"split\")) run_benchmark(\"scalar_split\", bench_scalar_split, bench_setup, NULL, &data, 10, iters);\n #endif\n     if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"inverse\")) run_benchmark(\"scalar_inverse\", bench_scalar_inverse, bench_setup, NULL, &data, 10, 2000);\n     if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"inverse\")) run_benchmark(\"scalar_inverse_var\", bench_scalar_inverse_var, bench_setup, NULL, &data, 10, 2000);\n \n-    if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"normalize\")) run_benchmark(\"field_normalize\", bench_field_normalize, bench_setup, NULL, &data, 10, 2000000);\n-    if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"normalize\")) run_benchmark(\"field_normalize_weak\", bench_field_normalize_weak, bench_setup, NULL, &data, 10, 2000000);\n-    if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"sqr\")) run_benchmark(\"field_sqr\", bench_field_sqr, bench_setup, NULL, &data, 10, 200000);\n-    if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"mul\")) run_benchmark(\"field_mul\", bench_field_mul, bench_setup, NULL, &data, 10, 200000);\n-    if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"inverse\")) run_benchmark(\"field_inverse\", bench_field_inverse, bench_setup, NULL, &data, 10, 20000);\n-    if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"inverse\")) run_benchmark(\"field_inverse_var\", bench_field_inverse_var, bench_setup, NULL, &data, 10, 20000);\n-    if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"sqrt\")) run_benchmark(\"field_sqrt\", bench_field_sqrt, bench_setup, NULL, &data, 10, 20000);\n+    if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"normalize\")) run_benchmark(\"field_normalize\", bench_field_normalize, bench_setup, NULL, &data, 10, iters*100);\n+    if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"normalize\")) run_benchmark(\"field_normalize_weak\", bench_field_normalize_weak, bench_setup, NULL, &data, 10, iters*100);\n+    if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"sqr\")) run_benchmark(\"field_sqr\", bench_field_sqr, bench_setup, NULL, &data, 10, iters*10);\n+    if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"mul\")) run_benchmark(\"field_mul\", bench_field_mul, bench_setup, NULL, &data, 10, iters*10);\n+    if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"inverse\")) run_benchmark(\"field_inverse\", bench_field_inverse, bench_setup, NULL, &data, 10, iters);\n+    if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"inverse\")) run_benchmark(\"field_inverse_var\", bench_field_inverse_var, bench_setup, NULL, &data, 10, iters);\n+    if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"sqrt\")) run_benchmark(\"field_sqrt\", bench_field_sqrt, bench_setup, NULL, &data, 10, iters);\n \n-    if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"double\")) run_benchmark(\"group_double_var\", bench_group_double_var, bench_setup, NULL, &data, 10, 200000);\n-    if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"add\")) run_benchmark(\"group_add_var\", bench_group_add_var, bench_setup, NULL, &data, 10, 200000);\n-    if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"add\")) run_benchmark(\"group_add_affine\", bench_group_add_affine, bench_setup, NULL, &data, 10, 200000);\n-    if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"add\")) run_benchmark(\"group_add_affine_var\", bench_group_add_affine_var, bench_setup, NULL, &data, 10, 200000);\n-    if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"jacobi\")) run_benchmark(\"group_jacobi_var\", bench_group_jacobi_var, bench_setup, NULL, &data, 10, 20000);\n+    if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"double\")) run_benchmark(\"group_double_var\", bench_group_double_var, bench_setup, NULL, &data, 10, iters*10);\n+    if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"add\")) run_benchmark(\"group_add_var\", bench_group_add_var, bench_setup, NULL, &data, 10, iters*10);\n+    if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"add\")) run_benchmark(\"group_add_affine\", bench_group_add_affine, bench_setup, NULL, &data, 10, iters*10);\n+    if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"add\")) run_benchmark(\"group_add_affine_var\", bench_group_add_affine_var, bench_setup, NULL, &data, 10, iters*10);\n+    if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"jacobi\")) run_benchmark(\"group_jacobi_var\", bench_group_jacobi_var, bench_setup, NULL, &data, 10, iters);\n \n-    if (have_flag(argc, argv, \"ecmult\") || have_flag(argc, argv, \"wnaf\")) run_benchmark(\"wnaf_const\", bench_wnaf_const, bench_setup, NULL, &data, 10, 20000);\n-    if (have_flag(argc, argv, \"ecmult\") || have_flag(argc, argv, \"wnaf\")) run_benchmark(\"ecmult_wnaf\", bench_ecmult_wnaf, bench_setup, NULL, &data, 10, 20000);\n+    if (have_flag(argc, argv, \"ecmult\") || have_flag(argc, argv, \"wnaf\")) run_benchmark(\"wnaf_const\", bench_wnaf_const, bench_setup, NULL, &data, 10, iters);\n+    if (have_flag(argc, argv, \"ecmult\") || have_flag(argc, argv, \"wnaf\")) run_benchmark(\"ecmult_wnaf\", bench_ecmult_wnaf, bench_setup, NULL, &data, 10, iters);\n \n-    if (have_flag(argc, argv, \"hash\") || have_flag(argc, argv, \"sha256\")) run_benchmark(\"hash_sha256\", bench_sha256, bench_setup, NULL, &data, 10, 20000);\n-    if (have_flag(argc, argv, \"hash\") || have_flag(argc, argv, \"hmac\")) run_benchmark(\"hash_hmac_sha256\", bench_hmac_sha256, bench_setup, NULL, &data, 10, 20000);\n-    if (have_flag(argc, argv, \"hash\") || have_flag(argc, argv, \"rng6979\")) run_benchmark(\"hash_rfc6979_hmac_sha256\", bench_rfc6979_hmac_sha256, bench_setup, NULL, &data, 10, 20000);\n+    if (have_flag(argc, argv, \"hash\") || have_flag(argc, argv, \"sha256\")) run_benchmark(\"hash_sha256\", bench_sha256, bench_setup, NULL, &data, 10, iters);\n+    if (have_flag(argc, argv, \"hash\") || have_flag(argc, argv, \"hmac\")) run_benchmark(\"hash_hmac_sha256\", bench_hmac_sha256, bench_setup, NULL, &data, 10, iters);\n+    if (have_flag(argc, argv, \"hash\") || have_flag(argc, argv, \"rng6979\")) run_benchmark(\"hash_rfc6979_hmac_sha256\", bench_rfc6979_hmac_sha256, bench_setup, NULL, &data, 10, iters);\n \n-    if (have_flag(argc, argv, \"context\") || have_flag(argc, argv, \"verify\")) run_benchmark(\"context_verify\", bench_context_verify, bench_setup, NULL, &data, 10, 20);\n-    if (have_flag(argc, argv, \"context\") || have_flag(argc, argv, \"sign\")) run_benchmark(\"context_sign\", bench_context_sign, bench_setup, NULL, &data, 10, 200);\n+    if (have_flag(argc, argv, \"context\") || have_flag(argc, argv, \"verify\")) run_benchmark(\"context_verify\", bench_context_verify, bench_setup, NULL, &data, 10, 1 + iters/1000);\n+    if (have_flag(argc, argv, \"context\") || have_flag(argc, argv, \"sign\")) run_benchmark(\"context_sign\", bench_context_sign, bench_setup, NULL, &data, 10, 1 + iters/100);\n \n #ifndef USE_NUM_NONE\n-    if (have_flag(argc, argv, \"num\") || have_flag(argc, argv, \"jacobi\")) run_benchmark(\"num_jacobi\", bench_num_jacobi, bench_setup, NULL, &data, 10, 200000);\n+    if (have_flag(argc, argv, \"num\") || have_flag(argc, argv, \"jacobi\")) run_benchmark(\"num_jacobi\", bench_num_jacobi, bench_setup, NULL, &data, 10, iters*10);\n #endif\n     return 0;\n }"
      },
      {
        "sha": "e952ed1215ed12bb7ef28ead6275262d75293dc7",
        "filename": "src/bench_recover.c",
        "status": "modified",
        "additions": 5,
        "deletions": 3,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67f232b5d874b501c114bced5d764db7f4f5ce99/src/bench_recover.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67f232b5d874b501c114bced5d764db7f4f5ce99/src/bench_recover.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench_recover.c?ref=67f232b5d874b501c114bced5d764db7f4f5ce99",
        "patch": "@@ -15,13 +15,13 @@ typedef struct {\n     unsigned char sig[64];\n } bench_recover_data;\n \n-void bench_recover(void* arg) {\n+void bench_recover(void* arg, int iters) {\n     int i;\n     bench_recover_data *data = (bench_recover_data*)arg;\n     secp256k1_pubkey pubkey;\n     unsigned char pubkeyc[33];\n \n-    for (i = 0; i < 20000; i++) {\n+    for (i = 0; i < iters; i++) {\n         int j;\n         size_t pubkeylen = 33;\n         secp256k1_ecdsa_recoverable_signature sig;\n@@ -51,9 +51,11 @@ void bench_recover_setup(void* arg) {\n int main(void) {\n     bench_recover_data data;\n \n+    int iters = get_iters(20000);\n+\n     data.ctx = secp256k1_context_create(SECP256K1_CONTEXT_VERIFY);\n \n-    run_benchmark(\"ecdsa_recover\", bench_recover, bench_recover_setup, NULL, &data, 10, 20000);\n+    run_benchmark(\"ecdsa_recover\", bench_recover, bench_recover_setup, NULL, &data, 10, iters);\n \n     secp256k1_context_destroy(data.ctx);\n     return 0;"
      },
      {
        "sha": "c6b2942cc0c9bdc062b97bbadb24f531b9bedc1e",
        "filename": "src/bench_sign.c",
        "status": "modified",
        "additions": 5,
        "deletions": 3,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67f232b5d874b501c114bced5d764db7f4f5ce99/src/bench_sign.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67f232b5d874b501c114bced5d764db7f4f5ce99/src/bench_sign.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench_sign.c?ref=67f232b5d874b501c114bced5d764db7f4f5ce99",
        "patch": "@@ -26,12 +26,12 @@ static void bench_sign_setup(void* arg) {\n     }\n }\n \n-static void bench_sign_run(void* arg) {\n+static void bench_sign_run(void* arg, int iters) {\n     int i;\n     bench_sign *data = (bench_sign*)arg;\n \n     unsigned char sig[74];\n-    for (i = 0; i < 20000; i++) {\n+    for (i = 0; i < iters; i++) {\n         size_t siglen = 74;\n         int j;\n         secp256k1_ecdsa_signature signature;\n@@ -47,9 +47,11 @@ static void bench_sign_run(void* arg) {\n int main(void) {\n     bench_sign data;\n \n+    int iters = get_iters(20000);\n+\n     data.ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN);\n \n-    run_benchmark(\"ecdsa_sign\", bench_sign_run, bench_sign_setup, NULL, &data, 10, 20000);\n+    run_benchmark(\"ecdsa_sign\", bench_sign_run, bench_sign_setup, NULL, &data, 10, iters);\n \n     secp256k1_context_destroy(data.ctx);\n     return 0;"
      },
      {
        "sha": "272d3e5cc4b4c19addc8eb3c977502872918d8f0",
        "filename": "src/bench_verify.c",
        "status": "modified",
        "additions": 9,
        "deletions": 6,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67f232b5d874b501c114bced5d764db7f4f5ce99/src/bench_verify.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67f232b5d874b501c114bced5d764db7f4f5ce99/src/bench_verify.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench_verify.c?ref=67f232b5d874b501c114bced5d764db7f4f5ce99",
        "patch": "@@ -17,6 +17,7 @@\n #include <openssl/obj_mac.h>\n #endif\n \n+\n typedef struct {\n     secp256k1_context *ctx;\n     unsigned char msg[32];\n@@ -30,11 +31,11 @@ typedef struct {\n #endif\n } benchmark_verify_t;\n \n-static void benchmark_verify(void* arg) {\n+static void benchmark_verify(void* arg, int iters) {\n     int i;\n     benchmark_verify_t* data = (benchmark_verify_t*)arg;\n \n-    for (i = 0; i < 20000; i++) {\n+    for (i = 0; i < iters; i++) {\n         secp256k1_pubkey pubkey;\n         secp256k1_ecdsa_signature sig;\n         data->sig[data->siglen - 1] ^= (i & 0xFF);\n@@ -50,11 +51,11 @@ static void benchmark_verify(void* arg) {\n }\n \n #ifdef ENABLE_OPENSSL_TESTS\n-static void benchmark_verify_openssl(void* arg) {\n+static void benchmark_verify_openssl(void* arg, int iters) {\n     int i;\n     benchmark_verify_t* data = (benchmark_verify_t*)arg;\n \n-    for (i = 0; i < 20000; i++) {\n+    for (i = 0; i < iters; i++) {\n         data->sig[data->siglen - 1] ^= (i & 0xFF);\n         data->sig[data->siglen - 2] ^= ((i >> 8) & 0xFF);\n         data->sig[data->siglen - 3] ^= ((i >> 16) & 0xFF);\n@@ -85,6 +86,8 @@ int main(void) {\n     secp256k1_ecdsa_signature sig;\n     benchmark_verify_t data;\n \n+    int iters = get_iters(20000);\n+\n     data.ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n \n     for (i = 0; i < 32; i++) {\n@@ -100,10 +103,10 @@ int main(void) {\n     data.pubkeylen = 33;\n     CHECK(secp256k1_ec_pubkey_serialize(data.ctx, data.pubkey, &data.pubkeylen, &pubkey, SECP256K1_EC_COMPRESSED) == 1);\n \n-    run_benchmark(\"ecdsa_verify\", benchmark_verify, NULL, NULL, &data, 10, 20000);\n+    run_benchmark(\"ecdsa_verify\", benchmark_verify, NULL, NULL, &data, 10, iters);\n #ifdef ENABLE_OPENSSL_TESTS\n     data.ec_group = EC_GROUP_new_by_curve_name(NID_secp256k1);\n-    run_benchmark(\"ecdsa_verify_openssl\", benchmark_verify_openssl, NULL, NULL, &data, 10, 20000);\n+    run_benchmark(\"ecdsa_verify_openssl\", benchmark_verify_openssl, NULL, NULL, &data, 10, iters);\n     EC_GROUP_free(data.ec_group);\n #endif\n "
      },
      {
        "sha": "5f54b59faa693bc4742d11ad72750ca92b4e1a34",
        "filename": "src/ecdsa_impl.h",
        "status": "modified",
        "additions": 48,
        "deletions": 46,
        "changes": 94,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67f232b5d874b501c114bced5d764db7f4f5ce99/src/ecdsa_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67f232b5d874b501c114bced5d764db7f4f5ce99/src/ecdsa_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecdsa_impl.h?ref=67f232b5d874b501c114bced5d764db7f4f5ce99",
        "patch": "@@ -46,68 +46,73 @@ static const secp256k1_fe secp256k1_ecdsa_const_p_minus_order = SECP256K1_FE_CON\n     0, 0, 0, 1, 0x45512319UL, 0x50B75FC4UL, 0x402DA172UL, 0x2FC9BAEEUL\n );\n \n-static int secp256k1_der_read_len(const unsigned char **sigp, const unsigned char *sigend) {\n-    int lenleft, b1;\n-    size_t ret = 0;\n+static int secp256k1_der_read_len(size_t *len, const unsigned char **sigp, const unsigned char *sigend) {\n+    size_t lenleft;\n+    unsigned char b1;\n+    VERIFY_CHECK(len != NULL);\n+    *len = 0;\n     if (*sigp >= sigend) {\n-        return -1;\n+        return 0;\n     }\n     b1 = *((*sigp)++);\n     if (b1 == 0xFF) {\n         /* X.690-0207 8.1.3.5.c the value 0xFF shall not be used. */\n-        return -1;\n+        return 0;\n     }\n     if ((b1 & 0x80) == 0) {\n         /* X.690-0207 8.1.3.4 short form length octets */\n-        return b1;\n+        *len = b1;\n+        return 1;\n     }\n     if (b1 == 0x80) {\n         /* Indefinite length is not allowed in DER. */\n-        return -1;\n+        return 0;\n     }\n     /* X.690-207 8.1.3.5 long form length octets */\n-    lenleft = b1 & 0x7F;\n-    if (lenleft > sigend - *sigp) {\n-        return -1;\n+    lenleft = b1 & 0x7F; /* lenleft is at least 1 */\n+    if (lenleft > (size_t)(sigend - *sigp)) {\n+        return 0;\n     }\n     if (**sigp == 0) {\n         /* Not the shortest possible length encoding. */\n-        return -1;\n+        return 0;\n     }\n-    if ((size_t)lenleft > sizeof(size_t)) {\n+    if (lenleft > sizeof(size_t)) {\n         /* The resulting length would exceed the range of a size_t, so\n          * certainly longer than the passed array size.\n          */\n-        return -1;\n+        return 0;\n     }\n     while (lenleft > 0) {\n-        ret = (ret << 8) | **sigp;\n-        if (ret + lenleft > (size_t)(sigend - *sigp)) {\n-            /* Result exceeds the length of the passed array. */\n-            return -1;\n-        }\n+        *len = (*len << 8) | **sigp;\n         (*sigp)++;\n         lenleft--;\n     }\n-    if (ret < 128) {\n+    if (*len > (size_t)(sigend - *sigp)) {\n+        /* Result exceeds the length of the passed array. */\n+        return 0;\n+    }\n+    if (*len < 128) {\n         /* Not the shortest possible length encoding. */\n-        return -1;\n+        return 0;\n     }\n-    return ret;\n+    return 1;\n }\n \n static int secp256k1_der_parse_integer(secp256k1_scalar *r, const unsigned char **sig, const unsigned char *sigend) {\n     int overflow = 0;\n     unsigned char ra[32] = {0};\n-    int rlen;\n+    size_t rlen;\n \n     if (*sig == sigend || **sig != 0x02) {\n         /* Not a primitive integer (X.690-0207 8.3.1). */\n         return 0;\n     }\n     (*sig)++;\n-    rlen = secp256k1_der_read_len(sig, sigend);\n-    if (rlen <= 0 || (*sig) + rlen > sigend) {\n+    if (secp256k1_der_read_len(&rlen, sig, sigend) == 0) {\n+        return 0;\n+    }\n+    if (rlen == 0 || *sig + rlen > sigend) {\n         /* Exceeds bounds or not at least length 1 (X.690-0207 8.3.1).  */\n         return 0;\n     }\n@@ -123,8 +128,11 @@ static int secp256k1_der_parse_integer(secp256k1_scalar *r, const unsigned char\n         /* Negative. */\n         overflow = 1;\n     }\n-    while (rlen > 0 && **sig == 0) {\n-        /* Skip leading zero bytes */\n+    /* There is at most one leading zero byte:\n+     * if there were two leading zero bytes, we would have failed and returned 0\n+     * because of excessive 0x00 padding already. */\n+    if (rlen > 0 && **sig == 0) {\n+        /* Skip leading zero byte */\n         rlen--;\n         (*sig)++;\n     }\n@@ -144,18 +152,16 @@ static int secp256k1_der_parse_integer(secp256k1_scalar *r, const unsigned char\n \n static int secp256k1_ecdsa_sig_parse(secp256k1_scalar *rr, secp256k1_scalar *rs, const unsigned char *sig, size_t size) {\n     const unsigned char *sigend = sig + size;\n-    int rlen;\n+    size_t rlen;\n     if (sig == sigend || *(sig++) != 0x30) {\n         /* The encoding doesn't start with a constructed sequence (X.690-0207 8.9.1). */\n         return 0;\n     }\n-    rlen = secp256k1_der_read_len(&sig, sigend);\n-    if (rlen < 0 || sig + rlen > sigend) {\n-        /* Tuple exceeds bounds */\n+    if (secp256k1_der_read_len(&rlen, &sig, sigend) == 0) {\n         return 0;\n     }\n-    if (sig + rlen != sigend) {\n-        /* Garbage after tuple. */\n+    if (rlen != (size_t)(sigend - sig)) {\n+        /* Tuple exceeds bounds or garage after tuple. */\n         return 0;\n     }\n \n@@ -274,22 +280,19 @@ static int secp256k1_ecdsa_sig_sign(const secp256k1_ecmult_gen_context *ctx, sec\n     secp256k1_ge r;\n     secp256k1_scalar n;\n     int overflow = 0;\n+    int high;\n \n     secp256k1_ecmult_gen(ctx, &rp, nonce);\n     secp256k1_ge_set_gej(&r, &rp);\n     secp256k1_fe_normalize(&r.x);\n     secp256k1_fe_normalize(&r.y);\n     secp256k1_fe_get_b32(b, &r.x);\n     secp256k1_scalar_set_b32(sigr, b, &overflow);\n-    /* These two conditions should be checked before calling */\n-    VERIFY_CHECK(!secp256k1_scalar_is_zero(sigr));\n-    VERIFY_CHECK(overflow == 0);\n-\n     if (recid) {\n         /* The overflow condition is cryptographically unreachable as hitting it requires finding the discrete log\n          * of some P where P.x >= order, and only 1 in about 2^127 points meet this criteria.\n          */\n-        *recid = (overflow ? 2 : 0) | (secp256k1_fe_is_odd(&r.y) ? 1 : 0);\n+        *recid = (overflow << 1) | secp256k1_fe_is_odd(&r.y);\n     }\n     secp256k1_scalar_mul(&n, sigr, seckey);\n     secp256k1_scalar_add(&n, &n, message);\n@@ -298,16 +301,15 @@ static int secp256k1_ecdsa_sig_sign(const secp256k1_ecmult_gen_context *ctx, sec\n     secp256k1_scalar_clear(&n);\n     secp256k1_gej_clear(&rp);\n     secp256k1_ge_clear(&r);\n-    if (secp256k1_scalar_is_zero(sigs)) {\n-        return 0;\n-    }\n-    if (secp256k1_scalar_is_high(sigs)) {\n-        secp256k1_scalar_negate(sigs, sigs);\n-        if (recid) {\n-            *recid ^= 1;\n-        }\n+    high = secp256k1_scalar_is_high(sigs);\n+    secp256k1_scalar_cond_negate(sigs, high);\n+    if (recid) {\n+            *recid ^= high;\n     }\n-    return 1;\n+    /* P.x = order is on the curve, so technically sig->r could end up being zero, which would be an invalid signature.\n+     * This is cryptographically unreachable as hitting it requires finding the discrete log of P.x = N.\n+     */\n+    return !secp256k1_scalar_is_zero(sigr) & !secp256k1_scalar_is_zero(sigs);\n }\n \n #endif /* SECP256K1_ECDSA_IMPL_H */"
      },
      {
        "sha": "e2e72d93039a72b1ba1837b3b5e392f4ea28759e",
        "filename": "src/eckey_impl.h",
        "status": "modified",
        "additions": 4,
        "deletions": 8,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67f232b5d874b501c114bced5d764db7f4f5ce99/src/eckey_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67f232b5d874b501c114bced5d764db7f4f5ce99/src/eckey_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/eckey_impl.h?ref=67f232b5d874b501c114bced5d764db7f4f5ce99",
        "patch": "@@ -54,10 +54,7 @@ static int secp256k1_eckey_pubkey_serialize(secp256k1_ge *elem, unsigned char *p\n \n static int secp256k1_eckey_privkey_tweak_add(secp256k1_scalar *key, const secp256k1_scalar *tweak) {\n     secp256k1_scalar_add(key, key, tweak);\n-    if (secp256k1_scalar_is_zero(key)) {\n-        return 0;\n-    }\n-    return 1;\n+    return !secp256k1_scalar_is_zero(key);\n }\n \n static int secp256k1_eckey_pubkey_tweak_add(const secp256k1_ecmult_context *ctx, secp256k1_ge *key, const secp256k1_scalar *tweak) {\n@@ -75,12 +72,11 @@ static int secp256k1_eckey_pubkey_tweak_add(const secp256k1_ecmult_context *ctx,\n }\n \n static int secp256k1_eckey_privkey_tweak_mul(secp256k1_scalar *key, const secp256k1_scalar *tweak) {\n-    if (secp256k1_scalar_is_zero(tweak)) {\n-        return 0;\n-    }\n+    int ret;\n+    ret = !secp256k1_scalar_is_zero(tweak);\n \n     secp256k1_scalar_mul(key, key, tweak);\n-    return 1;\n+    return ret;\n }\n \n static int secp256k1_eckey_pubkey_tweak_mul(const secp256k1_ecmult_context *ctx, secp256k1_ge *key, const secp256k1_scalar *tweak) {"
      },
      {
        "sha": "c9b198239d88974078443897b099851f94a6d395",
        "filename": "src/ecmult.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67f232b5d874b501c114bced5d764db7f4f5ce99/src/ecmult.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67f232b5d874b501c114bced5d764db7f4f5ce99/src/ecmult.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecmult.h?ref=67f232b5d874b501c114bced5d764db7f4f5ce99",
        "patch": "@@ -20,10 +20,10 @@ typedef struct {\n #endif\n } secp256k1_ecmult_context;\n \n+static const size_t SECP256K1_ECMULT_CONTEXT_PREALLOCATED_SIZE;\n static void secp256k1_ecmult_context_init(secp256k1_ecmult_context *ctx);\n-static void secp256k1_ecmult_context_build(secp256k1_ecmult_context *ctx, const secp256k1_callback *cb);\n-static void secp256k1_ecmult_context_clone(secp256k1_ecmult_context *dst,\n-                                           const secp256k1_ecmult_context *src, const secp256k1_callback *cb);\n+static void secp256k1_ecmult_context_build(secp256k1_ecmult_context *ctx, void **prealloc);\n+static void secp256k1_ecmult_context_finalize_memcpy(secp256k1_ecmult_context *dst, const secp256k1_ecmult_context *src);\n static void secp256k1_ecmult_context_clear(secp256k1_ecmult_context *ctx);\n static int secp256k1_ecmult_context_is_built(const secp256k1_ecmult_context *ctx);\n \n@@ -43,6 +43,6 @@ typedef int (secp256k1_ecmult_multi_callback)(secp256k1_scalar *sc, secp256k1_ge\n  *          0 if there is not enough scratch space for a single point or\n  *          callback returns 0\n  */\n-static int secp256k1_ecmult_multi_var(const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n);\n+static int secp256k1_ecmult_multi_var(const secp256k1_callback* error_callback, const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n);\n \n #endif /* SECP256K1_ECMULT_H */"
      },
      {
        "sha": "03bb33257d532f8a7345bd4b8f7b090ddb346a92",
        "filename": "src/ecmult_const.h",
        "status": "modified",
        "additions": 5,
        "deletions": 2,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67f232b5d874b501c114bced5d764db7f4f5ce99/src/ecmult_const.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67f232b5d874b501c114bced5d764db7f4f5ce99/src/ecmult_const.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecmult_const.h?ref=67f232b5d874b501c114bced5d764db7f4f5ce99",
        "patch": "@@ -10,8 +10,11 @@\n #include \"scalar.h\"\n #include \"group.h\"\n \n-/* Here `bits` should be set to the maximum bitlength of the _absolute value_ of `q`, plus\n- * one because we internally sometimes add 2 to the number during the WNAF conversion. */\n+/**\n+ * Multiply: R = q*A (in constant-time)\n+ * Here `bits` should be set to the maximum bitlength of the _absolute value_ of `q`, plus\n+ * one because we internally sometimes add 2 to the number during the WNAF conversion.\n+ */\n static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, const secp256k1_scalar *q, int bits);\n \n #endif /* SECP256K1_ECMULT_CONST_H */"
      },
      {
        "sha": "6d6d354aa4e1aa4583af6f9591800c5618c48fa1",
        "filename": "src/ecmult_const_impl.h",
        "status": "modified",
        "additions": 30,
        "deletions": 19,
        "changes": 49,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67f232b5d874b501c114bced5d764db7f4f5ce99/src/ecmult_const_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67f232b5d874b501c114bced5d764db7f4f5ce99/src/ecmult_const_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecmult_const_impl.h?ref=67f232b5d874b501c114bced5d764db7f4f5ce99",
        "patch": "@@ -14,16 +14,22 @@\n \n /* This is like `ECMULT_TABLE_GET_GE` but is constant time */\n #define ECMULT_CONST_TABLE_GET_GE(r,pre,n,w) do { \\\n-    int m; \\\n-    int abs_n = (n) * (((n) > 0) * 2 - 1); \\\n-    int idx_n = abs_n / 2; \\\n+    int m = 0; \\\n+    /* Extract the sign-bit for a constant time absolute-value. */ \\\n+    int mask = (n) >> (sizeof(n) * CHAR_BIT - 1); \\\n+    int abs_n = ((n) + mask) ^ mask; \\\n+    int idx_n = abs_n >> 1; \\\n     secp256k1_fe neg_y; \\\n     VERIFY_CHECK(((n) & 1) == 1); \\\n     VERIFY_CHECK((n) >= -((1 << ((w)-1)) - 1)); \\\n     VERIFY_CHECK((n) <=  ((1 << ((w)-1)) - 1)); \\\n     VERIFY_SETUP(secp256k1_fe_clear(&(r)->x)); \\\n     VERIFY_SETUP(secp256k1_fe_clear(&(r)->y)); \\\n-    for (m = 0; m < ECMULT_TABLE_SIZE(w); m++) { \\\n+    /* Unconditionally set r->x = (pre)[m].x. r->y = (pre)[m].y. because it's either the correct one \\\n+     * or will get replaced in the later iterations, this is needed to make sure `r` is initialized. */ \\\n+    (r)->x = (pre)[m].x; \\\n+    (r)->y = (pre)[m].y; \\\n+    for (m = 1; m < ECMULT_TABLE_SIZE(w); m++) { \\\n         /* This loop is used to avoid secret data in array indices. See\n          * the comment in ecmult_gen_impl.h for rationale. */ \\\n         secp256k1_fe_cmov(&(r)->x, &(pre)[m].x, m == idx_n); \\\n@@ -44,11 +50,11 @@\n  *\n  *  Adapted from `The Width-w NAF Method Provides Small Memory and Fast Elliptic Scalar\n  *  Multiplications Secure against Side Channel Attacks`, Okeya and Tagaki. M. Joye (Ed.)\n- *  CT-RSA 2003, LNCS 2612, pp. 328-443, 2003. Springer-Verlagy Berlin Heidelberg 2003\n+ *  CT-RSA 2003, LNCS 2612, pp. 328-443, 2003. Springer-Verlag Berlin Heidelberg 2003\n  *\n  *  Numbers reference steps of `Algorithm SPA-resistant Width-w NAF with Odd Scalar` on pp. 335\n  */\n-static int secp256k1_wnaf_const(int *wnaf, secp256k1_scalar s, int w, int size) {\n+static int secp256k1_wnaf_const(int *wnaf, const secp256k1_scalar *scalar, int w, int size) {\n     int global_sign;\n     int skew = 0;\n     int word = 0;\n@@ -59,8 +65,12 @@ static int secp256k1_wnaf_const(int *wnaf, secp256k1_scalar s, int w, int size)\n \n     int flip;\n     int bit;\n-    secp256k1_scalar neg_s;\n+    secp256k1_scalar s;\n     int not_neg_one;\n+\n+    VERIFY_CHECK(w > 0);\n+    VERIFY_CHECK(size > 0);\n+\n     /* Note that we cannot handle even numbers by negating them to be odd, as is\n      * done in other implementations, since if our scalars were specified to have\n      * width < 256 for performance reasons, their negations would have width 256\n@@ -75,12 +85,13 @@ static int secp256k1_wnaf_const(int *wnaf, secp256k1_scalar s, int w, int size)\n      * {1, 2} we want to add to the scalar when ensuring that it's odd. Further\n      * complicating things, -1 interacts badly with `secp256k1_scalar_cadd_bit` and\n      * we need to special-case it in this logic. */\n-    flip = secp256k1_scalar_is_high(&s);\n+    flip = secp256k1_scalar_is_high(scalar);\n     /* We add 1 to even numbers, 2 to odd ones, noting that negation flips parity */\n-    bit = flip ^ !secp256k1_scalar_is_even(&s);\n+    bit = flip ^ !secp256k1_scalar_is_even(scalar);\n     /* We check for negative one, since adding 2 to it will cause an overflow */\n-    secp256k1_scalar_negate(&neg_s, &s);\n-    not_neg_one = !secp256k1_scalar_is_one(&neg_s);\n+    secp256k1_scalar_negate(&s, scalar);\n+    not_neg_one = !secp256k1_scalar_is_one(&s);\n+    s = *scalar;\n     secp256k1_scalar_cadd_bit(&s, bit, not_neg_one);\n     /* If we had negative one, flip == 1, s.d[0] == 0, bit == 1, so caller expects\n      * that we added two to it and flipped it. In fact for -1 these operations are\n@@ -93,7 +104,7 @@ static int secp256k1_wnaf_const(int *wnaf, secp256k1_scalar s, int w, int size)\n \n     /* 4 */\n     u_last = secp256k1_scalar_shr_int(&s, w);\n-    while (word * w < size) {\n+    do {\n         int sign;\n         int even;\n \n@@ -109,7 +120,7 @@ static int secp256k1_wnaf_const(int *wnaf, secp256k1_scalar s, int w, int size)\n         wnaf[word++] = u_last * global_sign;\n \n         u_last = u;\n-    }\n+    } while (word * w < size);\n     wnaf[word] = u * global_sign;\n \n     VERIFY_CHECK(secp256k1_scalar_is_zero(&s));\n@@ -132,21 +143,20 @@ static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, cons\n     int wnaf_1[1 + WNAF_SIZE(WINDOW_A - 1)];\n \n     int i;\n-    secp256k1_scalar sc = *scalar;\n \n     /* build wnaf representation for q. */\n     int rsize = size;\n #ifdef USE_ENDOMORPHISM\n     if (size > 128) {\n         rsize = 128;\n         /* split q into q_1 and q_lam (where q = q_1 + q_lam*lambda, and q_1 and q_lam are ~128 bit) */\n-        secp256k1_scalar_split_lambda(&q_1, &q_lam, &sc);\n-        skew_1   = secp256k1_wnaf_const(wnaf_1,   q_1,   WINDOW_A - 1, 128);\n-        skew_lam = secp256k1_wnaf_const(wnaf_lam, q_lam, WINDOW_A - 1, 128);\n+        secp256k1_scalar_split_lambda(&q_1, &q_lam, scalar);\n+        skew_1   = secp256k1_wnaf_const(wnaf_1,   &q_1,   WINDOW_A - 1, 128);\n+        skew_lam = secp256k1_wnaf_const(wnaf_lam, &q_lam, WINDOW_A - 1, 128);\n     } else\n #endif\n     {\n-        skew_1   = secp256k1_wnaf_const(wnaf_1, sc, WINDOW_A - 1, size);\n+        skew_1   = secp256k1_wnaf_const(wnaf_1, scalar, WINDOW_A - 1, size);\n #ifdef USE_ENDOMORPHISM\n         skew_lam = 0;\n #endif\n@@ -168,6 +178,7 @@ static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, cons\n         for (i = 0; i < ECMULT_TABLE_SIZE(WINDOW_A); i++) {\n             secp256k1_ge_mul_lambda(&pre_a_lam[i], &pre_a[i]);\n         }\n+\n     }\n #endif\n \n@@ -191,7 +202,7 @@ static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, cons\n         int n;\n         int j;\n         for (j = 0; j < WINDOW_A - 1; ++j) {\n-            secp256k1_gej_double_nonzero(r, r, NULL);\n+            secp256k1_gej_double_nonzero(r, r);\n         }\n \n         n = wnaf_1[i];"
      },
      {
        "sha": "30815e5aa10e7866a99ca4fe6a3b85795c3a2bd0",
        "filename": "src/ecmult_gen.h",
        "status": "modified",
        "additions": 18,
        "deletions": 11,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67f232b5d874b501c114bced5d764db7f4f5ce99/src/ecmult_gen.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67f232b5d874b501c114bced5d764db7f4f5ce99/src/ecmult_gen.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecmult_gen.h?ref=67f232b5d874b501c114bced5d764db7f4f5ce99",
        "patch": "@@ -10,28 +10,35 @@\n #include \"scalar.h\"\n #include \"group.h\"\n \n+#if ECMULT_GEN_PREC_BITS != 2 && ECMULT_GEN_PREC_BITS != 4 && ECMULT_GEN_PREC_BITS != 8\n+#  error \"Set ECMULT_GEN_PREC_BITS to 2, 4 or 8.\"\n+#endif\n+#define ECMULT_GEN_PREC_B ECMULT_GEN_PREC_BITS\n+#define ECMULT_GEN_PREC_G (1 << ECMULT_GEN_PREC_B)\n+#define ECMULT_GEN_PREC_N (256 / ECMULT_GEN_PREC_B)\n+\n typedef struct {\n     /* For accelerating the computation of a*G:\n      * To harden against timing attacks, use the following mechanism:\n-     * * Break up the multiplicand into groups of 4 bits, called n_0, n_1, n_2, ..., n_63.\n-     * * Compute sum(n_i * 16^i * G + U_i, i=0..63), where:\n-     *   * U_i = U * 2^i (for i=0..62)\n-     *   * U_i = U * (1-2^63) (for i=63)\n-     *   where U is a point with no known corresponding scalar. Note that sum(U_i, i=0..63) = 0.\n-     * For each i, and each of the 16 possible values of n_i, (n_i * 16^i * G + U_i) is\n-     * precomputed (call it prec(i, n_i)). The formula now becomes sum(prec(i, n_i), i=0..63).\n+     * * Break up the multiplicand into groups of PREC_B bits, called n_0, n_1, n_2, ..., n_(PREC_N-1).\n+     * * Compute sum(n_i * (PREC_G)^i * G + U_i, i=0 ... PREC_N-1), where:\n+     *   * U_i = U * 2^i, for i=0 ... PREC_N-2\n+     *   * U_i = U * (1-2^(PREC_N-1)), for i=PREC_N-1\n+     *   where U is a point with no known corresponding scalar. Note that sum(U_i, i=0 ... PREC_N-1) = 0.\n+     * For each i, and each of the PREC_G possible values of n_i, (n_i * (PREC_G)^i * G + U_i) is\n+     * precomputed (call it prec(i, n_i)). The formula now becomes sum(prec(i, n_i), i=0 ... PREC_N-1).\n      * None of the resulting prec group elements have a known scalar, and neither do any of\n      * the intermediate sums while computing a*G.\n      */\n-    secp256k1_ge_storage (*prec)[64][16]; /* prec[j][i] = 16^j * i * G + U_i */\n+    secp256k1_ge_storage (*prec)[ECMULT_GEN_PREC_N][ECMULT_GEN_PREC_G]; /* prec[j][i] = (PREC_G)^j * i * G + U_i */\n     secp256k1_scalar blind;\n     secp256k1_gej initial;\n } secp256k1_ecmult_gen_context;\n \n+static const size_t SECP256K1_ECMULT_GEN_CONTEXT_PREALLOCATED_SIZE;\n static void secp256k1_ecmult_gen_context_init(secp256k1_ecmult_gen_context* ctx);\n-static void secp256k1_ecmult_gen_context_build(secp256k1_ecmult_gen_context* ctx, const secp256k1_callback* cb);\n-static void secp256k1_ecmult_gen_context_clone(secp256k1_ecmult_gen_context *dst,\n-                                               const secp256k1_ecmult_gen_context* src, const secp256k1_callback* cb);\n+static void secp256k1_ecmult_gen_context_build(secp256k1_ecmult_gen_context* ctx, void **prealloc);\n+static void secp256k1_ecmult_gen_context_finalize_memcpy(secp256k1_ecmult_gen_context *dst, const secp256k1_ecmult_gen_context* src);\n static void secp256k1_ecmult_gen_context_clear(secp256k1_ecmult_gen_context* ctx);\n static int secp256k1_ecmult_gen_context_is_built(const secp256k1_ecmult_gen_context* ctx);\n "
      },
      {
        "sha": "30ac16518bf4872cca6fe7d783851d59b0164230",
        "filename": "src/ecmult_gen_impl.h",
        "status": "modified",
        "additions": 48,
        "deletions": 50,
        "changes": 98,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67f232b5d874b501c114bced5d764db7f4f5ce99/src/ecmult_gen_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67f232b5d874b501c114bced5d764db7f4f5ce99/src/ecmult_gen_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecmult_gen_impl.h?ref=67f232b5d874b501c114bced5d764db7f4f5ce99",
        "patch": "@@ -7,30 +7,40 @@\n #ifndef SECP256K1_ECMULT_GEN_IMPL_H\n #define SECP256K1_ECMULT_GEN_IMPL_H\n \n+#include \"util.h\"\n #include \"scalar.h\"\n #include \"group.h\"\n #include \"ecmult_gen.h\"\n #include \"hash_impl.h\"\n #ifdef USE_ECMULT_STATIC_PRECOMPUTATION\n #include \"ecmult_static_context.h\"\n #endif\n+\n+#ifndef USE_ECMULT_STATIC_PRECOMPUTATION\n+    static const size_t SECP256K1_ECMULT_GEN_CONTEXT_PREALLOCATED_SIZE = ROUND_TO_ALIGN(sizeof(*((secp256k1_ecmult_gen_context*) NULL)->prec));\n+#else\n+    static const size_t SECP256K1_ECMULT_GEN_CONTEXT_PREALLOCATED_SIZE = 0;\n+#endif\n+\n static void secp256k1_ecmult_gen_context_init(secp256k1_ecmult_gen_context *ctx) {\n     ctx->prec = NULL;\n }\n \n-static void secp256k1_ecmult_gen_context_build(secp256k1_ecmult_gen_context *ctx, const secp256k1_callback* cb) {\n+static void secp256k1_ecmult_gen_context_build(secp256k1_ecmult_gen_context *ctx, void **prealloc) {\n #ifndef USE_ECMULT_STATIC_PRECOMPUTATION\n-    secp256k1_ge prec[1024];\n+    secp256k1_ge prec[ECMULT_GEN_PREC_N * ECMULT_GEN_PREC_G];\n     secp256k1_gej gj;\n     secp256k1_gej nums_gej;\n     int i, j;\n+    size_t const prealloc_size = SECP256K1_ECMULT_GEN_CONTEXT_PREALLOCATED_SIZE;\n+    void* const base = *prealloc;\n #endif\n \n     if (ctx->prec != NULL) {\n         return;\n     }\n #ifndef USE_ECMULT_STATIC_PRECOMPUTATION\n-    ctx->prec = (secp256k1_ge_storage (*)[64][16])checked_malloc(cb, sizeof(*ctx->prec));\n+    ctx->prec = (secp256k1_ge_storage (*)[ECMULT_GEN_PREC_N][ECMULT_GEN_PREC_G])manual_alloc(prealloc, prealloc_size, base, prealloc_size);\n \n     /* get the generator */\n     secp256k1_gej_set_ge(&gj, &secp256k1_ge_const_g);\n@@ -54,39 +64,39 @@ static void secp256k1_ecmult_gen_context_build(secp256k1_ecmult_gen_context *ctx\n \n     /* compute prec. */\n     {\n-        secp256k1_gej precj[1024]; /* Jacobian versions of prec. */\n+        secp256k1_gej precj[ECMULT_GEN_PREC_N * ECMULT_GEN_PREC_G]; /* Jacobian versions of prec. */\n         secp256k1_gej gbase;\n         secp256k1_gej numsbase;\n-        gbase = gj; /* 16^j * G */\n+        gbase = gj; /* PREC_G^j * G */\n         numsbase = nums_gej; /* 2^j * nums. */\n-        for (j = 0; j < 64; j++) {\n-            /* Set precj[j*16 .. j*16+15] to (numsbase, numsbase + gbase, ..., numsbase + 15*gbase). */\n-            precj[j*16] = numsbase;\n-            for (i = 1; i < 16; i++) {\n-                secp256k1_gej_add_var(&precj[j*16 + i], &precj[j*16 + i - 1], &gbase, NULL);\n+        for (j = 0; j < ECMULT_GEN_PREC_N; j++) {\n+            /* Set precj[j*PREC_G .. j*PREC_G+(PREC_G-1)] to (numsbase, numsbase + gbase, ..., numsbase + (PREC_G-1)*gbase). */\n+            precj[j*ECMULT_GEN_PREC_G] = numsbase;\n+            for (i = 1; i < ECMULT_GEN_PREC_G; i++) {\n+                secp256k1_gej_add_var(&precj[j*ECMULT_GEN_PREC_G + i], &precj[j*ECMULT_GEN_PREC_G + i - 1], &gbase, NULL);\n             }\n-            /* Multiply gbase by 16. */\n-            for (i = 0; i < 4; i++) {\n+            /* Multiply gbase by PREC_G. */\n+            for (i = 0; i < ECMULT_GEN_PREC_B; i++) {\n                 secp256k1_gej_double_var(&gbase, &gbase, NULL);\n             }\n             /* Multiply numbase by 2. */\n             secp256k1_gej_double_var(&numsbase, &numsbase, NULL);\n-            if (j == 62) {\n+            if (j == ECMULT_GEN_PREC_N - 2) {\n                 /* In the last iteration, numsbase is (1 - 2^j) * nums instead. */\n                 secp256k1_gej_neg(&numsbase, &numsbase);\n                 secp256k1_gej_add_var(&numsbase, &numsbase, &nums_gej, NULL);\n             }\n         }\n-        secp256k1_ge_set_all_gej_var(prec, precj, 1024);\n+        secp256k1_ge_set_all_gej_var(prec, precj, ECMULT_GEN_PREC_N * ECMULT_GEN_PREC_G);\n     }\n-    for (j = 0; j < 64; j++) {\n-        for (i = 0; i < 16; i++) {\n-            secp256k1_ge_to_storage(&(*ctx->prec)[j][i], &prec[j*16 + i]);\n+    for (j = 0; j < ECMULT_GEN_PREC_N; j++) {\n+        for (i = 0; i < ECMULT_GEN_PREC_G; i++) {\n+            secp256k1_ge_to_storage(&(*ctx->prec)[j][i], &prec[j*ECMULT_GEN_PREC_G + i]);\n         }\n     }\n #else\n-    (void)cb;\n-    ctx->prec = (secp256k1_ge_storage (*)[64][16])secp256k1_ecmult_static_context;\n+    (void)prealloc;\n+    ctx->prec = (secp256k1_ge_storage (*)[ECMULT_GEN_PREC_N][ECMULT_GEN_PREC_G])secp256k1_ecmult_static_context;\n #endif\n     secp256k1_ecmult_gen_blind(ctx, NULL);\n }\n@@ -95,27 +105,18 @@ static int secp256k1_ecmult_gen_context_is_built(const secp256k1_ecmult_gen_cont\n     return ctx->prec != NULL;\n }\n \n-static void secp256k1_ecmult_gen_context_clone(secp256k1_ecmult_gen_context *dst,\n-                                               const secp256k1_ecmult_gen_context *src, const secp256k1_callback* cb) {\n-    if (src->prec == NULL) {\n-        dst->prec = NULL;\n-    } else {\n+static void secp256k1_ecmult_gen_context_finalize_memcpy(secp256k1_ecmult_gen_context *dst, const secp256k1_ecmult_gen_context *src) {\n #ifndef USE_ECMULT_STATIC_PRECOMPUTATION\n-        dst->prec = (secp256k1_ge_storage (*)[64][16])checked_malloc(cb, sizeof(*dst->prec));\n-        memcpy(dst->prec, src->prec, sizeof(*dst->prec));\n+    if (src->prec != NULL) {\n+        /* We cast to void* first to suppress a -Wcast-align warning. */\n+        dst->prec = (secp256k1_ge_storage (*)[ECMULT_GEN_PREC_N][ECMULT_GEN_PREC_G])(void*)((unsigned char*)dst + ((unsigned char*)src->prec - (unsigned char*)src));\n+    }\n #else\n-        (void)cb;\n-        dst->prec = src->prec;\n+    (void)dst, (void)src;\n #endif\n-        dst->initial = src->initial;\n-        dst->blind = src->blind;\n-    }\n }\n \n static void secp256k1_ecmult_gen_context_clear(secp256k1_ecmult_gen_context *ctx) {\n-#ifndef USE_ECMULT_STATIC_PRECOMPUTATION\n-    free(ctx->prec);\n-#endif\n     secp256k1_scalar_clear(&ctx->blind);\n     secp256k1_gej_clear(&ctx->initial);\n     ctx->prec = NULL;\n@@ -132,9 +133,9 @@ static void secp256k1_ecmult_gen(const secp256k1_ecmult_gen_context *ctx, secp25\n     /* Blind scalar/point multiplication by computing (n-b)G + bG instead of nG. */\n     secp256k1_scalar_add(&gnb, gn, &ctx->blind);\n     add.infinity = 0;\n-    for (j = 0; j < 64; j++) {\n-        bits = secp256k1_scalar_get_bits(&gnb, j * 4, 4);\n-        for (i = 0; i < 16; i++) {\n+    for (j = 0; j < ECMULT_GEN_PREC_N; j++) {\n+        bits = secp256k1_scalar_get_bits(&gnb, j * ECMULT_GEN_PREC_B, ECMULT_GEN_PREC_B);\n+        for (i = 0; i < ECMULT_GEN_PREC_G; i++) {\n             /** This uses a conditional move to avoid any secret data in array indexes.\n              *   _Any_ use of secret indexes has been demonstrated to result in timing\n              *   sidechannels, even when the cache-line access patterns are uniform.\n@@ -162,7 +163,7 @@ static void secp256k1_ecmult_gen_blind(secp256k1_ecmult_gen_context *ctx, const\n     secp256k1_fe s;\n     unsigned char nonce32[32];\n     secp256k1_rfc6979_hmac_sha256 rng;\n-    int retry;\n+    int overflow;\n     unsigned char keydata[64] = {0};\n     if (seed32 == NULL) {\n         /* When seed is NULL, reset the initial point and blinding value. */\n@@ -182,21 +183,18 @@ static void secp256k1_ecmult_gen_blind(secp256k1_ecmult_gen_context *ctx, const\n     }\n     secp256k1_rfc6979_hmac_sha256_initialize(&rng, keydata, seed32 ? 64 : 32);\n     memset(keydata, 0, sizeof(keydata));\n-    /* Retry for out of range results to achieve uniformity. */\n-    do {\n-        secp256k1_rfc6979_hmac_sha256_generate(&rng, nonce32, 32);\n-        retry = !secp256k1_fe_set_b32(&s, nonce32);\n-        retry |= secp256k1_fe_is_zero(&s);\n-    } while (retry); /* This branch true is cryptographically unreachable. Requires sha256_hmac output > Fp. */\n+    /* Accept unobservably small non-uniformity. */\n+    secp256k1_rfc6979_hmac_sha256_generate(&rng, nonce32, 32);\n+    overflow = !secp256k1_fe_set_b32(&s, nonce32);\n+    overflow |= secp256k1_fe_is_zero(&s);\n+    secp256k1_fe_cmov(&s, &secp256k1_fe_one, overflow);\n     /* Randomize the projection to defend against multiplier sidechannels. */\n     secp256k1_gej_rescale(&ctx->initial, &s);\n     secp256k1_fe_clear(&s);\n-    do {\n-        secp256k1_rfc6979_hmac_sha256_generate(&rng, nonce32, 32);\n-        secp256k1_scalar_set_b32(&b, nonce32, &retry);\n-        /* A blinding value of 0 works, but would undermine the projection hardening. */\n-        retry |= secp256k1_scalar_is_zero(&b);\n-    } while (retry); /* This branch true is cryptographically unreachable. Requires sha256_hmac output > order. */\n+    secp256k1_rfc6979_hmac_sha256_generate(&rng, nonce32, 32);\n+    secp256k1_scalar_set_b32(&b, nonce32, NULL);\n+    /* A blinding value of 0 works, but would undermine the projection hardening. */\n+    secp256k1_scalar_cmov(&b, &secp256k1_scalar_one, secp256k1_scalar_is_zero(&b));\n     secp256k1_rfc6979_hmac_sha256_finalize(&rng);\n     memset(nonce32, 0, 32);\n     secp256k1_ecmult_gen(ctx, &gb, &b);"
      },
      {
        "sha": "f03fa9469d73ba56be9486eee509fd95fac9d359",
        "filename": "src/ecmult_impl.h",
        "status": "modified",
        "additions": 109,
        "deletions": 74,
        "changes": 183,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67f232b5d874b501c114bced5d764db7f4f5ce99/src/ecmult_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67f232b5d874b501c114bced5d764db7f4f5ce99/src/ecmult_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecmult_impl.h?ref=67f232b5d874b501c114bced5d764db7f4f5ce99",
        "patch": "@@ -10,6 +10,7 @@\n #include <string.h>\n #include <stdint.h>\n \n+#include \"util.h\"\n #include \"group.h\"\n #include \"scalar.h\"\n #include \"ecmult.h\"\n@@ -30,16 +31,32 @@\n #  endif\n #else\n /* optimal for 128-bit and 256-bit exponents. */\n-#define WINDOW_A 5\n-/** larger numbers may result in slightly better performance, at the cost of\n-    exponentially larger precomputed tables. */\n-#ifdef USE_ENDOMORPHISM\n-/** Two tables for window size 15: 1.375 MiB. */\n-#define WINDOW_G 15\n-#else\n-/** One table for window size 16: 1.375 MiB. */\n-#define WINDOW_G 16\n+#  define WINDOW_A 5\n+/** Larger values for ECMULT_WINDOW_SIZE result in possibly better\n+ *  performance at the cost of an exponentially larger precomputed\n+ *  table. The exact table size is\n+ *      (1 << (WINDOW_G - 2)) * sizeof(secp256k1_ge_storage)  bytes,\n+ *  where sizeof(secp256k1_ge_storage) is typically 64 bytes but can\n+ *  be larger due to platform-specific padding and alignment.\n+ *  If the endomorphism optimization is enabled (USE_ENDOMORMPHSIM)\n+ *  two tables of this size are used instead of only one.\n+ */\n+#  define WINDOW_G ECMULT_WINDOW_SIZE\n #endif\n+\n+/* Noone will ever need more than a window size of 24. The code might\n+ * be correct for larger values of ECMULT_WINDOW_SIZE but this is not\n+ * not tested.\n+ *\n+ * The following limitations are known, and there are probably more:\n+ * If WINDOW_G > 27 and size_t has 32 bits, then the code is incorrect\n+ * because the size of the memory object that we allocate (in bytes)\n+ * will not fit in a size_t.\n+ * If WINDOW_G > 31 and int has 32 bits, then the code is incorrect\n+ * because certain expressions will overflow.\n+ */\n+#if ECMULT_WINDOW_SIZE < 2 || ECMULT_WINDOW_SIZE > 24\n+#  error Set ECMULT_WINDOW_SIZE to an integer in range [2..24].\n #endif\n \n #ifdef USE_ENDOMORPHISM\n@@ -121,7 +138,7 @@ static void secp256k1_ecmult_odd_multiples_table(int n, secp256k1_gej *prej, sec\n  *    It only operates on tables sized for WINDOW_A wnaf multiples.\n  *  - secp256k1_ecmult_odd_multiples_table_storage_var, which converts its\n  *    resulting point set to actually affine points, and stores those in pre.\n- *    It operates on tables of any size, but uses heap-allocated temporaries.\n+ *    It operates on tables of any size.\n  *\n  *  To compute a*P + b*G, we compute a table for P using the first function,\n  *  and for G using the second (which requires an inverse, but it only needs to\n@@ -294,15 +311,24 @@ static void secp256k1_ecmult_odd_multiples_table_storage_var(const int n, secp25\n     } \\\n } while(0)\n \n+static const size_t SECP256K1_ECMULT_CONTEXT_PREALLOCATED_SIZE =\n+    ROUND_TO_ALIGN(sizeof((*((secp256k1_ecmult_context*) NULL)->pre_g)[0]) * ECMULT_TABLE_SIZE(WINDOW_G))\n+#ifdef USE_ENDOMORPHISM\n+    + ROUND_TO_ALIGN(sizeof((*((secp256k1_ecmult_context*) NULL)->pre_g_128)[0]) * ECMULT_TABLE_SIZE(WINDOW_G))\n+#endif\n+    ;\n+\n static void secp256k1_ecmult_context_init(secp256k1_ecmult_context *ctx) {\n     ctx->pre_g = NULL;\n #ifdef USE_ENDOMORPHISM\n     ctx->pre_g_128 = NULL;\n #endif\n }\n \n-static void secp256k1_ecmult_context_build(secp256k1_ecmult_context *ctx, const secp256k1_callback *cb) {\n+static void secp256k1_ecmult_context_build(secp256k1_ecmult_context *ctx, void **prealloc) {\n     secp256k1_gej gj;\n+    void* const base = *prealloc;\n+    size_t const prealloc_size = SECP256K1_ECMULT_CONTEXT_PREALLOCATED_SIZE;\n \n     if (ctx->pre_g != NULL) {\n         return;\n@@ -311,7 +337,12 @@ static void secp256k1_ecmult_context_build(secp256k1_ecmult_context *ctx, const\n     /* get the generator */\n     secp256k1_gej_set_ge(&gj, &secp256k1_ge_const_g);\n \n-    ctx->pre_g = (secp256k1_ge_storage (*)[])checked_malloc(cb, sizeof((*ctx->pre_g)[0]) * ECMULT_TABLE_SIZE(WINDOW_G));\n+    {\n+        size_t size = sizeof((*ctx->pre_g)[0]) * ((size_t)ECMULT_TABLE_SIZE(WINDOW_G));\n+        /* check for overflow */\n+        VERIFY_CHECK(size / sizeof((*ctx->pre_g)[0]) == ((size_t)ECMULT_TABLE_SIZE(WINDOW_G)));\n+        ctx->pre_g = (secp256k1_ge_storage (*)[])manual_alloc(prealloc, sizeof((*ctx->pre_g)[0]) * ECMULT_TABLE_SIZE(WINDOW_G), base, prealloc_size);\n+    }\n \n     /* precompute the tables with odd multiples */\n     secp256k1_ecmult_odd_multiples_table_storage_var(ECMULT_TABLE_SIZE(WINDOW_G), *ctx->pre_g, &gj);\n@@ -321,7 +352,10 @@ static void secp256k1_ecmult_context_build(secp256k1_ecmult_context *ctx, const\n         secp256k1_gej g_128j;\n         int i;\n \n-        ctx->pre_g_128 = (secp256k1_ge_storage (*)[])checked_malloc(cb, sizeof((*ctx->pre_g_128)[0]) * ECMULT_TABLE_SIZE(WINDOW_G));\n+        size_t size = sizeof((*ctx->pre_g_128)[0]) * ((size_t) ECMULT_TABLE_SIZE(WINDOW_G));\n+        /* check for overflow */\n+        VERIFY_CHECK(size / sizeof((*ctx->pre_g_128)[0]) == ((size_t)ECMULT_TABLE_SIZE(WINDOW_G)));\n+        ctx->pre_g_128 = (secp256k1_ge_storage (*)[])manual_alloc(prealloc, sizeof((*ctx->pre_g_128)[0]) * ECMULT_TABLE_SIZE(WINDOW_G), base, prealloc_size);\n \n         /* calculate 2^128*generator */\n         g_128j = gj;\n@@ -333,22 +367,14 @@ static void secp256k1_ecmult_context_build(secp256k1_ecmult_context *ctx, const\n #endif\n }\n \n-static void secp256k1_ecmult_context_clone(secp256k1_ecmult_context *dst,\n-                                           const secp256k1_ecmult_context *src, const secp256k1_callback *cb) {\n-    if (src->pre_g == NULL) {\n-        dst->pre_g = NULL;\n-    } else {\n-        size_t size = sizeof((*dst->pre_g)[0]) * ECMULT_TABLE_SIZE(WINDOW_G);\n-        dst->pre_g = (secp256k1_ge_storage (*)[])checked_malloc(cb, size);\n-        memcpy(dst->pre_g, src->pre_g, size);\n+static void secp256k1_ecmult_context_finalize_memcpy(secp256k1_ecmult_context *dst, const secp256k1_ecmult_context *src) {\n+    if (src->pre_g != NULL) {\n+        /* We cast to void* first to suppress a -Wcast-align warning. */\n+        dst->pre_g = (secp256k1_ge_storage (*)[])(void*)((unsigned char*)dst + ((unsigned char*)(src->pre_g) - (unsigned char*)src));\n     }\n #ifdef USE_ENDOMORPHISM\n-    if (src->pre_g_128 == NULL) {\n-        dst->pre_g_128 = NULL;\n-    } else {\n-        size_t size = sizeof((*dst->pre_g_128)[0]) * ECMULT_TABLE_SIZE(WINDOW_G);\n-        dst->pre_g_128 = (secp256k1_ge_storage (*)[])checked_malloc(cb, size);\n-        memcpy(dst->pre_g_128, src->pre_g_128, size);\n+    if (src->pre_g_128 != NULL) {\n+        dst->pre_g_128 = (secp256k1_ge_storage (*)[])(void*)((unsigned char*)dst + ((unsigned char*)(src->pre_g_128) - (unsigned char*)src));\n     }\n #endif\n }\n@@ -358,10 +384,6 @@ static int secp256k1_ecmult_context_is_built(const secp256k1_ecmult_context *ctx\n }\n \n static void secp256k1_ecmult_context_clear(secp256k1_ecmult_context *ctx) {\n-    free(ctx->pre_g);\n-#ifdef USE_ENDOMORPHISM\n-    free(ctx->pre_g_128);\n-#endif\n     secp256k1_ecmult_context_init(ctx);\n }\n \n@@ -373,7 +395,7 @@ static void secp256k1_ecmult_context_clear(secp256k1_ecmult_context *ctx) {\n  *    than the number of bits in the (absolute value) of the input.\n  */\n static int secp256k1_ecmult_wnaf(int *wnaf, int len, const secp256k1_scalar *a, int w) {\n-    secp256k1_scalar s = *a;\n+    secp256k1_scalar s;\n     int last_set_bit = -1;\n     int bit = 0;\n     int sign = 1;\n@@ -386,6 +408,7 @@ static int secp256k1_ecmult_wnaf(int *wnaf, int len, const secp256k1_scalar *a,\n \n     memset(wnaf, 0, len * sizeof(wnaf[0]));\n \n+    s = *a;\n     if (secp256k1_scalar_get_bits(&s, 255, 1)) {\n         secp256k1_scalar_negate(&s, &s);\n         sign = -1;\n@@ -418,7 +441,7 @@ static int secp256k1_ecmult_wnaf(int *wnaf, int len, const secp256k1_scalar *a,\n     CHECK(carry == 0);\n     while (bit < 256) {\n         CHECK(secp256k1_scalar_get_bits(&s, bit++, 1) == 0);\n-    } \n+    }\n #endif\n     return last_set_bit + 1;\n }\n@@ -626,52 +649,55 @@ static size_t secp256k1_strauss_scratch_size(size_t n_points) {\n     return n_points*point_size;\n }\n \n-static int secp256k1_ecmult_strauss_batch(const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n+static int secp256k1_ecmult_strauss_batch(const secp256k1_callback* error_callback, const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n     secp256k1_gej* points;\n     secp256k1_scalar* scalars;\n     struct secp256k1_strauss_state state;\n     size_t i;\n+    const size_t scratch_checkpoint = secp256k1_scratch_checkpoint(error_callback, scratch);\n \n     secp256k1_gej_set_infinity(r);\n     if (inp_g_sc == NULL && n_points == 0) {\n         return 1;\n     }\n \n-    if (!secp256k1_scratch_allocate_frame(scratch, secp256k1_strauss_scratch_size(n_points), STRAUSS_SCRATCH_OBJECTS)) {\n-        return 0;\n-    }\n-    points = (secp256k1_gej*)secp256k1_scratch_alloc(scratch, n_points * sizeof(secp256k1_gej));\n-    scalars = (secp256k1_scalar*)secp256k1_scratch_alloc(scratch, n_points * sizeof(secp256k1_scalar));\n-    state.prej = (secp256k1_gej*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_gej));\n-    state.zr = (secp256k1_fe*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_fe));\n+    points = (secp256k1_gej*)secp256k1_scratch_alloc(error_callback, scratch, n_points * sizeof(secp256k1_gej));\n+    scalars = (secp256k1_scalar*)secp256k1_scratch_alloc(error_callback, scratch, n_points * sizeof(secp256k1_scalar));\n+    state.prej = (secp256k1_gej*)secp256k1_scratch_alloc(error_callback, scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_gej));\n+    state.zr = (secp256k1_fe*)secp256k1_scratch_alloc(error_callback, scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_fe));\n #ifdef USE_ENDOMORPHISM\n-    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(scratch, n_points * 2 * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n+    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(error_callback, scratch, n_points * 2 * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n     state.pre_a_lam = state.pre_a + n_points * ECMULT_TABLE_SIZE(WINDOW_A);\n #else\n-    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n+    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(error_callback, scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n #endif\n-    state.ps = (struct secp256k1_strauss_point_state*)secp256k1_scratch_alloc(scratch, n_points * sizeof(struct secp256k1_strauss_point_state));\n+    state.ps = (struct secp256k1_strauss_point_state*)secp256k1_scratch_alloc(error_callback, scratch, n_points * sizeof(struct secp256k1_strauss_point_state));\n+\n+    if (points == NULL || scalars == NULL || state.prej == NULL || state.zr == NULL || state.pre_a == NULL) {\n+        secp256k1_scratch_apply_checkpoint(error_callback, scratch, scratch_checkpoint);\n+        return 0;\n+    }\n \n     for (i = 0; i < n_points; i++) {\n         secp256k1_ge point;\n         if (!cb(&scalars[i], &point, i+cb_offset, cbdata)) {\n-            secp256k1_scratch_deallocate_frame(scratch);\n+            secp256k1_scratch_apply_checkpoint(error_callback, scratch, scratch_checkpoint);\n             return 0;\n         }\n         secp256k1_gej_set_ge(&points[i], &point);\n     }\n     secp256k1_ecmult_strauss_wnaf(ctx, &state, r, n_points, points, scalars, inp_g_sc);\n-    secp256k1_scratch_deallocate_frame(scratch);\n+    secp256k1_scratch_apply_checkpoint(error_callback, scratch, scratch_checkpoint);\n     return 1;\n }\n \n /* Wrapper for secp256k1_ecmult_multi_func interface */\n-static int secp256k1_ecmult_strauss_batch_single(const secp256k1_ecmult_context *actx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n-    return secp256k1_ecmult_strauss_batch(actx, scratch, r, inp_g_sc, cb, cbdata, n, 0);\n+static int secp256k1_ecmult_strauss_batch_single(const secp256k1_callback* error_callback, const secp256k1_ecmult_context *actx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n+    return secp256k1_ecmult_strauss_batch(error_callback, actx, scratch, r, inp_g_sc, cb, cbdata, n, 0);\n }\n \n-static size_t secp256k1_strauss_max_points(secp256k1_scratch *scratch) {\n-    return secp256k1_scratch_max_allocation(scratch, STRAUSS_SCRATCH_OBJECTS) / secp256k1_strauss_scratch_size(1);\n+static size_t secp256k1_strauss_max_points(const secp256k1_callback* error_callback, secp256k1_scratch *scratch) {\n+    return secp256k1_scratch_max_allocation(error_callback, scratch, STRAUSS_SCRATCH_OBJECTS) / secp256k1_strauss_scratch_size(1);\n }\n \n /** Convert a number to WNAF notation.\n@@ -963,7 +989,8 @@ static size_t secp256k1_pippenger_scratch_size(size_t n_points, int bucket_windo\n     return (sizeof(secp256k1_gej) << bucket_window) + sizeof(struct secp256k1_pippenger_state) + entries * entry_size;\n }\n \n-static int secp256k1_ecmult_pippenger_batch(const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n+static int secp256k1_ecmult_pippenger_batch(const secp256k1_callback* error_callback, const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n+    const size_t scratch_checkpoint = secp256k1_scratch_checkpoint(error_callback, scratch);\n     /* Use 2(n+1) with the endomorphism, n+1 without, when calculating batch\n      * sizes. The reason for +1 is that we add the G scalar to the list of\n      * other scalars. */\n@@ -988,15 +1015,21 @@ static int secp256k1_ecmult_pippenger_batch(const secp256k1_ecmult_context *ctx,\n     }\n \n     bucket_window = secp256k1_pippenger_bucket_window(n_points);\n-    if (!secp256k1_scratch_allocate_frame(scratch, secp256k1_pippenger_scratch_size(n_points, bucket_window), PIPPENGER_SCRATCH_OBJECTS)) {\n+    points = (secp256k1_ge *) secp256k1_scratch_alloc(error_callback, scratch, entries * sizeof(*points));\n+    scalars = (secp256k1_scalar *) secp256k1_scratch_alloc(error_callback, scratch, entries * sizeof(*scalars));\n+    state_space = (struct secp256k1_pippenger_state *) secp256k1_scratch_alloc(error_callback, scratch, sizeof(*state_space));\n+    if (points == NULL || scalars == NULL || state_space == NULL) {\n+        secp256k1_scratch_apply_checkpoint(error_callback, scratch, scratch_checkpoint);\n+        return 0;\n+    }\n+\n+    state_space->ps = (struct secp256k1_pippenger_point_state *) secp256k1_scratch_alloc(error_callback, scratch, entries * sizeof(*state_space->ps));\n+    state_space->wnaf_na = (int *) secp256k1_scratch_alloc(error_callback, scratch, entries*(WNAF_SIZE(bucket_window+1)) * sizeof(int));\n+    buckets = (secp256k1_gej *) secp256k1_scratch_alloc(error_callback, scratch, (1<<bucket_window) * sizeof(*buckets));\n+    if (state_space->ps == NULL || state_space->wnaf_na == NULL || buckets == NULL) {\n+        secp256k1_scratch_apply_checkpoint(error_callback, scratch, scratch_checkpoint);\n         return 0;\n     }\n-    points = (secp256k1_ge *) secp256k1_scratch_alloc(scratch, entries * sizeof(*points));\n-    scalars = (secp256k1_scalar *) secp256k1_scratch_alloc(scratch, entries * sizeof(*scalars));\n-    state_space = (struct secp256k1_pippenger_state *) secp256k1_scratch_alloc(scratch, sizeof(*state_space));\n-    state_space->ps = (struct secp256k1_pippenger_point_state *) secp256k1_scratch_alloc(scratch, entries * sizeof(*state_space->ps));\n-    state_space->wnaf_na = (int *) secp256k1_scratch_alloc(scratch, entries*(WNAF_SIZE(bucket_window+1)) * sizeof(int));\n-    buckets = (secp256k1_gej *) secp256k1_scratch_alloc(scratch, sizeof(*buckets) << bucket_window);\n \n     if (inp_g_sc != NULL) {\n         scalars[0] = *inp_g_sc;\n@@ -1010,7 +1043,7 @@ static int secp256k1_ecmult_pippenger_batch(const secp256k1_ecmult_context *ctx,\n \n     while (point_idx < n_points) {\n         if (!cb(&scalars[idx], &points[idx], point_idx + cb_offset, cbdata)) {\n-            secp256k1_scratch_deallocate_frame(scratch);\n+            secp256k1_scratch_apply_checkpoint(error_callback, scratch, scratch_checkpoint);\n             return 0;\n         }\n         idx++;\n@@ -1034,22 +1067,22 @@ static int secp256k1_ecmult_pippenger_batch(const secp256k1_ecmult_context *ctx,\n     for(i = 0; i < 1<<bucket_window; i++) {\n         secp256k1_gej_clear(&buckets[i]);\n     }\n-    secp256k1_scratch_deallocate_frame(scratch);\n+    secp256k1_scratch_apply_checkpoint(error_callback, scratch, scratch_checkpoint);\n     return 1;\n }\n \n /* Wrapper for secp256k1_ecmult_multi_func interface */\n-static int secp256k1_ecmult_pippenger_batch_single(const secp256k1_ecmult_context *actx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n-    return secp256k1_ecmult_pippenger_batch(actx, scratch, r, inp_g_sc, cb, cbdata, n, 0);\n+static int secp256k1_ecmult_pippenger_batch_single(const secp256k1_callback* error_callback, const secp256k1_ecmult_context *actx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n+    return secp256k1_ecmult_pippenger_batch(error_callback, actx, scratch, r, inp_g_sc, cb, cbdata, n, 0);\n }\n \n /**\n  * Returns the maximum number of points in addition to G that can be used with\n  * a given scratch space. The function ensures that fewer points may also be\n  * used.\n  */\n-static size_t secp256k1_pippenger_max_points(secp256k1_scratch *scratch) {\n-    size_t max_alloc = secp256k1_scratch_max_allocation(scratch, PIPPENGER_SCRATCH_OBJECTS);\n+static size_t secp256k1_pippenger_max_points(const secp256k1_callback* error_callback, secp256k1_scratch *scratch) {\n+    size_t max_alloc = secp256k1_scratch_max_allocation(error_callback, scratch, PIPPENGER_SCRATCH_OBJECTS);\n     int bucket_window;\n     size_t res = 0;\n \n@@ -1131,11 +1164,11 @@ static int secp256k1_ecmult_multi_batch_size_helper(size_t *n_batches, size_t *n\n     return 1;\n }\n \n-typedef int (*secp256k1_ecmult_multi_func)(const secp256k1_ecmult_context*, secp256k1_scratch*, secp256k1_gej*, const secp256k1_scalar*, secp256k1_ecmult_multi_callback cb, void*, size_t);\n-static int secp256k1_ecmult_multi_var(const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n+typedef int (*secp256k1_ecmult_multi_func)(const secp256k1_callback* error_callback, const secp256k1_ecmult_context*, secp256k1_scratch*, secp256k1_gej*, const secp256k1_scalar*, secp256k1_ecmult_multi_callback cb, void*, size_t);\n+static int secp256k1_ecmult_multi_var(const secp256k1_callback* error_callback, const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n     size_t i;\n \n-    int (*f)(const secp256k1_ecmult_context*, secp256k1_scratch*, secp256k1_gej*, const secp256k1_scalar*, secp256k1_ecmult_multi_callback cb, void*, size_t, size_t);\n+    int (*f)(const secp256k1_callback* error_callback, const secp256k1_ecmult_context*, secp256k1_scratch*, secp256k1_gej*, const secp256k1_scalar*, secp256k1_ecmult_multi_callback cb, void*, size_t, size_t);\n     size_t n_batches;\n     size_t n_batch_points;\n \n@@ -1152,24 +1185,26 @@ static int secp256k1_ecmult_multi_var(const secp256k1_ecmult_context *ctx, secp2\n         return secp256k1_ecmult_multi_simple_var(ctx, r, inp_g_sc, cb, cbdata, n);\n     }\n \n-    /* Compute the batch sizes for pippenger given a scratch space. If it's greater than a threshold\n-     * use pippenger. Otherwise use strauss */\n-    if (!secp256k1_ecmult_multi_batch_size_helper(&n_batches, &n_batch_points, secp256k1_pippenger_max_points(scratch), n)) {\n-        return 0;\n+    /* Compute the batch sizes for Pippenger's algorithm given a scratch space. If it's greater than\n+     * a threshold use Pippenger's algorithm. Otherwise use Strauss' algorithm.\n+     * As a first step check if there's enough space for Pippenger's algo (which requires less space\n+     * than Strauss' algo) and if not, use the simple algorithm. */\n+    if (!secp256k1_ecmult_multi_batch_size_helper(&n_batches, &n_batch_points, secp256k1_pippenger_max_points(error_callback, scratch), n)) {\n+        return secp256k1_ecmult_multi_simple_var(ctx, r, inp_g_sc, cb, cbdata, n);\n     }\n     if (n_batch_points >= ECMULT_PIPPENGER_THRESHOLD) {\n         f = secp256k1_ecmult_pippenger_batch;\n     } else {\n-        if (!secp256k1_ecmult_multi_batch_size_helper(&n_batches, &n_batch_points, secp256k1_strauss_max_points(scratch), n)) {\n-            return 0;\n+        if (!secp256k1_ecmult_multi_batch_size_helper(&n_batches, &n_batch_points, secp256k1_strauss_max_points(error_callback, scratch), n)) {\n+            return secp256k1_ecmult_multi_simple_var(ctx, r, inp_g_sc, cb, cbdata, n);\n         }\n         f = secp256k1_ecmult_strauss_batch;\n     }\n     for(i = 0; i < n_batches; i++) {\n         size_t nbp = n < n_batch_points ? n : n_batch_points;\n         size_t offset = n_batch_points*i;\n         secp256k1_gej tmp;\n-        if (!f(ctx, scratch, &tmp, i == 0 ? inp_g_sc : NULL, cb, cbdata, nbp, offset)) {\n+        if (!f(error_callback, ctx, scratch, &tmp, i == 0 ? inp_g_sc : NULL, cb, cbdata, nbp, offset)) {\n             return 0;\n         }\n         secp256k1_gej_add_var(r, r, &tmp, NULL);"
      },
      {
        "sha": "7993a1f11e32db30af819f128271658a829e04dc",
        "filename": "src/field.h",
        "status": "modified",
        "additions": 6,
        "deletions": 4,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67f232b5d874b501c114bced5d764db7f4f5ce99/src/field.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67f232b5d874b501c114bced5d764db7f4f5ce99/src/field.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/field.h?ref=67f232b5d874b501c114bced5d764db7f4f5ce99",
        "patch": "@@ -32,10 +32,12 @@\n \n #include \"util.h\"\n \n-/** Normalize a field element. */\n+/** Normalize a field element. This brings the field element to a canonical representation, reduces\n+ *  its magnitude to 1, and reduces it modulo field size `p`.\n+ */\n static void secp256k1_fe_normalize(secp256k1_fe *r);\n \n-/** Weakly normalize a field element: reduce it magnitude to 1, but don't fully normalize. */\n+/** Weakly normalize a field element: reduce its magnitude to 1, but don't fully normalize. */\n static void secp256k1_fe_normalize_weak(secp256k1_fe *r);\n \n /** Normalize a field element, without constant-time guarantee. */\n@@ -123,10 +125,10 @@ static void secp256k1_fe_to_storage(secp256k1_fe_storage *r, const secp256k1_fe\n /** Convert a field element back from the storage type. */\n static void secp256k1_fe_from_storage(secp256k1_fe *r, const secp256k1_fe_storage *a);\n \n-/** If flag is true, set *r equal to *a; otherwise leave it. Constant-time. */\n+/** If flag is true, set *r equal to *a; otherwise leave it. Constant-time.  Both *r and *a must be initialized.*/\n static void secp256k1_fe_storage_cmov(secp256k1_fe_storage *r, const secp256k1_fe_storage *a, int flag);\n \n-/** If flag is true, set *r equal to *a; otherwise leave it. Constant-time. */\n+/** If flag is true, set *r equal to *a; otherwise leave it. Constant-time.  Both *r and *a must be initialized.*/\n static void secp256k1_fe_cmov(secp256k1_fe *r, const secp256k1_fe *a, int flag);\n \n #endif /* SECP256K1_FIELD_H */"
      },
      {
        "sha": "651500ee8eb90bdf54e058ea201ab4da1c912fd4",
        "filename": "src/field_10x26_impl.h",
        "status": "modified",
        "additions": 13,
        "deletions": 8,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67f232b5d874b501c114bced5d764db7f4f5ce99/src/field_10x26_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67f232b5d874b501c114bced5d764db7f4f5ce99/src/field_10x26_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/field_10x26_impl.h?ref=67f232b5d874b501c114bced5d764db7f4f5ce99",
        "patch": "@@ -320,6 +320,7 @@ static int secp256k1_fe_cmp_var(const secp256k1_fe *a, const secp256k1_fe *b) {\n }\n \n static int secp256k1_fe_set_b32(secp256k1_fe *r, const unsigned char *a) {\n+    int ret;\n     r->n[0] = (uint32_t)a[31] | ((uint32_t)a[30] << 8) | ((uint32_t)a[29] << 16) | ((uint32_t)(a[28] & 0x3) << 24);\n     r->n[1] = (uint32_t)((a[28] >> 2) & 0x3f) | ((uint32_t)a[27] << 6) | ((uint32_t)a[26] << 14) | ((uint32_t)(a[25] & 0xf) << 22);\n     r->n[2] = (uint32_t)((a[25] >> 4) & 0xf) | ((uint32_t)a[24] << 4) | ((uint32_t)a[23] << 12) | ((uint32_t)(a[22] & 0x3f) << 20);\n@@ -331,15 +332,17 @@ static int secp256k1_fe_set_b32(secp256k1_fe *r, const unsigned char *a) {\n     r->n[8] = (uint32_t)a[5] | ((uint32_t)a[4] << 8) | ((uint32_t)a[3] << 16) | ((uint32_t)(a[2] & 0x3) << 24);\n     r->n[9] = (uint32_t)((a[2] >> 2) & 0x3f) | ((uint32_t)a[1] << 6) | ((uint32_t)a[0] << 14);\n \n-    if (r->n[9] == 0x3FFFFFUL && (r->n[8] & r->n[7] & r->n[6] & r->n[5] & r->n[4] & r->n[3] & r->n[2]) == 0x3FFFFFFUL && (r->n[1] + 0x40UL + ((r->n[0] + 0x3D1UL) >> 26)) > 0x3FFFFFFUL) {\n-        return 0;\n-    }\n+    ret = !((r->n[9] == 0x3FFFFFUL) & ((r->n[8] & r->n[7] & r->n[6] & r->n[5] & r->n[4] & r->n[3] & r->n[2]) == 0x3FFFFFFUL) & ((r->n[1] + 0x40UL + ((r->n[0] + 0x3D1UL) >> 26)) > 0x3FFFFFFUL));\n #ifdef VERIFY\n     r->magnitude = 1;\n-    r->normalized = 1;\n-    secp256k1_fe_verify(r);\n+    if (ret) {\n+        r->normalized = 1;\n+        secp256k1_fe_verify(r);\n+    } else {\n+        r->normalized = 0;\n+    }\n #endif\n-    return 1;\n+    return ret;\n }\n \n /** Convert a field element to a 32-byte big endian value. Requires the input to be normalized */\n@@ -1094,6 +1097,7 @@ static void secp256k1_fe_sqr(secp256k1_fe *r, const secp256k1_fe *a) {\n \n static SECP256K1_INLINE void secp256k1_fe_cmov(secp256k1_fe *r, const secp256k1_fe *a, int flag) {\n     uint32_t mask0, mask1;\n+    VG_CHECK_VERIFY(r->n, sizeof(r->n));\n     mask0 = flag + ~((uint32_t)0);\n     mask1 = ~mask0;\n     r->n[0] = (r->n[0] & mask0) | (a->n[0] & mask1);\n@@ -1107,15 +1111,16 @@ static SECP256K1_INLINE void secp256k1_fe_cmov(secp256k1_fe *r, const secp256k1_\n     r->n[8] = (r->n[8] & mask0) | (a->n[8] & mask1);\n     r->n[9] = (r->n[9] & mask0) | (a->n[9] & mask1);\n #ifdef VERIFY\n-    if (a->magnitude > r->magnitude) {\n+    if (flag) {\n         r->magnitude = a->magnitude;\n+        r->normalized = a->normalized;\n     }\n-    r->normalized &= a->normalized;\n #endif\n }\n \n static SECP256K1_INLINE void secp256k1_fe_storage_cmov(secp256k1_fe_storage *r, const secp256k1_fe_storage *a, int flag) {\n     uint32_t mask0, mask1;\n+    VG_CHECK_VERIFY(r->n, sizeof(r->n));\n     mask0 = flag + ~((uint32_t)0);\n     mask1 = ~mask0;\n     r->n[0] = (r->n[0] & mask0) | (a->n[0] & mask1);"
      },
      {
        "sha": "71a38f915b2f462cd2ac6c8a749a62689a490408",
        "filename": "src/field_5x52_impl.h",
        "status": "modified",
        "additions": 13,
        "deletions": 8,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67f232b5d874b501c114bced5d764db7f4f5ce99/src/field_5x52_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67f232b5d874b501c114bced5d764db7f4f5ce99/src/field_5x52_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/field_5x52_impl.h?ref=67f232b5d874b501c114bced5d764db7f4f5ce99",
        "patch": "@@ -283,6 +283,7 @@ static int secp256k1_fe_cmp_var(const secp256k1_fe *a, const secp256k1_fe *b) {\n }\n \n static int secp256k1_fe_set_b32(secp256k1_fe *r, const unsigned char *a) {\n+    int ret;\n     r->n[0] = (uint64_t)a[31]\n             | ((uint64_t)a[30] << 8)\n             | ((uint64_t)a[29] << 16)\n@@ -317,15 +318,17 @@ static int secp256k1_fe_set_b32(secp256k1_fe *r, const unsigned char *a) {\n             | ((uint64_t)a[2] << 24)\n             | ((uint64_t)a[1] << 32)\n             | ((uint64_t)a[0] << 40);\n-    if (r->n[4] == 0x0FFFFFFFFFFFFULL && (r->n[3] & r->n[2] & r->n[1]) == 0xFFFFFFFFFFFFFULL && r->n[0] >= 0xFFFFEFFFFFC2FULL) {\n-        return 0;\n-    }\n+    ret = !((r->n[4] == 0x0FFFFFFFFFFFFULL) & ((r->n[3] & r->n[2] & r->n[1]) == 0xFFFFFFFFFFFFFULL) & (r->n[0] >= 0xFFFFEFFFFFC2FULL));\n #ifdef VERIFY\n     r->magnitude = 1;\n-    r->normalized = 1;\n-    secp256k1_fe_verify(r);\n+    if (ret) {\n+        r->normalized = 1;\n+        secp256k1_fe_verify(r);\n+    } else {\n+        r->normalized = 0;\n+    }\n #endif\n-    return 1;\n+    return ret;\n }\n \n /** Convert a field element to a 32-byte big endian value. Requires the input to be normalized */\n@@ -446,6 +449,7 @@ static void secp256k1_fe_sqr(secp256k1_fe *r, const secp256k1_fe *a) {\n \n static SECP256K1_INLINE void secp256k1_fe_cmov(secp256k1_fe *r, const secp256k1_fe *a, int flag) {\n     uint64_t mask0, mask1;\n+    VG_CHECK_VERIFY(r->n, sizeof(r->n));\n     mask0 = flag + ~((uint64_t)0);\n     mask1 = ~mask0;\n     r->n[0] = (r->n[0] & mask0) | (a->n[0] & mask1);\n@@ -454,15 +458,16 @@ static SECP256K1_INLINE void secp256k1_fe_cmov(secp256k1_fe *r, const secp256k1_\n     r->n[3] = (r->n[3] & mask0) | (a->n[3] & mask1);\n     r->n[4] = (r->n[4] & mask0) | (a->n[4] & mask1);\n #ifdef VERIFY\n-    if (a->magnitude > r->magnitude) {\n+    if (flag) {\n         r->magnitude = a->magnitude;\n+        r->normalized = a->normalized;\n     }\n-    r->normalized &= a->normalized;\n #endif\n }\n \n static SECP256K1_INLINE void secp256k1_fe_storage_cmov(secp256k1_fe_storage *r, const secp256k1_fe_storage *a, int flag) {\n     uint64_t mask0, mask1;\n+    VG_CHECK_VERIFY(r->n, sizeof(r->n));\n     mask0 = flag + ~((uint64_t)0);\n     mask1 = ~mask0;\n     r->n[0] = (r->n[0] & mask0) | (a->n[0] & mask1);"
      },
      {
        "sha": "485921a60e62b52e22175aaf03fb87fb1d17f1d5",
        "filename": "src/field_impl.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67f232b5d874b501c114bced5d764db7f4f5ce99/src/field_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67f232b5d874b501c114bced5d764db7f4f5ce99/src/field_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/field_impl.h?ref=67f232b5d874b501c114bced5d764db7f4f5ce99",
        "patch": "@@ -315,4 +315,6 @@ static int secp256k1_fe_is_quad_var(const secp256k1_fe *a) {\n #endif\n }\n \n+static const secp256k1_fe secp256k1_fe_one = SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 1);\n+\n #endif /* SECP256K1_FIELD_IMPL_H */"
      },
      {
        "sha": "539f574bfd0c690be1e939748bf86249305c981e",
        "filename": "src/gen_context.c",
        "status": "modified",
        "additions": 23,
        "deletions": 10,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67f232b5d874b501c114bced5d764db7f4f5ce99/src/gen_context.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67f232b5d874b501c114bced5d764db7f4f5ce99/src/gen_context.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/gen_context.c?ref=67f232b5d874b501c114bced5d764db7f4f5ce99",
        "patch": "@@ -4,10 +4,16 @@\n  * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n  **********************************************************************/\n \n+// Autotools creates libsecp256k1-config.h, of which ECMULT_GEN_PREC_BITS is needed.\n+// ifndef guard so downstream users can define their own if they do not use autotools.\n+#if !defined(ECMULT_GEN_PREC_BITS)\n+#include \"libsecp256k1-config.h\"\n+#endif\n #define USE_BASIC_CONFIG 1\n-\n #include \"basic-config.h\"\n+\n #include \"include/secp256k1.h\"\n+#include \"util.h\"\n #include \"field_impl.h\"\n #include \"scalar_impl.h\"\n #include \"group_impl.h\"\n@@ -26,6 +32,7 @@ static const secp256k1_callback default_error_callback = {\n \n int main(int argc, char **argv) {\n     secp256k1_ecmult_gen_context ctx;\n+    void *prealloc, *base;\n     int inner;\n     int outer;\n     FILE* fp;\n@@ -38,37 +45,43 @@ int main(int argc, char **argv) {\n         fprintf(stderr, \"Could not open src/ecmult_static_context.h for writing!\\n\");\n         return -1;\n     }\n-    \n+\n     fprintf(fp, \"#ifndef _SECP256K1_ECMULT_STATIC_CONTEXT_\\n\");\n     fprintf(fp, \"#define _SECP256K1_ECMULT_STATIC_CONTEXT_\\n\");\n     fprintf(fp, \"#include \\\"src/group.h\\\"\\n\");\n     fprintf(fp, \"#define SC SECP256K1_GE_STORAGE_CONST\\n\");\n-    fprintf(fp, \"static const secp256k1_ge_storage secp256k1_ecmult_static_context[64][16] = {\\n\");\n+    fprintf(fp, \"#if ECMULT_GEN_PREC_N != %d || ECMULT_GEN_PREC_G != %d\\n\", ECMULT_GEN_PREC_N, ECMULT_GEN_PREC_G);\n+    fprintf(fp, \"   #error configuration mismatch, invalid ECMULT_GEN_PREC_N, ECMULT_GEN_PREC_G. Try deleting ecmult_static_context.h before the build.\\n\");\n+    fprintf(fp, \"#endif\\n\");\n+    fprintf(fp, \"static const secp256k1_ge_storage secp256k1_ecmult_static_context[ECMULT_GEN_PREC_N][ECMULT_GEN_PREC_G] = {\\n\");\n \n+    base = checked_malloc(&default_error_callback, SECP256K1_ECMULT_GEN_CONTEXT_PREALLOCATED_SIZE);\n+    prealloc = base;\n     secp256k1_ecmult_gen_context_init(&ctx);\n-    secp256k1_ecmult_gen_context_build(&ctx, &default_error_callback);\n-    for(outer = 0; outer != 64; outer++) {\n+    secp256k1_ecmult_gen_context_build(&ctx, &prealloc);\n+    for(outer = 0; outer != ECMULT_GEN_PREC_N; outer++) {\n         fprintf(fp,\"{\\n\");\n-        for(inner = 0; inner != 16; inner++) {\n+        for(inner = 0; inner != ECMULT_GEN_PREC_G; inner++) {\n             fprintf(fp,\"    SC(%uu, %uu, %uu, %uu, %uu, %uu, %uu, %uu, %uu, %uu, %uu, %uu, %uu, %uu, %uu, %uu)\", SECP256K1_GE_STORAGE_CONST_GET((*ctx.prec)[outer][inner]));\n-            if (inner != 15) {\n+            if (inner != ECMULT_GEN_PREC_G - 1) {\n                 fprintf(fp,\",\\n\");\n             } else {\n                 fprintf(fp,\"\\n\");\n             }\n         }\n-        if (outer != 63) {\n+        if (outer != ECMULT_GEN_PREC_N - 1) {\n             fprintf(fp,\"},\\n\");\n         } else {\n             fprintf(fp,\"}\\n\");\n         }\n     }\n     fprintf(fp,\"};\\n\");\n     secp256k1_ecmult_gen_context_clear(&ctx);\n-    \n+    free(base);\n+\n     fprintf(fp, \"#undef SC\\n\");\n     fprintf(fp, \"#endif\\n\");\n     fclose(fp);\n-    \n+\n     return 0;\n }"
      },
      {
        "sha": "863644f0f0bbf7dde12ab53b2da4d87310163d93",
        "filename": "src/group.h",
        "status": "modified",
        "additions": 6,
        "deletions": 7,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67f232b5d874b501c114bced5d764db7f4f5ce99/src/group.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67f232b5d874b501c114bced5d764db7f4f5ce99/src/group.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/group.h?ref=67f232b5d874b501c114bced5d764db7f4f5ce99",
        "patch": "@@ -95,22 +95,21 @@ static int secp256k1_gej_is_infinity(const secp256k1_gej *a);\n /** Check whether a group element's y coordinate is a quadratic residue. */\n static int secp256k1_gej_has_quad_y_var(const secp256k1_gej *a);\n \n-/** Set r equal to the double of a. If rzr is not-NULL, r->z = a->z * *rzr (where infinity means an implicit z = 0).\n- * a may not be zero. Constant time. */\n-static void secp256k1_gej_double_nonzero(secp256k1_gej *r, const secp256k1_gej *a, secp256k1_fe *rzr);\n+/** Set r equal to the double of a, a cannot be infinity. Constant time. */\n+static void secp256k1_gej_double_nonzero(secp256k1_gej *r, const secp256k1_gej *a);\n \n-/** Set r equal to the double of a. If rzr is not-NULL, r->z = a->z * *rzr (where infinity means an implicit z = 0). */\n+/** Set r equal to the double of a. If rzr is not-NULL this sets *rzr such that r->z == a->z * *rzr (where infinity means an implicit z = 0). */\n static void secp256k1_gej_double_var(secp256k1_gej *r, const secp256k1_gej *a, secp256k1_fe *rzr);\n \n-/** Set r equal to the sum of a and b. If rzr is non-NULL, r->z = a->z * *rzr (a cannot be infinity in that case). */\n+/** Set r equal to the sum of a and b. If rzr is non-NULL this sets *rzr such that r->z == a->z * *rzr (a cannot be infinity in that case). */\n static void secp256k1_gej_add_var(secp256k1_gej *r, const secp256k1_gej *a, const secp256k1_gej *b, secp256k1_fe *rzr);\n \n /** Set r equal to the sum of a and b (with b given in affine coordinates, and not infinity). */\n static void secp256k1_gej_add_ge(secp256k1_gej *r, const secp256k1_gej *a, const secp256k1_ge *b);\n \n /** Set r equal to the sum of a and b (with b given in affine coordinates). This is more efficient\n     than secp256k1_gej_add_var. It is identical to secp256k1_gej_add_ge but without constant-time\n-    guarantee, and b is allowed to be infinity. If rzr is non-NULL, r->z = a->z * *rzr (a cannot be infinity in that case). */\n+    guarantee, and b is allowed to be infinity. If rzr is non-NULL this sets *rzr such that r->z == a->z * *rzr (a cannot be infinity in that case). */\n static void secp256k1_gej_add_ge_var(secp256k1_gej *r, const secp256k1_gej *a, const secp256k1_ge *b, secp256k1_fe *rzr);\n \n /** Set r equal to the sum of a and b (with the inverse of b's Z coordinate passed as bzinv). */\n@@ -133,7 +132,7 @@ static void secp256k1_ge_to_storage(secp256k1_ge_storage *r, const secp256k1_ge\n /** Convert a group element back from the storage type. */\n static void secp256k1_ge_from_storage(secp256k1_ge *r, const secp256k1_ge_storage *a);\n \n-/** If flag is true, set *r equal to *a; otherwise leave it. Constant-time. */\n+/** If flag is true, set *r equal to *a; otherwise leave it. Constant-time.  Both *r and *a must be initialized.*/\n static void secp256k1_ge_storage_cmov(secp256k1_ge_storage *r, const secp256k1_ge_storage *a, int flag);\n \n /** Rescale a jacobian point by b which must be non-zero. Constant-time. */"
      },
      {
        "sha": "43b039becfd58d112594dd6c9611c65d0c30f5a0",
        "filename": "src/group_impl.h",
        "status": "modified",
        "additions": 29,
        "deletions": 26,
        "changes": 55,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67f232b5d874b501c114bced5d764db7f4f5ce99/src/group_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67f232b5d874b501c114bced5d764db7f4f5ce99/src/group_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/group_impl.h?ref=67f232b5d874b501c114bced5d764db7f4f5ce99",
        "patch": "@@ -303,7 +303,7 @@ static int secp256k1_ge_is_valid_var(const secp256k1_ge *a) {\n     return secp256k1_fe_equal_var(&y2, &x3);\n }\n \n-static void secp256k1_gej_double_var(secp256k1_gej *r, const secp256k1_gej *a, secp256k1_fe *rzr) {\n+static SECP256K1_INLINE void secp256k1_gej_double_nonzero(secp256k1_gej *r, const secp256k1_gej *a) {\n     /* Operations: 3 mul, 4 sqr, 0 normalize, 12 mul_int/add/negate.\n      *\n      * Note that there is an implementation described at\n@@ -312,29 +312,9 @@ static void secp256k1_gej_double_var(secp256k1_gej *r, const secp256k1_gej *a, s\n      * mainly because it requires more normalizations.\n      */\n     secp256k1_fe t1,t2,t3,t4;\n-    /** For secp256k1, 2Q is infinity if and only if Q is infinity. This is because if 2Q = infinity,\n-     *  Q must equal -Q, or that Q.y == -(Q.y), or Q.y is 0. For a point on y^2 = x^3 + 7 to have\n-     *  y=0, x^3 must be -7 mod p. However, -7 has no cube root mod p.\n-     *\n-     *  Having said this, if this function receives a point on a sextic twist, e.g. by\n-     *  a fault attack, it is possible for y to be 0. This happens for y^2 = x^3 + 6,\n-     *  since -6 does have a cube root mod p. For this point, this function will not set\n-     *  the infinity flag even though the point doubles to infinity, and the result\n-     *  point will be gibberish (z = 0 but infinity = 0).\n-     */\n-    r->infinity = a->infinity;\n-    if (r->infinity) {\n-        if (rzr != NULL) {\n-            secp256k1_fe_set_int(rzr, 1);\n-        }\n-        return;\n-    }\n \n-    if (rzr != NULL) {\n-        *rzr = a->y;\n-        secp256k1_fe_normalize_weak(rzr);\n-        secp256k1_fe_mul_int(rzr, 2);\n-    }\n+    VERIFY_CHECK(!secp256k1_gej_is_infinity(a));\n+    r->infinity = 0;\n \n     secp256k1_fe_mul(&r->z, &a->z, &a->y);\n     secp256k1_fe_mul_int(&r->z, 2);       /* Z' = 2*Y*Z (2) */\n@@ -358,9 +338,32 @@ static void secp256k1_gej_double_var(secp256k1_gej *r, const secp256k1_gej *a, s\n     secp256k1_fe_add(&r->y, &t2);         /* Y' = 36*X^3*Y^2 - 27*X^6 - 8*Y^4 (4) */\n }\n \n-static SECP256K1_INLINE void secp256k1_gej_double_nonzero(secp256k1_gej *r, const secp256k1_gej *a, secp256k1_fe *rzr) {\n-    VERIFY_CHECK(!secp256k1_gej_is_infinity(a));\n-    secp256k1_gej_double_var(r, a, rzr);\n+static void secp256k1_gej_double_var(secp256k1_gej *r, const secp256k1_gej *a, secp256k1_fe *rzr) {\n+    /** For secp256k1, 2Q is infinity if and only if Q is infinity. This is because if 2Q = infinity,\n+     *  Q must equal -Q, or that Q.y == -(Q.y), or Q.y is 0. For a point on y^2 = x^3 + 7 to have\n+     *  y=0, x^3 must be -7 mod p. However, -7 has no cube root mod p.\n+     *\n+     *  Having said this, if this function receives a point on a sextic twist, e.g. by\n+     *  a fault attack, it is possible for y to be 0. This happens for y^2 = x^3 + 6,\n+     *  since -6 does have a cube root mod p. For this point, this function will not set\n+     *  the infinity flag even though the point doubles to infinity, and the result\n+     *  point will be gibberish (z = 0 but infinity = 0).\n+     */\n+    if (a->infinity) {\n+        r->infinity = 1;\n+        if (rzr != NULL) {\n+            secp256k1_fe_set_int(rzr, 1);\n+        }\n+        return;\n+    }\n+\n+    if (rzr != NULL) {\n+        *rzr = a->y;\n+        secp256k1_fe_normalize_weak(rzr);\n+        secp256k1_fe_mul_int(rzr, 2);\n+    }\n+\n+    secp256k1_gej_double_nonzero(r, a);\n }\n \n static void secp256k1_gej_add_var(secp256k1_gej *r, const secp256k1_gej *a, const secp256k1_gej *b, secp256k1_fe *rzr) {"
      },
      {
        "sha": "782f97216c284eff353a339fdd544c49ab2a7911",
        "filename": "src/hash_impl.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67f232b5d874b501c114bced5d764db7f4f5ce99/src/hash_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67f232b5d874b501c114bced5d764db7f4f5ce99/src/hash_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/hash_impl.h?ref=67f232b5d874b501c114bced5d764db7f4f5ce99",
        "patch": "@@ -131,7 +131,8 @@ static void secp256k1_sha256_transform(uint32_t* s, const uint32_t* chunk) {\n static void secp256k1_sha256_write(secp256k1_sha256 *hash, const unsigned char *data, size_t len) {\n     size_t bufsize = hash->bytes & 0x3F;\n     hash->bytes += len;\n-    while (bufsize + len >= 64) {\n+    VERIFY_CHECK(hash->bytes >= len);\n+    while (len >= 64 - bufsize) {\n         /* Fill the buffer, and process it. */\n         size_t chunk_len = 64 - bufsize;\n         memcpy(((unsigned char*)hash->buf) + bufsize, data, chunk_len);"
      },
      {
        "sha": "1c67802fba82e60498c560473e9966c161939ffb",
        "filename": "src/java/org/bitcoin/NativeSecp256k1.java",
        "status": "removed",
        "additions": 0,
        "deletions": 446,
        "changes": 446,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/java/org/bitcoin/NativeSecp256k1.java",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/java/org/bitcoin/NativeSecp256k1.java",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/java/org/bitcoin/NativeSecp256k1.java?ref=54245985fb3c89d72e285c4db39d38ed2f5fb0de",
        "patch": "@@ -1,446 +0,0 @@\n-/*\n- * Copyright 2013 Google Inc.\n- * Copyright 2014-2016 the libsecp256k1 contributors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.bitcoin;\n-\n-import java.nio.ByteBuffer;\n-import java.nio.ByteOrder;\n-\n-import java.math.BigInteger;\n-import com.google.common.base.Preconditions;\n-import java.util.concurrent.locks.Lock;\n-import java.util.concurrent.locks.ReentrantReadWriteLock;\n-import static org.bitcoin.NativeSecp256k1Util.*;\n-\n-/**\n- * <p>This class holds native methods to handle ECDSA verification.</p>\n- *\n- * <p>You can find an example library that can be used for this at https://github.com/bitcoin/secp256k1</p>\n- *\n- * <p>To build secp256k1 for use with bitcoinj, run\n- * `./configure --enable-jni --enable-experimental --enable-module-ecdh`\n- * and `make` then copy `.libs/libsecp256k1.so` to your system library path\n- * or point the JVM to the folder containing it with -Djava.library.path\n- * </p>\n- */\n-public class NativeSecp256k1 {\n-\n-    private static final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();\n-    private static final Lock r = rwl.readLock();\n-    private static final Lock w = rwl.writeLock();\n-    private static ThreadLocal<ByteBuffer> nativeECDSABuffer = new ThreadLocal<ByteBuffer>();\n-    /**\n-     * Verifies the given secp256k1 signature in native code.\n-     * Calling when enabled == false is undefined (probably library not loaded)\n-     *\n-     * @param data The data which was signed, must be exactly 32 bytes\n-     * @param signature The signature\n-     * @param pub The public key which did the signing\n-     */\n-    public static boolean verify(byte[] data, byte[] signature, byte[] pub) throws AssertFailException{\n-        Preconditions.checkArgument(data.length == 32 && signature.length <= 520 && pub.length <= 520);\n-\n-        ByteBuffer byteBuff = nativeECDSABuffer.get();\n-        if (byteBuff == null || byteBuff.capacity() < 520) {\n-            byteBuff = ByteBuffer.allocateDirect(520);\n-            byteBuff.order(ByteOrder.nativeOrder());\n-            nativeECDSABuffer.set(byteBuff);\n-        }\n-        byteBuff.rewind();\n-        byteBuff.put(data);\n-        byteBuff.put(signature);\n-        byteBuff.put(pub);\n-\n-        byte[][] retByteArray;\n-\n-        r.lock();\n-        try {\n-          return secp256k1_ecdsa_verify(byteBuff, Secp256k1Context.getContext(), signature.length, pub.length) == 1;\n-        } finally {\n-          r.unlock();\n-        }\n-    }\n-\n-    /**\n-     * libsecp256k1 Create an ECDSA signature.\n-     *\n-     * @param data Message hash, 32 bytes\n-     * @param key Secret key, 32 bytes\n-     *\n-     * Return values\n-     * @param sig byte array of signature\n-     */\n-    public static byte[] sign(byte[] data, byte[] sec) throws AssertFailException{\n-        Preconditions.checkArgument(data.length == 32 && sec.length <= 32);\n-\n-        ByteBuffer byteBuff = nativeECDSABuffer.get();\n-        if (byteBuff == null || byteBuff.capacity() < 32 + 32) {\n-            byteBuff = ByteBuffer.allocateDirect(32 + 32);\n-            byteBuff.order(ByteOrder.nativeOrder());\n-            nativeECDSABuffer.set(byteBuff);\n-        }\n-        byteBuff.rewind();\n-        byteBuff.put(data);\n-        byteBuff.put(sec);\n-\n-        byte[][] retByteArray;\n-\n-        r.lock();\n-        try {\n-          retByteArray = secp256k1_ecdsa_sign(byteBuff, Secp256k1Context.getContext());\n-        } finally {\n-          r.unlock();\n-        }\n-\n-        byte[] sigArr = retByteArray[0];\n-        int sigLen = new BigInteger(new byte[] { retByteArray[1][0] }).intValue();\n-        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n-\n-        assertEquals(sigArr.length, sigLen, \"Got bad signature length.\");\n-\n-        return retVal == 0 ? new byte[0] : sigArr;\n-    }\n-\n-    /**\n-     * libsecp256k1 Seckey Verify - returns 1 if valid, 0 if invalid\n-     *\n-     * @param seckey ECDSA Secret key, 32 bytes\n-     */\n-    public static boolean secKeyVerify(byte[] seckey) {\n-        Preconditions.checkArgument(seckey.length == 32);\n-\n-        ByteBuffer byteBuff = nativeECDSABuffer.get();\n-        if (byteBuff == null || byteBuff.capacity() < seckey.length) {\n-            byteBuff = ByteBuffer.allocateDirect(seckey.length);\n-            byteBuff.order(ByteOrder.nativeOrder());\n-            nativeECDSABuffer.set(byteBuff);\n-        }\n-        byteBuff.rewind();\n-        byteBuff.put(seckey);\n-\n-        r.lock();\n-        try {\n-          return secp256k1_ec_seckey_verify(byteBuff,Secp256k1Context.getContext()) == 1;\n-        } finally {\n-          r.unlock();\n-        }\n-    }\n-\n-\n-    /**\n-     * libsecp256k1 Compute Pubkey - computes public key from secret key\n-     *\n-     * @param seckey ECDSA Secret key, 32 bytes\n-     *\n-     * Return values\n-     * @param pubkey ECDSA Public key, 33 or 65 bytes\n-     */\n-    //TODO add a 'compressed' arg\n-    public static byte[] computePubkey(byte[] seckey) throws AssertFailException{\n-        Preconditions.checkArgument(seckey.length == 32);\n-\n-        ByteBuffer byteBuff = nativeECDSABuffer.get();\n-        if (byteBuff == null || byteBuff.capacity() < seckey.length) {\n-            byteBuff = ByteBuffer.allocateDirect(seckey.length);\n-            byteBuff.order(ByteOrder.nativeOrder());\n-            nativeECDSABuffer.set(byteBuff);\n-        }\n-        byteBuff.rewind();\n-        byteBuff.put(seckey);\n-\n-        byte[][] retByteArray;\n-\n-        r.lock();\n-        try {\n-          retByteArray = secp256k1_ec_pubkey_create(byteBuff, Secp256k1Context.getContext());\n-        } finally {\n-          r.unlock();\n-        }\n-\n-        byte[] pubArr = retByteArray[0];\n-        int pubLen = new BigInteger(new byte[] { retByteArray[1][0] }).intValue();\n-        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n-\n-        assertEquals(pubArr.length, pubLen, \"Got bad pubkey length.\");\n-\n-        return retVal == 0 ? new byte[0]: pubArr;\n-    }\n-\n-    /**\n-     * libsecp256k1 Cleanup - This destroys the secp256k1 context object\n-     * This should be called at the end of the program for proper cleanup of the context.\n-     */\n-    public static synchronized void cleanup() {\n-        w.lock();\n-        try {\n-          secp256k1_destroy_context(Secp256k1Context.getContext());\n-        } finally {\n-          w.unlock();\n-        }\n-    }\n-\n-    public static long cloneContext() {\n-       r.lock();\n-       try {\n-        return secp256k1_ctx_clone(Secp256k1Context.getContext());\n-       } finally { r.unlock(); }\n-    }\n-\n-    /**\n-     * libsecp256k1 PrivKey Tweak-Mul - Tweak privkey by multiplying to it\n-     *\n-     * @param tweak some bytes to tweak with\n-     * @param seckey 32-byte seckey\n-     */\n-    public static byte[] privKeyTweakMul(byte[] privkey, byte[] tweak) throws AssertFailException{\n-        Preconditions.checkArgument(privkey.length == 32);\n-\n-        ByteBuffer byteBuff = nativeECDSABuffer.get();\n-        if (byteBuff == null || byteBuff.capacity() < privkey.length + tweak.length) {\n-            byteBuff = ByteBuffer.allocateDirect(privkey.length + tweak.length);\n-            byteBuff.order(ByteOrder.nativeOrder());\n-            nativeECDSABuffer.set(byteBuff);\n-        }\n-        byteBuff.rewind();\n-        byteBuff.put(privkey);\n-        byteBuff.put(tweak);\n-\n-        byte[][] retByteArray;\n-        r.lock();\n-        try {\n-          retByteArray = secp256k1_privkey_tweak_mul(byteBuff,Secp256k1Context.getContext());\n-        } finally {\n-          r.unlock();\n-        }\n-\n-        byte[] privArr = retByteArray[0];\n-\n-        int privLen = (byte) new BigInteger(new byte[] { retByteArray[1][0] }).intValue() & 0xFF;\n-        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n-\n-        assertEquals(privArr.length, privLen, \"Got bad pubkey length.\");\n-\n-        assertEquals(retVal, 1, \"Failed return value check.\");\n-\n-        return privArr;\n-    }\n-\n-    /**\n-     * libsecp256k1 PrivKey Tweak-Add - Tweak privkey by adding to it\n-     *\n-     * @param tweak some bytes to tweak with\n-     * @param seckey 32-byte seckey\n-     */\n-    public static byte[] privKeyTweakAdd(byte[] privkey, byte[] tweak) throws AssertFailException{\n-        Preconditions.checkArgument(privkey.length == 32);\n-\n-        ByteBuffer byteBuff = nativeECDSABuffer.get();\n-        if (byteBuff == null || byteBuff.capacity() < privkey.length + tweak.length) {\n-            byteBuff = ByteBuffer.allocateDirect(privkey.length + tweak.length);\n-            byteBuff.order(ByteOrder.nativeOrder());\n-            nativeECDSABuffer.set(byteBuff);\n-        }\n-        byteBuff.rewind();\n-        byteBuff.put(privkey);\n-        byteBuff.put(tweak);\n-\n-        byte[][] retByteArray;\n-        r.lock();\n-        try {\n-          retByteArray = secp256k1_privkey_tweak_add(byteBuff,Secp256k1Context.getContext());\n-        } finally {\n-          r.unlock();\n-        }\n-\n-        byte[] privArr = retByteArray[0];\n-\n-        int privLen = (byte) new BigInteger(new byte[] { retByteArray[1][0] }).intValue() & 0xFF;\n-        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n-\n-        assertEquals(privArr.length, privLen, \"Got bad pubkey length.\");\n-\n-        assertEquals(retVal, 1, \"Failed return value check.\");\n-\n-        return privArr;\n-    }\n-\n-    /**\n-     * libsecp256k1 PubKey Tweak-Add - Tweak pubkey by adding to it\n-     *\n-     * @param tweak some bytes to tweak with\n-     * @param pubkey 32-byte seckey\n-     */\n-    public static byte[] pubKeyTweakAdd(byte[] pubkey, byte[] tweak) throws AssertFailException{\n-        Preconditions.checkArgument(pubkey.length == 33 || pubkey.length == 65);\n-\n-        ByteBuffer byteBuff = nativeECDSABuffer.get();\n-        if (byteBuff == null || byteBuff.capacity() < pubkey.length + tweak.length) {\n-            byteBuff = ByteBuffer.allocateDirect(pubkey.length + tweak.length);\n-            byteBuff.order(ByteOrder.nativeOrder());\n-            nativeECDSABuffer.set(byteBuff);\n-        }\n-        byteBuff.rewind();\n-        byteBuff.put(pubkey);\n-        byteBuff.put(tweak);\n-\n-        byte[][] retByteArray;\n-        r.lock();\n-        try {\n-          retByteArray = secp256k1_pubkey_tweak_add(byteBuff,Secp256k1Context.getContext(), pubkey.length);\n-        } finally {\n-          r.unlock();\n-        }\n-\n-        byte[] pubArr = retByteArray[0];\n-\n-        int pubLen = (byte) new BigInteger(new byte[] { retByteArray[1][0] }).intValue() & 0xFF;\n-        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n-\n-        assertEquals(pubArr.length, pubLen, \"Got bad pubkey length.\");\n-\n-        assertEquals(retVal, 1, \"Failed return value check.\");\n-\n-        return pubArr;\n-    }\n-\n-    /**\n-     * libsecp256k1 PubKey Tweak-Mul - Tweak pubkey by multiplying to it\n-     *\n-     * @param tweak some bytes to tweak with\n-     * @param pubkey 32-byte seckey\n-     */\n-    public static byte[] pubKeyTweakMul(byte[] pubkey, byte[] tweak) throws AssertFailException{\n-        Preconditions.checkArgument(pubkey.length == 33 || pubkey.length == 65);\n-\n-        ByteBuffer byteBuff = nativeECDSABuffer.get();\n-        if (byteBuff == null || byteBuff.capacity() < pubkey.length + tweak.length) {\n-            byteBuff = ByteBuffer.allocateDirect(pubkey.length + tweak.length);\n-            byteBuff.order(ByteOrder.nativeOrder());\n-            nativeECDSABuffer.set(byteBuff);\n-        }\n-        byteBuff.rewind();\n-        byteBuff.put(pubkey);\n-        byteBuff.put(tweak);\n-\n-        byte[][] retByteArray;\n-        r.lock();\n-        try {\n-          retByteArray = secp256k1_pubkey_tweak_mul(byteBuff,Secp256k1Context.getContext(), pubkey.length);\n-        } finally {\n-          r.unlock();\n-        }\n-\n-        byte[] pubArr = retByteArray[0];\n-\n-        int pubLen = (byte) new BigInteger(new byte[] { retByteArray[1][0] }).intValue() & 0xFF;\n-        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n-\n-        assertEquals(pubArr.length, pubLen, \"Got bad pubkey length.\");\n-\n-        assertEquals(retVal, 1, \"Failed return value check.\");\n-\n-        return pubArr;\n-    }\n-\n-    /**\n-     * libsecp256k1 create ECDH secret - constant time ECDH calculation\n-     *\n-     * @param seckey byte array of secret key used in exponentiaion\n-     * @param pubkey byte array of public key used in exponentiaion\n-     */\n-    public static byte[] createECDHSecret(byte[] seckey, byte[] pubkey) throws AssertFailException{\n-        Preconditions.checkArgument(seckey.length <= 32 && pubkey.length <= 65);\n-\n-        ByteBuffer byteBuff = nativeECDSABuffer.get();\n-        if (byteBuff == null || byteBuff.capacity() < 32 + pubkey.length) {\n-            byteBuff = ByteBuffer.allocateDirect(32 + pubkey.length);\n-            byteBuff.order(ByteOrder.nativeOrder());\n-            nativeECDSABuffer.set(byteBuff);\n-        }\n-        byteBuff.rewind();\n-        byteBuff.put(seckey);\n-        byteBuff.put(pubkey);\n-\n-        byte[][] retByteArray;\n-        r.lock();\n-        try {\n-          retByteArray = secp256k1_ecdh(byteBuff, Secp256k1Context.getContext(), pubkey.length);\n-        } finally {\n-          r.unlock();\n-        }\n-\n-        byte[] resArr = retByteArray[0];\n-        int retVal = new BigInteger(new byte[] { retByteArray[1][0] }).intValue();\n-\n-        assertEquals(resArr.length, 32, \"Got bad result length.\");\n-        assertEquals(retVal, 1, \"Failed return value check.\");\n-\n-        return resArr;\n-    }\n-\n-    /**\n-     * libsecp256k1 randomize - updates the context randomization\n-     *\n-     * @param seed 32-byte random seed\n-     */\n-    public static synchronized boolean randomize(byte[] seed) throws AssertFailException{\n-        Preconditions.checkArgument(seed.length == 32 || seed == null);\n-\n-        ByteBuffer byteBuff = nativeECDSABuffer.get();\n-        if (byteBuff == null || byteBuff.capacity() < seed.length) {\n-            byteBuff = ByteBuffer.allocateDirect(seed.length);\n-            byteBuff.order(ByteOrder.nativeOrder());\n-            nativeECDSABuffer.set(byteBuff);\n-        }\n-        byteBuff.rewind();\n-        byteBuff.put(seed);\n-\n-        w.lock();\n-        try {\n-          return secp256k1_context_randomize(byteBuff, Secp256k1Context.getContext()) == 1;\n-        } finally {\n-          w.unlock();\n-        }\n-    }\n-\n-    private static native long secp256k1_ctx_clone(long context);\n-\n-    private static native int secp256k1_context_randomize(ByteBuffer byteBuff, long context);\n-\n-    private static native byte[][] secp256k1_privkey_tweak_add(ByteBuffer byteBuff, long context);\n-\n-    private static native byte[][] secp256k1_privkey_tweak_mul(ByteBuffer byteBuff, long context);\n-\n-    private static native byte[][] secp256k1_pubkey_tweak_add(ByteBuffer byteBuff, long context, int pubLen);\n-\n-    private static native byte[][] secp256k1_pubkey_tweak_mul(ByteBuffer byteBuff, long context, int pubLen);\n-\n-    private static native void secp256k1_destroy_context(long context);\n-\n-    private static native int secp256k1_ecdsa_verify(ByteBuffer byteBuff, long context, int sigLen, int pubLen);\n-\n-    private static native byte[][] secp256k1_ecdsa_sign(ByteBuffer byteBuff, long context);\n-\n-    private static native int secp256k1_ec_seckey_verify(ByteBuffer byteBuff, long context);\n-\n-    private static native byte[][] secp256k1_ec_pubkey_create(ByteBuffer byteBuff, long context);\n-\n-    private static native byte[][] secp256k1_ec_pubkey_parse(ByteBuffer byteBuff, long context, int inputLen);\n-\n-    private static native byte[][] secp256k1_ecdh(ByteBuffer byteBuff, long context, int inputLen);\n-\n-}"
      },
      {
        "sha": "d766a1029ce389a73207431bdf7c0376b1fc6e35",
        "filename": "src/java/org/bitcoin/NativeSecp256k1Test.java",
        "status": "removed",
        "additions": 0,
        "deletions": 226,
        "changes": 226,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/java/org/bitcoin/NativeSecp256k1Test.java",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/java/org/bitcoin/NativeSecp256k1Test.java",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/java/org/bitcoin/NativeSecp256k1Test.java?ref=54245985fb3c89d72e285c4db39d38ed2f5fb0de",
        "patch": "@@ -1,226 +0,0 @@\n-package org.bitcoin;\n-\n-import com.google.common.io.BaseEncoding;\n-import java.util.Arrays;\n-import java.math.BigInteger;\n-import javax.xml.bind.DatatypeConverter;\n-import static org.bitcoin.NativeSecp256k1Util.*;\n-\n-/**\n- * This class holds test cases defined for testing this library.\n- */\n-public class NativeSecp256k1Test {\n-\n-    //TODO improve comments/add more tests\n-    /**\n-      * This tests verify() for a valid signature\n-      */\n-    public static void testVerifyPos() throws AssertFailException{\n-        boolean result = false;\n-        byte[] data = BaseEncoding.base16().lowerCase().decode(\"CF80CD8AED482D5D1527D7DC72FCEFF84E6326592848447D2DC0B0E87DFC9A90\".toLowerCase()); //sha256hash of \"testing\"\n-        byte[] sig = BaseEncoding.base16().lowerCase().decode(\"3044022079BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F817980220294F14E883B3F525B5367756C2A11EF6CF84B730B36C17CB0C56F0AAB2C98589\".toLowerCase());\n-        byte[] pub = BaseEncoding.base16().lowerCase().decode(\"040A629506E1B65CD9D2E0BA9C75DF9C4FED0DB16DC9625ED14397F0AFC836FAE595DC53F8B0EFE61E703075BD9B143BAC75EC0E19F82A2208CAEB32BE53414C40\".toLowerCase());\n-\n-        result = NativeSecp256k1.verify( data, sig, pub);\n-        assertEquals( result, true , \"testVerifyPos\");\n-    }\n-\n-    /**\n-      * This tests verify() for a non-valid signature\n-      */\n-    public static void testVerifyNeg() throws AssertFailException{\n-        boolean result = false;\n-        byte[] data = BaseEncoding.base16().lowerCase().decode(\"CF80CD8AED482D5D1527D7DC72FCEFF84E6326592848447D2DC0B0E87DFC9A91\".toLowerCase()); //sha256hash of \"testing\"\n-        byte[] sig = BaseEncoding.base16().lowerCase().decode(\"3044022079BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F817980220294F14E883B3F525B5367756C2A11EF6CF84B730B36C17CB0C56F0AAB2C98589\".toLowerCase());\n-        byte[] pub = BaseEncoding.base16().lowerCase().decode(\"040A629506E1B65CD9D2E0BA9C75DF9C4FED0DB16DC9625ED14397F0AFC836FAE595DC53F8B0EFE61E703075BD9B143BAC75EC0E19F82A2208CAEB32BE53414C40\".toLowerCase());\n-\n-        result = NativeSecp256k1.verify( data, sig, pub);\n-        //System.out.println(\" TEST \" + new BigInteger(1, resultbytes).toString(16));\n-        assertEquals( result, false , \"testVerifyNeg\");\n-    }\n-\n-    /**\n-      * This tests secret key verify() for a valid secretkey\n-      */\n-    public static void testSecKeyVerifyPos() throws AssertFailException{\n-        boolean result = false;\n-        byte[] sec = BaseEncoding.base16().lowerCase().decode(\"67E56582298859DDAE725F972992A07C6C4FB9F62A8FFF58CE3CA926A1063530\".toLowerCase());\n-\n-        result = NativeSecp256k1.secKeyVerify( sec );\n-        //System.out.println(\" TEST \" + new BigInteger(1, resultbytes).toString(16));\n-        assertEquals( result, true , \"testSecKeyVerifyPos\");\n-    }\n-\n-    /**\n-      * This tests secret key verify() for an invalid secretkey\n-      */\n-    public static void testSecKeyVerifyNeg() throws AssertFailException{\n-        boolean result = false;\n-        byte[] sec = BaseEncoding.base16().lowerCase().decode(\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\".toLowerCase());\n-\n-        result = NativeSecp256k1.secKeyVerify( sec );\n-        //System.out.println(\" TEST \" + new BigInteger(1, resultbytes).toString(16));\n-        assertEquals( result, false , \"testSecKeyVerifyNeg\");\n-    }\n-\n-    /**\n-      * This tests public key create() for a valid secretkey\n-      */\n-    public static void testPubKeyCreatePos() throws AssertFailException{\n-        byte[] sec = BaseEncoding.base16().lowerCase().decode(\"67E56582298859DDAE725F972992A07C6C4FB9F62A8FFF58CE3CA926A1063530\".toLowerCase());\n-\n-        byte[] resultArr = NativeSecp256k1.computePubkey( sec);\n-        String pubkeyString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n-        assertEquals( pubkeyString , \"04C591A8FF19AC9C4E4E5793673B83123437E975285E7B442F4EE2654DFFCA5E2D2103ED494718C697AC9AEBCFD19612E224DB46661011863ED2FC54E71861E2A6\" , \"testPubKeyCreatePos\");\n-    }\n-\n-    /**\n-      * This tests public key create() for a invalid secretkey\n-      */\n-    public static void testPubKeyCreateNeg() throws AssertFailException{\n-       byte[] sec = BaseEncoding.base16().lowerCase().decode(\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\".toLowerCase());\n-\n-       byte[] resultArr = NativeSecp256k1.computePubkey( sec);\n-       String pubkeyString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n-       assertEquals( pubkeyString, \"\" , \"testPubKeyCreateNeg\");\n-    }\n-\n-    /**\n-      * This tests sign() for a valid secretkey\n-      */\n-    public static void testSignPos() throws AssertFailException{\n-\n-        byte[] data = BaseEncoding.base16().lowerCase().decode(\"CF80CD8AED482D5D1527D7DC72FCEFF84E6326592848447D2DC0B0E87DFC9A90\".toLowerCase()); //sha256hash of \"testing\"\n-        byte[] sec = BaseEncoding.base16().lowerCase().decode(\"67E56582298859DDAE725F972992A07C6C4FB9F62A8FFF58CE3CA926A1063530\".toLowerCase());\n-\n-        byte[] resultArr = NativeSecp256k1.sign(data, sec);\n-        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n-        assertEquals( sigString, \"30440220182A108E1448DC8F1FB467D06A0F3BB8EA0533584CB954EF8DA112F1D60E39A202201C66F36DA211C087F3AF88B50EDF4F9BDAA6CF5FD6817E74DCA34DB12390C6E9\" , \"testSignPos\");\n-    }\n-\n-    /**\n-      * This tests sign() for a invalid secretkey\n-      */\n-    public static void testSignNeg() throws AssertFailException{\n-        byte[] data = BaseEncoding.base16().lowerCase().decode(\"CF80CD8AED482D5D1527D7DC72FCEFF84E6326592848447D2DC0B0E87DFC9A90\".toLowerCase()); //sha256hash of \"testing\"\n-        byte[] sec = BaseEncoding.base16().lowerCase().decode(\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\".toLowerCase());\n-\n-        byte[] resultArr = NativeSecp256k1.sign(data, sec);\n-        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n-        assertEquals( sigString, \"\" , \"testSignNeg\");\n-    }\n-\n-    /**\n-      * This tests private key tweak-add\n-      */\n-    public static void testPrivKeyTweakAdd_1() throws AssertFailException {\n-        byte[] sec = BaseEncoding.base16().lowerCase().decode(\"67E56582298859DDAE725F972992A07C6C4FB9F62A8FFF58CE3CA926A1063530\".toLowerCase());\n-        byte[] data = BaseEncoding.base16().lowerCase().decode(\"3982F19BEF1615BCCFBB05E321C10E1D4CBA3DF0E841C2E41EEB6016347653C3\".toLowerCase()); //sha256hash of \"tweak\"\n-\n-        byte[] resultArr = NativeSecp256k1.privKeyTweakAdd( sec , data );\n-        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n-        assertEquals( sigString , \"A168571E189E6F9A7E2D657A4B53AE99B909F7E712D1C23CED28093CD57C88F3\" , \"testPrivKeyAdd_1\");\n-    }\n-\n-    /**\n-      * This tests private key tweak-mul\n-      */\n-    public static void testPrivKeyTweakMul_1() throws AssertFailException {\n-        byte[] sec = BaseEncoding.base16().lowerCase().decode(\"67E56582298859DDAE725F972992A07C6C4FB9F62A8FFF58CE3CA926A1063530\".toLowerCase());\n-        byte[] data = BaseEncoding.base16().lowerCase().decode(\"3982F19BEF1615BCCFBB05E321C10E1D4CBA3DF0E841C2E41EEB6016347653C3\".toLowerCase()); //sha256hash of \"tweak\"\n-\n-        byte[] resultArr = NativeSecp256k1.privKeyTweakMul( sec , data );\n-        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n-        assertEquals( sigString , \"97F8184235F101550F3C71C927507651BD3F1CDB4A5A33B8986ACF0DEE20FFFC\" , \"testPrivKeyMul_1\");\n-    }\n-\n-    /**\n-      * This tests private key tweak-add uncompressed\n-      */\n-    public static void testPrivKeyTweakAdd_2() throws AssertFailException {\n-        byte[] pub = BaseEncoding.base16().lowerCase().decode(\"040A629506E1B65CD9D2E0BA9C75DF9C4FED0DB16DC9625ED14397F0AFC836FAE595DC53F8B0EFE61E703075BD9B143BAC75EC0E19F82A2208CAEB32BE53414C40\".toLowerCase());\n-        byte[] data = BaseEncoding.base16().lowerCase().decode(\"3982F19BEF1615BCCFBB05E321C10E1D4CBA3DF0E841C2E41EEB6016347653C3\".toLowerCase()); //sha256hash of \"tweak\"\n-\n-        byte[] resultArr = NativeSecp256k1.pubKeyTweakAdd( pub , data );\n-        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n-        assertEquals( sigString , \"0411C6790F4B663CCE607BAAE08C43557EDC1A4D11D88DFCB3D841D0C6A941AF525A268E2A863C148555C48FB5FBA368E88718A46E205FABC3DBA2CCFFAB0796EF\" , \"testPrivKeyAdd_2\");\n-    }\n-\n-    /**\n-      * This tests private key tweak-mul uncompressed\n-      */\n-    public static void testPrivKeyTweakMul_2() throws AssertFailException {\n-        byte[] pub = BaseEncoding.base16().lowerCase().decode(\"040A629506E1B65CD9D2E0BA9C75DF9C4FED0DB16DC9625ED14397F0AFC836FAE595DC53F8B0EFE61E703075BD9B143BAC75EC0E19F82A2208CAEB32BE53414C40\".toLowerCase());\n-        byte[] data = BaseEncoding.base16().lowerCase().decode(\"3982F19BEF1615BCCFBB05E321C10E1D4CBA3DF0E841C2E41EEB6016347653C3\".toLowerCase()); //sha256hash of \"tweak\"\n-\n-        byte[] resultArr = NativeSecp256k1.pubKeyTweakMul( pub , data );\n-        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n-        assertEquals( sigString , \"04E0FE6FE55EBCA626B98A807F6CAF654139E14E5E3698F01A9A658E21DC1D2791EC060D4F412A794D5370F672BC94B722640B5F76914151CFCA6E712CA48CC589\" , \"testPrivKeyMul_2\");\n-    }\n-\n-    /**\n-      * This tests seed randomization\n-      */\n-    public static void testRandomize() throws AssertFailException {\n-        byte[] seed = BaseEncoding.base16().lowerCase().decode(\"A441B15FE9A3CF56661190A0B93B9DEC7D04127288CC87250967CF3B52894D11\".toLowerCase()); //sha256hash of \"random\"\n-        boolean result = NativeSecp256k1.randomize(seed);\n-        assertEquals( result, true, \"testRandomize\");\n-    }\n-\n-    public static void testCreateECDHSecret() throws AssertFailException{\n-\n-        byte[] sec = BaseEncoding.base16().lowerCase().decode(\"67E56582298859DDAE725F972992A07C6C4FB9F62A8FFF58CE3CA926A1063530\".toLowerCase());\n-        byte[] pub = BaseEncoding.base16().lowerCase().decode(\"040A629506E1B65CD9D2E0BA9C75DF9C4FED0DB16DC9625ED14397F0AFC836FAE595DC53F8B0EFE61E703075BD9B143BAC75EC0E19F82A2208CAEB32BE53414C40\".toLowerCase());\n-\n-        byte[] resultArr = NativeSecp256k1.createECDHSecret(sec, pub);\n-        String ecdhString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n-        assertEquals( ecdhString, \"2A2A67007A926E6594AF3EB564FC74005B37A9C8AEF2033C4552051B5C87F043\" , \"testCreateECDHSecret\");\n-    }\n-\n-    public static void main(String[] args) throws AssertFailException{\n-\n-\n-        System.out.println(\"\\n libsecp256k1 enabled: \" + Secp256k1Context.isEnabled() + \"\\n\");\n-\n-        assertEquals( Secp256k1Context.isEnabled(), true, \"isEnabled\" );\n-\n-        //Test verify() success/fail\n-        testVerifyPos();\n-        testVerifyNeg();\n-\n-        //Test secKeyVerify() success/fail\n-        testSecKeyVerifyPos();\n-        testSecKeyVerifyNeg();\n-\n-        //Test computePubkey() success/fail\n-        testPubKeyCreatePos();\n-        testPubKeyCreateNeg();\n-\n-        //Test sign() success/fail\n-        testSignPos();\n-        testSignNeg();\n-\n-        //Test privKeyTweakAdd() 1\n-        testPrivKeyTweakAdd_1();\n-\n-        //Test privKeyTweakMul() 2\n-        testPrivKeyTweakMul_1();\n-\n-        //Test privKeyTweakAdd() 3\n-        testPrivKeyTweakAdd_2();\n-\n-        //Test privKeyTweakMul() 4\n-        testPrivKeyTweakMul_2();\n-\n-        //Test randomize()\n-        testRandomize();\n-\n-        //Test ECDH\n-        testCreateECDHSecret();\n-\n-        NativeSecp256k1.cleanup();\n-\n-        System.out.println(\" All tests passed.\" );\n-\n-    }\n-}"
      },
      {
        "sha": "04732ba044363a5dc5c525661a090c1bdf1d077f",
        "filename": "src/java/org/bitcoin/NativeSecp256k1Util.java",
        "status": "removed",
        "additions": 0,
        "deletions": 45,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/java/org/bitcoin/NativeSecp256k1Util.java",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/java/org/bitcoin/NativeSecp256k1Util.java",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/java/org/bitcoin/NativeSecp256k1Util.java?ref=54245985fb3c89d72e285c4db39d38ed2f5fb0de",
        "patch": "@@ -1,45 +0,0 @@\n-/*\n- * Copyright 2014-2016 the libsecp256k1 contributors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.bitcoin;\n-\n-public class NativeSecp256k1Util{\n-\n-    public static void assertEquals( int val, int val2, String message ) throws AssertFailException{\n-      if( val != val2 )\n-        throw new AssertFailException(\"FAIL: \" + message);\n-    }\n-\n-    public static void assertEquals( boolean val, boolean val2, String message ) throws AssertFailException{\n-      if( val != val2 )\n-        throw new AssertFailException(\"FAIL: \" + message);\n-      else\n-        System.out.println(\"PASS: \" + message);\n-    }\n-\n-    public static void assertEquals( String val, String val2, String message ) throws AssertFailException{\n-      if( !val.equals(val2) )\n-        throw new AssertFailException(\"FAIL: \" + message);\n-      else\n-        System.out.println(\"PASS: \" + message);\n-    }\n-\n-    public static class AssertFailException extends Exception {\n-      public AssertFailException(String message) {\n-        super( message );\n-      }\n-    }\n-}"
      },
      {
        "sha": "216c986a8b564d49b01243d513bdd182339e51b6",
        "filename": "src/java/org/bitcoin/Secp256k1Context.java",
        "status": "removed",
        "additions": 0,
        "deletions": 51,
        "changes": 51,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/java/org/bitcoin/Secp256k1Context.java",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/java/org/bitcoin/Secp256k1Context.java",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/java/org/bitcoin/Secp256k1Context.java?ref=54245985fb3c89d72e285c4db39d38ed2f5fb0de",
        "patch": "@@ -1,51 +0,0 @@\n-/*\n- * Copyright 2014-2016 the libsecp256k1 contributors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.bitcoin;\n-\n-/**\n- * This class holds the context reference used in native methods \n- * to handle ECDSA operations.\n- */\n-public class Secp256k1Context {\n-  private static final boolean enabled; //true if the library is loaded\n-  private static final long context; //ref to pointer to context obj\n-\n-  static { //static initializer\n-      boolean isEnabled = true;\n-      long contextRef = -1;\n-      try {\n-          System.loadLibrary(\"secp256k1\");\n-          contextRef = secp256k1_init_context();\n-      } catch (UnsatisfiedLinkError e) {\n-          System.out.println(\"UnsatisfiedLinkError: \" + e.toString());\n-          isEnabled = false;\n-      }\n-      enabled = isEnabled;\n-      context = contextRef;\n-  }\n-\n-  public static boolean isEnabled() {\n-     return enabled;\n-  }\n-\n-  public static long getContext() {\n-     if(!enabled) return -1; //sanity check\n-     return context;\n-  }\n-\n-  private static native long secp256k1_init_context();\n-}"
      },
      {
        "sha": "b50970b4f24c8cd3480368aab34a9d83df92fe1b",
        "filename": "src/java/org_bitcoin_NativeSecp256k1.c",
        "status": "removed",
        "additions": 0,
        "deletions": 379,
        "changes": 379,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/java/org_bitcoin_NativeSecp256k1.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/java/org_bitcoin_NativeSecp256k1.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/java/org_bitcoin_NativeSecp256k1.c?ref=54245985fb3c89d72e285c4db39d38ed2f5fb0de",
        "patch": "@@ -1,379 +0,0 @@\n-#include <stdlib.h>\n-#include <stdint.h>\n-#include <string.h>\n-#include \"org_bitcoin_NativeSecp256k1.h\"\n-#include \"include/secp256k1.h\"\n-#include \"include/secp256k1_ecdh.h\"\n-#include \"include/secp256k1_recovery.h\"\n-\n-\n-SECP256K1_API jlong JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ctx_1clone\n-  (JNIEnv* env, jclass classObject, jlong ctx_l)\n-{\n-  const secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n-\n-  jlong ctx_clone_l = (uintptr_t) secp256k1_context_clone(ctx);\n-\n-  (void)classObject;(void)env;\n-\n-  return ctx_clone_l;\n-\n-}\n-\n-SECP256K1_API jint JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1context_1randomize\n-  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l)\n-{\n-  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n-\n-  const unsigned char* seed = (unsigned char*) (*env)->GetDirectBufferAddress(env, byteBufferObject);\n-\n-  (void)classObject;\n-\n-  return secp256k1_context_randomize(ctx, seed);\n-\n-}\n-\n-SECP256K1_API void JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1destroy_1context\n-  (JNIEnv* env, jclass classObject, jlong ctx_l)\n-{\n-  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n-\n-  secp256k1_context_destroy(ctx);\n-\n-  (void)classObject;(void)env;\n-}\n-\n-SECP256K1_API jint JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ecdsa_1verify\n-  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l, jint siglen, jint publen)\n-{\n-  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n-\n-  unsigned char* data = (unsigned char*) (*env)->GetDirectBufferAddress(env, byteBufferObject);\n-  const unsigned char* sigdata = {  (unsigned char*) (data + 32) };\n-  const unsigned char* pubdata = { (unsigned char*) (data + siglen + 32) };\n-\n-  secp256k1_ecdsa_signature sig;\n-  secp256k1_pubkey pubkey;\n-\n-  int ret = secp256k1_ecdsa_signature_parse_der(ctx, &sig, sigdata, siglen);\n-\n-  if( ret ) {\n-    ret = secp256k1_ec_pubkey_parse(ctx, &pubkey, pubdata, publen);\n-\n-    if( ret ) {\n-      ret = secp256k1_ecdsa_verify(ctx, &sig, data, &pubkey);\n-    }\n-  }\n-\n-  (void)classObject;\n-\n-  return ret;\n-}\n-\n-SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ecdsa_1sign\n-  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l)\n-{\n-  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n-  unsigned char* data = (unsigned char*) (*env)->GetDirectBufferAddress(env, byteBufferObject);\n-  unsigned char* secKey = (unsigned char*) (data + 32);\n-\n-  jobjectArray retArray;\n-  jbyteArray sigArray, intsByteArray;\n-  unsigned char intsarray[2];\n-\n-  secp256k1_ecdsa_signature sig[72];\n-\n-  int ret = secp256k1_ecdsa_sign(ctx, sig, data, secKey, NULL, NULL);\n-\n-  unsigned char outputSer[72];\n-  size_t outputLen = 72;\n-\n-  if( ret ) {\n-    int ret2 = secp256k1_ecdsa_signature_serialize_der(ctx,outputSer, &outputLen, sig ); (void)ret2;\n-  }\n-\n-  intsarray[0] = outputLen;\n-  intsarray[1] = ret;\n-\n-  retArray = (*env)->NewObjectArray(env, 2,\n-    (*env)->FindClass(env, \"[B\"),\n-    (*env)->NewByteArray(env, 1));\n-\n-  sigArray = (*env)->NewByteArray(env, outputLen);\n-  (*env)->SetByteArrayRegion(env, sigArray, 0, outputLen, (jbyte*)outputSer);\n-  (*env)->SetObjectArrayElement(env, retArray, 0, sigArray);\n-\n-  intsByteArray = (*env)->NewByteArray(env, 2);\n-  (*env)->SetByteArrayRegion(env, intsByteArray, 0, 2, (jbyte*)intsarray);\n-  (*env)->SetObjectArrayElement(env, retArray, 1, intsByteArray);\n-\n-  (void)classObject;\n-\n-  return retArray;\n-}\n-\n-SECP256K1_API jint JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ec_1seckey_1verify\n-  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l)\n-{\n-  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n-  unsigned char* secKey = (unsigned char*) (*env)->GetDirectBufferAddress(env, byteBufferObject);\n-\n-  (void)classObject;\n-\n-  return secp256k1_ec_seckey_verify(ctx, secKey);\n-}\n-\n-SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ec_1pubkey_1create\n-  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l)\n-{\n-  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n-  const unsigned char* secKey = (unsigned char*) (*env)->GetDirectBufferAddress(env, byteBufferObject);\n-\n-  secp256k1_pubkey pubkey;\n-\n-  jobjectArray retArray;\n-  jbyteArray pubkeyArray, intsByteArray;\n-  unsigned char intsarray[2];\n-\n-  int ret = secp256k1_ec_pubkey_create(ctx, &pubkey, secKey);\n-\n-  unsigned char outputSer[65];\n-  size_t outputLen = 65;\n-\n-  if( ret ) {\n-    int ret2 = secp256k1_ec_pubkey_serialize(ctx,outputSer, &outputLen, &pubkey,SECP256K1_EC_UNCOMPRESSED );(void)ret2;\n-  }\n-\n-  intsarray[0] = outputLen;\n-  intsarray[1] = ret;\n-\n-  retArray = (*env)->NewObjectArray(env, 2,\n-    (*env)->FindClass(env, \"[B\"),\n-    (*env)->NewByteArray(env, 1));\n-\n-  pubkeyArray = (*env)->NewByteArray(env, outputLen);\n-  (*env)->SetByteArrayRegion(env, pubkeyArray, 0, outputLen, (jbyte*)outputSer);\n-  (*env)->SetObjectArrayElement(env, retArray, 0, pubkeyArray);\n-\n-  intsByteArray = (*env)->NewByteArray(env, 2);\n-  (*env)->SetByteArrayRegion(env, intsByteArray, 0, 2, (jbyte*)intsarray);\n-  (*env)->SetObjectArrayElement(env, retArray, 1, intsByteArray);\n-\n-  (void)classObject;\n-\n-  return retArray;\n-\n-}\n-\n-SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1privkey_1tweak_1add\n-  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l)\n-{\n-  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n-  unsigned char* privkey = (unsigned char*) (*env)->GetDirectBufferAddress(env, byteBufferObject);\n-  const unsigned char* tweak = (unsigned char*) (privkey + 32);\n-\n-  jobjectArray retArray;\n-  jbyteArray privArray, intsByteArray;\n-  unsigned char intsarray[2];\n-\n-  int privkeylen = 32;\n-\n-  int ret = secp256k1_ec_privkey_tweak_add(ctx, privkey, tweak);\n-\n-  intsarray[0] = privkeylen;\n-  intsarray[1] = ret;\n-\n-  retArray = (*env)->NewObjectArray(env, 2,\n-    (*env)->FindClass(env, \"[B\"),\n-    (*env)->NewByteArray(env, 1));\n-\n-  privArray = (*env)->NewByteArray(env, privkeylen);\n-  (*env)->SetByteArrayRegion(env, privArray, 0, privkeylen, (jbyte*)privkey);\n-  (*env)->SetObjectArrayElement(env, retArray, 0, privArray);\n-\n-  intsByteArray = (*env)->NewByteArray(env, 2);\n-  (*env)->SetByteArrayRegion(env, intsByteArray, 0, 2, (jbyte*)intsarray);\n-  (*env)->SetObjectArrayElement(env, retArray, 1, intsByteArray);\n-\n-  (void)classObject;\n-\n-  return retArray;\n-}\n-\n-SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1privkey_1tweak_1mul\n-  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l)\n-{\n-  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n-  unsigned char* privkey = (unsigned char*) (*env)->GetDirectBufferAddress(env, byteBufferObject);\n-  const unsigned char* tweak = (unsigned char*) (privkey + 32);\n-\n-  jobjectArray retArray;\n-  jbyteArray privArray, intsByteArray;\n-  unsigned char intsarray[2];\n-\n-  int privkeylen = 32;\n-\n-  int ret = secp256k1_ec_privkey_tweak_mul(ctx, privkey, tweak);\n-\n-  intsarray[0] = privkeylen;\n-  intsarray[1] = ret;\n-\n-  retArray = (*env)->NewObjectArray(env, 2,\n-    (*env)->FindClass(env, \"[B\"),\n-    (*env)->NewByteArray(env, 1));\n-\n-  privArray = (*env)->NewByteArray(env, privkeylen);\n-  (*env)->SetByteArrayRegion(env, privArray, 0, privkeylen, (jbyte*)privkey);\n-  (*env)->SetObjectArrayElement(env, retArray, 0, privArray);\n-\n-  intsByteArray = (*env)->NewByteArray(env, 2);\n-  (*env)->SetByteArrayRegion(env, intsByteArray, 0, 2, (jbyte*)intsarray);\n-  (*env)->SetObjectArrayElement(env, retArray, 1, intsByteArray);\n-\n-  (void)classObject;\n-\n-  return retArray;\n-}\n-\n-SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1pubkey_1tweak_1add\n-  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l, jint publen)\n-{\n-  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n-/*  secp256k1_pubkey* pubkey = (secp256k1_pubkey*) (*env)->GetDirectBufferAddress(env, byteBufferObject);*/\n-  unsigned char* pkey = (*env)->GetDirectBufferAddress(env, byteBufferObject);\n-  const unsigned char* tweak = (unsigned char*) (pkey + publen);\n-\n-  jobjectArray retArray;\n-  jbyteArray pubArray, intsByteArray;\n-  unsigned char intsarray[2];\n-  unsigned char outputSer[65];\n-  size_t outputLen = 65;\n-\n-  secp256k1_pubkey pubkey;\n-  int ret = secp256k1_ec_pubkey_parse(ctx, &pubkey, pkey, publen);\n-\n-  if( ret ) {\n-    ret = secp256k1_ec_pubkey_tweak_add(ctx, &pubkey, tweak);\n-  }\n-\n-  if( ret ) {\n-    int ret2 = secp256k1_ec_pubkey_serialize(ctx,outputSer, &outputLen, &pubkey,SECP256K1_EC_UNCOMPRESSED );(void)ret2;\n-  }\n-\n-  intsarray[0] = outputLen;\n-  intsarray[1] = ret;\n-\n-  retArray = (*env)->NewObjectArray(env, 2,\n-    (*env)->FindClass(env, \"[B\"),\n-    (*env)->NewByteArray(env, 1));\n-\n-  pubArray = (*env)->NewByteArray(env, outputLen);\n-  (*env)->SetByteArrayRegion(env, pubArray, 0, outputLen, (jbyte*)outputSer);\n-  (*env)->SetObjectArrayElement(env, retArray, 0, pubArray);\n-\n-  intsByteArray = (*env)->NewByteArray(env, 2);\n-  (*env)->SetByteArrayRegion(env, intsByteArray, 0, 2, (jbyte*)intsarray);\n-  (*env)->SetObjectArrayElement(env, retArray, 1, intsByteArray);\n-\n-  (void)classObject;\n-\n-  return retArray;\n-}\n-\n-SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1pubkey_1tweak_1mul\n-  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l, jint publen)\n-{\n-  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n-  unsigned char* pkey = (*env)->GetDirectBufferAddress(env, byteBufferObject);\n-  const unsigned char* tweak = (unsigned char*) (pkey + publen);\n-\n-  jobjectArray retArray;\n-  jbyteArray pubArray, intsByteArray;\n-  unsigned char intsarray[2];\n-  unsigned char outputSer[65];\n-  size_t outputLen = 65;\n-\n-  secp256k1_pubkey pubkey;\n-  int ret = secp256k1_ec_pubkey_parse(ctx, &pubkey, pkey, publen);\n-\n-  if ( ret ) {\n-    ret = secp256k1_ec_pubkey_tweak_mul(ctx, &pubkey, tweak);\n-  }\n-\n-  if( ret ) {\n-    int ret2 = secp256k1_ec_pubkey_serialize(ctx,outputSer, &outputLen, &pubkey,SECP256K1_EC_UNCOMPRESSED );(void)ret2;\n-  }\n-\n-  intsarray[0] = outputLen;\n-  intsarray[1] = ret;\n-\n-  retArray = (*env)->NewObjectArray(env, 2,\n-    (*env)->FindClass(env, \"[B\"),\n-    (*env)->NewByteArray(env, 1));\n-\n-  pubArray = (*env)->NewByteArray(env, outputLen);\n-  (*env)->SetByteArrayRegion(env, pubArray, 0, outputLen, (jbyte*)outputSer);\n-  (*env)->SetObjectArrayElement(env, retArray, 0, pubArray);\n-\n-  intsByteArray = (*env)->NewByteArray(env, 2);\n-  (*env)->SetByteArrayRegion(env, intsByteArray, 0, 2, (jbyte*)intsarray);\n-  (*env)->SetObjectArrayElement(env, retArray, 1, intsByteArray);\n-\n-  (void)classObject;\n-\n-  return retArray;\n-}\n-\n-SECP256K1_API jlong JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ecdsa_1pubkey_1combine\n-  (JNIEnv * env, jclass classObject, jobject byteBufferObject, jlong ctx_l, jint numkeys)\n-{\n-  (void)classObject;(void)env;(void)byteBufferObject;(void)ctx_l;(void)numkeys;\n-\n-  return 0;\n-}\n-\n-SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ecdh\n-  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l, jint publen)\n-{\n-  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n-  const unsigned char* secdata = (*env)->GetDirectBufferAddress(env, byteBufferObject);\n-  const unsigned char* pubdata = (const unsigned char*) (secdata + 32);\n-\n-  jobjectArray retArray;\n-  jbyteArray outArray, intsByteArray;\n-  unsigned char intsarray[1];\n-  secp256k1_pubkey pubkey;\n-  unsigned char nonce_res[32];\n-  size_t outputLen = 32;\n-\n-  int ret = secp256k1_ec_pubkey_parse(ctx, &pubkey, pubdata, publen);\n-\n-  if (ret) {\n-    ret = secp256k1_ecdh(\n-      ctx,\n-      nonce_res,\n-      &pubkey,\n-      secdata,\n-      NULL,\n-      NULL\n-    );\n-  }\n-\n-  intsarray[0] = ret;\n-\n-  retArray = (*env)->NewObjectArray(env, 2,\n-    (*env)->FindClass(env, \"[B\"),\n-    (*env)->NewByteArray(env, 1));\n-\n-  outArray = (*env)->NewByteArray(env, outputLen);\n-  (*env)->SetByteArrayRegion(env, outArray, 0, 32, (jbyte*)nonce_res);\n-  (*env)->SetObjectArrayElement(env, retArray, 0, outArray);\n-\n-  intsByteArray = (*env)->NewByteArray(env, 1);\n-  (*env)->SetByteArrayRegion(env, intsByteArray, 0, 1, (jbyte*)intsarray);\n-  (*env)->SetObjectArrayElement(env, retArray, 1, intsByteArray);\n-\n-  (void)classObject;\n-\n-  return retArray;\n-}"
      },
      {
        "sha": "fe613c9e9e77eddb18e0b0d8422948678f3408a8",
        "filename": "src/java/org_bitcoin_NativeSecp256k1.h",
        "status": "removed",
        "additions": 0,
        "deletions": 119,
        "changes": 119,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/java/org_bitcoin_NativeSecp256k1.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/java/org_bitcoin_NativeSecp256k1.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/java/org_bitcoin_NativeSecp256k1.h?ref=54245985fb3c89d72e285c4db39d38ed2f5fb0de",
        "patch": "@@ -1,119 +0,0 @@\n-/* DO NOT EDIT THIS FILE - it is machine generated */\n-#include <jni.h>\n-#include \"include/secp256k1.h\"\n-/* Header for class org_bitcoin_NativeSecp256k1 */\n-\n-#ifndef _Included_org_bitcoin_NativeSecp256k1\n-#define _Included_org_bitcoin_NativeSecp256k1\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-/*\n- * Class:     org_bitcoin_NativeSecp256k1\n- * Method:    secp256k1_ctx_clone\n- * Signature: (J)J\n- */\n-SECP256K1_API jlong JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ctx_1clone\n-  (JNIEnv *, jclass, jlong);\n-\n-/*\n- * Class:     org_bitcoin_NativeSecp256k1\n- * Method:    secp256k1_context_randomize\n- * Signature: (Ljava/nio/ByteBuffer;J)I\n- */\n-SECP256K1_API jint JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1context_1randomize\n-  (JNIEnv *, jclass, jobject, jlong);\n-\n-/*\n- * Class:     org_bitcoin_NativeSecp256k1\n- * Method:    secp256k1_privkey_tweak_add\n- * Signature: (Ljava/nio/ByteBuffer;J)[[B\n- */\n-SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1privkey_1tweak_1add\n-  (JNIEnv *, jclass, jobject, jlong);\n-\n-/*\n- * Class:     org_bitcoin_NativeSecp256k1\n- * Method:    secp256k1_privkey_tweak_mul\n- * Signature: (Ljava/nio/ByteBuffer;J)[[B\n- */\n-SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1privkey_1tweak_1mul\n-  (JNIEnv *, jclass, jobject, jlong);\n-\n-/*\n- * Class:     org_bitcoin_NativeSecp256k1\n- * Method:    secp256k1_pubkey_tweak_add\n- * Signature: (Ljava/nio/ByteBuffer;JI)[[B\n- */\n-SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1pubkey_1tweak_1add\n-  (JNIEnv *, jclass, jobject, jlong, jint);\n-\n-/*\n- * Class:     org_bitcoin_NativeSecp256k1\n- * Method:    secp256k1_pubkey_tweak_mul\n- * Signature: (Ljava/nio/ByteBuffer;JI)[[B\n- */\n-SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1pubkey_1tweak_1mul\n-  (JNIEnv *, jclass, jobject, jlong, jint);\n-\n-/*\n- * Class:     org_bitcoin_NativeSecp256k1\n- * Method:    secp256k1_destroy_context\n- * Signature: (J)V\n- */\n-SECP256K1_API void JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1destroy_1context\n-  (JNIEnv *, jclass, jlong);\n-\n-/*\n- * Class:     org_bitcoin_NativeSecp256k1\n- * Method:    secp256k1_ecdsa_verify\n- * Signature: (Ljava/nio/ByteBuffer;JII)I\n- */\n-SECP256K1_API jint JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ecdsa_1verify\n-  (JNIEnv *, jclass, jobject, jlong, jint, jint);\n-\n-/*\n- * Class:     org_bitcoin_NativeSecp256k1\n- * Method:    secp256k1_ecdsa_sign\n- * Signature: (Ljava/nio/ByteBuffer;J)[[B\n- */\n-SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ecdsa_1sign\n-  (JNIEnv *, jclass, jobject, jlong);\n-\n-/*\n- * Class:     org_bitcoin_NativeSecp256k1\n- * Method:    secp256k1_ec_seckey_verify\n- * Signature: (Ljava/nio/ByteBuffer;J)I\n- */\n-SECP256K1_API jint JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ec_1seckey_1verify\n-  (JNIEnv *, jclass, jobject, jlong);\n-\n-/*\n- * Class:     org_bitcoin_NativeSecp256k1\n- * Method:    secp256k1_ec_pubkey_create\n- * Signature: (Ljava/nio/ByteBuffer;J)[[B\n- */\n-SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ec_1pubkey_1create\n-  (JNIEnv *, jclass, jobject, jlong);\n-\n-/*\n- * Class:     org_bitcoin_NativeSecp256k1\n- * Method:    secp256k1_ec_pubkey_parse\n- * Signature: (Ljava/nio/ByteBuffer;JI)[[B\n- */\n-SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ec_1pubkey_1parse\n-  (JNIEnv *, jclass, jobject, jlong, jint);\n-\n-/*\n- * Class:     org_bitcoin_NativeSecp256k1\n- * Method:    secp256k1_ecdh\n- * Signature: (Ljava/nio/ByteBuffer;JI)[[B\n- */\n-SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ecdh\n-  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l, jint publen);\n-\n-\n-#ifdef __cplusplus\n-}\n-#endif\n-#endif"
      },
      {
        "sha": "a52939e7e7dacda374ec879d69b29ebb9add2dbc",
        "filename": "src/java/org_bitcoin_Secp256k1Context.c",
        "status": "removed",
        "additions": 0,
        "deletions": 15,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/java/org_bitcoin_Secp256k1Context.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/java/org_bitcoin_Secp256k1Context.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/java/org_bitcoin_Secp256k1Context.c?ref=54245985fb3c89d72e285c4db39d38ed2f5fb0de",
        "patch": "@@ -1,15 +0,0 @@\n-#include <stdlib.h>\n-#include <stdint.h>\n-#include \"org_bitcoin_Secp256k1Context.h\"\n-#include \"include/secp256k1.h\"\n-\n-SECP256K1_API jlong JNICALL Java_org_bitcoin_Secp256k1Context_secp256k1_1init_1context\n-  (JNIEnv* env, jclass classObject)\n-{\n-  secp256k1_context *ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n-\n-  (void)classObject;(void)env;\n-\n-  return (uintptr_t)ctx;\n-}\n-"
      },
      {
        "sha": "0d2bc84b7f3fde84f81115a037be6de105f0472b",
        "filename": "src/java/org_bitcoin_Secp256k1Context.h",
        "status": "removed",
        "additions": 0,
        "deletions": 22,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/java/org_bitcoin_Secp256k1Context.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/54245985fb3c89d72e285c4db39d38ed2f5fb0de/src/java/org_bitcoin_Secp256k1Context.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/java/org_bitcoin_Secp256k1Context.h?ref=54245985fb3c89d72e285c4db39d38ed2f5fb0de",
        "patch": "@@ -1,22 +0,0 @@\n-/* DO NOT EDIT THIS FILE - it is machine generated */\n-#include <jni.h>\n-#include \"include/secp256k1.h\"\n-/* Header for class org_bitcoin_Secp256k1Context */\n-\n-#ifndef _Included_org_bitcoin_Secp256k1Context\n-#define _Included_org_bitcoin_Secp256k1Context\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-/*\n- * Class:     org_bitcoin_Secp256k1Context\n- * Method:    secp256k1_init_context\n- * Signature: ()J\n- */\n-SECP256K1_API jlong JNICALL Java_org_bitcoin_Secp256k1Context_secp256k1_1init_1context\n-  (JNIEnv *, jclass);\n-\n-#ifdef __cplusplus\n-}\n-#endif\n-#endif"
      },
      {
        "sha": "07a25b80d4ab6f080d46fc55d635b0b86b7cb5f1",
        "filename": "src/modules/ecdh/main_impl.h",
        "status": "modified",
        "additions": 25,
        "deletions": 21,
        "changes": 46,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67f232b5d874b501c114bced5d764db7f4f5ce99/src/modules/ecdh/main_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67f232b5d874b501c114bced5d764db7f4f5ce99/src/modules/ecdh/main_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/ecdh/main_impl.h?ref=67f232b5d874b501c114bced5d764db7f4f5ce99",
        "patch": "@@ -10,14 +10,14 @@\n #include \"include/secp256k1_ecdh.h\"\n #include \"ecmult_const_impl.h\"\n \n-static int ecdh_hash_function_sha256(unsigned char *output, const unsigned char *x, const unsigned char *y, void *data) {\n-    unsigned char version = (y[31] & 0x01) | 0x02;\n+static int ecdh_hash_function_sha256(unsigned char *output, const unsigned char *x32, const unsigned char *y32, void *data) {\n+    unsigned char version = (y32[31] & 0x01) | 0x02;\n     secp256k1_sha256 sha;\n     (void)data;\n \n     secp256k1_sha256_initialize(&sha);\n     secp256k1_sha256_write(&sha, &version, 1);\n-    secp256k1_sha256_write(&sha, x, 32);\n+    secp256k1_sha256_write(&sha, x32, 32);\n     secp256k1_sha256_finalize(&sha, output);\n \n     return 1;\n@@ -32,36 +32,40 @@ int secp256k1_ecdh(const secp256k1_context* ctx, unsigned char *output, const se\n     secp256k1_gej res;\n     secp256k1_ge pt;\n     secp256k1_scalar s;\n+    unsigned char x[32];\n+    unsigned char y[32];\n+\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(output != NULL);\n     ARG_CHECK(point != NULL);\n     ARG_CHECK(scalar != NULL);\n+\n     if (hashfp == NULL) {\n         hashfp = secp256k1_ecdh_hash_function_default;\n     }\n \n     secp256k1_pubkey_load(ctx, &pt, point);\n     secp256k1_scalar_set_b32(&s, scalar, &overflow);\n-    if (overflow || secp256k1_scalar_is_zero(&s)) {\n-        ret = 0;\n-    } else {\n-        unsigned char x[32];\n-        unsigned char y[32];\n-\n-        secp256k1_ecmult_const(&res, &pt, &s, 256);\n-        secp256k1_ge_set_gej(&pt, &res);\n-\n-        /* Compute a hash of the point */\n-        secp256k1_fe_normalize(&pt.x);\n-        secp256k1_fe_normalize(&pt.y);\n-        secp256k1_fe_get_b32(x, &pt.x);\n-        secp256k1_fe_get_b32(y, &pt.y);\n-\n-        ret = hashfp(output, x, y, data);\n-    }\n \n+    overflow |= secp256k1_scalar_is_zero(&s);\n+    secp256k1_scalar_cmov(&s, &secp256k1_scalar_one, overflow);\n+\n+    secp256k1_ecmult_const(&res, &pt, &s, 256);\n+    secp256k1_ge_set_gej(&pt, &res);\n+\n+    /* Compute a hash of the point */\n+    secp256k1_fe_normalize(&pt.x);\n+    secp256k1_fe_normalize(&pt.y);\n+    secp256k1_fe_get_b32(x, &pt.x);\n+    secp256k1_fe_get_b32(y, &pt.y);\n+\n+    ret = hashfp(output, x, y, data);\n+\n+    memset(x, 0, 32);\n+    memset(y, 0, 32);\n     secp256k1_scalar_clear(&s);\n-    return ret;\n+\n+    return !!ret & !overflow;\n }\n \n #endif /* SECP256K1_MODULE_ECDH_MAIN_H */"
      },
      {
        "sha": "e2576aa953e5c19a7fcf1614412098830a0791d2",
        "filename": "src/modules/recovery/main_impl.h",
        "status": "modified",
        "additions": 3,
        "deletions": 36,
        "changes": 39,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67f232b5d874b501c114bced5d764db7f4f5ce99/src/modules/recovery/main_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67f232b5d874b501c114bced5d764db7f4f5ce99/src/modules/recovery/main_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/recovery/main_impl.h?ref=67f232b5d874b501c114bced5d764db7f4f5ce99",
        "patch": "@@ -122,48 +122,15 @@ static int secp256k1_ecdsa_sig_recover(const secp256k1_ecmult_context *ctx, cons\n \n int secp256k1_ecdsa_sign_recoverable(const secp256k1_context* ctx, secp256k1_ecdsa_recoverable_signature *signature, const unsigned char *msg32, const unsigned char *seckey, secp256k1_nonce_function noncefp, const void* noncedata) {\n     secp256k1_scalar r, s;\n-    secp256k1_scalar sec, non, msg;\n-    int recid;\n-    int ret = 0;\n-    int overflow = 0;\n+    int ret, recid;\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n     ARG_CHECK(msg32 != NULL);\n     ARG_CHECK(signature != NULL);\n     ARG_CHECK(seckey != NULL);\n-    if (noncefp == NULL) {\n-        noncefp = secp256k1_nonce_function_default;\n-    }\n \n-    secp256k1_scalar_set_b32(&sec, seckey, &overflow);\n-    /* Fail if the secret key is invalid. */\n-    if (!overflow && !secp256k1_scalar_is_zero(&sec)) {\n-        unsigned char nonce32[32];\n-        unsigned int count = 0;\n-        secp256k1_scalar_set_b32(&msg, msg32, NULL);\n-        while (1) {\n-            ret = noncefp(nonce32, msg32, seckey, NULL, (void*)noncedata, count);\n-            if (!ret) {\n-                break;\n-            }\n-            secp256k1_scalar_set_b32(&non, nonce32, &overflow);\n-            if (!secp256k1_scalar_is_zero(&non) && !overflow) {\n-                if (secp256k1_ecdsa_sig_sign(&ctx->ecmult_gen_ctx, &r, &s, &sec, &msg, &non, &recid)) {\n-                    break;\n-                }\n-            }\n-            count++;\n-        }\n-        memset(nonce32, 0, 32);\n-        secp256k1_scalar_clear(&msg);\n-        secp256k1_scalar_clear(&non);\n-        secp256k1_scalar_clear(&sec);\n-    }\n-    if (ret) {\n-        secp256k1_ecdsa_recoverable_signature_save(signature, &r, &s, recid);\n-    } else {\n-        memset(signature, 0, sizeof(*signature));\n-    }\n+    ret = secp256k1_ecdsa_sign_inner(ctx, &r, &s, &recid, msg32, seckey, noncefp, noncedata);\n+    secp256k1_ecdsa_recoverable_signature_save(signature, &r, &s, recid);\n     return ret;\n }\n "
      },
      {
        "sha": "38a533a755fc9aada88ffc66e358aee2e505d419",
        "filename": "src/modules/recovery/tests_impl.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67f232b5d874b501c114bced5d764db7f4f5ce99/src/modules/recovery/tests_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67f232b5d874b501c114bced5d764db7f4f5ce99/src/modules/recovery/tests_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/recovery/tests_impl.h?ref=67f232b5d874b501c114bced5d764db7f4f5ce99",
        "patch": "@@ -215,7 +215,7 @@ void test_ecdsa_recovery_edge_cases(void) {\n     };\n     const unsigned char sig64[64] = {\n         /* Generated by signing the above message with nonce 'This is the nonce we will use...'\n-         * and secret key 0 (which is not valid), resulting in recid 0. */\n+         * and secret key 0 (which is not valid), resulting in recid 1. */\n         0x67, 0xCB, 0x28, 0x5F, 0x9C, 0xD1, 0x94, 0xE8,\n         0x40, 0xD6, 0x29, 0x39, 0x7A, 0xF5, 0x56, 0x96,\n         0x62, 0xFD, 0xE4, 0x46, 0x49, 0x99, 0x59, 0x63,"
      },
      {
        "sha": "2a747035230bac4b6818d42032ce3c30ab427309",
        "filename": "src/scalar.h",
        "status": "modified",
        "additions": 12,
        "deletions": 1,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67f232b5d874b501c114bced5d764db7f4f5ce99/src/scalar.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67f232b5d874b501c114bced5d764db7f4f5ce99/src/scalar.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scalar.h?ref=67f232b5d874b501c114bced5d764db7f4f5ce99",
        "patch": "@@ -32,9 +32,17 @@ static unsigned int secp256k1_scalar_get_bits(const secp256k1_scalar *a, unsigne\n /** Access bits from a scalar. Not constant time. */\n static unsigned int secp256k1_scalar_get_bits_var(const secp256k1_scalar *a, unsigned int offset, unsigned int count);\n \n-/** Set a scalar from a big endian byte array. */\n+/** Set a scalar from a big endian byte array. The scalar will be reduced modulo group order `n`.\n+ * In:      bin:        pointer to a 32-byte array.\n+ * Out:     r:          scalar to be set.\n+ *          overflow:   non-zero if the scalar was bigger or equal to `n` before reduction, zero otherwise (can be NULL).\n+ */\n static void secp256k1_scalar_set_b32(secp256k1_scalar *r, const unsigned char *bin, int *overflow);\n \n+/** Set a scalar from a big endian byte array and returns 1 if it is a valid\n+ *  seckey and 0 otherwise. */\n+static int secp256k1_scalar_set_b32_seckey(secp256k1_scalar *r, const unsigned char *bin);\n+\n /** Set a scalar to an unsigned integer. */\n static void secp256k1_scalar_set_int(secp256k1_scalar *r, unsigned int v);\n \n@@ -103,4 +111,7 @@ static void secp256k1_scalar_split_lambda(secp256k1_scalar *r1, secp256k1_scalar\n /** Multiply a and b (without taking the modulus!), divide by 2**shift, and round to the nearest integer. Shift must be at least 256. */\n static void secp256k1_scalar_mul_shift_var(secp256k1_scalar *r, const secp256k1_scalar *a, const secp256k1_scalar *b, unsigned int shift);\n \n+/** If flag is true, set *r equal to *a; otherwise leave it. Constant-time.  Both *r and *a must be initialized.*/\n+static void secp256k1_scalar_cmov(secp256k1_scalar *r, const secp256k1_scalar *a, int flag);\n+\n #endif /* SECP256K1_SCALAR_H */"
      },
      {
        "sha": "8f539c4bc6b9fec329cb9acbceddc2f34605528c",
        "filename": "src/scalar_4x64_impl.h",
        "status": "modified",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67f232b5d874b501c114bced5d764db7f4f5ce99/src/scalar_4x64_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67f232b5d874b501c114bced5d764db7f4f5ce99/src/scalar_4x64_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scalar_4x64_impl.h?ref=67f232b5d874b501c114bced5d764db7f4f5ce99",
        "patch": "@@ -946,4 +946,15 @@ SECP256K1_INLINE static void secp256k1_scalar_mul_shift_var(secp256k1_scalar *r,\n     secp256k1_scalar_cadd_bit(r, 0, (l[(shift - 1) >> 6] >> ((shift - 1) & 0x3f)) & 1);\n }\n \n+static SECP256K1_INLINE void secp256k1_scalar_cmov(secp256k1_scalar *r, const secp256k1_scalar *a, int flag) {\n+    uint64_t mask0, mask1;\n+    VG_CHECK_VERIFY(r->d, sizeof(r->d));\n+    mask0 = flag + ~((uint64_t)0);\n+    mask1 = ~mask0;\n+    r->d[0] = (r->d[0] & mask0) | (a->d[0] & mask1);\n+    r->d[1] = (r->d[1] & mask0) | (a->d[1] & mask1);\n+    r->d[2] = (r->d[2] & mask0) | (a->d[2] & mask1);\n+    r->d[3] = (r->d[3] & mask0) | (a->d[3] & mask1);\n+}\n+\n #endif /* SECP256K1_SCALAR_REPR_IMPL_H */"
      },
      {
        "sha": "3c372f34fe93313f682266c4c07e08acb019e758",
        "filename": "src/scalar_8x32_impl.h",
        "status": "modified",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67f232b5d874b501c114bced5d764db7f4f5ce99/src/scalar_8x32_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67f232b5d874b501c114bced5d764db7f4f5ce99/src/scalar_8x32_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scalar_8x32_impl.h?ref=67f232b5d874b501c114bced5d764db7f4f5ce99",
        "patch": "@@ -718,4 +718,19 @@ SECP256K1_INLINE static void secp256k1_scalar_mul_shift_var(secp256k1_scalar *r,\n     secp256k1_scalar_cadd_bit(r, 0, (l[(shift - 1) >> 5] >> ((shift - 1) & 0x1f)) & 1);\n }\n \n+static SECP256K1_INLINE void secp256k1_scalar_cmov(secp256k1_scalar *r, const secp256k1_scalar *a, int flag) {\n+    uint32_t mask0, mask1;\n+    VG_CHECK_VERIFY(r->d, sizeof(r->d));\n+    mask0 = flag + ~((uint32_t)0);\n+    mask1 = ~mask0;\n+    r->d[0] = (r->d[0] & mask0) | (a->d[0] & mask1);\n+    r->d[1] = (r->d[1] & mask0) | (a->d[1] & mask1);\n+    r->d[2] = (r->d[2] & mask0) | (a->d[2] & mask1);\n+    r->d[3] = (r->d[3] & mask0) | (a->d[3] & mask1);\n+    r->d[4] = (r->d[4] & mask0) | (a->d[4] & mask1);\n+    r->d[5] = (r->d[5] & mask0) | (a->d[5] & mask1);\n+    r->d[6] = (r->d[6] & mask0) | (a->d[6] & mask1);\n+    r->d[7] = (r->d[7] & mask0) | (a->d[7] & mask1);\n+}\n+\n #endif /* SECP256K1_SCALAR_REPR_IMPL_H */"
      },
      {
        "sha": "70cd73db062af26508453fda50ee5a77789f4c66",
        "filename": "src/scalar_impl.h",
        "status": "modified",
        "additions": 10,
        "deletions": 1,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67f232b5d874b501c114bced5d764db7f4f5ce99/src/scalar_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67f232b5d874b501c114bced5d764db7f4f5ce99/src/scalar_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scalar_impl.h?ref=67f232b5d874b501c114bced5d764db7f4f5ce99",
        "patch": "@@ -7,8 +7,8 @@\n #ifndef SECP256K1_SCALAR_IMPL_H\n #define SECP256K1_SCALAR_IMPL_H\n \n-#include \"group.h\"\n #include \"scalar.h\"\n+#include \"util.h\"\n \n #if defined HAVE_CONFIG_H\n #include \"libsecp256k1-config.h\"\n@@ -24,6 +24,9 @@\n #error \"Please select scalar implementation\"\n #endif\n \n+static const secp256k1_scalar secp256k1_scalar_one = SECP256K1_SCALAR_CONST(0, 0, 0, 0, 0, 0, 0, 1);\n+static const secp256k1_scalar secp256k1_scalar_zero = SECP256K1_SCALAR_CONST(0, 0, 0, 0, 0, 0, 0, 0);\n+\n #ifndef USE_NUM_NONE\n static void secp256k1_scalar_get_num(secp256k1_num *r, const secp256k1_scalar *a) {\n     unsigned char c[32];\n@@ -52,6 +55,12 @@ static void secp256k1_scalar_order_get_num(secp256k1_num *r) {\n }\n #endif\n \n+static int secp256k1_scalar_set_b32_seckey(secp256k1_scalar *r, const unsigned char *bin) {\n+    int overflow;\n+    secp256k1_scalar_set_b32(r, bin, &overflow);\n+    return (!overflow) & (!secp256k1_scalar_is_zero(r));\n+}\n+\n static void secp256k1_scalar_inverse(secp256k1_scalar *r, const secp256k1_scalar *x) {\n #if defined(EXHAUSTIVE_TEST_ORDER)\n     int i;"
      },
      {
        "sha": "2794a7f171fa39b5741e4345455a3435b5a8a39d",
        "filename": "src/scalar_low.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67f232b5d874b501c114bced5d764db7f4f5ce99/src/scalar_low.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67f232b5d874b501c114bced5d764db7f4f5ce99/src/scalar_low.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scalar_low.h?ref=67f232b5d874b501c114bced5d764db7f4f5ce99",
        "patch": "@@ -12,4 +12,6 @@\n /** A scalar modulo the group order of the secp256k1 curve. */\n typedef uint32_t secp256k1_scalar;\n \n+#define SECP256K1_SCALAR_CONST(d7, d6, d5, d4, d3, d2, d1, d0) (d0)\n+\n #endif /* SECP256K1_SCALAR_REPR_H */"
      },
      {
        "sha": "b79cf1ff6c5cad46a183d51678b352e1154ac6a6",
        "filename": "src/scalar_low_impl.h",
        "status": "modified",
        "additions": 12,
        "deletions": 1,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67f232b5d874b501c114bced5d764db7f4f5ce99/src/scalar_low_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67f232b5d874b501c114bced5d764db7f4f5ce99/src/scalar_low_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scalar_low_impl.h?ref=67f232b5d874b501c114bced5d764db7f4f5ce99",
        "patch": "@@ -38,8 +38,11 @@ static int secp256k1_scalar_add(secp256k1_scalar *r, const secp256k1_scalar *a,\n \n static void secp256k1_scalar_cadd_bit(secp256k1_scalar *r, unsigned int bit, int flag) {\n     if (flag && bit < 32)\n-        *r += (1 << bit);\n+        *r += ((uint32_t)1 << bit);\n #ifdef VERIFY\n+    VERIFY_CHECK(bit < 32);\n+    /* Verify that adding (1 << bit) will not overflow any in-range scalar *r by overflowing the underlying uint32_t. */\n+    VERIFY_CHECK(((uint32_t)1 << bit) - 1 <= UINT32_MAX - EXHAUSTIVE_TEST_ORDER);\n     VERIFY_CHECK(secp256k1_scalar_check_overflow(r) == 0);\n #endif\n }\n@@ -111,4 +114,12 @@ SECP256K1_INLINE static int secp256k1_scalar_eq(const secp256k1_scalar *a, const\n     return *a == *b;\n }\n \n+static SECP256K1_INLINE void secp256k1_scalar_cmov(secp256k1_scalar *r, const secp256k1_scalar *a, int flag) {\n+    uint32_t mask0, mask1;\n+    VG_CHECK_VERIFY(r, sizeof(*r));\n+    mask0 = flag + ~((uint32_t)0);\n+    mask1 = ~mask0;\n+    *r = (*r & mask0) | (*a & mask1);\n+}\n+\n #endif /* SECP256K1_SCALAR_REPR_IMPL_H */"
      },
      {
        "sha": "77b35d126bbe6b22c4a2e72311dd87f91039848e",
        "filename": "src/scratch.h",
        "status": "modified",
        "additions": 17,
        "deletions": 14,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67f232b5d874b501c114bced5d764db7f4f5ce99/src/scratch.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67f232b5d874b501c114bced5d764db7f4f5ce99/src/scratch.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scratch.h?ref=67f232b5d874b501c114bced5d764db7f4f5ce99",
        "patch": "@@ -7,33 +7,36 @@\n #ifndef _SECP256K1_SCRATCH_\n #define _SECP256K1_SCRATCH_\n \n-#define SECP256K1_SCRATCH_MAX_FRAMES\t5\n-\n /* The typedef is used internally; the struct name is used in the public API\n  * (where it is exposed as a different typedef) */\n typedef struct secp256k1_scratch_space_struct {\n-    void *data[SECP256K1_SCRATCH_MAX_FRAMES];\n-    size_t offset[SECP256K1_SCRATCH_MAX_FRAMES];\n-    size_t frame_size[SECP256K1_SCRATCH_MAX_FRAMES];\n-    size_t frame;\n+    /** guard against interpreting this object as other types */\n+    unsigned char magic[8];\n+    /** actual allocated data */\n+    void *data;\n+    /** amount that has been allocated (i.e. `data + offset` is the next\n+     *  available pointer)  */\n+    size_t alloc_size;\n+    /** maximum size available to allocate */\n     size_t max_size;\n-    const secp256k1_callback* error_callback;\n } secp256k1_scratch;\n \n static secp256k1_scratch* secp256k1_scratch_create(const secp256k1_callback* error_callback, size_t max_size);\n \n-static void secp256k1_scratch_destroy(secp256k1_scratch* scratch);\n+static void secp256k1_scratch_destroy(const secp256k1_callback* error_callback, secp256k1_scratch* scratch);\n \n-/** Attempts to allocate a new stack frame with `n` available bytes. Returns 1 on success, 0 on failure */\n-static int secp256k1_scratch_allocate_frame(secp256k1_scratch* scratch, size_t n, size_t objects);\n+/** Returns an opaque object used to \"checkpoint\" a scratch space. Used\n+ *  with `secp256k1_scratch_apply_checkpoint` to undo allocations. */\n+static size_t secp256k1_scratch_checkpoint(const secp256k1_callback* error_callback, const secp256k1_scratch* scratch);\n \n-/** Deallocates a stack frame */\n-static void secp256k1_scratch_deallocate_frame(secp256k1_scratch* scratch);\n+/** Applies a check point received from `secp256k1_scratch_checkpoint`,\n+ *  undoing all allocations since that point. */\n+static void secp256k1_scratch_apply_checkpoint(const secp256k1_callback* error_callback, secp256k1_scratch* scratch, size_t checkpoint);\n \n /** Returns the maximum allocation the scratch space will allow */\n-static size_t secp256k1_scratch_max_allocation(const secp256k1_scratch* scratch, size_t n_objects);\n+static size_t secp256k1_scratch_max_allocation(const secp256k1_callback* error_callback, const secp256k1_scratch* scratch, size_t n_objects);\n \n /** Returns a pointer into the most recently allocated frame, or NULL if there is insufficient available space */\n-static void *secp256k1_scratch_alloc(secp256k1_scratch* scratch, size_t n);\n+static void *secp256k1_scratch_alloc(const secp256k1_callback* error_callback, secp256k1_scratch* scratch, size_t n);\n \n #endif"
      },
      {
        "sha": "4cee70000147b7b84e5759f00b0275fb9ead9107",
        "filename": "src/scratch_impl.h",
        "status": "modified",
        "additions": 47,
        "deletions": 45,
        "changes": 92,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67f232b5d874b501c114bced5d764db7f4f5ce99/src/scratch_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67f232b5d874b501c114bced5d764db7f4f5ce99/src/scratch_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scratch_impl.h?ref=67f232b5d874b501c114bced5d764db7f4f5ce99",
        "patch": "@@ -7,78 +7,80 @@\n #ifndef _SECP256K1_SCRATCH_IMPL_H_\n #define _SECP256K1_SCRATCH_IMPL_H_\n \n+#include \"util.h\"\n #include \"scratch.h\"\n \n-/* Using 16 bytes alignment because common architectures never have alignment\n- * requirements above 8 for any of the types we care about. In addition we\n- * leave some room because currently we don't care about a few bytes.\n- * TODO: Determine this at configure time. */\n-#define ALIGNMENT 16\n-\n-static secp256k1_scratch* secp256k1_scratch_create(const secp256k1_callback* error_callback, size_t max_size) {\n-    secp256k1_scratch* ret = (secp256k1_scratch*)checked_malloc(error_callback, sizeof(*ret));\n+static secp256k1_scratch* secp256k1_scratch_create(const secp256k1_callback* error_callback, size_t size) {\n+    const size_t base_alloc = ((sizeof(secp256k1_scratch) + ALIGNMENT - 1) / ALIGNMENT) * ALIGNMENT;\n+    void *alloc = checked_malloc(error_callback, base_alloc + size);\n+    secp256k1_scratch* ret = (secp256k1_scratch *)alloc;\n     if (ret != NULL) {\n         memset(ret, 0, sizeof(*ret));\n-        ret->max_size = max_size;\n-        ret->error_callback = error_callback;\n+        memcpy(ret->magic, \"scratch\", 8);\n+        ret->data = (void *) ((char *) alloc + base_alloc);\n+        ret->max_size = size;\n     }\n     return ret;\n }\n \n-static void secp256k1_scratch_destroy(secp256k1_scratch* scratch) {\n+static void secp256k1_scratch_destroy(const secp256k1_callback* error_callback, secp256k1_scratch* scratch) {\n     if (scratch != NULL) {\n-        VERIFY_CHECK(scratch->frame == 0);\n+        VERIFY_CHECK(scratch->alloc_size == 0); /* all checkpoints should be applied */\n+        if (memcmp(scratch->magic, \"scratch\", 8) != 0) {\n+            secp256k1_callback_call(error_callback, \"invalid scratch space\");\n+            return;\n+        }\n+        memset(scratch->magic, 0, sizeof(scratch->magic));\n         free(scratch);\n     }\n }\n \n-static size_t secp256k1_scratch_max_allocation(const secp256k1_scratch* scratch, size_t objects) {\n-    size_t i = 0;\n-    size_t allocated = 0;\n-    for (i = 0; i < scratch->frame; i++) {\n-        allocated += scratch->frame_size[i];\n-    }\n-    if (scratch->max_size - allocated <= objects * ALIGNMENT) {\n+static size_t secp256k1_scratch_checkpoint(const secp256k1_callback* error_callback, const secp256k1_scratch* scratch) {\n+    if (memcmp(scratch->magic, \"scratch\", 8) != 0) {\n+        secp256k1_callback_call(error_callback, \"invalid scratch space\");\n         return 0;\n     }\n-    return scratch->max_size - allocated - objects * ALIGNMENT;\n+    return scratch->alloc_size;\n }\n \n-static int secp256k1_scratch_allocate_frame(secp256k1_scratch* scratch, size_t n, size_t objects) {\n-    VERIFY_CHECK(scratch->frame < SECP256K1_SCRATCH_MAX_FRAMES);\n-\n-    if (n <= secp256k1_scratch_max_allocation(scratch, objects)) {\n-        n += objects * ALIGNMENT;\n-        scratch->data[scratch->frame] = checked_malloc(scratch->error_callback, n);\n-        if (scratch->data[scratch->frame] == NULL) {\n-            return 0;\n-        }\n-        scratch->frame_size[scratch->frame] = n;\n-        scratch->offset[scratch->frame] = 0;\n-        scratch->frame++;\n-        return 1;\n-    } else {\n-        return 0;\n+static void secp256k1_scratch_apply_checkpoint(const secp256k1_callback* error_callback, secp256k1_scratch* scratch, size_t checkpoint) {\n+    if (memcmp(scratch->magic, \"scratch\", 8) != 0) {\n+        secp256k1_callback_call(error_callback, \"invalid scratch space\");\n+        return;\n+    }\n+    if (checkpoint > scratch->alloc_size) {\n+        secp256k1_callback_call(error_callback, \"invalid checkpoint\");\n+        return;\n     }\n+    scratch->alloc_size = checkpoint;\n }\n \n-static void secp256k1_scratch_deallocate_frame(secp256k1_scratch* scratch) {\n-    VERIFY_CHECK(scratch->frame > 0);\n-    scratch->frame -= 1;\n-    free(scratch->data[scratch->frame]);\n+static size_t secp256k1_scratch_max_allocation(const secp256k1_callback* error_callback, const secp256k1_scratch* scratch, size_t objects) {\n+    if (memcmp(scratch->magic, \"scratch\", 8) != 0) {\n+        secp256k1_callback_call(error_callback, \"invalid scratch space\");\n+        return 0;\n+    }\n+    if (scratch->max_size - scratch->alloc_size <= objects * (ALIGNMENT - 1)) {\n+        return 0;\n+    }\n+    return scratch->max_size - scratch->alloc_size - objects * (ALIGNMENT - 1);\n }\n \n-static void *secp256k1_scratch_alloc(secp256k1_scratch* scratch, size_t size) {\n+static void *secp256k1_scratch_alloc(const secp256k1_callback* error_callback, secp256k1_scratch* scratch, size_t size) {\n     void *ret;\n-    size_t frame = scratch->frame - 1;\n-    size = ((size + ALIGNMENT - 1) / ALIGNMENT) * ALIGNMENT;\n+    size = ROUND_TO_ALIGN(size);\n+\n+    if (memcmp(scratch->magic, \"scratch\", 8) != 0) {\n+        secp256k1_callback_call(error_callback, \"invalid scratch space\");\n+        return NULL;\n+    }\n \n-    if (scratch->frame == 0 || size + scratch->offset[frame] > scratch->frame_size[frame]) {\n+    if (size > scratch->max_size - scratch->alloc_size) {\n         return NULL;\n     }\n-    ret = (void *) ((unsigned char *) scratch->data[frame] + scratch->offset[frame]);\n+    ret = (void *) ((char *) scratch->data + scratch->alloc_size);\n     memset(ret, 0, size);\n-    scratch->offset[frame] += size;\n+    scratch->alloc_size += size;\n \n     return ret;\n }"
      },
      {
        "sha": "b03a6e634596192375e27e54e5c2a2e114633482",
        "filename": "src/secp256k1.c",
        "status": "modified",
        "additions": 223,
        "deletions": 89,
        "changes": 312,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67f232b5d874b501c114bced5d764db7f4f5ce99/src/secp256k1.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67f232b5d874b501c114bced5d764db7f4f5ce99/src/secp256k1.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1.c?ref=67f232b5d874b501c114bced5d764db7f4f5ce99",
        "patch": "@@ -5,6 +5,7 @@\n  **********************************************************************/\n \n #include \"include/secp256k1.h\"\n+#include \"include/secp256k1_preallocated.h\"\n \n #include \"util.h\"\n #include \"num_impl.h\"\n@@ -19,108 +20,193 @@\n #include \"hash_impl.h\"\n #include \"scratch_impl.h\"\n \n+#if defined(VALGRIND)\n+# include <valgrind/memcheck.h>\n+#endif\n+\n #define ARG_CHECK(cond) do { \\\n     if (EXPECT(!(cond), 0)) { \\\n         secp256k1_callback_call(&ctx->illegal_callback, #cond); \\\n         return 0; \\\n     } \\\n } while(0)\n \n-static void default_illegal_callback_fn(const char* str, void* data) {\n+#define ARG_CHECK_NO_RETURN(cond) do { \\\n+    if (EXPECT(!(cond), 0)) { \\\n+        secp256k1_callback_call(&ctx->illegal_callback, #cond); \\\n+    } \\\n+} while(0)\n+\n+#ifndef USE_EXTERNAL_DEFAULT_CALLBACKS\n+#include <stdlib.h>\n+#include <stdio.h>\n+static void secp256k1_default_illegal_callback_fn(const char* str, void* data) {\n     (void)data;\n     fprintf(stderr, \"[libsecp256k1] illegal argument: %s\\n\", str);\n     abort();\n }\n-\n-static const secp256k1_callback default_illegal_callback = {\n-    default_illegal_callback_fn,\n-    NULL\n-};\n-\n-static void default_error_callback_fn(const char* str, void* data) {\n+static void secp256k1_default_error_callback_fn(const char* str, void* data) {\n     (void)data;\n     fprintf(stderr, \"[libsecp256k1] internal consistency check failed: %s\\n\", str);\n     abort();\n }\n+#else\n+void secp256k1_default_illegal_callback_fn(const char* str, void* data);\n+void secp256k1_default_error_callback_fn(const char* str, void* data);\n+#endif\n \n-static const secp256k1_callback default_error_callback = {\n-    default_error_callback_fn,\n+static const secp256k1_callback default_illegal_callback = {\n+    secp256k1_default_illegal_callback_fn,\n     NULL\n };\n \n+static const secp256k1_callback default_error_callback = {\n+    secp256k1_default_error_callback_fn,\n+    NULL\n+};\n \n struct secp256k1_context_struct {\n     secp256k1_ecmult_context ecmult_ctx;\n     secp256k1_ecmult_gen_context ecmult_gen_ctx;\n     secp256k1_callback illegal_callback;\n     secp256k1_callback error_callback;\n+    int declassify;\n };\n \n static const secp256k1_context secp256k1_context_no_precomp_ = {\n     { 0 },\n     { 0 },\n-    { default_illegal_callback_fn, 0 },\n-    { default_error_callback_fn, 0 }\n+    { secp256k1_default_illegal_callback_fn, 0 },\n+    { secp256k1_default_error_callback_fn, 0 },\n+    0\n };\n const secp256k1_context *secp256k1_context_no_precomp = &secp256k1_context_no_precomp_;\n \n-secp256k1_context* secp256k1_context_create(unsigned int flags) {\n-    secp256k1_context* ret = (secp256k1_context*)checked_malloc(&default_error_callback, sizeof(secp256k1_context));\n+size_t secp256k1_context_preallocated_size(unsigned int flags) {\n+    size_t ret = ROUND_TO_ALIGN(sizeof(secp256k1_context));\n+\n+    if (EXPECT((flags & SECP256K1_FLAGS_TYPE_MASK) != SECP256K1_FLAGS_TYPE_CONTEXT, 0)) {\n+            secp256k1_callback_call(&default_illegal_callback,\n+                                    \"Invalid flags\");\n+            return 0;\n+    }\n+\n+    if (flags & SECP256K1_FLAGS_BIT_CONTEXT_SIGN) {\n+        ret += SECP256K1_ECMULT_GEN_CONTEXT_PREALLOCATED_SIZE;\n+    }\n+    if (flags & SECP256K1_FLAGS_BIT_CONTEXT_VERIFY) {\n+        ret += SECP256K1_ECMULT_CONTEXT_PREALLOCATED_SIZE;\n+    }\n+    return ret;\n+}\n+\n+size_t secp256k1_context_preallocated_clone_size(const secp256k1_context* ctx) {\n+    size_t ret = ROUND_TO_ALIGN(sizeof(secp256k1_context));\n+    VERIFY_CHECK(ctx != NULL);\n+    if (secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx)) {\n+        ret += SECP256K1_ECMULT_GEN_CONTEXT_PREALLOCATED_SIZE;\n+    }\n+    if (secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx)) {\n+        ret += SECP256K1_ECMULT_CONTEXT_PREALLOCATED_SIZE;\n+    }\n+    return ret;\n+}\n+\n+secp256k1_context* secp256k1_context_preallocated_create(void* prealloc, unsigned int flags) {\n+    void* const base = prealloc;\n+    size_t prealloc_size;\n+    secp256k1_context* ret;\n+\n+    VERIFY_CHECK(prealloc != NULL);\n+    prealloc_size = secp256k1_context_preallocated_size(flags);\n+    ret = (secp256k1_context*)manual_alloc(&prealloc, sizeof(secp256k1_context), base, prealloc_size);\n     ret->illegal_callback = default_illegal_callback;\n     ret->error_callback = default_error_callback;\n \n     if (EXPECT((flags & SECP256K1_FLAGS_TYPE_MASK) != SECP256K1_FLAGS_TYPE_CONTEXT, 0)) {\n             secp256k1_callback_call(&ret->illegal_callback,\n                                     \"Invalid flags\");\n-            free(ret);\n             return NULL;\n     }\n \n     secp256k1_ecmult_context_init(&ret->ecmult_ctx);\n     secp256k1_ecmult_gen_context_init(&ret->ecmult_gen_ctx);\n \n     if (flags & SECP256K1_FLAGS_BIT_CONTEXT_SIGN) {\n-        secp256k1_ecmult_gen_context_build(&ret->ecmult_gen_ctx, &ret->error_callback);\n+        secp256k1_ecmult_gen_context_build(&ret->ecmult_gen_ctx, &prealloc);\n     }\n     if (flags & SECP256K1_FLAGS_BIT_CONTEXT_VERIFY) {\n-        secp256k1_ecmult_context_build(&ret->ecmult_ctx, &ret->error_callback);\n+        secp256k1_ecmult_context_build(&ret->ecmult_ctx, &prealloc);\n+    }\n+    ret->declassify = !!(flags & SECP256K1_FLAGS_BIT_CONTEXT_DECLASSIFY);\n+\n+    return (secp256k1_context*) ret;\n+}\n+\n+secp256k1_context* secp256k1_context_create(unsigned int flags) {\n+    size_t const prealloc_size = secp256k1_context_preallocated_size(flags);\n+    secp256k1_context* ctx = (secp256k1_context*)checked_malloc(&default_error_callback, prealloc_size);\n+    if (EXPECT(secp256k1_context_preallocated_create(ctx, flags) == NULL, 0)) {\n+        free(ctx);\n+        return NULL;\n     }\n \n+    return ctx;\n+}\n+\n+secp256k1_context* secp256k1_context_preallocated_clone(const secp256k1_context* ctx, void* prealloc) {\n+    size_t prealloc_size;\n+    secp256k1_context* ret;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(prealloc != NULL);\n+\n+    prealloc_size = secp256k1_context_preallocated_clone_size(ctx);\n+    ret = (secp256k1_context*)prealloc;\n+    memcpy(ret, ctx, prealloc_size);\n+    secp256k1_ecmult_gen_context_finalize_memcpy(&ret->ecmult_gen_ctx, &ctx->ecmult_gen_ctx);\n+    secp256k1_ecmult_context_finalize_memcpy(&ret->ecmult_ctx, &ctx->ecmult_ctx);\n     return ret;\n }\n \n secp256k1_context* secp256k1_context_clone(const secp256k1_context* ctx) {\n-    secp256k1_context* ret = (secp256k1_context*)checked_malloc(&ctx->error_callback, sizeof(secp256k1_context));\n-    ret->illegal_callback = ctx->illegal_callback;\n-    ret->error_callback = ctx->error_callback;\n-    secp256k1_ecmult_context_clone(&ret->ecmult_ctx, &ctx->ecmult_ctx, &ctx->error_callback);\n-    secp256k1_ecmult_gen_context_clone(&ret->ecmult_gen_ctx, &ctx->ecmult_gen_ctx, &ctx->error_callback);\n+    secp256k1_context* ret;\n+    size_t prealloc_size;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    prealloc_size = secp256k1_context_preallocated_clone_size(ctx);\n+    ret = (secp256k1_context*)checked_malloc(&ctx->error_callback, prealloc_size);\n+    ret = secp256k1_context_preallocated_clone(ctx, ret);\n     return ret;\n }\n \n-void secp256k1_context_destroy(secp256k1_context* ctx) {\n-    CHECK(ctx != secp256k1_context_no_precomp);\n+void secp256k1_context_preallocated_destroy(secp256k1_context* ctx) {\n+    ARG_CHECK_NO_RETURN(ctx != secp256k1_context_no_precomp);\n     if (ctx != NULL) {\n         secp256k1_ecmult_context_clear(&ctx->ecmult_ctx);\n         secp256k1_ecmult_gen_context_clear(&ctx->ecmult_gen_ctx);\n+    }\n+}\n \n+void secp256k1_context_destroy(secp256k1_context* ctx) {\n+    if (ctx != NULL) {\n+        secp256k1_context_preallocated_destroy(ctx);\n         free(ctx);\n     }\n }\n \n void secp256k1_context_set_illegal_callback(secp256k1_context* ctx, void (*fun)(const char* message, void* data), const void* data) {\n-    CHECK(ctx != secp256k1_context_no_precomp);\n+    ARG_CHECK_NO_RETURN(ctx != secp256k1_context_no_precomp);\n     if (fun == NULL) {\n-        fun = default_illegal_callback_fn;\n+        fun = secp256k1_default_illegal_callback_fn;\n     }\n     ctx->illegal_callback.fn = fun;\n     ctx->illegal_callback.data = data;\n }\n \n void secp256k1_context_set_error_callback(secp256k1_context* ctx, void (*fun)(const char* message, void* data), const void* data) {\n-    CHECK(ctx != secp256k1_context_no_precomp);\n+    ARG_CHECK_NO_RETURN(ctx != secp256k1_context_no_precomp);\n     if (fun == NULL) {\n-        fun = default_error_callback_fn;\n+        fun = secp256k1_default_error_callback_fn;\n     }\n     ctx->error_callback.fn = fun;\n     ctx->error_callback.data = data;\n@@ -131,8 +217,23 @@ secp256k1_scratch_space* secp256k1_scratch_space_create(const secp256k1_context*\n     return secp256k1_scratch_create(&ctx->error_callback, max_size);\n }\n \n-void secp256k1_scratch_space_destroy(secp256k1_scratch_space* scratch) {\n-    secp256k1_scratch_destroy(scratch);\n+void secp256k1_scratch_space_destroy(const secp256k1_context *ctx, secp256k1_scratch_space* scratch) {\n+    VERIFY_CHECK(ctx != NULL);\n+    secp256k1_scratch_destroy(&ctx->error_callback, scratch);\n+}\n+\n+/* Mark memory as no-longer-secret for the purpose of analysing constant-time behaviour\n+ *  of the software. This is setup for use with valgrind but could be substituted with\n+ *  the appropriate instrumentation for other analysis tools.\n+ */\n+static SECP256K1_INLINE void secp256k1_declassify(const secp256k1_context* ctx, void *p, size_t len) {\n+#if defined(VALGRIND)\n+    if (EXPECT(ctx->declassify,0)) VALGRIND_MAKE_MEM_DEFINED(p, len);\n+#else\n+    (void)ctx;\n+    (void)p;\n+    (void)len;\n+#endif\n }\n \n static int secp256k1_pubkey_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_pubkey* pubkey) {\n@@ -366,61 +467,83 @@ static int nonce_function_rfc6979(unsigned char *nonce32, const unsigned char *m\n const secp256k1_nonce_function secp256k1_nonce_function_rfc6979 = nonce_function_rfc6979;\n const secp256k1_nonce_function secp256k1_nonce_function_default = nonce_function_rfc6979;\n \n-int secp256k1_ecdsa_sign(const secp256k1_context* ctx, secp256k1_ecdsa_signature *signature, const unsigned char *msg32, const unsigned char *seckey, secp256k1_nonce_function noncefp, const void* noncedata) {\n-    secp256k1_scalar r, s;\n+static int secp256k1_ecdsa_sign_inner(const secp256k1_context* ctx, secp256k1_scalar* r, secp256k1_scalar* s, int* recid, const unsigned char *msg32, const unsigned char *seckey, secp256k1_nonce_function noncefp, const void* noncedata) {\n     secp256k1_scalar sec, non, msg;\n     int ret = 0;\n-    int overflow = 0;\n-    VERIFY_CHECK(ctx != NULL);\n-    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n-    ARG_CHECK(msg32 != NULL);\n-    ARG_CHECK(signature != NULL);\n-    ARG_CHECK(seckey != NULL);\n+    int is_sec_valid;\n+    unsigned char nonce32[32];\n+    unsigned int count = 0;\n+    /* Default initialization here is important so we won't pass uninit values to the cmov in the end */\n+    *r = secp256k1_scalar_zero;\n+    *s = secp256k1_scalar_zero;\n+    if (recid) {\n+        *recid = 0;\n+    }\n     if (noncefp == NULL) {\n         noncefp = secp256k1_nonce_function_default;\n     }\n \n-    secp256k1_scalar_set_b32(&sec, seckey, &overflow);\n     /* Fail if the secret key is invalid. */\n-    if (!overflow && !secp256k1_scalar_is_zero(&sec)) {\n-        unsigned char nonce32[32];\n-        unsigned int count = 0;\n-        secp256k1_scalar_set_b32(&msg, msg32, NULL);\n-        while (1) {\n-            ret = noncefp(nonce32, msg32, seckey, NULL, (void*)noncedata, count);\n-            if (!ret) {\n+    is_sec_valid = secp256k1_scalar_set_b32_seckey(&sec, seckey);\n+    secp256k1_scalar_cmov(&sec, &secp256k1_scalar_one, !is_sec_valid);\n+    secp256k1_scalar_set_b32(&msg, msg32, NULL);\n+    while (1) {\n+        int is_nonce_valid;\n+        ret = !!noncefp(nonce32, msg32, seckey, NULL, (void*)noncedata, count);\n+        if (!ret) {\n+            break;\n+        }\n+        is_nonce_valid = secp256k1_scalar_set_b32_seckey(&non, nonce32);\n+        /* The nonce is still secret here, but it being invalid is is less likely than 1:2^255. */\n+        secp256k1_declassify(ctx, &is_nonce_valid, sizeof(is_nonce_valid));\n+        if (is_nonce_valid) {\n+            ret = secp256k1_ecdsa_sig_sign(&ctx->ecmult_gen_ctx, r, s, &sec, &msg, &non, recid);\n+            /* The final signature is no longer a secret, nor is the fact that we were successful or not. */\n+            secp256k1_declassify(ctx, &ret, sizeof(ret));\n+            if (ret) {\n                 break;\n             }\n-            secp256k1_scalar_set_b32(&non, nonce32, &overflow);\n-            if (!overflow && !secp256k1_scalar_is_zero(&non)) {\n-                if (secp256k1_ecdsa_sig_sign(&ctx->ecmult_gen_ctx, &r, &s, &sec, &msg, &non, NULL)) {\n-                    break;\n-                }\n-            }\n-            count++;\n         }\n-        memset(nonce32, 0, 32);\n-        secp256k1_scalar_clear(&msg);\n-        secp256k1_scalar_clear(&non);\n-        secp256k1_scalar_clear(&sec);\n+        count++;\n     }\n-    if (ret) {\n-        secp256k1_ecdsa_signature_save(signature, &r, &s);\n-    } else {\n-        memset(signature, 0, sizeof(*signature));\n+    /* We don't want to declassify is_sec_valid and therefore the range of\n+     * seckey. As a result is_sec_valid is included in ret only after ret was\n+     * used as a branching variable. */\n+    ret &= is_sec_valid;\n+    memset(nonce32, 0, 32);\n+    secp256k1_scalar_clear(&msg);\n+    secp256k1_scalar_clear(&non);\n+    secp256k1_scalar_clear(&sec);\n+    secp256k1_scalar_cmov(r, &secp256k1_scalar_zero, !ret);\n+    secp256k1_scalar_cmov(s, &secp256k1_scalar_zero, !ret);\n+    if (recid) {\n+        const int zero = 0;\n+        secp256k1_int_cmov(recid, &zero, !ret);\n     }\n     return ret;\n }\n \n+int secp256k1_ecdsa_sign(const secp256k1_context* ctx, secp256k1_ecdsa_signature *signature, const unsigned char *msg32, const unsigned char *seckey, secp256k1_nonce_function noncefp, const void* noncedata) {\n+    secp256k1_scalar r, s;\n+    int ret;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(signature != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    ret = secp256k1_ecdsa_sign_inner(ctx, &r, &s, NULL, msg32, seckey, noncefp, noncedata);\n+    secp256k1_ecdsa_signature_save(signature, &r, &s);\n+    return ret;\n+}\n+\n int secp256k1_ec_seckey_verify(const secp256k1_context* ctx, const unsigned char *seckey) {\n     secp256k1_scalar sec;\n     int ret;\n-    int overflow;\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(seckey != NULL);\n \n-    secp256k1_scalar_set_b32(&sec, seckey, &overflow);\n-    ret = !overflow && !secp256k1_scalar_is_zero(&sec);\n+    ret = secp256k1_scalar_set_b32_seckey(&sec, seckey);\n     secp256k1_scalar_clear(&sec);\n     return ret;\n }\n@@ -429,35 +552,42 @@ int secp256k1_ec_pubkey_create(const secp256k1_context* ctx, secp256k1_pubkey *p\n     secp256k1_gej pj;\n     secp256k1_ge p;\n     secp256k1_scalar sec;\n-    int overflow;\n     int ret = 0;\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(pubkey != NULL);\n     memset(pubkey, 0, sizeof(*pubkey));\n     ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n     ARG_CHECK(seckey != NULL);\n \n-    secp256k1_scalar_set_b32(&sec, seckey, &overflow);\n-    ret = (!overflow) & (!secp256k1_scalar_is_zero(&sec));\n-    if (ret) {\n-        secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pj, &sec);\n-        secp256k1_ge_set_gej(&p, &pj);\n-        secp256k1_pubkey_save(pubkey, &p);\n-    }\n+    ret = secp256k1_scalar_set_b32_seckey(&sec, seckey);\n+    secp256k1_scalar_cmov(&sec, &secp256k1_scalar_one, !ret);\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pj, &sec);\n+    secp256k1_ge_set_gej(&p, &pj);\n+    secp256k1_pubkey_save(pubkey, &p);\n+    memczero(pubkey, sizeof(*pubkey), !ret);\n+\n     secp256k1_scalar_clear(&sec);\n     return ret;\n }\n \n-int secp256k1_ec_privkey_negate(const secp256k1_context* ctx, unsigned char *seckey) {\n+int secp256k1_ec_seckey_negate(const secp256k1_context* ctx, unsigned char *seckey) {\n     secp256k1_scalar sec;\n+    int ret = 0;\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(seckey != NULL);\n \n-    secp256k1_scalar_set_b32(&sec, seckey, NULL);\n+    ret = secp256k1_scalar_set_b32_seckey(&sec, seckey);\n+    secp256k1_scalar_cmov(&sec, &secp256k1_scalar_zero, !ret);\n     secp256k1_scalar_negate(&sec, &sec);\n     secp256k1_scalar_get_b32(seckey, &sec);\n \n-    return 1;\n+    secp256k1_scalar_clear(&sec);\n+    return ret;\n+}\n+\n+int secp256k1_ec_privkey_negate(const secp256k1_context* ctx, unsigned char *seckey) {\n+    return secp256k1_ec_seckey_negate(ctx, seckey);\n }\n \n int secp256k1_ec_pubkey_negate(const secp256k1_context* ctx, secp256k1_pubkey *pubkey) {\n@@ -475,7 +605,7 @@ int secp256k1_ec_pubkey_negate(const secp256k1_context* ctx, secp256k1_pubkey *p\n     return ret;\n }\n \n-int secp256k1_ec_privkey_tweak_add(const secp256k1_context* ctx, unsigned char *seckey, const unsigned char *tweak) {\n+int secp256k1_ec_seckey_tweak_add(const secp256k1_context* ctx, unsigned char *seckey, const unsigned char *tweak) {\n     secp256k1_scalar term;\n     secp256k1_scalar sec;\n     int ret = 0;\n@@ -485,19 +615,21 @@ int secp256k1_ec_privkey_tweak_add(const secp256k1_context* ctx, unsigned char *\n     ARG_CHECK(tweak != NULL);\n \n     secp256k1_scalar_set_b32(&term, tweak, &overflow);\n-    secp256k1_scalar_set_b32(&sec, seckey, NULL);\n+    ret = secp256k1_scalar_set_b32_seckey(&sec, seckey);\n \n-    ret = !overflow && secp256k1_eckey_privkey_tweak_add(&sec, &term);\n-    memset(seckey, 0, 32);\n-    if (ret) {\n-        secp256k1_scalar_get_b32(seckey, &sec);\n-    }\n+    ret &= (!overflow) & secp256k1_eckey_privkey_tweak_add(&sec, &term);\n+    secp256k1_scalar_cmov(&sec, &secp256k1_scalar_zero, !ret);\n+    secp256k1_scalar_get_b32(seckey, &sec);\n \n     secp256k1_scalar_clear(&sec);\n     secp256k1_scalar_clear(&term);\n     return ret;\n }\n \n+int secp256k1_ec_privkey_tweak_add(const secp256k1_context* ctx, unsigned char *seckey, const unsigned char *tweak) {\n+    return secp256k1_ec_seckey_tweak_add(ctx, seckey, tweak);\n+}\n+\n int secp256k1_ec_pubkey_tweak_add(const secp256k1_context* ctx, secp256k1_pubkey *pubkey, const unsigned char *tweak) {\n     secp256k1_ge p;\n     secp256k1_scalar term;\n@@ -522,7 +654,7 @@ int secp256k1_ec_pubkey_tweak_add(const secp256k1_context* ctx, secp256k1_pubkey\n     return ret;\n }\n \n-int secp256k1_ec_privkey_tweak_mul(const secp256k1_context* ctx, unsigned char *seckey, const unsigned char *tweak) {\n+int secp256k1_ec_seckey_tweak_mul(const secp256k1_context* ctx, unsigned char *seckey, const unsigned char *tweak) {\n     secp256k1_scalar factor;\n     secp256k1_scalar sec;\n     int ret = 0;\n@@ -532,18 +664,20 @@ int secp256k1_ec_privkey_tweak_mul(const secp256k1_context* ctx, unsigned char *\n     ARG_CHECK(tweak != NULL);\n \n     secp256k1_scalar_set_b32(&factor, tweak, &overflow);\n-    secp256k1_scalar_set_b32(&sec, seckey, NULL);\n-    ret = !overflow && secp256k1_eckey_privkey_tweak_mul(&sec, &factor);\n-    memset(seckey, 0, 32);\n-    if (ret) {\n-        secp256k1_scalar_get_b32(seckey, &sec);\n-    }\n+    ret = secp256k1_scalar_set_b32_seckey(&sec, seckey);\n+    ret &= (!overflow) & secp256k1_eckey_privkey_tweak_mul(&sec, &factor);\n+    secp256k1_scalar_cmov(&sec, &secp256k1_scalar_zero, !ret);\n+    secp256k1_scalar_get_b32(seckey, &sec);\n \n     secp256k1_scalar_clear(&sec);\n     secp256k1_scalar_clear(&factor);\n     return ret;\n }\n \n+int secp256k1_ec_privkey_tweak_mul(const secp256k1_context* ctx, unsigned char *seckey, const unsigned char *tweak) {\n+    return secp256k1_ec_seckey_tweak_mul(ctx, seckey, tweak);\n+}\n+\n int secp256k1_ec_pubkey_tweak_mul(const secp256k1_context* ctx, secp256k1_pubkey *pubkey, const unsigned char *tweak) {\n     secp256k1_ge p;\n     secp256k1_scalar factor;"
      },
      {
        "sha": "374ed7dc12732dfb4b673cb665b49a596dcf2ee3",
        "filename": "src/tests.c",
        "status": "modified",
        "additions": 564,
        "deletions": 115,
        "changes": 679,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67f232b5d874b501c114bced5d764db7f4f5ce99/src/tests.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67f232b5d874b501c114bced5d764db7f4f5ce99/src/tests.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/tests.c?ref=67f232b5d874b501c114bced5d764db7f4f5ce99",
        "patch": "@@ -16,6 +16,7 @@\n \n #include \"secp256k1.c\"\n #include \"include/secp256k1.h\"\n+#include \"include/secp256k1_preallocated.h\"\n #include \"testrand_impl.h\"\n \n #ifdef ENABLE_OPENSSL_TESTS\n@@ -31,17 +32,6 @@ void ECDSA_SIG_get0(const ECDSA_SIG *sig, const BIGNUM **pr, const BIGNUM **ps)\n #include \"contrib/lax_der_parsing.c\"\n #include \"contrib/lax_der_privatekey_parsing.c\"\n \n-#if !defined(VG_CHECK)\n-# if defined(VALGRIND)\n-#  include <valgrind/memcheck.h>\n-#  define VG_UNDEF(x,y) VALGRIND_MAKE_MEM_UNDEFINED((x),(y))\n-#  define VG_CHECK(x,y) VALGRIND_CHECK_MEM_IS_DEFINED((x),(y))\n-# else\n-#  define VG_UNDEF(x,y)\n-#  define VG_CHECK(x,y)\n-# endif\n-#endif\n-\n static int count = 64;\n static secp256k1_context *ctx = NULL;\n \n@@ -82,7 +72,9 @@ void random_field_element_magnitude(secp256k1_fe *fe) {\n     secp256k1_fe_negate(&zero, &zero, 0);\n     secp256k1_fe_mul_int(&zero, n - 1);\n     secp256k1_fe_add(fe, &zero);\n-    VERIFY_CHECK(fe->magnitude == n);\n+#ifdef VERIFY\n+    CHECK(fe->magnitude == n);\n+#endif\n }\n \n void random_group_element_test(secp256k1_ge *ge) {\n@@ -137,23 +129,53 @@ void random_scalar_order(secp256k1_scalar *num) {\n     } while(1);\n }\n \n-void run_context_tests(void) {\n+void random_scalar_order_b32(unsigned char *b32) {\n+    secp256k1_scalar num;\n+    random_scalar_order(&num);\n+    secp256k1_scalar_get_b32(b32, &num);\n+}\n+\n+void run_context_tests(int use_prealloc) {\n     secp256k1_pubkey pubkey;\n     secp256k1_pubkey zero_pubkey;\n     secp256k1_ecdsa_signature sig;\n     unsigned char ctmp[32];\n     int32_t ecount;\n     int32_t ecount2;\n-    secp256k1_context *none = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n-    secp256k1_context *sign = secp256k1_context_create(SECP256K1_CONTEXT_SIGN);\n-    secp256k1_context *vrfy = secp256k1_context_create(SECP256K1_CONTEXT_VERIFY);\n-    secp256k1_context *both = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n+    secp256k1_context *none;\n+    secp256k1_context *sign;\n+    secp256k1_context *vrfy;\n+    secp256k1_context *both;\n+    void *none_prealloc = NULL;\n+    void *sign_prealloc = NULL;\n+    void *vrfy_prealloc = NULL;\n+    void *both_prealloc = NULL;\n \n     secp256k1_gej pubj;\n     secp256k1_ge pub;\n     secp256k1_scalar msg, key, nonce;\n     secp256k1_scalar sigr, sigs;\n \n+    if (use_prealloc) {\n+        none_prealloc = malloc(secp256k1_context_preallocated_size(SECP256K1_CONTEXT_NONE));\n+        sign_prealloc = malloc(secp256k1_context_preallocated_size(SECP256K1_CONTEXT_SIGN));\n+        vrfy_prealloc = malloc(secp256k1_context_preallocated_size(SECP256K1_CONTEXT_VERIFY));\n+        both_prealloc = malloc(secp256k1_context_preallocated_size(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY));\n+        CHECK(none_prealloc != NULL);\n+        CHECK(sign_prealloc != NULL);\n+        CHECK(vrfy_prealloc != NULL);\n+        CHECK(both_prealloc != NULL);\n+        none = secp256k1_context_preallocated_create(none_prealloc, SECP256K1_CONTEXT_NONE);\n+        sign = secp256k1_context_preallocated_create(sign_prealloc, SECP256K1_CONTEXT_SIGN);\n+        vrfy = secp256k1_context_preallocated_create(vrfy_prealloc, SECP256K1_CONTEXT_VERIFY);\n+        both = secp256k1_context_preallocated_create(both_prealloc, SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n+    } else {\n+        none = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+        sign = secp256k1_context_create(SECP256K1_CONTEXT_SIGN);\n+        vrfy = secp256k1_context_create(SECP256K1_CONTEXT_VERIFY);\n+        both = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n+    }\n+\n     memset(&zero_pubkey, 0, sizeof(zero_pubkey));\n \n     ecount = 0;\n@@ -163,14 +185,57 @@ void run_context_tests(void) {\n     secp256k1_context_set_error_callback(sign, counting_illegal_callback_fn, NULL);\n     CHECK(vrfy->error_callback.fn != sign->error_callback.fn);\n \n+    /* check if sizes for cloning are consistent */\n+    CHECK(secp256k1_context_preallocated_clone_size(none) == secp256k1_context_preallocated_size(SECP256K1_CONTEXT_NONE));\n+    CHECK(secp256k1_context_preallocated_clone_size(sign) == secp256k1_context_preallocated_size(SECP256K1_CONTEXT_SIGN));\n+    CHECK(secp256k1_context_preallocated_clone_size(vrfy) == secp256k1_context_preallocated_size(SECP256K1_CONTEXT_VERIFY));\n+    CHECK(secp256k1_context_preallocated_clone_size(both) == secp256k1_context_preallocated_size(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY));\n+\n     /*** clone and destroy all of them to make sure cloning was complete ***/\n     {\n         secp256k1_context *ctx_tmp;\n \n-        ctx_tmp = none; none = secp256k1_context_clone(none); secp256k1_context_destroy(ctx_tmp);\n-        ctx_tmp = sign; sign = secp256k1_context_clone(sign); secp256k1_context_destroy(ctx_tmp);\n-        ctx_tmp = vrfy; vrfy = secp256k1_context_clone(vrfy); secp256k1_context_destroy(ctx_tmp);\n-        ctx_tmp = both; both = secp256k1_context_clone(both); secp256k1_context_destroy(ctx_tmp);\n+        if (use_prealloc) {\n+            /* clone into a non-preallocated context and then again into a new preallocated one. */\n+            ctx_tmp = none; none = secp256k1_context_clone(none); secp256k1_context_preallocated_destroy(ctx_tmp);\n+            free(none_prealloc); none_prealloc = malloc(secp256k1_context_preallocated_size(SECP256K1_CONTEXT_NONE)); CHECK(none_prealloc != NULL);\n+            ctx_tmp = none; none = secp256k1_context_preallocated_clone(none, none_prealloc); secp256k1_context_destroy(ctx_tmp);\n+\n+            ctx_tmp = sign; sign = secp256k1_context_clone(sign); secp256k1_context_preallocated_destroy(ctx_tmp);\n+            free(sign_prealloc); sign_prealloc = malloc(secp256k1_context_preallocated_size(SECP256K1_CONTEXT_SIGN)); CHECK(sign_prealloc != NULL);\n+            ctx_tmp = sign; sign = secp256k1_context_preallocated_clone(sign, sign_prealloc); secp256k1_context_destroy(ctx_tmp);\n+\n+            ctx_tmp = vrfy; vrfy = secp256k1_context_clone(vrfy); secp256k1_context_preallocated_destroy(ctx_tmp);\n+            free(vrfy_prealloc); vrfy_prealloc = malloc(secp256k1_context_preallocated_size(SECP256K1_CONTEXT_VERIFY)); CHECK(vrfy_prealloc != NULL);\n+            ctx_tmp = vrfy; vrfy = secp256k1_context_preallocated_clone(vrfy, vrfy_prealloc); secp256k1_context_destroy(ctx_tmp);\n+\n+            ctx_tmp = both; both = secp256k1_context_clone(both); secp256k1_context_preallocated_destroy(ctx_tmp);\n+            free(both_prealloc); both_prealloc = malloc(secp256k1_context_preallocated_size(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY)); CHECK(both_prealloc != NULL);\n+            ctx_tmp = both; both = secp256k1_context_preallocated_clone(both, both_prealloc); secp256k1_context_destroy(ctx_tmp);\n+        } else {\n+            /* clone into a preallocated context and then again into a new non-preallocated one. */\n+            void *prealloc_tmp;\n+\n+            prealloc_tmp = malloc(secp256k1_context_preallocated_size(SECP256K1_CONTEXT_NONE)); CHECK(prealloc_tmp != NULL);\n+            ctx_tmp = none; none = secp256k1_context_preallocated_clone(none, prealloc_tmp); secp256k1_context_destroy(ctx_tmp);\n+            ctx_tmp = none; none = secp256k1_context_clone(none); secp256k1_context_preallocated_destroy(ctx_tmp);\n+            free(prealloc_tmp);\n+\n+            prealloc_tmp = malloc(secp256k1_context_preallocated_size(SECP256K1_CONTEXT_SIGN)); CHECK(prealloc_tmp != NULL);\n+            ctx_tmp = sign; sign = secp256k1_context_preallocated_clone(sign, prealloc_tmp); secp256k1_context_destroy(ctx_tmp);\n+            ctx_tmp = sign; sign = secp256k1_context_clone(sign); secp256k1_context_preallocated_destroy(ctx_tmp);\n+            free(prealloc_tmp);\n+\n+            prealloc_tmp = malloc(secp256k1_context_preallocated_size(SECP256K1_CONTEXT_VERIFY)); CHECK(prealloc_tmp != NULL);\n+            ctx_tmp = vrfy; vrfy = secp256k1_context_preallocated_clone(vrfy, prealloc_tmp); secp256k1_context_destroy(ctx_tmp);\n+            ctx_tmp = vrfy; vrfy = secp256k1_context_clone(vrfy); secp256k1_context_preallocated_destroy(ctx_tmp);\n+            free(prealloc_tmp);\n+\n+            prealloc_tmp = malloc(secp256k1_context_preallocated_size(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY)); CHECK(prealloc_tmp != NULL);\n+            ctx_tmp = both; both = secp256k1_context_preallocated_clone(both, prealloc_tmp); secp256k1_context_destroy(ctx_tmp);\n+            ctx_tmp = both; both = secp256k1_context_clone(both); secp256k1_context_preallocated_destroy(ctx_tmp);\n+            free(prealloc_tmp);\n+        }\n     }\n \n     /* Verify that the error callback makes it across the clone. */\n@@ -229,10 +294,6 @@ void run_context_tests(void) {\n     secp256k1_context_set_illegal_callback(vrfy, NULL, NULL);\n     secp256k1_context_set_illegal_callback(sign, NULL, NULL);\n \n-    /* This shouldn't leak memory, due to already-set tests. */\n-    secp256k1_ecmult_gen_context_build(&sign->ecmult_gen_ctx, NULL);\n-    secp256k1_ecmult_context_build(&vrfy->ecmult_ctx, NULL);\n-\n     /* obtain a working nonce */\n     do {\n         random_scalar_order_test(&nonce);\n@@ -247,49 +308,95 @@ void run_context_tests(void) {\n     CHECK(secp256k1_ecdsa_sig_verify(&both->ecmult_ctx, &sigr, &sigs, &pub, &msg));\n \n     /* cleanup */\n-    secp256k1_context_destroy(none);\n-    secp256k1_context_destroy(sign);\n-    secp256k1_context_destroy(vrfy);\n-    secp256k1_context_destroy(both);\n+    if (use_prealloc) {\n+        secp256k1_context_preallocated_destroy(none);\n+        secp256k1_context_preallocated_destroy(sign);\n+        secp256k1_context_preallocated_destroy(vrfy);\n+        secp256k1_context_preallocated_destroy(both);\n+        free(none_prealloc);\n+        free(sign_prealloc);\n+        free(vrfy_prealloc);\n+        free(both_prealloc);\n+    } else {\n+        secp256k1_context_destroy(none);\n+        secp256k1_context_destroy(sign);\n+        secp256k1_context_destroy(vrfy);\n+        secp256k1_context_destroy(both);\n+    }\n     /* Defined as no-op. */\n     secp256k1_context_destroy(NULL);\n+    secp256k1_context_preallocated_destroy(NULL);\n+\n }\n \n void run_scratch_tests(void) {\n+    const size_t adj_alloc = ((500 + ALIGNMENT - 1) / ALIGNMENT) * ALIGNMENT;\n+\n     int32_t ecount = 0;\n+    size_t checkpoint;\n+    size_t checkpoint_2;\n     secp256k1_context *none = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n     secp256k1_scratch_space *scratch;\n+    secp256k1_scratch_space local_scratch;\n \n     /* Test public API */\n     secp256k1_context_set_illegal_callback(none, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_error_callback(none, counting_illegal_callback_fn, &ecount);\n \n     scratch = secp256k1_scratch_space_create(none, 1000);\n     CHECK(scratch != NULL);\n     CHECK(ecount == 0);\n \n     /* Test internal API */\n-    CHECK(secp256k1_scratch_max_allocation(scratch, 0) == 1000);\n-    CHECK(secp256k1_scratch_max_allocation(scratch, 1) < 1000);\n-\n-    /* Allocating 500 bytes with no frame fails */\n-    CHECK(secp256k1_scratch_alloc(scratch, 500) == NULL);\n-    CHECK(secp256k1_scratch_max_allocation(scratch, 0) == 1000);\n-\n-    /* ...but pushing a new stack frame does affect the max allocation */\n-    CHECK(secp256k1_scratch_allocate_frame(scratch, 500, 1 == 1));\n-    CHECK(secp256k1_scratch_max_allocation(scratch, 1) < 500); /* 500 - ALIGNMENT */\n-    CHECK(secp256k1_scratch_alloc(scratch, 500) != NULL);\n-    CHECK(secp256k1_scratch_alloc(scratch, 500) == NULL);\n-\n-    CHECK(secp256k1_scratch_allocate_frame(scratch, 500, 1) == 0);\n+    CHECK(secp256k1_scratch_max_allocation(&none->error_callback, scratch, 0) == 1000);\n+    CHECK(secp256k1_scratch_max_allocation(&none->error_callback, scratch, 1) == 1000 - (ALIGNMENT - 1));\n+    CHECK(scratch->alloc_size == 0);\n+    CHECK(scratch->alloc_size % ALIGNMENT == 0);\n+\n+    /* Allocating 500 bytes succeeds */\n+    checkpoint = secp256k1_scratch_checkpoint(&none->error_callback, scratch);\n+    CHECK(secp256k1_scratch_alloc(&none->error_callback, scratch, 500) != NULL);\n+    CHECK(secp256k1_scratch_max_allocation(&none->error_callback, scratch, 0) == 1000 - adj_alloc);\n+    CHECK(secp256k1_scratch_max_allocation(&none->error_callback, scratch, 1) == 1000 - adj_alloc - (ALIGNMENT - 1));\n+    CHECK(scratch->alloc_size != 0);\n+    CHECK(scratch->alloc_size % ALIGNMENT == 0);\n+\n+    /* Allocating another 500 bytes fails */\n+    CHECK(secp256k1_scratch_alloc(&none->error_callback, scratch, 500) == NULL);\n+    CHECK(secp256k1_scratch_max_allocation(&none->error_callback, scratch, 0) == 1000 - adj_alloc);\n+    CHECK(secp256k1_scratch_max_allocation(&none->error_callback, scratch, 1) == 1000 - adj_alloc - (ALIGNMENT - 1));\n+    CHECK(scratch->alloc_size != 0);\n+    CHECK(scratch->alloc_size % ALIGNMENT == 0);\n+\n+    /* ...but it succeeds once we apply the checkpoint to undo it */\n+    secp256k1_scratch_apply_checkpoint(&none->error_callback, scratch, checkpoint);\n+    CHECK(scratch->alloc_size == 0);\n+    CHECK(secp256k1_scratch_max_allocation(&none->error_callback, scratch, 0) == 1000);\n+    CHECK(secp256k1_scratch_alloc(&none->error_callback, scratch, 500) != NULL);\n+    CHECK(scratch->alloc_size != 0);\n+\n+    /* try to apply a bad checkpoint */\n+    checkpoint_2 = secp256k1_scratch_checkpoint(&none->error_callback, scratch);\n+    secp256k1_scratch_apply_checkpoint(&none->error_callback, scratch, checkpoint);\n+    CHECK(ecount == 0);\n+    secp256k1_scratch_apply_checkpoint(&none->error_callback, scratch, checkpoint_2); /* checkpoint_2 is after checkpoint */\n+    CHECK(ecount == 1);\n+    secp256k1_scratch_apply_checkpoint(&none->error_callback, scratch, (size_t) -1); /* this is just wildly invalid */\n+    CHECK(ecount == 2);\n \n-    /* ...and this effect is undone by popping the frame */\n-    secp256k1_scratch_deallocate_frame(scratch);\n-    CHECK(secp256k1_scratch_max_allocation(scratch, 0) == 1000);\n-    CHECK(secp256k1_scratch_alloc(scratch, 500) == NULL);\n+    /* try to use badly initialized scratch space */\n+    secp256k1_scratch_space_destroy(none, scratch);\n+    memset(&local_scratch, 0, sizeof(local_scratch));\n+    scratch = &local_scratch;\n+    CHECK(!secp256k1_scratch_max_allocation(&none->error_callback, scratch, 0));\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_scratch_alloc(&none->error_callback, scratch, 500) == NULL);\n+    CHECK(ecount == 4);\n+    secp256k1_scratch_space_destroy(none, scratch);\n+    CHECK(ecount == 5);\n \n     /* cleanup */\n-    secp256k1_scratch_space_destroy(scratch);\n+    secp256k1_scratch_space_destroy(none, NULL); /* no-op */\n     secp256k1_context_destroy(none);\n }\n \n@@ -965,11 +1072,31 @@ void scalar_test(void) {\n \n }\n \n+void run_scalar_set_b32_seckey_tests(void) {\n+    unsigned char b32[32];\n+    secp256k1_scalar s1;\n+    secp256k1_scalar s2;\n+\n+    /* Usually set_b32 and set_b32_seckey give the same result */\n+    random_scalar_order_b32(b32);\n+    secp256k1_scalar_set_b32(&s1, b32, NULL);\n+    CHECK(secp256k1_scalar_set_b32_seckey(&s2, b32) == 1);\n+    CHECK(secp256k1_scalar_eq(&s1, &s2) == 1);\n+\n+    memset(b32, 0, sizeof(b32));\n+    CHECK(secp256k1_scalar_set_b32_seckey(&s2, b32) == 0);\n+    memset(b32, 0xFF, sizeof(b32));\n+    CHECK(secp256k1_scalar_set_b32_seckey(&s2, b32) == 0);\n+}\n+\n void run_scalar_tests(void) {\n     int i;\n     for (i = 0; i < 128 * count; i++) {\n         scalar_test();\n     }\n+    for (i = 0; i < count; i++) {\n+        run_scalar_set_b32_seckey_tests();\n+    }\n \n     {\n         /* (-1)+1 should be zero. */\n@@ -985,16 +1112,43 @@ void run_scalar_tests(void) {\n \n #ifndef USE_NUM_NONE\n     {\n-        /* A scalar with value of the curve order should be 0. */\n+        /* Test secp256k1_scalar_set_b32 boundary conditions */\n         secp256k1_num order;\n-        secp256k1_scalar zero;\n+        secp256k1_scalar scalar;\n         unsigned char bin[32];\n+        unsigned char bin_tmp[32];\n         int overflow = 0;\n+        /* 2^256-1 - order */\n+        static const secp256k1_scalar all_ones_minus_order = SECP256K1_SCALAR_CONST(\n+            0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000001UL,\n+            0x45512319UL, 0x50B75FC4UL, 0x402DA173UL, 0x2FC9BEBEUL\n+        );\n+\n+        /* A scalar set to 0s should be 0. */\n+        memset(bin, 0, 32);\n+        secp256k1_scalar_set_b32(&scalar, bin, &overflow);\n+        CHECK(overflow == 0);\n+        CHECK(secp256k1_scalar_is_zero(&scalar));\n+\n+        /* A scalar with value of the curve order should be 0. */\n         secp256k1_scalar_order_get_num(&order);\n         secp256k1_num_get_bin(bin, 32, &order);\n-        secp256k1_scalar_set_b32(&zero, bin, &overflow);\n+        secp256k1_scalar_set_b32(&scalar, bin, &overflow);\n+        CHECK(overflow == 1);\n+        CHECK(secp256k1_scalar_is_zero(&scalar));\n+\n+        /* A scalar with value of the curve order minus one should not overflow. */\n+        bin[31] -= 1;\n+        secp256k1_scalar_set_b32(&scalar, bin, &overflow);\n+        CHECK(overflow == 0);\n+        secp256k1_scalar_get_b32(bin_tmp, &scalar);\n+        CHECK(memcmp(bin, bin_tmp, 32) == 0);\n+\n+        /* A scalar set to all 1s should overflow. */\n+        memset(bin, 0xFF, 32);\n+        secp256k1_scalar_set_b32(&scalar, bin, &overflow);\n         CHECK(overflow == 1);\n-        CHECK(secp256k1_scalar_is_zero(&zero));\n+        CHECK(secp256k1_scalar_eq(&scalar, &all_ones_minus_order));\n     }\n #endif\n \n@@ -1709,24 +1863,32 @@ void run_field_misc(void) {\n         /* Test fe conditional move; z is not normalized here. */\n         q = x;\n         secp256k1_fe_cmov(&x, &z, 0);\n-        VERIFY_CHECK(!x.normalized && x.magnitude == z.magnitude);\n+#ifdef VERIFY\n+        CHECK(x.normalized && x.magnitude == 1);\n+#endif\n         secp256k1_fe_cmov(&x, &x, 1);\n         CHECK(fe_memcmp(&x, &z) != 0);\n         CHECK(fe_memcmp(&x, &q) == 0);\n         secp256k1_fe_cmov(&q, &z, 1);\n-        VERIFY_CHECK(!q.normalized && q.magnitude == z.magnitude);\n+#ifdef VERIFY\n+        CHECK(!q.normalized && q.magnitude == z.magnitude);\n+#endif\n         CHECK(fe_memcmp(&q, &z) == 0);\n         secp256k1_fe_normalize_var(&x);\n         secp256k1_fe_normalize_var(&z);\n         CHECK(!secp256k1_fe_equal_var(&x, &z));\n         secp256k1_fe_normalize_var(&q);\n         secp256k1_fe_cmov(&q, &z, (i&1));\n-        VERIFY_CHECK(q.normalized && q.magnitude == 1);\n+#ifdef VERIFY\n+        CHECK(q.normalized && q.magnitude == 1);\n+#endif\n         for (j = 0; j < 6; j++) {\n             secp256k1_fe_negate(&z, &z, j+1);\n             secp256k1_fe_normalize_var(&q);\n             secp256k1_fe_cmov(&q, &z, (j&1));\n-            VERIFY_CHECK(!q.normalized && q.magnitude == (j+2));\n+#ifdef VERIFY\n+            CHECK((q.normalized != (j&1)) && q.magnitude == ((j&1) ? z.magnitude : 1));\n+#endif\n         }\n         secp256k1_fe_normalize_var(&z);\n         /* Test storage conversion and conditional moves. */\n@@ -2120,7 +2282,7 @@ void test_ge(void) {\n     /* Test batch gej -> ge conversion with many infinities. */\n     for (i = 0; i < 4 * runs + 1; i++) {\n         random_group_element_test(&ge[i]);\n-        /* randomly set half the points to infinitiy */\n+        /* randomly set half the points to infinity */\n         if(secp256k1_fe_is_odd(&ge[i].x)) {\n             secp256k1_ge_set_infinity(&ge[i]);\n         }\n@@ -2572,14 +2734,13 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n     secp256k1_gej r;\n     secp256k1_gej r2;\n     ecmult_multi_data data;\n-    secp256k1_scratch *scratch_empty;\n \n     data.sc = sc;\n     data.pt = pt;\n     secp256k1_scalar_set_int(&szero, 0);\n \n     /* No points to multiply */\n-    CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, NULL, ecmult_multi_callback, &data, 0));\n+    CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, NULL, ecmult_multi_callback, &data, 0));\n \n     /* Check 1- and 2-point multiplies against ecmult */\n     for (ncount = 0; ncount < count; ncount++) {\n@@ -2595,36 +2756,31 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n \n         /* only G scalar */\n         secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &ptgj, &szero, &sc[0]);\n-        CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &sc[0], ecmult_multi_callback, &data, 0));\n+        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &sc[0], ecmult_multi_callback, &data, 0));\n         secp256k1_gej_neg(&r2, &r2);\n         secp256k1_gej_add_var(&r, &r, &r2, NULL);\n         CHECK(secp256k1_gej_is_infinity(&r));\n \n         /* 1-point */\n         secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &ptgj, &sc[0], &szero);\n-        CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 1));\n+        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 1));\n         secp256k1_gej_neg(&r2, &r2);\n         secp256k1_gej_add_var(&r, &r, &r2, NULL);\n         CHECK(secp256k1_gej_is_infinity(&r));\n \n-        /* Try to multiply 1 point, but scratch space is empty */\n-        scratch_empty = secp256k1_scratch_create(&ctx->error_callback, 0);\n-        CHECK(!ecmult_multi(&ctx->ecmult_ctx, scratch_empty, &r, &szero, ecmult_multi_callback, &data, 1));\n-        secp256k1_scratch_destroy(scratch_empty);\n-\n         /* Try to multiply 1 point, but callback returns false */\n-        CHECK(!ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_false_callback, &data, 1));\n+        CHECK(!ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_false_callback, &data, 1));\n \n         /* 2-point */\n         secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &ptgj, &sc[0], &sc[1]);\n-        CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 2));\n+        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 2));\n         secp256k1_gej_neg(&r2, &r2);\n         secp256k1_gej_add_var(&r, &r, &r2, NULL);\n         CHECK(secp256k1_gej_is_infinity(&r));\n \n         /* 2-point with G scalar */\n         secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &ptgj, &sc[0], &sc[1]);\n-        CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &sc[1], ecmult_multi_callback, &data, 1));\n+        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &sc[1], ecmult_multi_callback, &data, 1));\n         secp256k1_gej_neg(&r2, &r2);\n         secp256k1_gej_add_var(&r, &r, &r2, NULL);\n         CHECK(secp256k1_gej_is_infinity(&r));\n@@ -2641,7 +2797,7 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n                 random_scalar_order(&sc[i]);\n                 secp256k1_ge_set_infinity(&pt[i]);\n             }\n-            CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n+            CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n             CHECK(secp256k1_gej_is_infinity(&r));\n         }\n \n@@ -2651,7 +2807,7 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n                 pt[i] = ptg;\n                 secp256k1_scalar_set_int(&sc[i], 0);\n             }\n-            CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n+            CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n             CHECK(secp256k1_gej_is_infinity(&r));\n         }\n \n@@ -2664,7 +2820,7 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n                 pt[2 * i + 1] = ptg;\n             }\n \n-            CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n+            CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n             CHECK(secp256k1_gej_is_infinity(&r));\n \n             random_scalar_order(&sc[0]);\n@@ -2677,7 +2833,7 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n                 secp256k1_ge_neg(&pt[2*i+1], &pt[2*i]);\n             }\n \n-            CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n+            CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n             CHECK(secp256k1_gej_is_infinity(&r));\n         }\n \n@@ -2692,7 +2848,7 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n             secp256k1_scalar_negate(&sc[i], &sc[i]);\n         }\n \n-        CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 32));\n+        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 32));\n         CHECK(secp256k1_gej_is_infinity(&r));\n     }\n \n@@ -2711,7 +2867,7 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n         }\n \n         secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &r, &sc[0], &szero);\n-        CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 20));\n+        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 20));\n         secp256k1_gej_neg(&r2, &r2);\n         secp256k1_gej_add_var(&r, &r, &r2, NULL);\n         CHECK(secp256k1_gej_is_infinity(&r));\n@@ -2734,7 +2890,7 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n \n         secp256k1_gej_set_ge(&p0j, &pt[0]);\n         secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &p0j, &rs, &szero);\n-        CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 20));\n+        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 20));\n         secp256k1_gej_neg(&r2, &r2);\n         secp256k1_gej_add_var(&r, &r, &r2, NULL);\n         CHECK(secp256k1_gej_is_infinity(&r));\n@@ -2747,13 +2903,13 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n     }\n \n     secp256k1_scalar_clear(&sc[0]);\n-    CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 20));\n+    CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 20));\n     secp256k1_scalar_clear(&sc[1]);\n     secp256k1_scalar_clear(&sc[2]);\n     secp256k1_scalar_clear(&sc[3]);\n     secp256k1_scalar_clear(&sc[4]);\n-    CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 6));\n-    CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 5));\n+    CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 6));\n+    CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 5));\n     CHECK(secp256k1_gej_is_infinity(&r));\n \n     /* Run through s0*(t0*P) + s1*(t1*P) exhaustively for many small values of s0, s1, t0, t1 */\n@@ -2798,7 +2954,7 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n                         secp256k1_scalar_add(&tmp1, &tmp1, &tmp2);\n \n                         secp256k1_ecmult(&ctx->ecmult_ctx, &expected, &ptgj, &tmp1, &szero);\n-                        CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &actual, &szero, ecmult_multi_callback, &data, 2));\n+                        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &actual, &szero, ecmult_multi_callback, &data, 2));\n                         secp256k1_gej_neg(&expected, &expected);\n                         secp256k1_gej_add_var(&actual, &actual, &expected, NULL);\n                         CHECK(secp256k1_gej_is_infinity(&actual));\n@@ -2809,6 +2965,24 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n     }\n }\n \n+void test_ecmult_multi_batch_single(secp256k1_ecmult_multi_func ecmult_multi) {\n+    secp256k1_scalar szero;\n+    secp256k1_scalar sc[32];\n+    secp256k1_ge pt[32];\n+    secp256k1_gej r;\n+    ecmult_multi_data data;\n+    secp256k1_scratch *scratch_empty;\n+\n+    data.sc = sc;\n+    data.pt = pt;\n+    secp256k1_scalar_set_int(&szero, 0);\n+\n+    /* Try to multiply 1 point, but scratch space is empty.*/\n+    scratch_empty = secp256k1_scratch_create(&ctx->error_callback, 0);\n+    CHECK(!ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch_empty, &r, &szero, ecmult_multi_callback, &data, 1));\n+    secp256k1_scratch_destroy(&ctx->error_callback, scratch_empty);\n+}\n+\n void test_secp256k1_pippenger_bucket_window_inv(void) {\n     int i;\n \n@@ -2839,17 +3013,27 @@ void test_ecmult_multi_pippenger_max_points(void) {\n     int bucket_window = 0;\n \n     for(; scratch_size < max_size; scratch_size+=256) {\n+        size_t i;\n+        size_t total_alloc;\n+        size_t checkpoint;\n         scratch = secp256k1_scratch_create(&ctx->error_callback, scratch_size);\n         CHECK(scratch != NULL);\n-        n_points_supported = secp256k1_pippenger_max_points(scratch);\n+        checkpoint = secp256k1_scratch_checkpoint(&ctx->error_callback, scratch);\n+        n_points_supported = secp256k1_pippenger_max_points(&ctx->error_callback, scratch);\n         if (n_points_supported == 0) {\n-            secp256k1_scratch_destroy(scratch);\n+            secp256k1_scratch_destroy(&ctx->error_callback, scratch);\n             continue;\n         }\n         bucket_window = secp256k1_pippenger_bucket_window(n_points_supported);\n-        CHECK(secp256k1_scratch_allocate_frame(scratch, secp256k1_pippenger_scratch_size(n_points_supported, bucket_window), PIPPENGER_SCRATCH_OBJECTS));\n-        secp256k1_scratch_deallocate_frame(scratch);\n-        secp256k1_scratch_destroy(scratch);\n+        /* allocate `total_alloc` bytes over `PIPPENGER_SCRATCH_OBJECTS` many allocations */\n+        total_alloc = secp256k1_pippenger_scratch_size(n_points_supported, bucket_window);\n+        for (i = 0; i < PIPPENGER_SCRATCH_OBJECTS - 1; i++) {\n+            CHECK(secp256k1_scratch_alloc(&ctx->error_callback, scratch, 1));\n+            total_alloc--;\n+        }\n+        CHECK(secp256k1_scratch_alloc(&ctx->error_callback, scratch, total_alloc));\n+        secp256k1_scratch_apply_checkpoint(&ctx->error_callback, scratch, checkpoint);\n+        secp256k1_scratch_destroy(&ctx->error_callback, scratch);\n     }\n     CHECK(bucket_window == PIPPENGER_MAX_BUCKET_WINDOW);\n }\n@@ -2932,19 +3116,25 @@ void test_ecmult_multi_batching(void) {\n     }\n     data.sc = sc;\n     data.pt = pt;\n+    secp256k1_gej_neg(&r2, &r2);\n \n-    /* Test with empty scratch space */\n+    /* Test with empty scratch space. It should compute the correct result using\n+     * ecmult_mult_simple algorithm which doesn't require a scratch space. */\n     scratch = secp256k1_scratch_create(&ctx->error_callback, 0);\n-    CHECK(!secp256k1_ecmult_multi_var(&ctx->ecmult_ctx, scratch, &r, &scG, ecmult_multi_callback, &data, 1));\n-    secp256k1_scratch_destroy(scratch);\n+    CHECK(secp256k1_ecmult_multi_var(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &scG, ecmult_multi_callback, &data, n_points));\n+    secp256k1_gej_add_var(&r, &r, &r2, NULL);\n+    CHECK(secp256k1_gej_is_infinity(&r));\n+    secp256k1_scratch_destroy(&ctx->error_callback, scratch);\n \n     /* Test with space for 1 point in pippenger. That's not enough because\n-     * ecmult_multi selects strauss which requires more memory. */\n+     * ecmult_multi selects strauss which requires more memory. It should\n+     * therefore select the simple algorithm. */\n     scratch = secp256k1_scratch_create(&ctx->error_callback, secp256k1_pippenger_scratch_size(1, 1) + PIPPENGER_SCRATCH_OBJECTS*ALIGNMENT);\n-    CHECK(!secp256k1_ecmult_multi_var(&ctx->ecmult_ctx, scratch, &r, &scG, ecmult_multi_callback, &data, 1));\n-    secp256k1_scratch_destroy(scratch);\n+    CHECK(secp256k1_ecmult_multi_var(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &scG, ecmult_multi_callback, &data, n_points));\n+    secp256k1_gej_add_var(&r, &r, &r2, NULL);\n+    CHECK(secp256k1_gej_is_infinity(&r));\n+    secp256k1_scratch_destroy(&ctx->error_callback, scratch);\n \n-    secp256k1_gej_neg(&r2, &r2);\n     for(i = 1; i <= n_points; i++) {\n         if (i > ECMULT_PIPPENGER_THRESHOLD) {\n             int bucket_window = secp256k1_pippenger_bucket_window(i);\n@@ -2954,10 +3144,10 @@ void test_ecmult_multi_batching(void) {\n             size_t scratch_size = secp256k1_strauss_scratch_size(i);\n             scratch = secp256k1_scratch_create(&ctx->error_callback, scratch_size + STRAUSS_SCRATCH_OBJECTS*ALIGNMENT);\n         }\n-        CHECK(secp256k1_ecmult_multi_var(&ctx->ecmult_ctx, scratch, &r, &scG, ecmult_multi_callback, &data, n_points));\n+        CHECK(secp256k1_ecmult_multi_var(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &scG, ecmult_multi_callback, &data, n_points));\n         secp256k1_gej_add_var(&r, &r, &r2, NULL);\n         CHECK(secp256k1_gej_is_infinity(&r));\n-        secp256k1_scratch_destroy(scratch);\n+        secp256k1_scratch_destroy(&ctx->error_callback, scratch);\n     }\n     free(sc);\n     free(pt);\n@@ -2972,13 +3162,15 @@ void run_ecmult_multi_tests(void) {\n     test_ecmult_multi(scratch, secp256k1_ecmult_multi_var);\n     test_ecmult_multi(NULL, secp256k1_ecmult_multi_var);\n     test_ecmult_multi(scratch, secp256k1_ecmult_pippenger_batch_single);\n+    test_ecmult_multi_batch_single(secp256k1_ecmult_pippenger_batch_single);\n     test_ecmult_multi(scratch, secp256k1_ecmult_strauss_batch_single);\n-    secp256k1_scratch_destroy(scratch);\n+    test_ecmult_multi_batch_single(secp256k1_ecmult_strauss_batch_single);\n+    secp256k1_scratch_destroy(&ctx->error_callback, scratch);\n \n     /* Run test_ecmult_multi with space for exactly one point */\n     scratch = secp256k1_scratch_create(&ctx->error_callback, secp256k1_strauss_scratch_size(1) + STRAUSS_SCRATCH_OBJECTS*ALIGNMENT);\n     test_ecmult_multi(scratch, secp256k1_ecmult_multi_var);\n-    secp256k1_scratch_destroy(scratch);\n+    secp256k1_scratch_destroy(&ctx->error_callback, scratch);\n \n     test_ecmult_multi_batch_size_helper();\n     test_ecmult_multi_batching();\n@@ -3050,7 +3242,7 @@ void test_constant_wnaf(const secp256k1_scalar *number, int w) {\n     }\n     bits = 128;\n #endif\n-    skew = secp256k1_wnaf_const(wnaf, num, w, bits);\n+    skew = secp256k1_wnaf_const(wnaf, &num, w, bits);\n \n     for (i = WNAF_SIZE_BITS(bits, w); i >= 0; --i) {\n         secp256k1_scalar t;\n@@ -3786,45 +3978,65 @@ void run_eckey_edge_case_test(void) {\n     pubkey_negone = pubkey;\n     /* Tweak of zero leaves the value unchanged. */\n     memset(ctmp2, 0, 32);\n-    CHECK(secp256k1_ec_privkey_tweak_add(ctx, ctmp, ctmp2) == 1);\n+    CHECK(secp256k1_ec_seckey_tweak_add(ctx, ctmp, ctmp2) == 1);\n     CHECK(memcmp(orderc, ctmp, 31) == 0 && ctmp[31] == 0x40);\n     memcpy(&pubkey2, &pubkey, sizeof(pubkey));\n     CHECK(secp256k1_ec_pubkey_tweak_add(ctx, &pubkey, ctmp2) == 1);\n     CHECK(memcmp(&pubkey, &pubkey2, sizeof(pubkey)) == 0);\n     /* Multiply tweak of zero zeroizes the output. */\n-    CHECK(secp256k1_ec_privkey_tweak_mul(ctx, ctmp, ctmp2) == 0);\n+    CHECK(secp256k1_ec_seckey_tweak_mul(ctx, ctmp, ctmp2) == 0);\n     CHECK(memcmp(zeros, ctmp, 32) == 0);\n     CHECK(secp256k1_ec_pubkey_tweak_mul(ctx, &pubkey, ctmp2) == 0);\n     CHECK(memcmp(&pubkey, zeros, sizeof(pubkey)) == 0);\n     memcpy(&pubkey, &pubkey2, sizeof(pubkey));\n-    /* Overflowing key tweak zeroizes. */\n+    /* If seckey_tweak_add or seckey_tweak_mul are called with an overflowing\n+    seckey, the seckey is zeroized. */\n+    memcpy(ctmp, orderc, 32);\n+    memset(ctmp2, 0, 32);\n+    ctmp2[31] = 0x01;\n+    CHECK(secp256k1_ec_seckey_verify(ctx, ctmp2) == 1);\n+    CHECK(secp256k1_ec_seckey_verify(ctx, ctmp) == 0);\n+    CHECK(secp256k1_ec_seckey_tweak_add(ctx, ctmp, ctmp2) == 0);\n+    CHECK(memcmp(zeros, ctmp, 32) == 0);\n+    memcpy(ctmp, orderc, 32);\n+    CHECK(secp256k1_ec_seckey_tweak_mul(ctx, ctmp, ctmp2) == 0);\n+    CHECK(memcmp(zeros, ctmp, 32) == 0);\n+    /* If seckey_tweak_add or seckey_tweak_mul are called with an overflowing\n+    tweak, the seckey is zeroized. */\n     memcpy(ctmp, orderc, 32);\n     ctmp[31] = 0x40;\n-    CHECK(secp256k1_ec_privkey_tweak_add(ctx, ctmp, orderc) == 0);\n+    CHECK(secp256k1_ec_seckey_tweak_add(ctx, ctmp, orderc) == 0);\n     CHECK(memcmp(zeros, ctmp, 32) == 0);\n     memcpy(ctmp, orderc, 32);\n     ctmp[31] = 0x40;\n-    CHECK(secp256k1_ec_privkey_tweak_mul(ctx, ctmp, orderc) == 0);\n+    CHECK(secp256k1_ec_seckey_tweak_mul(ctx, ctmp, orderc) == 0);\n     CHECK(memcmp(zeros, ctmp, 32) == 0);\n     memcpy(ctmp, orderc, 32);\n     ctmp[31] = 0x40;\n+    /* If pubkey_tweak_add or pubkey_tweak_mul are called with an overflowing\n+    tweak, the pubkey is zeroized. */\n     CHECK(secp256k1_ec_pubkey_tweak_add(ctx, &pubkey, orderc) == 0);\n     CHECK(memcmp(&pubkey, zeros, sizeof(pubkey)) == 0);\n     memcpy(&pubkey, &pubkey2, sizeof(pubkey));\n     CHECK(secp256k1_ec_pubkey_tweak_mul(ctx, &pubkey, orderc) == 0);\n     CHECK(memcmp(&pubkey, zeros, sizeof(pubkey)) == 0);\n     memcpy(&pubkey, &pubkey2, sizeof(pubkey));\n-    /* Private key tweaks results in a key of zero. */\n+    /* If the resulting key in secp256k1_ec_seckey_tweak_add and\n+     * secp256k1_ec_pubkey_tweak_add is 0 the functions fail and in the latter\n+     * case the pubkey is zeroized. */\n+    memcpy(ctmp, orderc, 32);\n+    ctmp[31] = 0x40;\n+    memset(ctmp2, 0, 32);\n     ctmp2[31] = 1;\n-    CHECK(secp256k1_ec_privkey_tweak_add(ctx, ctmp2, ctmp) == 0);\n+    CHECK(secp256k1_ec_seckey_tweak_add(ctx, ctmp2, ctmp) == 0);\n     CHECK(memcmp(zeros, ctmp2, 32) == 0);\n     ctmp2[31] = 1;\n     CHECK(secp256k1_ec_pubkey_tweak_add(ctx, &pubkey, ctmp2) == 0);\n     CHECK(memcmp(&pubkey, zeros, sizeof(pubkey)) == 0);\n     memcpy(&pubkey, &pubkey2, sizeof(pubkey));\n     /* Tweak computation wraps and results in a key of 1. */\n     ctmp2[31] = 2;\n-    CHECK(secp256k1_ec_privkey_tweak_add(ctx, ctmp2, ctmp) == 1);\n+    CHECK(secp256k1_ec_seckey_tweak_add(ctx, ctmp2, ctmp) == 1);\n     CHECK(memcmp(ctmp2, zeros, 31) == 0 && ctmp2[31] == 1);\n     ctmp2[31] = 2;\n     CHECK(secp256k1_ec_pubkey_tweak_add(ctx, &pubkey, ctmp2) == 1);\n@@ -3872,16 +4084,16 @@ void run_eckey_edge_case_test(void) {\n     CHECK(ecount == 2);\n     ecount = 0;\n     memset(ctmp2, 0, 32);\n-    CHECK(secp256k1_ec_privkey_tweak_add(ctx, NULL, ctmp2) == 0);\n+    CHECK(secp256k1_ec_seckey_tweak_add(ctx, NULL, ctmp2) == 0);\n     CHECK(ecount == 1);\n-    CHECK(secp256k1_ec_privkey_tweak_add(ctx, ctmp, NULL) == 0);\n+    CHECK(secp256k1_ec_seckey_tweak_add(ctx, ctmp, NULL) == 0);\n     CHECK(ecount == 2);\n     ecount = 0;\n     memset(ctmp2, 0, 32);\n     ctmp2[31] = 1;\n-    CHECK(secp256k1_ec_privkey_tweak_mul(ctx, NULL, ctmp2) == 0);\n+    CHECK(secp256k1_ec_seckey_tweak_mul(ctx, NULL, ctmp2) == 0);\n     CHECK(ecount == 1);\n-    CHECK(secp256k1_ec_privkey_tweak_mul(ctx, ctmp, NULL) == 0);\n+    CHECK(secp256k1_ec_seckey_tweak_mul(ctx, ctmp, NULL) == 0);\n     CHECK(ecount == 2);\n     ecount = 0;\n     CHECK(secp256k1_ec_pubkey_create(ctx, NULL, ctmp) == 0);\n@@ -3954,6 +4166,41 @@ void run_eckey_edge_case_test(void) {\n     secp256k1_context_set_illegal_callback(ctx, NULL, NULL);\n }\n \n+void run_eckey_negate_test(void) {\n+    unsigned char seckey[32];\n+    unsigned char seckey_tmp[32];\n+\n+    random_scalar_order_b32(seckey);\n+    memcpy(seckey_tmp, seckey, 32);\n+\n+    /* Verify negation changes the key and changes it back */\n+    CHECK(secp256k1_ec_seckey_negate(ctx, seckey) == 1);\n+    CHECK(memcmp(seckey, seckey_tmp, 32) != 0);\n+    CHECK(secp256k1_ec_seckey_negate(ctx, seckey) == 1);\n+    CHECK(memcmp(seckey, seckey_tmp, 32) == 0);\n+\n+    /* Check that privkey alias gives same result */\n+    CHECK(secp256k1_ec_seckey_negate(ctx, seckey) == 1);\n+    CHECK(secp256k1_ec_privkey_negate(ctx, seckey_tmp) == 1);\n+    CHECK(memcmp(seckey, seckey_tmp, 32) == 0);\n+\n+    /* Negating all 0s fails */\n+    memset(seckey, 0, 32);\n+    memset(seckey_tmp, 0, 32);\n+    CHECK(secp256k1_ec_seckey_negate(ctx, seckey) == 0);\n+    /* Check that seckey is not modified */\n+    CHECK(memcmp(seckey, seckey_tmp, 32) == 0);\n+\n+    /* Negating an overflowing seckey fails and the seckey is zeroed. In this\n+     * test, the seckey has 16 random bytes to ensure that ec_seckey_negate\n+     * doesn't just set seckey to a constant value in case of failure. */\n+    random_scalar_order_b32(seckey);\n+    memset(seckey, 0xFF, 16);\n+    memset(seckey_tmp, 0, 32);\n+    CHECK(secp256k1_ec_seckey_negate(ctx, seckey) == 0);\n+    CHECK(memcmp(seckey, seckey_tmp, 32) == 0);\n+}\n+\n void random_sign(secp256k1_scalar *sigr, secp256k1_scalar *sigs, const secp256k1_scalar *key, const secp256k1_scalar *msg, int *recid) {\n     secp256k1_scalar nonce;\n     do {\n@@ -4093,15 +4340,22 @@ void test_ecdsa_end_to_end(void) {\n     if (secp256k1_rand_int(3) == 0) {\n         int ret1;\n         int ret2;\n+        int ret3;\n         unsigned char rnd[32];\n+        unsigned char privkey_tmp[32];\n         secp256k1_pubkey pubkey2;\n         secp256k1_rand256_test(rnd);\n-        ret1 = secp256k1_ec_privkey_tweak_add(ctx, privkey, rnd);\n+        memcpy(privkey_tmp, privkey, 32);\n+        ret1 = secp256k1_ec_seckey_tweak_add(ctx, privkey, rnd);\n         ret2 = secp256k1_ec_pubkey_tweak_add(ctx, &pubkey, rnd);\n+        /* Check that privkey alias gives same result */\n+        ret3 = secp256k1_ec_privkey_tweak_add(ctx, privkey_tmp, rnd);\n         CHECK(ret1 == ret2);\n+        CHECK(ret2 == ret3);\n         if (ret1 == 0) {\n             return;\n         }\n+        CHECK(memcmp(privkey, privkey_tmp, 32) == 0);\n         CHECK(secp256k1_ec_pubkey_create(ctx, &pubkey2, privkey) == 1);\n         CHECK(memcmp(&pubkey, &pubkey2, sizeof(pubkey)) == 0);\n     }\n@@ -4110,15 +4364,22 @@ void test_ecdsa_end_to_end(void) {\n     if (secp256k1_rand_int(3) == 0) {\n         int ret1;\n         int ret2;\n+        int ret3;\n         unsigned char rnd[32];\n+        unsigned char privkey_tmp[32];\n         secp256k1_pubkey pubkey2;\n         secp256k1_rand256_test(rnd);\n-        ret1 = secp256k1_ec_privkey_tweak_mul(ctx, privkey, rnd);\n+        memcpy(privkey_tmp, privkey, 32);\n+        ret1 = secp256k1_ec_seckey_tweak_mul(ctx, privkey, rnd);\n         ret2 = secp256k1_ec_pubkey_tweak_mul(ctx, &pubkey, rnd);\n+        /* Check that privkey alias gives same result */\n+        ret3 = secp256k1_ec_privkey_tweak_mul(ctx, privkey_tmp, rnd);\n         CHECK(ret1 == ret2);\n+        CHECK(ret2 == ret3);\n         if (ret1 == 0) {\n             return;\n         }\n+        CHECK(memcmp(privkey, privkey_tmp, 32) == 0);\n         CHECK(secp256k1_ec_pubkey_create(ctx, &pubkey2, privkey) == 1);\n         CHECK(memcmp(&pubkey, &pubkey2, sizeof(pubkey)) == 0);\n     }\n@@ -4315,7 +4576,7 @@ int test_ecdsa_der_parse(const unsigned char *sig, size_t siglen, int certainly_\n     if (valid_der) {\n         ret |= (!roundtrips_der_lax) << 12;\n         ret |= (len_der != len_der_lax) << 13;\n-        ret |= (memcmp(roundtrip_der_lax, roundtrip_der, len_der) != 0) << 14;\n+        ret |= ((len_der != len_der_lax) || (memcmp(roundtrip_der_lax, roundtrip_der, len_der) != 0)) << 14;\n     }\n     ret |= (roundtrips_der != roundtrips_der_lax) << 15;\n     if (parsed_der) {\n@@ -4356,7 +4617,7 @@ int test_ecdsa_der_parse(const unsigned char *sig, size_t siglen, int certainly_\n     ret |= (roundtrips_der != roundtrips_openssl) << 7;\n     if (roundtrips_openssl) {\n         ret |= (len_der != (size_t)len_openssl) << 8;\n-        ret |= (memcmp(roundtrip_der, roundtrip_openssl, len_der) != 0) << 9;\n+        ret |= ((len_der != (size_t)len_openssl) || (memcmp(roundtrip_der, roundtrip_openssl, len_der) != 0)) << 9;\n     }\n #endif\n     return ret;\n@@ -5016,9 +5277,188 @@ void run_ecdsa_openssl(void) {\n # include \"modules/recovery/tests_impl.h\"\n #endif\n \n+void run_memczero_test(void) {\n+    unsigned char buf1[6] = {1, 2, 3, 4, 5, 6};\n+    unsigned char buf2[sizeof(buf1)];\n+\n+    /* memczero(..., ..., 0) is a noop. */\n+    memcpy(buf2, buf1, sizeof(buf1));\n+    memczero(buf1, sizeof(buf1), 0);\n+    CHECK(memcmp(buf1, buf2, sizeof(buf1)) == 0);\n+\n+    /* memczero(..., ..., 1) zeros the buffer. */\n+    memset(buf2, 0, sizeof(buf2));\n+    memczero(buf1, sizeof(buf1) , 1);\n+    CHECK(memcmp(buf1, buf2, sizeof(buf1)) == 0);\n+}\n+\n+void int_cmov_test(void) {\n+    int r = INT_MAX;\n+    int a = 0;\n+\n+    secp256k1_int_cmov(&r, &a, 0);\n+    CHECK(r == INT_MAX);\n+\n+    r = 0; a = INT_MAX;\n+    secp256k1_int_cmov(&r, &a, 1);\n+    CHECK(r == INT_MAX);\n+\n+    a = 0;\n+    secp256k1_int_cmov(&r, &a, 1);\n+    CHECK(r == 0);\n+\n+    a = 1;\n+    secp256k1_int_cmov(&r, &a, 1);\n+    CHECK(r == 1);\n+\n+    r = 1; a = 0;\n+    secp256k1_int_cmov(&r, &a, 0);\n+    CHECK(r == 1);\n+\n+}\n+\n+void fe_cmov_test(void) {\n+    static const secp256k1_fe zero = SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0);\n+    static const secp256k1_fe one = SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 1);\n+    static const secp256k1_fe max = SECP256K1_FE_CONST(\n+        0xFFFFFFFFUL, 0xFFFFFFFFUL, 0xFFFFFFFFUL, 0xFFFFFFFFUL,\n+        0xFFFFFFFFUL, 0xFFFFFFFFUL, 0xFFFFFFFFUL, 0xFFFFFFFFUL\n+    );\n+    secp256k1_fe r = max;\n+    secp256k1_fe a = zero;\n+\n+    secp256k1_fe_cmov(&r, &a, 0);\n+    CHECK(memcmp(&r, &max, sizeof(r)) == 0);\n+\n+    r = zero; a = max;\n+    secp256k1_fe_cmov(&r, &a, 1);\n+    CHECK(memcmp(&r, &max, sizeof(r)) == 0);\n+\n+    a = zero;\n+    secp256k1_fe_cmov(&r, &a, 1);\n+    CHECK(memcmp(&r, &zero, sizeof(r)) == 0);\n+\n+    a = one;\n+    secp256k1_fe_cmov(&r, &a, 1);\n+    CHECK(memcmp(&r, &one, sizeof(r)) == 0);\n+\n+    r = one; a = zero;\n+    secp256k1_fe_cmov(&r, &a, 0);\n+    CHECK(memcmp(&r, &one, sizeof(r)) == 0);\n+}\n+\n+void fe_storage_cmov_test(void) {\n+    static const secp256k1_fe_storage zero = SECP256K1_FE_STORAGE_CONST(0, 0, 0, 0, 0, 0, 0, 0);\n+    static const secp256k1_fe_storage one = SECP256K1_FE_STORAGE_CONST(0, 0, 0, 0, 0, 0, 0, 1);\n+    static const secp256k1_fe_storage max = SECP256K1_FE_STORAGE_CONST(\n+        0xFFFFFFFFUL, 0xFFFFFFFFUL, 0xFFFFFFFFUL, 0xFFFFFFFFUL,\n+        0xFFFFFFFFUL, 0xFFFFFFFFUL, 0xFFFFFFFFUL, 0xFFFFFFFFUL\n+    );\n+    secp256k1_fe_storage r = max;\n+    secp256k1_fe_storage a = zero;\n+\n+    secp256k1_fe_storage_cmov(&r, &a, 0);\n+    CHECK(memcmp(&r, &max, sizeof(r)) == 0);\n+\n+    r = zero; a = max;\n+    secp256k1_fe_storage_cmov(&r, &a, 1);\n+    CHECK(memcmp(&r, &max, sizeof(r)) == 0);\n+\n+    a = zero;\n+    secp256k1_fe_storage_cmov(&r, &a, 1);\n+    CHECK(memcmp(&r, &zero, sizeof(r)) == 0);\n+\n+    a = one;\n+    secp256k1_fe_storage_cmov(&r, &a, 1);\n+    CHECK(memcmp(&r, &one, sizeof(r)) == 0);\n+\n+    r = one; a = zero;\n+    secp256k1_fe_storage_cmov(&r, &a, 0);\n+    CHECK(memcmp(&r, &one, sizeof(r)) == 0);\n+}\n+\n+void scalar_cmov_test(void) {\n+    static const secp256k1_scalar zero = SECP256K1_SCALAR_CONST(0, 0, 0, 0, 0, 0, 0, 0);\n+    static const secp256k1_scalar one = SECP256K1_SCALAR_CONST(0, 0, 0, 0, 0, 0, 0, 1);\n+    static const secp256k1_scalar max = SECP256K1_SCALAR_CONST(\n+        0xFFFFFFFFUL, 0xFFFFFFFFUL, 0xFFFFFFFFUL, 0xFFFFFFFFUL,\n+        0xFFFFFFFFUL, 0xFFFFFFFFUL, 0xFFFFFFFFUL, 0xFFFFFFFFUL\n+    );\n+    secp256k1_scalar r = max;\n+    secp256k1_scalar a = zero;\n+\n+    secp256k1_scalar_cmov(&r, &a, 0);\n+    CHECK(memcmp(&r, &max, sizeof(r)) == 0);\n+\n+    r = zero; a = max;\n+    secp256k1_scalar_cmov(&r, &a, 1);\n+    CHECK(memcmp(&r, &max, sizeof(r)) == 0);\n+\n+    a = zero;\n+    secp256k1_scalar_cmov(&r, &a, 1);\n+    CHECK(memcmp(&r, &zero, sizeof(r)) == 0);\n+\n+    a = one;\n+    secp256k1_scalar_cmov(&r, &a, 1);\n+    CHECK(memcmp(&r, &one, sizeof(r)) == 0);\n+\n+    r = one; a = zero;\n+    secp256k1_scalar_cmov(&r, &a, 0);\n+    CHECK(memcmp(&r, &one, sizeof(r)) == 0);\n+}\n+\n+void ge_storage_cmov_test(void) {\n+    static const secp256k1_ge_storage zero = SECP256K1_GE_STORAGE_CONST(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n+    static const secp256k1_ge_storage one = SECP256K1_GE_STORAGE_CONST(0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1);\n+    static const secp256k1_ge_storage max = SECP256K1_GE_STORAGE_CONST(\n+        0xFFFFFFFFUL, 0xFFFFFFFFUL, 0xFFFFFFFFUL, 0xFFFFFFFFUL,\n+        0xFFFFFFFFUL, 0xFFFFFFFFUL, 0xFFFFFFFFUL, 0xFFFFFFFFUL,\n+        0xFFFFFFFFUL, 0xFFFFFFFFUL, 0xFFFFFFFFUL, 0xFFFFFFFFUL,\n+        0xFFFFFFFFUL, 0xFFFFFFFFUL, 0xFFFFFFFFUL, 0xFFFFFFFFUL\n+    );\n+    secp256k1_ge_storage r = max;\n+    secp256k1_ge_storage a = zero;\n+\n+    secp256k1_ge_storage_cmov(&r, &a, 0);\n+    CHECK(memcmp(&r, &max, sizeof(r)) == 0);\n+\n+    r = zero; a = max;\n+    secp256k1_ge_storage_cmov(&r, &a, 1);\n+    CHECK(memcmp(&r, &max, sizeof(r)) == 0);\n+\n+    a = zero;\n+    secp256k1_ge_storage_cmov(&r, &a, 1);\n+    CHECK(memcmp(&r, &zero, sizeof(r)) == 0);\n+\n+    a = one;\n+    secp256k1_ge_storage_cmov(&r, &a, 1);\n+    CHECK(memcmp(&r, &one, sizeof(r)) == 0);\n+\n+    r = one; a = zero;\n+    secp256k1_ge_storage_cmov(&r, &a, 0);\n+    CHECK(memcmp(&r, &one, sizeof(r)) == 0);\n+}\n+\n+void run_cmov_tests(void) {\n+    int_cmov_test();\n+    fe_cmov_test();\n+    fe_storage_cmov_test();\n+    scalar_cmov_test();\n+    ge_storage_cmov_test();\n+}\n+\n int main(int argc, char **argv) {\n     unsigned char seed16[16] = {0};\n     unsigned char run32[32] = {0};\n+\n+    /* Disable buffering for stdout to improve reliability of getting\n+     * diagnostic information. Happens right at the start of main because\n+     * setbuf must be used before any other operation on the stream. */\n+    setbuf(stdout, NULL);\n+    /* Also disable buffering for stderr because it's not guaranteed that it's\n+     * unbuffered on all systems. */\n+    setbuf(stderr, NULL);\n+\n     /* find iteration count */\n     if (argc > 1) {\n         count = strtol(argv[1], NULL, 0);\n@@ -5030,7 +5470,7 @@ int main(int argc, char **argv) {\n         const char* ch = argv[2];\n         while (pos < 16 && ch[0] != 0 && ch[1] != 0) {\n             unsigned short sh;\n-            if (sscanf(ch, \"%2hx\", &sh)) {\n+            if ((sscanf(ch, \"%2hx\", &sh)) == 1) {\n                 seed16[pos] = sh;\n             } else {\n                 break;\n@@ -5062,7 +5502,8 @@ int main(int argc, char **argv) {\n     printf(\"random seed = %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\\n\", seed16[0], seed16[1], seed16[2], seed16[3], seed16[4], seed16[5], seed16[6], seed16[7], seed16[8], seed16[9], seed16[10], seed16[11], seed16[12], seed16[13], seed16[14], seed16[15]);\n \n     /* initialize */\n-    run_context_tests();\n+    run_context_tests(0);\n+    run_context_tests(1);\n     run_scratch_tests();\n     ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n     if (secp256k1_rand_bits(1)) {\n@@ -5119,6 +5560,9 @@ int main(int argc, char **argv) {\n     /* EC key edge cases */\n     run_eckey_edge_case_test();\n \n+    /* EC key arithmetic test */\n+    run_eckey_negate_test();\n+\n #ifdef ENABLE_MODULE_ECDH\n     /* ecdh tests */\n     run_ecdh_tests();\n@@ -5139,6 +5583,11 @@ int main(int argc, char **argv) {\n     run_recovery_tests();\n #endif\n \n+    /* util tests */\n+    run_memczero_test();\n+\n+    run_cmov_tests();\n+\n     secp256k1_rand256(run32);\n     printf(\"random run = %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\\n\", run32[0], run32[1], run32[2], run32[3], run32[4], run32[5], run32[6], run32[7], run32[8], run32[9], run32[10], run32[11], run32[12], run32[13], run32[14], run32[15]);\n "
      },
      {
        "sha": "8cca1cef2194c3a970071d20a3e7127b4d38f6c5",
        "filename": "src/tests_exhaustive.c",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67f232b5d874b501c114bced5d764db7f4f5ce99/src/tests_exhaustive.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67f232b5d874b501c114bced5d764db7f4f5ce99/src/tests_exhaustive.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/tests_exhaustive.c?ref=67f232b5d874b501c114bced5d764db7f4f5ce99",
        "patch": "@@ -142,7 +142,7 @@ void test_exhaustive_addition(const secp256k1_ge *group, const secp256k1_gej *gr\n     for (i = 0; i < order; i++) {\n         secp256k1_gej tmp;\n         if (i > 0) {\n-            secp256k1_gej_double_nonzero(&tmp, &groupj[i], NULL);\n+            secp256k1_gej_double_nonzero(&tmp, &groupj[i]);\n             ge_equals_gej(&group[(2 * i) % order], &tmp);\n         }\n         secp256k1_gej_double_var(&tmp, &groupj[i], NULL);\n@@ -212,14 +212,14 @@ void test_exhaustive_ecmult_multi(const secp256k1_context *ctx, const secp256k1_\n                         data.pt[0] = group[x];\n                         data.pt[1] = group[y];\n \n-                        secp256k1_ecmult_multi_var(&ctx->ecmult_ctx, scratch, &tmp, &g_sc, ecmult_multi_callback, &data, 2);\n+                        secp256k1_ecmult_multi_var(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &tmp, &g_sc, ecmult_multi_callback, &data, 2);\n                         ge_equals_gej(&group[(i * x + j * y + k) % order], &tmp);\n                     }\n                 }\n             }\n         }\n     }\n-    secp256k1_scratch_destroy(scratch);\n+    secp256k1_scratch_destroy(&ctx->error_callback, scratch);\n }\n \n void r_from_k(secp256k1_scalar *r, const secp256k1_ge *group, int k) {"
      },
      {
        "sha": "8289e23e0c5db4761a85980587c415abbbd2714f",
        "filename": "src/util.h",
        "status": "modified",
        "additions": 90,
        "deletions": 0,
        "changes": 90,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67f232b5d874b501c114bced5d764db7f4f5ce99/src/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67f232b5d874b501c114bced5d764db7f4f5ce99/src/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.h?ref=67f232b5d874b501c114bced5d764db7f4f5ce99",
        "patch": "@@ -14,6 +14,7 @@\n #include <stdlib.h>\n #include <stdint.h>\n #include <stdio.h>\n+#include <limits.h>\n \n typedef struct {\n     void (*fn)(const char *text, void* data);\n@@ -68,6 +69,25 @@ static SECP256K1_INLINE void secp256k1_callback_call(const secp256k1_callback *\n #define VERIFY_SETUP(stmt)\n #endif\n \n+/* Define `VG_UNDEF` and `VG_CHECK` when VALGRIND is defined  */\n+#if !defined(VG_CHECK)\n+# if defined(VALGRIND)\n+#  include <valgrind/memcheck.h>\n+#  define VG_UNDEF(x,y) VALGRIND_MAKE_MEM_UNDEFINED((x),(y))\n+#  define VG_CHECK(x,y) VALGRIND_CHECK_MEM_IS_DEFINED((x),(y))\n+# else\n+#  define VG_UNDEF(x,y)\n+#  define VG_CHECK(x,y)\n+# endif\n+#endif\n+\n+/* Like `VG_CHECK` but on VERIFY only */\n+#if defined(VERIFY)\n+#define VG_CHECK_VERIFY(x,y) VG_CHECK((x), (y))\n+#else\n+#define VG_CHECK_VERIFY(x,y)\n+#endif\n+\n static SECP256K1_INLINE void *checked_malloc(const secp256k1_callback* cb, size_t size) {\n     void *ret = malloc(size);\n     if (ret == NULL) {\n@@ -84,6 +104,47 @@ static SECP256K1_INLINE void *checked_realloc(const secp256k1_callback* cb, void\n     return ret;\n }\n \n+#if defined(__BIGGEST_ALIGNMENT__)\n+#define ALIGNMENT __BIGGEST_ALIGNMENT__\n+#else\n+/* Using 16 bytes alignment because common architectures never have alignment\n+ * requirements above 8 for any of the types we care about. In addition we\n+ * leave some room because currently we don't care about a few bytes. */\n+#define ALIGNMENT 16\n+#endif\n+\n+#define ROUND_TO_ALIGN(size) (((size + ALIGNMENT - 1) / ALIGNMENT) * ALIGNMENT)\n+\n+/* Assume there is a contiguous memory object with bounds [base, base + max_size)\n+ * of which the memory range [base, *prealloc_ptr) is already allocated for usage,\n+ * where *prealloc_ptr is an aligned pointer. In that setting, this functions\n+ * reserves the subobject [*prealloc_ptr, *prealloc_ptr + alloc_size) of\n+ * alloc_size bytes by increasing *prealloc_ptr accordingly, taking into account\n+ * alignment requirements.\n+ *\n+ * The function returns an aligned pointer to the newly allocated subobject.\n+ *\n+ * This is useful for manual memory management: if we're simply given a block\n+ * [base, base + max_size), the caller can use this function to allocate memory\n+ * in this block and keep track of the current allocation state with *prealloc_ptr.\n+ *\n+ * It is VERIFY_CHECKed that there is enough space left in the memory object and\n+ * *prealloc_ptr is aligned relative to base.\n+ */\n+static SECP256K1_INLINE void *manual_alloc(void** prealloc_ptr, size_t alloc_size, void* base, size_t max_size) {\n+    size_t aligned_alloc_size = ROUND_TO_ALIGN(alloc_size);\n+    void* ret;\n+    VERIFY_CHECK(prealloc_ptr != NULL);\n+    VERIFY_CHECK(*prealloc_ptr != NULL);\n+    VERIFY_CHECK(base != NULL);\n+    VERIFY_CHECK((unsigned char*)*prealloc_ptr >= (unsigned char*)base);\n+    VERIFY_CHECK(((unsigned char*)*prealloc_ptr - (unsigned char*)base) % ALIGNMENT == 0);\n+    VERIFY_CHECK((unsigned char*)*prealloc_ptr - (unsigned char*)base + aligned_alloc_size <= max_size);\n+    ret = *prealloc_ptr;\n+    *((unsigned char**)prealloc_ptr) += aligned_alloc_size;\n+    return ret;\n+}\n+\n /* Macro for restrict, when available and not in a VERIFY build. */\n #if defined(SECP256K1_BUILD) && defined(VERIFY)\n # define SECP256K1_RESTRICT\n@@ -118,4 +179,33 @@ static SECP256K1_INLINE void *checked_realloc(const secp256k1_callback* cb, void\n SECP256K1_GNUC_EXT typedef unsigned __int128 uint128_t;\n #endif\n \n+/* Zero memory if flag == 1. Flag must be 0 or 1. Constant time. */\n+static SECP256K1_INLINE void memczero(void *s, size_t len, int flag) {\n+    unsigned char *p = (unsigned char *)s;\n+    /* Access flag with a volatile-qualified lvalue.\n+       This prevents clang from figuring out (after inlining) that flag can\n+       take only be 0 or 1, which leads to variable time code. */\n+    volatile int vflag = flag;\n+    unsigned char mask = -(unsigned char) vflag;\n+    while (len) {\n+        *p &= ~mask;\n+        p++;\n+        len--;\n+    }\n+}\n+\n+/** If flag is true, set *r equal to *a; otherwise leave it. Constant-time.  Both *r and *a must be initialized and non-negative.*/\n+static SECP256K1_INLINE void secp256k1_int_cmov(int *r, const int *a, int flag) {\n+    unsigned int mask0, mask1, r_masked, a_masked;\n+    /* Casting a negative int to unsigned and back to int is implementation defined behavior */\n+    VERIFY_CHECK(*r >= 0 && *a >= 0);\n+\n+    mask0 = (unsigned int)flag + ~0u;\n+    mask1 = ~mask0;\n+    r_masked = ((unsigned int)*r & mask0);\n+    a_masked = ((unsigned int)*a & mask1);\n+\n+    *r = (int)(r_masked | a_masked);\n+}\n+\n #endif /* SECP256K1_UTIL_H */"
      },
      {
        "sha": "60a82d599e8f9accfa9785c58755546051ace341",
        "filename": "src/valgrind_ctime_test.c",
        "status": "added",
        "additions": 119,
        "deletions": 0,
        "changes": 119,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/67f232b5d874b501c114bced5d764db7f4f5ce99/src/valgrind_ctime_test.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/67f232b5d874b501c114bced5d764db7f4f5ce99/src/valgrind_ctime_test.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/valgrind_ctime_test.c?ref=67f232b5d874b501c114bced5d764db7f4f5ce99",
        "patch": "@@ -0,0 +1,119 @@\n+/**********************************************************************\n+ * Copyright (c) 2020 Gregory Maxwell                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#include <valgrind/memcheck.h>\n+#include \"include/secp256k1.h\"\n+#include \"util.h\"\n+\n+#if ENABLE_MODULE_ECDH\n+# include \"include/secp256k1_ecdh.h\"\n+#endif\n+\n+#if ENABLE_MODULE_RECOVERY\n+# include \"include/secp256k1_recovery.h\"\n+#endif\n+\n+int main(void) {\n+    secp256k1_context* ctx;\n+    secp256k1_ecdsa_signature signature;\n+    secp256k1_pubkey pubkey;\n+    size_t siglen = 74;\n+    size_t outputlen = 33;\n+    int i;\n+    int ret;\n+    unsigned char msg[32];\n+    unsigned char key[32];\n+    unsigned char sig[74];\n+    unsigned char spubkey[33];\n+#if ENABLE_MODULE_RECOVERY\n+    secp256k1_ecdsa_recoverable_signature recoverable_signature;\n+    int recid;\n+#endif\n+\n+    if (!RUNNING_ON_VALGRIND) {\n+        fprintf(stderr, \"This test can only usefully be run inside valgrind.\\n\");\n+        fprintf(stderr, \"Usage: libtool --mode=execute valgrind ./valgrind_ctime_test\\n\");\n+        exit(1);\n+    }\n+\n+    /** In theory, testing with a single secret input should be sufficient:\n+     *  If control flow depended on secrets the tool would generate an error.\n+     */\n+    for (i = 0; i < 32; i++) {\n+        key[i] = i + 65;\n+    }\n+    for (i = 0; i < 32; i++) {\n+        msg[i] = i + 1;\n+    }\n+\n+    ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_DECLASSIFY);\n+\n+    /* Test keygen. */\n+    VALGRIND_MAKE_MEM_UNDEFINED(key, 32);\n+    ret = secp256k1_ec_pubkey_create(ctx, &pubkey, key);\n+    VALGRIND_MAKE_MEM_DEFINED(&pubkey, sizeof(secp256k1_pubkey));\n+    VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));\n+    CHECK(ret);\n+    CHECK(secp256k1_ec_pubkey_serialize(ctx, spubkey, &outputlen, &pubkey, SECP256K1_EC_COMPRESSED) == 1);\n+\n+    /* Test signing. */\n+    VALGRIND_MAKE_MEM_UNDEFINED(key, 32);\n+    ret = secp256k1_ecdsa_sign(ctx, &signature, msg, key, NULL, NULL);\n+    VALGRIND_MAKE_MEM_DEFINED(&signature, sizeof(secp256k1_ecdsa_signature));\n+    VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));\n+    CHECK(ret);\n+    CHECK(secp256k1_ecdsa_signature_serialize_der(ctx, sig, &siglen, &signature));\n+\n+#if ENABLE_MODULE_ECDH\n+    /* Test ECDH. */\n+    VALGRIND_MAKE_MEM_UNDEFINED(key, 32);\n+    ret = secp256k1_ecdh(ctx, msg, &pubkey, key, NULL, NULL);\n+    VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));\n+    CHECK(ret == 1);\n+#endif\n+\n+#if ENABLE_MODULE_RECOVERY\n+    /* Test signing a recoverable signature. */\n+    VALGRIND_MAKE_MEM_UNDEFINED(key, 32);\n+    ret = secp256k1_ecdsa_sign_recoverable(ctx, &recoverable_signature, msg, key, NULL, NULL);\n+    VALGRIND_MAKE_MEM_DEFINED(&recoverable_signature, sizeof(recoverable_signature));\n+    VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));\n+    CHECK(ret);\n+    CHECK(secp256k1_ecdsa_recoverable_signature_serialize_compact(ctx, sig, &recid, &recoverable_signature));\n+    CHECK(recid >= 0 && recid <= 3);\n+#endif\n+\n+    VALGRIND_MAKE_MEM_UNDEFINED(key, 32);\n+    ret = secp256k1_ec_seckey_verify(ctx, key);\n+    VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));\n+    CHECK(ret == 1);\n+\n+    VALGRIND_MAKE_MEM_UNDEFINED(key, 32);\n+    ret = secp256k1_ec_seckey_negate(ctx, key);\n+    VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));\n+    CHECK(ret == 1);\n+\n+    VALGRIND_MAKE_MEM_UNDEFINED(key, 32);\n+    VALGRIND_MAKE_MEM_UNDEFINED(msg, 32);\n+    ret = secp256k1_ec_seckey_tweak_add(ctx, key, msg);\n+    VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));\n+    CHECK(ret == 1);\n+\n+    VALGRIND_MAKE_MEM_UNDEFINED(key, 32);\n+    VALGRIND_MAKE_MEM_UNDEFINED(msg, 32);\n+    ret = secp256k1_ec_seckey_tweak_mul(ctx, key, msg);\n+    VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));\n+    CHECK(ret == 1);\n+\n+    /* Test context randomisation. Do this last because it leaves the context tainted. */\n+    VALGRIND_MAKE_MEM_UNDEFINED(key, 32);\n+    ret = secp256k1_context_randomize(ctx, key);\n+    VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));\n+    CHECK(ret);\n+\n+    secp256k1_context_destroy(ctx);\n+    return 0;\n+}"
      }
    ]
  },
  {
    "sha": "8903a1a0a78a705402123d2a5c465217cb9d791c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4OTAzYTFhMGE3OGE3MDU0MDIxMjNkMmE1YzQ2NTIxN2NiOWQ3OTFj",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-06-09T20:39:09Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-06-09T20:39:09Z"
      },
      "message": "Update src/secp256k1 subtree",
      "tree": {
        "sha": "0b03f9c68f9d9b0568f678804fbebe997e5fc549",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0b03f9c68f9d9b0568f678804fbebe997e5fc549"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8903a1a0a78a705402123d2a5c465217cb9d791c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8903a1a0a78a705402123d2a5c465217cb9d791c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8903a1a0a78a705402123d2a5c465217cb9d791c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8903a1a0a78a705402123d2a5c465217cb9d791c/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9ad6f14175c19b5d47267c3dd5840c14bad43c83",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9ad6f14175c19b5d47267c3dd5840c14bad43c83",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9ad6f14175c19b5d47267c3dd5840c14bad43c83"
      },
      {
        "sha": "67f232b5d874b501c114bced5d764db7f4f5ce99",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/67f232b5d874b501c114bced5d764db7f4f5ce99",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/67f232b5d874b501c114bced5d764db7f4f5ce99"
      }
    ],
    "stats": {
      "total": 4828,
      "additions": 2392,
      "deletions": 2436
    },
    "files": [
      {
        "sha": "cb4331aa90a2a212fc1473dc8fea50354554fd2a",
        "filename": "src/secp256k1/.gitignore",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/.gitignore?ref=8903a1a0a78a705402123d2a5c465217cb9d791c",
        "patch": "@@ -9,6 +9,7 @@ bench_internal\n tests\n exhaustive_tests\n gen_context\n+valgrind_ctime_test\n *.exe\n *.so\n *.a"
      },
      {
        "sha": "a6ad6fb27eaa488229c25748c21928518adc2c02",
        "filename": "src/secp256k1/.travis.yml",
        "status": "modified",
        "additions": 56,
        "deletions": 16,
        "changes": 72,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/.travis.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/.travis.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/.travis.yml?ref=8903a1a0a78a705402123d2a5c465217cb9d791c",
        "patch": "@@ -1,18 +1,23 @@\n language: c\n-os: linux\n+os:\n+  - linux\n+  - osx\n+\n+dist: bionic\n+# Valgrind currently supports upto macOS 10.13, the latest xcode of that version is 10.1\n+osx_image: xcode10.1\n addons:\n   apt:\n-    packages: libgmp-dev\n+    packages:\n+      - libgmp-dev\n+      - valgrind\n+      - libtool-bin\n compiler:\n   - clang\n   - gcc\n-cache:\n-  directories:\n-  - src/java/guava/\n env:\n   global:\n-    - FIELD=auto  BIGNUM=auto  SCALAR=auto  ENDOMORPHISM=no  STATICPRECOMPUTATION=yes  ASM=no  BUILD=check  EXTRAFLAGS=  HOST=  ECDH=no  RECOVERY=no  EXPERIMENTAL=no  JNI=no\n-    - GUAVA_URL=https://search.maven.org/remotecontent?filepath=com/google/guava/guava/18.0/guava-18.0.jar GUAVA_JAR=src/java/guava/guava-18.0.jar\n+    - FIELD=auto  BIGNUM=auto  SCALAR=auto  ENDOMORPHISM=no  STATICPRECOMPUTATION=yes  ECMULTGENPRECISION=auto  ASM=no  BUILD=check  EXTRAFLAGS=  HOST=  ECDH=no  RECOVERY=no  EXPERIMENTAL=no CTIMETEST=yes BENCH=yes ITERS=2\n   matrix:\n     - SCALAR=32bit    RECOVERY=yes\n     - SCALAR=32bit    FIELD=32bit       ECDH=yes  EXPERIMENTAL=yes\n@@ -26,43 +31,78 @@ env:\n     - BIGNUM=no\n     - BIGNUM=no       ENDOMORPHISM=yes RECOVERY=yes EXPERIMENTAL=yes\n     - BIGNUM=no       STATICPRECOMPUTATION=no\n-    - BUILD=distcheck\n-    - EXTRAFLAGS=CPPFLAGS=-DDETERMINISTIC\n-    - EXTRAFLAGS=CFLAGS=-O0\n-    - BUILD=check-java JNI=yes ECDH=yes EXPERIMENTAL=yes\n+    - BUILD=distcheck CTIMETEST= BENCH=\n+    - CPPFLAGS=-DDETERMINISTIC\n+    - CFLAGS=-O0 CTIMETEST=\n+    - ECMULTGENPRECISION=2\n+    - ECMULTGENPRECISION=8\n+    - VALGRIND=yes ENDOMORPHISM=yes BIGNUM=no ASM=x86_64 EXPERIMENTAL=yes ECDH=yes  RECOVERY=yes EXTRAFLAGS=\"--disable-openssl-tests\" CPPFLAGS=-DVALGRIND BUILD=\n+    - VALGRIND=yes                  BIGNUM=no ASM=x86_64 EXPERIMENTAL=yes ECDH=yes  RECOVERY=yes EXTRAFLAGS=\"--disable-openssl-tests\" CPPFLAGS=-DVALGRIND BUILD=\n matrix:\n   fast_finish: true\n   include:\n     - compiler: clang\n+      os: linux\n       env: HOST=i686-linux-gnu ENDOMORPHISM=yes\n       addons:\n         apt:\n           packages:\n             - gcc-multilib\n             - libgmp-dev:i386\n+            - valgrind\n+            - libtool-bin\n+            - libc6-dbg:i386\n     - compiler: clang\n       env: HOST=i686-linux-gnu\n+      os: linux\n       addons:\n         apt:\n           packages:\n             - gcc-multilib\n+            - valgrind\n+            - libtool-bin\n+            - libc6-dbg:i386\n     - compiler: gcc\n       env: HOST=i686-linux-gnu ENDOMORPHISM=yes\n+      os: linux\n       addons:\n         apt:\n           packages:\n             - gcc-multilib\n+            - valgrind\n+            - libtool-bin\n+            - libc6-dbg:i386\n     - compiler: gcc\n+      os: linux\n       env: HOST=i686-linux-gnu\n       addons:\n         apt:\n           packages:\n             - gcc-multilib\n             - libgmp-dev:i386\n-before_install: mkdir -p `dirname $GUAVA_JAR`\n-install: if [ ! -f $GUAVA_JAR ]; then wget $GUAVA_URL -O $GUAVA_JAR; fi\n+            - valgrind\n+            - libtool-bin\n+            - libc6-dbg:i386\n+\n+# We use this to install macOS dependencies instead of the built in `homebrew` plugin,\n+# because in xcode earlier than 11 they have a bug requiring updating the system which overall takes ~8 minutes.\n+# https://travis-ci.community/t/macos-build-fails-because-of-homebrew-bundle-unknown-command/7296\n+before_install:\n+ - if [ \"${TRAVIS_OS_NAME}\" = \"osx\" ]; then HOMEBREW_NO_AUTO_UPDATE=1 brew install gmp valgrind gcc@9; fi\n+\n before_script: ./autogen.sh\n+\n+# travis auto terminates jobs that go for 10 minutes without printing to stdout, but travis_wait doesn't work well with forking programs like valgrind (https://docs.travis-ci.com/user/common-build-problems/#build-times-out-because-no-output-was-received https://github.com/bitcoin-core/secp256k1/pull/750#issuecomment-623476860)\n script:\n- - if [ -n \"$HOST\" ]; then export USE_HOST=\"--host=$HOST\"; fi\n- - if [ \"x$HOST\" = \"xi686-linux-gnu\" ]; then export CC=\"$CC -m32\"; fi\n- - ./configure --enable-experimental=$EXPERIMENTAL --enable-endomorphism=$ENDOMORPHISM --with-field=$FIELD --with-bignum=$BIGNUM --with-scalar=$SCALAR --enable-ecmult-static-precomputation=$STATICPRECOMPUTATION --enable-module-ecdh=$ECDH --enable-module-recovery=$RECOVERY --enable-jni=$JNI $EXTRAFLAGS $USE_HOST && make -j2 $BUILD\n+  - function keep_alive() { while true; do echo -en \"\\a\"; sleep 60; done }\n+  - keep_alive &\n+  - ./contrib/travis.sh\n+  - kill %keep_alive\n+\n+after_script:\n+    - cat ./tests.log\n+    - cat ./exhaustive_tests.log\n+    - cat ./valgrind_ctime_test.log\n+    - cat ./bench.log\n+    - $CC --version\n+    - valgrind --version"
      },
      {
        "sha": "d8c1c79e8cba096b83a9362ce8e62ed04e9a8ad2",
        "filename": "src/secp256k1/Makefile.am",
        "status": "modified",
        "additions": 17,
        "deletions": 45,
        "changes": 62,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/Makefile.am?ref=8903a1a0a78a705402123d2a5c465217cb9d791c",
        "patch": "@@ -1,13 +1,8 @@\n ACLOCAL_AMFLAGS = -I build-aux/m4\n \n lib_LTLIBRARIES = libsecp256k1.la\n-if USE_JNI\n-JNI_LIB = libsecp256k1_jni.la\n-noinst_LTLIBRARIES = $(JNI_LIB)\n-else\n-JNI_LIB =\n-endif\n include_HEADERS = include/secp256k1.h\n+include_HEADERS += include/secp256k1_preallocated.h\n noinst_HEADERS =\n noinst_HEADERS += src/scalar.h\n noinst_HEADERS += src/scalar_4x64.h\n@@ -39,8 +34,6 @@ noinst_HEADERS += src/field_5x52.h\n noinst_HEADERS += src/field_5x52_impl.h\n noinst_HEADERS += src/field_5x52_int128_impl.h\n noinst_HEADERS += src/field_5x52_asm_impl.h\n-noinst_HEADERS += src/java/org_bitcoin_NativeSecp256k1.h\n-noinst_HEADERS += src/java/org_bitcoin_Secp256k1Context.h\n noinst_HEADERS += src/util.h\n noinst_HEADERS += src/scratch.h\n noinst_HEADERS += src/scratch_impl.h\n@@ -74,16 +67,19 @@ endif\n \n libsecp256k1_la_SOURCES = src/secp256k1.c\n libsecp256k1_la_CPPFLAGS = -DSECP256K1_BUILD -I$(top_srcdir)/include -I$(top_srcdir)/src $(SECP_INCLUDES)\n-libsecp256k1_la_LIBADD = $(JNI_LIB) $(SECP_LIBS) $(COMMON_LIB)\n+libsecp256k1_la_LIBADD = $(SECP_LIBS) $(COMMON_LIB)\n \n-libsecp256k1_jni_la_SOURCES  = src/java/org_bitcoin_NativeSecp256k1.c src/java/org_bitcoin_Secp256k1Context.c\n-libsecp256k1_jni_la_CPPFLAGS = -DSECP256K1_BUILD $(JNI_INCLUDES)\n+if VALGRIND_ENABLED\n+libsecp256k1_la_CPPFLAGS += -DVALGRIND\n+endif\n \n noinst_PROGRAMS =\n if USE_BENCHMARK\n noinst_PROGRAMS += bench_verify bench_sign bench_internal bench_ecmult\n bench_verify_SOURCES = src/bench_verify.c\n bench_verify_LDADD = libsecp256k1.la $(SECP_LIBS) $(SECP_TEST_LIBS) $(COMMON_LIB)\n+# SECP_TEST_INCLUDES are only used here for CRYPTO_CPPFLAGS\n+bench_verify_CPPFLAGS = -DSECP256K1_BUILD $(SECP_TEST_INCLUDES)\n bench_sign_SOURCES = src/bench_sign.c\n bench_sign_LDADD = libsecp256k1.la $(SECP_LIBS) $(SECP_TEST_LIBS) $(COMMON_LIB)\n bench_internal_SOURCES = src/bench_internal.c\n@@ -99,6 +95,12 @@ if USE_TESTS\n noinst_PROGRAMS += tests\n tests_SOURCES = src/tests.c\n tests_CPPFLAGS = -DSECP256K1_BUILD -I$(top_srcdir)/src -I$(top_srcdir)/include $(SECP_INCLUDES) $(SECP_TEST_INCLUDES)\n+if VALGRIND_ENABLED\n+tests_CPPFLAGS += -DVALGRIND\n+noinst_PROGRAMS += valgrind_ctime_test\n+valgrind_ctime_test_SOURCES = src/valgrind_ctime_test.c\n+valgrind_ctime_test_LDADD = libsecp256k1.la $(SECP_LIBS) $(SECP_TEST_LIBS) $(COMMON_LIB)\n+endif\n if !ENABLE_COVERAGE\n tests_CPPFLAGS += -DVERIFY\n endif\n@@ -119,42 +121,12 @@ exhaustive_tests_LDFLAGS = -static\n TESTS += exhaustive_tests\n endif\n \n-JAVAROOT=src/java\n-JAVAORG=org/bitcoin\n-JAVA_GUAVA=$(srcdir)/$(JAVAROOT)/guava/guava-18.0.jar\n-CLASSPATH_ENV=CLASSPATH=$(JAVA_GUAVA)\n-JAVA_FILES= \\\n-  $(JAVAROOT)/$(JAVAORG)/NativeSecp256k1.java \\\n-  $(JAVAROOT)/$(JAVAORG)/NativeSecp256k1Test.java \\\n-  $(JAVAROOT)/$(JAVAORG)/NativeSecp256k1Util.java \\\n-  $(JAVAROOT)/$(JAVAORG)/Secp256k1Context.java\n-\n-if USE_JNI\n-\n-$(JAVA_GUAVA):\n-\t@echo Guava is missing. Fetch it via: \\\n-\twget https://search.maven.org/remotecontent?filepath=com/google/guava/guava/18.0/guava-18.0.jar -O $(@)\n-\t@false\n-\n-.stamp-java: $(JAVA_FILES)\n-\t@echo   Compiling $^\n-\t$(AM_V_at)$(CLASSPATH_ENV) javac $^\n-\t@touch $@\n-\n-if USE_TESTS\n-\n-check-java: libsecp256k1.la $(JAVA_GUAVA) .stamp-java\n-\t$(AM_V_at)java -Djava.library.path=\"./:./src:./src/.libs:.libs/\" -cp \"$(JAVA_GUAVA):$(JAVAROOT)\" $(JAVAORG)/NativeSecp256k1Test\n-\n-endif\n-endif\n-\n if USE_ECMULT_STATIC_PRECOMPUTATION\n-CPPFLAGS_FOR_BUILD +=-I$(top_srcdir)\n+CPPFLAGS_FOR_BUILD +=-I$(top_srcdir) -I$(builddir)/src\n \n gen_context_OBJECTS = gen_context.o\n gen_context_BIN = gen_context$(BUILD_EXEEXT)\n-gen_%.o: src/gen_%.c\n+gen_%.o: src/gen_%.c src/libsecp256k1-config.h\n \t$(CC_FOR_BUILD) $(CPPFLAGS_FOR_BUILD) $(CFLAGS_FOR_BUILD) -c $< -o $@\n \n $(gen_context_BIN): $(gen_context_OBJECTS)\n@@ -168,10 +140,10 @@ $(bench_ecmult_OBJECTS): src/ecmult_static_context.h\n src/ecmult_static_context.h: $(gen_context_BIN)\n \t./$(gen_context_BIN)\n \n-CLEANFILES = $(gen_context_BIN) src/ecmult_static_context.h $(JAVAROOT)/$(JAVAORG)/*.class .stamp-java\n+CLEANFILES = $(gen_context_BIN) src/ecmult_static_context.h\n endif\n \n-EXTRA_DIST = autogen.sh src/gen_context.c src/basic-config.h $(JAVA_FILES)\n+EXTRA_DIST = autogen.sh src/gen_context.c src/basic-config.h\n \n if ENABLE_MODULE_ECDH\n include src/modules/ecdh/Makefile.am.include"
      },
      {
        "sha": "434178b372839b56a3b4b0dee2568ea57c05142c",
        "filename": "src/secp256k1/README.md",
        "status": "modified",
        "additions": 54,
        "deletions": 11,
        "changes": 65,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/README.md?ref=8903a1a0a78a705402123d2a5c465217cb9d791c",
        "patch": "@@ -3,17 +3,22 @@ libsecp256k1\n \n [![Build Status](https://travis-ci.org/bitcoin-core/secp256k1.svg?branch=master)](https://travis-ci.org/bitcoin-core/secp256k1)\n \n-Optimized C library for EC operations on curve secp256k1.\n+Optimized C library for ECDSA signatures and secret/public key operations on curve secp256k1.\n \n-This library is a work in progress and is being used to research best practices. Use at your own risk.\n+This library is intended to be the highest quality publicly available library for cryptography on the secp256k1 curve. However, the primary focus of its development has been for usage in the Bitcoin system and usage unlike Bitcoin's may be less well tested, verified, or suffer from a less well thought out interface. Correct usage requires some care and consideration that the library is fit for your application's purpose.\n \n Features:\n * secp256k1 ECDSA signing/verification and key generation.\n-* Adding/multiplying private/public keys.\n-* Serialization/parsing of private keys, public keys, signatures.\n-* Constant time, constant memory access signing and pubkey generation.\n-* Derandomized DSA (via RFC6979 or with a caller provided function.)\n+* Additive and multiplicative tweaking of secret/public keys.\n+* Serialization/parsing of secret keys, public keys, signatures.\n+* Constant time, constant memory access signing and public key generation.\n+* Derandomized ECDSA (via RFC6979 or with a caller provided function.)\n * Very efficient implementation.\n+* Suitable for embedded systems.\n+* Optional module for public key recovery.\n+* Optional module for ECDH key exchange (experimental).\n+\n+Experimental features have not received enough scrutiny to satisfy the standard of quality of this library but are made available for testing and review by the community. The APIs of these features should not be considered stable.\n \n Implementation details\n ----------------------\n@@ -23,11 +28,12 @@ Implementation details\n   * Extensive testing infrastructure.\n   * Structured to facilitate review and analysis.\n   * Intended to be portable to any system with a C89 compiler and uint64_t support.\n+  * No use of floating types.\n   * Expose only higher level interfaces to minimize the API surface and improve application security. (\"Be difficult to use insecurely.\")\n * Field operations\n   * Optimized implementation of arithmetic modulo the curve's field size (2^256 - 0x1000003D1).\n     * Using 5 52-bit limbs (including hand-optimized assembly for x86_64, by Diederik Huys).\n-    * Using 10 26-bit limbs.\n+    * Using 10 26-bit limbs (including hand-optimized assembly for 32-bit ARM, by Wladimir J. van der Laan).\n   * Field inverses and square roots using a sliding window over blocks of 1s (by Peter Dettman).\n * Scalar operations\n   * Optimized implementation without data-dependent branches of arithmetic modulo the curve's order.\n@@ -45,9 +51,11 @@ Implementation details\n   * Optionally (off by default) use secp256k1's efficiently-computable endomorphism to split the P multiplicand into 2 half-sized ones.\n * Point multiplication for signing\n   * Use a precomputed table of multiples of powers of 16 multiplied with the generator, so general multiplication becomes a series of additions.\n-  * Access the table with branch-free conditional moves so memory access is uniform.\n-  * No data-dependent branches\n-  * The precomputed tables add and eventually subtract points for which no known scalar (private key) is known, preventing even an attacker with control over the private key used to control the data internally.\n+  * Intended to be completely free of timing sidechannels for secret-key operations (on reasonable hardware/toolchains)\n+    * Access the table with branch-free conditional moves so memory access is uniform.\n+    * No data-dependent branches\n+  * Optional runtime blinding which attempts to frustrate differential power analysis.\n+  * The precomputed tables add and eventually subtract points for which no known scalar (secret key) is known, preventing even an attacker with control over the secret key used to control the data internally.\n \n Build steps\n -----------\n@@ -57,5 +65,40 @@ libsecp256k1 is built using autotools:\n     $ ./autogen.sh\n     $ ./configure\n     $ make\n-    $ ./tests\n+    $ make check\n     $ sudo make install  # optional\n+\n+Exhaustive tests\n+-----------\n+\n+    $ ./exhaustive_tests\n+\n+With valgrind, you might need to increase the max stack size:\n+\n+    $ valgrind --max-stackframe=2500000 ./exhaustive_tests\n+\n+Test coverage\n+-----------\n+\n+This library aims to have full coverage of the reachable lines and branches.\n+\n+To create a test coverage report, configure with `--enable-coverage` (use of GCC is necessary):\n+\n+    $ ./configure --enable-coverage\n+\n+Run the tests:\n+\n+    $ make check\n+\n+To create a report, `gcovr` is recommended, as it includes branch coverage reporting:\n+\n+    $ gcovr --exclude 'src/bench*' --print-summary\n+\n+To create a HTML report with coloured and annotated source code:\n+\n+    $ gcovr --exclude 'src/bench*' --html --html-details -o coverage.html\n+\n+Reporting a vulnerability\n+------------\n+\n+See [SECURITY.md](SECURITY.md)"
      },
      {
        "sha": "0e4d588030274e4a31c773e74dc196637f612259",
        "filename": "src/secp256k1/SECURITY.md",
        "status": "added",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/SECURITY.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/SECURITY.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/SECURITY.md?ref=8903a1a0a78a705402123d2a5c465217cb9d791c",
        "patch": "@@ -0,0 +1,15 @@\n+# Security Policy\n+\n+## Reporting a Vulnerability\n+\n+To report security issues send an email to secp256k1-security@bitcoincore.org (not for support).\n+\n+The following keys may be used to communicate sensitive information to developers:\n+\n+| Name | Fingerprint |\n+|------|-------------|\n+| Pieter Wuille | 133E AC17 9436 F14A 5CF1  B794 860F EB80 4E66 9320 |\n+| Andrew Poelstra | 699A 63EF C17A D3A9 A34C  FFC0 7AD0 A91C 40BD 0091 |\n+| Tim Ruffing | 09E0 3F87 1092 E40E 106E  902B 33BC 86AB 80FF 5516 |\n+\n+You can import a key by running the following command with that individual\u2019s fingerprint: `gpg --recv-keys \"<fingerprint>\"` Ensure that you put quotes around fingerprints containing spaces."
      },
      {
        "sha": "cdc78d87d48b09d45830e47a70f59219c3fee2ce",
        "filename": "src/secp256k1/build-aux/m4/ax_jni_include_dir.m4",
        "status": "removed",
        "additions": 0,
        "deletions": 145,
        "changes": 145,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9ad6f14175c19b5d47267c3dd5840c14bad43c83/src/secp256k1/build-aux/m4/ax_jni_include_dir.m4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9ad6f14175c19b5d47267c3dd5840c14bad43c83/src/secp256k1/build-aux/m4/ax_jni_include_dir.m4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/build-aux/m4/ax_jni_include_dir.m4?ref=9ad6f14175c19b5d47267c3dd5840c14bad43c83",
        "patch": "@@ -1,145 +0,0 @@\n-# ===========================================================================\n-#    https://www.gnu.org/software/autoconf-archive/ax_jni_include_dir.html\n-# ===========================================================================\n-#\n-# SYNOPSIS\n-#\n-#   AX_JNI_INCLUDE_DIR\n-#\n-# DESCRIPTION\n-#\n-#   AX_JNI_INCLUDE_DIR finds include directories needed for compiling\n-#   programs using the JNI interface.\n-#\n-#   JNI include directories are usually in the Java distribution. This is\n-#   deduced from the value of $JAVA_HOME, $JAVAC, or the path to \"javac\", in\n-#   that order. When this macro completes, a list of directories is left in\n-#   the variable JNI_INCLUDE_DIRS.\n-#\n-#   Example usage follows:\n-#\n-#     AX_JNI_INCLUDE_DIR\n-#\n-#     for JNI_INCLUDE_DIR in $JNI_INCLUDE_DIRS\n-#     do\n-#             CPPFLAGS=\"$CPPFLAGS -I$JNI_INCLUDE_DIR\"\n-#     done\n-#\n-#   If you want to force a specific compiler:\n-#\n-#   - at the configure.in level, set JAVAC=yourcompiler before calling\n-#   AX_JNI_INCLUDE_DIR\n-#\n-#   - at the configure level, setenv JAVAC\n-#\n-#   Note: This macro can work with the autoconf M4 macros for Java programs.\n-#   This particular macro is not part of the original set of macros.\n-#\n-# LICENSE\n-#\n-#   Copyright (c) 2008 Don Anderson <dda@sleepycat.com>\n-#\n-#   Copying and distribution of this file, with or without modification, are\n-#   permitted in any medium without royalty provided the copyright notice\n-#   and this notice are preserved. This file is offered as-is, without any\n-#   warranty.\n-\n-#serial 14\n-\n-AU_ALIAS([AC_JNI_INCLUDE_DIR], [AX_JNI_INCLUDE_DIR])\n-AC_DEFUN([AX_JNI_INCLUDE_DIR],[\n-\n-JNI_INCLUDE_DIRS=\"\"\n-\n-if test \"x$JAVA_HOME\" != x; then\n-\t_JTOPDIR=\"$JAVA_HOME\"\n-else\n-\tif test \"x$JAVAC\" = x; then\n-\t\tJAVAC=javac\n-\tfi\n-\tAC_PATH_PROG([_ACJNI_JAVAC], [$JAVAC], [no])\n-\tif test \"x$_ACJNI_JAVAC\" = xno; then\n-\t\tAC_MSG_WARN([cannot find JDK; try setting \\$JAVAC or \\$JAVA_HOME])\n-\tfi\n-\t_ACJNI_FOLLOW_SYMLINKS(\"$_ACJNI_JAVAC\")\n-\t_JTOPDIR=`echo \"$_ACJNI_FOLLOWED\" | sed -e 's://*:/:g' -e 's:/[[^/]]*$::'`\n-fi\n-\n-case \"$host_os\" in\n-        darwin*)        # Apple Java headers are inside the Xcode bundle.\n-            macos_version=$(sw_vers -productVersion | sed -n -e 's/^@<:@0-9@:>@*.\\(@<:@0-9@:>@*\\).@<:@0-9@:>@*/\\1/p')\n-            if @<:@ \"$macos_version\" -gt \"7\" @:>@; then\n-                _JTOPDIR=\"$(xcrun --show-sdk-path)/System/Library/Frameworks/JavaVM.framework\"\n-                _JINC=\"$_JTOPDIR/Headers\"\n-            else\n-                _JTOPDIR=\"/System/Library/Frameworks/JavaVM.framework\"\n-                _JINC=\"$_JTOPDIR/Headers\"\n-            fi\n-            ;;\n-        *) _JINC=\"$_JTOPDIR/include\";;\n-esac\n-_AS_ECHO_LOG([_JTOPDIR=$_JTOPDIR])\n-_AS_ECHO_LOG([_JINC=$_JINC])\n-\n-# On Mac OS X 10.6.4, jni.h is a symlink:\n-# /System/Library/Frameworks/JavaVM.framework/Versions/Current/Headers/jni.h\n-# -> ../../CurrentJDK/Headers/jni.h.\n-AC_CACHE_CHECK(jni headers, ac_cv_jni_header_path,\n-[\n-  if test -f \"$_JINC/jni.h\"; then\n-    ac_cv_jni_header_path=\"$_JINC\"\n-    JNI_INCLUDE_DIRS=\"$JNI_INCLUDE_DIRS $ac_cv_jni_header_path\"\n-  else\n-    _JTOPDIR=`echo \"$_JTOPDIR\" | sed -e 's:/[[^/]]*$::'`\n-    if test -f \"$_JTOPDIR/include/jni.h\"; then\n-      ac_cv_jni_header_path=\"$_JTOPDIR/include\"\n-      JNI_INCLUDE_DIRS=\"$JNI_INCLUDE_DIRS $ac_cv_jni_header_path\"\n-    else\n-      ac_cv_jni_header_path=none\n-    fi\n-  fi\n-])\n-\n-# get the likely subdirectories for system specific java includes\n-case \"$host_os\" in\n-bsdi*)          _JNI_INC_SUBDIRS=\"bsdos\";;\n-freebsd*)       _JNI_INC_SUBDIRS=\"freebsd\";;\n-darwin*)        _JNI_INC_SUBDIRS=\"darwin\";;\n-linux*)         _JNI_INC_SUBDIRS=\"linux genunix\";;\n-osf*)           _JNI_INC_SUBDIRS=\"alpha\";;\n-solaris*)       _JNI_INC_SUBDIRS=\"solaris\";;\n-mingw*)\t\t_JNI_INC_SUBDIRS=\"win32\";;\n-cygwin*)\t_JNI_INC_SUBDIRS=\"win32\";;\n-*)              _JNI_INC_SUBDIRS=\"genunix\";;\n-esac\n-\n-if test \"x$ac_cv_jni_header_path\" != \"xnone\"; then\n-  # add any subdirectories that are present\n-  for JINCSUBDIR in $_JNI_INC_SUBDIRS\n-  do\n-    if test -d \"$_JTOPDIR/include/$JINCSUBDIR\"; then\n-         JNI_INCLUDE_DIRS=\"$JNI_INCLUDE_DIRS $_JTOPDIR/include/$JINCSUBDIR\"\n-    fi\n-  done\n-fi\n-])\n-\n-# _ACJNI_FOLLOW_SYMLINKS <path>\n-# Follows symbolic links on <path>,\n-# finally setting variable _ACJNI_FOLLOWED\n-# ----------------------------------------\n-AC_DEFUN([_ACJNI_FOLLOW_SYMLINKS],[\n-# find the include directory relative to the javac executable\n-_cur=\"$1\"\n-while ls -ld \"$_cur\" 2>/dev/null | grep \" -> \" >/dev/null; do\n-        AC_MSG_CHECKING([symlink for $_cur])\n-        _slink=`ls -ld \"$_cur\" | sed 's/.* -> //'`\n-        case \"$_slink\" in\n-        /*) _cur=\"$_slink\";;\n-        # 'X' avoids triggering unwanted echo options.\n-        *) _cur=`echo \"X$_cur\" | sed -e 's/^X//' -e 's:[[^/]]*$::'`\"$_slink\";;\n-        esac\n-        AC_MSG_RESULT([$_cur])\n-done\n-_ACJNI_FOLLOWED=\"$_cur\"\n-])# _ACJNI"
      },
      {
        "sha": "1b2b71e6abaffd62323cf3f6f7ec903af5b82421",
        "filename": "src/secp256k1/build-aux/m4/bitcoin_secp.m4",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/build-aux/m4/bitcoin_secp.m4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/build-aux/m4/bitcoin_secp.m4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/build-aux/m4/bitcoin_secp.m4?ref=8903a1a0a78a705402123d2a5c465217cb9d791c",
        "patch": "@@ -38,6 +38,8 @@ AC_DEFUN([SECP_OPENSSL_CHECK],[\n   fi\n if test x\"$has_libcrypto\" = x\"yes\" && test x\"$has_openssl_ec\" = x; then\n   AC_MSG_CHECKING(for EC functions in libcrypto)\n+  CPPFLAGS_TEMP=\"$CPPFLAGS\"\n+  CPPFLAGS=\"$CRYPTO_CPPFLAGS $CPPFLAGS\"\n   AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n     #include <openssl/ec.h>\n     #include <openssl/ecdsa.h>\n@@ -51,6 +53,7 @@ if test x\"$has_libcrypto\" = x\"yes\" && test x\"$has_openssl_ec\" = x; then\n     ECDSA_SIG_free(sig_openssl);\n   ]])],[has_openssl_ec=yes],[has_openssl_ec=no])\n   AC_MSG_RESULT([$has_openssl_ec])\n+  CPPFLAGS=\"$CPPFLAGS_TEMP\"\n fi\n ])\n "
      },
      {
        "sha": "6021b760b517cfc72899ee8b49f1ecfc88f9f1a8",
        "filename": "src/secp256k1/configure.ac",
        "status": "modified",
        "additions": 114,
        "deletions": 72,
        "changes": 186,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/configure.ac?ref=8903a1a0a78a705402123d2a5c465217cb9d791c",
        "patch": "@@ -7,6 +7,11 @@ AH_TOP([#ifndef LIBSECP256K1_CONFIG_H])\n AH_TOP([#define LIBSECP256K1_CONFIG_H])\n AH_BOTTOM([#endif /*LIBSECP256K1_CONFIG_H*/])\n AM_INIT_AUTOMAKE([foreign subdir-objects])\n+\n+# Set -g if CFLAGS are not already set, which matches the default autoconf\n+# behavior (see PROG_CC in the Autoconf manual) with the exception that we don't\n+# set -O2 here because we set it in any case (see further down).\n+: ${CFLAGS=\"-g\"}\n LT_INIT\n \n dnl make the compilation flags quiet unless V=1 is used\n@@ -19,10 +24,6 @@ AC_PATH_TOOL(RANLIB, ranlib)\n AC_PATH_TOOL(STRIP, strip)\n AX_PROG_CC_FOR_BUILD\n \n-if test \"x$CFLAGS\" = \"x\"; then\n-  CFLAGS=\"-g\"\n-fi\n-\n AM_PROG_CC_C_O\n \n AC_PROG_CC_C89\n@@ -45,6 +46,7 @@ case $host_os in\n          if test x$openssl_prefix != x; then\n            PKG_CONFIG_PATH=\"$openssl_prefix/lib/pkgconfig:$PKG_CONFIG_PATH\"\n            export PKG_CONFIG_PATH\n+           CRYPTO_CPPFLAGS=\"-I$openssl_prefix/include\"\n          fi\n          if test x$gmp_prefix != x; then\n            GMP_CPPFLAGS=\"-I$gmp_prefix/include\"\n@@ -63,11 +65,11 @@ case $host_os in\n    ;;\n esac\n \n-CFLAGS=\"$CFLAGS -W\"\n+CFLAGS=\"-W $CFLAGS\"\n \n warn_CFLAGS=\"-std=c89 -pedantic -Wall -Wextra -Wcast-align -Wnested-externs -Wshadow -Wstrict-prototypes -Wno-unused-function -Wno-long-long -Wno-overlength-strings\"\n saved_CFLAGS=\"$CFLAGS\"\n-CFLAGS=\"$CFLAGS $warn_CFLAGS\"\n+CFLAGS=\"$warn_CFLAGS $CFLAGS\"\n AC_MSG_CHECKING([if ${CC} supports ${warn_CFLAGS}])\n AC_COMPILE_IFELSE([AC_LANG_SOURCE([[char foo;]])],\n     [ AC_MSG_RESULT([yes]) ],\n@@ -76,7 +78,7 @@ AC_COMPILE_IFELSE([AC_LANG_SOURCE([[char foo;]])],\n     ])\n \n saved_CFLAGS=\"$CFLAGS\"\n-CFLAGS=\"$CFLAGS -fvisibility=hidden\"\n+CFLAGS=\"-fvisibility=hidden $CFLAGS\"\n AC_MSG_CHECKING([if ${CC} supports -fvisibility=hidden])\n AC_COMPILE_IFELSE([AC_LANG_SOURCE([[char foo;]])],\n     [ AC_MSG_RESULT([yes]) ],\n@@ -85,42 +87,42 @@ AC_COMPILE_IFELSE([AC_LANG_SOURCE([[char foo;]])],\n     ])\n \n AC_ARG_ENABLE(benchmark,\n-    AS_HELP_STRING([--enable-benchmark],[compile benchmark (default is yes)]),\n+    AS_HELP_STRING([--enable-benchmark],[compile benchmark [default=yes]]),\n     [use_benchmark=$enableval],\n     [use_benchmark=yes])\n \n AC_ARG_ENABLE(coverage,\n-    AS_HELP_STRING([--enable-coverage],[enable compiler flags to support kcov coverage analysis]),\n+    AS_HELP_STRING([--enable-coverage],[enable compiler flags to support kcov coverage analysis [default=no]]),\n     [enable_coverage=$enableval],\n     [enable_coverage=no])\n \n AC_ARG_ENABLE(tests,\n-    AS_HELP_STRING([--enable-tests],[compile tests (default is yes)]),\n+    AS_HELP_STRING([--enable-tests],[compile tests [default=yes]]),\n     [use_tests=$enableval],\n     [use_tests=yes])\n \n AC_ARG_ENABLE(openssl_tests,\n-    AS_HELP_STRING([--enable-openssl-tests],[enable OpenSSL tests, if OpenSSL is available (default is auto)]),\n+    AS_HELP_STRING([--enable-openssl-tests],[enable OpenSSL tests [default=auto]]),\n     [enable_openssl_tests=$enableval],\n     [enable_openssl_tests=auto])\n \n AC_ARG_ENABLE(experimental,\n-    AS_HELP_STRING([--enable-experimental],[allow experimental configure options (default is no)]),\n+    AS_HELP_STRING([--enable-experimental],[allow experimental configure options [default=no]]),\n     [use_experimental=$enableval],\n     [use_experimental=no])\n \n AC_ARG_ENABLE(exhaustive_tests,\n-    AS_HELP_STRING([--enable-exhaustive-tests],[compile exhaustive tests (default is yes)]),\n+    AS_HELP_STRING([--enable-exhaustive-tests],[compile exhaustive tests [default=yes]]),\n     [use_exhaustive_tests=$enableval],\n     [use_exhaustive_tests=yes])\n \n AC_ARG_ENABLE(endomorphism,\n-    AS_HELP_STRING([--enable-endomorphism],[enable endomorphism (default is no)]),\n+    AS_HELP_STRING([--enable-endomorphism],[enable endomorphism [default=no]]),\n     [use_endomorphism=$enableval],\n     [use_endomorphism=no])\n \n AC_ARG_ENABLE(ecmult_static_precomputation,\n-    AS_HELP_STRING([--enable-ecmult-static-precomputation],[enable precomputed ecmult table for signing (default is yes)]),\n+    AS_HELP_STRING([--enable-ecmult-static-precomputation],[enable precomputed ecmult table for signing [default=auto]]),\n     [use_ecmult_static_precomputation=$enableval],\n     [use_ecmult_static_precomputation=auto])\n \n@@ -130,35 +132,55 @@ AC_ARG_ENABLE(module_ecdh,\n     [enable_module_ecdh=no])\n \n AC_ARG_ENABLE(module_recovery,\n-    AS_HELP_STRING([--enable-module-recovery],[enable ECDSA pubkey recovery module (default is no)]),\n+    AS_HELP_STRING([--enable-module-recovery],[enable ECDSA pubkey recovery module [default=no]]),\n     [enable_module_recovery=$enableval],\n     [enable_module_recovery=no])\n \n-AC_ARG_ENABLE(jni,\n-    AS_HELP_STRING([--enable-jni],[enable libsecp256k1_jni (default is no)]),\n-    [use_jni=$enableval],\n-    [use_jni=no])\n+AC_ARG_ENABLE(external_default_callbacks,\n+    AS_HELP_STRING([--enable-external-default-callbacks],[enable external default callback functions [default=no]]),\n+    [use_external_default_callbacks=$enableval],\n+    [use_external_default_callbacks=no])\n \n AC_ARG_WITH([field], [AS_HELP_STRING([--with-field=64bit|32bit|auto],\n-[Specify Field Implementation. Default is auto])],[req_field=$withval], [req_field=auto])\n+[finite field implementation to use [default=auto]])],[req_field=$withval], [req_field=auto])\n \n AC_ARG_WITH([bignum], [AS_HELP_STRING([--with-bignum=gmp|no|auto],\n-[Specify Bignum Implementation. Default is auto])],[req_bignum=$withval], [req_bignum=auto])\n+[bignum implementation to use [default=auto]])],[req_bignum=$withval], [req_bignum=auto])\n \n AC_ARG_WITH([scalar], [AS_HELP_STRING([--with-scalar=64bit|32bit|auto],\n-[Specify scalar implementation. Default is auto])],[req_scalar=$withval], [req_scalar=auto])\n-\n-AC_ARG_WITH([asm], [AS_HELP_STRING([--with-asm=x86_64|arm|no|auto]\n-[Specify assembly optimizations to use. Default is auto (experimental: arm)])],[req_asm=$withval], [req_asm=auto])\n+[scalar implementation to use [default=auto]])],[req_scalar=$withval], [req_scalar=auto])\n+\n+AC_ARG_WITH([asm], [AS_HELP_STRING([--with-asm=x86_64|arm|no|auto],\n+[assembly optimizations to use\u00a0(experimental: arm) [default=auto]])],[req_asm=$withval], [req_asm=auto])\n+\n+AC_ARG_WITH([ecmult-window], [AS_HELP_STRING([--with-ecmult-window=SIZE|auto],\n+[window size for ecmult precomputation for verification, specified as integer in range [2..24].]\n+[Larger values result in possibly better performance at the cost of an exponentially larger precomputed table.]\n+[The table will store 2^(SIZE-2) * 64 bytes of data but can be larger in memory due to platform-specific padding and alignment.]\n+[If the endomorphism optimization is enabled, two tables of this size are used instead of only one.]\n+[\"auto\" is a reasonable setting for desktop machines (currently 15). [default=auto]]\n+)],\n+[req_ecmult_window=$withval], [req_ecmult_window=auto])\n+\n+AC_ARG_WITH([ecmult-gen-precision], [AS_HELP_STRING([--with-ecmult-gen-precision=2|4|8|auto],\n+[Precision bits to tune the precomputed table size for signing.]\n+[The size of the table is 32kB for 2 bits, 64kB for 4 bits, 512kB for 8 bits of precision.]\n+[A larger table size usually results in possible faster signing.]\n+[\"auto\" is a reasonable setting for desktop machines (currently 4). [default=auto]]\n+)],\n+[req_ecmult_gen_precision=$withval], [req_ecmult_gen_precision=auto])\n \n AC_CHECK_TYPES([__int128])\n \n+AC_CHECK_HEADER([valgrind/memcheck.h], [enable_valgrind=yes], [enable_valgrind=no], [])\n+AM_CONDITIONAL([VALGRIND_ENABLED],[test \"$enable_valgrind\" = \"yes\"])\n+\n if test x\"$enable_coverage\" = x\"yes\"; then\n     AC_DEFINE(COVERAGE, 1, [Define this symbol to compile out all VERIFY code])\n-    CFLAGS=\"$CFLAGS -O0 --coverage\"\n-    LDFLAGS=\"--coverage\"\n+    CFLAGS=\"-O0 --coverage $CFLAGS\"\n+    LDFLAGS=\"--coverage $LDFLAGS\"\n else\n-    CFLAGS=\"$CFLAGS -O3\"\n+    CFLAGS=\"-O2 $CFLAGS\"\n fi\n \n if test x\"$use_ecmult_static_precomputation\" != x\"no\"; then\n@@ -176,7 +198,7 @@ if test x\"$use_ecmult_static_precomputation\" != x\"no\"; then\n \n   warn_CFLAGS_FOR_BUILD=\"-Wall -Wextra -Wno-unused-function\"\n   saved_CFLAGS=\"$CFLAGS\"\n-  CFLAGS=\"$CFLAGS $warn_CFLAGS_FOR_BUILD\"\n+  CFLAGS=\"$warn_CFLAGS_FOR_BUILD $CFLAGS\"\n   AC_MSG_CHECKING([if native ${CC_FOR_BUILD} supports ${warn_CFLAGS_FOR_BUILD}])\n   AC_COMPILE_IFELSE([AC_LANG_SOURCE([[char foo;]])],\n       [ AC_MSG_RESULT([yes]) ],\n@@ -188,7 +210,7 @@ if test x\"$use_ecmult_static_precomputation\" != x\"no\"; then\n   AC_RUN_IFELSE(\n     [AC_LANG_PROGRAM([], [])],\n     [working_native_cc=yes],\n-    [working_native_cc=no],[dnl])\n+    [working_native_cc=no],[:])\n \n   CFLAGS_FOR_BUILD=\"$CFLAGS\"\n \n@@ -387,12 +409,50 @@ case $set_scalar in\n   ;;\n esac\n \n+#set ecmult window size\n+if test x\"$req_ecmult_window\" = x\"auto\"; then\n+  set_ecmult_window=15\n+else\n+  set_ecmult_window=$req_ecmult_window\n+fi\n+\n+error_window_size=['window size for ecmult precomputation not an integer in range [2..24] or \"auto\"']\n+case $set_ecmult_window in\n+''|*[[!0-9]]*)\n+  # no valid integer\n+  AC_MSG_ERROR($error_window_size)\n+  ;;\n+*)\n+  if test \"$set_ecmult_window\" -lt 2 -o \"$set_ecmult_window\" -gt 24 ; then\n+    # not in range\n+    AC_MSG_ERROR($error_window_size)\n+  fi\n+  AC_DEFINE_UNQUOTED(ECMULT_WINDOW_SIZE, $set_ecmult_window, [Set window size for ecmult precomputation])\n+  ;;\n+esac\n+\n+#set ecmult gen precision\n+if test x\"$req_ecmult_gen_precision\" = x\"auto\"; then\n+  set_ecmult_gen_precision=4\n+else\n+  set_ecmult_gen_precision=$req_ecmult_gen_precision\n+fi\n+\n+case $set_ecmult_gen_precision in\n+2|4|8)\n+  AC_DEFINE_UNQUOTED(ECMULT_GEN_PREC_BITS, $set_ecmult_gen_precision, [Set ecmult gen precision bits])\n+  ;;\n+*)\n+  AC_MSG_ERROR(['ecmult gen precision not 2, 4, 8 or \"auto\"'])\n+  ;;\n+esac\n+\n if test x\"$use_tests\" = x\"yes\"; then\n   SECP_OPENSSL_CHECK\n   if test x\"$has_openssl_ec\" = x\"yes\"; then\n     if test x\"$enable_openssl_tests\" != x\"no\"; then\n       AC_DEFINE(ENABLE_OPENSSL_TESTS, 1, [Define this symbol if OpenSSL EC functions are available])\n-      SECP_TEST_INCLUDES=\"$SSL_CFLAGS $CRYPTO_CFLAGS\"\n+      SECP_TEST_INCLUDES=\"$SSL_CFLAGS $CRYPTO_CFLAGS $CRYPTO_CPPFLAGS\"\n       SECP_TEST_LIBS=\"$CRYPTO_LIBS\"\n \n       case $host in\n@@ -412,29 +472,6 @@ else\n   fi\n fi\n \n-if test x\"$use_jni\" != x\"no\"; then\n-  AX_JNI_INCLUDE_DIR\n-  have_jni_dependencies=yes\n-  if test x\"$enable_module_ecdh\" = x\"no\"; then\n-    have_jni_dependencies=no\n-  fi\n-  if test \"x$JNI_INCLUDE_DIRS\" = \"x\"; then\n-    have_jni_dependencies=no\n-  fi\n-  if test \"x$have_jni_dependencies\" = \"xno\"; then\n-    if test x\"$use_jni\" = x\"yes\"; then\n-      AC_MSG_ERROR([jni support explicitly requested but headers/dependencies were not found. Enable ECDH and try again.])\n-    fi\n-    AC_MSG_WARN([jni headers/dependencies not found. jni support disabled])\n-    use_jni=no\n-  else\n-    use_jni=yes\n-    for JNI_INCLUDE_DIR in $JNI_INCLUDE_DIRS; do\n-      JNI_INCLUDES=\"$JNI_INCLUDES -I$JNI_INCLUDE_DIR\"\n-    done\n-  fi\n-fi\n-\n if test x\"$set_bignum\" = x\"gmp\"; then\n   SECP_LIBS=\"$SECP_LIBS $GMP_LIBS\"\n   SECP_INCLUDES=\"$SECP_INCLUDES $GMP_CPPFLAGS\"\n@@ -462,6 +499,10 @@ if test x\"$use_external_asm\" = x\"yes\"; then\n   AC_DEFINE(USE_EXTERNAL_ASM, 1, [Define this symbol if an external (non-inline) assembly implementation is used])\n fi\n \n+if test x\"$use_external_default_callbacks\" = x\"yes\"; then\n+  AC_DEFINE(USE_EXTERNAL_DEFAULT_CALLBACKS, 1, [Define this symbol if an external implementation of the default callbacks is used])\n+fi\n+\n if test x\"$enable_experimental\" = x\"yes\"; then\n   AC_MSG_NOTICE([******])\n   AC_MSG_NOTICE([WARNING: experimental build])\n@@ -479,7 +520,6 @@ fi\n \n AC_CONFIG_HEADERS([src/libsecp256k1-config.h])\n AC_CONFIG_FILES([Makefile libsecp256k1.pc])\n-AC_SUBST(JNI_INCLUDES)\n AC_SUBST(SECP_INCLUDES)\n AC_SUBST(SECP_LIBS)\n AC_SUBST(SECP_TEST_LIBS)\n@@ -491,7 +531,6 @@ AM_CONDITIONAL([USE_BENCHMARK], [test x\"$use_benchmark\" = x\"yes\"])\n AM_CONDITIONAL([USE_ECMULT_STATIC_PRECOMPUTATION], [test x\"$set_precomp\" = x\"yes\"])\n AM_CONDITIONAL([ENABLE_MODULE_ECDH], [test x\"$enable_module_ecdh\" = x\"yes\"])\n AM_CONDITIONAL([ENABLE_MODULE_RECOVERY], [test x\"$enable_module_recovery\" = x\"yes\"])\n-AM_CONDITIONAL([USE_JNI], [test x\"$use_jni\" = x\"yes\"])\n AM_CONDITIONAL([USE_EXTERNAL_ASM], [test x\"$use_external_asm\" = x\"yes\"])\n AM_CONDITIONAL([USE_ASM_ARM], [test x\"$set_asm\" = x\"arm\"])\n \n@@ -504,21 +543,24 @@ AC_OUTPUT\n \n echo\n echo \"Build Options:\"\n-echo \"  with endomorphism   = $use_endomorphism\"\n-echo \"  with ecmult precomp = $set_precomp\"\n-echo \"  with jni            = $use_jni\"\n-echo \"  with benchmarks     = $use_benchmark\"\n-echo \"  with coverage       = $enable_coverage\"\n-echo \"  module ecdh         = $enable_module_ecdh\"\n-echo \"  module recovery     = $enable_module_recovery\"\n+echo \"  with endomorphism       = $use_endomorphism\"\n+echo \"  with ecmult precomp     = $set_precomp\"\n+echo \"  with external callbacks = $use_external_default_callbacks\"\n+echo \"  with benchmarks         = $use_benchmark\"\n+echo \"  with coverage           = $enable_coverage\"\n+echo \"  module ecdh             = $enable_module_ecdh\"\n+echo \"  module recovery         = $enable_module_recovery\"\n echo\n-echo \"  asm                 = $set_asm\"\n-echo \"  bignum              = $set_bignum\"\n-echo \"  field               = $set_field\"\n-echo \"  scalar              = $set_scalar\"\n+echo \"  asm                     = $set_asm\"\n+echo \"  bignum                  = $set_bignum\"\n+echo \"  field                   = $set_field\"\n+echo \"  scalar                  = $set_scalar\"\n+echo \"  ecmult window size      = $set_ecmult_window\"\n+echo \"  ecmult gen prec. bits   = $set_ecmult_gen_precision\"\n echo\n-echo \"  CC                  = $CC\"\n-echo \"  CFLAGS              = $CFLAGS\"\n-echo \"  CPPFLAGS            = $CPPFLAGS\"\n-echo \"  LDFLAGS             = $LDFLAGS\"\n+echo \"  valgrind                = $enable_valgrind\"\n+echo \"  CC                      = $CC\"\n+echo \"  CFLAGS                  = $CFLAGS\"\n+echo \"  CPPFLAGS                = $CPPFLAGS\"\n+echo \"  LDFLAGS                 = $LDFLAGS\"\n echo"
      },
      {
        "sha": "e177a0562dd2d2525a095c1dc3922b0ad5241ca5",
        "filename": "src/secp256k1/contrib/lax_der_parsing.c",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/contrib/lax_der_parsing.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/contrib/lax_der_parsing.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/contrib/lax_der_parsing.c?ref=8903a1a0a78a705402123d2a5c465217cb9d791c",
        "patch": "@@ -32,7 +32,7 @@ int ecdsa_signature_parse_der_lax(const secp256k1_context* ctx, secp256k1_ecdsa_\n     lenbyte = input[pos++];\n     if (lenbyte & 0x80) {\n         lenbyte -= 0x80;\n-        if (pos + lenbyte > inputlen) {\n+        if (lenbyte > inputlen - pos) {\n             return 0;\n         }\n         pos += lenbyte;\n@@ -51,7 +51,7 @@ int ecdsa_signature_parse_der_lax(const secp256k1_context* ctx, secp256k1_ecdsa_\n     lenbyte = input[pos++];\n     if (lenbyte & 0x80) {\n         lenbyte -= 0x80;\n-        if (pos + lenbyte > inputlen) {\n+        if (lenbyte > inputlen - pos) {\n             return 0;\n         }\n         while (lenbyte > 0 && input[pos] == 0) {\n@@ -89,7 +89,7 @@ int ecdsa_signature_parse_der_lax(const secp256k1_context* ctx, secp256k1_ecdsa_\n     lenbyte = input[pos++];\n     if (lenbyte & 0x80) {\n         lenbyte -= 0x80;\n-        if (pos + lenbyte > inputlen) {\n+        if (lenbyte > inputlen - pos) {\n             return 0;\n         }\n         while (lenbyte > 0 && input[pos] == 0) {"
      },
      {
        "sha": "3909d16a279dcee9d7d1b255f78baf8286b82d82",
        "filename": "src/secp256k1/contrib/travis.sh",
        "status": "added",
        "additions": 65,
        "deletions": 0,
        "changes": 65,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/contrib/travis.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/contrib/travis.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/contrib/travis.sh?ref=8903a1a0a78a705402123d2a5c465217cb9d791c",
        "patch": "@@ -0,0 +1,65 @@\n+#!/bin/sh\n+\n+set -e\n+set -x\n+\n+if [ -n \"$HOST\" ]\n+then\n+    export USE_HOST=\"--host=$HOST\"\n+fi\n+if [ \"$HOST\" = \"i686-linux-gnu\" ]\n+then\n+    export CC=\"$CC -m32\"\n+fi\n+if [ \"$TRAVIS_OS_NAME\" = \"osx\" ] && [ \"$TRAVIS_COMPILER\" = \"gcc\" ]\n+then\n+    export CC=\"gcc-9\"\n+fi\n+\n+./configure \\\n+    --enable-experimental=\"$EXPERIMENTAL\" --enable-endomorphism=\"$ENDOMORPHISM\" \\\n+    --with-field=\"$FIELD\" --with-bignum=\"$BIGNUM\" --with-asm=\"$ASM\" --with-scalar=\"$SCALAR\" \\\n+    --enable-ecmult-static-precomputation=\"$STATICPRECOMPUTATION\" --with-ecmult-gen-precision=\"$ECMULTGENPRECISION\" \\\n+    --enable-module-ecdh=\"$ECDH\" --enable-module-recovery=\"$RECOVERY\" \"$EXTRAFLAGS\" \"$USE_HOST\"\n+\n+if [ -n \"$BUILD\" ]\n+then\n+    make -j2 \"$BUILD\"\n+fi\n+if [ -n \"$VALGRIND\" ]\n+then\n+    make -j2\n+    # the `--error-exitcode` is required to make the test fail if valgrind found errors, otherwise it'll return 0 (http://valgrind.org/docs/manual/manual-core.html)\n+    valgrind --error-exitcode=42 ./tests 16\n+    valgrind --error-exitcode=42 ./exhaustive_tests\n+fi\n+if [ -n \"$BENCH\" ]\n+then\n+    if [ -n \"$VALGRIND\" ]\n+    then\n+        # Using the local `libtool` because on macOS the system's libtool has nothing to do with GNU libtool\n+        EXEC='./libtool --mode=execute valgrind --error-exitcode=42'\n+    else\n+        EXEC=\n+    fi\n+    # This limits the iterations in the benchmarks below to ITER(set in .travis.yml) iterations.\n+    export SECP256K1_BENCH_ITERS=\"$ITERS\"\n+    {\n+        $EXEC ./bench_ecmult\n+        $EXEC ./bench_internal\n+        $EXEC ./bench_sign\n+        $EXEC ./bench_verify\n+    } >> bench.log 2>&1\n+    if [ \"$RECOVERY\" = \"yes\" ]\n+    then\n+        $EXEC ./bench_recover >> bench.log 2>&1\n+    fi\n+    if [ \"$ECDH\" = \"yes\" ]\n+    then\n+        $EXEC ./bench_ecdh >> bench.log 2>&1\n+    fi\n+fi\n+if [ -n \"$CTIMETEST\" ]\n+then\n+    ./libtool --mode=execute valgrind --error-exitcode=42 ./valgrind_ctime_test > valgrind_ctime_test.log 2>&1\n+fi"
      },
      {
        "sha": "2ba2dca388150280773063aa7ed20235ee34d7fa",
        "filename": "src/secp256k1/include/secp256k1.h",
        "status": "modified",
        "additions": 150,
        "deletions": 52,
        "changes": 202,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/include/secp256k1.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/include/secp256k1.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/include/secp256k1.h?ref=8903a1a0a78a705402123d2a5c465217cb9d791c",
        "patch": "@@ -14,7 +14,7 @@ extern \"C\" {\n  * 2. Array lengths always immediately the follow the argument whose length\n  *    they describe, even if this violates rule 1.\n  * 3. Within the OUT/OUTIN/IN groups, pointers to data that is typically generated\n- *    later go first. This means: signatures, public nonces, private nonces,\n+ *    later go first. This means: signatures, public nonces, secret nonces,\n  *    messages, public keys, secret keys, tweaks.\n  * 4. Arguments that are not data pointers go last, from more complex to less\n  *    complex: function pointers, algorithm names, messages, void pointers,\n@@ -33,9 +33,10 @@ extern \"C\" {\n  *  verification).\n  *\n  *  A constructed context can safely be used from multiple threads\n- *  simultaneously, but API call that take a non-const pointer to a context\n+ *  simultaneously, but API calls that take a non-const pointer to a context\n  *  need exclusive access to it. In particular this is the case for\n- *  secp256k1_context_destroy and secp256k1_context_randomize.\n+ *  secp256k1_context_destroy, secp256k1_context_preallocated_destroy,\n+ *  and secp256k1_context_randomize.\n  *\n  *  Regarding randomization, either do it once at creation time (in which case\n  *  you do not need any locking for the other calls), or use a read-write lock.\n@@ -161,14 +162,17 @@ typedef int (*secp256k1_nonce_function)(\n /** The higher bits contain the actual data. Do not use directly. */\n #define SECP256K1_FLAGS_BIT_CONTEXT_VERIFY (1 << 8)\n #define SECP256K1_FLAGS_BIT_CONTEXT_SIGN (1 << 9)\n+#define SECP256K1_FLAGS_BIT_CONTEXT_DECLASSIFY (1 << 10)\n #define SECP256K1_FLAGS_BIT_COMPRESSION (1 << 8)\n \n-/** Flags to pass to secp256k1_context_create. */\n+/** Flags to pass to secp256k1_context_create, secp256k1_context_preallocated_size, and\n+ *  secp256k1_context_preallocated_create. */\n #define SECP256K1_CONTEXT_VERIFY (SECP256K1_FLAGS_TYPE_CONTEXT | SECP256K1_FLAGS_BIT_CONTEXT_VERIFY)\n #define SECP256K1_CONTEXT_SIGN (SECP256K1_FLAGS_TYPE_CONTEXT | SECP256K1_FLAGS_BIT_CONTEXT_SIGN)\n+#define SECP256K1_CONTEXT_DECLASSIFY (SECP256K1_FLAGS_TYPE_CONTEXT | SECP256K1_FLAGS_BIT_CONTEXT_DECLASSIFY)\n #define SECP256K1_CONTEXT_NONE (SECP256K1_FLAGS_TYPE_CONTEXT)\n \n-/** Flag to pass to secp256k1_ec_pubkey_serialize and secp256k1_ec_privkey_export. */\n+/** Flag to pass to secp256k1_ec_pubkey_serialize. */\n #define SECP256K1_EC_COMPRESSED (SECP256K1_FLAGS_TYPE_COMPRESSION | SECP256K1_FLAGS_BIT_COMPRESSION)\n #define SECP256K1_EC_UNCOMPRESSED (SECP256K1_FLAGS_TYPE_COMPRESSION)\n \n@@ -186,7 +190,11 @@ typedef int (*secp256k1_nonce_function)(\n  */\n SECP256K1_API extern const secp256k1_context *secp256k1_context_no_precomp;\n \n-/** Create a secp256k1 context object.\n+/** Create a secp256k1 context object (in dynamically allocated memory).\n+ *\n+ *  This function uses malloc to allocate memory. It is guaranteed that malloc is\n+ *  called at most once for every call of this function. If you need to avoid dynamic\n+ *  memory allocation entirely, see the functions in secp256k1_preallocated.h.\n  *\n  *  Returns: a newly created context object.\n  *  In:      flags: which parts of the context to initialize.\n@@ -197,7 +205,11 @@ SECP256K1_API secp256k1_context* secp256k1_context_create(\n     unsigned int flags\n ) SECP256K1_WARN_UNUSED_RESULT;\n \n-/** Copies a secp256k1 context object.\n+/** Copy a secp256k1 context object (into dynamically allocated memory).\n+ *\n+ *  This function uses malloc to allocate memory. It is guaranteed that malloc is\n+ *  called at most once for every call of this function. If you need to avoid dynamic\n+ *  memory allocation entirely, see the functions in secp256k1_preallocated.h.\n  *\n  *  Returns: a newly created context object.\n  *  Args:    ctx: an existing context to copy (cannot be NULL)\n@@ -206,10 +218,18 @@ SECP256K1_API secp256k1_context* secp256k1_context_clone(\n     const secp256k1_context* ctx\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_WARN_UNUSED_RESULT;\n \n-/** Destroy a secp256k1 context object.\n+/** Destroy a secp256k1 context object (created in dynamically allocated memory).\n  *\n  *  The context pointer may not be used afterwards.\n- *  Args:   ctx: an existing context to destroy (cannot be NULL)\n+ *\n+ *  The context to destroy must have been created using secp256k1_context_create\n+ *  or secp256k1_context_clone. If the context has instead been created using\n+ *  secp256k1_context_preallocated_create or secp256k1_context_preallocated_clone, the\n+ *  behaviour is undefined. In that case, secp256k1_context_preallocated_destroy must\n+ *  be used instead.\n+ *\n+ *  Args:   ctx: an existing context to destroy, constructed using\n+ *               secp256k1_context_create or secp256k1_context_clone\n  */\n SECP256K1_API void secp256k1_context_destroy(\n     secp256k1_context* ctx\n@@ -229,11 +249,28 @@ SECP256K1_API void secp256k1_context_destroy(\n  *  to cause a crash, though its return value and output arguments are\n  *  undefined.\n  *\n+ *  When this function has not been called (or called with fn==NULL), then the\n+ *  default handler will be used.\u00a0The library provides a default handler which\n+ *  writes the message to stderr and calls abort. This default handler can be\n+ *  replaced at link time if the preprocessor macro\n+ *  USE_EXTERNAL_DEFAULT_CALLBACKS is defined, which is the case if the build\n+ *  has been configured with --enable-external-default-callbacks. Then the\n+ *  following two symbols must be provided to link against:\n+ *   - void secp256k1_default_illegal_callback_fn(const char* message, void* data);\n+ *   - void secp256k1_default_error_callback_fn(const char* message, void* data);\n+ *  The library can call these default handlers even before a proper callback data\n+ *  pointer could have been set using secp256k1_context_set_illegal_callback or\n+ *  secp256k1_context_set_error_callback, e.g., when the creation of a context\n+ *  fails. In this case, the corresponding default handler will be called with\n+ *  the data pointer argument set to NULL.\n+ *\n  *  Args: ctx:  an existing context object (cannot be NULL)\n  *  In:   fun:  a pointer to a function to call when an illegal argument is\n- *              passed to the API, taking a message and an opaque pointer\n- *              (NULL restores a default handler that calls abort).\n+ *              passed to the API, taking a message and an opaque pointer.\n+ *              (NULL restores the default handler.)\n  *        data: the opaque pointer to pass to fun above.\n+ *\n+ *  See also secp256k1_context_set_error_callback.\n  */\n SECP256K1_API void secp256k1_context_set_illegal_callback(\n     secp256k1_context* ctx,\n@@ -253,9 +290,12 @@ SECP256K1_API void secp256k1_context_set_illegal_callback(\n  *\n  *  Args: ctx:  an existing context object (cannot be NULL)\n  *  In:   fun:  a pointer to a function to call when an internal error occurs,\n- *              taking a message and an opaque pointer (NULL restores a default\n- *              handler that calls abort).\n+ *              taking a message and an opaque pointer (NULL restores the\n+ *              default handler, see secp256k1_context_set_illegal_callback\n+ *              for details).\n  *        data: the opaque pointer to pass to fun above.\n+ *\n+ *  See also secp256k1_context_set_illegal_callback.\n  */\n SECP256K1_API void secp256k1_context_set_error_callback(\n     secp256k1_context* ctx,\n@@ -267,21 +307,24 @@ SECP256K1_API void secp256k1_context_set_error_callback(\n  *\n  *  Returns: a newly created scratch space.\n  *  Args: ctx:  an existing context object (cannot be NULL)\n- *  In:   max_size: maximum amount of memory to allocate\n+ *  In:   size: amount of memory to be available as scratch space. Some extra\n+ *              (<100 bytes) will be allocated for extra accounting.\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT secp256k1_scratch_space* secp256k1_scratch_space_create(\n     const secp256k1_context* ctx,\n-    size_t max_size\n+    size_t size\n ) SECP256K1_ARG_NONNULL(1);\n \n /** Destroy a secp256k1 scratch space.\n  *\n  *  The pointer may not be used afterwards.\n- *  Args:   scratch: space to destroy\n+ *  Args:       ctx: a secp256k1 context object.\n+ *          scratch: space to destroy\n  */\n SECP256K1_API void secp256k1_scratch_space_destroy(\n+    const secp256k1_context* ctx,\n     secp256k1_scratch_space* scratch\n-);\n+) SECP256K1_ARG_NONNULL(1);\n \n /** Parse a variable-length public key into the pubkey object.\n  *\n@@ -488,7 +531,7 @@ SECP256K1_API extern const secp256k1_nonce_function secp256k1_nonce_function_def\n /** Create an ECDSA signature.\n  *\n  *  Returns: 1: signature created\n- *           0: the nonce generation function failed, or the private key was invalid.\n+ *           0: the nonce generation function failed, or the secret key was invalid.\n  *  Args:    ctx:    pointer to a context object, initialized for signing (cannot be NULL)\n  *  Out:     sig:    pointer to an array where the signature will be placed (cannot be NULL)\n  *  In:      msg32:  the 32-byte message hash being signed (cannot be NULL)\n@@ -509,6 +552,11 @@ SECP256K1_API int secp256k1_ecdsa_sign(\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);\n \n /** Verify an ECDSA secret key.\n+ *\n+ *  A secret key is valid if it is not 0 and less than the secp256k1 curve order\n+ *  when interpreted as an integer (most significant byte first). The\n+ *  probability of choosing a 32-byte string uniformly at random which is an\n+ *  invalid secret key is negligible.\n  *\n  *  Returns: 1: secret key is valid\n  *           0: secret key is invalid\n@@ -526,20 +574,32 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_seckey_verify(\n  *           0: secret was invalid, try again\n  *  Args:   ctx:        pointer to a context object, initialized for signing (cannot be NULL)\n  *  Out:    pubkey:     pointer to the created public key (cannot be NULL)\n- *  In:     seckey:     pointer to a 32-byte private key (cannot be NULL)\n+ *  In:     seckey:     pointer to a 32-byte secret key (cannot be NULL)\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_create(\n     const secp256k1_context* ctx,\n     secp256k1_pubkey *pubkey,\n     const unsigned char *seckey\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n-/** Negates a private key in place.\n+/** Negates a secret key in place.\n  *\n- *  Returns: 1 always\n- *  Args:   ctx:        pointer to a context object\n- *  In/Out: seckey:     pointer to the 32-byte private key to be negated (cannot be NULL)\n+ *  Returns: 0 if the given secret key is invalid according to\n+ *           secp256k1_ec_seckey_verify. 1 otherwise\n+ *  Args:   ctx:    pointer to a context object\n+ *  In/Out: seckey: pointer to the 32-byte secret key to be negated. If the\n+ *                  secret key is invalid according to\n+ *                  secp256k1_ec_seckey_verify, this function returns 0 and\n+ *                  seckey will be set to some unspecified value. (cannot be\n+ *                  NULL)\n  */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_seckey_negate(\n+    const secp256k1_context* ctx,\n+    unsigned char *seckey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2);\n+\n+/** Same as secp256k1_ec_seckey_negate, but DEPRECATED. Will be removed in\n+ *  future versions. */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_privkey_negate(\n     const secp256k1_context* ctx,\n     unsigned char *seckey\n@@ -556,57 +616,93 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_negate(\n     secp256k1_pubkey *pubkey\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2);\n \n-/** Tweak a private key by adding tweak to it.\n- * Returns: 0 if the tweak was out of range (chance of around 1 in 2^128 for\n- *          uniformly random 32-byte arrays, or if the resulting private key\n- *          would be invalid (only when the tweak is the complement of the\n- *          private key). 1 otherwise.\n- * Args:    ctx:    pointer to a context object (cannot be NULL).\n- * In/Out:  seckey: pointer to a 32-byte private key.\n- * In:      tweak:  pointer to a 32-byte tweak.\n- */\n+/** Tweak a secret key by adding tweak to it.\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting secret key would be\n+ *           invalid (only when the tweak is the negation of the secret key). 1\n+ *           otherwise.\n+ *  Args:    ctx:   pointer to a context object (cannot be NULL).\n+ *  In/Out: seckey: pointer to a 32-byte secret key. If the secret key is\n+ *                  invalid according to secp256k1_ec_seckey_verify, this\n+ *                  function returns 0. seckey will be set to some unspecified\n+ *                  value if this function returns 0. (cannot be NULL)\n+ *  In:      tweak: pointer to a 32-byte tweak. If the tweak is invalid according to\n+ *                  secp256k1_ec_seckey_verify, this function returns 0. For\n+ *                  uniformly random 32-byte arrays the chance of being invalid\n+ *                  is negligible (around 1 in 2^128) (cannot be NULL).\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_seckey_tweak_add(\n+    const secp256k1_context* ctx,\n+    unsigned char *seckey,\n+    const unsigned char *tweak\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Same as secp256k1_ec_seckey_tweak_add, but DEPRECATED. Will be removed in\n+ *  future versions. */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_privkey_tweak_add(\n     const secp256k1_context* ctx,\n     unsigned char *seckey,\n     const unsigned char *tweak\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n /** Tweak a public key by adding tweak times the generator to it.\n- * Returns: 0 if the tweak was out of range (chance of around 1 in 2^128 for\n- *          uniformly random 32-byte arrays, or if the resulting public key\n- *          would be invalid (only when the tweak is the complement of the\n- *          corresponding private key). 1 otherwise.\n- * Args:    ctx:    pointer to a context object initialized for validation\n+ *\n+ *  Returns: 0 if the arguments are invalid or the resulting public key would be\n+ *           invalid (only when the tweak is the negation of the corresponding\n+ *           secret key). 1 otherwise.\n+ *  Args:    ctx:   pointer to a context object initialized for validation\n  *                  (cannot be NULL).\n- * In/Out:  pubkey: pointer to a public key object.\n- * In:      tweak:  pointer to a 32-byte tweak.\n+ *  In/Out: pubkey: pointer to a public key object. pubkey will be set to an\n+ *                  invalid value if this function returns 0 (cannot be NULL).\n+ *  In:      tweak: pointer to a 32-byte tweak. If the tweak is invalid according to\n+ *                  secp256k1_ec_seckey_verify, this function returns 0. For\n+ *                  uniformly random 32-byte arrays the chance of being invalid\n+ *                  is negligible (around 1 in 2^128) (cannot be NULL).\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_tweak_add(\n     const secp256k1_context* ctx,\n     secp256k1_pubkey *pubkey,\n     const unsigned char *tweak\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n-/** Tweak a private key by multiplying it by a tweak.\n- * Returns: 0 if the tweak was out of range (chance of around 1 in 2^128 for\n- *          uniformly random 32-byte arrays, or equal to zero. 1 otherwise.\n- * Args:   ctx:    pointer to a context object (cannot be NULL).\n- * In/Out: seckey: pointer to a 32-byte private key.\n- * In:     tweak:  pointer to a 32-byte tweak.\n+/** Tweak a secret key by multiplying it by a tweak.\n+ *\n+ *  Returns: 0 if the arguments are invalid. 1 otherwise.\n+ *  Args:   ctx:    pointer to a context object (cannot be NULL).\n+ *  In/Out: seckey: pointer to a 32-byte secret key. If the secret key is\n+ *                  invalid according to secp256k1_ec_seckey_verify, this\n+ *                  function returns 0. seckey will be set to some unspecified\n+ *                  value if this function returns 0. (cannot be NULL)\n+ *  In:      tweak: pointer to a 32-byte tweak. If the tweak is invalid according to\n+ *                  secp256k1_ec_seckey_verify, this function returns 0. For\n+ *                  uniformly random 32-byte arrays the chance of being invalid\n+ *                  is negligible (around 1 in 2^128) (cannot be NULL).\n  */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_seckey_tweak_mul(\n+    const secp256k1_context* ctx,\n+    unsigned char *seckey,\n+    const unsigned char *tweak\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n+\n+/** Same as secp256k1_ec_seckey_tweak_mul, but DEPRECATED. Will be removed in\n+ *  future versions. */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_privkey_tweak_mul(\n     const secp256k1_context* ctx,\n     unsigned char *seckey,\n     const unsigned char *tweak\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n /** Tweak a public key by multiplying it by a tweak value.\n- * Returns: 0 if the tweak was out of range (chance of around 1 in 2^128 for\n- *          uniformly random 32-byte arrays, or equal to zero. 1 otherwise.\n- * Args:    ctx:    pointer to a context object initialized for validation\n- *                 (cannot be NULL).\n- * In/Out:  pubkey: pointer to a public key obkect.\n- * In:      tweak:  pointer to a 32-byte tweak.\n+ *\n+ *  Returns: 0 if the arguments are invalid. 1 otherwise.\n+ *  Args:    ctx:   pointer to a context object initialized for validation\n+ *                  (cannot be NULL).\n+ *  In/Out: pubkey: pointer to a public key object. pubkey will be set to an\n+ *                  invalid value if this function returns 0 (cannot be NULL).\n+ *  In:      tweak: pointer to a 32-byte tweak. If the tweak is invalid according to\n+ *                  secp256k1_ec_seckey_verify, this function returns 0. For\n+ *                  uniformly random 32-byte arrays the chance of being invalid\n+ *                  is negligible (around 1 in 2^128) (cannot be NULL).\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_tweak_mul(\n     const secp256k1_context* ctx,\n@@ -636,14 +732,16 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_tweak_mul(\n  * contexts not initialized for signing; then it will have no effect and return 1.\n  *\n  * You should call this after secp256k1_context_create or\n- * secp256k1_context_clone, and may call this repeatedly afterwards.\n+ * secp256k1_context_clone (and secp256k1_context_preallocated_create or\n+ * secp256k1_context_clone, resp.), and you may call this repeatedly afterwards.\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_context_randomize(\n     secp256k1_context* ctx,\n     const unsigned char *seed32\n ) SECP256K1_ARG_NONNULL(1);\n \n /** Add a number of public keys together.\n+ *\n  *  Returns: 1: the sum of the public keys is valid.\n  *           0: the sum of the public keys is not valid.\n  *  Args:   ctx:        pointer to a context object"
      },
      {
        "sha": "4058e9c0436dd430f8cbe8c6a8b63be2a8c5dbc1",
        "filename": "src/secp256k1/include/secp256k1_ecdh.h",
        "status": "modified",
        "additions": 22,
        "deletions": 15,
        "changes": 37,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/include/secp256k1_ecdh.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/include/secp256k1_ecdh.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/include/secp256k1_ecdh.h?ref=8903a1a0a78a705402123d2a5c465217cb9d791c",
        "patch": "@@ -7,43 +7,50 @@\n extern \"C\" {\n #endif\n \n-/** A pointer to a function that applies hash function to a point\n+/** A pointer to a function that hashes an EC point to obtain an ECDH secret\n  *\n- *  Returns: 1 if a point was successfully hashed. 0 will cause ecdh to fail\n- *  Out:    output:     pointer to an array to be filled by the function\n- *  In:     x:          pointer to a 32-byte x coordinate\n- *          y:          pointer to a 32-byte y coordinate\n- *          data:       Arbitrary data pointer that is passed through\n+ *  Returns: 1 if the point was successfully hashed.\n+ *           0 will cause secp256k1_ecdh to fail and return 0.\n+ *           Other return values are not allowed, and the behaviour of\n+ *           secp256k1_ecdh is undefined for other return values.\n+ *  Out:     output:     pointer to an array to be filled by the function\n+ *  In:      x32:        pointer to a 32-byte x coordinate\n+ *           y32:        pointer to a 32-byte y coordinate\n+ *           data:       arbitrary data pointer that is passed through\n  */\n typedef int (*secp256k1_ecdh_hash_function)(\n   unsigned char *output,\n-  const unsigned char *x,\n-  const unsigned char *y,\n+  const unsigned char *x32,\n+  const unsigned char *y32,\n   void *data\n );\n \n-/** An implementation of SHA256 hash function that applies to compressed public key. */\n+/** An implementation of SHA256 hash function that applies to compressed public key.\n+ * Populates the output parameter with 32 bytes. */\n SECP256K1_API extern const secp256k1_ecdh_hash_function secp256k1_ecdh_hash_function_sha256;\n \n-/** A default ecdh hash function (currently equal to secp256k1_ecdh_hash_function_sha256). */\n+/** A default ECDH hash function (currently equal to secp256k1_ecdh_hash_function_sha256).\n+ * Populates the output parameter with 32 bytes. */\n SECP256K1_API extern const secp256k1_ecdh_hash_function secp256k1_ecdh_hash_function_default;\n \n /** Compute an EC Diffie-Hellman secret in constant time\n+ *\n  *  Returns: 1: exponentiation was successful\n- *           0: scalar was invalid (zero or overflow)\n+ *           0: scalar was invalid (zero or overflow) or hashfp returned 0\n  *  Args:    ctx:        pointer to a context object (cannot be NULL)\n- *  Out:     output:     pointer to an array to be filled by the function\n+ *  Out:     output:     pointer to an array to be filled by hashfp\n  *  In:      pubkey:     a pointer to a secp256k1_pubkey containing an\n  *                       initialized public key\n- *           privkey:    a 32-byte scalar with which to multiply the point\n+ *           seckey:     a 32-byte scalar with which to multiply the point\n  *           hashfp:     pointer to a hash function. If NULL, secp256k1_ecdh_hash_function_sha256 is used\n- *           data:       Arbitrary data pointer that is passed through\n+ *                       (in which case, 32 bytes will be written to output)\n+ *           data:       arbitrary data pointer that is passed through to hashfp\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ecdh(\n   const secp256k1_context* ctx,\n   unsigned char *output,\n   const secp256k1_pubkey *pubkey,\n-  const unsigned char *privkey,\n+  const unsigned char *seckey,\n   secp256k1_ecdh_hash_function hashfp,\n   void *data\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3) SECP256K1_ARG_NONNULL(4);"
      },
      {
        "sha": "a9ae15d5ae8d80264c5dd1e44b17ccf81a2456a4",
        "filename": "src/secp256k1/include/secp256k1_preallocated.h",
        "status": "added",
        "additions": 128,
        "deletions": 0,
        "changes": 128,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/include/secp256k1_preallocated.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/include/secp256k1_preallocated.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/include/secp256k1_preallocated.h?ref=8903a1a0a78a705402123d2a5c465217cb9d791c",
        "patch": "@@ -0,0 +1,128 @@\n+#ifndef SECP256K1_PREALLOCATED_H\n+#define SECP256K1_PREALLOCATED_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* The module provided by this header file is intended for settings in which it\n+ * is not possible or desirable to rely on dynamic memory allocation. It provides\n+ * functions for creating, cloning, and destroying secp256k1 context objects in a\n+ * contiguous fixed-size block of memory provided by the caller.\n+ *\n+ * Context objects created by functions in this module can be used like contexts\n+ * objects created by functions in secp256k1.h, i.e., they can be passed to any\n+ * API function that expects a context object (see secp256k1.h for details). The\n+ * only exception is that context objects created by functions in this module\n+ * must be destroyed using secp256k1_context_preallocated_destroy (in this\n+ * module) instead of secp256k1_context_destroy (in secp256k1.h).\n+ *\n+ * It is guaranteed that functions in this module will not call malloc or its\n+ * friends realloc, calloc, and free.\n+ */\n+\n+/** Determine the memory size of a secp256k1 context object to be created in\n+ *  caller-provided memory.\n+ *\n+ *  The purpose of this function is to determine how much memory must be provided\n+ *  to secp256k1_context_preallocated_create.\n+ *\n+ *  Returns: the required size of the caller-provided memory block\n+ *  In:      flags:    which parts of the context to initialize.\n+ */\n+SECP256K1_API size_t secp256k1_context_preallocated_size(\n+    unsigned int flags\n+) SECP256K1_WARN_UNUSED_RESULT;\n+\n+/** Create a secp256k1 context object in caller-provided memory.\n+ *\n+ *  The caller must provide a pointer to a rewritable contiguous block of memory\n+ *  of size at least secp256k1_context_preallocated_size(flags) bytes, suitably\n+ *  aligned to hold an object of any type.\n+ *\n+ *  The block of memory is exclusively owned by the created context object during\n+ *  the lifetime of this context object, which begins with the call to this\n+ *  function and ends when a call to secp256k1_context_preallocated_destroy\n+ *  (which destroys the context object again) returns. During the lifetime of the\n+ *  context object, the caller is obligated not to access this block of memory,\n+ *  i.e., the caller may not read or write the memory, e.g., by copying the memory\n+ *  contents to a different location or trying to create a second context object\n+ *  in the memory. In simpler words, the prealloc pointer (or any pointer derived\n+ *  from it) should not be used during the lifetime of the context object.\n+ *\n+ *  Returns: a newly created context object.\n+ *  In:      prealloc: a pointer to a rewritable contiguous block of memory of\n+ *                     size at least secp256k1_context_preallocated_size(flags)\n+ *                     bytes, as detailed above (cannot be NULL)\n+ *           flags:    which parts of the context to initialize.\n+ *\n+ *  See also secp256k1_context_randomize (in secp256k1.h)\n+ *  and secp256k1_context_preallocated_destroy.\n+ */\n+SECP256K1_API secp256k1_context* secp256k1_context_preallocated_create(\n+    void* prealloc,\n+    unsigned int flags\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_WARN_UNUSED_RESULT;\n+\n+/** Determine the memory size of a secp256k1 context object to be copied into\n+ *  caller-provided memory.\n+ *\n+ *  Returns: the required size of the caller-provided memory block.\n+ *  In:      ctx: an existing context to copy (cannot be NULL)\n+ */\n+SECP256K1_API size_t secp256k1_context_preallocated_clone_size(\n+    const secp256k1_context* ctx\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_WARN_UNUSED_RESULT;\n+\n+/** Copy a secp256k1 context object into caller-provided memory.\n+ *\n+ *  The caller must provide a pointer to a rewritable contiguous block of memory\n+ *  of size at least secp256k1_context_preallocated_size(flags) bytes, suitably\n+ *  aligned to hold an object of any type.\n+ *\n+ *  The block of memory is exclusively owned by the created context object during\n+ *  the lifetime of this context object, see the description of\n+ *  secp256k1_context_preallocated_create for details.\n+ *\n+ *  Returns: a newly created context object.\n+ *  Args:    ctx:      an existing context to copy (cannot be NULL)\n+ *  In:      prealloc: a pointer to a rewritable contiguous block of memory of\n+ *                     size at least secp256k1_context_preallocated_size(flags)\n+ *                     bytes, as detailed above (cannot be NULL)\n+ */\n+SECP256K1_API secp256k1_context* secp256k1_context_preallocated_clone(\n+    const secp256k1_context* ctx,\n+    void* prealloc\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_WARN_UNUSED_RESULT;\n+\n+/** Destroy a secp256k1 context object that has been created in\n+ *  caller-provided memory.\n+ *\n+ *  The context pointer may not be used afterwards.\n+ *\n+ *  The context to destroy must have been created using\n+ *  secp256k1_context_preallocated_create or secp256k1_context_preallocated_clone.\n+ *  If the context has instead been created using secp256k1_context_create or\n+ *  secp256k1_context_clone, the behaviour is undefined. In that case,\n+ *  secp256k1_context_destroy must be used instead.\n+ *\n+ *  If required, it is the responsibility of the caller to deallocate the block\n+ *  of memory properly after this function returns, e.g., by calling free on the\n+ *  preallocated pointer given to secp256k1_context_preallocated_create or\n+ *  secp256k1_context_preallocated_clone.\n+ *\n+ *  Args:   ctx: an existing context to destroy, constructed using\n+ *               secp256k1_context_preallocated_create or\n+ *               secp256k1_context_preallocated_clone (cannot be NULL)\n+ */\n+SECP256K1_API void secp256k1_context_preallocated_destroy(\n+    secp256k1_context* ctx\n+);\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif /* SECP256K1_PREALLOCATED_H */"
      },
      {
        "sha": "f8ccaecd3dfb188b8f73b00ea107b911703f6b58",
        "filename": "src/secp256k1/include/secp256k1_recovery.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/include/secp256k1_recovery.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/include/secp256k1_recovery.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/include/secp256k1_recovery.h?ref=8903a1a0a78a705402123d2a5c465217cb9d791c",
        "patch": "@@ -70,7 +70,7 @@ SECP256K1_API int secp256k1_ecdsa_recoverable_signature_serialize_compact(\n /** Create a recoverable ECDSA signature.\n  *\n  *  Returns: 1: signature created\n- *           0: the nonce generation function failed, or the private key was invalid.\n+ *           0: the nonce generation function failed, or the secret key was invalid.\n  *  Args:    ctx:    pointer to a context object, initialized for signing (cannot be NULL)\n  *  Out:     sig:    pointer to an array where the signature will be placed (cannot be NULL)\n  *  In:      msg32:  the 32-byte message hash being signed (cannot be NULL)"
      },
      {
        "sha": "9a5bd06721778da61e34ca16dcc60a10b0d20a36",
        "filename": "src/secp256k1/src/asm/field_10x26_arm.s",
        "status": "modified",
        "additions": 0,
        "deletions": 6,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/asm/field_10x26_arm.s",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/asm/field_10x26_arm.s",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/asm/field_10x26_arm.s?ref=8903a1a0a78a705402123d2a5c465217cb9d791c",
        "patch": "@@ -16,15 +16,9 @@ Note:\n */\n \n \t.syntax unified\n-\t.arch armv7-a\n \t@ eabi attributes - see readelf -A\n-\t.eabi_attribute 8, 1  @ Tag_ARM_ISA_use = yes\n-\t.eabi_attribute 9, 0  @ Tag_Thumb_ISA_use = no\n-\t.eabi_attribute 10, 0 @ Tag_FP_arch = none\n \t.eabi_attribute 24, 1 @ Tag_ABI_align_needed = 8-byte\n \t.eabi_attribute 25, 1 @ Tag_ABI_align_preserved = 8-byte, except leaf SP\n-\t.eabi_attribute 30, 2 @ Tag_ABI_optimization_goals = Aggressive Speed\n-\t.eabi_attribute 34, 1 @ Tag_CPU_unaligned_access = v6\n \t.text\n \n \t@ Field constants"
      },
      {
        "sha": "e9be39d4ca4d4eaacceef15c605a2a3fd8bb2813",
        "filename": "src/secp256k1/src/basic-config.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/basic-config.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/basic-config.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/basic-config.h?ref=8903a1a0a78a705402123d2a5c465217cb9d791c",
        "patch": "@@ -10,7 +10,10 @@\n #ifdef USE_BASIC_CONFIG\n \n #undef USE_ASM_X86_64\n+#undef USE_ECMULT_STATIC_PRECOMPUTATION\n #undef USE_ENDOMORPHISM\n+#undef USE_EXTERNAL_ASM\n+#undef USE_EXTERNAL_DEFAULT_CALLBACKS\n #undef USE_FIELD_10X26\n #undef USE_FIELD_5X52\n #undef USE_FIELD_INV_BUILTIN\n@@ -21,12 +24,14 @@\n #undef USE_SCALAR_8X32\n #undef USE_SCALAR_INV_BUILTIN\n #undef USE_SCALAR_INV_NUM\n+#undef ECMULT_WINDOW_SIZE\n \n #define USE_NUM_NONE 1\n #define USE_FIELD_INV_BUILTIN 1\n #define USE_SCALAR_INV_BUILTIN 1\n #define USE_FIELD_10X26 1\n #define USE_SCALAR_8X32 1\n+#define ECMULT_WINDOW_SIZE 15\n \n #endif /* USE_BASIC_CONFIG */\n "
      },
      {
        "sha": "9bfed903e04e4ec589277cd96b390e840aa2b015",
        "filename": "src/secp256k1/src/bench.h",
        "status": "modified",
        "additions": 74,
        "deletions": 23,
        "changes": 97,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/bench.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/bench.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench.h?ref=8903a1a0a78a705402123d2a5c465217cb9d791c",
        "patch": "@@ -7,45 +7,87 @@\n #ifndef SECP256K1_BENCH_H\n #define SECP256K1_BENCH_H\n \n+#include <stdint.h>\n #include <stdio.h>\n #include <string.h>\n-#include <math.h>\n #include \"sys/time.h\"\n \n-static double gettimedouble(void) {\n+static int64_t gettime_i64(void) {\n     struct timeval tv;\n     gettimeofday(&tv, NULL);\n-    return tv.tv_usec * 0.000001 + tv.tv_sec;\n+    return (int64_t)tv.tv_usec + (int64_t)tv.tv_sec * 1000000LL;\n }\n \n-void print_number(double x) {\n-    double y = x;\n-    int c = 0;\n-    if (y < 0.0) {\n-        y = -y;\n+#define FP_EXP (6)\n+#define FP_MULT (1000000LL)\n+\n+/* Format fixed point number. */\n+void print_number(const int64_t x) {\n+    int64_t x_abs, y;\n+    int c, i, rounding;\n+    size_t ptr;\n+    char buffer[30];\n+\n+    if (x == INT64_MIN) {\n+        /* Prevent UB. */\n+        printf(\"ERR\");\n+        return;\n     }\n-    while (y > 0 && y < 100.0) {\n-        y *= 10.0;\n+    x_abs = x < 0 ? -x : x;\n+\n+    /* Determine how many decimals we want to show (more than FP_EXP makes no\n+     * sense). */\n+    y = x_abs;\n+    c = 0;\n+    while (y > 0LL && y < 100LL * FP_MULT && c < FP_EXP) {\n+        y *= 10LL;\n         c++;\n     }\n-    printf(\"%.*f\", c, x);\n+\n+    /* Round to 'c' decimals. */\n+    y = x_abs;\n+    rounding = 0;\n+    for (i = c; i < FP_EXP; ++i) {\n+        rounding = (y % 10) >= 5;\n+        y /= 10;\n+    }\n+    y += rounding;\n+\n+    /* Format and print the number. */\n+    ptr = sizeof(buffer) - 1;\n+    buffer[ptr] = 0;\n+    if (c != 0) {\n+        for (i = 0; i < c; ++i) {\n+            buffer[--ptr] = '0' + (y % 10);\n+            y /= 10;\n+        }\n+        buffer[--ptr] = '.';\n+    }\n+    do {\n+        buffer[--ptr] = '0' + (y % 10);\n+        y /= 10;\n+    } while (y != 0);\n+    if (x < 0) {\n+        buffer[--ptr] = '-';\n+    }\n+    printf(\"%s\", &buffer[ptr]);\n }\n \n-void run_benchmark(char *name, void (*benchmark)(void*), void (*setup)(void*), void (*teardown)(void*), void* data, int count, int iter) {\n+void run_benchmark(char *name, void (*benchmark)(void*, int), void (*setup)(void*), void (*teardown)(void*, int), void* data, int count, int iter) {\n     int i;\n-    double min = HUGE_VAL;\n-    double sum = 0.0;\n-    double max = 0.0;\n+    int64_t min = INT64_MAX;\n+    int64_t sum = 0;\n+    int64_t max = 0;\n     for (i = 0; i < count; i++) {\n-        double begin, total;\n+        int64_t begin, total;\n         if (setup != NULL) {\n             setup(data);\n         }\n-        begin = gettimedouble();\n-        benchmark(data);\n-        total = gettimedouble() - begin;\n+        begin = gettime_i64();\n+        benchmark(data, iter);\n+        total = gettime_i64() - begin;\n         if (teardown != NULL) {\n-            teardown(data);\n+            teardown(data, iter);\n         }\n         if (total < min) {\n             min = total;\n@@ -56,11 +98,11 @@ void run_benchmark(char *name, void (*benchmark)(void*), void (*setup)(void*), v\n         sum += total;\n     }\n     printf(\"%s: min \", name);\n-    print_number(min * 1000000.0 / iter);\n+    print_number(min * FP_MULT / iter);\n     printf(\"us / avg \");\n-    print_number((sum / count) * 1000000.0 / iter);\n+    print_number(((sum * FP_MULT) / count) / iter);\n     printf(\"us / max \");\n-    print_number(max * 1000000.0 / iter);\n+    print_number(max * FP_MULT / iter);\n     printf(\"us\\n\");\n }\n \n@@ -79,4 +121,13 @@ int have_flag(int argc, char** argv, char *flag) {\n     return 0;\n }\n \n+int get_iters(int default_iters) {\n+    char* env = getenv(\"SECP256K1_BENCH_ITERS\");\n+    if (env) {\n+        return strtol(env, NULL, 0);\n+    } else {\n+        return default_iters;\n+    }\n+}\n+\n #endif /* SECP256K1_BENCH_H */"
      },
      {
        "sha": "f099d33884bcfbb2f4fe4c5e27e0342f3e3a1b47",
        "filename": "src/secp256k1/src/bench_ecdh.c",
        "status": "modified",
        "additions": 10,
        "deletions": 5,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/bench_ecdh.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/bench_ecdh.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_ecdh.c?ref=8903a1a0a78a705402123d2a5c465217cb9d791c",
        "patch": "@@ -28,27 +28,32 @@ static void bench_ecdh_setup(void* arg) {\n         0xa2, 0xba, 0xd1, 0x84, 0xf8, 0x83, 0xc6, 0x9f\n     };\n \n-    /* create a context with no capabilities */\n-    data->ctx = secp256k1_context_create(SECP256K1_FLAGS_TYPE_CONTEXT);\n     for (i = 0; i < 32; i++) {\n         data->scalar[i] = i + 1;\n     }\n     CHECK(secp256k1_ec_pubkey_parse(data->ctx, &data->point, point, sizeof(point)) == 1);\n }\n \n-static void bench_ecdh(void* arg) {\n+static void bench_ecdh(void* arg, int iters) {\n     int i;\n     unsigned char res[32];\n     bench_ecdh_data *data = (bench_ecdh_data*)arg;\n \n-    for (i = 0; i < 20000; i++) {\n+    for (i = 0; i < iters; i++) {\n         CHECK(secp256k1_ecdh(data->ctx, res, &data->point, data->scalar, NULL, NULL) == 1);\n     }\n }\n \n int main(void) {\n     bench_ecdh_data data;\n \n-    run_benchmark(\"ecdh\", bench_ecdh, bench_ecdh_setup, NULL, &data, 10, 20000);\n+    int iters = get_iters(20000);\n+\n+    /* create a context with no capabilities */\n+    data.ctx = secp256k1_context_create(SECP256K1_FLAGS_TYPE_CONTEXT);\n+\n+    run_benchmark(\"ecdh\", bench_ecdh, bench_ecdh_setup, NULL, &data, 10, iters);\n+\n+    secp256k1_context_destroy(data.ctx);\n     return 0;\n }"
      },
      {
        "sha": "facd07ef31b3eeff19a9adc3e9cceb4c69f800b6",
        "filename": "src/secp256k1/src/bench_ecmult.c",
        "status": "modified",
        "additions": 28,
        "deletions": 21,
        "changes": 49,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/bench_ecmult.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/bench_ecmult.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_ecmult.c?ref=8903a1a0a78a705402123d2a5c465217cb9d791c",
        "patch": "@@ -18,7 +18,6 @@\n #include \"secp256k1.c\"\n \n #define POINTS 32768\n-#define ITERS 10000\n \n typedef struct {\n     /* Setup once in advance */\n@@ -55,16 +54,16 @@ static int bench_callback(secp256k1_scalar* sc, secp256k1_ge* ge, size_t idx, vo\n     return 1;\n }\n \n-static void bench_ecmult(void* arg) {\n+static void bench_ecmult(void* arg, int iters) {\n     bench_data* data = (bench_data*)arg;\n \n-    size_t count = data->count;\n     int includes_g = data->includes_g;\n-    size_t iters = 1 + ITERS / count;\n-    size_t iter;\n+    int iter;\n+    int count = data->count;\n+    iters = iters / data->count;\n \n     for (iter = 0; iter < iters; ++iter) {\n-        data->ecmult_multi(&data->ctx->ecmult_ctx, data->scratch, &data->output[iter], data->includes_g ? &data->scalars[data->offset1] : NULL, bench_callback, arg, count - includes_g);\n+        data->ecmult_multi(&data->ctx->error_callback, &data->ctx->ecmult_ctx, data->scratch, &data->output[iter], data->includes_g ? &data->scalars[data->offset1] : NULL, bench_callback, arg, count - includes_g);\n         data->offset1 = (data->offset1 + count) % POINTS;\n         data->offset2 = (data->offset2 + count - 1) % POINTS;\n     }\n@@ -76,10 +75,10 @@ static void bench_ecmult_setup(void* arg) {\n     data->offset2 = (data->count * 0x7f6f537b + 0x6a1a8f49) % POINTS;\n }\n \n-static void bench_ecmult_teardown(void* arg) {\n+static void bench_ecmult_teardown(void* arg, int iters) {\n     bench_data* data = (bench_data*)arg;\n-    size_t iters = 1 + ITERS / data->count;\n-    size_t iter;\n+    int iter;\n+    iters = iters / data->count;\n     /* Verify the results in teardown, to avoid doing comparisons while benchmarking. */\n     for (iter = 0; iter < iters; ++iter) {\n         secp256k1_gej tmp;\n@@ -104,10 +103,10 @@ static void generate_scalar(uint32_t num, secp256k1_scalar* scalar) {\n     CHECK(!overflow);\n }\n \n-static void run_test(bench_data* data, size_t count, int includes_g) {\n+static void run_test(bench_data* data, size_t count, int includes_g, int num_iters) {\n     char str[32];\n     static const secp256k1_scalar zero = SECP256K1_SCALAR_CONST(0, 0, 0, 0, 0, 0, 0, 0);\n-    size_t iters = 1 + ITERS / count;\n+    size_t iters = 1 + num_iters / count;\n     size_t iter;\n \n     data->count = count;\n@@ -130,7 +129,7 @@ static void run_test(bench_data* data, size_t count, int includes_g) {\n \n     /* Run the benchmark. */\n     sprintf(str, includes_g ? \"ecmult_%ig\" : \"ecmult_%i\", (int)count);\n-    run_benchmark(str, bench_ecmult, bench_ecmult_setup, bench_ecmult_teardown, data, 10, count * (1 + ITERS / count));\n+    run_benchmark(str, bench_ecmult, bench_ecmult_setup, bench_ecmult_teardown, data, 10, count * iters);\n }\n \n int main(int argc, char **argv) {\n@@ -139,6 +138,8 @@ int main(int argc, char **argv) {\n     secp256k1_gej* pubkeys_gej;\n     size_t scratch_size;\n \n+    int iters = get_iters(10000);\n+\n     data.ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n     scratch_size = secp256k1_strauss_scratch_size(POINTS) + STRAUSS_SCRATCH_OBJECTS*16;\n     data.scratch = secp256k1_scratch_space_create(data.ctx, scratch_size);\n@@ -154,7 +155,7 @@ int main(int argc, char **argv) {\n         } else if(have_flag(argc, argv, \"simple\")) {\n             printf(\"Using simple algorithm:\\n\");\n             data.ecmult_multi = secp256k1_ecmult_multi_var;\n-            secp256k1_scratch_space_destroy(data.scratch);\n+            secp256k1_scratch_space_destroy(data.ctx, data.scratch);\n             data.scratch = NULL;\n         } else {\n             fprintf(stderr, \"%s: unrecognized argument '%s'.\\n\", argv[0], argv[1]);\n@@ -167,8 +168,8 @@ int main(int argc, char **argv) {\n     data.scalars = malloc(sizeof(secp256k1_scalar) * POINTS);\n     data.seckeys = malloc(sizeof(secp256k1_scalar) * POINTS);\n     data.pubkeys = malloc(sizeof(secp256k1_ge) * POINTS);\n-    data.expected_output = malloc(sizeof(secp256k1_gej) * (ITERS + 1));\n-    data.output = malloc(sizeof(secp256k1_gej) * (ITERS + 1));\n+    data.expected_output = malloc(sizeof(secp256k1_gej) * (iters + 1));\n+    data.output = malloc(sizeof(secp256k1_gej) * (iters + 1));\n \n     /* Generate a set of scalars, and private/public keypairs. */\n     pubkeys_gej = malloc(sizeof(secp256k1_gej) * POINTS);\n@@ -185,18 +186,24 @@ int main(int argc, char **argv) {\n     free(pubkeys_gej);\n \n     for (i = 1; i <= 8; ++i) {\n-        run_test(&data, i, 1);\n+        run_test(&data, i, 1, iters);\n     }\n \n-    for (p = 0; p <= 11; ++p) {\n-        for (i = 9; i <= 16; ++i) {\n-            run_test(&data, i << p, 1);\n+    /* This is disabled with low count of iterations because the loop runs 77 times even with iters=1\n+    * and the higher it goes the longer the computation takes(more points)\n+    * So we don't run this benchmark with low iterations to prevent slow down */\n+     if (iters > 2) {\n+        for (p = 0; p <= 11; ++p) {\n+            for (i = 9; i <= 16; ++i) {\n+                run_test(&data, i << p, 1, iters);\n+            }\n         }\n     }\n-    secp256k1_context_destroy(data.ctx);\n+\n     if (data.scratch != NULL) {\n-        secp256k1_scratch_space_destroy(data.scratch);\n+        secp256k1_scratch_space_destroy(data.ctx, data.scratch);\n     }\n+    secp256k1_context_destroy(data.ctx);\n     free(data.scalars);\n     free(data.pubkeys);\n     free(data.seckeys);"
      },
      {
        "sha": "20759127d3c9f12faa96856f9152edb7487a6c64",
        "filename": "src/secp256k1/src/bench_internal.c",
        "status": "modified",
        "additions": 113,
        "deletions": 101,
        "changes": 214,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/bench_internal.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/bench_internal.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_internal.c?ref=8903a1a0a78a705402123d2a5c465217cb9d791c",
        "patch": "@@ -56,314 +56,326 @@ void bench_setup(void* arg) {\n     memcpy(data->data + 32, init_y, 32);\n }\n \n-void bench_scalar_add(void* arg) {\n-    int i;\n+void bench_scalar_add(void* arg, int iters) {\n+    int i, j = 0;\n     bench_inv *data = (bench_inv*)arg;\n \n-    for (i = 0; i < 2000000; i++) {\n-        secp256k1_scalar_add(&data->scalar_x, &data->scalar_x, &data->scalar_y);\n+    for (i = 0; i < iters; i++) {\n+        j += secp256k1_scalar_add(&data->scalar_x, &data->scalar_x, &data->scalar_y);\n     }\n+    CHECK(j <= iters);\n }\n \n-void bench_scalar_negate(void* arg) {\n+void bench_scalar_negate(void* arg, int iters) {\n     int i;\n     bench_inv *data = (bench_inv*)arg;\n \n-    for (i = 0; i < 2000000; i++) {\n+    for (i = 0; i < iters; i++) {\n         secp256k1_scalar_negate(&data->scalar_x, &data->scalar_x);\n     }\n }\n \n-void bench_scalar_sqr(void* arg) {\n+void bench_scalar_sqr(void* arg, int iters) {\n     int i;\n     bench_inv *data = (bench_inv*)arg;\n \n-    for (i = 0; i < 200000; i++) {\n+    for (i = 0; i < iters; i++) {\n         secp256k1_scalar_sqr(&data->scalar_x, &data->scalar_x);\n     }\n }\n \n-void bench_scalar_mul(void* arg) {\n+void bench_scalar_mul(void* arg, int iters) {\n     int i;\n     bench_inv *data = (bench_inv*)arg;\n \n-    for (i = 0; i < 200000; i++) {\n+    for (i = 0; i < iters; i++) {\n         secp256k1_scalar_mul(&data->scalar_x, &data->scalar_x, &data->scalar_y);\n     }\n }\n \n #ifdef USE_ENDOMORPHISM\n-void bench_scalar_split(void* arg) {\n-    int i;\n+void bench_scalar_split(void* arg, int iters) {\n+    int i, j = 0;\n     bench_inv *data = (bench_inv*)arg;\n \n-    for (i = 0; i < 20000; i++) {\n-        secp256k1_scalar l, r;\n-        secp256k1_scalar_split_lambda(&l, &r, &data->scalar_x);\n-        secp256k1_scalar_add(&data->scalar_x, &data->scalar_x, &data->scalar_y);\n+    for (i = 0; i < iters; i++) {\n+        secp256k1_scalar_split_lambda(&data->scalar_x, &data->scalar_y, &data->scalar_x);\n+        j += secp256k1_scalar_add(&data->scalar_x, &data->scalar_x, &data->scalar_y);\n     }\n+    CHECK(j <= iters);\n }\n #endif\n \n-void bench_scalar_inverse(void* arg) {\n-    int i;\n+void bench_scalar_inverse(void* arg, int iters) {\n+    int i, j = 0;\n     bench_inv *data = (bench_inv*)arg;\n \n-    for (i = 0; i < 2000; i++) {\n+    for (i = 0; i < iters; i++) {\n         secp256k1_scalar_inverse(&data->scalar_x, &data->scalar_x);\n-        secp256k1_scalar_add(&data->scalar_x, &data->scalar_x, &data->scalar_y);\n+        j += secp256k1_scalar_add(&data->scalar_x, &data->scalar_x, &data->scalar_y);\n     }\n+    CHECK(j <= iters);\n }\n \n-void bench_scalar_inverse_var(void* arg) {\n-    int i;\n+void bench_scalar_inverse_var(void* arg, int iters) {\n+    int i, j = 0;\n     bench_inv *data = (bench_inv*)arg;\n \n-    for (i = 0; i < 2000; i++) {\n+    for (i = 0; i < iters; i++) {\n         secp256k1_scalar_inverse_var(&data->scalar_x, &data->scalar_x);\n-        secp256k1_scalar_add(&data->scalar_x, &data->scalar_x, &data->scalar_y);\n+        j += secp256k1_scalar_add(&data->scalar_x, &data->scalar_x, &data->scalar_y);\n     }\n+    CHECK(j <= iters);\n }\n \n-void bench_field_normalize(void* arg) {\n+void bench_field_normalize(void* arg, int iters) {\n     int i;\n     bench_inv *data = (bench_inv*)arg;\n \n-    for (i = 0; i < 2000000; i++) {\n+    for (i = 0; i < iters; i++) {\n         secp256k1_fe_normalize(&data->fe_x);\n     }\n }\n \n-void bench_field_normalize_weak(void* arg) {\n+void bench_field_normalize_weak(void* arg, int iters) {\n     int i;\n     bench_inv *data = (bench_inv*)arg;\n \n-    for (i = 0; i < 2000000; i++) {\n+    for (i = 0; i < iters; i++) {\n         secp256k1_fe_normalize_weak(&data->fe_x);\n     }\n }\n \n-void bench_field_mul(void* arg) {\n+void bench_field_mul(void* arg, int iters) {\n     int i;\n     bench_inv *data = (bench_inv*)arg;\n \n-    for (i = 0; i < 200000; i++) {\n+    for (i = 0; i < iters; i++) {\n         secp256k1_fe_mul(&data->fe_x, &data->fe_x, &data->fe_y);\n     }\n }\n \n-void bench_field_sqr(void* arg) {\n+void bench_field_sqr(void* arg, int iters) {\n     int i;\n     bench_inv *data = (bench_inv*)arg;\n \n-    for (i = 0; i < 200000; i++) {\n+    for (i = 0; i < iters; i++) {\n         secp256k1_fe_sqr(&data->fe_x, &data->fe_x);\n     }\n }\n \n-void bench_field_inverse(void* arg) {\n+void bench_field_inverse(void* arg, int iters) {\n     int i;\n     bench_inv *data = (bench_inv*)arg;\n \n-    for (i = 0; i < 20000; i++) {\n+    for (i = 0; i < iters; i++) {\n         secp256k1_fe_inv(&data->fe_x, &data->fe_x);\n         secp256k1_fe_add(&data->fe_x, &data->fe_y);\n     }\n }\n \n-void bench_field_inverse_var(void* arg) {\n+void bench_field_inverse_var(void* arg, int iters) {\n     int i;\n     bench_inv *data = (bench_inv*)arg;\n \n-    for (i = 0; i < 20000; i++) {\n+    for (i = 0; i < iters; i++) {\n         secp256k1_fe_inv_var(&data->fe_x, &data->fe_x);\n         secp256k1_fe_add(&data->fe_x, &data->fe_y);\n     }\n }\n \n-void bench_field_sqrt(void* arg) {\n-    int i;\n+void bench_field_sqrt(void* arg, int iters) {\n+    int i, j = 0;\n     bench_inv *data = (bench_inv*)arg;\n     secp256k1_fe t;\n \n-    for (i = 0; i < 20000; i++) {\n+    for (i = 0; i < iters; i++) {\n         t = data->fe_x;\n-        secp256k1_fe_sqrt(&data->fe_x, &t);\n+        j += secp256k1_fe_sqrt(&data->fe_x, &t);\n         secp256k1_fe_add(&data->fe_x, &data->fe_y);\n     }\n+    CHECK(j <= iters);\n }\n \n-void bench_group_double_var(void* arg) {\n+void bench_group_double_var(void* arg, int iters) {\n     int i;\n     bench_inv *data = (bench_inv*)arg;\n \n-    for (i = 0; i < 200000; i++) {\n+    for (i = 0; i < iters; i++) {\n         secp256k1_gej_double_var(&data->gej_x, &data->gej_x, NULL);\n     }\n }\n \n-void bench_group_add_var(void* arg) {\n+void bench_group_add_var(void* arg, int iters) {\n     int i;\n     bench_inv *data = (bench_inv*)arg;\n \n-    for (i = 0; i < 200000; i++) {\n+    for (i = 0; i < iters; i++) {\n         secp256k1_gej_add_var(&data->gej_x, &data->gej_x, &data->gej_y, NULL);\n     }\n }\n \n-void bench_group_add_affine(void* arg) {\n+void bench_group_add_affine(void* arg, int iters) {\n     int i;\n     bench_inv *data = (bench_inv*)arg;\n \n-    for (i = 0; i < 200000; i++) {\n+    for (i = 0; i < iters; i++) {\n         secp256k1_gej_add_ge(&data->gej_x, &data->gej_x, &data->ge_y);\n     }\n }\n \n-void bench_group_add_affine_var(void* arg) {\n+void bench_group_add_affine_var(void* arg, int iters) {\n     int i;\n     bench_inv *data = (bench_inv*)arg;\n \n-    for (i = 0; i < 200000; i++) {\n+    for (i = 0; i < iters; i++) {\n         secp256k1_gej_add_ge_var(&data->gej_x, &data->gej_x, &data->ge_y, NULL);\n     }\n }\n \n-void bench_group_jacobi_var(void* arg) {\n-    int i;\n+void bench_group_jacobi_var(void* arg, int iters) {\n+    int i, j = 0;\n     bench_inv *data = (bench_inv*)arg;\n \n-    for (i = 0; i < 20000; i++) {\n-        secp256k1_gej_has_quad_y_var(&data->gej_x);\n+    for (i = 0; i < iters; i++) {\n+        j += secp256k1_gej_has_quad_y_var(&data->gej_x);\n     }\n+    CHECK(j == iters);\n }\n \n-void bench_ecmult_wnaf(void* arg) {\n-    int i;\n+void bench_ecmult_wnaf(void* arg, int iters) {\n+    int i, bits = 0, overflow = 0;\n     bench_inv *data = (bench_inv*)arg;\n \n-    for (i = 0; i < 20000; i++) {\n-        secp256k1_ecmult_wnaf(data->wnaf, 256, &data->scalar_x, WINDOW_A);\n-        secp256k1_scalar_add(&data->scalar_x, &data->scalar_x, &data->scalar_y);\n+    for (i = 0; i < iters; i++) {\n+        bits += secp256k1_ecmult_wnaf(data->wnaf, 256, &data->scalar_x, WINDOW_A);\n+        overflow += secp256k1_scalar_add(&data->scalar_x, &data->scalar_x, &data->scalar_y);\n     }\n+    CHECK(overflow >= 0);\n+    CHECK(bits <= 256*iters);\n }\n \n-void bench_wnaf_const(void* arg) {\n-    int i;\n+void bench_wnaf_const(void* arg, int iters) {\n+    int i, bits = 0, overflow = 0;\n     bench_inv *data = (bench_inv*)arg;\n \n-    for (i = 0; i < 20000; i++) {\n-        secp256k1_wnaf_const(data->wnaf, data->scalar_x, WINDOW_A, 256);\n-        secp256k1_scalar_add(&data->scalar_x, &data->scalar_x, &data->scalar_y);\n+    for (i = 0; i < iters; i++) {\n+        bits += secp256k1_wnaf_const(data->wnaf, &data->scalar_x, WINDOW_A, 256);\n+        overflow += secp256k1_scalar_add(&data->scalar_x, &data->scalar_x, &data->scalar_y);\n     }\n+    CHECK(overflow >= 0);\n+    CHECK(bits <= 256*iters);\n }\n \n \n-void bench_sha256(void* arg) {\n+void bench_sha256(void* arg, int iters) {\n     int i;\n     bench_inv *data = (bench_inv*)arg;\n     secp256k1_sha256 sha;\n \n-    for (i = 0; i < 20000; i++) {\n+    for (i = 0; i < iters; i++) {\n         secp256k1_sha256_initialize(&sha);\n         secp256k1_sha256_write(&sha, data->data, 32);\n         secp256k1_sha256_finalize(&sha, data->data);\n     }\n }\n \n-void bench_hmac_sha256(void* arg) {\n+void bench_hmac_sha256(void* arg, int iters) {\n     int i;\n     bench_inv *data = (bench_inv*)arg;\n     secp256k1_hmac_sha256 hmac;\n \n-    for (i = 0; i < 20000; i++) {\n+    for (i = 0; i < iters; i++) {\n         secp256k1_hmac_sha256_initialize(&hmac, data->data, 32);\n         secp256k1_hmac_sha256_write(&hmac, data->data, 32);\n         secp256k1_hmac_sha256_finalize(&hmac, data->data);\n     }\n }\n \n-void bench_rfc6979_hmac_sha256(void* arg) {\n+void bench_rfc6979_hmac_sha256(void* arg, int iters) {\n     int i;\n     bench_inv *data = (bench_inv*)arg;\n     secp256k1_rfc6979_hmac_sha256 rng;\n \n-    for (i = 0; i < 20000; i++) {\n+    for (i = 0; i < iters; i++) {\n         secp256k1_rfc6979_hmac_sha256_initialize(&rng, data->data, 64);\n         secp256k1_rfc6979_hmac_sha256_generate(&rng, data->data, 32);\n     }\n }\n \n-void bench_context_verify(void* arg) {\n+void bench_context_verify(void* arg, int iters) {\n     int i;\n     (void)arg;\n-    for (i = 0; i < 20; i++) {\n+    for (i = 0; i < iters; i++) {\n         secp256k1_context_destroy(secp256k1_context_create(SECP256K1_CONTEXT_VERIFY));\n     }\n }\n \n-void bench_context_sign(void* arg) {\n+void bench_context_sign(void* arg, int iters) {\n     int i;\n     (void)arg;\n-    for (i = 0; i < 200; i++) {\n+    for (i = 0; i < iters; i++) {\n         secp256k1_context_destroy(secp256k1_context_create(SECP256K1_CONTEXT_SIGN));\n     }\n }\n \n #ifndef USE_NUM_NONE\n-void bench_num_jacobi(void* arg) {\n-    int i;\n+void bench_num_jacobi(void* arg, int iters) {\n+    int i, j = 0;\n     bench_inv *data = (bench_inv*)arg;\n     secp256k1_num nx, norder;\n \n     secp256k1_scalar_get_num(&nx, &data->scalar_x);\n     secp256k1_scalar_order_get_num(&norder);\n     secp256k1_scalar_get_num(&norder, &data->scalar_y);\n \n-    for (i = 0; i < 200000; i++) {\n-        secp256k1_num_jacobi(&nx, &norder);\n+    for (i = 0; i < iters; i++) {\n+        j += secp256k1_num_jacobi(&nx, &norder);\n     }\n+    CHECK(j <= iters);\n }\n #endif\n \n int main(int argc, char **argv) {\n     bench_inv data;\n-    if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"add\")) run_benchmark(\"scalar_add\", bench_scalar_add, bench_setup, NULL, &data, 10, 2000000);\n-    if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"negate\")) run_benchmark(\"scalar_negate\", bench_scalar_negate, bench_setup, NULL, &data, 10, 2000000);\n-    if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"sqr\")) run_benchmark(\"scalar_sqr\", bench_scalar_sqr, bench_setup, NULL, &data, 10, 200000);\n-    if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"mul\")) run_benchmark(\"scalar_mul\", bench_scalar_mul, bench_setup, NULL, &data, 10, 200000);\n+    int iters = get_iters(20000);\n+\n+    if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"add\")) run_benchmark(\"scalar_add\", bench_scalar_add, bench_setup, NULL, &data, 10, iters*100);\n+    if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"negate\")) run_benchmark(\"scalar_negate\", bench_scalar_negate, bench_setup, NULL, &data, 10, iters*100);\n+    if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"sqr\")) run_benchmark(\"scalar_sqr\", bench_scalar_sqr, bench_setup, NULL, &data, 10, iters*10);\n+    if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"mul\")) run_benchmark(\"scalar_mul\", bench_scalar_mul, bench_setup, NULL, &data, 10, iters*10);\n #ifdef USE_ENDOMORPHISM\n-    if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"split\")) run_benchmark(\"scalar_split\", bench_scalar_split, bench_setup, NULL, &data, 10, 20000);\n+    if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"split\")) run_benchmark(\"scalar_split\", bench_scalar_split, bench_setup, NULL, &data, 10, iters);\n #endif\n     if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"inverse\")) run_benchmark(\"scalar_inverse\", bench_scalar_inverse, bench_setup, NULL, &data, 10, 2000);\n     if (have_flag(argc, argv, \"scalar\") || have_flag(argc, argv, \"inverse\")) run_benchmark(\"scalar_inverse_var\", bench_scalar_inverse_var, bench_setup, NULL, &data, 10, 2000);\n \n-    if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"normalize\")) run_benchmark(\"field_normalize\", bench_field_normalize, bench_setup, NULL, &data, 10, 2000000);\n-    if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"normalize\")) run_benchmark(\"field_normalize_weak\", bench_field_normalize_weak, bench_setup, NULL, &data, 10, 2000000);\n-    if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"sqr\")) run_benchmark(\"field_sqr\", bench_field_sqr, bench_setup, NULL, &data, 10, 200000);\n-    if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"mul\")) run_benchmark(\"field_mul\", bench_field_mul, bench_setup, NULL, &data, 10, 200000);\n-    if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"inverse\")) run_benchmark(\"field_inverse\", bench_field_inverse, bench_setup, NULL, &data, 10, 20000);\n-    if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"inverse\")) run_benchmark(\"field_inverse_var\", bench_field_inverse_var, bench_setup, NULL, &data, 10, 20000);\n-    if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"sqrt\")) run_benchmark(\"field_sqrt\", bench_field_sqrt, bench_setup, NULL, &data, 10, 20000);\n+    if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"normalize\")) run_benchmark(\"field_normalize\", bench_field_normalize, bench_setup, NULL, &data, 10, iters*100);\n+    if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"normalize\")) run_benchmark(\"field_normalize_weak\", bench_field_normalize_weak, bench_setup, NULL, &data, 10, iters*100);\n+    if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"sqr\")) run_benchmark(\"field_sqr\", bench_field_sqr, bench_setup, NULL, &data, 10, iters*10);\n+    if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"mul\")) run_benchmark(\"field_mul\", bench_field_mul, bench_setup, NULL, &data, 10, iters*10);\n+    if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"inverse\")) run_benchmark(\"field_inverse\", bench_field_inverse, bench_setup, NULL, &data, 10, iters);\n+    if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"inverse\")) run_benchmark(\"field_inverse_var\", bench_field_inverse_var, bench_setup, NULL, &data, 10, iters);\n+    if (have_flag(argc, argv, \"field\") || have_flag(argc, argv, \"sqrt\")) run_benchmark(\"field_sqrt\", bench_field_sqrt, bench_setup, NULL, &data, 10, iters);\n \n-    if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"double\")) run_benchmark(\"group_double_var\", bench_group_double_var, bench_setup, NULL, &data, 10, 200000);\n-    if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"add\")) run_benchmark(\"group_add_var\", bench_group_add_var, bench_setup, NULL, &data, 10, 200000);\n-    if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"add\")) run_benchmark(\"group_add_affine\", bench_group_add_affine, bench_setup, NULL, &data, 10, 200000);\n-    if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"add\")) run_benchmark(\"group_add_affine_var\", bench_group_add_affine_var, bench_setup, NULL, &data, 10, 200000);\n-    if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"jacobi\")) run_benchmark(\"group_jacobi_var\", bench_group_jacobi_var, bench_setup, NULL, &data, 10, 20000);\n+    if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"double\")) run_benchmark(\"group_double_var\", bench_group_double_var, bench_setup, NULL, &data, 10, iters*10);\n+    if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"add\")) run_benchmark(\"group_add_var\", bench_group_add_var, bench_setup, NULL, &data, 10, iters*10);\n+    if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"add\")) run_benchmark(\"group_add_affine\", bench_group_add_affine, bench_setup, NULL, &data, 10, iters*10);\n+    if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"add\")) run_benchmark(\"group_add_affine_var\", bench_group_add_affine_var, bench_setup, NULL, &data, 10, iters*10);\n+    if (have_flag(argc, argv, \"group\") || have_flag(argc, argv, \"jacobi\")) run_benchmark(\"group_jacobi_var\", bench_group_jacobi_var, bench_setup, NULL, &data, 10, iters);\n \n-    if (have_flag(argc, argv, \"ecmult\") || have_flag(argc, argv, \"wnaf\")) run_benchmark(\"wnaf_const\", bench_wnaf_const, bench_setup, NULL, &data, 10, 20000);\n-    if (have_flag(argc, argv, \"ecmult\") || have_flag(argc, argv, \"wnaf\")) run_benchmark(\"ecmult_wnaf\", bench_ecmult_wnaf, bench_setup, NULL, &data, 10, 20000);\n+    if (have_flag(argc, argv, \"ecmult\") || have_flag(argc, argv, \"wnaf\")) run_benchmark(\"wnaf_const\", bench_wnaf_const, bench_setup, NULL, &data, 10, iters);\n+    if (have_flag(argc, argv, \"ecmult\") || have_flag(argc, argv, \"wnaf\")) run_benchmark(\"ecmult_wnaf\", bench_ecmult_wnaf, bench_setup, NULL, &data, 10, iters);\n \n-    if (have_flag(argc, argv, \"hash\") || have_flag(argc, argv, \"sha256\")) run_benchmark(\"hash_sha256\", bench_sha256, bench_setup, NULL, &data, 10, 20000);\n-    if (have_flag(argc, argv, \"hash\") || have_flag(argc, argv, \"hmac\")) run_benchmark(\"hash_hmac_sha256\", bench_hmac_sha256, bench_setup, NULL, &data, 10, 20000);\n-    if (have_flag(argc, argv, \"hash\") || have_flag(argc, argv, \"rng6979\")) run_benchmark(\"hash_rfc6979_hmac_sha256\", bench_rfc6979_hmac_sha256, bench_setup, NULL, &data, 10, 20000);\n+    if (have_flag(argc, argv, \"hash\") || have_flag(argc, argv, \"sha256\")) run_benchmark(\"hash_sha256\", bench_sha256, bench_setup, NULL, &data, 10, iters);\n+    if (have_flag(argc, argv, \"hash\") || have_flag(argc, argv, \"hmac\")) run_benchmark(\"hash_hmac_sha256\", bench_hmac_sha256, bench_setup, NULL, &data, 10, iters);\n+    if (have_flag(argc, argv, \"hash\") || have_flag(argc, argv, \"rng6979\")) run_benchmark(\"hash_rfc6979_hmac_sha256\", bench_rfc6979_hmac_sha256, bench_setup, NULL, &data, 10, iters);\n \n-    if (have_flag(argc, argv, \"context\") || have_flag(argc, argv, \"verify\")) run_benchmark(\"context_verify\", bench_context_verify, bench_setup, NULL, &data, 10, 20);\n-    if (have_flag(argc, argv, \"context\") || have_flag(argc, argv, \"sign\")) run_benchmark(\"context_sign\", bench_context_sign, bench_setup, NULL, &data, 10, 200);\n+    if (have_flag(argc, argv, \"context\") || have_flag(argc, argv, \"verify\")) run_benchmark(\"context_verify\", bench_context_verify, bench_setup, NULL, &data, 10, 1 + iters/1000);\n+    if (have_flag(argc, argv, \"context\") || have_flag(argc, argv, \"sign\")) run_benchmark(\"context_sign\", bench_context_sign, bench_setup, NULL, &data, 10, 1 + iters/100);\n \n #ifndef USE_NUM_NONE\n-    if (have_flag(argc, argv, \"num\") || have_flag(argc, argv, \"jacobi\")) run_benchmark(\"num_jacobi\", bench_num_jacobi, bench_setup, NULL, &data, 10, 200000);\n+    if (have_flag(argc, argv, \"num\") || have_flag(argc, argv, \"jacobi\")) run_benchmark(\"num_jacobi\", bench_num_jacobi, bench_setup, NULL, &data, 10, iters*10);\n #endif\n     return 0;\n }"
      },
      {
        "sha": "e952ed1215ed12bb7ef28ead6275262d75293dc7",
        "filename": "src/secp256k1/src/bench_recover.c",
        "status": "modified",
        "additions": 5,
        "deletions": 3,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/bench_recover.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/bench_recover.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_recover.c?ref=8903a1a0a78a705402123d2a5c465217cb9d791c",
        "patch": "@@ -15,13 +15,13 @@ typedef struct {\n     unsigned char sig[64];\n } bench_recover_data;\n \n-void bench_recover(void* arg) {\n+void bench_recover(void* arg, int iters) {\n     int i;\n     bench_recover_data *data = (bench_recover_data*)arg;\n     secp256k1_pubkey pubkey;\n     unsigned char pubkeyc[33];\n \n-    for (i = 0; i < 20000; i++) {\n+    for (i = 0; i < iters; i++) {\n         int j;\n         size_t pubkeylen = 33;\n         secp256k1_ecdsa_recoverable_signature sig;\n@@ -51,9 +51,11 @@ void bench_recover_setup(void* arg) {\n int main(void) {\n     bench_recover_data data;\n \n+    int iters = get_iters(20000);\n+\n     data.ctx = secp256k1_context_create(SECP256K1_CONTEXT_VERIFY);\n \n-    run_benchmark(\"ecdsa_recover\", bench_recover, bench_recover_setup, NULL, &data, 10, 20000);\n+    run_benchmark(\"ecdsa_recover\", bench_recover, bench_recover_setup, NULL, &data, 10, iters);\n \n     secp256k1_context_destroy(data.ctx);\n     return 0;"
      },
      {
        "sha": "c6b2942cc0c9bdc062b97bbadb24f531b9bedc1e",
        "filename": "src/secp256k1/src/bench_sign.c",
        "status": "modified",
        "additions": 5,
        "deletions": 3,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/bench_sign.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/bench_sign.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_sign.c?ref=8903a1a0a78a705402123d2a5c465217cb9d791c",
        "patch": "@@ -26,12 +26,12 @@ static void bench_sign_setup(void* arg) {\n     }\n }\n \n-static void bench_sign_run(void* arg) {\n+static void bench_sign_run(void* arg, int iters) {\n     int i;\n     bench_sign *data = (bench_sign*)arg;\n \n     unsigned char sig[74];\n-    for (i = 0; i < 20000; i++) {\n+    for (i = 0; i < iters; i++) {\n         size_t siglen = 74;\n         int j;\n         secp256k1_ecdsa_signature signature;\n@@ -47,9 +47,11 @@ static void bench_sign_run(void* arg) {\n int main(void) {\n     bench_sign data;\n \n+    int iters = get_iters(20000);\n+\n     data.ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN);\n \n-    run_benchmark(\"ecdsa_sign\", bench_sign_run, bench_sign_setup, NULL, &data, 10, 20000);\n+    run_benchmark(\"ecdsa_sign\", bench_sign_run, bench_sign_setup, NULL, &data, 10, iters);\n \n     secp256k1_context_destroy(data.ctx);\n     return 0;"
      },
      {
        "sha": "272d3e5cc4b4c19addc8eb3c977502872918d8f0",
        "filename": "src/secp256k1/src/bench_verify.c",
        "status": "modified",
        "additions": 9,
        "deletions": 6,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/bench_verify.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/bench_verify.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_verify.c?ref=8903a1a0a78a705402123d2a5c465217cb9d791c",
        "patch": "@@ -17,6 +17,7 @@\n #include <openssl/obj_mac.h>\n #endif\n \n+\n typedef struct {\n     secp256k1_context *ctx;\n     unsigned char msg[32];\n@@ -30,11 +31,11 @@ typedef struct {\n #endif\n } benchmark_verify_t;\n \n-static void benchmark_verify(void* arg) {\n+static void benchmark_verify(void* arg, int iters) {\n     int i;\n     benchmark_verify_t* data = (benchmark_verify_t*)arg;\n \n-    for (i = 0; i < 20000; i++) {\n+    for (i = 0; i < iters; i++) {\n         secp256k1_pubkey pubkey;\n         secp256k1_ecdsa_signature sig;\n         data->sig[data->siglen - 1] ^= (i & 0xFF);\n@@ -50,11 +51,11 @@ static void benchmark_verify(void* arg) {\n }\n \n #ifdef ENABLE_OPENSSL_TESTS\n-static void benchmark_verify_openssl(void* arg) {\n+static void benchmark_verify_openssl(void* arg, int iters) {\n     int i;\n     benchmark_verify_t* data = (benchmark_verify_t*)arg;\n \n-    for (i = 0; i < 20000; i++) {\n+    for (i = 0; i < iters; i++) {\n         data->sig[data->siglen - 1] ^= (i & 0xFF);\n         data->sig[data->siglen - 2] ^= ((i >> 8) & 0xFF);\n         data->sig[data->siglen - 3] ^= ((i >> 16) & 0xFF);\n@@ -85,6 +86,8 @@ int main(void) {\n     secp256k1_ecdsa_signature sig;\n     benchmark_verify_t data;\n \n+    int iters = get_iters(20000);\n+\n     data.ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n \n     for (i = 0; i < 32; i++) {\n@@ -100,10 +103,10 @@ int main(void) {\n     data.pubkeylen = 33;\n     CHECK(secp256k1_ec_pubkey_serialize(data.ctx, data.pubkey, &data.pubkeylen, &pubkey, SECP256K1_EC_COMPRESSED) == 1);\n \n-    run_benchmark(\"ecdsa_verify\", benchmark_verify, NULL, NULL, &data, 10, 20000);\n+    run_benchmark(\"ecdsa_verify\", benchmark_verify, NULL, NULL, &data, 10, iters);\n #ifdef ENABLE_OPENSSL_TESTS\n     data.ec_group = EC_GROUP_new_by_curve_name(NID_secp256k1);\n-    run_benchmark(\"ecdsa_verify_openssl\", benchmark_verify_openssl, NULL, NULL, &data, 10, 20000);\n+    run_benchmark(\"ecdsa_verify_openssl\", benchmark_verify_openssl, NULL, NULL, &data, 10, iters);\n     EC_GROUP_free(data.ec_group);\n #endif\n "
      },
      {
        "sha": "5f54b59faa693bc4742d11ad72750ca92b4e1a34",
        "filename": "src/secp256k1/src/ecdsa_impl.h",
        "status": "modified",
        "additions": 48,
        "deletions": 46,
        "changes": 94,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/ecdsa_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/ecdsa_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecdsa_impl.h?ref=8903a1a0a78a705402123d2a5c465217cb9d791c",
        "patch": "@@ -46,68 +46,73 @@ static const secp256k1_fe secp256k1_ecdsa_const_p_minus_order = SECP256K1_FE_CON\n     0, 0, 0, 1, 0x45512319UL, 0x50B75FC4UL, 0x402DA172UL, 0x2FC9BAEEUL\n );\n \n-static int secp256k1_der_read_len(const unsigned char **sigp, const unsigned char *sigend) {\n-    int lenleft, b1;\n-    size_t ret = 0;\n+static int secp256k1_der_read_len(size_t *len, const unsigned char **sigp, const unsigned char *sigend) {\n+    size_t lenleft;\n+    unsigned char b1;\n+    VERIFY_CHECK(len != NULL);\n+    *len = 0;\n     if (*sigp >= sigend) {\n-        return -1;\n+        return 0;\n     }\n     b1 = *((*sigp)++);\n     if (b1 == 0xFF) {\n         /* X.690-0207 8.1.3.5.c the value 0xFF shall not be used. */\n-        return -1;\n+        return 0;\n     }\n     if ((b1 & 0x80) == 0) {\n         /* X.690-0207 8.1.3.4 short form length octets */\n-        return b1;\n+        *len = b1;\n+        return 1;\n     }\n     if (b1 == 0x80) {\n         /* Indefinite length is not allowed in DER. */\n-        return -1;\n+        return 0;\n     }\n     /* X.690-207 8.1.3.5 long form length octets */\n-    lenleft = b1 & 0x7F;\n-    if (lenleft > sigend - *sigp) {\n-        return -1;\n+    lenleft = b1 & 0x7F; /* lenleft is at least 1 */\n+    if (lenleft > (size_t)(sigend - *sigp)) {\n+        return 0;\n     }\n     if (**sigp == 0) {\n         /* Not the shortest possible length encoding. */\n-        return -1;\n+        return 0;\n     }\n-    if ((size_t)lenleft > sizeof(size_t)) {\n+    if (lenleft > sizeof(size_t)) {\n         /* The resulting length would exceed the range of a size_t, so\n          * certainly longer than the passed array size.\n          */\n-        return -1;\n+        return 0;\n     }\n     while (lenleft > 0) {\n-        ret = (ret << 8) | **sigp;\n-        if (ret + lenleft > (size_t)(sigend - *sigp)) {\n-            /* Result exceeds the length of the passed array. */\n-            return -1;\n-        }\n+        *len = (*len << 8) | **sigp;\n         (*sigp)++;\n         lenleft--;\n     }\n-    if (ret < 128) {\n+    if (*len > (size_t)(sigend - *sigp)) {\n+        /* Result exceeds the length of the passed array. */\n+        return 0;\n+    }\n+    if (*len < 128) {\n         /* Not the shortest possible length encoding. */\n-        return -1;\n+        return 0;\n     }\n-    return ret;\n+    return 1;\n }\n \n static int secp256k1_der_parse_integer(secp256k1_scalar *r, const unsigned char **sig, const unsigned char *sigend) {\n     int overflow = 0;\n     unsigned char ra[32] = {0};\n-    int rlen;\n+    size_t rlen;\n \n     if (*sig == sigend || **sig != 0x02) {\n         /* Not a primitive integer (X.690-0207 8.3.1). */\n         return 0;\n     }\n     (*sig)++;\n-    rlen = secp256k1_der_read_len(sig, sigend);\n-    if (rlen <= 0 || (*sig) + rlen > sigend) {\n+    if (secp256k1_der_read_len(&rlen, sig, sigend) == 0) {\n+        return 0;\n+    }\n+    if (rlen == 0 || *sig + rlen > sigend) {\n         /* Exceeds bounds or not at least length 1 (X.690-0207 8.3.1).  */\n         return 0;\n     }\n@@ -123,8 +128,11 @@ static int secp256k1_der_parse_integer(secp256k1_scalar *r, const unsigned char\n         /* Negative. */\n         overflow = 1;\n     }\n-    while (rlen > 0 && **sig == 0) {\n-        /* Skip leading zero bytes */\n+    /* There is at most one leading zero byte:\n+     * if there were two leading zero bytes, we would have failed and returned 0\n+     * because of excessive 0x00 padding already. */\n+    if (rlen > 0 && **sig == 0) {\n+        /* Skip leading zero byte */\n         rlen--;\n         (*sig)++;\n     }\n@@ -144,18 +152,16 @@ static int secp256k1_der_parse_integer(secp256k1_scalar *r, const unsigned char\n \n static int secp256k1_ecdsa_sig_parse(secp256k1_scalar *rr, secp256k1_scalar *rs, const unsigned char *sig, size_t size) {\n     const unsigned char *sigend = sig + size;\n-    int rlen;\n+    size_t rlen;\n     if (sig == sigend || *(sig++) != 0x30) {\n         /* The encoding doesn't start with a constructed sequence (X.690-0207 8.9.1). */\n         return 0;\n     }\n-    rlen = secp256k1_der_read_len(&sig, sigend);\n-    if (rlen < 0 || sig + rlen > sigend) {\n-        /* Tuple exceeds bounds */\n+    if (secp256k1_der_read_len(&rlen, &sig, sigend) == 0) {\n         return 0;\n     }\n-    if (sig + rlen != sigend) {\n-        /* Garbage after tuple. */\n+    if (rlen != (size_t)(sigend - sig)) {\n+        /* Tuple exceeds bounds or garage after tuple. */\n         return 0;\n     }\n \n@@ -274,22 +280,19 @@ static int secp256k1_ecdsa_sig_sign(const secp256k1_ecmult_gen_context *ctx, sec\n     secp256k1_ge r;\n     secp256k1_scalar n;\n     int overflow = 0;\n+    int high;\n \n     secp256k1_ecmult_gen(ctx, &rp, nonce);\n     secp256k1_ge_set_gej(&r, &rp);\n     secp256k1_fe_normalize(&r.x);\n     secp256k1_fe_normalize(&r.y);\n     secp256k1_fe_get_b32(b, &r.x);\n     secp256k1_scalar_set_b32(sigr, b, &overflow);\n-    /* These two conditions should be checked before calling */\n-    VERIFY_CHECK(!secp256k1_scalar_is_zero(sigr));\n-    VERIFY_CHECK(overflow == 0);\n-\n     if (recid) {\n         /* The overflow condition is cryptographically unreachable as hitting it requires finding the discrete log\n          * of some P where P.x >= order, and only 1 in about 2^127 points meet this criteria.\n          */\n-        *recid = (overflow ? 2 : 0) | (secp256k1_fe_is_odd(&r.y) ? 1 : 0);\n+        *recid = (overflow << 1) | secp256k1_fe_is_odd(&r.y);\n     }\n     secp256k1_scalar_mul(&n, sigr, seckey);\n     secp256k1_scalar_add(&n, &n, message);\n@@ -298,16 +301,15 @@ static int secp256k1_ecdsa_sig_sign(const secp256k1_ecmult_gen_context *ctx, sec\n     secp256k1_scalar_clear(&n);\n     secp256k1_gej_clear(&rp);\n     secp256k1_ge_clear(&r);\n-    if (secp256k1_scalar_is_zero(sigs)) {\n-        return 0;\n-    }\n-    if (secp256k1_scalar_is_high(sigs)) {\n-        secp256k1_scalar_negate(sigs, sigs);\n-        if (recid) {\n-            *recid ^= 1;\n-        }\n+    high = secp256k1_scalar_is_high(sigs);\n+    secp256k1_scalar_cond_negate(sigs, high);\n+    if (recid) {\n+            *recid ^= high;\n     }\n-    return 1;\n+    /* P.x = order is on the curve, so technically sig->r could end up being zero, which would be an invalid signature.\n+     * This is cryptographically unreachable as hitting it requires finding the discrete log of P.x = N.\n+     */\n+    return !secp256k1_scalar_is_zero(sigr) & !secp256k1_scalar_is_zero(sigs);\n }\n \n #endif /* SECP256K1_ECDSA_IMPL_H */"
      },
      {
        "sha": "e2e72d93039a72b1ba1837b3b5e392f4ea28759e",
        "filename": "src/secp256k1/src/eckey_impl.h",
        "status": "modified",
        "additions": 4,
        "deletions": 8,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/eckey_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/eckey_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/eckey_impl.h?ref=8903a1a0a78a705402123d2a5c465217cb9d791c",
        "patch": "@@ -54,10 +54,7 @@ static int secp256k1_eckey_pubkey_serialize(secp256k1_ge *elem, unsigned char *p\n \n static int secp256k1_eckey_privkey_tweak_add(secp256k1_scalar *key, const secp256k1_scalar *tweak) {\n     secp256k1_scalar_add(key, key, tweak);\n-    if (secp256k1_scalar_is_zero(key)) {\n-        return 0;\n-    }\n-    return 1;\n+    return !secp256k1_scalar_is_zero(key);\n }\n \n static int secp256k1_eckey_pubkey_tweak_add(const secp256k1_ecmult_context *ctx, secp256k1_ge *key, const secp256k1_scalar *tweak) {\n@@ -75,12 +72,11 @@ static int secp256k1_eckey_pubkey_tweak_add(const secp256k1_ecmult_context *ctx,\n }\n \n static int secp256k1_eckey_privkey_tweak_mul(secp256k1_scalar *key, const secp256k1_scalar *tweak) {\n-    if (secp256k1_scalar_is_zero(tweak)) {\n-        return 0;\n-    }\n+    int ret;\n+    ret = !secp256k1_scalar_is_zero(tweak);\n \n     secp256k1_scalar_mul(key, key, tweak);\n-    return 1;\n+    return ret;\n }\n \n static int secp256k1_eckey_pubkey_tweak_mul(const secp256k1_ecmult_context *ctx, secp256k1_ge *key, const secp256k1_scalar *tweak) {"
      },
      {
        "sha": "c9b198239d88974078443897b099851f94a6d395",
        "filename": "src/secp256k1/src/ecmult.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/ecmult.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/ecmult.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecmult.h?ref=8903a1a0a78a705402123d2a5c465217cb9d791c",
        "patch": "@@ -20,10 +20,10 @@ typedef struct {\n #endif\n } secp256k1_ecmult_context;\n \n+static const size_t SECP256K1_ECMULT_CONTEXT_PREALLOCATED_SIZE;\n static void secp256k1_ecmult_context_init(secp256k1_ecmult_context *ctx);\n-static void secp256k1_ecmult_context_build(secp256k1_ecmult_context *ctx, const secp256k1_callback *cb);\n-static void secp256k1_ecmult_context_clone(secp256k1_ecmult_context *dst,\n-                                           const secp256k1_ecmult_context *src, const secp256k1_callback *cb);\n+static void secp256k1_ecmult_context_build(secp256k1_ecmult_context *ctx, void **prealloc);\n+static void secp256k1_ecmult_context_finalize_memcpy(secp256k1_ecmult_context *dst, const secp256k1_ecmult_context *src);\n static void secp256k1_ecmult_context_clear(secp256k1_ecmult_context *ctx);\n static int secp256k1_ecmult_context_is_built(const secp256k1_ecmult_context *ctx);\n \n@@ -43,6 +43,6 @@ typedef int (secp256k1_ecmult_multi_callback)(secp256k1_scalar *sc, secp256k1_ge\n  *          0 if there is not enough scratch space for a single point or\n  *          callback returns 0\n  */\n-static int secp256k1_ecmult_multi_var(const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n);\n+static int secp256k1_ecmult_multi_var(const secp256k1_callback* error_callback, const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n);\n \n #endif /* SECP256K1_ECMULT_H */"
      },
      {
        "sha": "03bb33257d532f8a7345bd4b8f7b090ddb346a92",
        "filename": "src/secp256k1/src/ecmult_const.h",
        "status": "modified",
        "additions": 5,
        "deletions": 2,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/ecmult_const.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/ecmult_const.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecmult_const.h?ref=8903a1a0a78a705402123d2a5c465217cb9d791c",
        "patch": "@@ -10,8 +10,11 @@\n #include \"scalar.h\"\n #include \"group.h\"\n \n-/* Here `bits` should be set to the maximum bitlength of the _absolute value_ of `q`, plus\n- * one because we internally sometimes add 2 to the number during the WNAF conversion. */\n+/**\n+ * Multiply: R = q*A (in constant-time)\n+ * Here `bits` should be set to the maximum bitlength of the _absolute value_ of `q`, plus\n+ * one because we internally sometimes add 2 to the number during the WNAF conversion.\n+ */\n static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, const secp256k1_scalar *q, int bits);\n \n #endif /* SECP256K1_ECMULT_CONST_H */"
      },
      {
        "sha": "6d6d354aa4e1aa4583af6f9591800c5618c48fa1",
        "filename": "src/secp256k1/src/ecmult_const_impl.h",
        "status": "modified",
        "additions": 30,
        "deletions": 19,
        "changes": 49,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/ecmult_const_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/ecmult_const_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecmult_const_impl.h?ref=8903a1a0a78a705402123d2a5c465217cb9d791c",
        "patch": "@@ -14,16 +14,22 @@\n \n /* This is like `ECMULT_TABLE_GET_GE` but is constant time */\n #define ECMULT_CONST_TABLE_GET_GE(r,pre,n,w) do { \\\n-    int m; \\\n-    int abs_n = (n) * (((n) > 0) * 2 - 1); \\\n-    int idx_n = abs_n / 2; \\\n+    int m = 0; \\\n+    /* Extract the sign-bit for a constant time absolute-value. */ \\\n+    int mask = (n) >> (sizeof(n) * CHAR_BIT - 1); \\\n+    int abs_n = ((n) + mask) ^ mask; \\\n+    int idx_n = abs_n >> 1; \\\n     secp256k1_fe neg_y; \\\n     VERIFY_CHECK(((n) & 1) == 1); \\\n     VERIFY_CHECK((n) >= -((1 << ((w)-1)) - 1)); \\\n     VERIFY_CHECK((n) <=  ((1 << ((w)-1)) - 1)); \\\n     VERIFY_SETUP(secp256k1_fe_clear(&(r)->x)); \\\n     VERIFY_SETUP(secp256k1_fe_clear(&(r)->y)); \\\n-    for (m = 0; m < ECMULT_TABLE_SIZE(w); m++) { \\\n+    /* Unconditionally set r->x = (pre)[m].x. r->y = (pre)[m].y. because it's either the correct one \\\n+     * or will get replaced in the later iterations, this is needed to make sure `r` is initialized. */ \\\n+    (r)->x = (pre)[m].x; \\\n+    (r)->y = (pre)[m].y; \\\n+    for (m = 1; m < ECMULT_TABLE_SIZE(w); m++) { \\\n         /* This loop is used to avoid secret data in array indices. See\n          * the comment in ecmult_gen_impl.h for rationale. */ \\\n         secp256k1_fe_cmov(&(r)->x, &(pre)[m].x, m == idx_n); \\\n@@ -44,11 +50,11 @@\n  *\n  *  Adapted from `The Width-w NAF Method Provides Small Memory and Fast Elliptic Scalar\n  *  Multiplications Secure against Side Channel Attacks`, Okeya and Tagaki. M. Joye (Ed.)\n- *  CT-RSA 2003, LNCS 2612, pp. 328-443, 2003. Springer-Verlagy Berlin Heidelberg 2003\n+ *  CT-RSA 2003, LNCS 2612, pp. 328-443, 2003. Springer-Verlag Berlin Heidelberg 2003\n  *\n  *  Numbers reference steps of `Algorithm SPA-resistant Width-w NAF with Odd Scalar` on pp. 335\n  */\n-static int secp256k1_wnaf_const(int *wnaf, secp256k1_scalar s, int w, int size) {\n+static int secp256k1_wnaf_const(int *wnaf, const secp256k1_scalar *scalar, int w, int size) {\n     int global_sign;\n     int skew = 0;\n     int word = 0;\n@@ -59,8 +65,12 @@ static int secp256k1_wnaf_const(int *wnaf, secp256k1_scalar s, int w, int size)\n \n     int flip;\n     int bit;\n-    secp256k1_scalar neg_s;\n+    secp256k1_scalar s;\n     int not_neg_one;\n+\n+    VERIFY_CHECK(w > 0);\n+    VERIFY_CHECK(size > 0);\n+\n     /* Note that we cannot handle even numbers by negating them to be odd, as is\n      * done in other implementations, since if our scalars were specified to have\n      * width < 256 for performance reasons, their negations would have width 256\n@@ -75,12 +85,13 @@ static int secp256k1_wnaf_const(int *wnaf, secp256k1_scalar s, int w, int size)\n      * {1, 2} we want to add to the scalar when ensuring that it's odd. Further\n      * complicating things, -1 interacts badly with `secp256k1_scalar_cadd_bit` and\n      * we need to special-case it in this logic. */\n-    flip = secp256k1_scalar_is_high(&s);\n+    flip = secp256k1_scalar_is_high(scalar);\n     /* We add 1 to even numbers, 2 to odd ones, noting that negation flips parity */\n-    bit = flip ^ !secp256k1_scalar_is_even(&s);\n+    bit = flip ^ !secp256k1_scalar_is_even(scalar);\n     /* We check for negative one, since adding 2 to it will cause an overflow */\n-    secp256k1_scalar_negate(&neg_s, &s);\n-    not_neg_one = !secp256k1_scalar_is_one(&neg_s);\n+    secp256k1_scalar_negate(&s, scalar);\n+    not_neg_one = !secp256k1_scalar_is_one(&s);\n+    s = *scalar;\n     secp256k1_scalar_cadd_bit(&s, bit, not_neg_one);\n     /* If we had negative one, flip == 1, s.d[0] == 0, bit == 1, so caller expects\n      * that we added two to it and flipped it. In fact for -1 these operations are\n@@ -93,7 +104,7 @@ static int secp256k1_wnaf_const(int *wnaf, secp256k1_scalar s, int w, int size)\n \n     /* 4 */\n     u_last = secp256k1_scalar_shr_int(&s, w);\n-    while (word * w < size) {\n+    do {\n         int sign;\n         int even;\n \n@@ -109,7 +120,7 @@ static int secp256k1_wnaf_const(int *wnaf, secp256k1_scalar s, int w, int size)\n         wnaf[word++] = u_last * global_sign;\n \n         u_last = u;\n-    }\n+    } while (word * w < size);\n     wnaf[word] = u * global_sign;\n \n     VERIFY_CHECK(secp256k1_scalar_is_zero(&s));\n@@ -132,21 +143,20 @@ static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, cons\n     int wnaf_1[1 + WNAF_SIZE(WINDOW_A - 1)];\n \n     int i;\n-    secp256k1_scalar sc = *scalar;\n \n     /* build wnaf representation for q. */\n     int rsize = size;\n #ifdef USE_ENDOMORPHISM\n     if (size > 128) {\n         rsize = 128;\n         /* split q into q_1 and q_lam (where q = q_1 + q_lam*lambda, and q_1 and q_lam are ~128 bit) */\n-        secp256k1_scalar_split_lambda(&q_1, &q_lam, &sc);\n-        skew_1   = secp256k1_wnaf_const(wnaf_1,   q_1,   WINDOW_A - 1, 128);\n-        skew_lam = secp256k1_wnaf_const(wnaf_lam, q_lam, WINDOW_A - 1, 128);\n+        secp256k1_scalar_split_lambda(&q_1, &q_lam, scalar);\n+        skew_1   = secp256k1_wnaf_const(wnaf_1,   &q_1,   WINDOW_A - 1, 128);\n+        skew_lam = secp256k1_wnaf_const(wnaf_lam, &q_lam, WINDOW_A - 1, 128);\n     } else\n #endif\n     {\n-        skew_1   = secp256k1_wnaf_const(wnaf_1, sc, WINDOW_A - 1, size);\n+        skew_1   = secp256k1_wnaf_const(wnaf_1, scalar, WINDOW_A - 1, size);\n #ifdef USE_ENDOMORPHISM\n         skew_lam = 0;\n #endif\n@@ -168,6 +178,7 @@ static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, cons\n         for (i = 0; i < ECMULT_TABLE_SIZE(WINDOW_A); i++) {\n             secp256k1_ge_mul_lambda(&pre_a_lam[i], &pre_a[i]);\n         }\n+\n     }\n #endif\n \n@@ -191,7 +202,7 @@ static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, cons\n         int n;\n         int j;\n         for (j = 0; j < WINDOW_A - 1; ++j) {\n-            secp256k1_gej_double_nonzero(r, r, NULL);\n+            secp256k1_gej_double_nonzero(r, r);\n         }\n \n         n = wnaf_1[i];"
      },
      {
        "sha": "30815e5aa10e7866a99ca4fe6a3b85795c3a2bd0",
        "filename": "src/secp256k1/src/ecmult_gen.h",
        "status": "modified",
        "additions": 18,
        "deletions": 11,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/ecmult_gen.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/ecmult_gen.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecmult_gen.h?ref=8903a1a0a78a705402123d2a5c465217cb9d791c",
        "patch": "@@ -10,28 +10,35 @@\n #include \"scalar.h\"\n #include \"group.h\"\n \n+#if ECMULT_GEN_PREC_BITS != 2 && ECMULT_GEN_PREC_BITS != 4 && ECMULT_GEN_PREC_BITS != 8\n+#  error \"Set ECMULT_GEN_PREC_BITS to 2, 4 or 8.\"\n+#endif\n+#define ECMULT_GEN_PREC_B ECMULT_GEN_PREC_BITS\n+#define ECMULT_GEN_PREC_G (1 << ECMULT_GEN_PREC_B)\n+#define ECMULT_GEN_PREC_N (256 / ECMULT_GEN_PREC_B)\n+\n typedef struct {\n     /* For accelerating the computation of a*G:\n      * To harden against timing attacks, use the following mechanism:\n-     * * Break up the multiplicand into groups of 4 bits, called n_0, n_1, n_2, ..., n_63.\n-     * * Compute sum(n_i * 16^i * G + U_i, i=0..63), where:\n-     *   * U_i = U * 2^i (for i=0..62)\n-     *   * U_i = U * (1-2^63) (for i=63)\n-     *   where U is a point with no known corresponding scalar. Note that sum(U_i, i=0..63) = 0.\n-     * For each i, and each of the 16 possible values of n_i, (n_i * 16^i * G + U_i) is\n-     * precomputed (call it prec(i, n_i)). The formula now becomes sum(prec(i, n_i), i=0..63).\n+     * * Break up the multiplicand into groups of PREC_B bits, called n_0, n_1, n_2, ..., n_(PREC_N-1).\n+     * * Compute sum(n_i * (PREC_G)^i * G + U_i, i=0 ... PREC_N-1), where:\n+     *   * U_i = U * 2^i, for i=0 ... PREC_N-2\n+     *   * U_i = U * (1-2^(PREC_N-1)), for i=PREC_N-1\n+     *   where U is a point with no known corresponding scalar. Note that sum(U_i, i=0 ... PREC_N-1) = 0.\n+     * For each i, and each of the PREC_G possible values of n_i, (n_i * (PREC_G)^i * G + U_i) is\n+     * precomputed (call it prec(i, n_i)). The formula now becomes sum(prec(i, n_i), i=0 ... PREC_N-1).\n      * None of the resulting prec group elements have a known scalar, and neither do any of\n      * the intermediate sums while computing a*G.\n      */\n-    secp256k1_ge_storage (*prec)[64][16]; /* prec[j][i] = 16^j * i * G + U_i */\n+    secp256k1_ge_storage (*prec)[ECMULT_GEN_PREC_N][ECMULT_GEN_PREC_G]; /* prec[j][i] = (PREC_G)^j * i * G + U_i */\n     secp256k1_scalar blind;\n     secp256k1_gej initial;\n } secp256k1_ecmult_gen_context;\n \n+static const size_t SECP256K1_ECMULT_GEN_CONTEXT_PREALLOCATED_SIZE;\n static void secp256k1_ecmult_gen_context_init(secp256k1_ecmult_gen_context* ctx);\n-static void secp256k1_ecmult_gen_context_build(secp256k1_ecmult_gen_context* ctx, const secp256k1_callback* cb);\n-static void secp256k1_ecmult_gen_context_clone(secp256k1_ecmult_gen_context *dst,\n-                                               const secp256k1_ecmult_gen_context* src, const secp256k1_callback* cb);\n+static void secp256k1_ecmult_gen_context_build(secp256k1_ecmult_gen_context* ctx, void **prealloc);\n+static void secp256k1_ecmult_gen_context_finalize_memcpy(secp256k1_ecmult_gen_context *dst, const secp256k1_ecmult_gen_context* src);\n static void secp256k1_ecmult_gen_context_clear(secp256k1_ecmult_gen_context* ctx);\n static int secp256k1_ecmult_gen_context_is_built(const secp256k1_ecmult_gen_context* ctx);\n "
      },
      {
        "sha": "30ac16518bf4872cca6fe7d783851d59b0164230",
        "filename": "src/secp256k1/src/ecmult_gen_impl.h",
        "status": "modified",
        "additions": 48,
        "deletions": 50,
        "changes": 98,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/ecmult_gen_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/ecmult_gen_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecmult_gen_impl.h?ref=8903a1a0a78a705402123d2a5c465217cb9d791c",
        "patch": "@@ -7,30 +7,40 @@\n #ifndef SECP256K1_ECMULT_GEN_IMPL_H\n #define SECP256K1_ECMULT_GEN_IMPL_H\n \n+#include \"util.h\"\n #include \"scalar.h\"\n #include \"group.h\"\n #include \"ecmult_gen.h\"\n #include \"hash_impl.h\"\n #ifdef USE_ECMULT_STATIC_PRECOMPUTATION\n #include \"ecmult_static_context.h\"\n #endif\n+\n+#ifndef USE_ECMULT_STATIC_PRECOMPUTATION\n+    static const size_t SECP256K1_ECMULT_GEN_CONTEXT_PREALLOCATED_SIZE = ROUND_TO_ALIGN(sizeof(*((secp256k1_ecmult_gen_context*) NULL)->prec));\n+#else\n+    static const size_t SECP256K1_ECMULT_GEN_CONTEXT_PREALLOCATED_SIZE = 0;\n+#endif\n+\n static void secp256k1_ecmult_gen_context_init(secp256k1_ecmult_gen_context *ctx) {\n     ctx->prec = NULL;\n }\n \n-static void secp256k1_ecmult_gen_context_build(secp256k1_ecmult_gen_context *ctx, const secp256k1_callback* cb) {\n+static void secp256k1_ecmult_gen_context_build(secp256k1_ecmult_gen_context *ctx, void **prealloc) {\n #ifndef USE_ECMULT_STATIC_PRECOMPUTATION\n-    secp256k1_ge prec[1024];\n+    secp256k1_ge prec[ECMULT_GEN_PREC_N * ECMULT_GEN_PREC_G];\n     secp256k1_gej gj;\n     secp256k1_gej nums_gej;\n     int i, j;\n+    size_t const prealloc_size = SECP256K1_ECMULT_GEN_CONTEXT_PREALLOCATED_SIZE;\n+    void* const base = *prealloc;\n #endif\n \n     if (ctx->prec != NULL) {\n         return;\n     }\n #ifndef USE_ECMULT_STATIC_PRECOMPUTATION\n-    ctx->prec = (secp256k1_ge_storage (*)[64][16])checked_malloc(cb, sizeof(*ctx->prec));\n+    ctx->prec = (secp256k1_ge_storage (*)[ECMULT_GEN_PREC_N][ECMULT_GEN_PREC_G])manual_alloc(prealloc, prealloc_size, base, prealloc_size);\n \n     /* get the generator */\n     secp256k1_gej_set_ge(&gj, &secp256k1_ge_const_g);\n@@ -54,39 +64,39 @@ static void secp256k1_ecmult_gen_context_build(secp256k1_ecmult_gen_context *ctx\n \n     /* compute prec. */\n     {\n-        secp256k1_gej precj[1024]; /* Jacobian versions of prec. */\n+        secp256k1_gej precj[ECMULT_GEN_PREC_N * ECMULT_GEN_PREC_G]; /* Jacobian versions of prec. */\n         secp256k1_gej gbase;\n         secp256k1_gej numsbase;\n-        gbase = gj; /* 16^j * G */\n+        gbase = gj; /* PREC_G^j * G */\n         numsbase = nums_gej; /* 2^j * nums. */\n-        for (j = 0; j < 64; j++) {\n-            /* Set precj[j*16 .. j*16+15] to (numsbase, numsbase + gbase, ..., numsbase + 15*gbase). */\n-            precj[j*16] = numsbase;\n-            for (i = 1; i < 16; i++) {\n-                secp256k1_gej_add_var(&precj[j*16 + i], &precj[j*16 + i - 1], &gbase, NULL);\n+        for (j = 0; j < ECMULT_GEN_PREC_N; j++) {\n+            /* Set precj[j*PREC_G .. j*PREC_G+(PREC_G-1)] to (numsbase, numsbase + gbase, ..., numsbase + (PREC_G-1)*gbase). */\n+            precj[j*ECMULT_GEN_PREC_G] = numsbase;\n+            for (i = 1; i < ECMULT_GEN_PREC_G; i++) {\n+                secp256k1_gej_add_var(&precj[j*ECMULT_GEN_PREC_G + i], &precj[j*ECMULT_GEN_PREC_G + i - 1], &gbase, NULL);\n             }\n-            /* Multiply gbase by 16. */\n-            for (i = 0; i < 4; i++) {\n+            /* Multiply gbase by PREC_G. */\n+            for (i = 0; i < ECMULT_GEN_PREC_B; i++) {\n                 secp256k1_gej_double_var(&gbase, &gbase, NULL);\n             }\n             /* Multiply numbase by 2. */\n             secp256k1_gej_double_var(&numsbase, &numsbase, NULL);\n-            if (j == 62) {\n+            if (j == ECMULT_GEN_PREC_N - 2) {\n                 /* In the last iteration, numsbase is (1 - 2^j) * nums instead. */\n                 secp256k1_gej_neg(&numsbase, &numsbase);\n                 secp256k1_gej_add_var(&numsbase, &numsbase, &nums_gej, NULL);\n             }\n         }\n-        secp256k1_ge_set_all_gej_var(prec, precj, 1024);\n+        secp256k1_ge_set_all_gej_var(prec, precj, ECMULT_GEN_PREC_N * ECMULT_GEN_PREC_G);\n     }\n-    for (j = 0; j < 64; j++) {\n-        for (i = 0; i < 16; i++) {\n-            secp256k1_ge_to_storage(&(*ctx->prec)[j][i], &prec[j*16 + i]);\n+    for (j = 0; j < ECMULT_GEN_PREC_N; j++) {\n+        for (i = 0; i < ECMULT_GEN_PREC_G; i++) {\n+            secp256k1_ge_to_storage(&(*ctx->prec)[j][i], &prec[j*ECMULT_GEN_PREC_G + i]);\n         }\n     }\n #else\n-    (void)cb;\n-    ctx->prec = (secp256k1_ge_storage (*)[64][16])secp256k1_ecmult_static_context;\n+    (void)prealloc;\n+    ctx->prec = (secp256k1_ge_storage (*)[ECMULT_GEN_PREC_N][ECMULT_GEN_PREC_G])secp256k1_ecmult_static_context;\n #endif\n     secp256k1_ecmult_gen_blind(ctx, NULL);\n }\n@@ -95,27 +105,18 @@ static int secp256k1_ecmult_gen_context_is_built(const secp256k1_ecmult_gen_cont\n     return ctx->prec != NULL;\n }\n \n-static void secp256k1_ecmult_gen_context_clone(secp256k1_ecmult_gen_context *dst,\n-                                               const secp256k1_ecmult_gen_context *src, const secp256k1_callback* cb) {\n-    if (src->prec == NULL) {\n-        dst->prec = NULL;\n-    } else {\n+static void secp256k1_ecmult_gen_context_finalize_memcpy(secp256k1_ecmult_gen_context *dst, const secp256k1_ecmult_gen_context *src) {\n #ifndef USE_ECMULT_STATIC_PRECOMPUTATION\n-        dst->prec = (secp256k1_ge_storage (*)[64][16])checked_malloc(cb, sizeof(*dst->prec));\n-        memcpy(dst->prec, src->prec, sizeof(*dst->prec));\n+    if (src->prec != NULL) {\n+        /* We cast to void* first to suppress a -Wcast-align warning. */\n+        dst->prec = (secp256k1_ge_storage (*)[ECMULT_GEN_PREC_N][ECMULT_GEN_PREC_G])(void*)((unsigned char*)dst + ((unsigned char*)src->prec - (unsigned char*)src));\n+    }\n #else\n-        (void)cb;\n-        dst->prec = src->prec;\n+    (void)dst, (void)src;\n #endif\n-        dst->initial = src->initial;\n-        dst->blind = src->blind;\n-    }\n }\n \n static void secp256k1_ecmult_gen_context_clear(secp256k1_ecmult_gen_context *ctx) {\n-#ifndef USE_ECMULT_STATIC_PRECOMPUTATION\n-    free(ctx->prec);\n-#endif\n     secp256k1_scalar_clear(&ctx->blind);\n     secp256k1_gej_clear(&ctx->initial);\n     ctx->prec = NULL;\n@@ -132,9 +133,9 @@ static void secp256k1_ecmult_gen(const secp256k1_ecmult_gen_context *ctx, secp25\n     /* Blind scalar/point multiplication by computing (n-b)G + bG instead of nG. */\n     secp256k1_scalar_add(&gnb, gn, &ctx->blind);\n     add.infinity = 0;\n-    for (j = 0; j < 64; j++) {\n-        bits = secp256k1_scalar_get_bits(&gnb, j * 4, 4);\n-        for (i = 0; i < 16; i++) {\n+    for (j = 0; j < ECMULT_GEN_PREC_N; j++) {\n+        bits = secp256k1_scalar_get_bits(&gnb, j * ECMULT_GEN_PREC_B, ECMULT_GEN_PREC_B);\n+        for (i = 0; i < ECMULT_GEN_PREC_G; i++) {\n             /** This uses a conditional move to avoid any secret data in array indexes.\n              *   _Any_ use of secret indexes has been demonstrated to result in timing\n              *   sidechannels, even when the cache-line access patterns are uniform.\n@@ -162,7 +163,7 @@ static void secp256k1_ecmult_gen_blind(secp256k1_ecmult_gen_context *ctx, const\n     secp256k1_fe s;\n     unsigned char nonce32[32];\n     secp256k1_rfc6979_hmac_sha256 rng;\n-    int retry;\n+    int overflow;\n     unsigned char keydata[64] = {0};\n     if (seed32 == NULL) {\n         /* When seed is NULL, reset the initial point and blinding value. */\n@@ -182,21 +183,18 @@ static void secp256k1_ecmult_gen_blind(secp256k1_ecmult_gen_context *ctx, const\n     }\n     secp256k1_rfc6979_hmac_sha256_initialize(&rng, keydata, seed32 ? 64 : 32);\n     memset(keydata, 0, sizeof(keydata));\n-    /* Retry for out of range results to achieve uniformity. */\n-    do {\n-        secp256k1_rfc6979_hmac_sha256_generate(&rng, nonce32, 32);\n-        retry = !secp256k1_fe_set_b32(&s, nonce32);\n-        retry |= secp256k1_fe_is_zero(&s);\n-    } while (retry); /* This branch true is cryptographically unreachable. Requires sha256_hmac output > Fp. */\n+    /* Accept unobservably small non-uniformity. */\n+    secp256k1_rfc6979_hmac_sha256_generate(&rng, nonce32, 32);\n+    overflow = !secp256k1_fe_set_b32(&s, nonce32);\n+    overflow |= secp256k1_fe_is_zero(&s);\n+    secp256k1_fe_cmov(&s, &secp256k1_fe_one, overflow);\n     /* Randomize the projection to defend against multiplier sidechannels. */\n     secp256k1_gej_rescale(&ctx->initial, &s);\n     secp256k1_fe_clear(&s);\n-    do {\n-        secp256k1_rfc6979_hmac_sha256_generate(&rng, nonce32, 32);\n-        secp256k1_scalar_set_b32(&b, nonce32, &retry);\n-        /* A blinding value of 0 works, but would undermine the projection hardening. */\n-        retry |= secp256k1_scalar_is_zero(&b);\n-    } while (retry); /* This branch true is cryptographically unreachable. Requires sha256_hmac output > order. */\n+    secp256k1_rfc6979_hmac_sha256_generate(&rng, nonce32, 32);\n+    secp256k1_scalar_set_b32(&b, nonce32, NULL);\n+    /* A blinding value of 0 works, but would undermine the projection hardening. */\n+    secp256k1_scalar_cmov(&b, &secp256k1_scalar_one, secp256k1_scalar_is_zero(&b));\n     secp256k1_rfc6979_hmac_sha256_finalize(&rng);\n     memset(nonce32, 0, 32);\n     secp256k1_ecmult_gen(ctx, &gb, &b);"
      },
      {
        "sha": "f03fa9469d73ba56be9486eee509fd95fac9d359",
        "filename": "src/secp256k1/src/ecmult_impl.h",
        "status": "modified",
        "additions": 109,
        "deletions": 74,
        "changes": 183,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/ecmult_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/ecmult_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecmult_impl.h?ref=8903a1a0a78a705402123d2a5c465217cb9d791c",
        "patch": "@@ -10,6 +10,7 @@\n #include <string.h>\n #include <stdint.h>\n \n+#include \"util.h\"\n #include \"group.h\"\n #include \"scalar.h\"\n #include \"ecmult.h\"\n@@ -30,16 +31,32 @@\n #  endif\n #else\n /* optimal for 128-bit and 256-bit exponents. */\n-#define WINDOW_A 5\n-/** larger numbers may result in slightly better performance, at the cost of\n-    exponentially larger precomputed tables. */\n-#ifdef USE_ENDOMORPHISM\n-/** Two tables for window size 15: 1.375 MiB. */\n-#define WINDOW_G 15\n-#else\n-/** One table for window size 16: 1.375 MiB. */\n-#define WINDOW_G 16\n+#  define WINDOW_A 5\n+/** Larger values for ECMULT_WINDOW_SIZE result in possibly better\n+ *  performance at the cost of an exponentially larger precomputed\n+ *  table. The exact table size is\n+ *      (1 << (WINDOW_G - 2)) * sizeof(secp256k1_ge_storage)  bytes,\n+ *  where sizeof(secp256k1_ge_storage) is typically 64 bytes but can\n+ *  be larger due to platform-specific padding and alignment.\n+ *  If the endomorphism optimization is enabled (USE_ENDOMORMPHSIM)\n+ *  two tables of this size are used instead of only one.\n+ */\n+#  define WINDOW_G ECMULT_WINDOW_SIZE\n #endif\n+\n+/* Noone will ever need more than a window size of 24. The code might\n+ * be correct for larger values of ECMULT_WINDOW_SIZE but this is not\n+ * not tested.\n+ *\n+ * The following limitations are known, and there are probably more:\n+ * If WINDOW_G > 27 and size_t has 32 bits, then the code is incorrect\n+ * because the size of the memory object that we allocate (in bytes)\n+ * will not fit in a size_t.\n+ * If WINDOW_G > 31 and int has 32 bits, then the code is incorrect\n+ * because certain expressions will overflow.\n+ */\n+#if ECMULT_WINDOW_SIZE < 2 || ECMULT_WINDOW_SIZE > 24\n+#  error Set ECMULT_WINDOW_SIZE to an integer in range [2..24].\n #endif\n \n #ifdef USE_ENDOMORPHISM\n@@ -121,7 +138,7 @@ static void secp256k1_ecmult_odd_multiples_table(int n, secp256k1_gej *prej, sec\n  *    It only operates on tables sized for WINDOW_A wnaf multiples.\n  *  - secp256k1_ecmult_odd_multiples_table_storage_var, which converts its\n  *    resulting point set to actually affine points, and stores those in pre.\n- *    It operates on tables of any size, but uses heap-allocated temporaries.\n+ *    It operates on tables of any size.\n  *\n  *  To compute a*P + b*G, we compute a table for P using the first function,\n  *  and for G using the second (which requires an inverse, but it only needs to\n@@ -294,15 +311,24 @@ static void secp256k1_ecmult_odd_multiples_table_storage_var(const int n, secp25\n     } \\\n } while(0)\n \n+static const size_t SECP256K1_ECMULT_CONTEXT_PREALLOCATED_SIZE =\n+    ROUND_TO_ALIGN(sizeof((*((secp256k1_ecmult_context*) NULL)->pre_g)[0]) * ECMULT_TABLE_SIZE(WINDOW_G))\n+#ifdef USE_ENDOMORPHISM\n+    + ROUND_TO_ALIGN(sizeof((*((secp256k1_ecmult_context*) NULL)->pre_g_128)[0]) * ECMULT_TABLE_SIZE(WINDOW_G))\n+#endif\n+    ;\n+\n static void secp256k1_ecmult_context_init(secp256k1_ecmult_context *ctx) {\n     ctx->pre_g = NULL;\n #ifdef USE_ENDOMORPHISM\n     ctx->pre_g_128 = NULL;\n #endif\n }\n \n-static void secp256k1_ecmult_context_build(secp256k1_ecmult_context *ctx, const secp256k1_callback *cb) {\n+static void secp256k1_ecmult_context_build(secp256k1_ecmult_context *ctx, void **prealloc) {\n     secp256k1_gej gj;\n+    void* const base = *prealloc;\n+    size_t const prealloc_size = SECP256K1_ECMULT_CONTEXT_PREALLOCATED_SIZE;\n \n     if (ctx->pre_g != NULL) {\n         return;\n@@ -311,7 +337,12 @@ static void secp256k1_ecmult_context_build(secp256k1_ecmult_context *ctx, const\n     /* get the generator */\n     secp256k1_gej_set_ge(&gj, &secp256k1_ge_const_g);\n \n-    ctx->pre_g = (secp256k1_ge_storage (*)[])checked_malloc(cb, sizeof((*ctx->pre_g)[0]) * ECMULT_TABLE_SIZE(WINDOW_G));\n+    {\n+        size_t size = sizeof((*ctx->pre_g)[0]) * ((size_t)ECMULT_TABLE_SIZE(WINDOW_G));\n+        /* check for overflow */\n+        VERIFY_CHECK(size / sizeof((*ctx->pre_g)[0]) == ((size_t)ECMULT_TABLE_SIZE(WINDOW_G)));\n+        ctx->pre_g = (secp256k1_ge_storage (*)[])manual_alloc(prealloc, sizeof((*ctx->pre_g)[0]) * ECMULT_TABLE_SIZE(WINDOW_G), base, prealloc_size);\n+    }\n \n     /* precompute the tables with odd multiples */\n     secp256k1_ecmult_odd_multiples_table_storage_var(ECMULT_TABLE_SIZE(WINDOW_G), *ctx->pre_g, &gj);\n@@ -321,7 +352,10 @@ static void secp256k1_ecmult_context_build(secp256k1_ecmult_context *ctx, const\n         secp256k1_gej g_128j;\n         int i;\n \n-        ctx->pre_g_128 = (secp256k1_ge_storage (*)[])checked_malloc(cb, sizeof((*ctx->pre_g_128)[0]) * ECMULT_TABLE_SIZE(WINDOW_G));\n+        size_t size = sizeof((*ctx->pre_g_128)[0]) * ((size_t) ECMULT_TABLE_SIZE(WINDOW_G));\n+        /* check for overflow */\n+        VERIFY_CHECK(size / sizeof((*ctx->pre_g_128)[0]) == ((size_t)ECMULT_TABLE_SIZE(WINDOW_G)));\n+        ctx->pre_g_128 = (secp256k1_ge_storage (*)[])manual_alloc(prealloc, sizeof((*ctx->pre_g_128)[0]) * ECMULT_TABLE_SIZE(WINDOW_G), base, prealloc_size);\n \n         /* calculate 2^128*generator */\n         g_128j = gj;\n@@ -333,22 +367,14 @@ static void secp256k1_ecmult_context_build(secp256k1_ecmult_context *ctx, const\n #endif\n }\n \n-static void secp256k1_ecmult_context_clone(secp256k1_ecmult_context *dst,\n-                                           const secp256k1_ecmult_context *src, const secp256k1_callback *cb) {\n-    if (src->pre_g == NULL) {\n-        dst->pre_g = NULL;\n-    } else {\n-        size_t size = sizeof((*dst->pre_g)[0]) * ECMULT_TABLE_SIZE(WINDOW_G);\n-        dst->pre_g = (secp256k1_ge_storage (*)[])checked_malloc(cb, size);\n-        memcpy(dst->pre_g, src->pre_g, size);\n+static void secp256k1_ecmult_context_finalize_memcpy(secp256k1_ecmult_context *dst, const secp256k1_ecmult_context *src) {\n+    if (src->pre_g != NULL) {\n+        /* We cast to void* first to suppress a -Wcast-align warning. */\n+        dst->pre_g = (secp256k1_ge_storage (*)[])(void*)((unsigned char*)dst + ((unsigned char*)(src->pre_g) - (unsigned char*)src));\n     }\n #ifdef USE_ENDOMORPHISM\n-    if (src->pre_g_128 == NULL) {\n-        dst->pre_g_128 = NULL;\n-    } else {\n-        size_t size = sizeof((*dst->pre_g_128)[0]) * ECMULT_TABLE_SIZE(WINDOW_G);\n-        dst->pre_g_128 = (secp256k1_ge_storage (*)[])checked_malloc(cb, size);\n-        memcpy(dst->pre_g_128, src->pre_g_128, size);\n+    if (src->pre_g_128 != NULL) {\n+        dst->pre_g_128 = (secp256k1_ge_storage (*)[])(void*)((unsigned char*)dst + ((unsigned char*)(src->pre_g_128) - (unsigned char*)src));\n     }\n #endif\n }\n@@ -358,10 +384,6 @@ static int secp256k1_ecmult_context_is_built(const secp256k1_ecmult_context *ctx\n }\n \n static void secp256k1_ecmult_context_clear(secp256k1_ecmult_context *ctx) {\n-    free(ctx->pre_g);\n-#ifdef USE_ENDOMORPHISM\n-    free(ctx->pre_g_128);\n-#endif\n     secp256k1_ecmult_context_init(ctx);\n }\n \n@@ -373,7 +395,7 @@ static void secp256k1_ecmult_context_clear(secp256k1_ecmult_context *ctx) {\n  *    than the number of bits in the (absolute value) of the input.\n  */\n static int secp256k1_ecmult_wnaf(int *wnaf, int len, const secp256k1_scalar *a, int w) {\n-    secp256k1_scalar s = *a;\n+    secp256k1_scalar s;\n     int last_set_bit = -1;\n     int bit = 0;\n     int sign = 1;\n@@ -386,6 +408,7 @@ static int secp256k1_ecmult_wnaf(int *wnaf, int len, const secp256k1_scalar *a,\n \n     memset(wnaf, 0, len * sizeof(wnaf[0]));\n \n+    s = *a;\n     if (secp256k1_scalar_get_bits(&s, 255, 1)) {\n         secp256k1_scalar_negate(&s, &s);\n         sign = -1;\n@@ -418,7 +441,7 @@ static int secp256k1_ecmult_wnaf(int *wnaf, int len, const secp256k1_scalar *a,\n     CHECK(carry == 0);\n     while (bit < 256) {\n         CHECK(secp256k1_scalar_get_bits(&s, bit++, 1) == 0);\n-    } \n+    }\n #endif\n     return last_set_bit + 1;\n }\n@@ -626,52 +649,55 @@ static size_t secp256k1_strauss_scratch_size(size_t n_points) {\n     return n_points*point_size;\n }\n \n-static int secp256k1_ecmult_strauss_batch(const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n+static int secp256k1_ecmult_strauss_batch(const secp256k1_callback* error_callback, const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n     secp256k1_gej* points;\n     secp256k1_scalar* scalars;\n     struct secp256k1_strauss_state state;\n     size_t i;\n+    const size_t scratch_checkpoint = secp256k1_scratch_checkpoint(error_callback, scratch);\n \n     secp256k1_gej_set_infinity(r);\n     if (inp_g_sc == NULL && n_points == 0) {\n         return 1;\n     }\n \n-    if (!secp256k1_scratch_allocate_frame(scratch, secp256k1_strauss_scratch_size(n_points), STRAUSS_SCRATCH_OBJECTS)) {\n-        return 0;\n-    }\n-    points = (secp256k1_gej*)secp256k1_scratch_alloc(scratch, n_points * sizeof(secp256k1_gej));\n-    scalars = (secp256k1_scalar*)secp256k1_scratch_alloc(scratch, n_points * sizeof(secp256k1_scalar));\n-    state.prej = (secp256k1_gej*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_gej));\n-    state.zr = (secp256k1_fe*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_fe));\n+    points = (secp256k1_gej*)secp256k1_scratch_alloc(error_callback, scratch, n_points * sizeof(secp256k1_gej));\n+    scalars = (secp256k1_scalar*)secp256k1_scratch_alloc(error_callback, scratch, n_points * sizeof(secp256k1_scalar));\n+    state.prej = (secp256k1_gej*)secp256k1_scratch_alloc(error_callback, scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_gej));\n+    state.zr = (secp256k1_fe*)secp256k1_scratch_alloc(error_callback, scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_fe));\n #ifdef USE_ENDOMORPHISM\n-    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(scratch, n_points * 2 * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n+    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(error_callback, scratch, n_points * 2 * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n     state.pre_a_lam = state.pre_a + n_points * ECMULT_TABLE_SIZE(WINDOW_A);\n #else\n-    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n+    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(error_callback, scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n #endif\n-    state.ps = (struct secp256k1_strauss_point_state*)secp256k1_scratch_alloc(scratch, n_points * sizeof(struct secp256k1_strauss_point_state));\n+    state.ps = (struct secp256k1_strauss_point_state*)secp256k1_scratch_alloc(error_callback, scratch, n_points * sizeof(struct secp256k1_strauss_point_state));\n+\n+    if (points == NULL || scalars == NULL || state.prej == NULL || state.zr == NULL || state.pre_a == NULL) {\n+        secp256k1_scratch_apply_checkpoint(error_callback, scratch, scratch_checkpoint);\n+        return 0;\n+    }\n \n     for (i = 0; i < n_points; i++) {\n         secp256k1_ge point;\n         if (!cb(&scalars[i], &point, i+cb_offset, cbdata)) {\n-            secp256k1_scratch_deallocate_frame(scratch);\n+            secp256k1_scratch_apply_checkpoint(error_callback, scratch, scratch_checkpoint);\n             return 0;\n         }\n         secp256k1_gej_set_ge(&points[i], &point);\n     }\n     secp256k1_ecmult_strauss_wnaf(ctx, &state, r, n_points, points, scalars, inp_g_sc);\n-    secp256k1_scratch_deallocate_frame(scratch);\n+    secp256k1_scratch_apply_checkpoint(error_callback, scratch, scratch_checkpoint);\n     return 1;\n }\n \n /* Wrapper for secp256k1_ecmult_multi_func interface */\n-static int secp256k1_ecmult_strauss_batch_single(const secp256k1_ecmult_context *actx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n-    return secp256k1_ecmult_strauss_batch(actx, scratch, r, inp_g_sc, cb, cbdata, n, 0);\n+static int secp256k1_ecmult_strauss_batch_single(const secp256k1_callback* error_callback, const secp256k1_ecmult_context *actx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n+    return secp256k1_ecmult_strauss_batch(error_callback, actx, scratch, r, inp_g_sc, cb, cbdata, n, 0);\n }\n \n-static size_t secp256k1_strauss_max_points(secp256k1_scratch *scratch) {\n-    return secp256k1_scratch_max_allocation(scratch, STRAUSS_SCRATCH_OBJECTS) / secp256k1_strauss_scratch_size(1);\n+static size_t secp256k1_strauss_max_points(const secp256k1_callback* error_callback, secp256k1_scratch *scratch) {\n+    return secp256k1_scratch_max_allocation(error_callback, scratch, STRAUSS_SCRATCH_OBJECTS) / secp256k1_strauss_scratch_size(1);\n }\n \n /** Convert a number to WNAF notation.\n@@ -963,7 +989,8 @@ static size_t secp256k1_pippenger_scratch_size(size_t n_points, int bucket_windo\n     return (sizeof(secp256k1_gej) << bucket_window) + sizeof(struct secp256k1_pippenger_state) + entries * entry_size;\n }\n \n-static int secp256k1_ecmult_pippenger_batch(const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n+static int secp256k1_ecmult_pippenger_batch(const secp256k1_callback* error_callback, const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n+    const size_t scratch_checkpoint = secp256k1_scratch_checkpoint(error_callback, scratch);\n     /* Use 2(n+1) with the endomorphism, n+1 without, when calculating batch\n      * sizes. The reason for +1 is that we add the G scalar to the list of\n      * other scalars. */\n@@ -988,15 +1015,21 @@ static int secp256k1_ecmult_pippenger_batch(const secp256k1_ecmult_context *ctx,\n     }\n \n     bucket_window = secp256k1_pippenger_bucket_window(n_points);\n-    if (!secp256k1_scratch_allocate_frame(scratch, secp256k1_pippenger_scratch_size(n_points, bucket_window), PIPPENGER_SCRATCH_OBJECTS)) {\n+    points = (secp256k1_ge *) secp256k1_scratch_alloc(error_callback, scratch, entries * sizeof(*points));\n+    scalars = (secp256k1_scalar *) secp256k1_scratch_alloc(error_callback, scratch, entries * sizeof(*scalars));\n+    state_space = (struct secp256k1_pippenger_state *) secp256k1_scratch_alloc(error_callback, scratch, sizeof(*state_space));\n+    if (points == NULL || scalars == NULL || state_space == NULL) {\n+        secp256k1_scratch_apply_checkpoint(error_callback, scratch, scratch_checkpoint);\n+        return 0;\n+    }\n+\n+    state_space->ps = (struct secp256k1_pippenger_point_state *) secp256k1_scratch_alloc(error_callback, scratch, entries * sizeof(*state_space->ps));\n+    state_space->wnaf_na = (int *) secp256k1_scratch_alloc(error_callback, scratch, entries*(WNAF_SIZE(bucket_window+1)) * sizeof(int));\n+    buckets = (secp256k1_gej *) secp256k1_scratch_alloc(error_callback, scratch, (1<<bucket_window) * sizeof(*buckets));\n+    if (state_space->ps == NULL || state_space->wnaf_na == NULL || buckets == NULL) {\n+        secp256k1_scratch_apply_checkpoint(error_callback, scratch, scratch_checkpoint);\n         return 0;\n     }\n-    points = (secp256k1_ge *) secp256k1_scratch_alloc(scratch, entries * sizeof(*points));\n-    scalars = (secp256k1_scalar *) secp256k1_scratch_alloc(scratch, entries * sizeof(*scalars));\n-    state_space = (struct secp256k1_pippenger_state *) secp256k1_scratch_alloc(scratch, sizeof(*state_space));\n-    state_space->ps = (struct secp256k1_pippenger_point_state *) secp256k1_scratch_alloc(scratch, entries * sizeof(*state_space->ps));\n-    state_space->wnaf_na = (int *) secp256k1_scratch_alloc(scratch, entries*(WNAF_SIZE(bucket_window+1)) * sizeof(int));\n-    buckets = (secp256k1_gej *) secp256k1_scratch_alloc(scratch, sizeof(*buckets) << bucket_window);\n \n     if (inp_g_sc != NULL) {\n         scalars[0] = *inp_g_sc;\n@@ -1010,7 +1043,7 @@ static int secp256k1_ecmult_pippenger_batch(const secp256k1_ecmult_context *ctx,\n \n     while (point_idx < n_points) {\n         if (!cb(&scalars[idx], &points[idx], point_idx + cb_offset, cbdata)) {\n-            secp256k1_scratch_deallocate_frame(scratch);\n+            secp256k1_scratch_apply_checkpoint(error_callback, scratch, scratch_checkpoint);\n             return 0;\n         }\n         idx++;\n@@ -1034,22 +1067,22 @@ static int secp256k1_ecmult_pippenger_batch(const secp256k1_ecmult_context *ctx,\n     for(i = 0; i < 1<<bucket_window; i++) {\n         secp256k1_gej_clear(&buckets[i]);\n     }\n-    secp256k1_scratch_deallocate_frame(scratch);\n+    secp256k1_scratch_apply_checkpoint(error_callback, scratch, scratch_checkpoint);\n     return 1;\n }\n \n /* Wrapper for secp256k1_ecmult_multi_func interface */\n-static int secp256k1_ecmult_pippenger_batch_single(const secp256k1_ecmult_context *actx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n-    return secp256k1_ecmult_pippenger_batch(actx, scratch, r, inp_g_sc, cb, cbdata, n, 0);\n+static int secp256k1_ecmult_pippenger_batch_single(const secp256k1_callback* error_callback, const secp256k1_ecmult_context *actx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n+    return secp256k1_ecmult_pippenger_batch(error_callback, actx, scratch, r, inp_g_sc, cb, cbdata, n, 0);\n }\n \n /**\n  * Returns the maximum number of points in addition to G that can be used with\n  * a given scratch space. The function ensures that fewer points may also be\n  * used.\n  */\n-static size_t secp256k1_pippenger_max_points(secp256k1_scratch *scratch) {\n-    size_t max_alloc = secp256k1_scratch_max_allocation(scratch, PIPPENGER_SCRATCH_OBJECTS);\n+static size_t secp256k1_pippenger_max_points(const secp256k1_callback* error_callback, secp256k1_scratch *scratch) {\n+    size_t max_alloc = secp256k1_scratch_max_allocation(error_callback, scratch, PIPPENGER_SCRATCH_OBJECTS);\n     int bucket_window;\n     size_t res = 0;\n \n@@ -1131,11 +1164,11 @@ static int secp256k1_ecmult_multi_batch_size_helper(size_t *n_batches, size_t *n\n     return 1;\n }\n \n-typedef int (*secp256k1_ecmult_multi_func)(const secp256k1_ecmult_context*, secp256k1_scratch*, secp256k1_gej*, const secp256k1_scalar*, secp256k1_ecmult_multi_callback cb, void*, size_t);\n-static int secp256k1_ecmult_multi_var(const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n+typedef int (*secp256k1_ecmult_multi_func)(const secp256k1_callback* error_callback, const secp256k1_ecmult_context*, secp256k1_scratch*, secp256k1_gej*, const secp256k1_scalar*, secp256k1_ecmult_multi_callback cb, void*, size_t);\n+static int secp256k1_ecmult_multi_var(const secp256k1_callback* error_callback, const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n     size_t i;\n \n-    int (*f)(const secp256k1_ecmult_context*, secp256k1_scratch*, secp256k1_gej*, const secp256k1_scalar*, secp256k1_ecmult_multi_callback cb, void*, size_t, size_t);\n+    int (*f)(const secp256k1_callback* error_callback, const secp256k1_ecmult_context*, secp256k1_scratch*, secp256k1_gej*, const secp256k1_scalar*, secp256k1_ecmult_multi_callback cb, void*, size_t, size_t);\n     size_t n_batches;\n     size_t n_batch_points;\n \n@@ -1152,24 +1185,26 @@ static int secp256k1_ecmult_multi_var(const secp256k1_ecmult_context *ctx, secp2\n         return secp256k1_ecmult_multi_simple_var(ctx, r, inp_g_sc, cb, cbdata, n);\n     }\n \n-    /* Compute the batch sizes for pippenger given a scratch space. If it's greater than a threshold\n-     * use pippenger. Otherwise use strauss */\n-    if (!secp256k1_ecmult_multi_batch_size_helper(&n_batches, &n_batch_points, secp256k1_pippenger_max_points(scratch), n)) {\n-        return 0;\n+    /* Compute the batch sizes for Pippenger's algorithm given a scratch space. If it's greater than\n+     * a threshold use Pippenger's algorithm. Otherwise use Strauss' algorithm.\n+     * As a first step check if there's enough space for Pippenger's algo (which requires less space\n+     * than Strauss' algo) and if not, use the simple algorithm. */\n+    if (!secp256k1_ecmult_multi_batch_size_helper(&n_batches, &n_batch_points, secp256k1_pippenger_max_points(error_callback, scratch), n)) {\n+        return secp256k1_ecmult_multi_simple_var(ctx, r, inp_g_sc, cb, cbdata, n);\n     }\n     if (n_batch_points >= ECMULT_PIPPENGER_THRESHOLD) {\n         f = secp256k1_ecmult_pippenger_batch;\n     } else {\n-        if (!secp256k1_ecmult_multi_batch_size_helper(&n_batches, &n_batch_points, secp256k1_strauss_max_points(scratch), n)) {\n-            return 0;\n+        if (!secp256k1_ecmult_multi_batch_size_helper(&n_batches, &n_batch_points, secp256k1_strauss_max_points(error_callback, scratch), n)) {\n+            return secp256k1_ecmult_multi_simple_var(ctx, r, inp_g_sc, cb, cbdata, n);\n         }\n         f = secp256k1_ecmult_strauss_batch;\n     }\n     for(i = 0; i < n_batches; i++) {\n         size_t nbp = n < n_batch_points ? n : n_batch_points;\n         size_t offset = n_batch_points*i;\n         secp256k1_gej tmp;\n-        if (!f(ctx, scratch, &tmp, i == 0 ? inp_g_sc : NULL, cb, cbdata, nbp, offset)) {\n+        if (!f(error_callback, ctx, scratch, &tmp, i == 0 ? inp_g_sc : NULL, cb, cbdata, nbp, offset)) {\n             return 0;\n         }\n         secp256k1_gej_add_var(r, r, &tmp, NULL);"
      },
      {
        "sha": "7993a1f11e32db30af819f128271658a829e04dc",
        "filename": "src/secp256k1/src/field.h",
        "status": "modified",
        "additions": 6,
        "deletions": 4,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/field.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/field.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field.h?ref=8903a1a0a78a705402123d2a5c465217cb9d791c",
        "patch": "@@ -32,10 +32,12 @@\n \n #include \"util.h\"\n \n-/** Normalize a field element. */\n+/** Normalize a field element. This brings the field element to a canonical representation, reduces\n+ *  its magnitude to 1, and reduces it modulo field size `p`.\n+ */\n static void secp256k1_fe_normalize(secp256k1_fe *r);\n \n-/** Weakly normalize a field element: reduce it magnitude to 1, but don't fully normalize. */\n+/** Weakly normalize a field element: reduce its magnitude to 1, but don't fully normalize. */\n static void secp256k1_fe_normalize_weak(secp256k1_fe *r);\n \n /** Normalize a field element, without constant-time guarantee. */\n@@ -123,10 +125,10 @@ static void secp256k1_fe_to_storage(secp256k1_fe_storage *r, const secp256k1_fe\n /** Convert a field element back from the storage type. */\n static void secp256k1_fe_from_storage(secp256k1_fe *r, const secp256k1_fe_storage *a);\n \n-/** If flag is true, set *r equal to *a; otherwise leave it. Constant-time. */\n+/** If flag is true, set *r equal to *a; otherwise leave it. Constant-time.  Both *r and *a must be initialized.*/\n static void secp256k1_fe_storage_cmov(secp256k1_fe_storage *r, const secp256k1_fe_storage *a, int flag);\n \n-/** If flag is true, set *r equal to *a; otherwise leave it. Constant-time. */\n+/** If flag is true, set *r equal to *a; otherwise leave it. Constant-time.  Both *r and *a must be initialized.*/\n static void secp256k1_fe_cmov(secp256k1_fe *r, const secp256k1_fe *a, int flag);\n \n #endif /* SECP256K1_FIELD_H */"
      },
      {
        "sha": "651500ee8eb90bdf54e058ea201ab4da1c912fd4",
        "filename": "src/secp256k1/src/field_10x26_impl.h",
        "status": "modified",
        "additions": 13,
        "deletions": 8,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/field_10x26_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/field_10x26_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field_10x26_impl.h?ref=8903a1a0a78a705402123d2a5c465217cb9d791c",
        "patch": "@@ -320,6 +320,7 @@ static int secp256k1_fe_cmp_var(const secp256k1_fe *a, const secp256k1_fe *b) {\n }\n \n static int secp256k1_fe_set_b32(secp256k1_fe *r, const unsigned char *a) {\n+    int ret;\n     r->n[0] = (uint32_t)a[31] | ((uint32_t)a[30] << 8) | ((uint32_t)a[29] << 16) | ((uint32_t)(a[28] & 0x3) << 24);\n     r->n[1] = (uint32_t)((a[28] >> 2) & 0x3f) | ((uint32_t)a[27] << 6) | ((uint32_t)a[26] << 14) | ((uint32_t)(a[25] & 0xf) << 22);\n     r->n[2] = (uint32_t)((a[25] >> 4) & 0xf) | ((uint32_t)a[24] << 4) | ((uint32_t)a[23] << 12) | ((uint32_t)(a[22] & 0x3f) << 20);\n@@ -331,15 +332,17 @@ static int secp256k1_fe_set_b32(secp256k1_fe *r, const unsigned char *a) {\n     r->n[8] = (uint32_t)a[5] | ((uint32_t)a[4] << 8) | ((uint32_t)a[3] << 16) | ((uint32_t)(a[2] & 0x3) << 24);\n     r->n[9] = (uint32_t)((a[2] >> 2) & 0x3f) | ((uint32_t)a[1] << 6) | ((uint32_t)a[0] << 14);\n \n-    if (r->n[9] == 0x3FFFFFUL && (r->n[8] & r->n[7] & r->n[6] & r->n[5] & r->n[4] & r->n[3] & r->n[2]) == 0x3FFFFFFUL && (r->n[1] + 0x40UL + ((r->n[0] + 0x3D1UL) >> 26)) > 0x3FFFFFFUL) {\n-        return 0;\n-    }\n+    ret = !((r->n[9] == 0x3FFFFFUL) & ((r->n[8] & r->n[7] & r->n[6] & r->n[5] & r->n[4] & r->n[3] & r->n[2]) == 0x3FFFFFFUL) & ((r->n[1] + 0x40UL + ((r->n[0] + 0x3D1UL) >> 26)) > 0x3FFFFFFUL));\n #ifdef VERIFY\n     r->magnitude = 1;\n-    r->normalized = 1;\n-    secp256k1_fe_verify(r);\n+    if (ret) {\n+        r->normalized = 1;\n+        secp256k1_fe_verify(r);\n+    } else {\n+        r->normalized = 0;\n+    }\n #endif\n-    return 1;\n+    return ret;\n }\n \n /** Convert a field element to a 32-byte big endian value. Requires the input to be normalized */\n@@ -1094,6 +1097,7 @@ static void secp256k1_fe_sqr(secp256k1_fe *r, const secp256k1_fe *a) {\n \n static SECP256K1_INLINE void secp256k1_fe_cmov(secp256k1_fe *r, const secp256k1_fe *a, int flag) {\n     uint32_t mask0, mask1;\n+    VG_CHECK_VERIFY(r->n, sizeof(r->n));\n     mask0 = flag + ~((uint32_t)0);\n     mask1 = ~mask0;\n     r->n[0] = (r->n[0] & mask0) | (a->n[0] & mask1);\n@@ -1107,15 +1111,16 @@ static SECP256K1_INLINE void secp256k1_fe_cmov(secp256k1_fe *r, const secp256k1_\n     r->n[8] = (r->n[8] & mask0) | (a->n[8] & mask1);\n     r->n[9] = (r->n[9] & mask0) | (a->n[9] & mask1);\n #ifdef VERIFY\n-    if (a->magnitude > r->magnitude) {\n+    if (flag) {\n         r->magnitude = a->magnitude;\n+        r->normalized = a->normalized;\n     }\n-    r->normalized &= a->normalized;\n #endif\n }\n \n static SECP256K1_INLINE void secp256k1_fe_storage_cmov(secp256k1_fe_storage *r, const secp256k1_fe_storage *a, int flag) {\n     uint32_t mask0, mask1;\n+    VG_CHECK_VERIFY(r->n, sizeof(r->n));\n     mask0 = flag + ~((uint32_t)0);\n     mask1 = ~mask0;\n     r->n[0] = (r->n[0] & mask0) | (a->n[0] & mask1);"
      },
      {
        "sha": "71a38f915b2f462cd2ac6c8a749a62689a490408",
        "filename": "src/secp256k1/src/field_5x52_impl.h",
        "status": "modified",
        "additions": 13,
        "deletions": 8,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/field_5x52_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/field_5x52_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field_5x52_impl.h?ref=8903a1a0a78a705402123d2a5c465217cb9d791c",
        "patch": "@@ -283,6 +283,7 @@ static int secp256k1_fe_cmp_var(const secp256k1_fe *a, const secp256k1_fe *b) {\n }\n \n static int secp256k1_fe_set_b32(secp256k1_fe *r, const unsigned char *a) {\n+    int ret;\n     r->n[0] = (uint64_t)a[31]\n             | ((uint64_t)a[30] << 8)\n             | ((uint64_t)a[29] << 16)\n@@ -317,15 +318,17 @@ static int secp256k1_fe_set_b32(secp256k1_fe *r, const unsigned char *a) {\n             | ((uint64_t)a[2] << 24)\n             | ((uint64_t)a[1] << 32)\n             | ((uint64_t)a[0] << 40);\n-    if (r->n[4] == 0x0FFFFFFFFFFFFULL && (r->n[3] & r->n[2] & r->n[1]) == 0xFFFFFFFFFFFFFULL && r->n[0] >= 0xFFFFEFFFFFC2FULL) {\n-        return 0;\n-    }\n+    ret = !((r->n[4] == 0x0FFFFFFFFFFFFULL) & ((r->n[3] & r->n[2] & r->n[1]) == 0xFFFFFFFFFFFFFULL) & (r->n[0] >= 0xFFFFEFFFFFC2FULL));\n #ifdef VERIFY\n     r->magnitude = 1;\n-    r->normalized = 1;\n-    secp256k1_fe_verify(r);\n+    if (ret) {\n+        r->normalized = 1;\n+        secp256k1_fe_verify(r);\n+    } else {\n+        r->normalized = 0;\n+    }\n #endif\n-    return 1;\n+    return ret;\n }\n \n /** Convert a field element to a 32-byte big endian value. Requires the input to be normalized */\n@@ -446,6 +449,7 @@ static void secp256k1_fe_sqr(secp256k1_fe *r, const secp256k1_fe *a) {\n \n static SECP256K1_INLINE void secp256k1_fe_cmov(secp256k1_fe *r, const secp256k1_fe *a, int flag) {\n     uint64_t mask0, mask1;\n+    VG_CHECK_VERIFY(r->n, sizeof(r->n));\n     mask0 = flag + ~((uint64_t)0);\n     mask1 = ~mask0;\n     r->n[0] = (r->n[0] & mask0) | (a->n[0] & mask1);\n@@ -454,15 +458,16 @@ static SECP256K1_INLINE void secp256k1_fe_cmov(secp256k1_fe *r, const secp256k1_\n     r->n[3] = (r->n[3] & mask0) | (a->n[3] & mask1);\n     r->n[4] = (r->n[4] & mask0) | (a->n[4] & mask1);\n #ifdef VERIFY\n-    if (a->magnitude > r->magnitude) {\n+    if (flag) {\n         r->magnitude = a->magnitude;\n+        r->normalized = a->normalized;\n     }\n-    r->normalized &= a->normalized;\n #endif\n }\n \n static SECP256K1_INLINE void secp256k1_fe_storage_cmov(secp256k1_fe_storage *r, const secp256k1_fe_storage *a, int flag) {\n     uint64_t mask0, mask1;\n+    VG_CHECK_VERIFY(r->n, sizeof(r->n));\n     mask0 = flag + ~((uint64_t)0);\n     mask1 = ~mask0;\n     r->n[0] = (r->n[0] & mask0) | (a->n[0] & mask1);"
      },
      {
        "sha": "485921a60e62b52e22175aaf03fb87fb1d17f1d5",
        "filename": "src/secp256k1/src/field_impl.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/field_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/field_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field_impl.h?ref=8903a1a0a78a705402123d2a5c465217cb9d791c",
        "patch": "@@ -315,4 +315,6 @@ static int secp256k1_fe_is_quad_var(const secp256k1_fe *a) {\n #endif\n }\n \n+static const secp256k1_fe secp256k1_fe_one = SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 1);\n+\n #endif /* SECP256K1_FIELD_IMPL_H */"
      },
      {
        "sha": "539f574bfd0c690be1e939748bf86249305c981e",
        "filename": "src/secp256k1/src/gen_context.c",
        "status": "modified",
        "additions": 23,
        "deletions": 10,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/gen_context.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/gen_context.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/gen_context.c?ref=8903a1a0a78a705402123d2a5c465217cb9d791c",
        "patch": "@@ -4,10 +4,16 @@\n  * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n  **********************************************************************/\n \n+// Autotools creates libsecp256k1-config.h, of which ECMULT_GEN_PREC_BITS is needed.\n+// ifndef guard so downstream users can define their own if they do not use autotools.\n+#if !defined(ECMULT_GEN_PREC_BITS)\n+#include \"libsecp256k1-config.h\"\n+#endif\n #define USE_BASIC_CONFIG 1\n-\n #include \"basic-config.h\"\n+\n #include \"include/secp256k1.h\"\n+#include \"util.h\"\n #include \"field_impl.h\"\n #include \"scalar_impl.h\"\n #include \"group_impl.h\"\n@@ -26,6 +32,7 @@ static const secp256k1_callback default_error_callback = {\n \n int main(int argc, char **argv) {\n     secp256k1_ecmult_gen_context ctx;\n+    void *prealloc, *base;\n     int inner;\n     int outer;\n     FILE* fp;\n@@ -38,37 +45,43 @@ int main(int argc, char **argv) {\n         fprintf(stderr, \"Could not open src/ecmult_static_context.h for writing!\\n\");\n         return -1;\n     }\n-    \n+\n     fprintf(fp, \"#ifndef _SECP256K1_ECMULT_STATIC_CONTEXT_\\n\");\n     fprintf(fp, \"#define _SECP256K1_ECMULT_STATIC_CONTEXT_\\n\");\n     fprintf(fp, \"#include \\\"src/group.h\\\"\\n\");\n     fprintf(fp, \"#define SC SECP256K1_GE_STORAGE_CONST\\n\");\n-    fprintf(fp, \"static const secp256k1_ge_storage secp256k1_ecmult_static_context[64][16] = {\\n\");\n+    fprintf(fp, \"#if ECMULT_GEN_PREC_N != %d || ECMULT_GEN_PREC_G != %d\\n\", ECMULT_GEN_PREC_N, ECMULT_GEN_PREC_G);\n+    fprintf(fp, \"   #error configuration mismatch, invalid ECMULT_GEN_PREC_N, ECMULT_GEN_PREC_G. Try deleting ecmult_static_context.h before the build.\\n\");\n+    fprintf(fp, \"#endif\\n\");\n+    fprintf(fp, \"static const secp256k1_ge_storage secp256k1_ecmult_static_context[ECMULT_GEN_PREC_N][ECMULT_GEN_PREC_G] = {\\n\");\n \n+    base = checked_malloc(&default_error_callback, SECP256K1_ECMULT_GEN_CONTEXT_PREALLOCATED_SIZE);\n+    prealloc = base;\n     secp256k1_ecmult_gen_context_init(&ctx);\n-    secp256k1_ecmult_gen_context_build(&ctx, &default_error_callback);\n-    for(outer = 0; outer != 64; outer++) {\n+    secp256k1_ecmult_gen_context_build(&ctx, &prealloc);\n+    for(outer = 0; outer != ECMULT_GEN_PREC_N; outer++) {\n         fprintf(fp,\"{\\n\");\n-        for(inner = 0; inner != 16; inner++) {\n+        for(inner = 0; inner != ECMULT_GEN_PREC_G; inner++) {\n             fprintf(fp,\"    SC(%uu, %uu, %uu, %uu, %uu, %uu, %uu, %uu, %uu, %uu, %uu, %uu, %uu, %uu, %uu, %uu)\", SECP256K1_GE_STORAGE_CONST_GET((*ctx.prec)[outer][inner]));\n-            if (inner != 15) {\n+            if (inner != ECMULT_GEN_PREC_G - 1) {\n                 fprintf(fp,\",\\n\");\n             } else {\n                 fprintf(fp,\"\\n\");\n             }\n         }\n-        if (outer != 63) {\n+        if (outer != ECMULT_GEN_PREC_N - 1) {\n             fprintf(fp,\"},\\n\");\n         } else {\n             fprintf(fp,\"}\\n\");\n         }\n     }\n     fprintf(fp,\"};\\n\");\n     secp256k1_ecmult_gen_context_clear(&ctx);\n-    \n+    free(base);\n+\n     fprintf(fp, \"#undef SC\\n\");\n     fprintf(fp, \"#endif\\n\");\n     fclose(fp);\n-    \n+\n     return 0;\n }"
      },
      {
        "sha": "863644f0f0bbf7dde12ab53b2da4d87310163d93",
        "filename": "src/secp256k1/src/group.h",
        "status": "modified",
        "additions": 6,
        "deletions": 7,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/group.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/group.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/group.h?ref=8903a1a0a78a705402123d2a5c465217cb9d791c",
        "patch": "@@ -95,22 +95,21 @@ static int secp256k1_gej_is_infinity(const secp256k1_gej *a);\n /** Check whether a group element's y coordinate is a quadratic residue. */\n static int secp256k1_gej_has_quad_y_var(const secp256k1_gej *a);\n \n-/** Set r equal to the double of a. If rzr is not-NULL, r->z = a->z * *rzr (where infinity means an implicit z = 0).\n- * a may not be zero. Constant time. */\n-static void secp256k1_gej_double_nonzero(secp256k1_gej *r, const secp256k1_gej *a, secp256k1_fe *rzr);\n+/** Set r equal to the double of a, a cannot be infinity. Constant time. */\n+static void secp256k1_gej_double_nonzero(secp256k1_gej *r, const secp256k1_gej *a);\n \n-/** Set r equal to the double of a. If rzr is not-NULL, r->z = a->z * *rzr (where infinity means an implicit z = 0). */\n+/** Set r equal to the double of a. If rzr is not-NULL this sets *rzr such that r->z == a->z * *rzr (where infinity means an implicit z = 0). */\n static void secp256k1_gej_double_var(secp256k1_gej *r, const secp256k1_gej *a, secp256k1_fe *rzr);\n \n-/** Set r equal to the sum of a and b. If rzr is non-NULL, r->z = a->z * *rzr (a cannot be infinity in that case). */\n+/** Set r equal to the sum of a and b. If rzr is non-NULL this sets *rzr such that r->z == a->z * *rzr (a cannot be infinity in that case). */\n static void secp256k1_gej_add_var(secp256k1_gej *r, const secp256k1_gej *a, const secp256k1_gej *b, secp256k1_fe *rzr);\n \n /** Set r equal to the sum of a and b (with b given in affine coordinates, and not infinity). */\n static void secp256k1_gej_add_ge(secp256k1_gej *r, const secp256k1_gej *a, const secp256k1_ge *b);\n \n /** Set r equal to the sum of a and b (with b given in affine coordinates). This is more efficient\n     than secp256k1_gej_add_var. It is identical to secp256k1_gej_add_ge but without constant-time\n-    guarantee, and b is allowed to be infinity. If rzr is non-NULL, r->z = a->z * *rzr (a cannot be infinity in that case). */\n+    guarantee, and b is allowed to be infinity. If rzr is non-NULL this sets *rzr such that r->z == a->z * *rzr (a cannot be infinity in that case). */\n static void secp256k1_gej_add_ge_var(secp256k1_gej *r, const secp256k1_gej *a, const secp256k1_ge *b, secp256k1_fe *rzr);\n \n /** Set r equal to the sum of a and b (with the inverse of b's Z coordinate passed as bzinv). */\n@@ -133,7 +132,7 @@ static void secp256k1_ge_to_storage(secp256k1_ge_storage *r, const secp256k1_ge\n /** Convert a group element back from the storage type. */\n static void secp256k1_ge_from_storage(secp256k1_ge *r, const secp256k1_ge_storage *a);\n \n-/** If flag is true, set *r equal to *a; otherwise leave it. Constant-time. */\n+/** If flag is true, set *r equal to *a; otherwise leave it. Constant-time.  Both *r and *a must be initialized.*/\n static void secp256k1_ge_storage_cmov(secp256k1_ge_storage *r, const secp256k1_ge_storage *a, int flag);\n \n /** Rescale a jacobian point by b which must be non-zero. Constant-time. */"
      },
      {
        "sha": "43b039becfd58d112594dd6c9611c65d0c30f5a0",
        "filename": "src/secp256k1/src/group_impl.h",
        "status": "modified",
        "additions": 29,
        "deletions": 26,
        "changes": 55,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/group_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/group_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/group_impl.h?ref=8903a1a0a78a705402123d2a5c465217cb9d791c",
        "patch": "@@ -303,7 +303,7 @@ static int secp256k1_ge_is_valid_var(const secp256k1_ge *a) {\n     return secp256k1_fe_equal_var(&y2, &x3);\n }\n \n-static void secp256k1_gej_double_var(secp256k1_gej *r, const secp256k1_gej *a, secp256k1_fe *rzr) {\n+static SECP256K1_INLINE void secp256k1_gej_double_nonzero(secp256k1_gej *r, const secp256k1_gej *a) {\n     /* Operations: 3 mul, 4 sqr, 0 normalize, 12 mul_int/add/negate.\n      *\n      * Note that there is an implementation described at\n@@ -312,29 +312,9 @@ static void secp256k1_gej_double_var(secp256k1_gej *r, const secp256k1_gej *a, s\n      * mainly because it requires more normalizations.\n      */\n     secp256k1_fe t1,t2,t3,t4;\n-    /** For secp256k1, 2Q is infinity if and only if Q is infinity. This is because if 2Q = infinity,\n-     *  Q must equal -Q, or that Q.y == -(Q.y), or Q.y is 0. For a point on y^2 = x^3 + 7 to have\n-     *  y=0, x^3 must be -7 mod p. However, -7 has no cube root mod p.\n-     *\n-     *  Having said this, if this function receives a point on a sextic twist, e.g. by\n-     *  a fault attack, it is possible for y to be 0. This happens for y^2 = x^3 + 6,\n-     *  since -6 does have a cube root mod p. For this point, this function will not set\n-     *  the infinity flag even though the point doubles to infinity, and the result\n-     *  point will be gibberish (z = 0 but infinity = 0).\n-     */\n-    r->infinity = a->infinity;\n-    if (r->infinity) {\n-        if (rzr != NULL) {\n-            secp256k1_fe_set_int(rzr, 1);\n-        }\n-        return;\n-    }\n \n-    if (rzr != NULL) {\n-        *rzr = a->y;\n-        secp256k1_fe_normalize_weak(rzr);\n-        secp256k1_fe_mul_int(rzr, 2);\n-    }\n+    VERIFY_CHECK(!secp256k1_gej_is_infinity(a));\n+    r->infinity = 0;\n \n     secp256k1_fe_mul(&r->z, &a->z, &a->y);\n     secp256k1_fe_mul_int(&r->z, 2);       /* Z' = 2*Y*Z (2) */\n@@ -358,9 +338,32 @@ static void secp256k1_gej_double_var(secp256k1_gej *r, const secp256k1_gej *a, s\n     secp256k1_fe_add(&r->y, &t2);         /* Y' = 36*X^3*Y^2 - 27*X^6 - 8*Y^4 (4) */\n }\n \n-static SECP256K1_INLINE void secp256k1_gej_double_nonzero(secp256k1_gej *r, const secp256k1_gej *a, secp256k1_fe *rzr) {\n-    VERIFY_CHECK(!secp256k1_gej_is_infinity(a));\n-    secp256k1_gej_double_var(r, a, rzr);\n+static void secp256k1_gej_double_var(secp256k1_gej *r, const secp256k1_gej *a, secp256k1_fe *rzr) {\n+    /** For secp256k1, 2Q is infinity if and only if Q is infinity. This is because if 2Q = infinity,\n+     *  Q must equal -Q, or that Q.y == -(Q.y), or Q.y is 0. For a point on y^2 = x^3 + 7 to have\n+     *  y=0, x^3 must be -7 mod p. However, -7 has no cube root mod p.\n+     *\n+     *  Having said this, if this function receives a point on a sextic twist, e.g. by\n+     *  a fault attack, it is possible for y to be 0. This happens for y^2 = x^3 + 6,\n+     *  since -6 does have a cube root mod p. For this point, this function will not set\n+     *  the infinity flag even though the point doubles to infinity, and the result\n+     *  point will be gibberish (z = 0 but infinity = 0).\n+     */\n+    if (a->infinity) {\n+        r->infinity = 1;\n+        if (rzr != NULL) {\n+            secp256k1_fe_set_int(rzr, 1);\n+        }\n+        return;\n+    }\n+\n+    if (rzr != NULL) {\n+        *rzr = a->y;\n+        secp256k1_fe_normalize_weak(rzr);\n+        secp256k1_fe_mul_int(rzr, 2);\n+    }\n+\n+    secp256k1_gej_double_nonzero(r, a);\n }\n \n static void secp256k1_gej_add_var(secp256k1_gej *r, const secp256k1_gej *a, const secp256k1_gej *b, secp256k1_fe *rzr) {"
      },
      {
        "sha": "782f97216c284eff353a339fdd544c49ab2a7911",
        "filename": "src/secp256k1/src/hash_impl.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/hash_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/hash_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/hash_impl.h?ref=8903a1a0a78a705402123d2a5c465217cb9d791c",
        "patch": "@@ -131,7 +131,8 @@ static void secp256k1_sha256_transform(uint32_t* s, const uint32_t* chunk) {\n static void secp256k1_sha256_write(secp256k1_sha256 *hash, const unsigned char *data, size_t len) {\n     size_t bufsize = hash->bytes & 0x3F;\n     hash->bytes += len;\n-    while (bufsize + len >= 64) {\n+    VERIFY_CHECK(hash->bytes >= len);\n+    while (len >= 64 - bufsize) {\n         /* Fill the buffer, and process it. */\n         size_t chunk_len = 64 - bufsize;\n         memcpy(((unsigned char*)hash->buf) + bufsize, data, chunk_len);"
      },
      {
        "sha": "1c67802fba82e60498c560473e9966c161939ffb",
        "filename": "src/secp256k1/src/java/org/bitcoin/NativeSecp256k1.java",
        "status": "removed",
        "additions": 0,
        "deletions": 446,
        "changes": 446,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9ad6f14175c19b5d47267c3dd5840c14bad43c83/src/secp256k1/src/java/org/bitcoin/NativeSecp256k1.java",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9ad6f14175c19b5d47267c3dd5840c14bad43c83/src/secp256k1/src/java/org/bitcoin/NativeSecp256k1.java",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/java/org/bitcoin/NativeSecp256k1.java?ref=9ad6f14175c19b5d47267c3dd5840c14bad43c83",
        "patch": "@@ -1,446 +0,0 @@\n-/*\n- * Copyright 2013 Google Inc.\n- * Copyright 2014-2016 the libsecp256k1 contributors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.bitcoin;\n-\n-import java.nio.ByteBuffer;\n-import java.nio.ByteOrder;\n-\n-import java.math.BigInteger;\n-import com.google.common.base.Preconditions;\n-import java.util.concurrent.locks.Lock;\n-import java.util.concurrent.locks.ReentrantReadWriteLock;\n-import static org.bitcoin.NativeSecp256k1Util.*;\n-\n-/**\n- * <p>This class holds native methods to handle ECDSA verification.</p>\n- *\n- * <p>You can find an example library that can be used for this at https://github.com/bitcoin/secp256k1</p>\n- *\n- * <p>To build secp256k1 for use with bitcoinj, run\n- * `./configure --enable-jni --enable-experimental --enable-module-ecdh`\n- * and `make` then copy `.libs/libsecp256k1.so` to your system library path\n- * or point the JVM to the folder containing it with -Djava.library.path\n- * </p>\n- */\n-public class NativeSecp256k1 {\n-\n-    private static final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();\n-    private static final Lock r = rwl.readLock();\n-    private static final Lock w = rwl.writeLock();\n-    private static ThreadLocal<ByteBuffer> nativeECDSABuffer = new ThreadLocal<ByteBuffer>();\n-    /**\n-     * Verifies the given secp256k1 signature in native code.\n-     * Calling when enabled == false is undefined (probably library not loaded)\n-     *\n-     * @param data The data which was signed, must be exactly 32 bytes\n-     * @param signature The signature\n-     * @param pub The public key which did the signing\n-     */\n-    public static boolean verify(byte[] data, byte[] signature, byte[] pub) throws AssertFailException{\n-        Preconditions.checkArgument(data.length == 32 && signature.length <= 520 && pub.length <= 520);\n-\n-        ByteBuffer byteBuff = nativeECDSABuffer.get();\n-        if (byteBuff == null || byteBuff.capacity() < 520) {\n-            byteBuff = ByteBuffer.allocateDirect(520);\n-            byteBuff.order(ByteOrder.nativeOrder());\n-            nativeECDSABuffer.set(byteBuff);\n-        }\n-        byteBuff.rewind();\n-        byteBuff.put(data);\n-        byteBuff.put(signature);\n-        byteBuff.put(pub);\n-\n-        byte[][] retByteArray;\n-\n-        r.lock();\n-        try {\n-          return secp256k1_ecdsa_verify(byteBuff, Secp256k1Context.getContext(), signature.length, pub.length) == 1;\n-        } finally {\n-          r.unlock();\n-        }\n-    }\n-\n-    /**\n-     * libsecp256k1 Create an ECDSA signature.\n-     *\n-     * @param data Message hash, 32 bytes\n-     * @param key Secret key, 32 bytes\n-     *\n-     * Return values\n-     * @param sig byte array of signature\n-     */\n-    public static byte[] sign(byte[] data, byte[] sec) throws AssertFailException{\n-        Preconditions.checkArgument(data.length == 32 && sec.length <= 32);\n-\n-        ByteBuffer byteBuff = nativeECDSABuffer.get();\n-        if (byteBuff == null || byteBuff.capacity() < 32 + 32) {\n-            byteBuff = ByteBuffer.allocateDirect(32 + 32);\n-            byteBuff.order(ByteOrder.nativeOrder());\n-            nativeECDSABuffer.set(byteBuff);\n-        }\n-        byteBuff.rewind();\n-        byteBuff.put(data);\n-        byteBuff.put(sec);\n-\n-        byte[][] retByteArray;\n-\n-        r.lock();\n-        try {\n-          retByteArray = secp256k1_ecdsa_sign(byteBuff, Secp256k1Context.getContext());\n-        } finally {\n-          r.unlock();\n-        }\n-\n-        byte[] sigArr = retByteArray[0];\n-        int sigLen = new BigInteger(new byte[] { retByteArray[1][0] }).intValue();\n-        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n-\n-        assertEquals(sigArr.length, sigLen, \"Got bad signature length.\");\n-\n-        return retVal == 0 ? new byte[0] : sigArr;\n-    }\n-\n-    /**\n-     * libsecp256k1 Seckey Verify - returns 1 if valid, 0 if invalid\n-     *\n-     * @param seckey ECDSA Secret key, 32 bytes\n-     */\n-    public static boolean secKeyVerify(byte[] seckey) {\n-        Preconditions.checkArgument(seckey.length == 32);\n-\n-        ByteBuffer byteBuff = nativeECDSABuffer.get();\n-        if (byteBuff == null || byteBuff.capacity() < seckey.length) {\n-            byteBuff = ByteBuffer.allocateDirect(seckey.length);\n-            byteBuff.order(ByteOrder.nativeOrder());\n-            nativeECDSABuffer.set(byteBuff);\n-        }\n-        byteBuff.rewind();\n-        byteBuff.put(seckey);\n-\n-        r.lock();\n-        try {\n-          return secp256k1_ec_seckey_verify(byteBuff,Secp256k1Context.getContext()) == 1;\n-        } finally {\n-          r.unlock();\n-        }\n-    }\n-\n-\n-    /**\n-     * libsecp256k1 Compute Pubkey - computes public key from secret key\n-     *\n-     * @param seckey ECDSA Secret key, 32 bytes\n-     *\n-     * Return values\n-     * @param pubkey ECDSA Public key, 33 or 65 bytes\n-     */\n-    //TODO add a 'compressed' arg\n-    public static byte[] computePubkey(byte[] seckey) throws AssertFailException{\n-        Preconditions.checkArgument(seckey.length == 32);\n-\n-        ByteBuffer byteBuff = nativeECDSABuffer.get();\n-        if (byteBuff == null || byteBuff.capacity() < seckey.length) {\n-            byteBuff = ByteBuffer.allocateDirect(seckey.length);\n-            byteBuff.order(ByteOrder.nativeOrder());\n-            nativeECDSABuffer.set(byteBuff);\n-        }\n-        byteBuff.rewind();\n-        byteBuff.put(seckey);\n-\n-        byte[][] retByteArray;\n-\n-        r.lock();\n-        try {\n-          retByteArray = secp256k1_ec_pubkey_create(byteBuff, Secp256k1Context.getContext());\n-        } finally {\n-          r.unlock();\n-        }\n-\n-        byte[] pubArr = retByteArray[0];\n-        int pubLen = new BigInteger(new byte[] { retByteArray[1][0] }).intValue();\n-        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n-\n-        assertEquals(pubArr.length, pubLen, \"Got bad pubkey length.\");\n-\n-        return retVal == 0 ? new byte[0]: pubArr;\n-    }\n-\n-    /**\n-     * libsecp256k1 Cleanup - This destroys the secp256k1 context object\n-     * This should be called at the end of the program for proper cleanup of the context.\n-     */\n-    public static synchronized void cleanup() {\n-        w.lock();\n-        try {\n-          secp256k1_destroy_context(Secp256k1Context.getContext());\n-        } finally {\n-          w.unlock();\n-        }\n-    }\n-\n-    public static long cloneContext() {\n-       r.lock();\n-       try {\n-        return secp256k1_ctx_clone(Secp256k1Context.getContext());\n-       } finally { r.unlock(); }\n-    }\n-\n-    /**\n-     * libsecp256k1 PrivKey Tweak-Mul - Tweak privkey by multiplying to it\n-     *\n-     * @param tweak some bytes to tweak with\n-     * @param seckey 32-byte seckey\n-     */\n-    public static byte[] privKeyTweakMul(byte[] privkey, byte[] tweak) throws AssertFailException{\n-        Preconditions.checkArgument(privkey.length == 32);\n-\n-        ByteBuffer byteBuff = nativeECDSABuffer.get();\n-        if (byteBuff == null || byteBuff.capacity() < privkey.length + tweak.length) {\n-            byteBuff = ByteBuffer.allocateDirect(privkey.length + tweak.length);\n-            byteBuff.order(ByteOrder.nativeOrder());\n-            nativeECDSABuffer.set(byteBuff);\n-        }\n-        byteBuff.rewind();\n-        byteBuff.put(privkey);\n-        byteBuff.put(tweak);\n-\n-        byte[][] retByteArray;\n-        r.lock();\n-        try {\n-          retByteArray = secp256k1_privkey_tweak_mul(byteBuff,Secp256k1Context.getContext());\n-        } finally {\n-          r.unlock();\n-        }\n-\n-        byte[] privArr = retByteArray[0];\n-\n-        int privLen = (byte) new BigInteger(new byte[] { retByteArray[1][0] }).intValue() & 0xFF;\n-        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n-\n-        assertEquals(privArr.length, privLen, \"Got bad pubkey length.\");\n-\n-        assertEquals(retVal, 1, \"Failed return value check.\");\n-\n-        return privArr;\n-    }\n-\n-    /**\n-     * libsecp256k1 PrivKey Tweak-Add - Tweak privkey by adding to it\n-     *\n-     * @param tweak some bytes to tweak with\n-     * @param seckey 32-byte seckey\n-     */\n-    public static byte[] privKeyTweakAdd(byte[] privkey, byte[] tweak) throws AssertFailException{\n-        Preconditions.checkArgument(privkey.length == 32);\n-\n-        ByteBuffer byteBuff = nativeECDSABuffer.get();\n-        if (byteBuff == null || byteBuff.capacity() < privkey.length + tweak.length) {\n-            byteBuff = ByteBuffer.allocateDirect(privkey.length + tweak.length);\n-            byteBuff.order(ByteOrder.nativeOrder());\n-            nativeECDSABuffer.set(byteBuff);\n-        }\n-        byteBuff.rewind();\n-        byteBuff.put(privkey);\n-        byteBuff.put(tweak);\n-\n-        byte[][] retByteArray;\n-        r.lock();\n-        try {\n-          retByteArray = secp256k1_privkey_tweak_add(byteBuff,Secp256k1Context.getContext());\n-        } finally {\n-          r.unlock();\n-        }\n-\n-        byte[] privArr = retByteArray[0];\n-\n-        int privLen = (byte) new BigInteger(new byte[] { retByteArray[1][0] }).intValue() & 0xFF;\n-        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n-\n-        assertEquals(privArr.length, privLen, \"Got bad pubkey length.\");\n-\n-        assertEquals(retVal, 1, \"Failed return value check.\");\n-\n-        return privArr;\n-    }\n-\n-    /**\n-     * libsecp256k1 PubKey Tweak-Add - Tweak pubkey by adding to it\n-     *\n-     * @param tweak some bytes to tweak with\n-     * @param pubkey 32-byte seckey\n-     */\n-    public static byte[] pubKeyTweakAdd(byte[] pubkey, byte[] tweak) throws AssertFailException{\n-        Preconditions.checkArgument(pubkey.length == 33 || pubkey.length == 65);\n-\n-        ByteBuffer byteBuff = nativeECDSABuffer.get();\n-        if (byteBuff == null || byteBuff.capacity() < pubkey.length + tweak.length) {\n-            byteBuff = ByteBuffer.allocateDirect(pubkey.length + tweak.length);\n-            byteBuff.order(ByteOrder.nativeOrder());\n-            nativeECDSABuffer.set(byteBuff);\n-        }\n-        byteBuff.rewind();\n-        byteBuff.put(pubkey);\n-        byteBuff.put(tweak);\n-\n-        byte[][] retByteArray;\n-        r.lock();\n-        try {\n-          retByteArray = secp256k1_pubkey_tweak_add(byteBuff,Secp256k1Context.getContext(), pubkey.length);\n-        } finally {\n-          r.unlock();\n-        }\n-\n-        byte[] pubArr = retByteArray[0];\n-\n-        int pubLen = (byte) new BigInteger(new byte[] { retByteArray[1][0] }).intValue() & 0xFF;\n-        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n-\n-        assertEquals(pubArr.length, pubLen, \"Got bad pubkey length.\");\n-\n-        assertEquals(retVal, 1, \"Failed return value check.\");\n-\n-        return pubArr;\n-    }\n-\n-    /**\n-     * libsecp256k1 PubKey Tweak-Mul - Tweak pubkey by multiplying to it\n-     *\n-     * @param tweak some bytes to tweak with\n-     * @param pubkey 32-byte seckey\n-     */\n-    public static byte[] pubKeyTweakMul(byte[] pubkey, byte[] tweak) throws AssertFailException{\n-        Preconditions.checkArgument(pubkey.length == 33 || pubkey.length == 65);\n-\n-        ByteBuffer byteBuff = nativeECDSABuffer.get();\n-        if (byteBuff == null || byteBuff.capacity() < pubkey.length + tweak.length) {\n-            byteBuff = ByteBuffer.allocateDirect(pubkey.length + tweak.length);\n-            byteBuff.order(ByteOrder.nativeOrder());\n-            nativeECDSABuffer.set(byteBuff);\n-        }\n-        byteBuff.rewind();\n-        byteBuff.put(pubkey);\n-        byteBuff.put(tweak);\n-\n-        byte[][] retByteArray;\n-        r.lock();\n-        try {\n-          retByteArray = secp256k1_pubkey_tweak_mul(byteBuff,Secp256k1Context.getContext(), pubkey.length);\n-        } finally {\n-          r.unlock();\n-        }\n-\n-        byte[] pubArr = retByteArray[0];\n-\n-        int pubLen = (byte) new BigInteger(new byte[] { retByteArray[1][0] }).intValue() & 0xFF;\n-        int retVal = new BigInteger(new byte[] { retByteArray[1][1] }).intValue();\n-\n-        assertEquals(pubArr.length, pubLen, \"Got bad pubkey length.\");\n-\n-        assertEquals(retVal, 1, \"Failed return value check.\");\n-\n-        return pubArr;\n-    }\n-\n-    /**\n-     * libsecp256k1 create ECDH secret - constant time ECDH calculation\n-     *\n-     * @param seckey byte array of secret key used in exponentiaion\n-     * @param pubkey byte array of public key used in exponentiaion\n-     */\n-    public static byte[] createECDHSecret(byte[] seckey, byte[] pubkey) throws AssertFailException{\n-        Preconditions.checkArgument(seckey.length <= 32 && pubkey.length <= 65);\n-\n-        ByteBuffer byteBuff = nativeECDSABuffer.get();\n-        if (byteBuff == null || byteBuff.capacity() < 32 + pubkey.length) {\n-            byteBuff = ByteBuffer.allocateDirect(32 + pubkey.length);\n-            byteBuff.order(ByteOrder.nativeOrder());\n-            nativeECDSABuffer.set(byteBuff);\n-        }\n-        byteBuff.rewind();\n-        byteBuff.put(seckey);\n-        byteBuff.put(pubkey);\n-\n-        byte[][] retByteArray;\n-        r.lock();\n-        try {\n-          retByteArray = secp256k1_ecdh(byteBuff, Secp256k1Context.getContext(), pubkey.length);\n-        } finally {\n-          r.unlock();\n-        }\n-\n-        byte[] resArr = retByteArray[0];\n-        int retVal = new BigInteger(new byte[] { retByteArray[1][0] }).intValue();\n-\n-        assertEquals(resArr.length, 32, \"Got bad result length.\");\n-        assertEquals(retVal, 1, \"Failed return value check.\");\n-\n-        return resArr;\n-    }\n-\n-    /**\n-     * libsecp256k1 randomize - updates the context randomization\n-     *\n-     * @param seed 32-byte random seed\n-     */\n-    public static synchronized boolean randomize(byte[] seed) throws AssertFailException{\n-        Preconditions.checkArgument(seed.length == 32 || seed == null);\n-\n-        ByteBuffer byteBuff = nativeECDSABuffer.get();\n-        if (byteBuff == null || byteBuff.capacity() < seed.length) {\n-            byteBuff = ByteBuffer.allocateDirect(seed.length);\n-            byteBuff.order(ByteOrder.nativeOrder());\n-            nativeECDSABuffer.set(byteBuff);\n-        }\n-        byteBuff.rewind();\n-        byteBuff.put(seed);\n-\n-        w.lock();\n-        try {\n-          return secp256k1_context_randomize(byteBuff, Secp256k1Context.getContext()) == 1;\n-        } finally {\n-          w.unlock();\n-        }\n-    }\n-\n-    private static native long secp256k1_ctx_clone(long context);\n-\n-    private static native int secp256k1_context_randomize(ByteBuffer byteBuff, long context);\n-\n-    private static native byte[][] secp256k1_privkey_tweak_add(ByteBuffer byteBuff, long context);\n-\n-    private static native byte[][] secp256k1_privkey_tweak_mul(ByteBuffer byteBuff, long context);\n-\n-    private static native byte[][] secp256k1_pubkey_tweak_add(ByteBuffer byteBuff, long context, int pubLen);\n-\n-    private static native byte[][] secp256k1_pubkey_tweak_mul(ByteBuffer byteBuff, long context, int pubLen);\n-\n-    private static native void secp256k1_destroy_context(long context);\n-\n-    private static native int secp256k1_ecdsa_verify(ByteBuffer byteBuff, long context, int sigLen, int pubLen);\n-\n-    private static native byte[][] secp256k1_ecdsa_sign(ByteBuffer byteBuff, long context);\n-\n-    private static native int secp256k1_ec_seckey_verify(ByteBuffer byteBuff, long context);\n-\n-    private static native byte[][] secp256k1_ec_pubkey_create(ByteBuffer byteBuff, long context);\n-\n-    private static native byte[][] secp256k1_ec_pubkey_parse(ByteBuffer byteBuff, long context, int inputLen);\n-\n-    private static native byte[][] secp256k1_ecdh(ByteBuffer byteBuff, long context, int inputLen);\n-\n-}"
      },
      {
        "sha": "d766a1029ce389a73207431bdf7c0376b1fc6e35",
        "filename": "src/secp256k1/src/java/org/bitcoin/NativeSecp256k1Test.java",
        "status": "removed",
        "additions": 0,
        "deletions": 226,
        "changes": 226,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9ad6f14175c19b5d47267c3dd5840c14bad43c83/src/secp256k1/src/java/org/bitcoin/NativeSecp256k1Test.java",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9ad6f14175c19b5d47267c3dd5840c14bad43c83/src/secp256k1/src/java/org/bitcoin/NativeSecp256k1Test.java",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/java/org/bitcoin/NativeSecp256k1Test.java?ref=9ad6f14175c19b5d47267c3dd5840c14bad43c83",
        "patch": "@@ -1,226 +0,0 @@\n-package org.bitcoin;\n-\n-import com.google.common.io.BaseEncoding;\n-import java.util.Arrays;\n-import java.math.BigInteger;\n-import javax.xml.bind.DatatypeConverter;\n-import static org.bitcoin.NativeSecp256k1Util.*;\n-\n-/**\n- * This class holds test cases defined for testing this library.\n- */\n-public class NativeSecp256k1Test {\n-\n-    //TODO improve comments/add more tests\n-    /**\n-      * This tests verify() for a valid signature\n-      */\n-    public static void testVerifyPos() throws AssertFailException{\n-        boolean result = false;\n-        byte[] data = BaseEncoding.base16().lowerCase().decode(\"CF80CD8AED482D5D1527D7DC72FCEFF84E6326592848447D2DC0B0E87DFC9A90\".toLowerCase()); //sha256hash of \"testing\"\n-        byte[] sig = BaseEncoding.base16().lowerCase().decode(\"3044022079BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F817980220294F14E883B3F525B5367756C2A11EF6CF84B730B36C17CB0C56F0AAB2C98589\".toLowerCase());\n-        byte[] pub = BaseEncoding.base16().lowerCase().decode(\"040A629506E1B65CD9D2E0BA9C75DF9C4FED0DB16DC9625ED14397F0AFC836FAE595DC53F8B0EFE61E703075BD9B143BAC75EC0E19F82A2208CAEB32BE53414C40\".toLowerCase());\n-\n-        result = NativeSecp256k1.verify( data, sig, pub);\n-        assertEquals( result, true , \"testVerifyPos\");\n-    }\n-\n-    /**\n-      * This tests verify() for a non-valid signature\n-      */\n-    public static void testVerifyNeg() throws AssertFailException{\n-        boolean result = false;\n-        byte[] data = BaseEncoding.base16().lowerCase().decode(\"CF80CD8AED482D5D1527D7DC72FCEFF84E6326592848447D2DC0B0E87DFC9A91\".toLowerCase()); //sha256hash of \"testing\"\n-        byte[] sig = BaseEncoding.base16().lowerCase().decode(\"3044022079BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F817980220294F14E883B3F525B5367756C2A11EF6CF84B730B36C17CB0C56F0AAB2C98589\".toLowerCase());\n-        byte[] pub = BaseEncoding.base16().lowerCase().decode(\"040A629506E1B65CD9D2E0BA9C75DF9C4FED0DB16DC9625ED14397F0AFC836FAE595DC53F8B0EFE61E703075BD9B143BAC75EC0E19F82A2208CAEB32BE53414C40\".toLowerCase());\n-\n-        result = NativeSecp256k1.verify( data, sig, pub);\n-        //System.out.println(\" TEST \" + new BigInteger(1, resultbytes).toString(16));\n-        assertEquals( result, false , \"testVerifyNeg\");\n-    }\n-\n-    /**\n-      * This tests secret key verify() for a valid secretkey\n-      */\n-    public static void testSecKeyVerifyPos() throws AssertFailException{\n-        boolean result = false;\n-        byte[] sec = BaseEncoding.base16().lowerCase().decode(\"67E56582298859DDAE725F972992A07C6C4FB9F62A8FFF58CE3CA926A1063530\".toLowerCase());\n-\n-        result = NativeSecp256k1.secKeyVerify( sec );\n-        //System.out.println(\" TEST \" + new BigInteger(1, resultbytes).toString(16));\n-        assertEquals( result, true , \"testSecKeyVerifyPos\");\n-    }\n-\n-    /**\n-      * This tests secret key verify() for an invalid secretkey\n-      */\n-    public static void testSecKeyVerifyNeg() throws AssertFailException{\n-        boolean result = false;\n-        byte[] sec = BaseEncoding.base16().lowerCase().decode(\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\".toLowerCase());\n-\n-        result = NativeSecp256k1.secKeyVerify( sec );\n-        //System.out.println(\" TEST \" + new BigInteger(1, resultbytes).toString(16));\n-        assertEquals( result, false , \"testSecKeyVerifyNeg\");\n-    }\n-\n-    /**\n-      * This tests public key create() for a valid secretkey\n-      */\n-    public static void testPubKeyCreatePos() throws AssertFailException{\n-        byte[] sec = BaseEncoding.base16().lowerCase().decode(\"67E56582298859DDAE725F972992A07C6C4FB9F62A8FFF58CE3CA926A1063530\".toLowerCase());\n-\n-        byte[] resultArr = NativeSecp256k1.computePubkey( sec);\n-        String pubkeyString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n-        assertEquals( pubkeyString , \"04C591A8FF19AC9C4E4E5793673B83123437E975285E7B442F4EE2654DFFCA5E2D2103ED494718C697AC9AEBCFD19612E224DB46661011863ED2FC54E71861E2A6\" , \"testPubKeyCreatePos\");\n-    }\n-\n-    /**\n-      * This tests public key create() for a invalid secretkey\n-      */\n-    public static void testPubKeyCreateNeg() throws AssertFailException{\n-       byte[] sec = BaseEncoding.base16().lowerCase().decode(\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\".toLowerCase());\n-\n-       byte[] resultArr = NativeSecp256k1.computePubkey( sec);\n-       String pubkeyString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n-       assertEquals( pubkeyString, \"\" , \"testPubKeyCreateNeg\");\n-    }\n-\n-    /**\n-      * This tests sign() for a valid secretkey\n-      */\n-    public static void testSignPos() throws AssertFailException{\n-\n-        byte[] data = BaseEncoding.base16().lowerCase().decode(\"CF80CD8AED482D5D1527D7DC72FCEFF84E6326592848447D2DC0B0E87DFC9A90\".toLowerCase()); //sha256hash of \"testing\"\n-        byte[] sec = BaseEncoding.base16().lowerCase().decode(\"67E56582298859DDAE725F972992A07C6C4FB9F62A8FFF58CE3CA926A1063530\".toLowerCase());\n-\n-        byte[] resultArr = NativeSecp256k1.sign(data, sec);\n-        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n-        assertEquals( sigString, \"30440220182A108E1448DC8F1FB467D06A0F3BB8EA0533584CB954EF8DA112F1D60E39A202201C66F36DA211C087F3AF88B50EDF4F9BDAA6CF5FD6817E74DCA34DB12390C6E9\" , \"testSignPos\");\n-    }\n-\n-    /**\n-      * This tests sign() for a invalid secretkey\n-      */\n-    public static void testSignNeg() throws AssertFailException{\n-        byte[] data = BaseEncoding.base16().lowerCase().decode(\"CF80CD8AED482D5D1527D7DC72FCEFF84E6326592848447D2DC0B0E87DFC9A90\".toLowerCase()); //sha256hash of \"testing\"\n-        byte[] sec = BaseEncoding.base16().lowerCase().decode(\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\".toLowerCase());\n-\n-        byte[] resultArr = NativeSecp256k1.sign(data, sec);\n-        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n-        assertEquals( sigString, \"\" , \"testSignNeg\");\n-    }\n-\n-    /**\n-      * This tests private key tweak-add\n-      */\n-    public static void testPrivKeyTweakAdd_1() throws AssertFailException {\n-        byte[] sec = BaseEncoding.base16().lowerCase().decode(\"67E56582298859DDAE725F972992A07C6C4FB9F62A8FFF58CE3CA926A1063530\".toLowerCase());\n-        byte[] data = BaseEncoding.base16().lowerCase().decode(\"3982F19BEF1615BCCFBB05E321C10E1D4CBA3DF0E841C2E41EEB6016347653C3\".toLowerCase()); //sha256hash of \"tweak\"\n-\n-        byte[] resultArr = NativeSecp256k1.privKeyTweakAdd( sec , data );\n-        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n-        assertEquals( sigString , \"A168571E189E6F9A7E2D657A4B53AE99B909F7E712D1C23CED28093CD57C88F3\" , \"testPrivKeyAdd_1\");\n-    }\n-\n-    /**\n-      * This tests private key tweak-mul\n-      */\n-    public static void testPrivKeyTweakMul_1() throws AssertFailException {\n-        byte[] sec = BaseEncoding.base16().lowerCase().decode(\"67E56582298859DDAE725F972992A07C6C4FB9F62A8FFF58CE3CA926A1063530\".toLowerCase());\n-        byte[] data = BaseEncoding.base16().lowerCase().decode(\"3982F19BEF1615BCCFBB05E321C10E1D4CBA3DF0E841C2E41EEB6016347653C3\".toLowerCase()); //sha256hash of \"tweak\"\n-\n-        byte[] resultArr = NativeSecp256k1.privKeyTweakMul( sec , data );\n-        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n-        assertEquals( sigString , \"97F8184235F101550F3C71C927507651BD3F1CDB4A5A33B8986ACF0DEE20FFFC\" , \"testPrivKeyMul_1\");\n-    }\n-\n-    /**\n-      * This tests private key tweak-add uncompressed\n-      */\n-    public static void testPrivKeyTweakAdd_2() throws AssertFailException {\n-        byte[] pub = BaseEncoding.base16().lowerCase().decode(\"040A629506E1B65CD9D2E0BA9C75DF9C4FED0DB16DC9625ED14397F0AFC836FAE595DC53F8B0EFE61E703075BD9B143BAC75EC0E19F82A2208CAEB32BE53414C40\".toLowerCase());\n-        byte[] data = BaseEncoding.base16().lowerCase().decode(\"3982F19BEF1615BCCFBB05E321C10E1D4CBA3DF0E841C2E41EEB6016347653C3\".toLowerCase()); //sha256hash of \"tweak\"\n-\n-        byte[] resultArr = NativeSecp256k1.pubKeyTweakAdd( pub , data );\n-        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n-        assertEquals( sigString , \"0411C6790F4B663CCE607BAAE08C43557EDC1A4D11D88DFCB3D841D0C6A941AF525A268E2A863C148555C48FB5FBA368E88718A46E205FABC3DBA2CCFFAB0796EF\" , \"testPrivKeyAdd_2\");\n-    }\n-\n-    /**\n-      * This tests private key tweak-mul uncompressed\n-      */\n-    public static void testPrivKeyTweakMul_2() throws AssertFailException {\n-        byte[] pub = BaseEncoding.base16().lowerCase().decode(\"040A629506E1B65CD9D2E0BA9C75DF9C4FED0DB16DC9625ED14397F0AFC836FAE595DC53F8B0EFE61E703075BD9B143BAC75EC0E19F82A2208CAEB32BE53414C40\".toLowerCase());\n-        byte[] data = BaseEncoding.base16().lowerCase().decode(\"3982F19BEF1615BCCFBB05E321C10E1D4CBA3DF0E841C2E41EEB6016347653C3\".toLowerCase()); //sha256hash of \"tweak\"\n-\n-        byte[] resultArr = NativeSecp256k1.pubKeyTweakMul( pub , data );\n-        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n-        assertEquals( sigString , \"04E0FE6FE55EBCA626B98A807F6CAF654139E14E5E3698F01A9A658E21DC1D2791EC060D4F412A794D5370F672BC94B722640B5F76914151CFCA6E712CA48CC589\" , \"testPrivKeyMul_2\");\n-    }\n-\n-    /**\n-      * This tests seed randomization\n-      */\n-    public static void testRandomize() throws AssertFailException {\n-        byte[] seed = BaseEncoding.base16().lowerCase().decode(\"A441B15FE9A3CF56661190A0B93B9DEC7D04127288CC87250967CF3B52894D11\".toLowerCase()); //sha256hash of \"random\"\n-        boolean result = NativeSecp256k1.randomize(seed);\n-        assertEquals( result, true, \"testRandomize\");\n-    }\n-\n-    public static void testCreateECDHSecret() throws AssertFailException{\n-\n-        byte[] sec = BaseEncoding.base16().lowerCase().decode(\"67E56582298859DDAE725F972992A07C6C4FB9F62A8FFF58CE3CA926A1063530\".toLowerCase());\n-        byte[] pub = BaseEncoding.base16().lowerCase().decode(\"040A629506E1B65CD9D2E0BA9C75DF9C4FED0DB16DC9625ED14397F0AFC836FAE595DC53F8B0EFE61E703075BD9B143BAC75EC0E19F82A2208CAEB32BE53414C40\".toLowerCase());\n-\n-        byte[] resultArr = NativeSecp256k1.createECDHSecret(sec, pub);\n-        String ecdhString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n-        assertEquals( ecdhString, \"2A2A67007A926E6594AF3EB564FC74005B37A9C8AEF2033C4552051B5C87F043\" , \"testCreateECDHSecret\");\n-    }\n-\n-    public static void main(String[] args) throws AssertFailException{\n-\n-\n-        System.out.println(\"\\n libsecp256k1 enabled: \" + Secp256k1Context.isEnabled() + \"\\n\");\n-\n-        assertEquals( Secp256k1Context.isEnabled(), true, \"isEnabled\" );\n-\n-        //Test verify() success/fail\n-        testVerifyPos();\n-        testVerifyNeg();\n-\n-        //Test secKeyVerify() success/fail\n-        testSecKeyVerifyPos();\n-        testSecKeyVerifyNeg();\n-\n-        //Test computePubkey() success/fail\n-        testPubKeyCreatePos();\n-        testPubKeyCreateNeg();\n-\n-        //Test sign() success/fail\n-        testSignPos();\n-        testSignNeg();\n-\n-        //Test privKeyTweakAdd() 1\n-        testPrivKeyTweakAdd_1();\n-\n-        //Test privKeyTweakMul() 2\n-        testPrivKeyTweakMul_1();\n-\n-        //Test privKeyTweakAdd() 3\n-        testPrivKeyTweakAdd_2();\n-\n-        //Test privKeyTweakMul() 4\n-        testPrivKeyTweakMul_2();\n-\n-        //Test randomize()\n-        testRandomize();\n-\n-        //Test ECDH\n-        testCreateECDHSecret();\n-\n-        NativeSecp256k1.cleanup();\n-\n-        System.out.println(\" All tests passed.\" );\n-\n-    }\n-}"
      },
      {
        "sha": "04732ba044363a5dc5c525661a090c1bdf1d077f",
        "filename": "src/secp256k1/src/java/org/bitcoin/NativeSecp256k1Util.java",
        "status": "removed",
        "additions": 0,
        "deletions": 45,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9ad6f14175c19b5d47267c3dd5840c14bad43c83/src/secp256k1/src/java/org/bitcoin/NativeSecp256k1Util.java",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9ad6f14175c19b5d47267c3dd5840c14bad43c83/src/secp256k1/src/java/org/bitcoin/NativeSecp256k1Util.java",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/java/org/bitcoin/NativeSecp256k1Util.java?ref=9ad6f14175c19b5d47267c3dd5840c14bad43c83",
        "patch": "@@ -1,45 +0,0 @@\n-/*\n- * Copyright 2014-2016 the libsecp256k1 contributors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.bitcoin;\n-\n-public class NativeSecp256k1Util{\n-\n-    public static void assertEquals( int val, int val2, String message ) throws AssertFailException{\n-      if( val != val2 )\n-        throw new AssertFailException(\"FAIL: \" + message);\n-    }\n-\n-    public static void assertEquals( boolean val, boolean val2, String message ) throws AssertFailException{\n-      if( val != val2 )\n-        throw new AssertFailException(\"FAIL: \" + message);\n-      else\n-        System.out.println(\"PASS: \" + message);\n-    }\n-\n-    public static void assertEquals( String val, String val2, String message ) throws AssertFailException{\n-      if( !val.equals(val2) )\n-        throw new AssertFailException(\"FAIL: \" + message);\n-      else\n-        System.out.println(\"PASS: \" + message);\n-    }\n-\n-    public static class AssertFailException extends Exception {\n-      public AssertFailException(String message) {\n-        super( message );\n-      }\n-    }\n-}"
      },
      {
        "sha": "216c986a8b564d49b01243d513bdd182339e51b6",
        "filename": "src/secp256k1/src/java/org/bitcoin/Secp256k1Context.java",
        "status": "removed",
        "additions": 0,
        "deletions": 51,
        "changes": 51,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9ad6f14175c19b5d47267c3dd5840c14bad43c83/src/secp256k1/src/java/org/bitcoin/Secp256k1Context.java",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9ad6f14175c19b5d47267c3dd5840c14bad43c83/src/secp256k1/src/java/org/bitcoin/Secp256k1Context.java",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/java/org/bitcoin/Secp256k1Context.java?ref=9ad6f14175c19b5d47267c3dd5840c14bad43c83",
        "patch": "@@ -1,51 +0,0 @@\n-/*\n- * Copyright 2014-2016 the libsecp256k1 contributors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.bitcoin;\n-\n-/**\n- * This class holds the context reference used in native methods \n- * to handle ECDSA operations.\n- */\n-public class Secp256k1Context {\n-  private static final boolean enabled; //true if the library is loaded\n-  private static final long context; //ref to pointer to context obj\n-\n-  static { //static initializer\n-      boolean isEnabled = true;\n-      long contextRef = -1;\n-      try {\n-          System.loadLibrary(\"secp256k1\");\n-          contextRef = secp256k1_init_context();\n-      } catch (UnsatisfiedLinkError e) {\n-          System.out.println(\"UnsatisfiedLinkError: \" + e.toString());\n-          isEnabled = false;\n-      }\n-      enabled = isEnabled;\n-      context = contextRef;\n-  }\n-\n-  public static boolean isEnabled() {\n-     return enabled;\n-  }\n-\n-  public static long getContext() {\n-     if(!enabled) return -1; //sanity check\n-     return context;\n-  }\n-\n-  private static native long secp256k1_init_context();\n-}"
      },
      {
        "sha": "b50970b4f24c8cd3480368aab34a9d83df92fe1b",
        "filename": "src/secp256k1/src/java/org_bitcoin_NativeSecp256k1.c",
        "status": "removed",
        "additions": 0,
        "deletions": 379,
        "changes": 379,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9ad6f14175c19b5d47267c3dd5840c14bad43c83/src/secp256k1/src/java/org_bitcoin_NativeSecp256k1.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9ad6f14175c19b5d47267c3dd5840c14bad43c83/src/secp256k1/src/java/org_bitcoin_NativeSecp256k1.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/java/org_bitcoin_NativeSecp256k1.c?ref=9ad6f14175c19b5d47267c3dd5840c14bad43c83",
        "patch": "@@ -1,379 +0,0 @@\n-#include <stdlib.h>\n-#include <stdint.h>\n-#include <string.h>\n-#include \"org_bitcoin_NativeSecp256k1.h\"\n-#include \"include/secp256k1.h\"\n-#include \"include/secp256k1_ecdh.h\"\n-#include \"include/secp256k1_recovery.h\"\n-\n-\n-SECP256K1_API jlong JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ctx_1clone\n-  (JNIEnv* env, jclass classObject, jlong ctx_l)\n-{\n-  const secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n-\n-  jlong ctx_clone_l = (uintptr_t) secp256k1_context_clone(ctx);\n-\n-  (void)classObject;(void)env;\n-\n-  return ctx_clone_l;\n-\n-}\n-\n-SECP256K1_API jint JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1context_1randomize\n-  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l)\n-{\n-  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n-\n-  const unsigned char* seed = (unsigned char*) (*env)->GetDirectBufferAddress(env, byteBufferObject);\n-\n-  (void)classObject;\n-\n-  return secp256k1_context_randomize(ctx, seed);\n-\n-}\n-\n-SECP256K1_API void JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1destroy_1context\n-  (JNIEnv* env, jclass classObject, jlong ctx_l)\n-{\n-  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n-\n-  secp256k1_context_destroy(ctx);\n-\n-  (void)classObject;(void)env;\n-}\n-\n-SECP256K1_API jint JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ecdsa_1verify\n-  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l, jint siglen, jint publen)\n-{\n-  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n-\n-  unsigned char* data = (unsigned char*) (*env)->GetDirectBufferAddress(env, byteBufferObject);\n-  const unsigned char* sigdata = {  (unsigned char*) (data + 32) };\n-  const unsigned char* pubdata = { (unsigned char*) (data + siglen + 32) };\n-\n-  secp256k1_ecdsa_signature sig;\n-  secp256k1_pubkey pubkey;\n-\n-  int ret = secp256k1_ecdsa_signature_parse_der(ctx, &sig, sigdata, siglen);\n-\n-  if( ret ) {\n-    ret = secp256k1_ec_pubkey_parse(ctx, &pubkey, pubdata, publen);\n-\n-    if( ret ) {\n-      ret = secp256k1_ecdsa_verify(ctx, &sig, data, &pubkey);\n-    }\n-  }\n-\n-  (void)classObject;\n-\n-  return ret;\n-}\n-\n-SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ecdsa_1sign\n-  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l)\n-{\n-  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n-  unsigned char* data = (unsigned char*) (*env)->GetDirectBufferAddress(env, byteBufferObject);\n-  unsigned char* secKey = (unsigned char*) (data + 32);\n-\n-  jobjectArray retArray;\n-  jbyteArray sigArray, intsByteArray;\n-  unsigned char intsarray[2];\n-\n-  secp256k1_ecdsa_signature sig[72];\n-\n-  int ret = secp256k1_ecdsa_sign(ctx, sig, data, secKey, NULL, NULL);\n-\n-  unsigned char outputSer[72];\n-  size_t outputLen = 72;\n-\n-  if( ret ) {\n-    int ret2 = secp256k1_ecdsa_signature_serialize_der(ctx,outputSer, &outputLen, sig ); (void)ret2;\n-  }\n-\n-  intsarray[0] = outputLen;\n-  intsarray[1] = ret;\n-\n-  retArray = (*env)->NewObjectArray(env, 2,\n-    (*env)->FindClass(env, \"[B\"),\n-    (*env)->NewByteArray(env, 1));\n-\n-  sigArray = (*env)->NewByteArray(env, outputLen);\n-  (*env)->SetByteArrayRegion(env, sigArray, 0, outputLen, (jbyte*)outputSer);\n-  (*env)->SetObjectArrayElement(env, retArray, 0, sigArray);\n-\n-  intsByteArray = (*env)->NewByteArray(env, 2);\n-  (*env)->SetByteArrayRegion(env, intsByteArray, 0, 2, (jbyte*)intsarray);\n-  (*env)->SetObjectArrayElement(env, retArray, 1, intsByteArray);\n-\n-  (void)classObject;\n-\n-  return retArray;\n-}\n-\n-SECP256K1_API jint JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ec_1seckey_1verify\n-  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l)\n-{\n-  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n-  unsigned char* secKey = (unsigned char*) (*env)->GetDirectBufferAddress(env, byteBufferObject);\n-\n-  (void)classObject;\n-\n-  return secp256k1_ec_seckey_verify(ctx, secKey);\n-}\n-\n-SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ec_1pubkey_1create\n-  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l)\n-{\n-  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n-  const unsigned char* secKey = (unsigned char*) (*env)->GetDirectBufferAddress(env, byteBufferObject);\n-\n-  secp256k1_pubkey pubkey;\n-\n-  jobjectArray retArray;\n-  jbyteArray pubkeyArray, intsByteArray;\n-  unsigned char intsarray[2];\n-\n-  int ret = secp256k1_ec_pubkey_create(ctx, &pubkey, secKey);\n-\n-  unsigned char outputSer[65];\n-  size_t outputLen = 65;\n-\n-  if( ret ) {\n-    int ret2 = secp256k1_ec_pubkey_serialize(ctx,outputSer, &outputLen, &pubkey,SECP256K1_EC_UNCOMPRESSED );(void)ret2;\n-  }\n-\n-  intsarray[0] = outputLen;\n-  intsarray[1] = ret;\n-\n-  retArray = (*env)->NewObjectArray(env, 2,\n-    (*env)->FindClass(env, \"[B\"),\n-    (*env)->NewByteArray(env, 1));\n-\n-  pubkeyArray = (*env)->NewByteArray(env, outputLen);\n-  (*env)->SetByteArrayRegion(env, pubkeyArray, 0, outputLen, (jbyte*)outputSer);\n-  (*env)->SetObjectArrayElement(env, retArray, 0, pubkeyArray);\n-\n-  intsByteArray = (*env)->NewByteArray(env, 2);\n-  (*env)->SetByteArrayRegion(env, intsByteArray, 0, 2, (jbyte*)intsarray);\n-  (*env)->SetObjectArrayElement(env, retArray, 1, intsByteArray);\n-\n-  (void)classObject;\n-\n-  return retArray;\n-\n-}\n-\n-SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1privkey_1tweak_1add\n-  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l)\n-{\n-  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n-  unsigned char* privkey = (unsigned char*) (*env)->GetDirectBufferAddress(env, byteBufferObject);\n-  const unsigned char* tweak = (unsigned char*) (privkey + 32);\n-\n-  jobjectArray retArray;\n-  jbyteArray privArray, intsByteArray;\n-  unsigned char intsarray[2];\n-\n-  int privkeylen = 32;\n-\n-  int ret = secp256k1_ec_privkey_tweak_add(ctx, privkey, tweak);\n-\n-  intsarray[0] = privkeylen;\n-  intsarray[1] = ret;\n-\n-  retArray = (*env)->NewObjectArray(env, 2,\n-    (*env)->FindClass(env, \"[B\"),\n-    (*env)->NewByteArray(env, 1));\n-\n-  privArray = (*env)->NewByteArray(env, privkeylen);\n-  (*env)->SetByteArrayRegion(env, privArray, 0, privkeylen, (jbyte*)privkey);\n-  (*env)->SetObjectArrayElement(env, retArray, 0, privArray);\n-\n-  intsByteArray = (*env)->NewByteArray(env, 2);\n-  (*env)->SetByteArrayRegion(env, intsByteArray, 0, 2, (jbyte*)intsarray);\n-  (*env)->SetObjectArrayElement(env, retArray, 1, intsByteArray);\n-\n-  (void)classObject;\n-\n-  return retArray;\n-}\n-\n-SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1privkey_1tweak_1mul\n-  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l)\n-{\n-  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n-  unsigned char* privkey = (unsigned char*) (*env)->GetDirectBufferAddress(env, byteBufferObject);\n-  const unsigned char* tweak = (unsigned char*) (privkey + 32);\n-\n-  jobjectArray retArray;\n-  jbyteArray privArray, intsByteArray;\n-  unsigned char intsarray[2];\n-\n-  int privkeylen = 32;\n-\n-  int ret = secp256k1_ec_privkey_tweak_mul(ctx, privkey, tweak);\n-\n-  intsarray[0] = privkeylen;\n-  intsarray[1] = ret;\n-\n-  retArray = (*env)->NewObjectArray(env, 2,\n-    (*env)->FindClass(env, \"[B\"),\n-    (*env)->NewByteArray(env, 1));\n-\n-  privArray = (*env)->NewByteArray(env, privkeylen);\n-  (*env)->SetByteArrayRegion(env, privArray, 0, privkeylen, (jbyte*)privkey);\n-  (*env)->SetObjectArrayElement(env, retArray, 0, privArray);\n-\n-  intsByteArray = (*env)->NewByteArray(env, 2);\n-  (*env)->SetByteArrayRegion(env, intsByteArray, 0, 2, (jbyte*)intsarray);\n-  (*env)->SetObjectArrayElement(env, retArray, 1, intsByteArray);\n-\n-  (void)classObject;\n-\n-  return retArray;\n-}\n-\n-SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1pubkey_1tweak_1add\n-  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l, jint publen)\n-{\n-  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n-/*  secp256k1_pubkey* pubkey = (secp256k1_pubkey*) (*env)->GetDirectBufferAddress(env, byteBufferObject);*/\n-  unsigned char* pkey = (*env)->GetDirectBufferAddress(env, byteBufferObject);\n-  const unsigned char* tweak = (unsigned char*) (pkey + publen);\n-\n-  jobjectArray retArray;\n-  jbyteArray pubArray, intsByteArray;\n-  unsigned char intsarray[2];\n-  unsigned char outputSer[65];\n-  size_t outputLen = 65;\n-\n-  secp256k1_pubkey pubkey;\n-  int ret = secp256k1_ec_pubkey_parse(ctx, &pubkey, pkey, publen);\n-\n-  if( ret ) {\n-    ret = secp256k1_ec_pubkey_tweak_add(ctx, &pubkey, tweak);\n-  }\n-\n-  if( ret ) {\n-    int ret2 = secp256k1_ec_pubkey_serialize(ctx,outputSer, &outputLen, &pubkey,SECP256K1_EC_UNCOMPRESSED );(void)ret2;\n-  }\n-\n-  intsarray[0] = outputLen;\n-  intsarray[1] = ret;\n-\n-  retArray = (*env)->NewObjectArray(env, 2,\n-    (*env)->FindClass(env, \"[B\"),\n-    (*env)->NewByteArray(env, 1));\n-\n-  pubArray = (*env)->NewByteArray(env, outputLen);\n-  (*env)->SetByteArrayRegion(env, pubArray, 0, outputLen, (jbyte*)outputSer);\n-  (*env)->SetObjectArrayElement(env, retArray, 0, pubArray);\n-\n-  intsByteArray = (*env)->NewByteArray(env, 2);\n-  (*env)->SetByteArrayRegion(env, intsByteArray, 0, 2, (jbyte*)intsarray);\n-  (*env)->SetObjectArrayElement(env, retArray, 1, intsByteArray);\n-\n-  (void)classObject;\n-\n-  return retArray;\n-}\n-\n-SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1pubkey_1tweak_1mul\n-  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l, jint publen)\n-{\n-  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n-  unsigned char* pkey = (*env)->GetDirectBufferAddress(env, byteBufferObject);\n-  const unsigned char* tweak = (unsigned char*) (pkey + publen);\n-\n-  jobjectArray retArray;\n-  jbyteArray pubArray, intsByteArray;\n-  unsigned char intsarray[2];\n-  unsigned char outputSer[65];\n-  size_t outputLen = 65;\n-\n-  secp256k1_pubkey pubkey;\n-  int ret = secp256k1_ec_pubkey_parse(ctx, &pubkey, pkey, publen);\n-\n-  if ( ret ) {\n-    ret = secp256k1_ec_pubkey_tweak_mul(ctx, &pubkey, tweak);\n-  }\n-\n-  if( ret ) {\n-    int ret2 = secp256k1_ec_pubkey_serialize(ctx,outputSer, &outputLen, &pubkey,SECP256K1_EC_UNCOMPRESSED );(void)ret2;\n-  }\n-\n-  intsarray[0] = outputLen;\n-  intsarray[1] = ret;\n-\n-  retArray = (*env)->NewObjectArray(env, 2,\n-    (*env)->FindClass(env, \"[B\"),\n-    (*env)->NewByteArray(env, 1));\n-\n-  pubArray = (*env)->NewByteArray(env, outputLen);\n-  (*env)->SetByteArrayRegion(env, pubArray, 0, outputLen, (jbyte*)outputSer);\n-  (*env)->SetObjectArrayElement(env, retArray, 0, pubArray);\n-\n-  intsByteArray = (*env)->NewByteArray(env, 2);\n-  (*env)->SetByteArrayRegion(env, intsByteArray, 0, 2, (jbyte*)intsarray);\n-  (*env)->SetObjectArrayElement(env, retArray, 1, intsByteArray);\n-\n-  (void)classObject;\n-\n-  return retArray;\n-}\n-\n-SECP256K1_API jlong JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ecdsa_1pubkey_1combine\n-  (JNIEnv * env, jclass classObject, jobject byteBufferObject, jlong ctx_l, jint numkeys)\n-{\n-  (void)classObject;(void)env;(void)byteBufferObject;(void)ctx_l;(void)numkeys;\n-\n-  return 0;\n-}\n-\n-SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ecdh\n-  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l, jint publen)\n-{\n-  secp256k1_context *ctx = (secp256k1_context*)(uintptr_t)ctx_l;\n-  const unsigned char* secdata = (*env)->GetDirectBufferAddress(env, byteBufferObject);\n-  const unsigned char* pubdata = (const unsigned char*) (secdata + 32);\n-\n-  jobjectArray retArray;\n-  jbyteArray outArray, intsByteArray;\n-  unsigned char intsarray[1];\n-  secp256k1_pubkey pubkey;\n-  unsigned char nonce_res[32];\n-  size_t outputLen = 32;\n-\n-  int ret = secp256k1_ec_pubkey_parse(ctx, &pubkey, pubdata, publen);\n-\n-  if (ret) {\n-    ret = secp256k1_ecdh(\n-      ctx,\n-      nonce_res,\n-      &pubkey,\n-      secdata,\n-      NULL,\n-      NULL\n-    );\n-  }\n-\n-  intsarray[0] = ret;\n-\n-  retArray = (*env)->NewObjectArray(env, 2,\n-    (*env)->FindClass(env, \"[B\"),\n-    (*env)->NewByteArray(env, 1));\n-\n-  outArray = (*env)->NewByteArray(env, outputLen);\n-  (*env)->SetByteArrayRegion(env, outArray, 0, 32, (jbyte*)nonce_res);\n-  (*env)->SetObjectArrayElement(env, retArray, 0, outArray);\n-\n-  intsByteArray = (*env)->NewByteArray(env, 1);\n-  (*env)->SetByteArrayRegion(env, intsByteArray, 0, 1, (jbyte*)intsarray);\n-  (*env)->SetObjectArrayElement(env, retArray, 1, intsByteArray);\n-\n-  (void)classObject;\n-\n-  return retArray;\n-}"
      },
      {
        "sha": "fe613c9e9e77eddb18e0b0d8422948678f3408a8",
        "filename": "src/secp256k1/src/java/org_bitcoin_NativeSecp256k1.h",
        "status": "removed",
        "additions": 0,
        "deletions": 119,
        "changes": 119,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9ad6f14175c19b5d47267c3dd5840c14bad43c83/src/secp256k1/src/java/org_bitcoin_NativeSecp256k1.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9ad6f14175c19b5d47267c3dd5840c14bad43c83/src/secp256k1/src/java/org_bitcoin_NativeSecp256k1.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/java/org_bitcoin_NativeSecp256k1.h?ref=9ad6f14175c19b5d47267c3dd5840c14bad43c83",
        "patch": "@@ -1,119 +0,0 @@\n-/* DO NOT EDIT THIS FILE - it is machine generated */\n-#include <jni.h>\n-#include \"include/secp256k1.h\"\n-/* Header for class org_bitcoin_NativeSecp256k1 */\n-\n-#ifndef _Included_org_bitcoin_NativeSecp256k1\n-#define _Included_org_bitcoin_NativeSecp256k1\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-/*\n- * Class:     org_bitcoin_NativeSecp256k1\n- * Method:    secp256k1_ctx_clone\n- * Signature: (J)J\n- */\n-SECP256K1_API jlong JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ctx_1clone\n-  (JNIEnv *, jclass, jlong);\n-\n-/*\n- * Class:     org_bitcoin_NativeSecp256k1\n- * Method:    secp256k1_context_randomize\n- * Signature: (Ljava/nio/ByteBuffer;J)I\n- */\n-SECP256K1_API jint JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1context_1randomize\n-  (JNIEnv *, jclass, jobject, jlong);\n-\n-/*\n- * Class:     org_bitcoin_NativeSecp256k1\n- * Method:    secp256k1_privkey_tweak_add\n- * Signature: (Ljava/nio/ByteBuffer;J)[[B\n- */\n-SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1privkey_1tweak_1add\n-  (JNIEnv *, jclass, jobject, jlong);\n-\n-/*\n- * Class:     org_bitcoin_NativeSecp256k1\n- * Method:    secp256k1_privkey_tweak_mul\n- * Signature: (Ljava/nio/ByteBuffer;J)[[B\n- */\n-SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1privkey_1tweak_1mul\n-  (JNIEnv *, jclass, jobject, jlong);\n-\n-/*\n- * Class:     org_bitcoin_NativeSecp256k1\n- * Method:    secp256k1_pubkey_tweak_add\n- * Signature: (Ljava/nio/ByteBuffer;JI)[[B\n- */\n-SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1pubkey_1tweak_1add\n-  (JNIEnv *, jclass, jobject, jlong, jint);\n-\n-/*\n- * Class:     org_bitcoin_NativeSecp256k1\n- * Method:    secp256k1_pubkey_tweak_mul\n- * Signature: (Ljava/nio/ByteBuffer;JI)[[B\n- */\n-SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1pubkey_1tweak_1mul\n-  (JNIEnv *, jclass, jobject, jlong, jint);\n-\n-/*\n- * Class:     org_bitcoin_NativeSecp256k1\n- * Method:    secp256k1_destroy_context\n- * Signature: (J)V\n- */\n-SECP256K1_API void JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1destroy_1context\n-  (JNIEnv *, jclass, jlong);\n-\n-/*\n- * Class:     org_bitcoin_NativeSecp256k1\n- * Method:    secp256k1_ecdsa_verify\n- * Signature: (Ljava/nio/ByteBuffer;JII)I\n- */\n-SECP256K1_API jint JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ecdsa_1verify\n-  (JNIEnv *, jclass, jobject, jlong, jint, jint);\n-\n-/*\n- * Class:     org_bitcoin_NativeSecp256k1\n- * Method:    secp256k1_ecdsa_sign\n- * Signature: (Ljava/nio/ByteBuffer;J)[[B\n- */\n-SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ecdsa_1sign\n-  (JNIEnv *, jclass, jobject, jlong);\n-\n-/*\n- * Class:     org_bitcoin_NativeSecp256k1\n- * Method:    secp256k1_ec_seckey_verify\n- * Signature: (Ljava/nio/ByteBuffer;J)I\n- */\n-SECP256K1_API jint JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ec_1seckey_1verify\n-  (JNIEnv *, jclass, jobject, jlong);\n-\n-/*\n- * Class:     org_bitcoin_NativeSecp256k1\n- * Method:    secp256k1_ec_pubkey_create\n- * Signature: (Ljava/nio/ByteBuffer;J)[[B\n- */\n-SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ec_1pubkey_1create\n-  (JNIEnv *, jclass, jobject, jlong);\n-\n-/*\n- * Class:     org_bitcoin_NativeSecp256k1\n- * Method:    secp256k1_ec_pubkey_parse\n- * Signature: (Ljava/nio/ByteBuffer;JI)[[B\n- */\n-SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ec_1pubkey_1parse\n-  (JNIEnv *, jclass, jobject, jlong, jint);\n-\n-/*\n- * Class:     org_bitcoin_NativeSecp256k1\n- * Method:    secp256k1_ecdh\n- * Signature: (Ljava/nio/ByteBuffer;JI)[[B\n- */\n-SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1ecdh\n-  (JNIEnv* env, jclass classObject, jobject byteBufferObject, jlong ctx_l, jint publen);\n-\n-\n-#ifdef __cplusplus\n-}\n-#endif\n-#endif"
      },
      {
        "sha": "a52939e7e7dacda374ec879d69b29ebb9add2dbc",
        "filename": "src/secp256k1/src/java/org_bitcoin_Secp256k1Context.c",
        "status": "removed",
        "additions": 0,
        "deletions": 15,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9ad6f14175c19b5d47267c3dd5840c14bad43c83/src/secp256k1/src/java/org_bitcoin_Secp256k1Context.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9ad6f14175c19b5d47267c3dd5840c14bad43c83/src/secp256k1/src/java/org_bitcoin_Secp256k1Context.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/java/org_bitcoin_Secp256k1Context.c?ref=9ad6f14175c19b5d47267c3dd5840c14bad43c83",
        "patch": "@@ -1,15 +0,0 @@\n-#include <stdlib.h>\n-#include <stdint.h>\n-#include \"org_bitcoin_Secp256k1Context.h\"\n-#include \"include/secp256k1.h\"\n-\n-SECP256K1_API jlong JNICALL Java_org_bitcoin_Secp256k1Context_secp256k1_1init_1context\n-  (JNIEnv* env, jclass classObject)\n-{\n-  secp256k1_context *ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n-\n-  (void)classObject;(void)env;\n-\n-  return (uintptr_t)ctx;\n-}\n-"
      },
      {
        "sha": "0d2bc84b7f3fde84f81115a037be6de105f0472b",
        "filename": "src/secp256k1/src/java/org_bitcoin_Secp256k1Context.h",
        "status": "removed",
        "additions": 0,
        "deletions": 22,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9ad6f14175c19b5d47267c3dd5840c14bad43c83/src/secp256k1/src/java/org_bitcoin_Secp256k1Context.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9ad6f14175c19b5d47267c3dd5840c14bad43c83/src/secp256k1/src/java/org_bitcoin_Secp256k1Context.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/java/org_bitcoin_Secp256k1Context.h?ref=9ad6f14175c19b5d47267c3dd5840c14bad43c83",
        "patch": "@@ -1,22 +0,0 @@\n-/* DO NOT EDIT THIS FILE - it is machine generated */\n-#include <jni.h>\n-#include \"include/secp256k1.h\"\n-/* Header for class org_bitcoin_Secp256k1Context */\n-\n-#ifndef _Included_org_bitcoin_Secp256k1Context\n-#define _Included_org_bitcoin_Secp256k1Context\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-/*\n- * Class:     org_bitcoin_Secp256k1Context\n- * Method:    secp256k1_init_context\n- * Signature: ()J\n- */\n-SECP256K1_API jlong JNICALL Java_org_bitcoin_Secp256k1Context_secp256k1_1init_1context\n-  (JNIEnv *, jclass);\n-\n-#ifdef __cplusplus\n-}\n-#endif\n-#endif"
      },
      {
        "sha": "07a25b80d4ab6f080d46fc55d635b0b86b7cb5f1",
        "filename": "src/secp256k1/src/modules/ecdh/main_impl.h",
        "status": "modified",
        "additions": 25,
        "deletions": 21,
        "changes": 46,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/modules/ecdh/main_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/modules/ecdh/main_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/ecdh/main_impl.h?ref=8903a1a0a78a705402123d2a5c465217cb9d791c",
        "patch": "@@ -10,14 +10,14 @@\n #include \"include/secp256k1_ecdh.h\"\n #include \"ecmult_const_impl.h\"\n \n-static int ecdh_hash_function_sha256(unsigned char *output, const unsigned char *x, const unsigned char *y, void *data) {\n-    unsigned char version = (y[31] & 0x01) | 0x02;\n+static int ecdh_hash_function_sha256(unsigned char *output, const unsigned char *x32, const unsigned char *y32, void *data) {\n+    unsigned char version = (y32[31] & 0x01) | 0x02;\n     secp256k1_sha256 sha;\n     (void)data;\n \n     secp256k1_sha256_initialize(&sha);\n     secp256k1_sha256_write(&sha, &version, 1);\n-    secp256k1_sha256_write(&sha, x, 32);\n+    secp256k1_sha256_write(&sha, x32, 32);\n     secp256k1_sha256_finalize(&sha, output);\n \n     return 1;\n@@ -32,36 +32,40 @@ int secp256k1_ecdh(const secp256k1_context* ctx, unsigned char *output, const se\n     secp256k1_gej res;\n     secp256k1_ge pt;\n     secp256k1_scalar s;\n+    unsigned char x[32];\n+    unsigned char y[32];\n+\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(output != NULL);\n     ARG_CHECK(point != NULL);\n     ARG_CHECK(scalar != NULL);\n+\n     if (hashfp == NULL) {\n         hashfp = secp256k1_ecdh_hash_function_default;\n     }\n \n     secp256k1_pubkey_load(ctx, &pt, point);\n     secp256k1_scalar_set_b32(&s, scalar, &overflow);\n-    if (overflow || secp256k1_scalar_is_zero(&s)) {\n-        ret = 0;\n-    } else {\n-        unsigned char x[32];\n-        unsigned char y[32];\n-\n-        secp256k1_ecmult_const(&res, &pt, &s, 256);\n-        secp256k1_ge_set_gej(&pt, &res);\n-\n-        /* Compute a hash of the point */\n-        secp256k1_fe_normalize(&pt.x);\n-        secp256k1_fe_normalize(&pt.y);\n-        secp256k1_fe_get_b32(x, &pt.x);\n-        secp256k1_fe_get_b32(y, &pt.y);\n-\n-        ret = hashfp(output, x, y, data);\n-    }\n \n+    overflow |= secp256k1_scalar_is_zero(&s);\n+    secp256k1_scalar_cmov(&s, &secp256k1_scalar_one, overflow);\n+\n+    secp256k1_ecmult_const(&res, &pt, &s, 256);\n+    secp256k1_ge_set_gej(&pt, &res);\n+\n+    /* Compute a hash of the point */\n+    secp256k1_fe_normalize(&pt.x);\n+    secp256k1_fe_normalize(&pt.y);\n+    secp256k1_fe_get_b32(x, &pt.x);\n+    secp256k1_fe_get_b32(y, &pt.y);\n+\n+    ret = hashfp(output, x, y, data);\n+\n+    memset(x, 0, 32);\n+    memset(y, 0, 32);\n     secp256k1_scalar_clear(&s);\n-    return ret;\n+\n+    return !!ret & !overflow;\n }\n \n #endif /* SECP256K1_MODULE_ECDH_MAIN_H */"
      },
      {
        "sha": "e2576aa953e5c19a7fcf1614412098830a0791d2",
        "filename": "src/secp256k1/src/modules/recovery/main_impl.h",
        "status": "modified",
        "additions": 3,
        "deletions": 36,
        "changes": 39,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/modules/recovery/main_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/modules/recovery/main_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/recovery/main_impl.h?ref=8903a1a0a78a705402123d2a5c465217cb9d791c",
        "patch": "@@ -122,48 +122,15 @@ static int secp256k1_ecdsa_sig_recover(const secp256k1_ecmult_context *ctx, cons\n \n int secp256k1_ecdsa_sign_recoverable(const secp256k1_context* ctx, secp256k1_ecdsa_recoverable_signature *signature, const unsigned char *msg32, const unsigned char *seckey, secp256k1_nonce_function noncefp, const void* noncedata) {\n     secp256k1_scalar r, s;\n-    secp256k1_scalar sec, non, msg;\n-    int recid;\n-    int ret = 0;\n-    int overflow = 0;\n+    int ret, recid;\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n     ARG_CHECK(msg32 != NULL);\n     ARG_CHECK(signature != NULL);\n     ARG_CHECK(seckey != NULL);\n-    if (noncefp == NULL) {\n-        noncefp = secp256k1_nonce_function_default;\n-    }\n \n-    secp256k1_scalar_set_b32(&sec, seckey, &overflow);\n-    /* Fail if the secret key is invalid. */\n-    if (!overflow && !secp256k1_scalar_is_zero(&sec)) {\n-        unsigned char nonce32[32];\n-        unsigned int count = 0;\n-        secp256k1_scalar_set_b32(&msg, msg32, NULL);\n-        while (1) {\n-            ret = noncefp(nonce32, msg32, seckey, NULL, (void*)noncedata, count);\n-            if (!ret) {\n-                break;\n-            }\n-            secp256k1_scalar_set_b32(&non, nonce32, &overflow);\n-            if (!secp256k1_scalar_is_zero(&non) && !overflow) {\n-                if (secp256k1_ecdsa_sig_sign(&ctx->ecmult_gen_ctx, &r, &s, &sec, &msg, &non, &recid)) {\n-                    break;\n-                }\n-            }\n-            count++;\n-        }\n-        memset(nonce32, 0, 32);\n-        secp256k1_scalar_clear(&msg);\n-        secp256k1_scalar_clear(&non);\n-        secp256k1_scalar_clear(&sec);\n-    }\n-    if (ret) {\n-        secp256k1_ecdsa_recoverable_signature_save(signature, &r, &s, recid);\n-    } else {\n-        memset(signature, 0, sizeof(*signature));\n-    }\n+    ret = secp256k1_ecdsa_sign_inner(ctx, &r, &s, &recid, msg32, seckey, noncefp, noncedata);\n+    secp256k1_ecdsa_recoverable_signature_save(signature, &r, &s, recid);\n     return ret;\n }\n "
      },
      {
        "sha": "38a533a755fc9aada88ffc66e358aee2e505d419",
        "filename": "src/secp256k1/src/modules/recovery/tests_impl.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/modules/recovery/tests_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/modules/recovery/tests_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/recovery/tests_impl.h?ref=8903a1a0a78a705402123d2a5c465217cb9d791c",
        "patch": "@@ -215,7 +215,7 @@ void test_ecdsa_recovery_edge_cases(void) {\n     };\n     const unsigned char sig64[64] = {\n         /* Generated by signing the above message with nonce 'This is the nonce we will use...'\n-         * and secret key 0 (which is not valid), resulting in recid 0. */\n+         * and secret key 0 (which is not valid), resulting in recid 1. */\n         0x67, 0xCB, 0x28, 0x5F, 0x9C, 0xD1, 0x94, 0xE8,\n         0x40, 0xD6, 0x29, 0x39, 0x7A, 0xF5, 0x56, 0x96,\n         0x62, 0xFD, 0xE4, 0x46, 0x49, 0x99, 0x59, 0x63,"
      },
      {
        "sha": "2a747035230bac4b6818d42032ce3c30ab427309",
        "filename": "src/secp256k1/src/scalar.h",
        "status": "modified",
        "additions": 12,
        "deletions": 1,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/scalar.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/scalar.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/scalar.h?ref=8903a1a0a78a705402123d2a5c465217cb9d791c",
        "patch": "@@ -32,9 +32,17 @@ static unsigned int secp256k1_scalar_get_bits(const secp256k1_scalar *a, unsigne\n /** Access bits from a scalar. Not constant time. */\n static unsigned int secp256k1_scalar_get_bits_var(const secp256k1_scalar *a, unsigned int offset, unsigned int count);\n \n-/** Set a scalar from a big endian byte array. */\n+/** Set a scalar from a big endian byte array. The scalar will be reduced modulo group order `n`.\n+ * In:      bin:        pointer to a 32-byte array.\n+ * Out:     r:          scalar to be set.\n+ *          overflow:   non-zero if the scalar was bigger or equal to `n` before reduction, zero otherwise (can be NULL).\n+ */\n static void secp256k1_scalar_set_b32(secp256k1_scalar *r, const unsigned char *bin, int *overflow);\n \n+/** Set a scalar from a big endian byte array and returns 1 if it is a valid\n+ *  seckey and 0 otherwise. */\n+static int secp256k1_scalar_set_b32_seckey(secp256k1_scalar *r, const unsigned char *bin);\n+\n /** Set a scalar to an unsigned integer. */\n static void secp256k1_scalar_set_int(secp256k1_scalar *r, unsigned int v);\n \n@@ -103,4 +111,7 @@ static void secp256k1_scalar_split_lambda(secp256k1_scalar *r1, secp256k1_scalar\n /** Multiply a and b (without taking the modulus!), divide by 2**shift, and round to the nearest integer. Shift must be at least 256. */\n static void secp256k1_scalar_mul_shift_var(secp256k1_scalar *r, const secp256k1_scalar *a, const secp256k1_scalar *b, unsigned int shift);\n \n+/** If flag is true, set *r equal to *a; otherwise leave it. Constant-time.  Both *r and *a must be initialized.*/\n+static void secp256k1_scalar_cmov(secp256k1_scalar *r, const secp256k1_scalar *a, int flag);\n+\n #endif /* SECP256K1_SCALAR_H */"
      },
      {
        "sha": "8f539c4bc6b9fec329cb9acbceddc2f34605528c",
        "filename": "src/secp256k1/src/scalar_4x64_impl.h",
        "status": "modified",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/scalar_4x64_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/scalar_4x64_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/scalar_4x64_impl.h?ref=8903a1a0a78a705402123d2a5c465217cb9d791c",
        "patch": "@@ -946,4 +946,15 @@ SECP256K1_INLINE static void secp256k1_scalar_mul_shift_var(secp256k1_scalar *r,\n     secp256k1_scalar_cadd_bit(r, 0, (l[(shift - 1) >> 6] >> ((shift - 1) & 0x3f)) & 1);\n }\n \n+static SECP256K1_INLINE void secp256k1_scalar_cmov(secp256k1_scalar *r, const secp256k1_scalar *a, int flag) {\n+    uint64_t mask0, mask1;\n+    VG_CHECK_VERIFY(r->d, sizeof(r->d));\n+    mask0 = flag + ~((uint64_t)0);\n+    mask1 = ~mask0;\n+    r->d[0] = (r->d[0] & mask0) | (a->d[0] & mask1);\n+    r->d[1] = (r->d[1] & mask0) | (a->d[1] & mask1);\n+    r->d[2] = (r->d[2] & mask0) | (a->d[2] & mask1);\n+    r->d[3] = (r->d[3] & mask0) | (a->d[3] & mask1);\n+}\n+\n #endif /* SECP256K1_SCALAR_REPR_IMPL_H */"
      },
      {
        "sha": "3c372f34fe93313f682266c4c07e08acb019e758",
        "filename": "src/secp256k1/src/scalar_8x32_impl.h",
        "status": "modified",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/scalar_8x32_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/scalar_8x32_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/scalar_8x32_impl.h?ref=8903a1a0a78a705402123d2a5c465217cb9d791c",
        "patch": "@@ -718,4 +718,19 @@ SECP256K1_INLINE static void secp256k1_scalar_mul_shift_var(secp256k1_scalar *r,\n     secp256k1_scalar_cadd_bit(r, 0, (l[(shift - 1) >> 5] >> ((shift - 1) & 0x1f)) & 1);\n }\n \n+static SECP256K1_INLINE void secp256k1_scalar_cmov(secp256k1_scalar *r, const secp256k1_scalar *a, int flag) {\n+    uint32_t mask0, mask1;\n+    VG_CHECK_VERIFY(r->d, sizeof(r->d));\n+    mask0 = flag + ~((uint32_t)0);\n+    mask1 = ~mask0;\n+    r->d[0] = (r->d[0] & mask0) | (a->d[0] & mask1);\n+    r->d[1] = (r->d[1] & mask0) | (a->d[1] & mask1);\n+    r->d[2] = (r->d[2] & mask0) | (a->d[2] & mask1);\n+    r->d[3] = (r->d[3] & mask0) | (a->d[3] & mask1);\n+    r->d[4] = (r->d[4] & mask0) | (a->d[4] & mask1);\n+    r->d[5] = (r->d[5] & mask0) | (a->d[5] & mask1);\n+    r->d[6] = (r->d[6] & mask0) | (a->d[6] & mask1);\n+    r->d[7] = (r->d[7] & mask0) | (a->d[7] & mask1);\n+}\n+\n #endif /* SECP256K1_SCALAR_REPR_IMPL_H */"
      },
      {
        "sha": "70cd73db062af26508453fda50ee5a77789f4c66",
        "filename": "src/secp256k1/src/scalar_impl.h",
        "status": "modified",
        "additions": 10,
        "deletions": 1,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/scalar_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/scalar_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/scalar_impl.h?ref=8903a1a0a78a705402123d2a5c465217cb9d791c",
        "patch": "@@ -7,8 +7,8 @@\n #ifndef SECP256K1_SCALAR_IMPL_H\n #define SECP256K1_SCALAR_IMPL_H\n \n-#include \"group.h\"\n #include \"scalar.h\"\n+#include \"util.h\"\n \n #if defined HAVE_CONFIG_H\n #include \"libsecp256k1-config.h\"\n@@ -24,6 +24,9 @@\n #error \"Please select scalar implementation\"\n #endif\n \n+static const secp256k1_scalar secp256k1_scalar_one = SECP256K1_SCALAR_CONST(0, 0, 0, 0, 0, 0, 0, 1);\n+static const secp256k1_scalar secp256k1_scalar_zero = SECP256K1_SCALAR_CONST(0, 0, 0, 0, 0, 0, 0, 0);\n+\n #ifndef USE_NUM_NONE\n static void secp256k1_scalar_get_num(secp256k1_num *r, const secp256k1_scalar *a) {\n     unsigned char c[32];\n@@ -52,6 +55,12 @@ static void secp256k1_scalar_order_get_num(secp256k1_num *r) {\n }\n #endif\n \n+static int secp256k1_scalar_set_b32_seckey(secp256k1_scalar *r, const unsigned char *bin) {\n+    int overflow;\n+    secp256k1_scalar_set_b32(r, bin, &overflow);\n+    return (!overflow) & (!secp256k1_scalar_is_zero(r));\n+}\n+\n static void secp256k1_scalar_inverse(secp256k1_scalar *r, const secp256k1_scalar *x) {\n #if defined(EXHAUSTIVE_TEST_ORDER)\n     int i;"
      },
      {
        "sha": "2794a7f171fa39b5741e4345455a3435b5a8a39d",
        "filename": "src/secp256k1/src/scalar_low.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/scalar_low.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/scalar_low.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/scalar_low.h?ref=8903a1a0a78a705402123d2a5c465217cb9d791c",
        "patch": "@@ -12,4 +12,6 @@\n /** A scalar modulo the group order of the secp256k1 curve. */\n typedef uint32_t secp256k1_scalar;\n \n+#define SECP256K1_SCALAR_CONST(d7, d6, d5, d4, d3, d2, d1, d0) (d0)\n+\n #endif /* SECP256K1_SCALAR_REPR_H */"
      },
      {
        "sha": "b79cf1ff6c5cad46a183d51678b352e1154ac6a6",
        "filename": "src/secp256k1/src/scalar_low_impl.h",
        "status": "modified",
        "additions": 12,
        "deletions": 1,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/scalar_low_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/scalar_low_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/scalar_low_impl.h?ref=8903a1a0a78a705402123d2a5c465217cb9d791c",
        "patch": "@@ -38,8 +38,11 @@ static int secp256k1_scalar_add(secp256k1_scalar *r, const secp256k1_scalar *a,\n \n static void secp256k1_scalar_cadd_bit(secp256k1_scalar *r, unsigned int bit, int flag) {\n     if (flag && bit < 32)\n-        *r += (1 << bit);\n+        *r += ((uint32_t)1 << bit);\n #ifdef VERIFY\n+    VERIFY_CHECK(bit < 32);\n+    /* Verify that adding (1 << bit) will not overflow any in-range scalar *r by overflowing the underlying uint32_t. */\n+    VERIFY_CHECK(((uint32_t)1 << bit) - 1 <= UINT32_MAX - EXHAUSTIVE_TEST_ORDER);\n     VERIFY_CHECK(secp256k1_scalar_check_overflow(r) == 0);\n #endif\n }\n@@ -111,4 +114,12 @@ SECP256K1_INLINE static int secp256k1_scalar_eq(const secp256k1_scalar *a, const\n     return *a == *b;\n }\n \n+static SECP256K1_INLINE void secp256k1_scalar_cmov(secp256k1_scalar *r, const secp256k1_scalar *a, int flag) {\n+    uint32_t mask0, mask1;\n+    VG_CHECK_VERIFY(r, sizeof(*r));\n+    mask0 = flag + ~((uint32_t)0);\n+    mask1 = ~mask0;\n+    *r = (*r & mask0) | (*a & mask1);\n+}\n+\n #endif /* SECP256K1_SCALAR_REPR_IMPL_H */"
      },
      {
        "sha": "77b35d126bbe6b22c4a2e72311dd87f91039848e",
        "filename": "src/secp256k1/src/scratch.h",
        "status": "modified",
        "additions": 17,
        "deletions": 14,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/scratch.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/scratch.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/scratch.h?ref=8903a1a0a78a705402123d2a5c465217cb9d791c",
        "patch": "@@ -7,33 +7,36 @@\n #ifndef _SECP256K1_SCRATCH_\n #define _SECP256K1_SCRATCH_\n \n-#define SECP256K1_SCRATCH_MAX_FRAMES\t5\n-\n /* The typedef is used internally; the struct name is used in the public API\n  * (where it is exposed as a different typedef) */\n typedef struct secp256k1_scratch_space_struct {\n-    void *data[SECP256K1_SCRATCH_MAX_FRAMES];\n-    size_t offset[SECP256K1_SCRATCH_MAX_FRAMES];\n-    size_t frame_size[SECP256K1_SCRATCH_MAX_FRAMES];\n-    size_t frame;\n+    /** guard against interpreting this object as other types */\n+    unsigned char magic[8];\n+    /** actual allocated data */\n+    void *data;\n+    /** amount that has been allocated (i.e. `data + offset` is the next\n+     *  available pointer)  */\n+    size_t alloc_size;\n+    /** maximum size available to allocate */\n     size_t max_size;\n-    const secp256k1_callback* error_callback;\n } secp256k1_scratch;\n \n static secp256k1_scratch* secp256k1_scratch_create(const secp256k1_callback* error_callback, size_t max_size);\n \n-static void secp256k1_scratch_destroy(secp256k1_scratch* scratch);\n+static void secp256k1_scratch_destroy(const secp256k1_callback* error_callback, secp256k1_scratch* scratch);\n \n-/** Attempts to allocate a new stack frame with `n` available bytes. Returns 1 on success, 0 on failure */\n-static int secp256k1_scratch_allocate_frame(secp256k1_scratch* scratch, size_t n, size_t objects);\n+/** Returns an opaque object used to \"checkpoint\" a scratch space. Used\n+ *  with `secp256k1_scratch_apply_checkpoint` to undo allocations. */\n+static size_t secp256k1_scratch_checkpoint(const secp256k1_callback* error_callback, const secp256k1_scratch* scratch);\n \n-/** Deallocates a stack frame */\n-static void secp256k1_scratch_deallocate_frame(secp256k1_scratch* scratch);\n+/** Applies a check point received from `secp256k1_scratch_checkpoint`,\n+ *  undoing all allocations since that point. */\n+static void secp256k1_scratch_apply_checkpoint(const secp256k1_callback* error_callback, secp256k1_scratch* scratch, size_t checkpoint);\n \n /** Returns the maximum allocation the scratch space will allow */\n-static size_t secp256k1_scratch_max_allocation(const secp256k1_scratch* scratch, size_t n_objects);\n+static size_t secp256k1_scratch_max_allocation(const secp256k1_callback* error_callback, const secp256k1_scratch* scratch, size_t n_objects);\n \n /** Returns a pointer into the most recently allocated frame, or NULL if there is insufficient available space */\n-static void *secp256k1_scratch_alloc(secp256k1_scratch* scratch, size_t n);\n+static void *secp256k1_scratch_alloc(const secp256k1_callback* error_callback, secp256k1_scratch* scratch, size_t n);\n \n #endif"
      },
      {
        "sha": "4cee70000147b7b84e5759f00b0275fb9ead9107",
        "filename": "src/secp256k1/src/scratch_impl.h",
        "status": "modified",
        "additions": 47,
        "deletions": 45,
        "changes": 92,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/scratch_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/scratch_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/scratch_impl.h?ref=8903a1a0a78a705402123d2a5c465217cb9d791c",
        "patch": "@@ -7,78 +7,80 @@\n #ifndef _SECP256K1_SCRATCH_IMPL_H_\n #define _SECP256K1_SCRATCH_IMPL_H_\n \n+#include \"util.h\"\n #include \"scratch.h\"\n \n-/* Using 16 bytes alignment because common architectures never have alignment\n- * requirements above 8 for any of the types we care about. In addition we\n- * leave some room because currently we don't care about a few bytes.\n- * TODO: Determine this at configure time. */\n-#define ALIGNMENT 16\n-\n-static secp256k1_scratch* secp256k1_scratch_create(const secp256k1_callback* error_callback, size_t max_size) {\n-    secp256k1_scratch* ret = (secp256k1_scratch*)checked_malloc(error_callback, sizeof(*ret));\n+static secp256k1_scratch* secp256k1_scratch_create(const secp256k1_callback* error_callback, size_t size) {\n+    const size_t base_alloc = ((sizeof(secp256k1_scratch) + ALIGNMENT - 1) / ALIGNMENT) * ALIGNMENT;\n+    void *alloc = checked_malloc(error_callback, base_alloc + size);\n+    secp256k1_scratch* ret = (secp256k1_scratch *)alloc;\n     if (ret != NULL) {\n         memset(ret, 0, sizeof(*ret));\n-        ret->max_size = max_size;\n-        ret->error_callback = error_callback;\n+        memcpy(ret->magic, \"scratch\", 8);\n+        ret->data = (void *) ((char *) alloc + base_alloc);\n+        ret->max_size = size;\n     }\n     return ret;\n }\n \n-static void secp256k1_scratch_destroy(secp256k1_scratch* scratch) {\n+static void secp256k1_scratch_destroy(const secp256k1_callback* error_callback, secp256k1_scratch* scratch) {\n     if (scratch != NULL) {\n-        VERIFY_CHECK(scratch->frame == 0);\n+        VERIFY_CHECK(scratch->alloc_size == 0); /* all checkpoints should be applied */\n+        if (memcmp(scratch->magic, \"scratch\", 8) != 0) {\n+            secp256k1_callback_call(error_callback, \"invalid scratch space\");\n+            return;\n+        }\n+        memset(scratch->magic, 0, sizeof(scratch->magic));\n         free(scratch);\n     }\n }\n \n-static size_t secp256k1_scratch_max_allocation(const secp256k1_scratch* scratch, size_t objects) {\n-    size_t i = 0;\n-    size_t allocated = 0;\n-    for (i = 0; i < scratch->frame; i++) {\n-        allocated += scratch->frame_size[i];\n-    }\n-    if (scratch->max_size - allocated <= objects * ALIGNMENT) {\n+static size_t secp256k1_scratch_checkpoint(const secp256k1_callback* error_callback, const secp256k1_scratch* scratch) {\n+    if (memcmp(scratch->magic, \"scratch\", 8) != 0) {\n+        secp256k1_callback_call(error_callback, \"invalid scratch space\");\n         return 0;\n     }\n-    return scratch->max_size - allocated - objects * ALIGNMENT;\n+    return scratch->alloc_size;\n }\n \n-static int secp256k1_scratch_allocate_frame(secp256k1_scratch* scratch, size_t n, size_t objects) {\n-    VERIFY_CHECK(scratch->frame < SECP256K1_SCRATCH_MAX_FRAMES);\n-\n-    if (n <= secp256k1_scratch_max_allocation(scratch, objects)) {\n-        n += objects * ALIGNMENT;\n-        scratch->data[scratch->frame] = checked_malloc(scratch->error_callback, n);\n-        if (scratch->data[scratch->frame] == NULL) {\n-            return 0;\n-        }\n-        scratch->frame_size[scratch->frame] = n;\n-        scratch->offset[scratch->frame] = 0;\n-        scratch->frame++;\n-        return 1;\n-    } else {\n-        return 0;\n+static void secp256k1_scratch_apply_checkpoint(const secp256k1_callback* error_callback, secp256k1_scratch* scratch, size_t checkpoint) {\n+    if (memcmp(scratch->magic, \"scratch\", 8) != 0) {\n+        secp256k1_callback_call(error_callback, \"invalid scratch space\");\n+        return;\n+    }\n+    if (checkpoint > scratch->alloc_size) {\n+        secp256k1_callback_call(error_callback, \"invalid checkpoint\");\n+        return;\n     }\n+    scratch->alloc_size = checkpoint;\n }\n \n-static void secp256k1_scratch_deallocate_frame(secp256k1_scratch* scratch) {\n-    VERIFY_CHECK(scratch->frame > 0);\n-    scratch->frame -= 1;\n-    free(scratch->data[scratch->frame]);\n+static size_t secp256k1_scratch_max_allocation(const secp256k1_callback* error_callback, const secp256k1_scratch* scratch, size_t objects) {\n+    if (memcmp(scratch->magic, \"scratch\", 8) != 0) {\n+        secp256k1_callback_call(error_callback, \"invalid scratch space\");\n+        return 0;\n+    }\n+    if (scratch->max_size - scratch->alloc_size <= objects * (ALIGNMENT - 1)) {\n+        return 0;\n+    }\n+    return scratch->max_size - scratch->alloc_size - objects * (ALIGNMENT - 1);\n }\n \n-static void *secp256k1_scratch_alloc(secp256k1_scratch* scratch, size_t size) {\n+static void *secp256k1_scratch_alloc(const secp256k1_callback* error_callback, secp256k1_scratch* scratch, size_t size) {\n     void *ret;\n-    size_t frame = scratch->frame - 1;\n-    size = ((size + ALIGNMENT - 1) / ALIGNMENT) * ALIGNMENT;\n+    size = ROUND_TO_ALIGN(size);\n+\n+    if (memcmp(scratch->magic, \"scratch\", 8) != 0) {\n+        secp256k1_callback_call(error_callback, \"invalid scratch space\");\n+        return NULL;\n+    }\n \n-    if (scratch->frame == 0 || size + scratch->offset[frame] > scratch->frame_size[frame]) {\n+    if (size > scratch->max_size - scratch->alloc_size) {\n         return NULL;\n     }\n-    ret = (void *) ((unsigned char *) scratch->data[frame] + scratch->offset[frame]);\n+    ret = (void *) ((char *) scratch->data + scratch->alloc_size);\n     memset(ret, 0, size);\n-    scratch->offset[frame] += size;\n+    scratch->alloc_size += size;\n \n     return ret;\n }"
      },
      {
        "sha": "b03a6e634596192375e27e54e5c2a2e114633482",
        "filename": "src/secp256k1/src/secp256k1.c",
        "status": "modified",
        "additions": 223,
        "deletions": 89,
        "changes": 312,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/secp256k1.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/secp256k1.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/secp256k1.c?ref=8903a1a0a78a705402123d2a5c465217cb9d791c",
        "patch": "@@ -5,6 +5,7 @@\n  **********************************************************************/\n \n #include \"include/secp256k1.h\"\n+#include \"include/secp256k1_preallocated.h\"\n \n #include \"util.h\"\n #include \"num_impl.h\"\n@@ -19,108 +20,193 @@\n #include \"hash_impl.h\"\n #include \"scratch_impl.h\"\n \n+#if defined(VALGRIND)\n+# include <valgrind/memcheck.h>\n+#endif\n+\n #define ARG_CHECK(cond) do { \\\n     if (EXPECT(!(cond), 0)) { \\\n         secp256k1_callback_call(&ctx->illegal_callback, #cond); \\\n         return 0; \\\n     } \\\n } while(0)\n \n-static void default_illegal_callback_fn(const char* str, void* data) {\n+#define ARG_CHECK_NO_RETURN(cond) do { \\\n+    if (EXPECT(!(cond), 0)) { \\\n+        secp256k1_callback_call(&ctx->illegal_callback, #cond); \\\n+    } \\\n+} while(0)\n+\n+#ifndef USE_EXTERNAL_DEFAULT_CALLBACKS\n+#include <stdlib.h>\n+#include <stdio.h>\n+static void secp256k1_default_illegal_callback_fn(const char* str, void* data) {\n     (void)data;\n     fprintf(stderr, \"[libsecp256k1] illegal argument: %s\\n\", str);\n     abort();\n }\n-\n-static const secp256k1_callback default_illegal_callback = {\n-    default_illegal_callback_fn,\n-    NULL\n-};\n-\n-static void default_error_callback_fn(const char* str, void* data) {\n+static void secp256k1_default_error_callback_fn(const char* str, void* data) {\n     (void)data;\n     fprintf(stderr, \"[libsecp256k1] internal consistency check failed: %s\\n\", str);\n     abort();\n }\n+#else\n+void secp256k1_default_illegal_callback_fn(const char* str, void* data);\n+void secp256k1_default_error_callback_fn(const char* str, void* data);\n+#endif\n \n-static const secp256k1_callback default_error_callback = {\n-    default_error_callback_fn,\n+static const secp256k1_callback default_illegal_callback = {\n+    secp256k1_default_illegal_callback_fn,\n     NULL\n };\n \n+static const secp256k1_callback default_error_callback = {\n+    secp256k1_default_error_callback_fn,\n+    NULL\n+};\n \n struct secp256k1_context_struct {\n     secp256k1_ecmult_context ecmult_ctx;\n     secp256k1_ecmult_gen_context ecmult_gen_ctx;\n     secp256k1_callback illegal_callback;\n     secp256k1_callback error_callback;\n+    int declassify;\n };\n \n static const secp256k1_context secp256k1_context_no_precomp_ = {\n     { 0 },\n     { 0 },\n-    { default_illegal_callback_fn, 0 },\n-    { default_error_callback_fn, 0 }\n+    { secp256k1_default_illegal_callback_fn, 0 },\n+    { secp256k1_default_error_callback_fn, 0 },\n+    0\n };\n const secp256k1_context *secp256k1_context_no_precomp = &secp256k1_context_no_precomp_;\n \n-secp256k1_context* secp256k1_context_create(unsigned int flags) {\n-    secp256k1_context* ret = (secp256k1_context*)checked_malloc(&default_error_callback, sizeof(secp256k1_context));\n+size_t secp256k1_context_preallocated_size(unsigned int flags) {\n+    size_t ret = ROUND_TO_ALIGN(sizeof(secp256k1_context));\n+\n+    if (EXPECT((flags & SECP256K1_FLAGS_TYPE_MASK) != SECP256K1_FLAGS_TYPE_CONTEXT, 0)) {\n+            secp256k1_callback_call(&default_illegal_callback,\n+                                    \"Invalid flags\");\n+            return 0;\n+    }\n+\n+    if (flags & SECP256K1_FLAGS_BIT_CONTEXT_SIGN) {\n+        ret += SECP256K1_ECMULT_GEN_CONTEXT_PREALLOCATED_SIZE;\n+    }\n+    if (flags & SECP256K1_FLAGS_BIT_CONTEXT_VERIFY) {\n+        ret += SECP256K1_ECMULT_CONTEXT_PREALLOCATED_SIZE;\n+    }\n+    return ret;\n+}\n+\n+size_t secp256k1_context_preallocated_clone_size(const secp256k1_context* ctx) {\n+    size_t ret = ROUND_TO_ALIGN(sizeof(secp256k1_context));\n+    VERIFY_CHECK(ctx != NULL);\n+    if (secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx)) {\n+        ret += SECP256K1_ECMULT_GEN_CONTEXT_PREALLOCATED_SIZE;\n+    }\n+    if (secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx)) {\n+        ret += SECP256K1_ECMULT_CONTEXT_PREALLOCATED_SIZE;\n+    }\n+    return ret;\n+}\n+\n+secp256k1_context* secp256k1_context_preallocated_create(void* prealloc, unsigned int flags) {\n+    void* const base = prealloc;\n+    size_t prealloc_size;\n+    secp256k1_context* ret;\n+\n+    VERIFY_CHECK(prealloc != NULL);\n+    prealloc_size = secp256k1_context_preallocated_size(flags);\n+    ret = (secp256k1_context*)manual_alloc(&prealloc, sizeof(secp256k1_context), base, prealloc_size);\n     ret->illegal_callback = default_illegal_callback;\n     ret->error_callback = default_error_callback;\n \n     if (EXPECT((flags & SECP256K1_FLAGS_TYPE_MASK) != SECP256K1_FLAGS_TYPE_CONTEXT, 0)) {\n             secp256k1_callback_call(&ret->illegal_callback,\n                                     \"Invalid flags\");\n-            free(ret);\n             return NULL;\n     }\n \n     secp256k1_ecmult_context_init(&ret->ecmult_ctx);\n     secp256k1_ecmult_gen_context_init(&ret->ecmult_gen_ctx);\n \n     if (flags & SECP256K1_FLAGS_BIT_CONTEXT_SIGN) {\n-        secp256k1_ecmult_gen_context_build(&ret->ecmult_gen_ctx, &ret->error_callback);\n+        secp256k1_ecmult_gen_context_build(&ret->ecmult_gen_ctx, &prealloc);\n     }\n     if (flags & SECP256K1_FLAGS_BIT_CONTEXT_VERIFY) {\n-        secp256k1_ecmult_context_build(&ret->ecmult_ctx, &ret->error_callback);\n+        secp256k1_ecmult_context_build(&ret->ecmult_ctx, &prealloc);\n+    }\n+    ret->declassify = !!(flags & SECP256K1_FLAGS_BIT_CONTEXT_DECLASSIFY);\n+\n+    return (secp256k1_context*) ret;\n+}\n+\n+secp256k1_context* secp256k1_context_create(unsigned int flags) {\n+    size_t const prealloc_size = secp256k1_context_preallocated_size(flags);\n+    secp256k1_context* ctx = (secp256k1_context*)checked_malloc(&default_error_callback, prealloc_size);\n+    if (EXPECT(secp256k1_context_preallocated_create(ctx, flags) == NULL, 0)) {\n+        free(ctx);\n+        return NULL;\n     }\n \n+    return ctx;\n+}\n+\n+secp256k1_context* secp256k1_context_preallocated_clone(const secp256k1_context* ctx, void* prealloc) {\n+    size_t prealloc_size;\n+    secp256k1_context* ret;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(prealloc != NULL);\n+\n+    prealloc_size = secp256k1_context_preallocated_clone_size(ctx);\n+    ret = (secp256k1_context*)prealloc;\n+    memcpy(ret, ctx, prealloc_size);\n+    secp256k1_ecmult_gen_context_finalize_memcpy(&ret->ecmult_gen_ctx, &ctx->ecmult_gen_ctx);\n+    secp256k1_ecmult_context_finalize_memcpy(&ret->ecmult_ctx, &ctx->ecmult_ctx);\n     return ret;\n }\n \n secp256k1_context* secp256k1_context_clone(const secp256k1_context* ctx) {\n-    secp256k1_context* ret = (secp256k1_context*)checked_malloc(&ctx->error_callback, sizeof(secp256k1_context));\n-    ret->illegal_callback = ctx->illegal_callback;\n-    ret->error_callback = ctx->error_callback;\n-    secp256k1_ecmult_context_clone(&ret->ecmult_ctx, &ctx->ecmult_ctx, &ctx->error_callback);\n-    secp256k1_ecmult_gen_context_clone(&ret->ecmult_gen_ctx, &ctx->ecmult_gen_ctx, &ctx->error_callback);\n+    secp256k1_context* ret;\n+    size_t prealloc_size;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    prealloc_size = secp256k1_context_preallocated_clone_size(ctx);\n+    ret = (secp256k1_context*)checked_malloc(&ctx->error_callback, prealloc_size);\n+    ret = secp256k1_context_preallocated_clone(ctx, ret);\n     return ret;\n }\n \n-void secp256k1_context_destroy(secp256k1_context* ctx) {\n-    CHECK(ctx != secp256k1_context_no_precomp);\n+void secp256k1_context_preallocated_destroy(secp256k1_context* ctx) {\n+    ARG_CHECK_NO_RETURN(ctx != secp256k1_context_no_precomp);\n     if (ctx != NULL) {\n         secp256k1_ecmult_context_clear(&ctx->ecmult_ctx);\n         secp256k1_ecmult_gen_context_clear(&ctx->ecmult_gen_ctx);\n+    }\n+}\n \n+void secp256k1_context_destroy(secp256k1_context* ctx) {\n+    if (ctx != NULL) {\n+        secp256k1_context_preallocated_destroy(ctx);\n         free(ctx);\n     }\n }\n \n void secp256k1_context_set_illegal_callback(secp256k1_context* ctx, void (*fun)(const char* message, void* data), const void* data) {\n-    CHECK(ctx != secp256k1_context_no_precomp);\n+    ARG_CHECK_NO_RETURN(ctx != secp256k1_context_no_precomp);\n     if (fun == NULL) {\n-        fun = default_illegal_callback_fn;\n+        fun = secp256k1_default_illegal_callback_fn;\n     }\n     ctx->illegal_callback.fn = fun;\n     ctx->illegal_callback.data = data;\n }\n \n void secp256k1_context_set_error_callback(secp256k1_context* ctx, void (*fun)(const char* message, void* data), const void* data) {\n-    CHECK(ctx != secp256k1_context_no_precomp);\n+    ARG_CHECK_NO_RETURN(ctx != secp256k1_context_no_precomp);\n     if (fun == NULL) {\n-        fun = default_error_callback_fn;\n+        fun = secp256k1_default_error_callback_fn;\n     }\n     ctx->error_callback.fn = fun;\n     ctx->error_callback.data = data;\n@@ -131,8 +217,23 @@ secp256k1_scratch_space* secp256k1_scratch_space_create(const secp256k1_context*\n     return secp256k1_scratch_create(&ctx->error_callback, max_size);\n }\n \n-void secp256k1_scratch_space_destroy(secp256k1_scratch_space* scratch) {\n-    secp256k1_scratch_destroy(scratch);\n+void secp256k1_scratch_space_destroy(const secp256k1_context *ctx, secp256k1_scratch_space* scratch) {\n+    VERIFY_CHECK(ctx != NULL);\n+    secp256k1_scratch_destroy(&ctx->error_callback, scratch);\n+}\n+\n+/* Mark memory as no-longer-secret for the purpose of analysing constant-time behaviour\n+ *  of the software. This is setup for use with valgrind but could be substituted with\n+ *  the appropriate instrumentation for other analysis tools.\n+ */\n+static SECP256K1_INLINE void secp256k1_declassify(const secp256k1_context* ctx, void *p, size_t len) {\n+#if defined(VALGRIND)\n+    if (EXPECT(ctx->declassify,0)) VALGRIND_MAKE_MEM_DEFINED(p, len);\n+#else\n+    (void)ctx;\n+    (void)p;\n+    (void)len;\n+#endif\n }\n \n static int secp256k1_pubkey_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_pubkey* pubkey) {\n@@ -366,61 +467,83 @@ static int nonce_function_rfc6979(unsigned char *nonce32, const unsigned char *m\n const secp256k1_nonce_function secp256k1_nonce_function_rfc6979 = nonce_function_rfc6979;\n const secp256k1_nonce_function secp256k1_nonce_function_default = nonce_function_rfc6979;\n \n-int secp256k1_ecdsa_sign(const secp256k1_context* ctx, secp256k1_ecdsa_signature *signature, const unsigned char *msg32, const unsigned char *seckey, secp256k1_nonce_function noncefp, const void* noncedata) {\n-    secp256k1_scalar r, s;\n+static int secp256k1_ecdsa_sign_inner(const secp256k1_context* ctx, secp256k1_scalar* r, secp256k1_scalar* s, int* recid, const unsigned char *msg32, const unsigned char *seckey, secp256k1_nonce_function noncefp, const void* noncedata) {\n     secp256k1_scalar sec, non, msg;\n     int ret = 0;\n-    int overflow = 0;\n-    VERIFY_CHECK(ctx != NULL);\n-    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n-    ARG_CHECK(msg32 != NULL);\n-    ARG_CHECK(signature != NULL);\n-    ARG_CHECK(seckey != NULL);\n+    int is_sec_valid;\n+    unsigned char nonce32[32];\n+    unsigned int count = 0;\n+    /* Default initialization here is important so we won't pass uninit values to the cmov in the end */\n+    *r = secp256k1_scalar_zero;\n+    *s = secp256k1_scalar_zero;\n+    if (recid) {\n+        *recid = 0;\n+    }\n     if (noncefp == NULL) {\n         noncefp = secp256k1_nonce_function_default;\n     }\n \n-    secp256k1_scalar_set_b32(&sec, seckey, &overflow);\n     /* Fail if the secret key is invalid. */\n-    if (!overflow && !secp256k1_scalar_is_zero(&sec)) {\n-        unsigned char nonce32[32];\n-        unsigned int count = 0;\n-        secp256k1_scalar_set_b32(&msg, msg32, NULL);\n-        while (1) {\n-            ret = noncefp(nonce32, msg32, seckey, NULL, (void*)noncedata, count);\n-            if (!ret) {\n+    is_sec_valid = secp256k1_scalar_set_b32_seckey(&sec, seckey);\n+    secp256k1_scalar_cmov(&sec, &secp256k1_scalar_one, !is_sec_valid);\n+    secp256k1_scalar_set_b32(&msg, msg32, NULL);\n+    while (1) {\n+        int is_nonce_valid;\n+        ret = !!noncefp(nonce32, msg32, seckey, NULL, (void*)noncedata, count);\n+        if (!ret) {\n+            break;\n+        }\n+        is_nonce_valid = secp256k1_scalar_set_b32_seckey(&non, nonce32);\n+        /* The nonce is still secret here, but it being invalid is is less likely than 1:2^255. */\n+        secp256k1_declassify(ctx, &is_nonce_valid, sizeof(is_nonce_valid));\n+        if (is_nonce_valid) {\n+            ret = secp256k1_ecdsa_sig_sign(&ctx->ecmult_gen_ctx, r, s, &sec, &msg, &non, recid);\n+            /* The final signature is no longer a secret, nor is the fact that we were successful or not. */\n+            secp256k1_declassify(ctx, &ret, sizeof(ret));\n+            if (ret) {\n                 break;\n             }\n-            secp256k1_scalar_set_b32(&non, nonce32, &overflow);\n-            if (!overflow && !secp256k1_scalar_is_zero(&non)) {\n-                if (secp256k1_ecdsa_sig_sign(&ctx->ecmult_gen_ctx, &r, &s, &sec, &msg, &non, NULL)) {\n-                    break;\n-                }\n-            }\n-            count++;\n         }\n-        memset(nonce32, 0, 32);\n-        secp256k1_scalar_clear(&msg);\n-        secp256k1_scalar_clear(&non);\n-        secp256k1_scalar_clear(&sec);\n+        count++;\n     }\n-    if (ret) {\n-        secp256k1_ecdsa_signature_save(signature, &r, &s);\n-    } else {\n-        memset(signature, 0, sizeof(*signature));\n+    /* We don't want to declassify is_sec_valid and therefore the range of\n+     * seckey. As a result is_sec_valid is included in ret only after ret was\n+     * used as a branching variable. */\n+    ret &= is_sec_valid;\n+    memset(nonce32, 0, 32);\n+    secp256k1_scalar_clear(&msg);\n+    secp256k1_scalar_clear(&non);\n+    secp256k1_scalar_clear(&sec);\n+    secp256k1_scalar_cmov(r, &secp256k1_scalar_zero, !ret);\n+    secp256k1_scalar_cmov(s, &secp256k1_scalar_zero, !ret);\n+    if (recid) {\n+        const int zero = 0;\n+        secp256k1_int_cmov(recid, &zero, !ret);\n     }\n     return ret;\n }\n \n+int secp256k1_ecdsa_sign(const secp256k1_context* ctx, secp256k1_ecdsa_signature *signature, const unsigned char *msg32, const unsigned char *seckey, secp256k1_nonce_function noncefp, const void* noncedata) {\n+    secp256k1_scalar r, s;\n+    int ret;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n+    ARG_CHECK(msg32 != NULL);\n+    ARG_CHECK(signature != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    ret = secp256k1_ecdsa_sign_inner(ctx, &r, &s, NULL, msg32, seckey, noncefp, noncedata);\n+    secp256k1_ecdsa_signature_save(signature, &r, &s);\n+    return ret;\n+}\n+\n int secp256k1_ec_seckey_verify(const secp256k1_context* ctx, const unsigned char *seckey) {\n     secp256k1_scalar sec;\n     int ret;\n-    int overflow;\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(seckey != NULL);\n \n-    secp256k1_scalar_set_b32(&sec, seckey, &overflow);\n-    ret = !overflow && !secp256k1_scalar_is_zero(&sec);\n+    ret = secp256k1_scalar_set_b32_seckey(&sec, seckey);\n     secp256k1_scalar_clear(&sec);\n     return ret;\n }\n@@ -429,35 +552,42 @@ int secp256k1_ec_pubkey_create(const secp256k1_context* ctx, secp256k1_pubkey *p\n     secp256k1_gej pj;\n     secp256k1_ge p;\n     secp256k1_scalar sec;\n-    int overflow;\n     int ret = 0;\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(pubkey != NULL);\n     memset(pubkey, 0, sizeof(*pubkey));\n     ARG_CHECK(secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx));\n     ARG_CHECK(seckey != NULL);\n \n-    secp256k1_scalar_set_b32(&sec, seckey, &overflow);\n-    ret = (!overflow) & (!secp256k1_scalar_is_zero(&sec));\n-    if (ret) {\n-        secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pj, &sec);\n-        secp256k1_ge_set_gej(&p, &pj);\n-        secp256k1_pubkey_save(pubkey, &p);\n-    }\n+    ret = secp256k1_scalar_set_b32_seckey(&sec, seckey);\n+    secp256k1_scalar_cmov(&sec, &secp256k1_scalar_one, !ret);\n+\n+    secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pj, &sec);\n+    secp256k1_ge_set_gej(&p, &pj);\n+    secp256k1_pubkey_save(pubkey, &p);\n+    memczero(pubkey, sizeof(*pubkey), !ret);\n+\n     secp256k1_scalar_clear(&sec);\n     return ret;\n }\n \n-int secp256k1_ec_privkey_negate(const secp256k1_context* ctx, unsigned char *seckey) {\n+int secp256k1_ec_seckey_negate(const secp256k1_context* ctx, unsigned char *seckey) {\n     secp256k1_scalar sec;\n+    int ret = 0;\n     VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(seckey != NULL);\n \n-    secp256k1_scalar_set_b32(&sec, seckey, NULL);\n+    ret = secp256k1_scalar_set_b32_seckey(&sec, seckey);\n+    secp256k1_scalar_cmov(&sec, &secp256k1_scalar_zero, !ret);\n     secp256k1_scalar_negate(&sec, &sec);\n     secp256k1_scalar_get_b32(seckey, &sec);\n \n-    return 1;\n+    secp256k1_scalar_clear(&sec);\n+    return ret;\n+}\n+\n+int secp256k1_ec_privkey_negate(const secp256k1_context* ctx, unsigned char *seckey) {\n+    return secp256k1_ec_seckey_negate(ctx, seckey);\n }\n \n int secp256k1_ec_pubkey_negate(const secp256k1_context* ctx, secp256k1_pubkey *pubkey) {\n@@ -475,7 +605,7 @@ int secp256k1_ec_pubkey_negate(const secp256k1_context* ctx, secp256k1_pubkey *p\n     return ret;\n }\n \n-int secp256k1_ec_privkey_tweak_add(const secp256k1_context* ctx, unsigned char *seckey, const unsigned char *tweak) {\n+int secp256k1_ec_seckey_tweak_add(const secp256k1_context* ctx, unsigned char *seckey, const unsigned char *tweak) {\n     secp256k1_scalar term;\n     secp256k1_scalar sec;\n     int ret = 0;\n@@ -485,19 +615,21 @@ int secp256k1_ec_privkey_tweak_add(const secp256k1_context* ctx, unsigned char *\n     ARG_CHECK(tweak != NULL);\n \n     secp256k1_scalar_set_b32(&term, tweak, &overflow);\n-    secp256k1_scalar_set_b32(&sec, seckey, NULL);\n+    ret = secp256k1_scalar_set_b32_seckey(&sec, seckey);\n \n-    ret = !overflow && secp256k1_eckey_privkey_tweak_add(&sec, &term);\n-    memset(seckey, 0, 32);\n-    if (ret) {\n-        secp256k1_scalar_get_b32(seckey, &sec);\n-    }\n+    ret &= (!overflow) & secp256k1_eckey_privkey_tweak_add(&sec, &term);\n+    secp256k1_scalar_cmov(&sec, &secp256k1_scalar_zero, !ret);\n+    secp256k1_scalar_get_b32(seckey, &sec);\n \n     secp256k1_scalar_clear(&sec);\n     secp256k1_scalar_clear(&term);\n     return ret;\n }\n \n+int secp256k1_ec_privkey_tweak_add(const secp256k1_context* ctx, unsigned char *seckey, const unsigned char *tweak) {\n+    return secp256k1_ec_seckey_tweak_add(ctx, seckey, tweak);\n+}\n+\n int secp256k1_ec_pubkey_tweak_add(const secp256k1_context* ctx, secp256k1_pubkey *pubkey, const unsigned char *tweak) {\n     secp256k1_ge p;\n     secp256k1_scalar term;\n@@ -522,7 +654,7 @@ int secp256k1_ec_pubkey_tweak_add(const secp256k1_context* ctx, secp256k1_pubkey\n     return ret;\n }\n \n-int secp256k1_ec_privkey_tweak_mul(const secp256k1_context* ctx, unsigned char *seckey, const unsigned char *tweak) {\n+int secp256k1_ec_seckey_tweak_mul(const secp256k1_context* ctx, unsigned char *seckey, const unsigned char *tweak) {\n     secp256k1_scalar factor;\n     secp256k1_scalar sec;\n     int ret = 0;\n@@ -532,18 +664,20 @@ int secp256k1_ec_privkey_tweak_mul(const secp256k1_context* ctx, unsigned char *\n     ARG_CHECK(tweak != NULL);\n \n     secp256k1_scalar_set_b32(&factor, tweak, &overflow);\n-    secp256k1_scalar_set_b32(&sec, seckey, NULL);\n-    ret = !overflow && secp256k1_eckey_privkey_tweak_mul(&sec, &factor);\n-    memset(seckey, 0, 32);\n-    if (ret) {\n-        secp256k1_scalar_get_b32(seckey, &sec);\n-    }\n+    ret = secp256k1_scalar_set_b32_seckey(&sec, seckey);\n+    ret &= (!overflow) & secp256k1_eckey_privkey_tweak_mul(&sec, &factor);\n+    secp256k1_scalar_cmov(&sec, &secp256k1_scalar_zero, !ret);\n+    secp256k1_scalar_get_b32(seckey, &sec);\n \n     secp256k1_scalar_clear(&sec);\n     secp256k1_scalar_clear(&factor);\n     return ret;\n }\n \n+int secp256k1_ec_privkey_tweak_mul(const secp256k1_context* ctx, unsigned char *seckey, const unsigned char *tweak) {\n+    return secp256k1_ec_seckey_tweak_mul(ctx, seckey, tweak);\n+}\n+\n int secp256k1_ec_pubkey_tweak_mul(const secp256k1_context* ctx, secp256k1_pubkey *pubkey, const unsigned char *tweak) {\n     secp256k1_ge p;\n     secp256k1_scalar factor;"
      },
      {
        "sha": "374ed7dc12732dfb4b673cb665b49a596dcf2ee3",
        "filename": "src/secp256k1/src/tests.c",
        "status": "modified",
        "additions": 564,
        "deletions": 115,
        "changes": 679,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/tests.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/tests.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/tests.c?ref=8903a1a0a78a705402123d2a5c465217cb9d791c",
        "patch": "@@ -16,6 +16,7 @@\n \n #include \"secp256k1.c\"\n #include \"include/secp256k1.h\"\n+#include \"include/secp256k1_preallocated.h\"\n #include \"testrand_impl.h\"\n \n #ifdef ENABLE_OPENSSL_TESTS\n@@ -31,17 +32,6 @@ void ECDSA_SIG_get0(const ECDSA_SIG *sig, const BIGNUM **pr, const BIGNUM **ps)\n #include \"contrib/lax_der_parsing.c\"\n #include \"contrib/lax_der_privatekey_parsing.c\"\n \n-#if !defined(VG_CHECK)\n-# if defined(VALGRIND)\n-#  include <valgrind/memcheck.h>\n-#  define VG_UNDEF(x,y) VALGRIND_MAKE_MEM_UNDEFINED((x),(y))\n-#  define VG_CHECK(x,y) VALGRIND_CHECK_MEM_IS_DEFINED((x),(y))\n-# else\n-#  define VG_UNDEF(x,y)\n-#  define VG_CHECK(x,y)\n-# endif\n-#endif\n-\n static int count = 64;\n static secp256k1_context *ctx = NULL;\n \n@@ -82,7 +72,9 @@ void random_field_element_magnitude(secp256k1_fe *fe) {\n     secp256k1_fe_negate(&zero, &zero, 0);\n     secp256k1_fe_mul_int(&zero, n - 1);\n     secp256k1_fe_add(fe, &zero);\n-    VERIFY_CHECK(fe->magnitude == n);\n+#ifdef VERIFY\n+    CHECK(fe->magnitude == n);\n+#endif\n }\n \n void random_group_element_test(secp256k1_ge *ge) {\n@@ -137,23 +129,53 @@ void random_scalar_order(secp256k1_scalar *num) {\n     } while(1);\n }\n \n-void run_context_tests(void) {\n+void random_scalar_order_b32(unsigned char *b32) {\n+    secp256k1_scalar num;\n+    random_scalar_order(&num);\n+    secp256k1_scalar_get_b32(b32, &num);\n+}\n+\n+void run_context_tests(int use_prealloc) {\n     secp256k1_pubkey pubkey;\n     secp256k1_pubkey zero_pubkey;\n     secp256k1_ecdsa_signature sig;\n     unsigned char ctmp[32];\n     int32_t ecount;\n     int32_t ecount2;\n-    secp256k1_context *none = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n-    secp256k1_context *sign = secp256k1_context_create(SECP256K1_CONTEXT_SIGN);\n-    secp256k1_context *vrfy = secp256k1_context_create(SECP256K1_CONTEXT_VERIFY);\n-    secp256k1_context *both = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n+    secp256k1_context *none;\n+    secp256k1_context *sign;\n+    secp256k1_context *vrfy;\n+    secp256k1_context *both;\n+    void *none_prealloc = NULL;\n+    void *sign_prealloc = NULL;\n+    void *vrfy_prealloc = NULL;\n+    void *both_prealloc = NULL;\n \n     secp256k1_gej pubj;\n     secp256k1_ge pub;\n     secp256k1_scalar msg, key, nonce;\n     secp256k1_scalar sigr, sigs;\n \n+    if (use_prealloc) {\n+        none_prealloc = malloc(secp256k1_context_preallocated_size(SECP256K1_CONTEXT_NONE));\n+        sign_prealloc = malloc(secp256k1_context_preallocated_size(SECP256K1_CONTEXT_SIGN));\n+        vrfy_prealloc = malloc(secp256k1_context_preallocated_size(SECP256K1_CONTEXT_VERIFY));\n+        both_prealloc = malloc(secp256k1_context_preallocated_size(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY));\n+        CHECK(none_prealloc != NULL);\n+        CHECK(sign_prealloc != NULL);\n+        CHECK(vrfy_prealloc != NULL);\n+        CHECK(both_prealloc != NULL);\n+        none = secp256k1_context_preallocated_create(none_prealloc, SECP256K1_CONTEXT_NONE);\n+        sign = secp256k1_context_preallocated_create(sign_prealloc, SECP256K1_CONTEXT_SIGN);\n+        vrfy = secp256k1_context_preallocated_create(vrfy_prealloc, SECP256K1_CONTEXT_VERIFY);\n+        both = secp256k1_context_preallocated_create(both_prealloc, SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n+    } else {\n+        none = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+        sign = secp256k1_context_create(SECP256K1_CONTEXT_SIGN);\n+        vrfy = secp256k1_context_create(SECP256K1_CONTEXT_VERIFY);\n+        both = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n+    }\n+\n     memset(&zero_pubkey, 0, sizeof(zero_pubkey));\n \n     ecount = 0;\n@@ -163,14 +185,57 @@ void run_context_tests(void) {\n     secp256k1_context_set_error_callback(sign, counting_illegal_callback_fn, NULL);\n     CHECK(vrfy->error_callback.fn != sign->error_callback.fn);\n \n+    /* check if sizes for cloning are consistent */\n+    CHECK(secp256k1_context_preallocated_clone_size(none) == secp256k1_context_preallocated_size(SECP256K1_CONTEXT_NONE));\n+    CHECK(secp256k1_context_preallocated_clone_size(sign) == secp256k1_context_preallocated_size(SECP256K1_CONTEXT_SIGN));\n+    CHECK(secp256k1_context_preallocated_clone_size(vrfy) == secp256k1_context_preallocated_size(SECP256K1_CONTEXT_VERIFY));\n+    CHECK(secp256k1_context_preallocated_clone_size(both) == secp256k1_context_preallocated_size(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY));\n+\n     /*** clone and destroy all of them to make sure cloning was complete ***/\n     {\n         secp256k1_context *ctx_tmp;\n \n-        ctx_tmp = none; none = secp256k1_context_clone(none); secp256k1_context_destroy(ctx_tmp);\n-        ctx_tmp = sign; sign = secp256k1_context_clone(sign); secp256k1_context_destroy(ctx_tmp);\n-        ctx_tmp = vrfy; vrfy = secp256k1_context_clone(vrfy); secp256k1_context_destroy(ctx_tmp);\n-        ctx_tmp = both; both = secp256k1_context_clone(both); secp256k1_context_destroy(ctx_tmp);\n+        if (use_prealloc) {\n+            /* clone into a non-preallocated context and then again into a new preallocated one. */\n+            ctx_tmp = none; none = secp256k1_context_clone(none); secp256k1_context_preallocated_destroy(ctx_tmp);\n+            free(none_prealloc); none_prealloc = malloc(secp256k1_context_preallocated_size(SECP256K1_CONTEXT_NONE)); CHECK(none_prealloc != NULL);\n+            ctx_tmp = none; none = secp256k1_context_preallocated_clone(none, none_prealloc); secp256k1_context_destroy(ctx_tmp);\n+\n+            ctx_tmp = sign; sign = secp256k1_context_clone(sign); secp256k1_context_preallocated_destroy(ctx_tmp);\n+            free(sign_prealloc); sign_prealloc = malloc(secp256k1_context_preallocated_size(SECP256K1_CONTEXT_SIGN)); CHECK(sign_prealloc != NULL);\n+            ctx_tmp = sign; sign = secp256k1_context_preallocated_clone(sign, sign_prealloc); secp256k1_context_destroy(ctx_tmp);\n+\n+            ctx_tmp = vrfy; vrfy = secp256k1_context_clone(vrfy); secp256k1_context_preallocated_destroy(ctx_tmp);\n+            free(vrfy_prealloc); vrfy_prealloc = malloc(secp256k1_context_preallocated_size(SECP256K1_CONTEXT_VERIFY)); CHECK(vrfy_prealloc != NULL);\n+            ctx_tmp = vrfy; vrfy = secp256k1_context_preallocated_clone(vrfy, vrfy_prealloc); secp256k1_context_destroy(ctx_tmp);\n+\n+            ctx_tmp = both; both = secp256k1_context_clone(both); secp256k1_context_preallocated_destroy(ctx_tmp);\n+            free(both_prealloc); both_prealloc = malloc(secp256k1_context_preallocated_size(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY)); CHECK(both_prealloc != NULL);\n+            ctx_tmp = both; both = secp256k1_context_preallocated_clone(both, both_prealloc); secp256k1_context_destroy(ctx_tmp);\n+        } else {\n+            /* clone into a preallocated context and then again into a new non-preallocated one. */\n+            void *prealloc_tmp;\n+\n+            prealloc_tmp = malloc(secp256k1_context_preallocated_size(SECP256K1_CONTEXT_NONE)); CHECK(prealloc_tmp != NULL);\n+            ctx_tmp = none; none = secp256k1_context_preallocated_clone(none, prealloc_tmp); secp256k1_context_destroy(ctx_tmp);\n+            ctx_tmp = none; none = secp256k1_context_clone(none); secp256k1_context_preallocated_destroy(ctx_tmp);\n+            free(prealloc_tmp);\n+\n+            prealloc_tmp = malloc(secp256k1_context_preallocated_size(SECP256K1_CONTEXT_SIGN)); CHECK(prealloc_tmp != NULL);\n+            ctx_tmp = sign; sign = secp256k1_context_preallocated_clone(sign, prealloc_tmp); secp256k1_context_destroy(ctx_tmp);\n+            ctx_tmp = sign; sign = secp256k1_context_clone(sign); secp256k1_context_preallocated_destroy(ctx_tmp);\n+            free(prealloc_tmp);\n+\n+            prealloc_tmp = malloc(secp256k1_context_preallocated_size(SECP256K1_CONTEXT_VERIFY)); CHECK(prealloc_tmp != NULL);\n+            ctx_tmp = vrfy; vrfy = secp256k1_context_preallocated_clone(vrfy, prealloc_tmp); secp256k1_context_destroy(ctx_tmp);\n+            ctx_tmp = vrfy; vrfy = secp256k1_context_clone(vrfy); secp256k1_context_preallocated_destroy(ctx_tmp);\n+            free(prealloc_tmp);\n+\n+            prealloc_tmp = malloc(secp256k1_context_preallocated_size(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY)); CHECK(prealloc_tmp != NULL);\n+            ctx_tmp = both; both = secp256k1_context_preallocated_clone(both, prealloc_tmp); secp256k1_context_destroy(ctx_tmp);\n+            ctx_tmp = both; both = secp256k1_context_clone(both); secp256k1_context_preallocated_destroy(ctx_tmp);\n+            free(prealloc_tmp);\n+        }\n     }\n \n     /* Verify that the error callback makes it across the clone. */\n@@ -229,10 +294,6 @@ void run_context_tests(void) {\n     secp256k1_context_set_illegal_callback(vrfy, NULL, NULL);\n     secp256k1_context_set_illegal_callback(sign, NULL, NULL);\n \n-    /* This shouldn't leak memory, due to already-set tests. */\n-    secp256k1_ecmult_gen_context_build(&sign->ecmult_gen_ctx, NULL);\n-    secp256k1_ecmult_context_build(&vrfy->ecmult_ctx, NULL);\n-\n     /* obtain a working nonce */\n     do {\n         random_scalar_order_test(&nonce);\n@@ -247,49 +308,95 @@ void run_context_tests(void) {\n     CHECK(secp256k1_ecdsa_sig_verify(&both->ecmult_ctx, &sigr, &sigs, &pub, &msg));\n \n     /* cleanup */\n-    secp256k1_context_destroy(none);\n-    secp256k1_context_destroy(sign);\n-    secp256k1_context_destroy(vrfy);\n-    secp256k1_context_destroy(both);\n+    if (use_prealloc) {\n+        secp256k1_context_preallocated_destroy(none);\n+        secp256k1_context_preallocated_destroy(sign);\n+        secp256k1_context_preallocated_destroy(vrfy);\n+        secp256k1_context_preallocated_destroy(both);\n+        free(none_prealloc);\n+        free(sign_prealloc);\n+        free(vrfy_prealloc);\n+        free(both_prealloc);\n+    } else {\n+        secp256k1_context_destroy(none);\n+        secp256k1_context_destroy(sign);\n+        secp256k1_context_destroy(vrfy);\n+        secp256k1_context_destroy(both);\n+    }\n     /* Defined as no-op. */\n     secp256k1_context_destroy(NULL);\n+    secp256k1_context_preallocated_destroy(NULL);\n+\n }\n \n void run_scratch_tests(void) {\n+    const size_t adj_alloc = ((500 + ALIGNMENT - 1) / ALIGNMENT) * ALIGNMENT;\n+\n     int32_t ecount = 0;\n+    size_t checkpoint;\n+    size_t checkpoint_2;\n     secp256k1_context *none = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n     secp256k1_scratch_space *scratch;\n+    secp256k1_scratch_space local_scratch;\n \n     /* Test public API */\n     secp256k1_context_set_illegal_callback(none, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_error_callback(none, counting_illegal_callback_fn, &ecount);\n \n     scratch = secp256k1_scratch_space_create(none, 1000);\n     CHECK(scratch != NULL);\n     CHECK(ecount == 0);\n \n     /* Test internal API */\n-    CHECK(secp256k1_scratch_max_allocation(scratch, 0) == 1000);\n-    CHECK(secp256k1_scratch_max_allocation(scratch, 1) < 1000);\n-\n-    /* Allocating 500 bytes with no frame fails */\n-    CHECK(secp256k1_scratch_alloc(scratch, 500) == NULL);\n-    CHECK(secp256k1_scratch_max_allocation(scratch, 0) == 1000);\n-\n-    /* ...but pushing a new stack frame does affect the max allocation */\n-    CHECK(secp256k1_scratch_allocate_frame(scratch, 500, 1 == 1));\n-    CHECK(secp256k1_scratch_max_allocation(scratch, 1) < 500); /* 500 - ALIGNMENT */\n-    CHECK(secp256k1_scratch_alloc(scratch, 500) != NULL);\n-    CHECK(secp256k1_scratch_alloc(scratch, 500) == NULL);\n-\n-    CHECK(secp256k1_scratch_allocate_frame(scratch, 500, 1) == 0);\n+    CHECK(secp256k1_scratch_max_allocation(&none->error_callback, scratch, 0) == 1000);\n+    CHECK(secp256k1_scratch_max_allocation(&none->error_callback, scratch, 1) == 1000 - (ALIGNMENT - 1));\n+    CHECK(scratch->alloc_size == 0);\n+    CHECK(scratch->alloc_size % ALIGNMENT == 0);\n+\n+    /* Allocating 500 bytes succeeds */\n+    checkpoint = secp256k1_scratch_checkpoint(&none->error_callback, scratch);\n+    CHECK(secp256k1_scratch_alloc(&none->error_callback, scratch, 500) != NULL);\n+    CHECK(secp256k1_scratch_max_allocation(&none->error_callback, scratch, 0) == 1000 - adj_alloc);\n+    CHECK(secp256k1_scratch_max_allocation(&none->error_callback, scratch, 1) == 1000 - adj_alloc - (ALIGNMENT - 1));\n+    CHECK(scratch->alloc_size != 0);\n+    CHECK(scratch->alloc_size % ALIGNMENT == 0);\n+\n+    /* Allocating another 500 bytes fails */\n+    CHECK(secp256k1_scratch_alloc(&none->error_callback, scratch, 500) == NULL);\n+    CHECK(secp256k1_scratch_max_allocation(&none->error_callback, scratch, 0) == 1000 - adj_alloc);\n+    CHECK(secp256k1_scratch_max_allocation(&none->error_callback, scratch, 1) == 1000 - adj_alloc - (ALIGNMENT - 1));\n+    CHECK(scratch->alloc_size != 0);\n+    CHECK(scratch->alloc_size % ALIGNMENT == 0);\n+\n+    /* ...but it succeeds once we apply the checkpoint to undo it */\n+    secp256k1_scratch_apply_checkpoint(&none->error_callback, scratch, checkpoint);\n+    CHECK(scratch->alloc_size == 0);\n+    CHECK(secp256k1_scratch_max_allocation(&none->error_callback, scratch, 0) == 1000);\n+    CHECK(secp256k1_scratch_alloc(&none->error_callback, scratch, 500) != NULL);\n+    CHECK(scratch->alloc_size != 0);\n+\n+    /* try to apply a bad checkpoint */\n+    checkpoint_2 = secp256k1_scratch_checkpoint(&none->error_callback, scratch);\n+    secp256k1_scratch_apply_checkpoint(&none->error_callback, scratch, checkpoint);\n+    CHECK(ecount == 0);\n+    secp256k1_scratch_apply_checkpoint(&none->error_callback, scratch, checkpoint_2); /* checkpoint_2 is after checkpoint */\n+    CHECK(ecount == 1);\n+    secp256k1_scratch_apply_checkpoint(&none->error_callback, scratch, (size_t) -1); /* this is just wildly invalid */\n+    CHECK(ecount == 2);\n \n-    /* ...and this effect is undone by popping the frame */\n-    secp256k1_scratch_deallocate_frame(scratch);\n-    CHECK(secp256k1_scratch_max_allocation(scratch, 0) == 1000);\n-    CHECK(secp256k1_scratch_alloc(scratch, 500) == NULL);\n+    /* try to use badly initialized scratch space */\n+    secp256k1_scratch_space_destroy(none, scratch);\n+    memset(&local_scratch, 0, sizeof(local_scratch));\n+    scratch = &local_scratch;\n+    CHECK(!secp256k1_scratch_max_allocation(&none->error_callback, scratch, 0));\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_scratch_alloc(&none->error_callback, scratch, 500) == NULL);\n+    CHECK(ecount == 4);\n+    secp256k1_scratch_space_destroy(none, scratch);\n+    CHECK(ecount == 5);\n \n     /* cleanup */\n-    secp256k1_scratch_space_destroy(scratch);\n+    secp256k1_scratch_space_destroy(none, NULL); /* no-op */\n     secp256k1_context_destroy(none);\n }\n \n@@ -965,11 +1072,31 @@ void scalar_test(void) {\n \n }\n \n+void run_scalar_set_b32_seckey_tests(void) {\n+    unsigned char b32[32];\n+    secp256k1_scalar s1;\n+    secp256k1_scalar s2;\n+\n+    /* Usually set_b32 and set_b32_seckey give the same result */\n+    random_scalar_order_b32(b32);\n+    secp256k1_scalar_set_b32(&s1, b32, NULL);\n+    CHECK(secp256k1_scalar_set_b32_seckey(&s2, b32) == 1);\n+    CHECK(secp256k1_scalar_eq(&s1, &s2) == 1);\n+\n+    memset(b32, 0, sizeof(b32));\n+    CHECK(secp256k1_scalar_set_b32_seckey(&s2, b32) == 0);\n+    memset(b32, 0xFF, sizeof(b32));\n+    CHECK(secp256k1_scalar_set_b32_seckey(&s2, b32) == 0);\n+}\n+\n void run_scalar_tests(void) {\n     int i;\n     for (i = 0; i < 128 * count; i++) {\n         scalar_test();\n     }\n+    for (i = 0; i < count; i++) {\n+        run_scalar_set_b32_seckey_tests();\n+    }\n \n     {\n         /* (-1)+1 should be zero. */\n@@ -985,16 +1112,43 @@ void run_scalar_tests(void) {\n \n #ifndef USE_NUM_NONE\n     {\n-        /* A scalar with value of the curve order should be 0. */\n+        /* Test secp256k1_scalar_set_b32 boundary conditions */\n         secp256k1_num order;\n-        secp256k1_scalar zero;\n+        secp256k1_scalar scalar;\n         unsigned char bin[32];\n+        unsigned char bin_tmp[32];\n         int overflow = 0;\n+        /* 2^256-1 - order */\n+        static const secp256k1_scalar all_ones_minus_order = SECP256K1_SCALAR_CONST(\n+            0x00000000UL, 0x00000000UL, 0x00000000UL, 0x00000001UL,\n+            0x45512319UL, 0x50B75FC4UL, 0x402DA173UL, 0x2FC9BEBEUL\n+        );\n+\n+        /* A scalar set to 0s should be 0. */\n+        memset(bin, 0, 32);\n+        secp256k1_scalar_set_b32(&scalar, bin, &overflow);\n+        CHECK(overflow == 0);\n+        CHECK(secp256k1_scalar_is_zero(&scalar));\n+\n+        /* A scalar with value of the curve order should be 0. */\n         secp256k1_scalar_order_get_num(&order);\n         secp256k1_num_get_bin(bin, 32, &order);\n-        secp256k1_scalar_set_b32(&zero, bin, &overflow);\n+        secp256k1_scalar_set_b32(&scalar, bin, &overflow);\n+        CHECK(overflow == 1);\n+        CHECK(secp256k1_scalar_is_zero(&scalar));\n+\n+        /* A scalar with value of the curve order minus one should not overflow. */\n+        bin[31] -= 1;\n+        secp256k1_scalar_set_b32(&scalar, bin, &overflow);\n+        CHECK(overflow == 0);\n+        secp256k1_scalar_get_b32(bin_tmp, &scalar);\n+        CHECK(memcmp(bin, bin_tmp, 32) == 0);\n+\n+        /* A scalar set to all 1s should overflow. */\n+        memset(bin, 0xFF, 32);\n+        secp256k1_scalar_set_b32(&scalar, bin, &overflow);\n         CHECK(overflow == 1);\n-        CHECK(secp256k1_scalar_is_zero(&zero));\n+        CHECK(secp256k1_scalar_eq(&scalar, &all_ones_minus_order));\n     }\n #endif\n \n@@ -1709,24 +1863,32 @@ void run_field_misc(void) {\n         /* Test fe conditional move; z is not normalized here. */\n         q = x;\n         secp256k1_fe_cmov(&x, &z, 0);\n-        VERIFY_CHECK(!x.normalized && x.magnitude == z.magnitude);\n+#ifdef VERIFY\n+        CHECK(x.normalized && x.magnitude == 1);\n+#endif\n         secp256k1_fe_cmov(&x, &x, 1);\n         CHECK(fe_memcmp(&x, &z) != 0);\n         CHECK(fe_memcmp(&x, &q) == 0);\n         secp256k1_fe_cmov(&q, &z, 1);\n-        VERIFY_CHECK(!q.normalized && q.magnitude == z.magnitude);\n+#ifdef VERIFY\n+        CHECK(!q.normalized && q.magnitude == z.magnitude);\n+#endif\n         CHECK(fe_memcmp(&q, &z) == 0);\n         secp256k1_fe_normalize_var(&x);\n         secp256k1_fe_normalize_var(&z);\n         CHECK(!secp256k1_fe_equal_var(&x, &z));\n         secp256k1_fe_normalize_var(&q);\n         secp256k1_fe_cmov(&q, &z, (i&1));\n-        VERIFY_CHECK(q.normalized && q.magnitude == 1);\n+#ifdef VERIFY\n+        CHECK(q.normalized && q.magnitude == 1);\n+#endif\n         for (j = 0; j < 6; j++) {\n             secp256k1_fe_negate(&z, &z, j+1);\n             secp256k1_fe_normalize_var(&q);\n             secp256k1_fe_cmov(&q, &z, (j&1));\n-            VERIFY_CHECK(!q.normalized && q.magnitude == (j+2));\n+#ifdef VERIFY\n+            CHECK((q.normalized != (j&1)) && q.magnitude == ((j&1) ? z.magnitude : 1));\n+#endif\n         }\n         secp256k1_fe_normalize_var(&z);\n         /* Test storage conversion and conditional moves. */\n@@ -2120,7 +2282,7 @@ void test_ge(void) {\n     /* Test batch gej -> ge conversion with many infinities. */\n     for (i = 0; i < 4 * runs + 1; i++) {\n         random_group_element_test(&ge[i]);\n-        /* randomly set half the points to infinitiy */\n+        /* randomly set half the points to infinity */\n         if(secp256k1_fe_is_odd(&ge[i].x)) {\n             secp256k1_ge_set_infinity(&ge[i]);\n         }\n@@ -2572,14 +2734,13 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n     secp256k1_gej r;\n     secp256k1_gej r2;\n     ecmult_multi_data data;\n-    secp256k1_scratch *scratch_empty;\n \n     data.sc = sc;\n     data.pt = pt;\n     secp256k1_scalar_set_int(&szero, 0);\n \n     /* No points to multiply */\n-    CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, NULL, ecmult_multi_callback, &data, 0));\n+    CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, NULL, ecmult_multi_callback, &data, 0));\n \n     /* Check 1- and 2-point multiplies against ecmult */\n     for (ncount = 0; ncount < count; ncount++) {\n@@ -2595,36 +2756,31 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n \n         /* only G scalar */\n         secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &ptgj, &szero, &sc[0]);\n-        CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &sc[0], ecmult_multi_callback, &data, 0));\n+        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &sc[0], ecmult_multi_callback, &data, 0));\n         secp256k1_gej_neg(&r2, &r2);\n         secp256k1_gej_add_var(&r, &r, &r2, NULL);\n         CHECK(secp256k1_gej_is_infinity(&r));\n \n         /* 1-point */\n         secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &ptgj, &sc[0], &szero);\n-        CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 1));\n+        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 1));\n         secp256k1_gej_neg(&r2, &r2);\n         secp256k1_gej_add_var(&r, &r, &r2, NULL);\n         CHECK(secp256k1_gej_is_infinity(&r));\n \n-        /* Try to multiply 1 point, but scratch space is empty */\n-        scratch_empty = secp256k1_scratch_create(&ctx->error_callback, 0);\n-        CHECK(!ecmult_multi(&ctx->ecmult_ctx, scratch_empty, &r, &szero, ecmult_multi_callback, &data, 1));\n-        secp256k1_scratch_destroy(scratch_empty);\n-\n         /* Try to multiply 1 point, but callback returns false */\n-        CHECK(!ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_false_callback, &data, 1));\n+        CHECK(!ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_false_callback, &data, 1));\n \n         /* 2-point */\n         secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &ptgj, &sc[0], &sc[1]);\n-        CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 2));\n+        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 2));\n         secp256k1_gej_neg(&r2, &r2);\n         secp256k1_gej_add_var(&r, &r, &r2, NULL);\n         CHECK(secp256k1_gej_is_infinity(&r));\n \n         /* 2-point with G scalar */\n         secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &ptgj, &sc[0], &sc[1]);\n-        CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &sc[1], ecmult_multi_callback, &data, 1));\n+        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &sc[1], ecmult_multi_callback, &data, 1));\n         secp256k1_gej_neg(&r2, &r2);\n         secp256k1_gej_add_var(&r, &r, &r2, NULL);\n         CHECK(secp256k1_gej_is_infinity(&r));\n@@ -2641,7 +2797,7 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n                 random_scalar_order(&sc[i]);\n                 secp256k1_ge_set_infinity(&pt[i]);\n             }\n-            CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n+            CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n             CHECK(secp256k1_gej_is_infinity(&r));\n         }\n \n@@ -2651,7 +2807,7 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n                 pt[i] = ptg;\n                 secp256k1_scalar_set_int(&sc[i], 0);\n             }\n-            CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n+            CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n             CHECK(secp256k1_gej_is_infinity(&r));\n         }\n \n@@ -2664,7 +2820,7 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n                 pt[2 * i + 1] = ptg;\n             }\n \n-            CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n+            CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n             CHECK(secp256k1_gej_is_infinity(&r));\n \n             random_scalar_order(&sc[0]);\n@@ -2677,7 +2833,7 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n                 secp256k1_ge_neg(&pt[2*i+1], &pt[2*i]);\n             }\n \n-            CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n+            CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n             CHECK(secp256k1_gej_is_infinity(&r));\n         }\n \n@@ -2692,7 +2848,7 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n             secp256k1_scalar_negate(&sc[i], &sc[i]);\n         }\n \n-        CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 32));\n+        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 32));\n         CHECK(secp256k1_gej_is_infinity(&r));\n     }\n \n@@ -2711,7 +2867,7 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n         }\n \n         secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &r, &sc[0], &szero);\n-        CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 20));\n+        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 20));\n         secp256k1_gej_neg(&r2, &r2);\n         secp256k1_gej_add_var(&r, &r, &r2, NULL);\n         CHECK(secp256k1_gej_is_infinity(&r));\n@@ -2734,7 +2890,7 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n \n         secp256k1_gej_set_ge(&p0j, &pt[0]);\n         secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &p0j, &rs, &szero);\n-        CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 20));\n+        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 20));\n         secp256k1_gej_neg(&r2, &r2);\n         secp256k1_gej_add_var(&r, &r, &r2, NULL);\n         CHECK(secp256k1_gej_is_infinity(&r));\n@@ -2747,13 +2903,13 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n     }\n \n     secp256k1_scalar_clear(&sc[0]);\n-    CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 20));\n+    CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 20));\n     secp256k1_scalar_clear(&sc[1]);\n     secp256k1_scalar_clear(&sc[2]);\n     secp256k1_scalar_clear(&sc[3]);\n     secp256k1_scalar_clear(&sc[4]);\n-    CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 6));\n-    CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 5));\n+    CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 6));\n+    CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 5));\n     CHECK(secp256k1_gej_is_infinity(&r));\n \n     /* Run through s0*(t0*P) + s1*(t1*P) exhaustively for many small values of s0, s1, t0, t1 */\n@@ -2798,7 +2954,7 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n                         secp256k1_scalar_add(&tmp1, &tmp1, &tmp2);\n \n                         secp256k1_ecmult(&ctx->ecmult_ctx, &expected, &ptgj, &tmp1, &szero);\n-                        CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &actual, &szero, ecmult_multi_callback, &data, 2));\n+                        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &actual, &szero, ecmult_multi_callback, &data, 2));\n                         secp256k1_gej_neg(&expected, &expected);\n                         secp256k1_gej_add_var(&actual, &actual, &expected, NULL);\n                         CHECK(secp256k1_gej_is_infinity(&actual));\n@@ -2809,6 +2965,24 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n     }\n }\n \n+void test_ecmult_multi_batch_single(secp256k1_ecmult_multi_func ecmult_multi) {\n+    secp256k1_scalar szero;\n+    secp256k1_scalar sc[32];\n+    secp256k1_ge pt[32];\n+    secp256k1_gej r;\n+    ecmult_multi_data data;\n+    secp256k1_scratch *scratch_empty;\n+\n+    data.sc = sc;\n+    data.pt = pt;\n+    secp256k1_scalar_set_int(&szero, 0);\n+\n+    /* Try to multiply 1 point, but scratch space is empty.*/\n+    scratch_empty = secp256k1_scratch_create(&ctx->error_callback, 0);\n+    CHECK(!ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch_empty, &r, &szero, ecmult_multi_callback, &data, 1));\n+    secp256k1_scratch_destroy(&ctx->error_callback, scratch_empty);\n+}\n+\n void test_secp256k1_pippenger_bucket_window_inv(void) {\n     int i;\n \n@@ -2839,17 +3013,27 @@ void test_ecmult_multi_pippenger_max_points(void) {\n     int bucket_window = 0;\n \n     for(; scratch_size < max_size; scratch_size+=256) {\n+        size_t i;\n+        size_t total_alloc;\n+        size_t checkpoint;\n         scratch = secp256k1_scratch_create(&ctx->error_callback, scratch_size);\n         CHECK(scratch != NULL);\n-        n_points_supported = secp256k1_pippenger_max_points(scratch);\n+        checkpoint = secp256k1_scratch_checkpoint(&ctx->error_callback, scratch);\n+        n_points_supported = secp256k1_pippenger_max_points(&ctx->error_callback, scratch);\n         if (n_points_supported == 0) {\n-            secp256k1_scratch_destroy(scratch);\n+            secp256k1_scratch_destroy(&ctx->error_callback, scratch);\n             continue;\n         }\n         bucket_window = secp256k1_pippenger_bucket_window(n_points_supported);\n-        CHECK(secp256k1_scratch_allocate_frame(scratch, secp256k1_pippenger_scratch_size(n_points_supported, bucket_window), PIPPENGER_SCRATCH_OBJECTS));\n-        secp256k1_scratch_deallocate_frame(scratch);\n-        secp256k1_scratch_destroy(scratch);\n+        /* allocate `total_alloc` bytes over `PIPPENGER_SCRATCH_OBJECTS` many allocations */\n+        total_alloc = secp256k1_pippenger_scratch_size(n_points_supported, bucket_window);\n+        for (i = 0; i < PIPPENGER_SCRATCH_OBJECTS - 1; i++) {\n+            CHECK(secp256k1_scratch_alloc(&ctx->error_callback, scratch, 1));\n+            total_alloc--;\n+        }\n+        CHECK(secp256k1_scratch_alloc(&ctx->error_callback, scratch, total_alloc));\n+        secp256k1_scratch_apply_checkpoint(&ctx->error_callback, scratch, checkpoint);\n+        secp256k1_scratch_destroy(&ctx->error_callback, scratch);\n     }\n     CHECK(bucket_window == PIPPENGER_MAX_BUCKET_WINDOW);\n }\n@@ -2932,19 +3116,25 @@ void test_ecmult_multi_batching(void) {\n     }\n     data.sc = sc;\n     data.pt = pt;\n+    secp256k1_gej_neg(&r2, &r2);\n \n-    /* Test with empty scratch space */\n+    /* Test with empty scratch space. It should compute the correct result using\n+     * ecmult_mult_simple algorithm which doesn't require a scratch space. */\n     scratch = secp256k1_scratch_create(&ctx->error_callback, 0);\n-    CHECK(!secp256k1_ecmult_multi_var(&ctx->ecmult_ctx, scratch, &r, &scG, ecmult_multi_callback, &data, 1));\n-    secp256k1_scratch_destroy(scratch);\n+    CHECK(secp256k1_ecmult_multi_var(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &scG, ecmult_multi_callback, &data, n_points));\n+    secp256k1_gej_add_var(&r, &r, &r2, NULL);\n+    CHECK(secp256k1_gej_is_infinity(&r));\n+    secp256k1_scratch_destroy(&ctx->error_callback, scratch);\n \n     /* Test with space for 1 point in pippenger. That's not enough because\n-     * ecmult_multi selects strauss which requires more memory. */\n+     * ecmult_multi selects strauss which requires more memory. It should\n+     * therefore select the simple algorithm. */\n     scratch = secp256k1_scratch_create(&ctx->error_callback, secp256k1_pippenger_scratch_size(1, 1) + PIPPENGER_SCRATCH_OBJECTS*ALIGNMENT);\n-    CHECK(!secp256k1_ecmult_multi_var(&ctx->ecmult_ctx, scratch, &r, &scG, ecmult_multi_callback, &data, 1));\n-    secp256k1_scratch_destroy(scratch);\n+    CHECK(secp256k1_ecmult_multi_var(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &scG, ecmult_multi_callback, &data, n_points));\n+    secp256k1_gej_add_var(&r, &r, &r2, NULL);\n+    CHECK(secp256k1_gej_is_infinity(&r));\n+    secp256k1_scratch_destroy(&ctx->error_callback, scratch);\n \n-    secp256k1_gej_neg(&r2, &r2);\n     for(i = 1; i <= n_points; i++) {\n         if (i > ECMULT_PIPPENGER_THRESHOLD) {\n             int bucket_window = secp256k1_pippenger_bucket_window(i);\n@@ -2954,10 +3144,10 @@ void test_ecmult_multi_batching(void) {\n             size_t scratch_size = secp256k1_strauss_scratch_size(i);\n             scratch = secp256k1_scratch_create(&ctx->error_callback, scratch_size + STRAUSS_SCRATCH_OBJECTS*ALIGNMENT);\n         }\n-        CHECK(secp256k1_ecmult_multi_var(&ctx->ecmult_ctx, scratch, &r, &scG, ecmult_multi_callback, &data, n_points));\n+        CHECK(secp256k1_ecmult_multi_var(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &scG, ecmult_multi_callback, &data, n_points));\n         secp256k1_gej_add_var(&r, &r, &r2, NULL);\n         CHECK(secp256k1_gej_is_infinity(&r));\n-        secp256k1_scratch_destroy(scratch);\n+        secp256k1_scratch_destroy(&ctx->error_callback, scratch);\n     }\n     free(sc);\n     free(pt);\n@@ -2972,13 +3162,15 @@ void run_ecmult_multi_tests(void) {\n     test_ecmult_multi(scratch, secp256k1_ecmult_multi_var);\n     test_ecmult_multi(NULL, secp256k1_ecmult_multi_var);\n     test_ecmult_multi(scratch, secp256k1_ecmult_pippenger_batch_single);\n+    test_ecmult_multi_batch_single(secp256k1_ecmult_pippenger_batch_single);\n     test_ecmult_multi(scratch, secp256k1_ecmult_strauss_batch_single);\n-    secp256k1_scratch_destroy(scratch);\n+    test_ecmult_multi_batch_single(secp256k1_ecmult_strauss_batch_single);\n+    secp256k1_scratch_destroy(&ctx->error_callback, scratch);\n \n     /* Run test_ecmult_multi with space for exactly one point */\n     scratch = secp256k1_scratch_create(&ctx->error_callback, secp256k1_strauss_scratch_size(1) + STRAUSS_SCRATCH_OBJECTS*ALIGNMENT);\n     test_ecmult_multi(scratch, secp256k1_ecmult_multi_var);\n-    secp256k1_scratch_destroy(scratch);\n+    secp256k1_scratch_destroy(&ctx->error_callback, scratch);\n \n     test_ecmult_multi_batch_size_helper();\n     test_ecmult_multi_batching();\n@@ -3050,7 +3242,7 @@ void test_constant_wnaf(const secp256k1_scalar *number, int w) {\n     }\n     bits = 128;\n #endif\n-    skew = secp256k1_wnaf_const(wnaf, num, w, bits);\n+    skew = secp256k1_wnaf_const(wnaf, &num, w, bits);\n \n     for (i = WNAF_SIZE_BITS(bits, w); i >= 0; --i) {\n         secp256k1_scalar t;\n@@ -3786,45 +3978,65 @@ void run_eckey_edge_case_test(void) {\n     pubkey_negone = pubkey;\n     /* Tweak of zero leaves the value unchanged. */\n     memset(ctmp2, 0, 32);\n-    CHECK(secp256k1_ec_privkey_tweak_add(ctx, ctmp, ctmp2) == 1);\n+    CHECK(secp256k1_ec_seckey_tweak_add(ctx, ctmp, ctmp2) == 1);\n     CHECK(memcmp(orderc, ctmp, 31) == 0 && ctmp[31] == 0x40);\n     memcpy(&pubkey2, &pubkey, sizeof(pubkey));\n     CHECK(secp256k1_ec_pubkey_tweak_add(ctx, &pubkey, ctmp2) == 1);\n     CHECK(memcmp(&pubkey, &pubkey2, sizeof(pubkey)) == 0);\n     /* Multiply tweak of zero zeroizes the output. */\n-    CHECK(secp256k1_ec_privkey_tweak_mul(ctx, ctmp, ctmp2) == 0);\n+    CHECK(secp256k1_ec_seckey_tweak_mul(ctx, ctmp, ctmp2) == 0);\n     CHECK(memcmp(zeros, ctmp, 32) == 0);\n     CHECK(secp256k1_ec_pubkey_tweak_mul(ctx, &pubkey, ctmp2) == 0);\n     CHECK(memcmp(&pubkey, zeros, sizeof(pubkey)) == 0);\n     memcpy(&pubkey, &pubkey2, sizeof(pubkey));\n-    /* Overflowing key tweak zeroizes. */\n+    /* If seckey_tweak_add or seckey_tweak_mul are called with an overflowing\n+    seckey, the seckey is zeroized. */\n+    memcpy(ctmp, orderc, 32);\n+    memset(ctmp2, 0, 32);\n+    ctmp2[31] = 0x01;\n+    CHECK(secp256k1_ec_seckey_verify(ctx, ctmp2) == 1);\n+    CHECK(secp256k1_ec_seckey_verify(ctx, ctmp) == 0);\n+    CHECK(secp256k1_ec_seckey_tweak_add(ctx, ctmp, ctmp2) == 0);\n+    CHECK(memcmp(zeros, ctmp, 32) == 0);\n+    memcpy(ctmp, orderc, 32);\n+    CHECK(secp256k1_ec_seckey_tweak_mul(ctx, ctmp, ctmp2) == 0);\n+    CHECK(memcmp(zeros, ctmp, 32) == 0);\n+    /* If seckey_tweak_add or seckey_tweak_mul are called with an overflowing\n+    tweak, the seckey is zeroized. */\n     memcpy(ctmp, orderc, 32);\n     ctmp[31] = 0x40;\n-    CHECK(secp256k1_ec_privkey_tweak_add(ctx, ctmp, orderc) == 0);\n+    CHECK(secp256k1_ec_seckey_tweak_add(ctx, ctmp, orderc) == 0);\n     CHECK(memcmp(zeros, ctmp, 32) == 0);\n     memcpy(ctmp, orderc, 32);\n     ctmp[31] = 0x40;\n-    CHECK(secp256k1_ec_privkey_tweak_mul(ctx, ctmp, orderc) == 0);\n+    CHECK(secp256k1_ec_seckey_tweak_mul(ctx, ctmp, orderc) == 0);\n     CHECK(memcmp(zeros, ctmp, 32) == 0);\n     memcpy(ctmp, orderc, 32);\n     ctmp[31] = 0x40;\n+    /* If pubkey_tweak_add or pubkey_tweak_mul are called with an overflowing\n+    tweak, the pubkey is zeroized. */\n     CHECK(secp256k1_ec_pubkey_tweak_add(ctx, &pubkey, orderc) == 0);\n     CHECK(memcmp(&pubkey, zeros, sizeof(pubkey)) == 0);\n     memcpy(&pubkey, &pubkey2, sizeof(pubkey));\n     CHECK(secp256k1_ec_pubkey_tweak_mul(ctx, &pubkey, orderc) == 0);\n     CHECK(memcmp(&pubkey, zeros, sizeof(pubkey)) == 0);\n     memcpy(&pubkey, &pubkey2, sizeof(pubkey));\n-    /* Private key tweaks results in a key of zero. */\n+    /* If the resulting key in secp256k1_ec_seckey_tweak_add and\n+     * secp256k1_ec_pubkey_tweak_add is 0 the functions fail and in the latter\n+     * case the pubkey is zeroized. */\n+    memcpy(ctmp, orderc, 32);\n+    ctmp[31] = 0x40;\n+    memset(ctmp2, 0, 32);\n     ctmp2[31] = 1;\n-    CHECK(secp256k1_ec_privkey_tweak_add(ctx, ctmp2, ctmp) == 0);\n+    CHECK(secp256k1_ec_seckey_tweak_add(ctx, ctmp2, ctmp) == 0);\n     CHECK(memcmp(zeros, ctmp2, 32) == 0);\n     ctmp2[31] = 1;\n     CHECK(secp256k1_ec_pubkey_tweak_add(ctx, &pubkey, ctmp2) == 0);\n     CHECK(memcmp(&pubkey, zeros, sizeof(pubkey)) == 0);\n     memcpy(&pubkey, &pubkey2, sizeof(pubkey));\n     /* Tweak computation wraps and results in a key of 1. */\n     ctmp2[31] = 2;\n-    CHECK(secp256k1_ec_privkey_tweak_add(ctx, ctmp2, ctmp) == 1);\n+    CHECK(secp256k1_ec_seckey_tweak_add(ctx, ctmp2, ctmp) == 1);\n     CHECK(memcmp(ctmp2, zeros, 31) == 0 && ctmp2[31] == 1);\n     ctmp2[31] = 2;\n     CHECK(secp256k1_ec_pubkey_tweak_add(ctx, &pubkey, ctmp2) == 1);\n@@ -3872,16 +4084,16 @@ void run_eckey_edge_case_test(void) {\n     CHECK(ecount == 2);\n     ecount = 0;\n     memset(ctmp2, 0, 32);\n-    CHECK(secp256k1_ec_privkey_tweak_add(ctx, NULL, ctmp2) == 0);\n+    CHECK(secp256k1_ec_seckey_tweak_add(ctx, NULL, ctmp2) == 0);\n     CHECK(ecount == 1);\n-    CHECK(secp256k1_ec_privkey_tweak_add(ctx, ctmp, NULL) == 0);\n+    CHECK(secp256k1_ec_seckey_tweak_add(ctx, ctmp, NULL) == 0);\n     CHECK(ecount == 2);\n     ecount = 0;\n     memset(ctmp2, 0, 32);\n     ctmp2[31] = 1;\n-    CHECK(secp256k1_ec_privkey_tweak_mul(ctx, NULL, ctmp2) == 0);\n+    CHECK(secp256k1_ec_seckey_tweak_mul(ctx, NULL, ctmp2) == 0);\n     CHECK(ecount == 1);\n-    CHECK(secp256k1_ec_privkey_tweak_mul(ctx, ctmp, NULL) == 0);\n+    CHECK(secp256k1_ec_seckey_tweak_mul(ctx, ctmp, NULL) == 0);\n     CHECK(ecount == 2);\n     ecount = 0;\n     CHECK(secp256k1_ec_pubkey_create(ctx, NULL, ctmp) == 0);\n@@ -3954,6 +4166,41 @@ void run_eckey_edge_case_test(void) {\n     secp256k1_context_set_illegal_callback(ctx, NULL, NULL);\n }\n \n+void run_eckey_negate_test(void) {\n+    unsigned char seckey[32];\n+    unsigned char seckey_tmp[32];\n+\n+    random_scalar_order_b32(seckey);\n+    memcpy(seckey_tmp, seckey, 32);\n+\n+    /* Verify negation changes the key and changes it back */\n+    CHECK(secp256k1_ec_seckey_negate(ctx, seckey) == 1);\n+    CHECK(memcmp(seckey, seckey_tmp, 32) != 0);\n+    CHECK(secp256k1_ec_seckey_negate(ctx, seckey) == 1);\n+    CHECK(memcmp(seckey, seckey_tmp, 32) == 0);\n+\n+    /* Check that privkey alias gives same result */\n+    CHECK(secp256k1_ec_seckey_negate(ctx, seckey) == 1);\n+    CHECK(secp256k1_ec_privkey_negate(ctx, seckey_tmp) == 1);\n+    CHECK(memcmp(seckey, seckey_tmp, 32) == 0);\n+\n+    /* Negating all 0s fails */\n+    memset(seckey, 0, 32);\n+    memset(seckey_tmp, 0, 32);\n+    CHECK(secp256k1_ec_seckey_negate(ctx, seckey) == 0);\n+    /* Check that seckey is not modified */\n+    CHECK(memcmp(seckey, seckey_tmp, 32) == 0);\n+\n+    /* Negating an overflowing seckey fails and the seckey is zeroed. In this\n+     * test, the seckey has 16 random bytes to ensure that ec_seckey_negate\n+     * doesn't just set seckey to a constant value in case of failure. */\n+    random_scalar_order_b32(seckey);\n+    memset(seckey, 0xFF, 16);\n+    memset(seckey_tmp, 0, 32);\n+    CHECK(secp256k1_ec_seckey_negate(ctx, seckey) == 0);\n+    CHECK(memcmp(seckey, seckey_tmp, 32) == 0);\n+}\n+\n void random_sign(secp256k1_scalar *sigr, secp256k1_scalar *sigs, const secp256k1_scalar *key, const secp256k1_scalar *msg, int *recid) {\n     secp256k1_scalar nonce;\n     do {\n@@ -4093,15 +4340,22 @@ void test_ecdsa_end_to_end(void) {\n     if (secp256k1_rand_int(3) == 0) {\n         int ret1;\n         int ret2;\n+        int ret3;\n         unsigned char rnd[32];\n+        unsigned char privkey_tmp[32];\n         secp256k1_pubkey pubkey2;\n         secp256k1_rand256_test(rnd);\n-        ret1 = secp256k1_ec_privkey_tweak_add(ctx, privkey, rnd);\n+        memcpy(privkey_tmp, privkey, 32);\n+        ret1 = secp256k1_ec_seckey_tweak_add(ctx, privkey, rnd);\n         ret2 = secp256k1_ec_pubkey_tweak_add(ctx, &pubkey, rnd);\n+        /* Check that privkey alias gives same result */\n+        ret3 = secp256k1_ec_privkey_tweak_add(ctx, privkey_tmp, rnd);\n         CHECK(ret1 == ret2);\n+        CHECK(ret2 == ret3);\n         if (ret1 == 0) {\n             return;\n         }\n+        CHECK(memcmp(privkey, privkey_tmp, 32) == 0);\n         CHECK(secp256k1_ec_pubkey_create(ctx, &pubkey2, privkey) == 1);\n         CHECK(memcmp(&pubkey, &pubkey2, sizeof(pubkey)) == 0);\n     }\n@@ -4110,15 +4364,22 @@ void test_ecdsa_end_to_end(void) {\n     if (secp256k1_rand_int(3) == 0) {\n         int ret1;\n         int ret2;\n+        int ret3;\n         unsigned char rnd[32];\n+        unsigned char privkey_tmp[32];\n         secp256k1_pubkey pubkey2;\n         secp256k1_rand256_test(rnd);\n-        ret1 = secp256k1_ec_privkey_tweak_mul(ctx, privkey, rnd);\n+        memcpy(privkey_tmp, privkey, 32);\n+        ret1 = secp256k1_ec_seckey_tweak_mul(ctx, privkey, rnd);\n         ret2 = secp256k1_ec_pubkey_tweak_mul(ctx, &pubkey, rnd);\n+        /* Check that privkey alias gives same result */\n+        ret3 = secp256k1_ec_privkey_tweak_mul(ctx, privkey_tmp, rnd);\n         CHECK(ret1 == ret2);\n+        CHECK(ret2 == ret3);\n         if (ret1 == 0) {\n             return;\n         }\n+        CHECK(memcmp(privkey, privkey_tmp, 32) == 0);\n         CHECK(secp256k1_ec_pubkey_create(ctx, &pubkey2, privkey) == 1);\n         CHECK(memcmp(&pubkey, &pubkey2, sizeof(pubkey)) == 0);\n     }\n@@ -4315,7 +4576,7 @@ int test_ecdsa_der_parse(const unsigned char *sig, size_t siglen, int certainly_\n     if (valid_der) {\n         ret |= (!roundtrips_der_lax) << 12;\n         ret |= (len_der != len_der_lax) << 13;\n-        ret |= (memcmp(roundtrip_der_lax, roundtrip_der, len_der) != 0) << 14;\n+        ret |= ((len_der != len_der_lax) || (memcmp(roundtrip_der_lax, roundtrip_der, len_der) != 0)) << 14;\n     }\n     ret |= (roundtrips_der != roundtrips_der_lax) << 15;\n     if (parsed_der) {\n@@ -4356,7 +4617,7 @@ int test_ecdsa_der_parse(const unsigned char *sig, size_t siglen, int certainly_\n     ret |= (roundtrips_der != roundtrips_openssl) << 7;\n     if (roundtrips_openssl) {\n         ret |= (len_der != (size_t)len_openssl) << 8;\n-        ret |= (memcmp(roundtrip_der, roundtrip_openssl, len_der) != 0) << 9;\n+        ret |= ((len_der != (size_t)len_openssl) || (memcmp(roundtrip_der, roundtrip_openssl, len_der) != 0)) << 9;\n     }\n #endif\n     return ret;\n@@ -5016,9 +5277,188 @@ void run_ecdsa_openssl(void) {\n # include \"modules/recovery/tests_impl.h\"\n #endif\n \n+void run_memczero_test(void) {\n+    unsigned char buf1[6] = {1, 2, 3, 4, 5, 6};\n+    unsigned char buf2[sizeof(buf1)];\n+\n+    /* memczero(..., ..., 0) is a noop. */\n+    memcpy(buf2, buf1, sizeof(buf1));\n+    memczero(buf1, sizeof(buf1), 0);\n+    CHECK(memcmp(buf1, buf2, sizeof(buf1)) == 0);\n+\n+    /* memczero(..., ..., 1) zeros the buffer. */\n+    memset(buf2, 0, sizeof(buf2));\n+    memczero(buf1, sizeof(buf1) , 1);\n+    CHECK(memcmp(buf1, buf2, sizeof(buf1)) == 0);\n+}\n+\n+void int_cmov_test(void) {\n+    int r = INT_MAX;\n+    int a = 0;\n+\n+    secp256k1_int_cmov(&r, &a, 0);\n+    CHECK(r == INT_MAX);\n+\n+    r = 0; a = INT_MAX;\n+    secp256k1_int_cmov(&r, &a, 1);\n+    CHECK(r == INT_MAX);\n+\n+    a = 0;\n+    secp256k1_int_cmov(&r, &a, 1);\n+    CHECK(r == 0);\n+\n+    a = 1;\n+    secp256k1_int_cmov(&r, &a, 1);\n+    CHECK(r == 1);\n+\n+    r = 1; a = 0;\n+    secp256k1_int_cmov(&r, &a, 0);\n+    CHECK(r == 1);\n+\n+}\n+\n+void fe_cmov_test(void) {\n+    static const secp256k1_fe zero = SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 0);\n+    static const secp256k1_fe one = SECP256K1_FE_CONST(0, 0, 0, 0, 0, 0, 0, 1);\n+    static const secp256k1_fe max = SECP256K1_FE_CONST(\n+        0xFFFFFFFFUL, 0xFFFFFFFFUL, 0xFFFFFFFFUL, 0xFFFFFFFFUL,\n+        0xFFFFFFFFUL, 0xFFFFFFFFUL, 0xFFFFFFFFUL, 0xFFFFFFFFUL\n+    );\n+    secp256k1_fe r = max;\n+    secp256k1_fe a = zero;\n+\n+    secp256k1_fe_cmov(&r, &a, 0);\n+    CHECK(memcmp(&r, &max, sizeof(r)) == 0);\n+\n+    r = zero; a = max;\n+    secp256k1_fe_cmov(&r, &a, 1);\n+    CHECK(memcmp(&r, &max, sizeof(r)) == 0);\n+\n+    a = zero;\n+    secp256k1_fe_cmov(&r, &a, 1);\n+    CHECK(memcmp(&r, &zero, sizeof(r)) == 0);\n+\n+    a = one;\n+    secp256k1_fe_cmov(&r, &a, 1);\n+    CHECK(memcmp(&r, &one, sizeof(r)) == 0);\n+\n+    r = one; a = zero;\n+    secp256k1_fe_cmov(&r, &a, 0);\n+    CHECK(memcmp(&r, &one, sizeof(r)) == 0);\n+}\n+\n+void fe_storage_cmov_test(void) {\n+    static const secp256k1_fe_storage zero = SECP256K1_FE_STORAGE_CONST(0, 0, 0, 0, 0, 0, 0, 0);\n+    static const secp256k1_fe_storage one = SECP256K1_FE_STORAGE_CONST(0, 0, 0, 0, 0, 0, 0, 1);\n+    static const secp256k1_fe_storage max = SECP256K1_FE_STORAGE_CONST(\n+        0xFFFFFFFFUL, 0xFFFFFFFFUL, 0xFFFFFFFFUL, 0xFFFFFFFFUL,\n+        0xFFFFFFFFUL, 0xFFFFFFFFUL, 0xFFFFFFFFUL, 0xFFFFFFFFUL\n+    );\n+    secp256k1_fe_storage r = max;\n+    secp256k1_fe_storage a = zero;\n+\n+    secp256k1_fe_storage_cmov(&r, &a, 0);\n+    CHECK(memcmp(&r, &max, sizeof(r)) == 0);\n+\n+    r = zero; a = max;\n+    secp256k1_fe_storage_cmov(&r, &a, 1);\n+    CHECK(memcmp(&r, &max, sizeof(r)) == 0);\n+\n+    a = zero;\n+    secp256k1_fe_storage_cmov(&r, &a, 1);\n+    CHECK(memcmp(&r, &zero, sizeof(r)) == 0);\n+\n+    a = one;\n+    secp256k1_fe_storage_cmov(&r, &a, 1);\n+    CHECK(memcmp(&r, &one, sizeof(r)) == 0);\n+\n+    r = one; a = zero;\n+    secp256k1_fe_storage_cmov(&r, &a, 0);\n+    CHECK(memcmp(&r, &one, sizeof(r)) == 0);\n+}\n+\n+void scalar_cmov_test(void) {\n+    static const secp256k1_scalar zero = SECP256K1_SCALAR_CONST(0, 0, 0, 0, 0, 0, 0, 0);\n+    static const secp256k1_scalar one = SECP256K1_SCALAR_CONST(0, 0, 0, 0, 0, 0, 0, 1);\n+    static const secp256k1_scalar max = SECP256K1_SCALAR_CONST(\n+        0xFFFFFFFFUL, 0xFFFFFFFFUL, 0xFFFFFFFFUL, 0xFFFFFFFFUL,\n+        0xFFFFFFFFUL, 0xFFFFFFFFUL, 0xFFFFFFFFUL, 0xFFFFFFFFUL\n+    );\n+    secp256k1_scalar r = max;\n+    secp256k1_scalar a = zero;\n+\n+    secp256k1_scalar_cmov(&r, &a, 0);\n+    CHECK(memcmp(&r, &max, sizeof(r)) == 0);\n+\n+    r = zero; a = max;\n+    secp256k1_scalar_cmov(&r, &a, 1);\n+    CHECK(memcmp(&r, &max, sizeof(r)) == 0);\n+\n+    a = zero;\n+    secp256k1_scalar_cmov(&r, &a, 1);\n+    CHECK(memcmp(&r, &zero, sizeof(r)) == 0);\n+\n+    a = one;\n+    secp256k1_scalar_cmov(&r, &a, 1);\n+    CHECK(memcmp(&r, &one, sizeof(r)) == 0);\n+\n+    r = one; a = zero;\n+    secp256k1_scalar_cmov(&r, &a, 0);\n+    CHECK(memcmp(&r, &one, sizeof(r)) == 0);\n+}\n+\n+void ge_storage_cmov_test(void) {\n+    static const secp256k1_ge_storage zero = SECP256K1_GE_STORAGE_CONST(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n+    static const secp256k1_ge_storage one = SECP256K1_GE_STORAGE_CONST(0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1);\n+    static const secp256k1_ge_storage max = SECP256K1_GE_STORAGE_CONST(\n+        0xFFFFFFFFUL, 0xFFFFFFFFUL, 0xFFFFFFFFUL, 0xFFFFFFFFUL,\n+        0xFFFFFFFFUL, 0xFFFFFFFFUL, 0xFFFFFFFFUL, 0xFFFFFFFFUL,\n+        0xFFFFFFFFUL, 0xFFFFFFFFUL, 0xFFFFFFFFUL, 0xFFFFFFFFUL,\n+        0xFFFFFFFFUL, 0xFFFFFFFFUL, 0xFFFFFFFFUL, 0xFFFFFFFFUL\n+    );\n+    secp256k1_ge_storage r = max;\n+    secp256k1_ge_storage a = zero;\n+\n+    secp256k1_ge_storage_cmov(&r, &a, 0);\n+    CHECK(memcmp(&r, &max, sizeof(r)) == 0);\n+\n+    r = zero; a = max;\n+    secp256k1_ge_storage_cmov(&r, &a, 1);\n+    CHECK(memcmp(&r, &max, sizeof(r)) == 0);\n+\n+    a = zero;\n+    secp256k1_ge_storage_cmov(&r, &a, 1);\n+    CHECK(memcmp(&r, &zero, sizeof(r)) == 0);\n+\n+    a = one;\n+    secp256k1_ge_storage_cmov(&r, &a, 1);\n+    CHECK(memcmp(&r, &one, sizeof(r)) == 0);\n+\n+    r = one; a = zero;\n+    secp256k1_ge_storage_cmov(&r, &a, 0);\n+    CHECK(memcmp(&r, &one, sizeof(r)) == 0);\n+}\n+\n+void run_cmov_tests(void) {\n+    int_cmov_test();\n+    fe_cmov_test();\n+    fe_storage_cmov_test();\n+    scalar_cmov_test();\n+    ge_storage_cmov_test();\n+}\n+\n int main(int argc, char **argv) {\n     unsigned char seed16[16] = {0};\n     unsigned char run32[32] = {0};\n+\n+    /* Disable buffering for stdout to improve reliability of getting\n+     * diagnostic information. Happens right at the start of main because\n+     * setbuf must be used before any other operation on the stream. */\n+    setbuf(stdout, NULL);\n+    /* Also disable buffering for stderr because it's not guaranteed that it's\n+     * unbuffered on all systems. */\n+    setbuf(stderr, NULL);\n+\n     /* find iteration count */\n     if (argc > 1) {\n         count = strtol(argv[1], NULL, 0);\n@@ -5030,7 +5470,7 @@ int main(int argc, char **argv) {\n         const char* ch = argv[2];\n         while (pos < 16 && ch[0] != 0 && ch[1] != 0) {\n             unsigned short sh;\n-            if (sscanf(ch, \"%2hx\", &sh)) {\n+            if ((sscanf(ch, \"%2hx\", &sh)) == 1) {\n                 seed16[pos] = sh;\n             } else {\n                 break;\n@@ -5062,7 +5502,8 @@ int main(int argc, char **argv) {\n     printf(\"random seed = %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\\n\", seed16[0], seed16[1], seed16[2], seed16[3], seed16[4], seed16[5], seed16[6], seed16[7], seed16[8], seed16[9], seed16[10], seed16[11], seed16[12], seed16[13], seed16[14], seed16[15]);\n \n     /* initialize */\n-    run_context_tests();\n+    run_context_tests(0);\n+    run_context_tests(1);\n     run_scratch_tests();\n     ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n     if (secp256k1_rand_bits(1)) {\n@@ -5119,6 +5560,9 @@ int main(int argc, char **argv) {\n     /* EC key edge cases */\n     run_eckey_edge_case_test();\n \n+    /* EC key arithmetic test */\n+    run_eckey_negate_test();\n+\n #ifdef ENABLE_MODULE_ECDH\n     /* ecdh tests */\n     run_ecdh_tests();\n@@ -5139,6 +5583,11 @@ int main(int argc, char **argv) {\n     run_recovery_tests();\n #endif\n \n+    /* util tests */\n+    run_memczero_test();\n+\n+    run_cmov_tests();\n+\n     secp256k1_rand256(run32);\n     printf(\"random run = %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\\n\", run32[0], run32[1], run32[2], run32[3], run32[4], run32[5], run32[6], run32[7], run32[8], run32[9], run32[10], run32[11], run32[12], run32[13], run32[14], run32[15]);\n "
      },
      {
        "sha": "8cca1cef2194c3a970071d20a3e7127b4d38f6c5",
        "filename": "src/secp256k1/src/tests_exhaustive.c",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/tests_exhaustive.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/tests_exhaustive.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/tests_exhaustive.c?ref=8903a1a0a78a705402123d2a5c465217cb9d791c",
        "patch": "@@ -142,7 +142,7 @@ void test_exhaustive_addition(const secp256k1_ge *group, const secp256k1_gej *gr\n     for (i = 0; i < order; i++) {\n         secp256k1_gej tmp;\n         if (i > 0) {\n-            secp256k1_gej_double_nonzero(&tmp, &groupj[i], NULL);\n+            secp256k1_gej_double_nonzero(&tmp, &groupj[i]);\n             ge_equals_gej(&group[(2 * i) % order], &tmp);\n         }\n         secp256k1_gej_double_var(&tmp, &groupj[i], NULL);\n@@ -212,14 +212,14 @@ void test_exhaustive_ecmult_multi(const secp256k1_context *ctx, const secp256k1_\n                         data.pt[0] = group[x];\n                         data.pt[1] = group[y];\n \n-                        secp256k1_ecmult_multi_var(&ctx->ecmult_ctx, scratch, &tmp, &g_sc, ecmult_multi_callback, &data, 2);\n+                        secp256k1_ecmult_multi_var(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &tmp, &g_sc, ecmult_multi_callback, &data, 2);\n                         ge_equals_gej(&group[(i * x + j * y + k) % order], &tmp);\n                     }\n                 }\n             }\n         }\n     }\n-    secp256k1_scratch_destroy(scratch);\n+    secp256k1_scratch_destroy(&ctx->error_callback, scratch);\n }\n \n void r_from_k(secp256k1_scalar *r, const secp256k1_ge *group, int k) {"
      },
      {
        "sha": "8289e23e0c5db4761a85980587c415abbbd2714f",
        "filename": "src/secp256k1/src/util.h",
        "status": "modified",
        "additions": 90,
        "deletions": 0,
        "changes": 90,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/util.h?ref=8903a1a0a78a705402123d2a5c465217cb9d791c",
        "patch": "@@ -14,6 +14,7 @@\n #include <stdlib.h>\n #include <stdint.h>\n #include <stdio.h>\n+#include <limits.h>\n \n typedef struct {\n     void (*fn)(const char *text, void* data);\n@@ -68,6 +69,25 @@ static SECP256K1_INLINE void secp256k1_callback_call(const secp256k1_callback *\n #define VERIFY_SETUP(stmt)\n #endif\n \n+/* Define `VG_UNDEF` and `VG_CHECK` when VALGRIND is defined  */\n+#if !defined(VG_CHECK)\n+# if defined(VALGRIND)\n+#  include <valgrind/memcheck.h>\n+#  define VG_UNDEF(x,y) VALGRIND_MAKE_MEM_UNDEFINED((x),(y))\n+#  define VG_CHECK(x,y) VALGRIND_CHECK_MEM_IS_DEFINED((x),(y))\n+# else\n+#  define VG_UNDEF(x,y)\n+#  define VG_CHECK(x,y)\n+# endif\n+#endif\n+\n+/* Like `VG_CHECK` but on VERIFY only */\n+#if defined(VERIFY)\n+#define VG_CHECK_VERIFY(x,y) VG_CHECK((x), (y))\n+#else\n+#define VG_CHECK_VERIFY(x,y)\n+#endif\n+\n static SECP256K1_INLINE void *checked_malloc(const secp256k1_callback* cb, size_t size) {\n     void *ret = malloc(size);\n     if (ret == NULL) {\n@@ -84,6 +104,47 @@ static SECP256K1_INLINE void *checked_realloc(const secp256k1_callback* cb, void\n     return ret;\n }\n \n+#if defined(__BIGGEST_ALIGNMENT__)\n+#define ALIGNMENT __BIGGEST_ALIGNMENT__\n+#else\n+/* Using 16 bytes alignment because common architectures never have alignment\n+ * requirements above 8 for any of the types we care about. In addition we\n+ * leave some room because currently we don't care about a few bytes. */\n+#define ALIGNMENT 16\n+#endif\n+\n+#define ROUND_TO_ALIGN(size) (((size + ALIGNMENT - 1) / ALIGNMENT) * ALIGNMENT)\n+\n+/* Assume there is a contiguous memory object with bounds [base, base + max_size)\n+ * of which the memory range [base, *prealloc_ptr) is already allocated for usage,\n+ * where *prealloc_ptr is an aligned pointer. In that setting, this functions\n+ * reserves the subobject [*prealloc_ptr, *prealloc_ptr + alloc_size) of\n+ * alloc_size bytes by increasing *prealloc_ptr accordingly, taking into account\n+ * alignment requirements.\n+ *\n+ * The function returns an aligned pointer to the newly allocated subobject.\n+ *\n+ * This is useful for manual memory management: if we're simply given a block\n+ * [base, base + max_size), the caller can use this function to allocate memory\n+ * in this block and keep track of the current allocation state with *prealloc_ptr.\n+ *\n+ * It is VERIFY_CHECKed that there is enough space left in the memory object and\n+ * *prealloc_ptr is aligned relative to base.\n+ */\n+static SECP256K1_INLINE void *manual_alloc(void** prealloc_ptr, size_t alloc_size, void* base, size_t max_size) {\n+    size_t aligned_alloc_size = ROUND_TO_ALIGN(alloc_size);\n+    void* ret;\n+    VERIFY_CHECK(prealloc_ptr != NULL);\n+    VERIFY_CHECK(*prealloc_ptr != NULL);\n+    VERIFY_CHECK(base != NULL);\n+    VERIFY_CHECK((unsigned char*)*prealloc_ptr >= (unsigned char*)base);\n+    VERIFY_CHECK(((unsigned char*)*prealloc_ptr - (unsigned char*)base) % ALIGNMENT == 0);\n+    VERIFY_CHECK((unsigned char*)*prealloc_ptr - (unsigned char*)base + aligned_alloc_size <= max_size);\n+    ret = *prealloc_ptr;\n+    *((unsigned char**)prealloc_ptr) += aligned_alloc_size;\n+    return ret;\n+}\n+\n /* Macro for restrict, when available and not in a VERIFY build. */\n #if defined(SECP256K1_BUILD) && defined(VERIFY)\n # define SECP256K1_RESTRICT\n@@ -118,4 +179,33 @@ static SECP256K1_INLINE void *checked_realloc(const secp256k1_callback* cb, void\n SECP256K1_GNUC_EXT typedef unsigned __int128 uint128_t;\n #endif\n \n+/* Zero memory if flag == 1. Flag must be 0 or 1. Constant time. */\n+static SECP256K1_INLINE void memczero(void *s, size_t len, int flag) {\n+    unsigned char *p = (unsigned char *)s;\n+    /* Access flag with a volatile-qualified lvalue.\n+       This prevents clang from figuring out (after inlining) that flag can\n+       take only be 0 or 1, which leads to variable time code. */\n+    volatile int vflag = flag;\n+    unsigned char mask = -(unsigned char) vflag;\n+    while (len) {\n+        *p &= ~mask;\n+        p++;\n+        len--;\n+    }\n+}\n+\n+/** If flag is true, set *r equal to *a; otherwise leave it. Constant-time.  Both *r and *a must be initialized and non-negative.*/\n+static SECP256K1_INLINE void secp256k1_int_cmov(int *r, const int *a, int flag) {\n+    unsigned int mask0, mask1, r_masked, a_masked;\n+    /* Casting a negative int to unsigned and back to int is implementation defined behavior */\n+    VERIFY_CHECK(*r >= 0 && *a >= 0);\n+\n+    mask0 = (unsigned int)flag + ~0u;\n+    mask1 = ~mask0;\n+    r_masked = ((unsigned int)*r & mask0);\n+    a_masked = ((unsigned int)*a & mask1);\n+\n+    *r = (int)(r_masked | a_masked);\n+}\n+\n #endif /* SECP256K1_UTIL_H */"
      },
      {
        "sha": "60a82d599e8f9accfa9785c58755546051ace341",
        "filename": "src/secp256k1/src/valgrind_ctime_test.c",
        "status": "added",
        "additions": 119,
        "deletions": 0,
        "changes": 119,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/valgrind_ctime_test.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8903a1a0a78a705402123d2a5c465217cb9d791c/src/secp256k1/src/valgrind_ctime_test.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/valgrind_ctime_test.c?ref=8903a1a0a78a705402123d2a5c465217cb9d791c",
        "patch": "@@ -0,0 +1,119 @@\n+/**********************************************************************\n+ * Copyright (c) 2020 Gregory Maxwell                                 *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#include <valgrind/memcheck.h>\n+#include \"include/secp256k1.h\"\n+#include \"util.h\"\n+\n+#if ENABLE_MODULE_ECDH\n+# include \"include/secp256k1_ecdh.h\"\n+#endif\n+\n+#if ENABLE_MODULE_RECOVERY\n+# include \"include/secp256k1_recovery.h\"\n+#endif\n+\n+int main(void) {\n+    secp256k1_context* ctx;\n+    secp256k1_ecdsa_signature signature;\n+    secp256k1_pubkey pubkey;\n+    size_t siglen = 74;\n+    size_t outputlen = 33;\n+    int i;\n+    int ret;\n+    unsigned char msg[32];\n+    unsigned char key[32];\n+    unsigned char sig[74];\n+    unsigned char spubkey[33];\n+#if ENABLE_MODULE_RECOVERY\n+    secp256k1_ecdsa_recoverable_signature recoverable_signature;\n+    int recid;\n+#endif\n+\n+    if (!RUNNING_ON_VALGRIND) {\n+        fprintf(stderr, \"This test can only usefully be run inside valgrind.\\n\");\n+        fprintf(stderr, \"Usage: libtool --mode=execute valgrind ./valgrind_ctime_test\\n\");\n+        exit(1);\n+    }\n+\n+    /** In theory, testing with a single secret input should be sufficient:\n+     *  If control flow depended on secrets the tool would generate an error.\n+     */\n+    for (i = 0; i < 32; i++) {\n+        key[i] = i + 65;\n+    }\n+    for (i = 0; i < 32; i++) {\n+        msg[i] = i + 1;\n+    }\n+\n+    ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_DECLASSIFY);\n+\n+    /* Test keygen. */\n+    VALGRIND_MAKE_MEM_UNDEFINED(key, 32);\n+    ret = secp256k1_ec_pubkey_create(ctx, &pubkey, key);\n+    VALGRIND_MAKE_MEM_DEFINED(&pubkey, sizeof(secp256k1_pubkey));\n+    VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));\n+    CHECK(ret);\n+    CHECK(secp256k1_ec_pubkey_serialize(ctx, spubkey, &outputlen, &pubkey, SECP256K1_EC_COMPRESSED) == 1);\n+\n+    /* Test signing. */\n+    VALGRIND_MAKE_MEM_UNDEFINED(key, 32);\n+    ret = secp256k1_ecdsa_sign(ctx, &signature, msg, key, NULL, NULL);\n+    VALGRIND_MAKE_MEM_DEFINED(&signature, sizeof(secp256k1_ecdsa_signature));\n+    VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));\n+    CHECK(ret);\n+    CHECK(secp256k1_ecdsa_signature_serialize_der(ctx, sig, &siglen, &signature));\n+\n+#if ENABLE_MODULE_ECDH\n+    /* Test ECDH. */\n+    VALGRIND_MAKE_MEM_UNDEFINED(key, 32);\n+    ret = secp256k1_ecdh(ctx, msg, &pubkey, key, NULL, NULL);\n+    VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));\n+    CHECK(ret == 1);\n+#endif\n+\n+#if ENABLE_MODULE_RECOVERY\n+    /* Test signing a recoverable signature. */\n+    VALGRIND_MAKE_MEM_UNDEFINED(key, 32);\n+    ret = secp256k1_ecdsa_sign_recoverable(ctx, &recoverable_signature, msg, key, NULL, NULL);\n+    VALGRIND_MAKE_MEM_DEFINED(&recoverable_signature, sizeof(recoverable_signature));\n+    VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));\n+    CHECK(ret);\n+    CHECK(secp256k1_ecdsa_recoverable_signature_serialize_compact(ctx, sig, &recid, &recoverable_signature));\n+    CHECK(recid >= 0 && recid <= 3);\n+#endif\n+\n+    VALGRIND_MAKE_MEM_UNDEFINED(key, 32);\n+    ret = secp256k1_ec_seckey_verify(ctx, key);\n+    VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));\n+    CHECK(ret == 1);\n+\n+    VALGRIND_MAKE_MEM_UNDEFINED(key, 32);\n+    ret = secp256k1_ec_seckey_negate(ctx, key);\n+    VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));\n+    CHECK(ret == 1);\n+\n+    VALGRIND_MAKE_MEM_UNDEFINED(key, 32);\n+    VALGRIND_MAKE_MEM_UNDEFINED(msg, 32);\n+    ret = secp256k1_ec_seckey_tweak_add(ctx, key, msg);\n+    VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));\n+    CHECK(ret == 1);\n+\n+    VALGRIND_MAKE_MEM_UNDEFINED(key, 32);\n+    VALGRIND_MAKE_MEM_UNDEFINED(msg, 32);\n+    ret = secp256k1_ec_seckey_tweak_mul(ctx, key, msg);\n+    VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));\n+    CHECK(ret == 1);\n+\n+    /* Test context randomisation. Do this last because it leaves the context tainted. */\n+    VALGRIND_MAKE_MEM_UNDEFINED(key, 32);\n+    ret = secp256k1_context_randomize(ctx, key);\n+    VALGRIND_MAKE_MEM_DEFINED(&ret, sizeof(ret));\n+    CHECK(ret);\n+\n+    secp256k1_context_destroy(ctx);\n+    return 0;\n+}"
      }
    ]
  },
  {
    "sha": "ddc2419c090b0af65edc9eb07ac0a736eb351b69",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkZGMyNDE5YzA5MGIwYWY2NWVkYzllYjA3YWMwYTczNmViMzUxYjY5",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-06-09T20:41:38Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-06-09T20:41:38Z"
      },
      "message": "Update MSVC build config for libsecp256k1",
      "tree": {
        "sha": "b83f00244bf5ec7bc0f6a3aa7240db023a00e3a3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b83f00244bf5ec7bc0f6a3aa7240db023a00e3a3"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ddc2419c090b0af65edc9eb07ac0a736eb351b69",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ddc2419c090b0af65edc9eb07ac0a736eb351b69",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ddc2419c090b0af65edc9eb07ac0a736eb351b69",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ddc2419c090b0af65edc9eb07ac0a736eb351b69/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8903a1a0a78a705402123d2a5c465217cb9d791c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8903a1a0a78a705402123d2a5c465217cb9d791c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8903a1a0a78a705402123d2a5c465217cb9d791c"
      }
    ],
    "stats": {
      "total": 3,
      "additions": 3,
      "deletions": 0
    },
    "files": [
      {
        "sha": "5978b9a0d96f0c107da6c2beae79dae4c7536749",
        "filename": "build_msvc/libsecp256k1_config.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ddc2419c090b0af65edc9eb07ac0a736eb351b69/build_msvc/libsecp256k1_config.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ddc2419c090b0af65edc9eb07ac0a736eb351b69/build_msvc/libsecp256k1_config.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build_msvc/libsecp256k1_config.h?ref=ddc2419c090b0af65edc9eb07ac0a736eb351b69",
        "patch": "@@ -26,4 +26,7 @@\n #define USE_FIELD_10X26 1\n #define USE_SCALAR_8X32 1\n \n+#define ECMULT_GEN_PREC_BITS 4\n+#define ECMULT_WINDOW_SIZE 15\n+\n #endif /* BITCOIN_LIBSECP256K1_CONFIG_H */"
      }
    ]
  },
  {
    "sha": "ca8bc4233059bb576c658d1b20bbfbfc00e8481f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjYThiYzQyMzMwNTliYjU3NmM2NThkMWIyMGJiZmJmYzAwZTg0ODFm",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-06-11T01:15:38Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-06-11T01:15:38Z"
      },
      "message": "Drop --disable-jni from libsecp256k1 configure options",
      "tree": {
        "sha": "d71837602ee3784b0cda9f0bc4a9ca4449f40467",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d71837602ee3784b0cda9f0bc4a9ca4449f40467"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ca8bc4233059bb576c658d1b20bbfbfc00e8481f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ca8bc4233059bb576c658d1b20bbfbfc00e8481f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ca8bc4233059bb576c658d1b20bbfbfc00e8481f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ca8bc4233059bb576c658d1b20bbfbfc00e8481f/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ddc2419c090b0af65edc9eb07ac0a736eb351b69",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ddc2419c090b0af65edc9eb07ac0a736eb351b69",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ddc2419c090b0af65edc9eb07ac0a736eb351b69"
      }
    ],
    "stats": {
      "total": 2,
      "additions": 1,
      "deletions": 1
    },
    "files": [
      {
        "sha": "c38d5ca1a2f1df2b85e7dd654c366b7c7b836df6",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca8bc4233059bb576c658d1b20bbfbfc00e8481f/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca8bc4233059bb576c658d1b20bbfbfc00e8481f/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=ca8bc4233059bb576c658d1b20bbfbfc00e8481f",
        "patch": "@@ -1721,7 +1721,7 @@ if test x$need_bundled_univalue = xyes; then\n   AC_CONFIG_SUBDIRS([src/univalue])\n fi\n \n-ac_configure_args=\"${ac_configure_args} --disable-shared --with-pic --enable-benchmark=no --with-bignum=no --enable-module-recovery --disable-jni\"\n+ac_configure_args=\"${ac_configure_args} --disable-shared --with-pic --enable-benchmark=no --with-bignum=no --enable-module-recovery\"\n AC_CONFIG_SUBDIRS([src/secp256k1])\n \n AC_OUTPUT"
      }
    ]
  },
  {
    "sha": "e10439ce5a54cd13062e4ed07ebc681e385ed5cb",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplMTA0MzljZTVhNTRjZDEzMDYyZTRlZDA3ZWJjNjgxZTM4NWVkNWNi",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-06-11T01:29:33Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-06-11T01:29:33Z"
      },
      "message": "scripted-diff: rename privkey with seckey in secp256k1 interface\n\n-BEGIN VERIFY SCRIPT-\nsed -i 's/privkey/seckey/g' src/key.cpp\n-END VERIFY SCRIPT-",
      "tree": {
        "sha": "f6b871865c595178b53a2537c1c78538b20122b5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f6b871865c595178b53a2537c1c78538b20122b5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e10439ce5a54cd13062e4ed07ebc681e385ed5cb",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e10439ce5a54cd13062e4ed07ebc681e385ed5cb",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e10439ce5a54cd13062e4ed07ebc681e385ed5cb",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e10439ce5a54cd13062e4ed07ebc681e385ed5cb/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ca8bc4233059bb576c658d1b20bbfbfc00e8481f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ca8bc4233059bb576c658d1b20bbfbfc00e8481f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ca8bc4233059bb576c658d1b20bbfbfc00e8481f"
      }
    ],
    "stats": {
      "total": 78,
      "additions": 39,
      "deletions": 39
    },
    "files": [
      {
        "sha": "7eecc6e0830cfb13a368e09a2bb6397718f4f9f4",
        "filename": "src/key.cpp",
        "status": "modified",
        "additions": 39,
        "deletions": 39,
        "changes": 78,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e10439ce5a54cd13062e4ed07ebc681e385ed5cb/src/key.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e10439ce5a54cd13062e4ed07ebc681e385ed5cb/src/key.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/key.cpp?ref=e10439ce5a54cd13062e4ed07ebc681e385ed5cb",
        "patch": "@@ -31,46 +31,46 @@ static secp256k1_context* secp256k1_context_sign = nullptr;\n  *\n  * out32 must point to an output buffer of length at least 32 bytes.\n  */\n-static int ec_privkey_import_der(const secp256k1_context* ctx, unsigned char *out32, const unsigned char *privkey, size_t privkeylen) {\n-    const unsigned char *end = privkey + privkeylen;\n+static int ec_seckey_import_der(const secp256k1_context* ctx, unsigned char *out32, const unsigned char *seckey, size_t seckeylen) {\n+    const unsigned char *end = seckey + seckeylen;\n     memset(out32, 0, 32);\n     /* sequence header */\n-    if (end - privkey < 1 || *privkey != 0x30u) {\n+    if (end - seckey < 1 || *seckey != 0x30u) {\n         return 0;\n     }\n-    privkey++;\n+    seckey++;\n     /* sequence length constructor */\n-    if (end - privkey < 1 || !(*privkey & 0x80u)) {\n+    if (end - seckey < 1 || !(*seckey & 0x80u)) {\n         return 0;\n     }\n-    ptrdiff_t lenb = *privkey & ~0x80u; privkey++;\n+    ptrdiff_t lenb = *seckey & ~0x80u; seckey++;\n     if (lenb < 1 || lenb > 2) {\n         return 0;\n     }\n-    if (end - privkey < lenb) {\n+    if (end - seckey < lenb) {\n         return 0;\n     }\n     /* sequence length */\n-    ptrdiff_t len = privkey[lenb-1] | (lenb > 1 ? privkey[lenb-2] << 8 : 0u);\n-    privkey += lenb;\n-    if (end - privkey < len) {\n+    ptrdiff_t len = seckey[lenb-1] | (lenb > 1 ? seckey[lenb-2] << 8 : 0u);\n+    seckey += lenb;\n+    if (end - seckey < len) {\n         return 0;\n     }\n     /* sequence element 0: version number (=1) */\n-    if (end - privkey < 3 || privkey[0] != 0x02u || privkey[1] != 0x01u || privkey[2] != 0x01u) {\n+    if (end - seckey < 3 || seckey[0] != 0x02u || seckey[1] != 0x01u || seckey[2] != 0x01u) {\n         return 0;\n     }\n-    privkey += 3;\n+    seckey += 3;\n     /* sequence element 1: octet string, up to 32 bytes */\n-    if (end - privkey < 2 || privkey[0] != 0x04u) {\n+    if (end - seckey < 2 || seckey[0] != 0x04u) {\n         return 0;\n     }\n-    ptrdiff_t oslen = privkey[1];\n-    privkey += 2;\n-    if (oslen > 32 || end - privkey < oslen) {\n+    ptrdiff_t oslen = seckey[1];\n+    seckey += 2;\n+    if (oslen > 32 || end - seckey < oslen) {\n         return 0;\n     }\n-    memcpy(out32 + (32 - oslen), privkey, oslen);\n+    memcpy(out32 + (32 - oslen), seckey, oslen);\n     if (!secp256k1_ec_seckey_verify(ctx, out32)) {\n         memset(out32, 0, 32);\n         return 0;\n@@ -83,17 +83,17 @@ static int ec_privkey_import_der(const secp256k1_context* ctx, unsigned char *ou\n  * <http://www.secg.org/sec1-v2.pdf>. The optional parameters and publicKey fields are\n  * included.\n  *\n- * privkey must point to an output buffer of length at least CKey::SIZE bytes.\n- * privkeylen must initially be set to the size of the privkey buffer. Upon return it\n+ * seckey must point to an output buffer of length at least CKey::SIZE bytes.\n+ * seckeylen must initially be set to the size of the seckey buffer. Upon return it\n  * will be set to the number of bytes used in the buffer.\n  * key32 must point to a 32-byte raw private key.\n  */\n-static int ec_privkey_export_der(const secp256k1_context *ctx, unsigned char *privkey, size_t *privkeylen, const unsigned char *key32, bool compressed) {\n-    assert(*privkeylen >= CKey::SIZE);\n+static int ec_seckey_export_der(const secp256k1_context *ctx, unsigned char *seckey, size_t *seckeylen, const unsigned char *key32, bool compressed) {\n+    assert(*seckeylen >= CKey::SIZE);\n     secp256k1_pubkey pubkey;\n     size_t pubkeylen = 0;\n     if (!secp256k1_ec_pubkey_create(ctx, &pubkey, key32)) {\n-        *privkeylen = 0;\n+        *seckeylen = 0;\n         return 0;\n     }\n     if (compressed) {\n@@ -111,15 +111,15 @@ static int ec_privkey_export_der(const secp256k1_context *ctx, unsigned char *pr\n             0xFF,0xFF,0xFF,0xFF,0xFE,0xBA,0xAE,0xDC,0xE6,0xAF,0x48,0xA0,0x3B,0xBF,0xD2,0x5E,\n             0x8C,0xD0,0x36,0x41,0x41,0x02,0x01,0x01,0xA1,0x24,0x03,0x22,0x00\n         };\n-        unsigned char *ptr = privkey;\n+        unsigned char *ptr = seckey;\n         memcpy(ptr, begin, sizeof(begin)); ptr += sizeof(begin);\n         memcpy(ptr, key32, 32); ptr += 32;\n         memcpy(ptr, middle, sizeof(middle)); ptr += sizeof(middle);\n         pubkeylen = CPubKey::COMPRESSED_SIZE;\n         secp256k1_ec_pubkey_serialize(ctx, ptr, &pubkeylen, &pubkey, SECP256K1_EC_COMPRESSED);\n         ptr += pubkeylen;\n-        *privkeylen = ptr - privkey;\n-        assert(*privkeylen == CKey::COMPRESSED_SIZE);\n+        *seckeylen = ptr - seckey;\n+        assert(*seckeylen == CKey::COMPRESSED_SIZE);\n     } else {\n         static const unsigned char begin[] = {\n             0x30,0x82,0x01,0x13,0x02,0x01,0x01,0x04,0x20\n@@ -137,15 +137,15 @@ static int ec_privkey_export_der(const secp256k1_context *ctx, unsigned char *pr\n             0xFF,0xFF,0xFF,0xFF,0xFE,0xBA,0xAE,0xDC,0xE6,0xAF,0x48,0xA0,0x3B,0xBF,0xD2,0x5E,\n             0x8C,0xD0,0x36,0x41,0x41,0x02,0x01,0x01,0xA1,0x44,0x03,0x42,0x00\n         };\n-        unsigned char *ptr = privkey;\n+        unsigned char *ptr = seckey;\n         memcpy(ptr, begin, sizeof(begin)); ptr += sizeof(begin);\n         memcpy(ptr, key32, 32); ptr += 32;\n         memcpy(ptr, middle, sizeof(middle)); ptr += sizeof(middle);\n         pubkeylen = CPubKey::SIZE;\n         secp256k1_ec_pubkey_serialize(ctx, ptr, &pubkeylen, &pubkey, SECP256K1_EC_UNCOMPRESSED);\n         ptr += pubkeylen;\n-        *privkeylen = ptr - privkey;\n-        assert(*privkeylen == CKey::SIZE);\n+        *seckeylen = ptr - seckey;\n+        assert(*seckeylen == CKey::SIZE);\n     }\n     return 1;\n }\n@@ -165,20 +165,20 @@ void CKey::MakeNewKey(bool fCompressedIn) {\n bool CKey::Negate()\n {\n     assert(fValid);\n-    return secp256k1_ec_privkey_negate(secp256k1_context_sign, keydata.data());\n+    return secp256k1_ec_seckey_negate(secp256k1_context_sign, keydata.data());\n }\n \n CPrivKey CKey::GetPrivKey() const {\n     assert(fValid);\n-    CPrivKey privkey;\n+    CPrivKey seckey;\n     int ret;\n-    size_t privkeylen;\n-    privkey.resize(SIZE);\n-    privkeylen = SIZE;\n-    ret = ec_privkey_export_der(secp256k1_context_sign, privkey.data(), &privkeylen, begin(), fCompressed);\n+    size_t seckeylen;\n+    seckey.resize(SIZE);\n+    seckeylen = SIZE;\n+    ret = ec_seckey_export_der(secp256k1_context_sign, seckey.data(), &seckeylen, begin(), fCompressed);\n     assert(ret);\n-    privkey.resize(privkeylen);\n-    return privkey;\n+    seckey.resize(seckeylen);\n+    return seckey;\n }\n \n CPubKey CKey::GetPubKey() const {\n@@ -258,8 +258,8 @@ bool CKey::SignCompact(const uint256 &hash, std::vector<unsigned char>& vchSig)\n     return true;\n }\n \n-bool CKey::Load(const CPrivKey &privkey, const CPubKey &vchPubKey, bool fSkipCheck=false) {\n-    if (!ec_privkey_import_der(secp256k1_context_sign, (unsigned char*)begin(), privkey.data(), privkey.size()))\n+bool CKey::Load(const CPrivKey &seckey, const CPubKey &vchPubKey, bool fSkipCheck=false) {\n+    if (!ec_seckey_import_der(secp256k1_context_sign, (unsigned char*)begin(), seckey.data(), seckey.size()))\n         return false;\n     fCompressed = vchPubKey.IsCompressed();\n     fValid = true;\n@@ -284,7 +284,7 @@ bool CKey::Derive(CKey& keyChild, ChainCode &ccChild, unsigned int nChild, const\n     }\n     memcpy(ccChild.begin(), vout.data()+32, 32);\n     memcpy((unsigned char*)keyChild.begin(), begin(), 32);\n-    bool ret = secp256k1_ec_privkey_tweak_add(secp256k1_context_sign, (unsigned char*)keyChild.begin(), vout.data());\n+    bool ret = secp256k1_ec_seckey_tweak_add(secp256k1_context_sign, (unsigned char*)keyChild.begin(), vout.data());\n     keyChild.fCompressed = true;\n     keyChild.fValid = ret;\n     return ret;"
      }
    ]
  }
]