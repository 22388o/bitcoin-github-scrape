[
  {
    "sha": "e012f3cea0ca4096dd4dd59a356a973c43651912",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplMDEyZjNjZWEwY2E0MDk2ZGQ0ZGQ1OWEzNTZhOTczYzQzNjUxOTEy",
    "commit": {
      "author": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2016-06-08T08:23:25Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2016-06-08T08:28:51Z"
      },
      "message": "util: Add ParseUInt32 and ParseUInt64\n\nAdd error and range-checking parsers for unsigned 32 and 64 bit numbers.\nThe 32-bit variant is required for parsing sequence numbers from the\ncommand line in `bitcoin-tx` (see #8164 for discussion). I've thrown in\nthe 64-bit variant as a bonus, as I'm sure it will be needed at some\npoint.\n\nAlso adds tests, and updates `developer-notes.md`.",
      "tree": {
        "sha": "2d6b478372ca006337efe387ad9f6818caec56d3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2d6b478372ca006337efe387ad9f6818caec56d3"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e012f3cea0ca4096dd4dd59a356a973c43651912",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e012f3cea0ca4096dd4dd59a356a973c43651912",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e012f3cea0ca4096dd4dd59a356a973c43651912",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e012f3cea0ca4096dd4dd59a356a973c43651912/comments",
    "author": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "0f24eaf253abe7d1479777ef10f8f4e8eeb9d06e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0f24eaf253abe7d1479777ef10f8f4e8eeb9d06e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0f24eaf253abe7d1479777ef10f8f4e8eeb9d06e"
      }
    ],
    "stats": {
      "total": 113,
      "additions": 112,
      "deletions": 1
    },
    "files": [
      {
        "sha": "e40b73ffa7b93abb74249c66a7c7ddf455b469a4",
        "filename": "doc/developer-notes.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e012f3cea0ca4096dd4dd59a356a973c43651912/doc/developer-notes.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e012f3cea0ca4096dd4dd59a356a973c43651912/doc/developer-notes.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/developer-notes.md?ref=e012f3cea0ca4096dd4dd59a356a973c43651912",
        "patch": "@@ -323,7 +323,7 @@ Strings and formatting\n     buffer overflows and surprises with `\\0` characters. Also some C string manipulations\n     tend to act differently depending on platform, or even the user locale\n \n-- Use `ParseInt32`, `ParseInt64`, `ParseDouble` from `utilstrencodings.h` for number parsing\n+- Use `ParseInt32`, `ParseInt64`, `ParseUInt32`, `ParseUInt64`, `ParseDouble` from `utilstrencodings.h` for number parsing\n \n   - *Rationale*: These functions do overflow checking, and avoid pesky locale issues\n "
      },
      {
        "sha": "e467a4171d984c7b2101576fbfd9c4511ff1f559",
        "filename": "src/test/util_tests.cpp",
        "status": "modified",
        "additions": 63,
        "deletions": 0,
        "changes": 63,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e012f3cea0ca4096dd4dd59a356a973c43651912/src/test/util_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e012f3cea0ca4096dd4dd59a356a973c43651912/src/test/util_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util_tests.cpp?ref=e012f3cea0ca4096dd4dd59a356a973c43651912",
        "patch": "@@ -376,6 +376,69 @@ BOOST_AUTO_TEST_CASE(test_ParseInt64)\n     BOOST_CHECK(!ParseInt64(\"32482348723847471234\", NULL));\n }\n \n+BOOST_AUTO_TEST_CASE(test_ParseUInt32)\n+{\n+    uint32_t n;\n+    // Valid values\n+    BOOST_CHECK(ParseUInt32(\"1234\", NULL));\n+    BOOST_CHECK(ParseUInt32(\"0\", &n) && n == 0);\n+    BOOST_CHECK(ParseUInt32(\"1234\", &n) && n == 1234);\n+    BOOST_CHECK(ParseUInt32(\"01234\", &n) && n == 1234); // no octal\n+    BOOST_CHECK(ParseUInt32(\"2147483647\", &n) && n == 2147483647);\n+    BOOST_CHECK(ParseUInt32(\"2147483648\", &n) && n == (uint32_t)2147483648);\n+    BOOST_CHECK(ParseUInt32(\"4294967295\", &n) && n == (uint32_t)4294967295);\n+    // Invalid values\n+    BOOST_CHECK(!ParseUInt32(\"\", &n));\n+    BOOST_CHECK(!ParseUInt32(\" 1\", &n)); // no padding inside\n+    BOOST_CHECK(!ParseUInt32(\" -1\", &n));\n+    BOOST_CHECK(!ParseUInt32(\"1 \", &n));\n+    BOOST_CHECK(!ParseUInt32(\"1a\", &n));\n+    BOOST_CHECK(!ParseUInt32(\"aap\", &n));\n+    BOOST_CHECK(!ParseUInt32(\"0x1\", &n)); // no hex\n+    BOOST_CHECK(!ParseUInt32(\"0x1\", &n)); // no hex\n+    const char test_bytes[] = {'1', 0, '1'};\n+    std::string teststr(test_bytes, sizeof(test_bytes));\n+    BOOST_CHECK(!ParseUInt32(teststr, &n)); // no embedded NULs\n+    // Overflow and underflow\n+    BOOST_CHECK(!ParseUInt32(\"-2147483648\", &n));\n+    BOOST_CHECK(!ParseUInt32(\"4294967296\", &n));\n+    BOOST_CHECK(!ParseUInt32(\"-1234\", &n));\n+    BOOST_CHECK(!ParseUInt32(\"-32482348723847471234\", NULL));\n+    BOOST_CHECK(!ParseUInt32(\"32482348723847471234\", NULL));\n+}\n+\n+BOOST_AUTO_TEST_CASE(test_ParseUInt64)\n+{\n+    uint64_t n;\n+    // Valid values\n+    BOOST_CHECK(ParseUInt64(\"1234\", NULL));\n+    BOOST_CHECK(ParseUInt64(\"0\", &n) && n == 0LL);\n+    BOOST_CHECK(ParseUInt64(\"1234\", &n) && n == 1234LL);\n+    BOOST_CHECK(ParseUInt64(\"01234\", &n) && n == 1234LL); // no octal\n+    BOOST_CHECK(ParseUInt64(\"2147483647\", &n) && n == 2147483647LL);\n+    BOOST_CHECK(ParseUInt64(\"9223372036854775807\", &n) && n == 9223372036854775807ULL);\n+    BOOST_CHECK(ParseUInt64(\"9223372036854775808\", &n) && n == 9223372036854775808ULL);\n+    BOOST_CHECK(ParseUInt64(\"18446744073709551615\", &n) && n == 18446744073709551615ULL);\n+    // Invalid values\n+    BOOST_CHECK(!ParseUInt64(\"\", &n));\n+    BOOST_CHECK(!ParseUInt64(\" 1\", &n)); // no padding inside\n+    BOOST_CHECK(!ParseUInt64(\" -1\", &n));\n+    BOOST_CHECK(!ParseUInt64(\"1 \", &n));\n+    BOOST_CHECK(!ParseUInt64(\"1a\", &n));\n+    BOOST_CHECK(!ParseUInt64(\"aap\", &n));\n+    BOOST_CHECK(!ParseUInt64(\"0x1\", &n)); // no hex\n+    const char test_bytes[] = {'1', 0, '1'};\n+    std::string teststr(test_bytes, sizeof(test_bytes));\n+    BOOST_CHECK(!ParseUInt64(teststr, &n)); // no embedded NULs\n+    // Overflow and underflow\n+    BOOST_CHECK(!ParseUInt64(\"-9223372036854775809\", NULL));\n+    BOOST_CHECK(!ParseUInt64(\"18446744073709551616\", NULL));\n+    BOOST_CHECK(!ParseUInt64(\"-32482348723847471234\", NULL));\n+    BOOST_CHECK(!ParseUInt64(\"-2147483648\", &n));\n+    BOOST_CHECK(!ParseUInt64(\"-9223372036854775808\", &n));\n+    BOOST_CHECK(!ParseUInt64(\"-1234\", &n));\n+}\n+\n BOOST_AUTO_TEST_CASE(test_ParseDouble)\n {\n     double n;"
      },
      {
        "sha": "5ffdb3be15cf4c36359fe875423c79cd9fc387a3",
        "filename": "src/utilstrencodings.cpp",
        "status": "modified",
        "additions": 34,
        "deletions": 0,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e012f3cea0ca4096dd4dd59a356a973c43651912/src/utilstrencodings.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e012f3cea0ca4096dd4dd59a356a973c43651912/src/utilstrencodings.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/utilstrencodings.cpp?ref=e012f3cea0ca4096dd4dd59a356a973c43651912",
        "patch": "@@ -461,6 +461,40 @@ bool ParseInt64(const std::string& str, int64_t *out)\n         n <= std::numeric_limits<int64_t>::max();\n }\n \n+bool ParseUInt32(const std::string& str, uint32_t *out)\n+{\n+    if (!ParsePrechecks(str))\n+        return false;\n+    if (str.size() >= 1 && str[0] == '-') // Reject negative values, unfortunately strtoul accepts these by default if they fit in the range\n+        return false;\n+    char *endp = NULL;\n+    errno = 0; // strtoul will not set errno if valid\n+    unsigned long int n = strtoul(str.c_str(), &endp, 10);\n+    if(out) *out = (uint32_t)n;\n+    // Note that strtoul returns a *unsigned long int*, so even if it doesn't report a over/underflow\n+    // we still have to check that the returned value is within the range of an *uint32_t*. On 64-bit\n+    // platforms the size of these types may be different.\n+    return endp && *endp == 0 && !errno &&\n+        n <= std::numeric_limits<uint32_t>::max();\n+}\n+\n+bool ParseUInt64(const std::string& str, uint64_t *out)\n+{\n+    if (!ParsePrechecks(str))\n+        return false;\n+    if (str.size() >= 1 && str[0] == '-') // Reject negative values, unfortunately strtoull accepts these by default if they fit in the range\n+        return false;\n+    char *endp = NULL;\n+    errno = 0; // strtoull will not set errno if valid\n+    unsigned long long int n = strtoull(str.c_str(), &endp, 10);\n+    if(out) *out = (uint64_t)n;\n+    // Note that strtoull returns a *unsigned long long int*, so even if it doesn't report a over/underflow\n+    // we still have to check that the returned value is within the range of an *uint64_t*.\n+    return endp && *endp == 0 && !errno &&\n+        n <= std::numeric_limits<uint64_t>::max();\n+}\n+\n+\n bool ParseDouble(const std::string& str, double *out)\n {\n     if (!ParsePrechecks(str))"
      },
      {
        "sha": "5744f78c6e631864b692297e1f21db18d3b15531",
        "filename": "src/utilstrencodings.h",
        "status": "modified",
        "additions": 14,
        "deletions": 0,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e012f3cea0ca4096dd4dd59a356a973c43651912/src/utilstrencodings.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e012f3cea0ca4096dd4dd59a356a973c43651912/src/utilstrencodings.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/utilstrencodings.h?ref=e012f3cea0ca4096dd4dd59a356a973c43651912",
        "patch": "@@ -70,6 +70,20 @@ bool ParseInt32(const std::string& str, int32_t *out);\n  */\n bool ParseInt64(const std::string& str, int64_t *out);\n \n+/**\n+ * Convert decimal string to unsigned 32-bit integer with strict parse error feedback.\n+ * @returns true if the entire string could be parsed as valid integer,\n+ *   false if not the entire string could be parsed or when overflow or underflow occurred.\n+ */\n+bool ParseUInt32(const std::string& str, uint32_t *out);\n+\n+/**\n+ * Convert decimal string to unsigned 64-bit integer with strict parse error feedback.\n+ * @returns true if the entire string could be parsed as valid integer,\n+ *   false if not the entire string could be parsed or when overflow or underflow occurred.\n+ */\n+bool ParseUInt64(const std::string& str, uint64_t *out);\n+\n /**\n  * Convert string to double with strict parse error feedback.\n  * @returns true if the entire string could be parsed as valid double,"
      }
    ]
  }
]