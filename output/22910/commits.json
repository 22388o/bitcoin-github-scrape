[
  {
    "sha": "7389262e64e2e8c02f00f707cbddaf31905d2516",
    "node_id": "C_kwDOABII59oAKDczODkyNjJlNjRlMmU4YzAyZjAwZjcwN2NiZGRhZjMxOTA1ZDI1MTY",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-08-31T12:22:36Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-10-08T12:58:28Z"
      },
      "message": "[build] Add netgroup.cpp|h\n\nThese aren't used yet.",
      "tree": {
        "sha": "61c98d8513ed59fc1524bb1e772f0433831729b0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/61c98d8513ed59fc1524bb1e772f0433831729b0"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7389262e64e2e8c02f00f707cbddaf31905d2516",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7389262e64e2e8c02f00f707cbddaf31905d2516",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7389262e64e2e8c02f00f707cbddaf31905d2516",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7389262e64e2e8c02f00f707cbddaf31905d2516/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "927586990eb9bc8403a3831247847bdd3bf60423",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/927586990eb9bc8403a3831247847bdd3bf60423",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/927586990eb9bc8403a3831247847bdd3bf60423"
      }
    ],
    "stats": {
      "total": 20,
      "additions": 20,
      "deletions": 0
    },
    "files": [
      {
        "sha": "28c1ba31c708738fe6889e5ed18ee8f9b3206be0",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7389262e64e2e8c02f00f707cbddaf31905d2516/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7389262e64e2e8c02f00f707cbddaf31905d2516/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=7389262e64e2e8c02f00f707cbddaf31905d2516",
        "patch": "@@ -183,6 +183,7 @@ BITCOIN_CORE_H = \\\n   net_types.h \\\n   netaddress.h \\\n   netbase.h \\\n+  netgroup.h \\\n   netmessagemaker.h \\\n   node/blockstorage.h \\\n   node/coin.h \\\n@@ -345,6 +346,7 @@ libbitcoin_server_a_SOURCES = \\\n   mapport.cpp \\\n   miner.cpp \\\n   net.cpp \\\n+  netgroup.cpp \\\n   net_processing.cpp \\\n   node/blockstorage.cpp \\\n   node/coin.cpp \\"
      },
      {
        "sha": "17a48ad0258fc880f62202df61898f6b01666c08",
        "filename": "src/netgroup.cpp",
        "status": "added",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7389262e64e2e8c02f00f707cbddaf31905d2516/src/netgroup.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7389262e64e2e8c02f00f707cbddaf31905d2516/src/netgroup.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netgroup.cpp?ref=7389262e64e2e8c02f00f707cbddaf31905d2516",
        "patch": "@@ -0,0 +1,5 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <netgroup.h>"
      },
      {
        "sha": "1fd3470e0f6353bea8df0184654f5e8a4c951ce0",
        "filename": "src/netgroup.h",
        "status": "added",
        "additions": 13,
        "deletions": 0,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7389262e64e2e8c02f00f707cbddaf31905d2516/src/netgroup.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7389262e64e2e8c02f00f707cbddaf31905d2516/src/netgroup.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netgroup.h?ref=7389262e64e2e8c02f00f707cbddaf31905d2516",
        "patch": "@@ -0,0 +1,13 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_NETGROUP_H\n+#define BITCOIN_NETGROUP_H\n+\n+/**\n+ * Netgroup manager\n+ */\n+class NetGroupManager {};\n+\n+#endif // BITCOIN_NETGROUP_H"
      }
    ]
  },
  {
    "sha": "f23683c2b3b43dc189528d8ca2e5b575c15a591a",
    "node_id": "C_kwDOABII59oAKGYyMzY4M2MyYjNiNDNkYzE4OTUyOGQ4Y2EyZTViNTc1YzE1YTU5MWE",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-08-31T12:32:40Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-10-08T12:58:28Z"
      },
      "message": "[init] Add netgroupman to node.context\n\nThis is constructed before addrman and connman, and destructed afterwards.\n\nnetgroupman does not currently do anything, but will have functionality added in future commits.",
      "tree": {
        "sha": "ffbbb8c953c4dd70ece56c4e4691bee506dd80dc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ffbbb8c953c4dd70ece56c4e4691bee506dd80dc"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f23683c2b3b43dc189528d8ca2e5b575c15a591a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f23683c2b3b43dc189528d8ca2e5b575c15a591a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f23683c2b3b43dc189528d8ca2e5b575c15a591a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f23683c2b3b43dc189528d8ca2e5b575c15a591a/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7389262e64e2e8c02f00f707cbddaf31905d2516",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7389262e64e2e8c02f00f707cbddaf31905d2516",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7389262e64e2e8c02f00f707cbddaf31905d2516"
      }
    ],
    "stats": {
      "total": 13,
      "additions": 11,
      "deletions": 2
    },
    "files": [
      {
        "sha": "68d0a9dd8185b00a09aa5cbc8916548133252fd9",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 2,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f23683c2b3b43dc189528d8ca2e5b575c15a591a/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f23683c2b3b43dc189528d8ca2e5b575c15a591a/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=f23683c2b3b43dc189528d8ca2e5b575c15a591a",
        "patch": "@@ -34,6 +34,7 @@\n #include <net_permissions.h>\n #include <net_processing.h>\n #include <netbase.h>\n+#include <netgroup.h>\n #include <node/blockstorage.h>\n #include <node/context.h>\n #include <node/ui_interface.h>\n@@ -218,6 +219,7 @@ void Shutdown(NodeContext& node)\n     node.connman.reset();\n     node.banman.reset();\n     node.addrman.reset();\n+    node.netgroupman.reset();\n \n     if (node.mempool && node.mempool->IsLoaded() && node.args->GetBoolArg(\"-persistmempool\", DEFAULT_PERSIST_MEMPOOL)) {\n         DumpMempool(*node.mempool);\n@@ -1209,8 +1211,9 @@ bool AppInitMain(NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)\n     const bool ignores_incoming_txs{args.GetBoolArg(\"-blocksonly\", DEFAULT_BLOCKSONLY)};\n \n     {\n-        // Initialize addrman\n-        assert(!node.addrman);\n+        // Initialize netgroup manager\n+        assert(!node.netgroupman);\n+        node.netgroupman = std::make_unique<NetGroupManager>();\n \n         // Read asmap file if configured\n         std::vector<bool> asmap;\n@@ -1237,6 +1240,9 @@ bool AppInitMain(NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)\n             LogPrintf(\"Using /16 prefix for IP bucketing\\n\");\n         }\n \n+        // Initialize addrman\n+        assert(!node.addrman);\n+\n         uiInterface.InitMessage(_(\"Loading P2P addresses\u2026\").translated);\n         if (const auto error{LoadAddrman(asmap, args, node.addrman)}) {\n             return InitError(*error);"
      },
      {
        "sha": "a4bc1355b2ea150a30d9610ab0b7f1376c61214c",
        "filename": "src/node/context.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f23683c2b3b43dc189528d8ca2e5b575c15a591a/src/node/context.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f23683c2b3b43dc189528d8ca2e5b575c15a591a/src/node/context.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/context.cpp?ref=f23683c2b3b43dc189528d8ca2e5b575c15a591a",
        "patch": "@@ -9,6 +9,7 @@\n #include <interfaces/chain.h>\n #include <net.h>\n #include <net_processing.h>\n+#include <netgroup.h>\n #include <policy/fees.h>\n #include <scheduler.h>\n #include <txmempool.h>"
      },
      {
        "sha": "57679bfd7326b28bb75f71631c791323690e69c8",
        "filename": "src/node/context.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f23683c2b3b43dc189528d8ca2e5b575c15a591a/src/node/context.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f23683c2b3b43dc189528d8ca2e5b575c15a591a/src/node/context.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/context.h?ref=f23683c2b3b43dc189528d8ca2e5b575c15a591a",
        "patch": "@@ -18,6 +18,7 @@ class CConnman;\n class CScheduler;\n class CTxMemPool;\n class ChainstateManager;\n+class NetGroupManager;\n class PeerManager;\n namespace interfaces {\n class Chain;\n@@ -42,6 +43,7 @@ struct NodeContext {\n     std::unique_ptr<AddrMan> addrman;\n     std::unique_ptr<CConnman> connman;\n     std::unique_ptr<CTxMemPool> mempool;\n+    std::unique_ptr<const NetGroupManager> netgroupman;\n     std::unique_ptr<CBlockPolicyEstimator> fee_estimator;\n     std::unique_ptr<PeerManager> peerman;\n     std::unique_ptr<ChainstateManager> chainman;"
      }
    ]
  },
  {
    "sha": "2f6fc90cedab4f9166c7469c9e79b24eadd1e030",
    "node_id": "C_kwDOABII59oAKDJmNmZjOTBjZWRhYjRmOTE2NmM3NDY5YzllNzliMjRlYWRkMWUwMzA",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-08-31T17:40:18Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-10-08T13:07:30Z"
      },
      "message": "[net] Move asmap into NetGroupManager",
      "tree": {
        "sha": "9d7430b438723f86c3415cd7683f05b17bb44245",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9d7430b438723f86c3415cd7683f05b17bb44245"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2f6fc90cedab4f9166c7469c9e79b24eadd1e030",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2f6fc90cedab4f9166c7469c9e79b24eadd1e030",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2f6fc90cedab4f9166c7469c9e79b24eadd1e030",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2f6fc90cedab4f9166c7469c9e79b24eadd1e030/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f23683c2b3b43dc189528d8ca2e5b575c15a591a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f23683c2b3b43dc189528d8ca2e5b575c15a591a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f23683c2b3b43dc189528d8ca2e5b575c15a591a"
      }
    ],
    "stats": {
      "total": 327,
      "additions": 189,
      "deletions": 138
    },
    "files": [
      {
        "sha": "428f1b0504df1270040b92e840aa9a7f4171814f",
        "filename": "src/addrdb.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2f6fc90cedab4f9166c7469c9e79b24eadd1e030/src/addrdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2f6fc90cedab4f9166c7469c9e79b24eadd1e030/src/addrdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrdb.cpp?ref=2f6fc90cedab4f9166c7469c9e79b24eadd1e030",
        "patch": "@@ -12,6 +12,7 @@\n #include <hash.h>\n #include <logging/timer.h>\n #include <netbase.h>\n+#include <netgroup.h>\n #include <random.h>\n #include <streams.h>\n #include <tinyformat.h>\n@@ -181,10 +182,10 @@ void ReadFromStream(AddrMan& addr, CDataStream& ssPeers)\n     DeserializeDB(ssPeers, addr, false);\n }\n \n-std::optional<bilingual_str> LoadAddrman(const std::vector<bool>& asmap, const ArgsManager& args, std::unique_ptr<AddrMan>& addrman)\n+std::optional<bilingual_str> LoadAddrman(const NetGroupManager& netgroupman, const ArgsManager& args, std::unique_ptr<AddrMan>& addrman)\n {\n     auto check_addrman = std::clamp<int32_t>(args.GetIntArg(\"-checkaddrman\", DEFAULT_ADDRMAN_CONSISTENCY_CHECKS), 0, 1000000);\n-    addrman = std::make_unique<AddrMan>(asmap, /* deterministic */ false, /* consistency_check_ratio */ check_addrman);\n+    addrman = std::make_unique<AddrMan>(netgroupman, /* deterministic */ false, /* consistency_check_ratio */ check_addrman);\n \n     int64_t nStart = GetTimeMillis();\n     const auto path_addr{args.GetDataDirNet() / \"peers.dat\"};\n@@ -193,7 +194,7 @@ std::optional<bilingual_str> LoadAddrman(const std::vector<bool>& asmap, const A\n         LogPrintf(\"Loaded %i addresses from peers.dat  %dms\\n\", addrman->size(), GetTimeMillis() - nStart);\n     } catch (const DbNotFoundError&) {\n         // Addrman can be in an inconsistent state after failure, reset it\n-        addrman = std::make_unique<AddrMan>(asmap, /* deterministic */ false, /* consistency_check_ratio */ check_addrman);\n+        addrman = std::make_unique<AddrMan>(netgroupman, /* deterministic */ false, /* consistency_check_ratio */ check_addrman);\n         LogPrintf(\"Creating peers.dat because the file was not found (%s)\\n\", path_addr);\n         DumpPeerAddresses(args, *addrman);\n     } catch (const std::exception& e) {"
      },
      {
        "sha": "fb32cb86f0973125dbbcde1ec4ca6198781e931a",
        "filename": "src/addrdb.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2f6fc90cedab4f9166c7469c9e79b24eadd1e030/src/addrdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2f6fc90cedab4f9166c7469c9e79b24eadd1e030/src/addrdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrdb.h?ref=2f6fc90cedab4f9166c7469c9e79b24eadd1e030",
        "patch": "@@ -17,6 +17,7 @@ class ArgsManager;\n class AddrMan;\n class CAddress;\n class CDataStream;\n+class NetGroupManager;\n struct bilingual_str;\n \n bool DumpPeerAddresses(const ArgsManager& args, const AddrMan& addr);\n@@ -48,7 +49,7 @@ class CBanDB\n };\n \n /** Returns an error string on failure */\n-std::optional<bilingual_str> LoadAddrman(const std::vector<bool>& asmap, const ArgsManager& args, std::unique_ptr<AddrMan>& addrman);\n+std::optional<bilingual_str> LoadAddrman(const NetGroupManager& netgroupman, const ArgsManager& args, std::unique_ptr<AddrMan>& addrman);\n \n /**\n  * Dump the anchor IP address database (anchors.dat)"
      },
      {
        "sha": "30000b9c254448bb30a50223aca9dbdda66b320c",
        "filename": "src/addrman.cpp",
        "status": "modified",
        "additions": 18,
        "deletions": 28,
        "changes": 46,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2f6fc90cedab4f9166c7469c9e79b24eadd1e030/src/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2f6fc90cedab4f9166c7469c9e79b24eadd1e030/src/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.cpp?ref=2f6fc90cedab4f9166c7469c9e79b24eadd1e030",
        "patch": "@@ -103,11 +103,11 @@ double AddrInfo::GetChance(int64_t nNow) const\n     return fChance;\n }\n \n-AddrManImpl::AddrManImpl(std::vector<bool>&& asmap, bool deterministic, int32_t consistency_check_ratio)\n+AddrManImpl::AddrManImpl(const NetGroupManager& netgroupman, bool deterministic, int32_t consistency_check_ratio)\n     : insecure_rand{deterministic}\n     , nKey{deterministic ? uint256{1} : insecure_rand.rand256()}\n     , m_consistency_check_ratio{consistency_check_ratio}\n-    , m_asmap{std::move(asmap)}\n+    , m_netgroupman{netgroupman}\n {\n     for (auto& bucket : vvNew) {\n         for (auto& entry : bucket) {\n@@ -223,8 +223,8 @@ void AddrManImpl::Serialize(Stream& s_) const\n     // Store asmap checksum after bucket entries so that it\n     // can be ignored by older clients for backward compatibility.\n     uint256 asmap_checksum;\n-    if (m_asmap.size() != 0) {\n-        asmap_checksum = SerializeHash(m_asmap);\n+    if (m_netgroupman.GetAsmap().size() != 0) {\n+        asmap_checksum = SerializeHash(m_netgroupman.GetAsmap());\n     }\n     s << asmap_checksum;\n }\n@@ -296,7 +296,7 @@ void AddrManImpl::Unserialize(Stream& s_)\n     for (int n = 0; n < nTried; n++) {\n         AddrInfo info;\n         s >> info;\n-        int nKBucket = info.GetTriedBucket(nKey, m_asmap);\n+        int nKBucket = info.GetTriedBucket(nKey, m_netgroupman.GetAsmap());\n         int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);\n         if (info.IsValid()\n                 && vvTried[nKBucket][nKBucketPos] == -1) {\n@@ -334,8 +334,8 @@ void AddrManImpl::Unserialize(Stream& s_)\n     // to restore the entries to the buckets/positions they were in before\n     // serialization.\n     uint256 supplied_asmap_checksum;\n-    if (m_asmap.size() != 0) {\n-        supplied_asmap_checksum = SerializeHash(m_asmap);\n+    if (m_netgroupman.GetAsmap().size() != 0) {\n+        supplied_asmap_checksum = SerializeHash(m_netgroupman.GetAsmap());\n     }\n     uint256 serialized_asmap_checksum;\n     if (format >= Format::V2_ASMAP) {\n@@ -369,7 +369,7 @@ void AddrManImpl::Unserialize(Stream& s_)\n         } else {\n             // In case the new table data cannot be used (bucket count wrong or new asmap),\n             // try to give them a reference based on their primary source address.\n-            bucket = info.GetNewBucket(nKey, m_asmap);\n+            bucket = info.GetNewBucket(nKey, m_netgroupman.GetAsmap());\n             bucket_position = info.GetBucketPosition(nKey, true, bucket);\n             if (vvNew[bucket][bucket_position] == -1) {\n                 vvNew[bucket][bucket_position] = entry_index;\n@@ -492,7 +492,7 @@ void AddrManImpl::MakeTried(AddrInfo& info, int nId)\n     AssertLockHeld(cs);\n \n     // remove the entry from all new buckets\n-    const int start_bucket{info.GetNewBucket(nKey, m_asmap)};\n+    const int start_bucket{info.GetNewBucket(nKey, m_netgroupman.GetAsmap())};\n     for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {\n         const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};\n         const int pos{info.GetBucketPosition(nKey, true, bucket)};\n@@ -507,7 +507,7 @@ void AddrManImpl::MakeTried(AddrInfo& info, int nId)\n     assert(info.nRefCount == 0);\n \n     // which tried bucket to move the entry to\n-    int nKBucket = info.GetTriedBucket(nKey, m_asmap);\n+    int nKBucket = info.GetTriedBucket(nKey, m_netgroupman.GetAsmap());\n     int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);\n \n     // first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).\n@@ -523,7 +523,7 @@ void AddrManImpl::MakeTried(AddrInfo& info, int nId)\n         nTried--;\n \n         // find which new bucket it belongs to\n-        int nUBucket = infoOld.GetNewBucket(nKey, m_asmap);\n+        int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman.GetAsmap());\n         int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);\n         ClearNew(nUBucket, nUBucketPos);\n         assert(vvNew[nUBucket][nUBucketPos] == -1);\n@@ -577,7 +577,7 @@ void AddrManImpl::Good_(const CService& addr, bool test_before_evict, int64_t nT\n     }\n \n     // which tried bucket to move the entry to\n-    int tried_bucket = info.GetTriedBucket(nKey, m_asmap);\n+    int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman.GetAsmap());\n     int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);\n \n     // Will moving this address into tried evict another entry?\n@@ -647,7 +647,7 @@ bool AddrManImpl::Add_(const CAddress& addr, const CNetAddr& source, int64_t nTi\n         fNew = true;\n     }\n \n-    int nUBucket = pinfo->GetNewBucket(nKey, source, m_asmap);\n+    int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman.GetAsmap());\n     int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);\n     if (vvNew[nUBucket][nUBucketPos] != nId) {\n         bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;\n@@ -842,7 +842,7 @@ void AddrManImpl::ResolveCollisions_()\n             AddrInfo& info_new = mapInfo[id_new];\n \n             // Which tried bucket to move the entry to.\n-            int tried_bucket = info_new.GetTriedBucket(nKey, m_asmap);\n+            int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman.GetAsmap());\n             int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);\n             if (!info_new.IsValid()) { // id_new may no longer map to a valid address\n                 erase_collision = true;\n@@ -908,7 +908,7 @@ std::pair<CAddress, int64_t> AddrManImpl::SelectTriedCollision_()\n     const AddrInfo& newInfo = mapInfo[id_new];\n \n     // which tried bucket to move the entry to\n-    int tried_bucket = newInfo.GetTriedBucket(nKey, m_asmap);\n+    int tried_bucket = newInfo.GetTriedBucket(nKey, m_netgroupman.GetAsmap());\n     int tried_bucket_pos = newInfo.GetBucketPosition(nKey, false, tried_bucket);\n \n     const AddrInfo& info_old = mapInfo[vvTried[tried_bucket][tried_bucket_pos]];\n@@ -981,7 +981,7 @@ int AddrManImpl::ForceCheckAddrman() const\n                 if (!setTried.count(vvTried[n][i]))\n                     return -11;\n                 const auto it{mapInfo.find(vvTried[n][i])};\n-                if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_asmap) != n) {\n+                if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman.GetAsmap()) != n) {\n                     return -17;\n                 }\n                 if (it->second.GetBucketPosition(nKey, false, n) != i) {\n@@ -1105,13 +1105,8 @@ void AddrManImpl::SetServices(const CService& addr, ServiceFlags nServices)\n     Check();\n }\n \n-const std::vector<bool>& AddrManImpl::GetAsmap() const\n-{\n-    return m_asmap;\n-}\n-\n-AddrMan::AddrMan(std::vector<bool> asmap, bool deterministic, int32_t consistency_check_ratio)\n-    : m_impl(std::make_unique<AddrManImpl>(std::move(asmap), deterministic, consistency_check_ratio)) {}\n+AddrMan::AddrMan(const NetGroupManager& netgroupman, bool deterministic, int32_t consistency_check_ratio)\n+    : m_impl(std::make_unique<AddrManImpl>(netgroupman, deterministic, consistency_check_ratio)) {}\n \n AddrMan::~AddrMan() = default;\n \n@@ -1185,8 +1180,3 @@ void AddrMan::SetServices(const CService& addr, ServiceFlags nServices)\n {\n     m_impl->SetServices(addr, nServices);\n }\n-\n-const std::vector<bool>& AddrMan::GetAsmap() const\n-{\n-    return m_impl->GetAsmap();\n-}"
      },
      {
        "sha": "084d1c9253ac0118c8044516e2c698a1507e97e5",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2f6fc90cedab4f9166c7469c9e79b24eadd1e030/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2f6fc90cedab4f9166c7469c9e79b24eadd1e030/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=2f6fc90cedab4f9166c7469c9e79b24eadd1e030",
        "patch": "@@ -7,6 +7,7 @@\n #define BITCOIN_ADDRMAN_H\n \n #include <netaddress.h>\n+#include <netgroup.h>\n #include <protocol.h>\n #include <streams.h>\n #include <timedata.h>\n@@ -56,7 +57,7 @@ class AddrMan\n     const std::unique_ptr<AddrManImpl> m_impl;\n \n public:\n-    explicit AddrMan(std::vector<bool> asmap, bool deterministic, int32_t consistency_check_ratio);\n+    explicit AddrMan(const NetGroupManager& netgroupman, bool deterministic, int32_t consistency_check_ratio);\n \n     ~AddrMan();\n \n@@ -126,8 +127,6 @@ class AddrMan\n     //! Update an entry's service bits.\n     void SetServices(const CService& addr, ServiceFlags nServices);\n \n-    const std::vector<bool>& GetAsmap() const;\n-\n     friend class AddrManTest;\n     friend class AddrManDeterministic;\n };"
      },
      {
        "sha": "ec9fceb0e20ddade92c0afc2cf9f3a04d1c00f18",
        "filename": "src/addrman_impl.h",
        "status": "modified",
        "additions": 3,
        "deletions": 18,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2f6fc90cedab4f9166c7469c9e79b24eadd1e030/src/addrman_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2f6fc90cedab4f9166c7469c9e79b24eadd1e030/src/addrman_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman_impl.h?ref=2f6fc90cedab4f9166c7469c9e79b24eadd1e030",
        "patch": "@@ -99,7 +99,7 @@ class AddrInfo : public CAddress\n class AddrManImpl\n {\n public:\n-    AddrManImpl(std::vector<bool>&& asmap, bool deterministic, int32_t consistency_check_ratio);\n+    AddrManImpl(const NetGroupManager& netgroupman, bool deterministic, int32_t consistency_check_ratio);\n \n     ~AddrManImpl();\n \n@@ -136,8 +136,6 @@ class AddrManImpl\n     void SetServices(const CService& addr, ServiceFlags nServices)\n         EXCLUSIVE_LOCKS_REQUIRED(!cs);\n \n-    const std::vector<bool>& GetAsmap() const;\n-\n     friend class AddrManTest;\n     friend class AddrManDeterministic;\n \n@@ -208,21 +206,8 @@ class AddrManImpl\n     /** Perform consistency checks every m_consistency_check_ratio operations (if non-zero). */\n     const int32_t m_consistency_check_ratio;\n \n-    // Compressed IP->ASN mapping, loaded from a file when a node starts.\n-    // Should be always empty if no file was provided.\n-    // This mapping is then used for bucketing nodes in Addrman.\n-    //\n-    // If asmap is provided, nodes will be bucketed by\n-    // AS they belong to, in order to make impossible for a node\n-    // to connect to several nodes hosted in a single AS.\n-    // This is done in response to Erebus attack, but also to generally\n-    // diversify the connections every node creates,\n-    // especially useful when a large fraction of nodes\n-    // operate under a couple of cloud providers.\n-    //\n-    // If a new asmap was provided, the existing records\n-    // would be re-bucketed accordingly.\n-    const std::vector<bool> m_asmap;\n+    /** Reference to the netgroup manager. netgroupman must be constructed before addrman and destructed after. */\n+    const NetGroupManager& m_netgroupman;\n \n     //! Find an entry.\n     AddrInfo* Find(const CNetAddr& addr, int* pnId = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs);"
      },
      {
        "sha": "6a15c6281193461f0f753907c403f6c5e92d01d6",
        "filename": "src/bench/addrman.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 4,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2f6fc90cedab4f9166c7469c9e79b24eadd1e030/src/bench/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2f6fc90cedab4f9166c7469c9e79b24eadd1e030/src/bench/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/addrman.cpp?ref=2f6fc90cedab4f9166c7469c9e79b24eadd1e030",
        "patch": "@@ -4,6 +4,7 @@\n \n #include <addrman.h>\n #include <bench/bench.h>\n+#include <netgroup.h>\n #include <random.h>\n #include <util/check.h>\n #include <util/time.h>\n@@ -19,6 +20,13 @@ static constexpr size_t NUM_ADDRESSES_PER_SOURCE = 256;\n static std::vector<CAddress> g_sources;\n static std::vector<std::vector<CAddress>> g_addresses;\n \n+static NetGroupManager g_netgroupman{std::vector<bool>()};\n+\n+static AddrMan CreateAddrMan()\n+{\n+    return AddrMan{g_netgroupman, /* deterministic */ false, /* consistency_check_ratio */ 0};\n+}\n+\n static void CreateAddresses()\n {\n     if (g_sources.size() > 0) { // already created\n@@ -74,14 +82,14 @@ static void AddrManAdd(benchmark::Bench& bench)\n     CreateAddresses();\n \n     bench.run([&] {\n-        AddrMan addrman{/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0};\n+        AddrMan addrman = CreateAddrMan();\n         AddAddressesToAddrMan(addrman);\n     });\n }\n \n static void AddrManSelect(benchmark::Bench& bench)\n {\n-    AddrMan addrman(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n+    AddrMan addrman = CreateAddrMan();\n \n     FillAddrMan(addrman);\n \n@@ -93,7 +101,7 @@ static void AddrManSelect(benchmark::Bench& bench)\n \n static void AddrManGetAddr(benchmark::Bench& bench)\n {\n-    AddrMan addrman(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n+    AddrMan addrman = CreateAddrMan();\n \n     FillAddrMan(addrman);\n \n@@ -122,7 +130,7 @@ static void AddrManAddThenGood(benchmark::Bench& bench)\n         //\n         // This has some overhead (exactly the result of AddrManAdd benchmark), but that overhead is constant so improvements in\n         // AddrMan::Good() will still be noticeable.\n-        AddrMan addrman(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n+        AddrMan addrman(g_netgroupman, /* deterministic */ false, /* consistency_check_ratio */ 0);\n         AddAddressesToAddrMan(addrman);\n \n         markSomeAsGood(addrman);"
      },
      {
        "sha": "b3ab84d88369f1f675825d787422eeb4419f3ce2",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 3,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2f6fc90cedab4f9166c7469c9e79b24eadd1e030/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2f6fc90cedab4f9166c7469c9e79b24eadd1e030/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=2f6fc90cedab4f9166c7469c9e79b24eadd1e030",
        "patch": "@@ -1213,7 +1213,6 @@ bool AppInitMain(NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)\n     {\n         // Initialize netgroup manager\n         assert(!node.netgroupman);\n-        node.netgroupman = std::make_unique<NetGroupManager>();\n \n         // Read asmap file if configured\n         std::vector<bool> asmap;\n@@ -1240,19 +1239,23 @@ bool AppInitMain(NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)\n             LogPrintf(\"Using /16 prefix for IP bucketing\\n\");\n         }\n \n+        node.netgroupman = std::make_unique<NetGroupManager>(std::move(asmap));\n+\n         // Initialize addrman\n         assert(!node.addrman);\n \n         uiInterface.InitMessage(_(\"Loading P2P addresses\u2026\").translated);\n-        if (const auto error{LoadAddrman(asmap, args, node.addrman)}) {\n+        if (const auto error{LoadAddrman(*node.netgroupman, args, node.addrman)}) {\n             return InitError(*error);\n         }\n     }\n \n     assert(!node.banman);\n     node.banman = std::make_unique<BanMan>(gArgs.GetDataDirNet() / \"banlist\", &uiInterface, args.GetIntArg(\"-bantime\", DEFAULT_MISBEHAVING_BANTIME));\n     assert(!node.connman);\n-    node.connman = std::make_unique<CConnman>(GetRand(std::numeric_limits<uint64_t>::max()), GetRand(std::numeric_limits<uint64_t>::max()), *node.addrman, args.GetBoolArg(\"-networkactive\", true));\n+    node.connman = std::make_unique<CConnman>(GetRand(std::numeric_limits<uint64_t>::max()),\n+                                              GetRand(std::numeric_limits<uint64_t>::max()),\n+                                              *node.addrman, *node.netgroupman, args.GetBoolArg(\"-networkactive\", true));\n \n     assert(!node.fee_estimator);\n     // Don't initialize fee estimation with old data if we don't relay transactions,"
      },
      {
        "sha": "c3b32debaeb89d42c17f9725dadc79201d0ecd94",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 7,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2f6fc90cedab4f9166c7469c9e79b24eadd1e030/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2f6fc90cedab4f9166c7469c9e79b24eadd1e030/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=2f6fc90cedab4f9166c7469c9e79b24eadd1e030",
        "patch": "@@ -1923,7 +1923,7 @@ void CConnman::ThreadOpenConnections(const std::vector<std::string> connect)\n                     case ConnectionType::BLOCK_RELAY:\n                     case ConnectionType::ADDR_FETCH:\n                     case ConnectionType::FEELER:\n-                        setConnected.insert(pnode->addr.GetGroup(addrman.GetAsmap()));\n+                        setConnected.insert(pnode->addr.GetGroup(m_netgroupman.GetAsmap()));\n                 } // no default case, so the compiler can warn about missing cases\n             }\n         }\n@@ -1997,7 +1997,7 @@ void CConnman::ThreadOpenConnections(const std::vector<std::string> connect)\n                 m_anchors.pop_back();\n                 if (!addr.IsValid() || IsLocal(addr) || !IsReachable(addr) ||\n                     !HasAllDesirableServiceFlags(addr.nServices) ||\n-                    setConnected.count(addr.GetGroup(addrman.GetAsmap()))) continue;\n+                    setConnected.count(addr.GetGroup(m_netgroupman.GetAsmap()))) continue;\n                 addrConnect = addr;\n                 LogPrint(BCLog::NET, \"Trying to make an anchor connection to %s\\n\", addrConnect.ToString());\n                 break;\n@@ -2038,7 +2038,7 @@ void CConnman::ThreadOpenConnections(const std::vector<std::string> connect)\n             }\n \n             // Require outbound connections, other than feelers, to be to distinct network groups\n-            if (!fFeeler && setConnected.count(addr.GetGroup(addrman.GetAsmap()))) {\n+            if (!fFeeler && setConnected.count(addr.GetGroup(m_netgroupman.GetAsmap()))) {\n                 break;\n             }\n \n@@ -2444,8 +2444,12 @@ void CConnman::SetNetworkActive(bool active)\n     }\n }\n \n-CConnman::CConnman(uint64_t nSeed0In, uint64_t nSeed1In, AddrMan& addrman_in, bool network_active)\n-    : addrman(addrman_in), nSeed0(nSeed0In), nSeed1(nSeed1In)\n+CConnman::CConnman(uint64_t nSeed0In, uint64_t nSeed1In, AddrMan& addrman_in,\n+                   const NetGroupManager& netgroupman, bool network_active)\n+    : addrman(addrman_in)\n+    , m_netgroupman{netgroupman}\n+    , nSeed0(nSeed0In)\n+    , nSeed1(nSeed1In)\n {\n     SetTryNewOutboundPeer(false);\n \n@@ -2810,7 +2814,7 @@ void CConnman::GetNodeStats(std::vector<CNodeStats>& vstats) const\n     for (CNode* pnode : vNodes) {\n         vstats.emplace_back();\n         pnode->CopyStats(vstats.back());\n-        vstats.back().m_mapped_as = pnode->addr.GetMappedAS(addrman.GetAsmap());\n+        vstats.back().m_mapped_as = pnode->addr.GetMappedAS(m_netgroupman.GetAsmap());\n     }\n }\n \n@@ -3073,7 +3077,7 @@ CSipHasher CConnman::GetDeterministicRandomizer(uint64_t id) const\n \n uint64_t CConnman::CalculateKeyedNetGroup(const CAddress& ad) const\n {\n-    std::vector<unsigned char> vchNetGroup(ad.GetGroup(addrman.GetAsmap()));\n+    std::vector<unsigned char> vchNetGroup(ad.GetGroup(m_netgroupman.GetAsmap()));\n \n     return GetDeterministicRandomizer(RANDOMIZER_ID_NETGROUP).Write(vchNetGroup.data(), vchNetGroup.size()).Finalize();\n }"
      },
      {
        "sha": "d91c311822339394d84f61f1a0c10598ee34d8dd",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 5,
        "deletions": 1,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2f6fc90cedab4f9166c7469c9e79b24eadd1e030/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2f6fc90cedab4f9166c7469c9e79b24eadd1e030/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=2f6fc90cedab4f9166c7469c9e79b24eadd1e030",
        "patch": "@@ -17,6 +17,7 @@\n #include <net_permissions.h>\n #include <netaddress.h>\n #include <netbase.h>\n+#include <netgroup.h>\n #include <policy/feerate.h>\n #include <protocol.h>\n #include <random.h>\n@@ -797,7 +798,9 @@ class CConnman\n         m_onion_binds = connOptions.onion_binds;\n     }\n \n-    CConnman(uint64_t seed0, uint64_t seed1, AddrMan& addrman, bool network_active = true);\n+    CConnman(uint64_t seed0, uint64_t seed1, AddrMan& addrman, const NetGroupManager& netgroupman,\n+             bool network_active = true);\n+\n     ~CConnman();\n     bool Start(CScheduler& scheduler, const Options& options);\n \n@@ -1050,6 +1053,7 @@ class CConnman\n     std::atomic<bool> fNetworkActive{true};\n     bool fAddressesInitialized{false};\n     AddrMan& addrman;\n+    const NetGroupManager& m_netgroupman;\n     std::deque<std::string> m_addr_fetches GUARDED_BY(m_addr_fetches_mutex);\n     RecursiveMutex m_addr_fetches_mutex;\n     std::vector<std::string> vAddedNodes GUARDED_BY(cs_vAddedNodes);"
      },
      {
        "sha": "fcf46bb2bb7f845acbc32d93bfd8c1543d4739d7",
        "filename": "src/netgroup.h",
        "status": "modified",
        "additions": 33,
        "deletions": 1,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2f6fc90cedab4f9166c7469c9e79b24eadd1e030/src/netgroup.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2f6fc90cedab4f9166c7469c9e79b24eadd1e030/src/netgroup.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netgroup.h?ref=2f6fc90cedab4f9166c7469c9e79b24eadd1e030",
        "patch": "@@ -5,9 +5,41 @@\n #ifndef BITCOIN_NETGROUP_H\n #define BITCOIN_NETGROUP_H\n \n+#include <vector>\n+\n /**\n  * Netgroup manager\n  */\n-class NetGroupManager {};\n+class NetGroupManager {\n+public:\n+    explicit NetGroupManager(std::vector<bool> asmap)\n+        : m_asmap{std::move(asmap)}\n+    {}\n+\n+    /* Get a reference to (const) asmap. May be held as long as NetGroupManager\n+     * exists, since the data is const. */\n+    const std::vector<bool>& GetAsmap() const { return m_asmap; }\n+\n+private:\n+    /** Compressed IP->ASN mapping, loaded from a file when a node starts.\n+     *\n+     * This mapping is then used for bucketing nodes in Addrman and for\n+     * ensuring we connect to a diverse set of peers in Connman. The map is\n+     * empty if no file was provided.\n+     *\n+     * If asmap is provided, nodes will be bucketed by AS they belong to, in\n+     * order to make impossible for a node to connect to several nodes hosted\n+     * in a single AS. This is done in response to Erebus attack, but also to\n+     * generally diversify the connections every node creates, especially\n+     * useful when a large fraction of nodes operate under a couple of cloud\n+     * providers.\n+     *\n+     * If a new asmap is provided, the existing addrman records are\n+     * re-bucketed.\n+     *\n+     * This is initialized in the constructor, const, and therefore is\n+     * thread-safe. */\n+    const std::vector<bool> m_asmap;\n+};\n \n #endif // BITCOIN_NETGROUP_H"
      },
      {
        "sha": "d0a473ca9ca957c1d857cbb57bab3747ae6374ae",
        "filename": "src/test/addrman_tests.cpp",
        "status": "modified",
        "additions": 47,
        "deletions": 43,
        "changes": 90,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2f6fc90cedab4f9166c7469c9e79b24eadd1e030/src/test/addrman_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2f6fc90cedab4f9166c7469c9e79b24eadd1e030/src/test/addrman_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/addrman_tests.cpp?ref=2f6fc90cedab4f9166c7469c9e79b24eadd1e030",
        "patch": "@@ -27,14 +27,18 @@ class AddrManSerializationMock : public AddrMan\n public:\n     virtual void Serialize(CDataStream& s) const = 0;\n \n-    AddrManSerializationMock()\n-        : AddrMan(/* asmap */ std::vector<bool>(), /* deterministic */ true, /* consistency_check_ratio */ 100)\n+    AddrManSerializationMock(const NetGroupManager& netgroupman)\n+        : AddrMan(netgroupman, /* deterministic */ true, /* consistency_check_ratio */ 100)\n     {}\n };\n \n class AddrManUncorrupted : public AddrManSerializationMock\n {\n public:\n+    AddrManUncorrupted(const NetGroupManager& netgroupman)\n+        : AddrManSerializationMock(netgroupman)\n+    {}\n+\n     void Serialize(CDataStream& s) const override\n     {\n         AddrMan::Serialize(s);\n@@ -44,6 +48,10 @@ class AddrManUncorrupted : public AddrManSerializationMock\n class AddrManCorrupted : public AddrManSerializationMock\n {\n public:\n+    AddrManCorrupted(const NetGroupManager& netgroupman)\n+        : AddrManSerializationMock(netgroupman)\n+    {}\n+\n     void Serialize(CDataStream& s) const override\n     {\n         // Produces corrupt output that claims addrman has 20 addrs when it only has one addr.\n@@ -79,15 +87,10 @@ static CDataStream AddrmanToStream(const AddrManSerializationMock& _addrman)\n \n class AddrManTest : public AddrMan\n {\n-private:\n-    bool deterministic;\n public:\n-    explicit AddrManTest(bool makeDeterministic = true,\n-                         std::vector<bool> asmap = std::vector<bool>())\n-        : AddrMan(asmap, makeDeterministic, /* consistency_check_ratio */ 100)\n-    {\n-        deterministic = makeDeterministic;\n-    }\n+    explicit AddrManTest(const NetGroupManager& netgroupman)\n+        : AddrMan(netgroupman, /* deterministic */ true, /* consistency_check_ratio */ 100)\n+    {}\n \n     AddrInfo* Find(const CNetAddr& addr, int* pnId = nullptr)\n     {\n@@ -162,11 +165,11 @@ static std::vector<bool> FromBytes(const unsigned char* source, int vector_size)\n }\n \n \n-BOOST_FIXTURE_TEST_SUITE(addrman_tests, BasicTestingSetup)\n+BOOST_FIXTURE_TEST_SUITE(addrman_tests, TestingSetup)\n \n BOOST_AUTO_TEST_CASE(addrman_simple)\n {\n-    auto addrman = std::make_unique<AddrManTest>();\n+    auto addrman = std::make_unique<AddrManTest>(*m_node.netgroupman);\n \n     CNetAddr source = ResolveIP(\"252.2.2.2\");\n \n@@ -200,7 +203,7 @@ BOOST_AUTO_TEST_CASE(addrman_simple)\n     BOOST_CHECK(addrman->size() >= 1);\n \n     // Test: reset addrman and test AddrMan::Add multiple addresses works as expected\n-    addrman = std::make_unique<AddrManTest>();\n+    addrman = std::make_unique<AddrManTest>(*m_node.netgroupman);\n     std::vector<CAddress> vAddr;\n     vAddr.push_back(CAddress(ResolveService(\"250.1.1.3\", 8333), NODE_NONE));\n     vAddr.push_back(CAddress(ResolveService(\"250.1.1.4\", 8333), NODE_NONE));\n@@ -210,7 +213,7 @@ BOOST_AUTO_TEST_CASE(addrman_simple)\n \n BOOST_AUTO_TEST_CASE(addrman_ports)\n {\n-    AddrManTest addrman;\n+    AddrManTest addrman(*m_node.netgroupman);\n \n     CNetAddr source = ResolveIP(\"252.2.2.2\");\n \n@@ -239,7 +242,7 @@ BOOST_AUTO_TEST_CASE(addrman_ports)\n \n BOOST_AUTO_TEST_CASE(addrman_select)\n {\n-    AddrManTest addrman;\n+    AddrManTest addrman(*m_node.netgroupman);\n \n     CNetAddr source = ResolveIP(\"252.2.2.2\");\n \n@@ -298,7 +301,7 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n \n BOOST_AUTO_TEST_CASE(addrman_new_collisions)\n {\n-    AddrManTest addrman;\n+    AddrManTest addrman(*m_node.netgroupman);\n \n     CNetAddr source = ResolveIP(\"252.2.2.2\");\n \n@@ -327,7 +330,7 @@ BOOST_AUTO_TEST_CASE(addrman_new_collisions)\n \n BOOST_AUTO_TEST_CASE(addrman_tried_collisions)\n {\n-    AddrManTest addrman;\n+    AddrManTest addrman(*m_node.netgroupman);\n \n     CNetAddr source = ResolveIP(\"252.2.2.2\");\n \n@@ -357,7 +360,7 @@ BOOST_AUTO_TEST_CASE(addrman_tried_collisions)\n \n BOOST_AUTO_TEST_CASE(addrman_find)\n {\n-    AddrManTest addrman;\n+    AddrManTest addrman(*m_node.netgroupman);\n \n     BOOST_CHECK_EQUAL(addrman.size(), 0U);\n \n@@ -390,7 +393,7 @@ BOOST_AUTO_TEST_CASE(addrman_find)\n \n BOOST_AUTO_TEST_CASE(addrman_create)\n {\n-    AddrManTest addrman;\n+    AddrManTest addrman(*m_node.netgroupman);\n \n     BOOST_CHECK_EQUAL(addrman.size(), 0U);\n \n@@ -410,7 +413,7 @@ BOOST_AUTO_TEST_CASE(addrman_create)\n \n BOOST_AUTO_TEST_CASE(addrman_delete)\n {\n-    AddrManTest addrman;\n+    AddrManTest addrman(*m_node.netgroupman);\n \n     BOOST_CHECK_EQUAL(addrman.size(), 0U);\n \n@@ -430,7 +433,7 @@ BOOST_AUTO_TEST_CASE(addrman_delete)\n \n BOOST_AUTO_TEST_CASE(addrman_getaddr)\n {\n-    AddrManTest addrman;\n+    AddrManTest addrman(*m_node.netgroupman);\n \n     // Test: Sanity check, GetAddr should never return anything if addrman\n     //  is empty.\n@@ -490,7 +493,7 @@ BOOST_AUTO_TEST_CASE(addrman_getaddr)\n \n BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket_legacy)\n {\n-    AddrManTest addrman;\n+    AddrManTest addrman(*m_node.netgroupman);\n \n     CAddress addr1 = CAddress(ResolveService(\"250.1.1.1\", 8333), NODE_NONE);\n     CAddress addr2 = CAddress(ResolveService(\"250.1.1.1\", 9999), NODE_NONE);\n@@ -545,7 +548,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket_legacy)\n \n BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket_legacy)\n {\n-    AddrManTest addrman;\n+    AddrManTest addrman(*m_node.netgroupman);\n \n     CAddress addr1 = CAddress(ResolveService(\"250.1.2.1\", 8333), NODE_NONE);\n     CAddress addr2 = CAddress(ResolveService(\"250.1.2.1\", 9999), NODE_NONE);\n@@ -623,7 +626,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket_legacy)\n // 101.8.0.0/16 AS8\n BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket)\n {\n-    AddrManTest addrman;\n+    AddrManTest addrman(*m_node.netgroupman);\n \n     CAddress addr1 = CAddress(ResolveService(\"250.1.1.1\", 8333), NODE_NONE);\n     CAddress addr2 = CAddress(ResolveService(\"250.1.1.1\", 9999), NODE_NONE);\n@@ -678,7 +681,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket)\n \n BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n {\n-    AddrManTest addrman;\n+    AddrManTest addrman(*m_node.netgroupman);\n \n     CAddress addr1 = CAddress(ResolveService(\"250.1.2.1\", 8333), NODE_NONE);\n     CAddress addr2 = CAddress(ResolveService(\"250.1.2.1\", 9999), NODE_NONE);\n@@ -759,10 +762,11 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n BOOST_AUTO_TEST_CASE(addrman_serialization)\n {\n     std::vector<bool> asmap1 = FromBytes(asmap_raw, sizeof(asmap_raw) * 8);\n+    NetGroupManager netgroupman{asmap1};\n \n-    auto addrman_asmap1 = std::make_unique<AddrManTest>(true, asmap1);\n-    auto addrman_asmap1_dup = std::make_unique<AddrManTest>(true, asmap1);\n-    auto addrman_noasmap = std::make_unique<AddrManTest>();\n+    auto addrman_asmap1 = std::make_unique<AddrManTest>(netgroupman);\n+    auto addrman_asmap1_dup = std::make_unique<AddrManTest>(netgroupman);\n+    auto addrman_noasmap = std::make_unique<AddrManTest>(*m_node.netgroupman);\n     CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n \n     CAddress addr = CAddress(ResolveService(\"250.1.1.1\"), NODE_NONE);\n@@ -792,8 +796,8 @@ BOOST_AUTO_TEST_CASE(addrman_serialization)\n     BOOST_CHECK(bucketAndEntry_asmap1.second != bucketAndEntry_noasmap.second);\n \n     // deserializing non-asmaped peers.dat to asmaped addrman\n-    addrman_asmap1 = std::make_unique<AddrManTest>(true, asmap1);\n-    addrman_noasmap = std::make_unique<AddrManTest>();\n+    addrman_asmap1 = std::make_unique<AddrManTest>(netgroupman);\n+    addrman_noasmap = std::make_unique<AddrManTest>(*m_node.netgroupman);\n     addrman_noasmap->Add({addr}, default_source);\n     stream << *addrman_noasmap;\n     stream >> *addrman_asmap1;\n@@ -804,8 +808,8 @@ BOOST_AUTO_TEST_CASE(addrman_serialization)\n     BOOST_CHECK(bucketAndEntry_asmap1_deser.second == bucketAndEntry_asmap1_dup.second);\n \n     // used to map to different buckets, now maps to the same bucket.\n-    addrman_asmap1 = std::make_unique<AddrManTest>(true, asmap1);\n-    addrman_noasmap = std::make_unique<AddrManTest>();\n+    addrman_asmap1 = std::make_unique<AddrManTest>(netgroupman);\n+    addrman_noasmap = std::make_unique<AddrManTest>(*m_node.netgroupman);\n     CAddress addr1 = CAddress(ResolveService(\"250.1.1.1\"), NODE_NONE);\n     CAddress addr2 = CAddress(ResolveService(\"250.2.1.1\"), NODE_NONE);\n     addrman_noasmap->Add({addr, addr2}, default_source);\n@@ -825,7 +829,7 @@ BOOST_AUTO_TEST_CASE(remove_invalid)\n {\n     // Confirm that invalid addresses are ignored in unserialization.\n \n-    auto addrman = std::make_unique<AddrManTest>();\n+    auto addrman = std::make_unique<AddrManTest>(*m_node.netgroupman);\n     CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n \n     const CAddress new1{ResolveService(\"5.5.5.5\"), NODE_NONE};\n@@ -857,14 +861,14 @@ BOOST_AUTO_TEST_CASE(remove_invalid)\n     BOOST_REQUIRE(pos + sizeof(tried2_raw_replacement) <= stream.size());\n     memcpy(stream.data() + pos, tried2_raw_replacement, sizeof(tried2_raw_replacement));\n \n-    addrman = std::make_unique<AddrManTest>();\n+    addrman = std::make_unique<AddrManTest>(*m_node.netgroupman);\n     stream >> *addrman;\n     BOOST_CHECK_EQUAL(addrman->size(), 2);\n }\n \n BOOST_AUTO_TEST_CASE(addrman_selecttriedcollision)\n {\n-    AddrManTest addrman;\n+    AddrManTest addrman(*m_node.netgroupman);\n \n     BOOST_CHECK(addrman.size() == 0);\n \n@@ -896,7 +900,7 @@ BOOST_AUTO_TEST_CASE(addrman_selecttriedcollision)\n \n BOOST_AUTO_TEST_CASE(addrman_noevict)\n {\n-    AddrManTest addrman;\n+    AddrManTest addrman(*m_node.netgroupman);\n \n     // Add 35 addresses.\n     CNetAddr source = ResolveIP(\"252.2.2.2\");\n@@ -952,7 +956,7 @@ BOOST_AUTO_TEST_CASE(addrman_noevict)\n \n BOOST_AUTO_TEST_CASE(addrman_evictionworks)\n {\n-    AddrManTest addrman;\n+    AddrManTest addrman(*m_node.netgroupman);\n \n     BOOST_CHECK(addrman.size() == 0);\n \n@@ -1006,7 +1010,7 @@ BOOST_AUTO_TEST_CASE(addrman_evictionworks)\n \n BOOST_AUTO_TEST_CASE(load_addrman)\n {\n-    AddrManUncorrupted addrmanUncorrupted;\n+    AddrManUncorrupted addrmanUncorrupted(*m_node.netgroupman);\n \n     CService addr1, addr2, addr3;\n     BOOST_CHECK(Lookup(\"250.7.1.1\", addr1, 8333, false));\n@@ -1025,7 +1029,7 @@ BOOST_AUTO_TEST_CASE(load_addrman)\n     // Test that the de-serialization does not throw an exception.\n     CDataStream ssPeers1 = AddrmanToStream(addrmanUncorrupted);\n     bool exceptionThrown = false;\n-    AddrMan addrman1(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 100);\n+    AddrMan addrman1(*m_node.netgroupman, /* deterministic */ false, /* consistency_check_ratio */ 100);\n \n     BOOST_CHECK(addrman1.size() == 0);\n     try {\n@@ -1042,7 +1046,7 @@ BOOST_AUTO_TEST_CASE(load_addrman)\n     // Test that ReadFromStream creates an addrman with the correct number of addrs.\n     CDataStream ssPeers2 = AddrmanToStream(addrmanUncorrupted);\n \n-    AddrMan addrman2(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 100);\n+    AddrMan addrman2(*m_node.netgroupman, /* deterministic */ false, /* consistency_check_ratio */ 100);\n     BOOST_CHECK(addrman2.size() == 0);\n     ReadFromStream(addrman2, ssPeers2);\n     BOOST_CHECK(addrman2.size() == 3);\n@@ -1051,12 +1055,12 @@ BOOST_AUTO_TEST_CASE(load_addrman)\n \n BOOST_AUTO_TEST_CASE(load_addrman_corrupted)\n {\n-    AddrManCorrupted addrmanCorrupted;\n+    AddrManCorrupted addrmanCorrupted(*m_node.netgroupman);\n \n     // Test that the de-serialization of corrupted addrman throws an exception.\n     CDataStream ssPeers1 = AddrmanToStream(addrmanCorrupted);\n     bool exceptionThrown = false;\n-    AddrMan addrman1(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 100);\n+    AddrMan addrman1(*m_node.netgroupman, /* deterministic */ false, /* consistency_check_ratio */ 100);\n     BOOST_CHECK(addrman1.size() == 0);\n     try {\n         unsigned char pchMsgTmp[4];\n@@ -1072,7 +1076,7 @@ BOOST_AUTO_TEST_CASE(load_addrman_corrupted)\n     // Test that ReadFromStream fails if peers.dat is corrupt\n     CDataStream ssPeers2 = AddrmanToStream(addrmanCorrupted);\n \n-    AddrMan addrman2(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 100);\n+    AddrMan addrman2(*m_node.netgroupman, /* deterministic */ false, /* consistency_check_ratio */ 100);\n     BOOST_CHECK(addrman2.size() == 0);\n     BOOST_CHECK_THROW(ReadFromStream(addrman2, ssPeers2), std::ios_base::failure);\n }"
      },
      {
        "sha": "a4f49ba4049177123764fba2ea92dde417316296",
        "filename": "src/test/denialofservice_tests.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2f6fc90cedab4f9166c7469c9e79b24eadd1e030/src/test/denialofservice_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2f6fc90cedab4f9166c7469c9e79b24eadd1e030/src/test/denialofservice_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/denialofservice_tests.cpp?ref=2f6fc90cedab4f9166c7469c9e79b24eadd1e030",
        "patch": "@@ -51,7 +51,7 @@ BOOST_FIXTURE_TEST_SUITE(denialofservice_tests, TestingSetup)\n BOOST_AUTO_TEST_CASE(outbound_slow_chain_eviction)\n {\n     const CChainParams& chainparams = Params();\n-    auto connman = std::make_unique<CConnman>(0x1337, 0x1337, *m_node.addrman);\n+    auto connman = std::make_unique<CConnman>(0x1337, 0x1337, *m_node.addrman, *m_node.netgroupman);\n     auto peerLogic = PeerManager::make(chainparams, *connman, *m_node.addrman, nullptr,\n                                        *m_node.chainman, *m_node.mempool, false);\n \n@@ -119,7 +119,7 @@ static void AddRandomOutboundPeer(std::vector<CNode*>& vNodes, PeerManager& peer\n BOOST_AUTO_TEST_CASE(stale_tip_peer_management)\n {\n     const CChainParams& chainparams = Params();\n-    auto connman = std::make_unique<ConnmanTestMsg>(0x1337, 0x1337, *m_node.addrman);\n+    auto connman = std::make_unique<ConnmanTestMsg>(0x1337, 0x1337, *m_node.addrman, *m_node.netgroupman);\n     auto peerLogic = PeerManager::make(chainparams, *connman, *m_node.addrman, nullptr,\n                                        *m_node.chainman, *m_node.mempool, false);\n \n@@ -192,7 +192,7 @@ BOOST_AUTO_TEST_CASE(peer_discouragement)\n {\n     const CChainParams& chainparams = Params();\n     auto banman = std::make_unique<BanMan>(m_args.GetDataDirBase() / \"banlist\", nullptr, DEFAULT_MISBEHAVING_BANTIME);\n-    auto connman = std::make_unique<ConnmanTestMsg>(0x1337, 0x1337, *m_node.addrman);\n+    auto connman = std::make_unique<ConnmanTestMsg>(0x1337, 0x1337, *m_node.addrman, *m_node.netgroupman);\n     auto peerLogic = PeerManager::make(chainparams, *connman, *m_node.addrman, banman.get(),\n                                        *m_node.chainman, *m_node.mempool, false);\n \n@@ -286,7 +286,7 @@ BOOST_AUTO_TEST_CASE(DoS_bantime)\n {\n     const CChainParams& chainparams = Params();\n     auto banman = std::make_unique<BanMan>(m_args.GetDataDirBase() / \"banlist\", nullptr, DEFAULT_MISBEHAVING_BANTIME);\n-    auto connman = std::make_unique<CConnman>(0x1337, 0x1337, *m_node.addrman);\n+    auto connman = std::make_unique<CConnman>(0x1337, 0x1337, *m_node.addrman, *m_node.netgroupman);\n     auto peerLogic = PeerManager::make(chainparams, *connman, *m_node.addrman, banman.get(),\n                                        *m_node.chainman, *m_node.mempool, false);\n "
      },
      {
        "sha": "f9494761c35387861ea784e9e0c66ee3614835a6",
        "filename": "src/test/fuzz/addrman.cpp",
        "status": "modified",
        "additions": 24,
        "deletions": 16,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2f6fc90cedab4f9166c7469c9e79b24eadd1e030/src/test/fuzz/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2f6fc90cedab4f9166c7469c9e79b24eadd1e030/src/test/fuzz/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/addrman.cpp?ref=2f6fc90cedab4f9166c7469c9e79b24eadd1e030",
        "patch": "@@ -11,6 +11,7 @@\n #include <test/fuzz/FuzzedDataProvider.h>\n #include <test/fuzz/fuzz.h>\n #include <test/fuzz/util.h>\n+#include <test/util/setup_common.h>\n #include <time.h>\n #include <util/asmap.h>\n \n@@ -20,16 +21,30 @@\n #include <string>\n #include <vector>\n \n+namespace {\n+const TestingSetup* g_setup;\n+} // namespace\n+\n void initialize_addrman()\n {\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n     SelectParams(CBaseChainParams::REGTEST);\n }\n \n+[[nodiscard]] inline NetGroupManager ConsumeNetGroupManager(FuzzedDataProvider& fuzzed_data_provider) noexcept\n+{\n+    std::vector<bool> asmap = ConsumeRandomLengthBitVector(fuzzed_data_provider);\n+    if (!SanityCheckASMap(asmap, 128)) asmap.clear();\n+    return NetGroupManager(asmap);\n+}\n+\n FUZZ_TARGET_INIT(data_stream_addr_man, initialize_addrman)\n {\n     FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n     CDataStream data_stream = ConsumeDataStream(fuzzed_data_provider);\n-    AddrMan addr_man(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n+    NetGroupManager netgroupman{ConsumeNetGroupManager(fuzzed_data_provider)};\n+    AddrMan addr_man(netgroupman, /* deterministic */ false, /* consistency_check_ratio */ 0);\n     try {\n         ReadFromStream(addr_man, data_stream);\n     } catch (const std::exception&) {\n@@ -112,8 +127,8 @@ void FillAddrman(AddrMan& addrman, FuzzedDataProvider& fuzzed_data_provider)\n class AddrManDeterministic : public AddrMan\n {\n public:\n-    explicit AddrManDeterministic(std::vector<bool> asmap, FuzzedDataProvider& fuzzed_data_provider)\n-        : AddrMan(std::move(asmap), /* deterministic */ true, /* consistency_check_ratio */ 0)\n+    explicit AddrManDeterministic(const NetGroupManager& netgroupman, FuzzedDataProvider& fuzzed_data_provider)\n+        : AddrMan(netgroupman, /* deterministic */ true, /* consistency_check_ratio */ 0)\n     {\n         WITH_LOCK(m_impl->cs, m_impl->insecure_rand = FastRandomContext{ConsumeUInt256(fuzzed_data_provider)});\n     }\n@@ -206,19 +221,12 @@ class AddrManDeterministic : public AddrMan\n     }\n };\n \n-[[nodiscard]] inline std::vector<bool> ConsumeAsmap(FuzzedDataProvider& fuzzed_data_provider) noexcept\n-{\n-    std::vector<bool> asmap = ConsumeRandomLengthBitVector(fuzzed_data_provider);\n-    if (!SanityCheckASMap(asmap, 128)) asmap.clear();\n-    return asmap;\n-}\n-\n FUZZ_TARGET_INIT(addrman, initialize_addrman)\n {\n     FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n     SetMockTime(ConsumeTime(fuzzed_data_provider));\n-    std::vector<bool> asmap = ConsumeAsmap(fuzzed_data_provider);\n-    auto addr_man_ptr = std::make_unique<AddrManDeterministic>(asmap, fuzzed_data_provider);\n+    NetGroupManager netgroupman{ConsumeNetGroupManager(fuzzed_data_provider)};\n+    auto addr_man_ptr = std::make_unique<AddrManDeterministic>(netgroupman, fuzzed_data_provider);\n     if (fuzzed_data_provider.ConsumeBool()) {\n         const std::vector<uint8_t> serialized_data{ConsumeRandomLengthByteVector(fuzzed_data_provider)};\n         CDataStream ds(serialized_data, SER_DISK, INIT_PROTO_VERSION);\n@@ -227,7 +235,7 @@ FUZZ_TARGET_INIT(addrman, initialize_addrman)\n         try {\n             ds >> *addr_man_ptr;\n         } catch (const std::ios_base::failure&) {\n-            addr_man_ptr = std::make_unique<AddrManDeterministic>(asmap, fuzzed_data_provider);\n+            addr_man_ptr = std::make_unique<AddrManDeterministic>(netgroupman, fuzzed_data_provider);\n         }\n     }\n     AddrManDeterministic& addr_man = *addr_man_ptr;\n@@ -296,9 +304,9 @@ FUZZ_TARGET_INIT(addrman_serdeser, initialize_addrman)\n     FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n     SetMockTime(ConsumeTime(fuzzed_data_provider));\n \n-    std::vector<bool> asmap = ConsumeAsmap(fuzzed_data_provider);\n-    AddrManDeterministic addr_man1{asmap, fuzzed_data_provider};\n-    AddrManDeterministic addr_man2{asmap, fuzzed_data_provider};\n+    NetGroupManager netgroupman{ConsumeNetGroupManager(fuzzed_data_provider)};\n+    AddrManDeterministic addr_man1{netgroupman, fuzzed_data_provider};\n+    AddrManDeterministic addr_man2{netgroupman, fuzzed_data_provider};\n \n     CDataStream data_stream(SER_NETWORK, PROTOCOL_VERSION);\n "
      },
      {
        "sha": "984a4a237c6c1b8383ce8660712b7c63ed770abf",
        "filename": "src/test/fuzz/connman.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 3,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2f6fc90cedab4f9166c7469c9e79b24eadd1e030/src/test/fuzz/connman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2f6fc90cedab4f9166c7469c9e79b24eadd1e030/src/test/fuzz/connman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/connman.cpp?ref=2f6fc90cedab4f9166c7469c9e79b24eadd1e030",
        "patch": "@@ -16,17 +16,25 @@\n #include <cstdint>\n #include <vector>\n \n+namespace {\n+const TestingSetup* g_setup;\n+} // namespace\n+\n void initialize_connman()\n {\n-    static const auto testing_setup = MakeNoLogFileContext<>();\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n }\n \n FUZZ_TARGET_INIT(connman, initialize_connman)\n {\n     FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n     SetMockTime(ConsumeTime(fuzzed_data_provider));\n-    AddrMan addrman(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n-    CConnman connman{fuzzed_data_provider.ConsumeIntegral<uint64_t>(), fuzzed_data_provider.ConsumeIntegral<uint64_t>(), addrman, fuzzed_data_provider.ConsumeBool()};\n+    CConnman connman{fuzzed_data_provider.ConsumeIntegral<uint64_t>(),\n+                     fuzzed_data_provider.ConsumeIntegral<uint64_t>(),\n+                     *g_setup->m_node.addrman,\n+                     *g_setup->m_node.netgroupman,\n+                     fuzzed_data_provider.ConsumeBool()};\n     CNetAddr random_netaddr;\n     CNode random_node = ConsumeNode(fuzzed_data_provider);\n     CSubNet random_subnet;"
      },
      {
        "sha": "0245d496d5f5f9e5b4d5c8e4aed7fea65529a414",
        "filename": "src/test/fuzz/deserialize.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2f6fc90cedab4f9166c7469c9e79b24eadd1e030/src/test/fuzz/deserialize.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2f6fc90cedab4f9166c7469c9e79b24eadd1e030/src/test/fuzz/deserialize.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/deserialize.cpp?ref=2f6fc90cedab4f9166c7469c9e79b24eadd1e030",
        "patch": "@@ -15,6 +15,7 @@\n #include <merkleblock.h>\n #include <net.h>\n #include <netbase.h>\n+#include <netgroup.h>\n #include <node/utxo_snapshot.h>\n #include <primitives/block.h>\n #include <protocol.h>\n@@ -189,7 +190,8 @@ FUZZ_TARGET_DESERIALIZE(blockmerkleroot, {\n     BlockMerkleRoot(block, &mutated);\n })\n FUZZ_TARGET_DESERIALIZE(addrman_deserialize, {\n-    AddrMan am(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n+    NetGroupManager netgroupman{std::vector<bool>()};\n+    AddrMan am(netgroupman, /* deterministic */ false, /* consistency_check_ratio */ 0);\n     DeserializeFromFuzzingInput(buffer, am);\n })\n FUZZ_TARGET_DESERIALIZE(blockheader_deserialize, {"
      },
      {
        "sha": "e7165ce01d381caf87cf9b963b3173a947d60c0a",
        "filename": "src/test/util/setup_common.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2f6fc90cedab4f9166c7469c9e79b24eadd1e030/src/test/util/setup_common.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2f6fc90cedab4f9166c7469c9e79b24eadd1e030/src/test/util/setup_common.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util/setup_common.cpp?ref=2f6fc90cedab4f9166c7469c9e79b24eadd1e030",
        "patch": "@@ -161,6 +161,7 @@ ChainTestingSetup::~ChainTestingSetup()\n     m_node.connman.reset();\n     m_node.banman.reset();\n     m_node.addrman.reset();\n+    m_node.netgroupman.reset();\n     m_node.args = nullptr;\n     UnloadBlockIndex(m_node.mempool.get(), *m_node.chainman);\n     m_node.mempool.reset();\n@@ -192,9 +193,10 @@ TestingSetup::TestingSetup(const std::string& chainName, const std::vector<const\n         throw std::runtime_error(strprintf(\"ActivateBestChain failed. (%s)\", state.ToString()));\n     }\n \n-    m_node.addrman = std::make_unique<AddrMan>(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n+    m_node.netgroupman = std::make_unique<NetGroupManager>(/* asmap */ std::vector<bool>());\n+    m_node.addrman = std::make_unique<AddrMan>(*m_node.netgroupman, /* deterministic */ false, /* consistency_check_ratio */ 0);\n     m_node.banman = std::make_unique<BanMan>(m_args.GetDataDirBase() / \"banlist\", nullptr, DEFAULT_MISBEHAVING_BANTIME);\n-    m_node.connman = std::make_unique<CConnman>(0x1337, 0x1337, *m_node.addrman); // Deterministic randomness for tests.\n+    m_node.connman = std::make_unique<CConnman>(0x1337, 0x1337, *m_node.addrman, *m_node.netgroupman); // Deterministic randomness for tests.\n     m_node.peerman = PeerManager::make(chainparams, *m_node.connman, *m_node.addrman,\n                                        m_node.banman.get(), *m_node.chainman,\n                                        *m_node.mempool, false);"
      }
    ]
  },
  {
    "sha": "745906690a96b7747f62bb1dd13254043dfdb56f",
    "node_id": "C_kwDOABII59oAKDc0NTkwNjY5MGE5NmI3NzQ3ZjYyYmIxZGQxMzI1NDA0M2RmZGI1NmY",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-09-01T11:12:52Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-10-08T13:07:30Z"
      },
      "message": "[netgroupman] Add GetMappedAS() and GetGroup()\n\nThese currently call through to the CNetAddr methods. The logic will be moved in a future commit.",
      "tree": {
        "sha": "95975d367e14553eb7a863edb2bea648a30e057c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/95975d367e14553eb7a863edb2bea648a30e057c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/745906690a96b7747f62bb1dd13254043dfdb56f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/745906690a96b7747f62bb1dd13254043dfdb56f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/745906690a96b7747f62bb1dd13254043dfdb56f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/745906690a96b7747f62bb1dd13254043dfdb56f/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2f6fc90cedab4f9166c7469c9e79b24eadd1e030",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2f6fc90cedab4f9166c7469c9e79b24eadd1e030",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2f6fc90cedab4f9166c7469c9e79b24eadd1e030"
      }
    ],
    "stats": {
      "total": 163,
      "additions": 88,
      "deletions": 75
    },
    "files": [
      {
        "sha": "41f4bf1f5967a9021e8203177a3158647968240a",
        "filename": "src/addrman.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 17,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/745906690a96b7747f62bb1dd13254043dfdb56f/src/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/745906690a96b7747f62bb1dd13254043dfdb56f/src/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.cpp?ref=745906690a96b7747f62bb1dd13254043dfdb56f",
        "patch": "@@ -41,23 +41,23 @@ static constexpr size_t ADDRMAN_SET_TRIED_COLLISION_SIZE{10};\n /** The maximum time we'll spend trying to resolve a tried table collision, in seconds */\n static constexpr int64_t ADDRMAN_TEST_WINDOW{40*60}; // 40 minutes\n \n-int AddrInfo::GetTriedBucket(const uint256& nKey, const std::vector<bool>& asmap) const\n+int AddrInfo::GetTriedBucket(const uint256& nKey, const NetGroupManager& netgroupman) const\n {\n     uint64_t hash1 = (CHashWriter(SER_GETHASH, 0) << nKey << GetKey()).GetCheapHash();\n-    uint64_t hash2 = (CHashWriter(SER_GETHASH, 0) << nKey << GetGroup(asmap) << (hash1 % ADDRMAN_TRIED_BUCKETS_PER_GROUP)).GetCheapHash();\n+    uint64_t hash2 = (CHashWriter(SER_GETHASH, 0) << nKey << netgroupman.GetGroup(*this) << (hash1 % ADDRMAN_TRIED_BUCKETS_PER_GROUP)).GetCheapHash();\n     int tried_bucket = hash2 % ADDRMAN_TRIED_BUCKET_COUNT;\n-    uint32_t mapped_as = GetMappedAS(asmap);\n+    uint32_t mapped_as = netgroupman.GetMappedAS(*this);\n     LogPrint(BCLog::NET, \"IP %s mapped to AS%i belongs to tried bucket %i\\n\", ToStringIP(), mapped_as, tried_bucket);\n     return tried_bucket;\n }\n \n-int AddrInfo::GetNewBucket(const uint256& nKey, const CNetAddr& src, const std::vector<bool>& asmap) const\n+int AddrInfo::GetNewBucket(const uint256& nKey, const CNetAddr& src, const NetGroupManager& netgroupman) const\n {\n-    std::vector<unsigned char> vchSourceGroupKey = src.GetGroup(asmap);\n-    uint64_t hash1 = (CHashWriter(SER_GETHASH, 0) << nKey << GetGroup(asmap) << vchSourceGroupKey).GetCheapHash();\n+    std::vector<unsigned char> vchSourceGroupKey = netgroupman.GetGroup(src);\n+    uint64_t hash1 = (CHashWriter(SER_GETHASH, 0) << nKey << netgroupman.GetGroup(*this) << vchSourceGroupKey).GetCheapHash();\n     uint64_t hash2 = (CHashWriter(SER_GETHASH, 0) << nKey << vchSourceGroupKey << (hash1 % ADDRMAN_NEW_BUCKETS_PER_SOURCE_GROUP)).GetCheapHash();\n     int new_bucket = hash2 % ADDRMAN_NEW_BUCKET_COUNT;\n-    uint32_t mapped_as = GetMappedAS(asmap);\n+    uint32_t mapped_as = netgroupman.GetMappedAS(*this);\n     LogPrint(BCLog::NET, \"IP %s mapped to AS%i belongs to new bucket %i\\n\", ToStringIP(), mapped_as, new_bucket);\n     return new_bucket;\n }\n@@ -296,7 +296,7 @@ void AddrManImpl::Unserialize(Stream& s_)\n     for (int n = 0; n < nTried; n++) {\n         AddrInfo info;\n         s >> info;\n-        int nKBucket = info.GetTriedBucket(nKey, m_netgroupman.GetAsmap());\n+        int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);\n         int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);\n         if (info.IsValid()\n                 && vvTried[nKBucket][nKBucketPos] == -1) {\n@@ -369,7 +369,7 @@ void AddrManImpl::Unserialize(Stream& s_)\n         } else {\n             // In case the new table data cannot be used (bucket count wrong or new asmap),\n             // try to give them a reference based on their primary source address.\n-            bucket = info.GetNewBucket(nKey, m_netgroupman.GetAsmap());\n+            bucket = info.GetNewBucket(nKey, m_netgroupman);\n             bucket_position = info.GetBucketPosition(nKey, true, bucket);\n             if (vvNew[bucket][bucket_position] == -1) {\n                 vvNew[bucket][bucket_position] = entry_index;\n@@ -492,7 +492,7 @@ void AddrManImpl::MakeTried(AddrInfo& info, int nId)\n     AssertLockHeld(cs);\n \n     // remove the entry from all new buckets\n-    const int start_bucket{info.GetNewBucket(nKey, m_netgroupman.GetAsmap())};\n+    const int start_bucket{info.GetNewBucket(nKey, m_netgroupman)};\n     for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; ++n) {\n         const int bucket{(start_bucket + n) % ADDRMAN_NEW_BUCKET_COUNT};\n         const int pos{info.GetBucketPosition(nKey, true, bucket)};\n@@ -507,7 +507,7 @@ void AddrManImpl::MakeTried(AddrInfo& info, int nId)\n     assert(info.nRefCount == 0);\n \n     // which tried bucket to move the entry to\n-    int nKBucket = info.GetTriedBucket(nKey, m_netgroupman.GetAsmap());\n+    int nKBucket = info.GetTriedBucket(nKey, m_netgroupman);\n     int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);\n \n     // first make space to add it (the existing tried entry there is moved to new, deleting whatever is there).\n@@ -523,7 +523,7 @@ void AddrManImpl::MakeTried(AddrInfo& info, int nId)\n         nTried--;\n \n         // find which new bucket it belongs to\n-        int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman.GetAsmap());\n+        int nUBucket = infoOld.GetNewBucket(nKey, m_netgroupman);\n         int nUBucketPos = infoOld.GetBucketPosition(nKey, true, nUBucket);\n         ClearNew(nUBucket, nUBucketPos);\n         assert(vvNew[nUBucket][nUBucketPos] == -1);\n@@ -577,7 +577,7 @@ void AddrManImpl::Good_(const CService& addr, bool test_before_evict, int64_t nT\n     }\n \n     // which tried bucket to move the entry to\n-    int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman.GetAsmap());\n+    int tried_bucket = info.GetTriedBucket(nKey, m_netgroupman);\n     int tried_bucket_pos = info.GetBucketPosition(nKey, false, tried_bucket);\n \n     // Will moving this address into tried evict another entry?\n@@ -647,7 +647,7 @@ bool AddrManImpl::Add_(const CAddress& addr, const CNetAddr& source, int64_t nTi\n         fNew = true;\n     }\n \n-    int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman.GetAsmap());\n+    int nUBucket = pinfo->GetNewBucket(nKey, source, m_netgroupman);\n     int nUBucketPos = pinfo->GetBucketPosition(nKey, true, nUBucket);\n     if (vvNew[nUBucket][nUBucketPos] != nId) {\n         bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;\n@@ -842,7 +842,7 @@ void AddrManImpl::ResolveCollisions_()\n             AddrInfo& info_new = mapInfo[id_new];\n \n             // Which tried bucket to move the entry to.\n-            int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman.GetAsmap());\n+            int tried_bucket = info_new.GetTriedBucket(nKey, m_netgroupman);\n             int tried_bucket_pos = info_new.GetBucketPosition(nKey, false, tried_bucket);\n             if (!info_new.IsValid()) { // id_new may no longer map to a valid address\n                 erase_collision = true;\n@@ -908,7 +908,7 @@ std::pair<CAddress, int64_t> AddrManImpl::SelectTriedCollision_()\n     const AddrInfo& newInfo = mapInfo[id_new];\n \n     // which tried bucket to move the entry to\n-    int tried_bucket = newInfo.GetTriedBucket(nKey, m_netgroupman.GetAsmap());\n+    int tried_bucket = newInfo.GetTriedBucket(nKey, m_netgroupman);\n     int tried_bucket_pos = newInfo.GetBucketPosition(nKey, false, tried_bucket);\n \n     const AddrInfo& info_old = mapInfo[vvTried[tried_bucket][tried_bucket_pos]];\n@@ -981,7 +981,7 @@ int AddrManImpl::ForceCheckAddrman() const\n                 if (!setTried.count(vvTried[n][i]))\n                     return -11;\n                 const auto it{mapInfo.find(vvTried[n][i])};\n-                if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman.GetAsmap()) != n) {\n+                if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_netgroupman) != n) {\n                     return -17;\n                 }\n                 if (it->second.GetBucketPosition(nKey, false, n) != i) {"
      },
      {
        "sha": "4baaf827400e13c2053aa29b2355be4fdd458627",
        "filename": "src/addrman_impl.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/745906690a96b7747f62bb1dd13254043dfdb56f/src/addrman_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/745906690a96b7747f62bb1dd13254043dfdb56f/src/addrman_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman_impl.h?ref=745906690a96b7747f62bb1dd13254043dfdb56f",
        "patch": "@@ -75,15 +75,15 @@ class AddrInfo : public CAddress\n     }\n \n     //! Calculate in which \"tried\" bucket this entry belongs\n-    int GetTriedBucket(const uint256 &nKey, const std::vector<bool> &asmap) const;\n+    int GetTriedBucket(const uint256& nKey, const NetGroupManager& netgroupman) const;\n \n     //! Calculate in which \"new\" bucket this entry belongs, given a certain source\n-    int GetNewBucket(const uint256 &nKey, const CNetAddr& src, const std::vector<bool> &asmap) const;\n+    int GetNewBucket(const uint256& nKey, const CNetAddr& src, const NetGroupManager& netgroupman) const;\n \n     //! Calculate in which \"new\" bucket this entry belongs, using its default source\n-    int GetNewBucket(const uint256 &nKey, const std::vector<bool> &asmap) const\n+    int GetNewBucket(const uint256& nKey, const NetGroupManager& netgroupman) const\n     {\n-        return GetNewBucket(nKey, source, asmap);\n+        return GetNewBucket(nKey, source, netgroupman);\n     }\n \n     //! Calculate in which position of a bucket to store this entry."
      },
      {
        "sha": "e0b38a4330d1f1b7b2355ab8a331e582f3bb638d",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/745906690a96b7747f62bb1dd13254043dfdb56f/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/745906690a96b7747f62bb1dd13254043dfdb56f/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=745906690a96b7747f62bb1dd13254043dfdb56f",
        "patch": "@@ -1923,7 +1923,7 @@ void CConnman::ThreadOpenConnections(const std::vector<std::string> connect)\n                     case ConnectionType::BLOCK_RELAY:\n                     case ConnectionType::ADDR_FETCH:\n                     case ConnectionType::FEELER:\n-                        setConnected.insert(pnode->addr.GetGroup(m_netgroupman.GetAsmap()));\n+                        setConnected.insert(m_netgroupman.GetGroup(pnode->addr));\n                 } // no default case, so the compiler can warn about missing cases\n             }\n         }\n@@ -1997,7 +1997,7 @@ void CConnman::ThreadOpenConnections(const std::vector<std::string> connect)\n                 m_anchors.pop_back();\n                 if (!addr.IsValid() || IsLocal(addr) || !IsReachable(addr) ||\n                     !HasAllDesirableServiceFlags(addr.nServices) ||\n-                    setConnected.count(addr.GetGroup(m_netgroupman.GetAsmap()))) continue;\n+                    setConnected.count(m_netgroupman.GetGroup(addr))) continue;\n                 addrConnect = addr;\n                 LogPrint(BCLog::NET, \"Trying to make an anchor connection to %s\\n\", addrConnect.ToString());\n                 break;\n@@ -2038,7 +2038,7 @@ void CConnman::ThreadOpenConnections(const std::vector<std::string> connect)\n             }\n \n             // Require outbound connections, other than feelers, to be to distinct network groups\n-            if (!fFeeler && setConnected.count(addr.GetGroup(m_netgroupman.GetAsmap()))) {\n+            if (!fFeeler && setConnected.count(m_netgroupman.GetGroup(addr))) {\n                 break;\n             }\n \n@@ -2814,7 +2814,7 @@ void CConnman::GetNodeStats(std::vector<CNodeStats>& vstats) const\n     for (CNode* pnode : vNodes) {\n         vstats.emplace_back();\n         pnode->CopyStats(vstats.back());\n-        vstats.back().m_mapped_as = pnode->addr.GetMappedAS(m_netgroupman.GetAsmap());\n+        vstats.back().m_mapped_as = m_netgroupman.GetMappedAS(pnode->addr);\n     }\n }\n \n@@ -3075,9 +3075,9 @@ CSipHasher CConnman::GetDeterministicRandomizer(uint64_t id) const\n     return CSipHasher(nSeed0, nSeed1).Write(id);\n }\n \n-uint64_t CConnman::CalculateKeyedNetGroup(const CAddress& ad) const\n+uint64_t CConnman::CalculateKeyedNetGroup(const CAddress& address) const\n {\n-    std::vector<unsigned char> vchNetGroup(ad.GetGroup(m_netgroupman.GetAsmap()));\n+    std::vector<unsigned char> vchNetGroup(m_netgroupman.GetGroup(address));\n \n     return GetDeterministicRandomizer(RANDOMIZER_ID_NETGROUP).Write(vchNetGroup.data(), vchNetGroup.size()).Finalize();\n }"
      },
      {
        "sha": "54c65d356c22907ea20829da714ea967950a5a8b",
        "filename": "src/netgroup.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/745906690a96b7747f62bb1dd13254043dfdb56f/src/netgroup.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/745906690a96b7747f62bb1dd13254043dfdb56f/src/netgroup.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netgroup.cpp?ref=745906690a96b7747f62bb1dd13254043dfdb56f",
        "patch": "@@ -3,3 +3,13 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include <netgroup.h>\n+\n+std::vector<unsigned char> NetGroupManager::GetGroup(const CNetAddr& address) const\n+{\n+    return address.GetGroup(m_asmap);\n+}\n+\n+uint32_t NetGroupManager::GetMappedAS(const CNetAddr& address) const\n+{\n+    return address.GetMappedAS(m_asmap);\n+}"
      },
      {
        "sha": "7fe4d3f2b4bccac76834148d0387ad44b2e918b9",
        "filename": "src/netgroup.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/745906690a96b7747f62bb1dd13254043dfdb56f/src/netgroup.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/745906690a96b7747f62bb1dd13254043dfdb56f/src/netgroup.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netgroup.h?ref=745906690a96b7747f62bb1dd13254043dfdb56f",
        "patch": "@@ -5,6 +5,8 @@\n #ifndef BITCOIN_NETGROUP_H\n #define BITCOIN_NETGROUP_H\n \n+#include <netaddress.h>\n+\n #include <vector>\n \n /**\n@@ -20,6 +22,9 @@ class NetGroupManager {\n      * exists, since the data is const. */\n     const std::vector<bool>& GetAsmap() const { return m_asmap; }\n \n+    std::vector<unsigned char> GetGroup(const CNetAddr& address) const;\n+\n+    uint32_t GetMappedAS(const CNetAddr& address) const;\n private:\n     /** Compressed IP->ASN mapping, loaded from a file when a node starts.\n      *"
      },
      {
        "sha": "93e7b74a4b3280a803b7cd33e61a194148d25df4",
        "filename": "src/test/addrman_tests.cpp",
        "status": "modified",
        "additions": 29,
        "deletions": 34,
        "changes": 63,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/745906690a96b7747f62bb1dd13254043dfdb56f/src/test/addrman_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/745906690a96b7747f62bb1dd13254043dfdb56f/src/test/addrman_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/addrman_tests.cpp?ref=745906690a96b7747f62bb1dd13254043dfdb56f",
        "patch": "@@ -506,27 +506,25 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket_legacy)\n     uint256 nKey1 = (uint256)(CHashWriter(SER_GETHASH, 0) << 1).GetHash();\n     uint256 nKey2 = (uint256)(CHashWriter(SER_GETHASH, 0) << 2).GetHash();\n \n-    std::vector<bool> asmap; // use /16\n-\n-    BOOST_CHECK_EQUAL(info1.GetTriedBucket(nKey1, asmap), 40);\n+    BOOST_CHECK_EQUAL(info1.GetTriedBucket(nKey1, *m_node.netgroupman), 40);\n \n     // Test: Make sure key actually randomizes bucket placement. A fail on\n     //  this test could be a security issue.\n-    BOOST_CHECK(info1.GetTriedBucket(nKey1, asmap) != info1.GetTriedBucket(nKey2, asmap));\n+    BOOST_CHECK(info1.GetTriedBucket(nKey1, *m_node.netgroupman) != info1.GetTriedBucket(nKey2, *m_node.netgroupman));\n \n     // Test: Two addresses with same IP but different ports can map to\n     //  different buckets because they have different keys.\n     AddrInfo info2 = AddrInfo(addr2, source1);\n \n     BOOST_CHECK(info1.GetKey() != info2.GetKey());\n-    BOOST_CHECK(info1.GetTriedBucket(nKey1, asmap) != info2.GetTriedBucket(nKey1, asmap));\n+    BOOST_CHECK(info1.GetTriedBucket(nKey1, *m_node.netgroupman) != info2.GetTriedBucket(nKey1, *m_node.netgroupman));\n \n     std::set<int> buckets;\n     for (int i = 0; i < 255; i++) {\n         AddrInfo infoi = AddrInfo(\n             CAddress(ResolveService(\"250.1.1.\" + ToString(i)), NODE_NONE),\n             ResolveIP(\"250.1.1.\" + ToString(i)));\n-        int bucket = infoi.GetTriedBucket(nKey1, asmap);\n+        int bucket = infoi.GetTriedBucket(nKey1, *m_node.netgroupman);\n         buckets.insert(bucket);\n     }\n     // Test: IP addresses in the same /16 prefix should\n@@ -538,7 +536,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket_legacy)\n         AddrInfo infoj = AddrInfo(\n             CAddress(ResolveService(\"250.\" + ToString(j) + \".1.1\"), NODE_NONE),\n             ResolveIP(\"250.\" + ToString(j) + \".1.1\"));\n-        int bucket = infoj.GetTriedBucket(nKey1, asmap);\n+        int bucket = infoj.GetTriedBucket(nKey1, *m_node.netgroupman);\n         buckets.insert(bucket);\n     }\n     // Test: IP addresses in the different /16 prefix should map to more than\n@@ -560,27 +558,25 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket_legacy)\n     uint256 nKey1 = (uint256)(CHashWriter(SER_GETHASH, 0) << 1).GetHash();\n     uint256 nKey2 = (uint256)(CHashWriter(SER_GETHASH, 0) << 2).GetHash();\n \n-    std::vector<bool> asmap; // use /16\n-\n     // Test: Make sure the buckets are what we expect\n-    BOOST_CHECK_EQUAL(info1.GetNewBucket(nKey1, asmap), 786);\n-    BOOST_CHECK_EQUAL(info1.GetNewBucket(nKey1, source1, asmap), 786);\n+    BOOST_CHECK_EQUAL(info1.GetNewBucket(nKey1, *m_node.netgroupman), 786);\n+    BOOST_CHECK_EQUAL(info1.GetNewBucket(nKey1, source1, *m_node.netgroupman), 786);\n \n     // Test: Make sure key actually randomizes bucket placement. A fail on\n     //  this test could be a security issue.\n-    BOOST_CHECK(info1.GetNewBucket(nKey1, asmap) != info1.GetNewBucket(nKey2, asmap));\n+    BOOST_CHECK(info1.GetNewBucket(nKey1, *m_node.netgroupman) != info1.GetNewBucket(nKey2, *m_node.netgroupman));\n \n     // Test: Ports should not affect bucket placement in the addr\n     AddrInfo info2 = AddrInfo(addr2, source1);\n     BOOST_CHECK(info1.GetKey() != info2.GetKey());\n-    BOOST_CHECK_EQUAL(info1.GetNewBucket(nKey1, asmap), info2.GetNewBucket(nKey1, asmap));\n+    BOOST_CHECK_EQUAL(info1.GetNewBucket(nKey1, *m_node.netgroupman), info2.GetNewBucket(nKey1, *m_node.netgroupman));\n \n     std::set<int> buckets;\n     for (int i = 0; i < 255; i++) {\n         AddrInfo infoi = AddrInfo(\n             CAddress(ResolveService(\"250.1.1.\" + ToString(i)), NODE_NONE),\n             ResolveIP(\"250.1.1.\" + ToString(i)));\n-        int bucket = infoi.GetNewBucket(nKey1, asmap);\n+        int bucket = infoi.GetNewBucket(nKey1, *m_node.netgroupman);\n         buckets.insert(bucket);\n     }\n     // Test: IP addresses in the same group (\\16 prefix for IPv4) should\n@@ -593,7 +589,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket_legacy)\n                                         ResolveService(\n                                             ToString(250 + (j / 255)) + \".\" + ToString(j % 256) + \".1.1\"), NODE_NONE),\n             ResolveIP(\"251.4.1.1\"));\n-        int bucket = infoj.GetNewBucket(nKey1, asmap);\n+        int bucket = infoj.GetNewBucket(nKey1, *m_node.netgroupman);\n         buckets.insert(bucket);\n     }\n     // Test: IP addresses in the same source groups should map to NO MORE\n@@ -605,7 +601,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket_legacy)\n         AddrInfo infoj = AddrInfo(\n             CAddress(ResolveService(\"250.1.1.1\"), NODE_NONE),\n             ResolveIP(\"250.\" + ToString(p) + \".1.1\"));\n-        int bucket = infoj.GetNewBucket(nKey1, asmap);\n+        int bucket = infoj.GetNewBucket(nKey1, *m_node.netgroupman);\n         buckets.insert(bucket);\n     }\n     // Test: IP addresses in the different source groups should map to MORE\n@@ -626,7 +622,8 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket_legacy)\n // 101.8.0.0/16 AS8\n BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket)\n {\n-    AddrManTest addrman(*m_node.netgroupman);\n+    std::vector<bool> asmap = FromBytes(asmap_raw, sizeof(asmap_raw) * 8);\n+    NetGroupManager netgroupman{asmap};\n \n     CAddress addr1 = CAddress(ResolveService(\"250.1.1.1\", 8333), NODE_NONE);\n     CAddress addr2 = CAddress(ResolveService(\"250.1.1.1\", 9999), NODE_NONE);\n@@ -639,27 +636,26 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket)\n     uint256 nKey1 = (uint256)(CHashWriter(SER_GETHASH, 0) << 1).GetHash();\n     uint256 nKey2 = (uint256)(CHashWriter(SER_GETHASH, 0) << 2).GetHash();\n \n-    std::vector<bool> asmap = FromBytes(asmap_raw, sizeof(asmap_raw) * 8);\n \n-    BOOST_CHECK_EQUAL(info1.GetTriedBucket(nKey1, asmap), 236);\n+    BOOST_CHECK_EQUAL(info1.GetTriedBucket(nKey1, netgroupman), 236);\n \n     // Test: Make sure key actually randomizes bucket placement. A fail on\n     //  this test could be a security issue.\n-    BOOST_CHECK(info1.GetTriedBucket(nKey1, asmap) != info1.GetTriedBucket(nKey2, asmap));\n+    BOOST_CHECK(info1.GetTriedBucket(nKey1, netgroupman) != info1.GetTriedBucket(nKey2, netgroupman));\n \n     // Test: Two addresses with same IP but different ports can map to\n     //  different buckets because they have different keys.\n     AddrInfo info2 = AddrInfo(addr2, source1);\n \n     BOOST_CHECK(info1.GetKey() != info2.GetKey());\n-    BOOST_CHECK(info1.GetTriedBucket(nKey1, asmap) != info2.GetTriedBucket(nKey1, asmap));\n+    BOOST_CHECK(info1.GetTriedBucket(nKey1, netgroupman) != info2.GetTriedBucket(nKey1, netgroupman));\n \n     std::set<int> buckets;\n     for (int j = 0; j < 255; j++) {\n         AddrInfo infoj = AddrInfo(\n             CAddress(ResolveService(\"101.\" + ToString(j) + \".1.1\"), NODE_NONE),\n             ResolveIP(\"101.\" + ToString(j) + \".1.1\"));\n-        int bucket = infoj.GetTriedBucket(nKey1, asmap);\n+        int bucket = infoj.GetTriedBucket(nKey1, netgroupman);\n         buckets.insert(bucket);\n     }\n     // Test: IP addresses in the different /16 prefix MAY map to more than\n@@ -671,7 +667,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket)\n         AddrInfo infoj = AddrInfo(\n             CAddress(ResolveService(\"250.\" + ToString(j) + \".1.1\"), NODE_NONE),\n             ResolveIP(\"250.\" + ToString(j) + \".1.1\"));\n-        int bucket = infoj.GetTriedBucket(nKey1, asmap);\n+        int bucket = infoj.GetTriedBucket(nKey1, netgroupman);\n         buckets.insert(bucket);\n     }\n     // Test: IP addresses in the different /16 prefix MAY NOT map to more than\n@@ -681,7 +677,8 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket)\n \n BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n {\n-    AddrManTest addrman(*m_node.netgroupman);\n+    std::vector<bool> asmap = FromBytes(asmap_raw, sizeof(asmap_raw) * 8);\n+    NetGroupManager netgroupman{asmap};\n \n     CAddress addr1 = CAddress(ResolveService(\"250.1.2.1\", 8333), NODE_NONE);\n     CAddress addr2 = CAddress(ResolveService(\"250.1.2.1\", 9999), NODE_NONE);\n@@ -693,27 +690,25 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n     uint256 nKey1 = (uint256)(CHashWriter(SER_GETHASH, 0) << 1).GetHash();\n     uint256 nKey2 = (uint256)(CHashWriter(SER_GETHASH, 0) << 2).GetHash();\n \n-    std::vector<bool> asmap = FromBytes(asmap_raw, sizeof(asmap_raw) * 8);\n-\n     // Test: Make sure the buckets are what we expect\n-    BOOST_CHECK_EQUAL(info1.GetNewBucket(nKey1, asmap), 795);\n-    BOOST_CHECK_EQUAL(info1.GetNewBucket(nKey1, source1, asmap), 795);\n+    BOOST_CHECK_EQUAL(info1.GetNewBucket(nKey1, netgroupman), 795);\n+    BOOST_CHECK_EQUAL(info1.GetNewBucket(nKey1, source1, netgroupman), 795);\n \n     // Test: Make sure key actually randomizes bucket placement. A fail on\n     //  this test could be a security issue.\n-    BOOST_CHECK(info1.GetNewBucket(nKey1, asmap) != info1.GetNewBucket(nKey2, asmap));\n+    BOOST_CHECK(info1.GetNewBucket(nKey1, netgroupman) != info1.GetNewBucket(nKey2, netgroupman));\n \n     // Test: Ports should not affect bucket placement in the addr\n     AddrInfo info2 = AddrInfo(addr2, source1);\n     BOOST_CHECK(info1.GetKey() != info2.GetKey());\n-    BOOST_CHECK_EQUAL(info1.GetNewBucket(nKey1, asmap), info2.GetNewBucket(nKey1, asmap));\n+    BOOST_CHECK_EQUAL(info1.GetNewBucket(nKey1, netgroupman), info2.GetNewBucket(nKey1, netgroupman));\n \n     std::set<int> buckets;\n     for (int i = 0; i < 255; i++) {\n         AddrInfo infoi = AddrInfo(\n             CAddress(ResolveService(\"250.1.1.\" + ToString(i)), NODE_NONE),\n             ResolveIP(\"250.1.1.\" + ToString(i)));\n-        int bucket = infoi.GetNewBucket(nKey1, asmap);\n+        int bucket = infoi.GetNewBucket(nKey1, netgroupman);\n         buckets.insert(bucket);\n     }\n     // Test: IP addresses in the same /16 prefix\n@@ -726,7 +721,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n                                         ResolveService(\n                                             ToString(250 + (j / 255)) + \".\" + ToString(j % 256) + \".1.1\"), NODE_NONE),\n             ResolveIP(\"251.4.1.1\"));\n-        int bucket = infoj.GetNewBucket(nKey1, asmap);\n+        int bucket = infoj.GetNewBucket(nKey1, netgroupman);\n         buckets.insert(bucket);\n     }\n     // Test: IP addresses in the same source /16 prefix should not map to more\n@@ -738,7 +733,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n         AddrInfo infoj = AddrInfo(\n             CAddress(ResolveService(\"250.1.1.1\"), NODE_NONE),\n             ResolveIP(\"101.\" + ToString(p) + \".1.1\"));\n-        int bucket = infoj.GetNewBucket(nKey1, asmap);\n+        int bucket = infoj.GetNewBucket(nKey1, netgroupman);\n         buckets.insert(bucket);\n     }\n     // Test: IP addresses in the different source /16 prefixes usually map to MORE\n@@ -750,7 +745,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n         AddrInfo infoj = AddrInfo(\n             CAddress(ResolveService(\"250.1.1.1\"), NODE_NONE),\n             ResolveIP(\"250.\" + ToString(p) + \".1.1\"));\n-        int bucket = infoj.GetNewBucket(nKey1, asmap);\n+        int bucket = infoj.GetNewBucket(nKey1, netgroupman);\n         buckets.insert(bucket);\n     }\n     // Test: IP addresses in the different source /16 prefixes sometimes map to NO MORE"
      },
      {
        "sha": "6fe242394600c5e92eef2e995d342f130e4b15b7",
        "filename": "src/test/fuzz/asmap.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/745906690a96b7747f62bb1dd13254043dfdb56f/src/test/fuzz/asmap.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/745906690a96b7747f62bb1dd13254043dfdb56f/src/test/fuzz/asmap.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/asmap.cpp?ref=745906690a96b7747f62bb1dd13254043dfdb56f",
        "patch": "@@ -3,6 +3,7 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include <netaddress.h>\n+#include <netgroup.h>\n #include <test/fuzz/fuzz.h>\n #include <util/asmap.h>\n \n@@ -56,5 +57,6 @@ FUZZ_TARGET(asmap)\n         memcpy(&ipv4, addr_data, addr_size);\n         net_addr.SetIP(CNetAddr{ipv4});\n     }\n-    (void)net_addr.GetMappedAS(asmap);\n+    NetGroupManager netgroupman{asmap};\n+    (void)netgroupman.GetMappedAS(net_addr);\n }"
      },
      {
        "sha": "e519c41e3afcf31e3ef4d9c56baf8471747898f9",
        "filename": "src/test/netbase_tests.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 13,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/745906690a96b7747f62bb1dd13254043dfdb56f/src/test/netbase_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/745906690a96b7747f62bb1dd13254043dfdb56f/src/test/netbase_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/netbase_tests.cpp?ref=745906690a96b7747f62bb1dd13254043dfdb56f",
        "patch": "@@ -5,6 +5,7 @@\n #include <net_permissions.h>\n #include <netaddress.h>\n #include <netbase.h>\n+#include <netgroup.h>\n #include <protocol.h>\n #include <serialize.h>\n #include <streams.h>\n@@ -315,22 +316,22 @@ BOOST_AUTO_TEST_CASE(subnet_test)\n \n BOOST_AUTO_TEST_CASE(netbase_getgroup)\n {\n-    std::vector<bool> asmap; // use /16\n-    BOOST_CHECK(ResolveIP(\"127.0.0.1\").GetGroup(asmap) == std::vector<unsigned char>({0})); // Local -> !Routable()\n-    BOOST_CHECK(ResolveIP(\"257.0.0.1\").GetGroup(asmap) == std::vector<unsigned char>({0})); // !Valid -> !Routable()\n-    BOOST_CHECK(ResolveIP(\"10.0.0.1\").GetGroup(asmap) == std::vector<unsigned char>({0})); // RFC1918 -> !Routable()\n-    BOOST_CHECK(ResolveIP(\"169.254.1.1\").GetGroup(asmap) == std::vector<unsigned char>({0})); // RFC3927 -> !Routable()\n-    BOOST_CHECK(ResolveIP(\"1.2.3.4\").GetGroup(asmap) == std::vector<unsigned char>({(unsigned char)NET_IPV4, 1, 2})); // IPv4\n-    BOOST_CHECK(ResolveIP(\"::FFFF:0:102:304\").GetGroup(asmap) == std::vector<unsigned char>({(unsigned char)NET_IPV4, 1, 2})); // RFC6145\n-    BOOST_CHECK(ResolveIP(\"64:FF9B::102:304\").GetGroup(asmap) == std::vector<unsigned char>({(unsigned char)NET_IPV4, 1, 2})); // RFC6052\n-    BOOST_CHECK(ResolveIP(\"2002:102:304:9999:9999:9999:9999:9999\").GetGroup(asmap) == std::vector<unsigned char>({(unsigned char)NET_IPV4, 1, 2})); // RFC3964\n-    BOOST_CHECK(ResolveIP(\"2001:0:9999:9999:9999:9999:FEFD:FCFB\").GetGroup(asmap) == std::vector<unsigned char>({(unsigned char)NET_IPV4, 1, 2})); // RFC4380\n-    BOOST_CHECK(ResolveIP(\"2001:470:abcd:9999:9999:9999:9999:9999\").GetGroup(asmap) == std::vector<unsigned char>({(unsigned char)NET_IPV6, 32, 1, 4, 112, 175})); //he.net\n-    BOOST_CHECK(ResolveIP(\"2001:2001:9999:9999:9999:9999:9999:9999\").GetGroup(asmap) == std::vector<unsigned char>({(unsigned char)NET_IPV6, 32, 1, 32, 1})); //IPv6\n+    NetGroupManager netgroupman{std::vector<bool>()}; // use /16\n+    BOOST_CHECK(netgroupman.GetGroup(ResolveIP(\"127.0.0.1\")) == std::vector<unsigned char>({0})); // Local -> !Routable()\n+    BOOST_CHECK(netgroupman.GetGroup(ResolveIP(\"257.0.0.1\")) == std::vector<unsigned char>({0})); // !Valid -> !Routable()\n+    BOOST_CHECK(netgroupman.GetGroup(ResolveIP(\"10.0.0.1\")) == std::vector<unsigned char>({0})); // RFC1918 -> !Routable()\n+    BOOST_CHECK(netgroupman.GetGroup(ResolveIP(\"169.254.1.1\")) == std::vector<unsigned char>({0})); // RFC3927 -> !Routable()\n+    BOOST_CHECK(netgroupman.GetGroup(ResolveIP(\"1.2.3.4\")) == std::vector<unsigned char>({(unsigned char)NET_IPV4, 1, 2})); // IPv4\n+    BOOST_CHECK(netgroupman.GetGroup(ResolveIP(\"::FFFF:0:102:304\")) == std::vector<unsigned char>({(unsigned char)NET_IPV4, 1, 2})); // RFC6145\n+    BOOST_CHECK(netgroupman.GetGroup(ResolveIP(\"64:FF9B::102:304\")) == std::vector<unsigned char>({(unsigned char)NET_IPV4, 1, 2})); // RFC6052\n+    BOOST_CHECK(netgroupman.GetGroup(ResolveIP(\"2002:102:304:9999:9999:9999:9999:9999\")) == std::vector<unsigned char>({(unsigned char)NET_IPV4, 1, 2})); // RFC3964\n+    BOOST_CHECK(netgroupman.GetGroup(ResolveIP(\"2001:0:9999:9999:9999:9999:FEFD:FCFB\")) == std::vector<unsigned char>({(unsigned char)NET_IPV4, 1, 2})); // RFC4380\n+    BOOST_CHECK(netgroupman.GetGroup(ResolveIP(\"2001:470:abcd:9999:9999:9999:9999:9999\")) == std::vector<unsigned char>({(unsigned char)NET_IPV6, 32, 1, 4, 112, 175})); //he.net\n+    BOOST_CHECK(netgroupman.GetGroup(ResolveIP(\"2001:2001:9999:9999:9999:9999:9999:9999\")) == std::vector<unsigned char>({(unsigned char)NET_IPV6, 32, 1, 32, 1})); //IPv6\n \n     // baz.net sha256 hash: 12929400eb4607c4ac075f087167e75286b179c693eb059a01774b864e8fe505\n     std::vector<unsigned char> internal_group = {NET_INTERNAL, 0x12, 0x92, 0x94, 0x00, 0xeb, 0x46, 0x07, 0xc4, 0xac, 0x07};\n-    BOOST_CHECK(CreateInternal(\"baz.net\").GetGroup(asmap) == internal_group);\n+    BOOST_CHECK(netgroupman.GetGroup(CreateInternal(\"baz.net\")) == internal_group);\n }\n \n BOOST_AUTO_TEST_CASE(netbase_parsenetwork)"
      }
    ]
  },
  {
    "sha": "16cef1ba368302531672ffe81d19bf70e61bd127",
    "node_id": "C_kwDOABII59oAKDE2Y2VmMWJhMzY4MzAyNTMxNjcyZmZlODFkMTliZjcwZTYxYmQxMjc",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-09-07T13:03:54Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-10-08T13:07:30Z"
      },
      "message": "[rename] Only use public CNetAddr functions and data in GetMappedAS() and GetGroup()\n\nAlso change parameter/variable names. This makes the next commit mostly\nmove-only.",
      "tree": {
        "sha": "260d010df746d60203ff834eb189b323ca163339",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/260d010df746d60203ff834eb189b323ca163339"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/16cef1ba368302531672ffe81d19bf70e61bd127",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/16cef1ba368302531672ffe81d19bf70e61bd127",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/16cef1ba368302531672ffe81d19bf70e61bd127",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/16cef1ba368302531672ffe81d19bf70e61bd127/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "745906690a96b7747f62bb1dd13254043dfdb56f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/745906690a96b7747f62bb1dd13254043dfdb56f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/745906690a96b7747f62bb1dd13254043dfdb56f"
      }
    ],
    "stats": {
      "total": 49,
      "additions": 27,
      "deletions": 22
    },
    "files": [
      {
        "sha": "03fddefe0c2fdc4ee6772926161c63685b7ad89a",
        "filename": "src/netaddress.cpp",
        "status": "modified",
        "additions": 27,
        "deletions": 22,
        "changes": 49,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/16cef1ba368302531672ffe81d19bf70e61bd127/src/netaddress.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/16cef1ba368302531672ffe81d19bf70e61bd127/src/netaddress.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.cpp?ref=16cef1ba368302531672ffe81d19bf70e61bd127",
        "patch": "@@ -722,34 +722,36 @@ Network CNetAddr::GetNetClass() const\n     return m_net;\n }\n \n-uint32_t CNetAddr::GetMappedAS(const std::vector<bool> &asmap) const {\n-    uint32_t net_class = GetNetClass();\n-    if (asmap.size() == 0 || (net_class != NET_IPV4 && net_class != NET_IPV6)) {\n+uint32_t CNetAddr::GetMappedAS(const std::vector<bool> &m_asmap) const {\n+    const CNetAddr& address = *this;\n+    uint32_t net_class = address.GetNetClass();\n+    if (m_asmap.size() == 0 || (net_class != NET_IPV4 && net_class != NET_IPV6)) {\n         return 0; // Indicates not found, safe because AS0 is reserved per RFC7607.\n     }\n     std::vector<bool> ip_bits(128);\n-    if (HasLinkedIPv4()) {\n+    if (address.HasLinkedIPv4()) {\n         // For lookup, treat as if it was just an IPv4 address (IPV4_IN_IPV6_PREFIX + IPv4 bits)\n         for (int8_t byte_i = 0; byte_i < 12; ++byte_i) {\n             for (uint8_t bit_i = 0; bit_i < 8; ++bit_i) {\n                 ip_bits[byte_i * 8 + bit_i] = (IPV4_IN_IPV6_PREFIX[byte_i] >> (7 - bit_i)) & 1;\n             }\n         }\n-        uint32_t ipv4 = GetLinkedIPv4();\n+        uint32_t ipv4 = address.GetLinkedIPv4();\n         for (int i = 0; i < 32; ++i) {\n             ip_bits[96 + i] = (ipv4 >> (31 - i)) & 1;\n         }\n     } else {\n         // Use all 128 bits of the IPv6 address otherwise\n-        assert(IsIPv6());\n+        assert(address.IsIPv6());\n+        auto addr_bytes = address.GetAddrBytes();\n         for (int8_t byte_i = 0; byte_i < 16; ++byte_i) {\n-            uint8_t cur_byte = m_addr[byte_i];\n+            uint8_t cur_byte = addr_bytes[byte_i];\n             for (uint8_t bit_i = 0; bit_i < 8; ++bit_i) {\n                 ip_bits[byte_i * 8 + bit_i] = (cur_byte >> (7 - bit_i)) & 1;\n             }\n         }\n     }\n-    uint32_t mapped_as = Interpret(asmap, ip_bits);\n+    uint32_t mapped_as = Interpret(m_asmap, ip_bits);\n     return mapped_as;\n }\n \n@@ -763,13 +765,13 @@ uint32_t CNetAddr::GetMappedAS(const std::vector<bool> &asmap) const {\n  * @note No two connections will be attempted to addresses with the same network\n  *       group.\n  */\n-std::vector<unsigned char> CNetAddr::GetGroup(const std::vector<bool> &asmap) const\n+std::vector<unsigned char> CNetAddr::GetGroup(const std::vector<bool> &m_asmap) const\n {\n+    const CNetAddr& address = *this;\n     std::vector<unsigned char> vchRet;\n-    uint32_t net_class = GetNetClass();\n     // If non-empty asmap is supplied and the address is IPv4/IPv6,\n     // return ASN to be used for bucketing.\n-    uint32_t asn = GetMappedAS(asmap);\n+    uint32_t asn = GetMappedAS(m_asmap);\n     if (asn != 0) { // Either asmap was empty, or address has non-asmappable net class (e.g. TOR).\n         vchRet.push_back(NET_IPV6); // IPv4 and IPv6 with same ASN should be in the same bucket\n         for (int i = 0; i < 4; i++) {\n@@ -778,25 +780,27 @@ std::vector<unsigned char> CNetAddr::GetGroup(const std::vector<bool> &asmap) co\n         return vchRet;\n     }\n \n-    vchRet.push_back(net_class);\n+    vchRet.push_back(address.GetNetClass());\n+    int nStartByte{0};\n     int nBits{0};\n \n-    if (IsLocal()) {\n+    if (address.IsLocal()) {\n         // all local addresses belong to the same group\n-    } else if (IsInternal()) {\n+    } else if (address.IsInternal()) {\n         // all internal-usage addresses get their own group\n+        nStartByte = INTERNAL_IN_IPV6_PREFIX.size();\n         nBits = ADDR_INTERNAL_SIZE * 8;\n-    } else if (!IsRoutable()) {\n+    } else if (!address.IsRoutable()) {\n         // all other unroutable addresses belong to the same group\n-    } else if (HasLinkedIPv4()) {\n+    } else if (address.HasLinkedIPv4()) {\n         // IPv4 addresses (and mapped IPv4 addresses) use /16 groups\n-        uint32_t ipv4 = GetLinkedIPv4();\n+        uint32_t ipv4 = address.GetLinkedIPv4();\n         vchRet.push_back((ipv4 >> 24) & 0xFF);\n         vchRet.push_back((ipv4 >> 16) & 0xFF);\n         return vchRet;\n-    } else if (IsTor() || IsI2P() || IsCJDNS()) {\n+    } else if (address.IsTor() || address.IsI2P() || address.IsCJDNS()) {\n         nBits = 4;\n-    } else if (IsHeNet()) {\n+    } else if (address.IsHeNet()) {\n         // for he.net, use /36 groups\n         nBits = 36;\n     } else {\n@@ -805,13 +809,14 @@ std::vector<unsigned char> CNetAddr::GetGroup(const std::vector<bool> &asmap) co\n     }\n \n     // Push our address onto vchRet.\n+    auto addr_bytes = address.GetAddrBytes();\n     const size_t num_bytes = nBits / 8;\n-    vchRet.insert(vchRet.end(), m_addr.begin(), m_addr.begin() + num_bytes);\n+    vchRet.insert(vchRet.end(), addr_bytes.begin() + nStartByte, addr_bytes.begin() + nStartByte + num_bytes);\n     nBits %= 8;\n     // ...for the last byte, push nBits and for the rest of the byte push 1's\n     if (nBits > 0) {\n-        assert(num_bytes < m_addr.size());\n-        vchRet.push_back(m_addr[num_bytes] | ((1 << (8 - nBits)) - 1));\n+        assert(num_bytes < addr_bytes.size());\n+        vchRet.push_back(addr_bytes[num_bytes] | ((1 << (8 - nBits)) - 1));\n     }\n \n     return vchRet;"
      }
    ]
  },
  {
    "sha": "2d9f8f5c55929ce5a5e65424c8b51c324d1b240e",
    "node_id": "C_kwDOABII59oAKDJkOWY4ZjVjNTU5MjljZTVhNWU2NTQyNGM4YjUxYzMyNGQxYjI0MGU",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-09-01T14:55:32Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-10-08T13:07:30Z"
      },
      "message": "[netgroupman] Move GetMappedAS() and GetGroup() logic to NetGroupManager\n\nReviewer hint: use:\n\n`git diff --color-moved=dimmed-zebra --color-moved-ws=ignore-all-space`",
      "tree": {
        "sha": "c334db2f56d5a5cd030e50074a09d443cd623eb0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c334db2f56d5a5cd030e50074a09d443cd623eb0"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2d9f8f5c55929ce5a5e65424c8b51c324d1b240e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2d9f8f5c55929ce5a5e65424c8b51c324d1b240e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2d9f8f5c55929ce5a5e65424c8b51c324d1b240e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2d9f8f5c55929ce5a5e65424c8b51c324d1b240e/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "16cef1ba368302531672ffe81d19bf70e61bd127",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/16cef1ba368302531672ffe81d19bf70e61bd127",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/16cef1ba368302531672ffe81d19bf70e61bd127"
      }
    ],
    "stats": {
      "total": 207,
      "additions": 98,
      "deletions": 109
    },
    "files": [
      {
        "sha": "12d014bc6f079ec1ddc7da07e0ba5cd5d0f42a2b",
        "filename": "src/netaddress.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 101,
        "changes": 101,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2d9f8f5c55929ce5a5e65424c8b51c324d1b240e/src/netaddress.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2d9f8f5c55929ce5a5e65424c8b51c324d1b240e/src/netaddress.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.cpp?ref=2d9f8f5c55929ce5a5e65424c8b51c324d1b240e",
        "patch": "@@ -10,7 +10,6 @@\n #include <hash.h>\n #include <prevector.h>\n #include <tinyformat.h>\n-#include <util/asmap.h>\n #include <util/strencodings.h>\n #include <util/string.h>\n \n@@ -722,106 +721,6 @@ Network CNetAddr::GetNetClass() const\n     return m_net;\n }\n \n-uint32_t CNetAddr::GetMappedAS(const std::vector<bool> &m_asmap) const {\n-    const CNetAddr& address = *this;\n-    uint32_t net_class = address.GetNetClass();\n-    if (m_asmap.size() == 0 || (net_class != NET_IPV4 && net_class != NET_IPV6)) {\n-        return 0; // Indicates not found, safe because AS0 is reserved per RFC7607.\n-    }\n-    std::vector<bool> ip_bits(128);\n-    if (address.HasLinkedIPv4()) {\n-        // For lookup, treat as if it was just an IPv4 address (IPV4_IN_IPV6_PREFIX + IPv4 bits)\n-        for (int8_t byte_i = 0; byte_i < 12; ++byte_i) {\n-            for (uint8_t bit_i = 0; bit_i < 8; ++bit_i) {\n-                ip_bits[byte_i * 8 + bit_i] = (IPV4_IN_IPV6_PREFIX[byte_i] >> (7 - bit_i)) & 1;\n-            }\n-        }\n-        uint32_t ipv4 = address.GetLinkedIPv4();\n-        for (int i = 0; i < 32; ++i) {\n-            ip_bits[96 + i] = (ipv4 >> (31 - i)) & 1;\n-        }\n-    } else {\n-        // Use all 128 bits of the IPv6 address otherwise\n-        assert(address.IsIPv6());\n-        auto addr_bytes = address.GetAddrBytes();\n-        for (int8_t byte_i = 0; byte_i < 16; ++byte_i) {\n-            uint8_t cur_byte = addr_bytes[byte_i];\n-            for (uint8_t bit_i = 0; bit_i < 8; ++bit_i) {\n-                ip_bits[byte_i * 8 + bit_i] = (cur_byte >> (7 - bit_i)) & 1;\n-            }\n-        }\n-    }\n-    uint32_t mapped_as = Interpret(m_asmap, ip_bits);\n-    return mapped_as;\n-}\n-\n-/**\n- * Get the canonical identifier of our network group\n- *\n- * The groups are assigned in a way where it should be costly for an attacker to\n- * obtain addresses with many different group identifiers, even if it is cheap\n- * to obtain addresses with the same identifier.\n- *\n- * @note No two connections will be attempted to addresses with the same network\n- *       group.\n- */\n-std::vector<unsigned char> CNetAddr::GetGroup(const std::vector<bool> &m_asmap) const\n-{\n-    const CNetAddr& address = *this;\n-    std::vector<unsigned char> vchRet;\n-    // If non-empty asmap is supplied and the address is IPv4/IPv6,\n-    // return ASN to be used for bucketing.\n-    uint32_t asn = GetMappedAS(m_asmap);\n-    if (asn != 0) { // Either asmap was empty, or address has non-asmappable net class (e.g. TOR).\n-        vchRet.push_back(NET_IPV6); // IPv4 and IPv6 with same ASN should be in the same bucket\n-        for (int i = 0; i < 4; i++) {\n-            vchRet.push_back((asn >> (8 * i)) & 0xFF);\n-        }\n-        return vchRet;\n-    }\n-\n-    vchRet.push_back(address.GetNetClass());\n-    int nStartByte{0};\n-    int nBits{0};\n-\n-    if (address.IsLocal()) {\n-        // all local addresses belong to the same group\n-    } else if (address.IsInternal()) {\n-        // all internal-usage addresses get their own group\n-        nStartByte = INTERNAL_IN_IPV6_PREFIX.size();\n-        nBits = ADDR_INTERNAL_SIZE * 8;\n-    } else if (!address.IsRoutable()) {\n-        // all other unroutable addresses belong to the same group\n-    } else if (address.HasLinkedIPv4()) {\n-        // IPv4 addresses (and mapped IPv4 addresses) use /16 groups\n-        uint32_t ipv4 = address.GetLinkedIPv4();\n-        vchRet.push_back((ipv4 >> 24) & 0xFF);\n-        vchRet.push_back((ipv4 >> 16) & 0xFF);\n-        return vchRet;\n-    } else if (address.IsTor() || address.IsI2P() || address.IsCJDNS()) {\n-        nBits = 4;\n-    } else if (address.IsHeNet()) {\n-        // for he.net, use /36 groups\n-        nBits = 36;\n-    } else {\n-        // for the rest of the IPv6 network, use /32 groups\n-        nBits = 32;\n-    }\n-\n-    // Push our address onto vchRet.\n-    auto addr_bytes = address.GetAddrBytes();\n-    const size_t num_bytes = nBits / 8;\n-    vchRet.insert(vchRet.end(), addr_bytes.begin() + nStartByte, addr_bytes.begin() + nStartByte + num_bytes);\n-    nBits %= 8;\n-    // ...for the last byte, push nBits and for the rest of the byte push 1's\n-    if (nBits > 0) {\n-        assert(num_bytes < addr_bytes.size());\n-        vchRet.push_back(addr_bytes[num_bytes] | ((1 << (8 - nBits)) - 1));\n-    }\n-\n-    return vchRet;\n-}\n-\n std::vector<unsigned char> CNetAddr::GetAddrBytes() const\n {\n     if (IsAddrV1Compatible()) {"
      },
      {
        "sha": "ed513bd9c28305744e200ca78b13e9edfe6ab09e",
        "filename": "src/netaddress.h",
        "status": "modified",
        "additions": 0,
        "deletions": 6,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2d9f8f5c55929ce5a5e65424c8b51c324d1b240e/src/netaddress.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2d9f8f5c55929ce5a5e65424c8b51c324d1b240e/src/netaddress.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.h?ref=2d9f8f5c55929ce5a5e65424c8b51c324d1b240e",
        "patch": "@@ -203,12 +203,6 @@ class CNetAddr\n     //! Whether this address has a linked IPv4 address (see GetLinkedIPv4()).\n     bool HasLinkedIPv4() const;\n \n-    // The AS on the BGP path to the node we use to diversify\n-    // peers in AddrMan bucketing based on the AS infrastructure.\n-    // The ip->AS mapping depends on how asmap is constructed.\n-    uint32_t GetMappedAS(const std::vector<bool>& asmap) const;\n-\n-    std::vector<unsigned char> GetGroup(const std::vector<bool>& asmap) const;\n     std::vector<unsigned char> GetAddrBytes() const;\n     int GetReachabilityFrom(const CNetAddr* paddrPartner = nullptr) const;\n "
      },
      {
        "sha": "2538ec8862b6f670a1cb5723217d64aa21e0a038",
        "filename": "src/netgroup.cpp",
        "status": "modified",
        "additions": 83,
        "deletions": 2,
        "changes": 85,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2d9f8f5c55929ce5a5e65424c8b51c324d1b240e/src/netgroup.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2d9f8f5c55929ce5a5e65424c8b51c324d1b240e/src/netgroup.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netgroup.cpp?ref=2d9f8f5c55929ce5a5e65424c8b51c324d1b240e",
        "patch": "@@ -4,12 +4,93 @@\n \n #include <netgroup.h>\n \n+#include <util/asmap.h>\n+\n std::vector<unsigned char> NetGroupManager::GetGroup(const CNetAddr& address) const\n {\n-    return address.GetGroup(m_asmap);\n+    std::vector<unsigned char> vchRet;\n+    // If non-empty asmap is supplied and the address is IPv4/IPv6,\n+    // return ASN to be used for bucketing.\n+    uint32_t asn = GetMappedAS(address);\n+    if (asn != 0) { // Either asmap was empty, or address has non-asmappable net class (e.g. TOR).\n+        vchRet.push_back(NET_IPV6); // IPv4 and IPv6 with same ASN should be in the same bucket\n+        for (int i = 0; i < 4; i++) {\n+            vchRet.push_back((asn >> (8 * i)) & 0xFF);\n+        }\n+        return vchRet;\n+    }\n+\n+    vchRet.push_back(address.GetNetClass());\n+    int nStartByte{0};\n+    int nBits{0};\n+\n+    if (address.IsLocal()) {\n+        // all local addresses belong to the same group\n+    } else if (address.IsInternal()) {\n+        // all internal-usage addresses get their own group\n+        nStartByte = INTERNAL_IN_IPV6_PREFIX.size();\n+        nBits = ADDR_INTERNAL_SIZE * 8;\n+    } else if (!address.IsRoutable()) {\n+        // all other unroutable addresses belong to the same group\n+    } else if (address.HasLinkedIPv4()) {\n+        // IPv4 addresses (and mapped IPv4 addresses) use /16 groups\n+        uint32_t ipv4 = address.GetLinkedIPv4();\n+        vchRet.push_back((ipv4 >> 24) & 0xFF);\n+        vchRet.push_back((ipv4 >> 16) & 0xFF);\n+        return vchRet;\n+    } else if (address.IsTor() || address.IsI2P() || address.IsCJDNS()) {\n+        nBits = 4;\n+    } else if (address.IsHeNet()) {\n+        // for he.net, use /36 groups\n+        nBits = 36;\n+    } else {\n+        // for the rest of the IPv6 network, use /32 groups\n+        nBits = 32;\n+    }\n+\n+    // Push our address onto vchRet.\n+    auto addr_bytes = address.GetAddrBytes();\n+    const size_t num_bytes = nBits / 8;\n+    vchRet.insert(vchRet.end(), addr_bytes.begin() + nStartByte, addr_bytes.begin() + nStartByte + num_bytes);\n+    nBits %= 8;\n+    // ...for the last byte, push nBits and for the rest of the byte push 1's\n+    if (nBits > 0) {\n+        assert(num_bytes < addr_bytes.size());\n+        vchRet.push_back(addr_bytes[num_bytes] | ((1 << (8 - nBits)) - 1));\n+    }\n+\n+    return vchRet;\n }\n \n uint32_t NetGroupManager::GetMappedAS(const CNetAddr& address) const\n {\n-    return address.GetMappedAS(m_asmap);\n+    uint32_t net_class = address.GetNetClass();\n+    if (m_asmap.size() == 0 || (net_class != NET_IPV4 && net_class != NET_IPV6)) {\n+        return 0; // Indicates not found, safe because AS0 is reserved per RFC7607.\n+    }\n+    std::vector<bool> ip_bits(128);\n+    if (address.HasLinkedIPv4()) {\n+        // For lookup, treat as if it was just an IPv4 address (IPV4_IN_IPV6_PREFIX + IPv4 bits)\n+        for (int8_t byte_i = 0; byte_i < 12; ++byte_i) {\n+            for (uint8_t bit_i = 0; bit_i < 8; ++bit_i) {\n+                ip_bits[byte_i * 8 + bit_i] = (IPV4_IN_IPV6_PREFIX[byte_i] >> (7 - bit_i)) & 1;\n+            }\n+        }\n+        uint32_t ipv4 = address.GetLinkedIPv4();\n+        for (int i = 0; i < 32; ++i) {\n+            ip_bits[96 + i] = (ipv4 >> (31 - i)) & 1;\n+        }\n+    } else {\n+        // Use all 128 bits of the IPv6 address otherwise\n+        assert(address.IsIPv6());\n+        auto addr_bytes = address.GetAddrBytes();\n+        for (int8_t byte_i = 0; byte_i < 16; ++byte_i) {\n+            uint8_t cur_byte = addr_bytes[byte_i];\n+            for (uint8_t bit_i = 0; bit_i < 8; ++bit_i) {\n+                ip_bits[byte_i * 8 + bit_i] = (cur_byte >> (7 - bit_i)) & 1;\n+            }\n+        }\n+    }\n+    uint32_t mapped_as = Interpret(m_asmap, ip_bits);\n+    return mapped_as;\n }"
      },
      {
        "sha": "29c4829ef6c3c068f0ad8f3d9c0a0fceb6ef6916",
        "filename": "src/netgroup.h",
        "status": "modified",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2d9f8f5c55929ce5a5e65424c8b51c324d1b240e/src/netgroup.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2d9f8f5c55929ce5a5e65424c8b51c324d1b240e/src/netgroup.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netgroup.h?ref=2d9f8f5c55929ce5a5e65424c8b51c324d1b240e",
        "patch": "@@ -22,8 +22,23 @@ class NetGroupManager {\n      * exists, since the data is const. */\n     const std::vector<bool>& GetAsmap() const { return m_asmap; }\n \n+    /**\n+     * Get the canonical identifier of the network group for address.\n+     *\n+     * The groups are assigned in a way where it should be costly for an attacker to\n+     * obtain addresses with many different group identifiers, even if it is cheap\n+     * to obtain addresses with the same identifier.\n+     *\n+     * @note No two connections will be attempted to addresses with the same network\n+     *       group.\n+     */\n     std::vector<unsigned char> GetGroup(const CNetAddr& address) const;\n \n+    /**\n+     *  Get the autonomous system on the BGP path to address.\n+     *\n+     *  The ip->AS mapping depends on how asmap is constructed.\n+     */\n     uint32_t GetMappedAS(const CNetAddr& address) const;\n private:\n     /** Compressed IP->ASN mapping, loaded from a file when a node starts."
      }
    ]
  },
  {
    "sha": "347148fc1b46c8b28f3a0e8ebd037298d45e4e05",
    "node_id": "C_kwDOABII59oAKDM0NzE0OGZjMWI0NmM4YjI4ZjNhMGU4ZWJkMDM3Mjk4ZDQ1ZTRlMDU",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-09-01T15:34:23Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-10-08T13:07:30Z"
      },
      "message": "[netgroupman] Move asmap checksum calculation to NetGroupManager",
      "tree": {
        "sha": "7fbd6b991fa7efe85bdbed26a3f3473ab7901f1f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7fbd6b991fa7efe85bdbed26a3f3473ab7901f1f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/347148fc1b46c8b28f3a0e8ebd037298d45e4e05",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/347148fc1b46c8b28f3a0e8ebd037298d45e4e05",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/347148fc1b46c8b28f3a0e8ebd037298d45e4e05",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/347148fc1b46c8b28f3a0e8ebd037298d45e4e05/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2d9f8f5c55929ce5a5e65424c8b51c324d1b240e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2d9f8f5c55929ce5a5e65424c8b51c324d1b240e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2d9f8f5c55929ce5a5e65424c8b51c324d1b240e"
      }
    ],
    "stats": {
      "total": 23,
      "additions": 14,
      "deletions": 9
    },
    "files": [
      {
        "sha": "1cbfc14b2cdd01446e49b15580e7ad5d03ed4fed",
        "filename": "src/addrman.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 9,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/347148fc1b46c8b28f3a0e8ebd037298d45e4e05/src/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/347148fc1b46c8b28f3a0e8ebd037298d45e4e05/src/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.cpp?ref=347148fc1b46c8b28f3a0e8ebd037298d45e4e05",
        "patch": "@@ -222,11 +222,7 @@ void AddrManImpl::Serialize(Stream& s_) const\n     }\n     // Store asmap checksum after bucket entries so that it\n     // can be ignored by older clients for backward compatibility.\n-    uint256 asmap_checksum;\n-    if (m_netgroupman.GetAsmap().size() != 0) {\n-        asmap_checksum = SerializeHash(m_netgroupman.GetAsmap());\n-    }\n-    s << asmap_checksum;\n+    s << m_netgroupman.GetAsmapChecksum();\n }\n \n template <typename Stream>\n@@ -333,10 +329,7 @@ void AddrManImpl::Unserialize(Stream& s_)\n     // If the bucket count and asmap checksum haven't changed, then attempt\n     // to restore the entries to the buckets/positions they were in before\n     // serialization.\n-    uint256 supplied_asmap_checksum;\n-    if (m_netgroupman.GetAsmap().size() != 0) {\n-        supplied_asmap_checksum = SerializeHash(m_netgroupman.GetAsmap());\n-    }\n+    uint256 supplied_asmap_checksum{m_netgroupman.GetAsmapChecksum()};\n     uint256 serialized_asmap_checksum;\n     if (format >= Format::V2_ASMAP) {\n         s >> serialized_asmap_checksum;"
      },
      {
        "sha": "035016b28034572a7450450180fc52520be4f0e0",
        "filename": "src/netgroup.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/347148fc1b46c8b28f3a0e8ebd037298d45e4e05/src/netgroup.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/347148fc1b46c8b28f3a0e8ebd037298d45e4e05/src/netgroup.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netgroup.cpp?ref=347148fc1b46c8b28f3a0e8ebd037298d45e4e05",
        "patch": "@@ -4,8 +4,16 @@\n \n #include <netgroup.h>\n \n+#include <hash.h>\n #include <util/asmap.h>\n \n+uint256 NetGroupManager::GetAsmapChecksum() const\n+{\n+    if (!m_asmap.size()) return {};\n+\n+    return SerializeHash(m_asmap);\n+}\n+\n std::vector<unsigned char> NetGroupManager::GetGroup(const CNetAddr& address) const\n {\n     std::vector<unsigned char> vchRet;"
      },
      {
        "sha": "79a1c367e0ab4361edb723c9596fe003b1d09709",
        "filename": "src/netgroup.h",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/347148fc1b46c8b28f3a0e8ebd037298d45e4e05/src/netgroup.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/347148fc1b46c8b28f3a0e8ebd037298d45e4e05/src/netgroup.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netgroup.h?ref=347148fc1b46c8b28f3a0e8ebd037298d45e4e05",
        "patch": "@@ -6,6 +6,7 @@\n #define BITCOIN_NETGROUP_H\n \n #include <netaddress.h>\n+#include <uint256.h>\n \n #include <vector>\n \n@@ -22,6 +23,9 @@ class NetGroupManager {\n      * exists, since the data is const. */\n     const std::vector<bool>& GetAsmap() const { return m_asmap; }\n \n+    /** Get a checksum identifying the asmap being used. */\n+    uint256 GetAsmapChecksum() const;\n+\n     /**\n      * Get the canonical identifier of the network group for address.\n      *"
      }
    ]
  },
  {
    "sha": "0328a29b37cd5004e4dc8d8612a13c819d835099",
    "node_id": "C_kwDOABII59oAKDAzMjhhMjliMzdjZDUwMDRlNGRjOGQ4NjEyYTEzYzgxOWQ4MzUwOTk",
    "commit": {
      "author": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-09-01T15:35:45Z"
      },
      "committer": {
        "name": "John Newbery",
        "email": "john@johnnewbery.com",
        "date": "2021-10-08T13:07:30Z"
      },
      "message": "[netgroupman] Remove NetGroupManager::GetAsmap()\n\nasmap no longer needs to be exposed anywhere outside NetGroupManager.",
      "tree": {
        "sha": "2e1a1f8ee3e53a0d568d08e92eebe6616d30c39a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2e1a1f8ee3e53a0d568d08e92eebe6616d30c39a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0328a29b37cd5004e4dc8d8612a13c819d835099",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0328a29b37cd5004e4dc8d8612a13c819d835099",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0328a29b37cd5004e4dc8d8612a13c819d835099",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0328a29b37cd5004e4dc8d8612a13c819d835099/comments",
    "author": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jnewbery",
      "id": 1063656,
      "node_id": "MDQ6VXNlcjEwNjM2NTY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jnewbery",
      "html_url": "https://github.com/jnewbery",
      "followers_url": "https://api.github.com/users/jnewbery/followers",
      "following_url": "https://api.github.com/users/jnewbery/following{/other_user}",
      "gists_url": "https://api.github.com/users/jnewbery/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
      "organizations_url": "https://api.github.com/users/jnewbery/orgs",
      "repos_url": "https://api.github.com/users/jnewbery/repos",
      "events_url": "https://api.github.com/users/jnewbery/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jnewbery/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "347148fc1b46c8b28f3a0e8ebd037298d45e4e05",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/347148fc1b46c8b28f3a0e8ebd037298d45e4e05",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/347148fc1b46c8b28f3a0e8ebd037298d45e4e05"
      }
    ],
    "stats": {
      "total": 4,
      "additions": 0,
      "deletions": 4
    },
    "files": [
      {
        "sha": "977243c91fba862f0567e18048d6ff9812362c0d",
        "filename": "src/netgroup.h",
        "status": "modified",
        "additions": 0,
        "deletions": 4,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0328a29b37cd5004e4dc8d8612a13c819d835099/src/netgroup.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0328a29b37cd5004e4dc8d8612a13c819d835099/src/netgroup.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netgroup.h?ref=0328a29b37cd5004e4dc8d8612a13c819d835099",
        "patch": "@@ -19,10 +19,6 @@ class NetGroupManager {\n         : m_asmap{std::move(asmap)}\n     {}\n \n-    /* Get a reference to (const) asmap. May be held as long as NetGroupManager\n-     * exists, since the data is const. */\n-    const std::vector<bool>& GetAsmap() const { return m_asmap; }\n-\n     /** Get a checksum identifying the asmap being used. */\n     uint256 GetAsmapChecksum() const;\n "
      }
    ]
  }
]