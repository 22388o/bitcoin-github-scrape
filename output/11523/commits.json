[
  {
    "sha": "863748bdd99f37d655921ba220705cf0bec107fd",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4NjM3NDhiZGQ5OWYzN2Q2NTU5MjFiYTIyMDcwNWNmMGJlYzEwN2Zk",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2017-10-03T19:29:20Z"
      },
      "committer": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2017-10-19T01:13:28Z"
      },
      "message": "Refactor CValidationState API\n\nReplace state.DoS with state.Invalid where possible\n\nReplace state.DoS with more descriptive calls where straightforward\n\nReplace all remaining uses of state.DoS and state.Invalid with more descriptive calls\n\nConvert all nDoS usage to an enum class with named levels\n\nRemove dead CValidationState::Invalid fn\n\nClean up one use of NonStandardTx to use default args\n\nUse a custom enum class for reporting corruption to make it more clear where corruption occurs\n\nCValidationState: Remove rejectreason default argument\n\nDrop useless ret parameter from CValidationState::DoS\n\nreturn false directly from CValidtationState update call sites",
      "tree": {
        "sha": "f1d02b14196a2a28303ef865ae55405b457281f4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f1d02b14196a2a28303ef865ae55405b457281f4"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/863748bdd99f37d655921ba220705cf0bec107fd",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/863748bdd99f37d655921ba220705cf0bec107fd",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/863748bdd99f37d655921ba220705cf0bec107fd",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/863748bdd99f37d655921ba220705cf0bec107fd/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "02ac8c892b1fa98d9c4422f1bda89ea421ed17bd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/02ac8c892b1fa98d9c4422f1bda89ea421ed17bd",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/02ac8c892b1fa98d9c4422f1bda89ea421ed17bd"
      }
    ],
    "stats": {
      "total": 563,
      "additions": 365,
      "deletions": 198
    },
    "files": [
      {
        "sha": "015b8aac046129583d4607cce872a41376bbf33f",
        "filename": "src/consensus/tx_verify.cpp",
        "status": "modified",
        "additions": 46,
        "deletions": 24,
        "changes": 70,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/863748bdd99f37d655921ba220705cf0bec107fd/src/consensus/tx_verify.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/863748bdd99f37d655921ba220705cf0bec107fd/src/consensus/tx_verify.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/tx_verify.cpp?ref=863748bdd99f37d655921ba220705cf0bec107fd",
        "patch": "@@ -159,47 +159,65 @@ int64_t GetTransactionSigOpCost(const CTransaction& tx, const CCoinsViewCache& i\n bool CheckTransaction(const CTransaction& tx, CValidationState &state, bool fCheckDuplicateInputs)\n {\n     // Basic checks that don't depend on any context\n-    if (tx.vin.empty())\n-        return state.DoS(10, false, REJECT_INVALID, \"bad-txns-vin-empty\");\n-    if (tx.vout.empty())\n-        return state.DoS(10, false, REJECT_INVALID, \"bad-txns-vout-empty\");\n+    if (tx.vin.empty()) {\n+        state.BadTx(\"bad-txns-vin-empty\", \"\", DoS_SEVERITY::MEDIUM);\n+        return false;\n+    }\n+    if (tx.vout.empty()) {\n+        state.BadTx(\"bad-txns-vout-empty\", \"\", DoS_SEVERITY::MEDIUM);\n+        return false;\n+    }\n     // Size limits (this doesn't take the witness into account, as that hasn't been checked for malleability)\n-    if (::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT)\n-        return state.DoS(100, false, REJECT_INVALID, \"bad-txns-oversize\");\n+    if (::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT) {\n+        state.BadTx(\"bad-txns-oversize\");\n+        return false;\n+    }\n \n     // Check for negative or overflow output values\n     CAmount nValueOut = 0;\n     for (const auto& txout : tx.vout)\n     {\n-        if (txout.nValue < 0)\n-            return state.DoS(100, false, REJECT_INVALID, \"bad-txns-vout-negative\");\n-        if (txout.nValue > MAX_MONEY)\n-            return state.DoS(100, false, REJECT_INVALID, \"bad-txns-vout-toolarge\");\n+        if (txout.nValue < 0) {\n+            state.BadTx(\"bad-txns-vout-negative\");\n+            return false;\n+        }\n+        if (txout.nValue > MAX_MONEY) {\n+            state.BadTx(\"bad-txns-vout-toolarge\");\n+            return false;\n+        }\n         nValueOut += txout.nValue;\n-        if (!MoneyRange(nValueOut))\n-            return state.DoS(100, false, REJECT_INVALID, \"bad-txns-txouttotal-toolarge\");\n+        if (!MoneyRange(nValueOut)) {\n+            state.BadTx(\"bad-txns-txouttotal-toolarge\");\n+            return false;\n+        }\n     }\n \n     // Check for duplicate inputs - note that this check is slow so we skip it in CheckBlock\n     if (fCheckDuplicateInputs) {\n         std::set<COutPoint> vInOutPoints;\n         for (const auto& txin : tx.vin)\n         {\n-            if (!vInOutPoints.insert(txin.prevout).second)\n-                return state.DoS(100, false, REJECT_INVALID, \"bad-txns-inputs-duplicate\");\n+            if (!vInOutPoints.insert(txin.prevout).second) {\n+                state.BadTx(\"bad-txns-inputs-duplicate\");\n+                return false;\n+            }\n         }\n     }\n \n     if (tx.IsCoinBase())\n     {\n-        if (tx.vin[0].scriptSig.size() < 2 || tx.vin[0].scriptSig.size() > 100)\n-            return state.DoS(100, false, REJECT_INVALID, \"bad-cb-length\");\n+        if (tx.vin[0].scriptSig.size() < 2 || tx.vin[0].scriptSig.size() > 100) {\n+            state.BadTx(\"bad-cb-length\");\n+            return false;\n+        }\n     }\n     else\n     {\n         for (const auto& txin : tx.vin)\n-            if (txin.prevout.IsNull())\n-                return state.DoS(10, false, REJECT_INVALID, \"bad-txns-prevout-null\");\n+            if (txin.prevout.IsNull()) {\n+                state.BadTx(\"bad-txns-prevout-null\", \"\", DoS_SEVERITY::MEDIUM);\n+                return false;\n+            }\n     }\n \n     return true;\n@@ -209,8 +227,9 @@ bool Consensus::CheckTxInputs(const CTransaction& tx, CValidationState& state, c\n {\n     // are the actual inputs available?\n     if (!inputs.HaveInputs(tx)) {\n-        return state.DoS(100, false, REJECT_INVALID, \"bad-txns-inputs-missingorspent\", false,\n+        state.BadTx(\"bad-txns-inputs-missingorspent\",\n                          strprintf(\"%s: inputs missing/spent\", __func__));\n+        return false;\n     }\n \n     CAmount nValueIn = 0;\n@@ -221,28 +240,31 @@ bool Consensus::CheckTxInputs(const CTransaction& tx, CValidationState& state, c\n \n         // If prev is coinbase, check that it's matured\n         if (coin.IsCoinBase() && nSpendHeight - coin.nHeight < COINBASE_MATURITY) {\n-            return state.Invalid(false,\n-                REJECT_INVALID, \"bad-txns-premature-spend-of-coinbase\",\n+            state.BadTx(\"bad-txns-premature-spend-of-coinbase\",\n                 strprintf(\"tried to spend coinbase at depth %d\", nSpendHeight - coin.nHeight));\n+            return false;\n         }\n \n         // Check for negative or overflow input values\n         nValueIn += coin.out.nValue;\n         if (!MoneyRange(coin.out.nValue) || !MoneyRange(nValueIn)) {\n-            return state.DoS(100, false, REJECT_INVALID, \"bad-txns-inputvalues-outofrange\");\n+            state.BadTx(\"bad-txns-inputvalues-outofrange\");\n+            return false;\n         }\n     }\n \n     const CAmount value_out = tx.GetValueOut();\n     if (nValueIn < value_out) {\n-        return state.DoS(100, false, REJECT_INVALID, \"bad-txns-in-belowout\", false,\n+        state.BadTx(\"bad-txns-in-belowout\",\n             strprintf(\"value in (%s) < value out (%s)\", FormatMoney(nValueIn), FormatMoney(value_out)));\n+        return false;\n     }\n \n     // Tally transaction fees\n     const CAmount txfee_aux = nValueIn - value_out;\n     if (!MoneyRange(txfee_aux)) {\n-        return state.DoS(100, false, REJECT_INVALID, \"bad-txns-fee-outofrange\");\n+        state.BadTx(\"bad-txns-fee-outofrange\");\n+        return false;\n     }\n \n     txfee = txfee_aux;"
      },
      {
        "sha": "8a328d8a7b3f41e70ce252b0e2404a97890b2cdb",
        "filename": "src/consensus/validation.h",
        "status": "modified",
        "additions": 81,
        "deletions": 17,
        "changes": 98,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/863748bdd99f37d655921ba220705cf0bec107fd/src/consensus/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/863748bdd99f37d655921ba220705cf0bec107fd/src/consensus/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/validation.h?ref=863748bdd99f37d655921ba220705cf0bec107fd",
        "patch": "@@ -22,6 +22,35 @@ static const unsigned char REJECT_NONSTANDARD = 0x40;\n static const unsigned char REJECT_INSUFFICIENTFEE = 0x42;\n static const unsigned char REJECT_CHECKPOINT = 0x43;\n \n+/** Reject codes greater or equal to this can be returned by AcceptToMemPool\n+ * for transactions, to signal internal conditions. They cannot and should not\n+ * be sent over the P2P network.\n+ *\n+ * These error codes are not consensus, but consensus changes should avoid using them\n+ * unnecessarily so as not to cause needless churn in core-based clients.\n+ */\n+static const unsigned int REJECT_INTERNAL = 0x100;\n+/** Too high fee. Can not be triggered by P2P transactions */\n+static const unsigned int REJECT_HIGHFEE = 0x100;\n+\n+enum class DoS_SEVERITY : int {\n+    NONE = 0,\n+    LOW = 1,\n+    MEDIUM = 10,\n+    ELEVATED = 20,\n+    HIGH = 50,\n+    CRITICAL = 100,\n+};\n+inline int ToBanScore(const DoS_SEVERITY x) {\n+    return (int) x;\n+}\n+inline bool operator>(const DoS_SEVERITY lhs, const DoS_SEVERITY rhs) {\n+    return ((int) lhs) > ((int) rhs);\n+}\n+enum class CORRUPTION_POSSIBLE : bool {\n+    False = 0,\n+    True = 1\n+};\n /** Capture information about block/transaction validation */\n class CValidationState {\n private:\n@@ -30,37 +59,71 @@ class CValidationState {\n         MODE_INVALID, //!< network rule violation (DoS value may be set)\n         MODE_ERROR,   //!< run-time error\n     } mode;\n-    int nDoS;\n+    DoS_SEVERITY nDoS;\n     std::string strRejectReason;\n     unsigned int chRejectCode;\n-    bool corruptionPossible;\n+    CORRUPTION_POSSIBLE corruptionPossible;\n     std::string strDebugMessage;\n-public:\n-    CValidationState() : mode(MODE_VALID), nDoS(0), chRejectCode(0), corruptionPossible(false) {}\n-    bool DoS(int level, bool ret = false,\n+    void DoS(DoS_SEVERITY level,\n              unsigned int chRejectCodeIn=0, const std::string &strRejectReasonIn=\"\",\n-             bool corruptionIn=false,\n+             CORRUPTION_POSSIBLE corruptionIn=CORRUPTION_POSSIBLE::False,\n              const std::string &strDebugMessageIn=\"\") {\n         chRejectCode = chRejectCodeIn;\n         strRejectReason = strRejectReasonIn;\n         corruptionPossible = corruptionIn;\n         strDebugMessage = strDebugMessageIn;\n         if (mode == MODE_ERROR)\n-            return ret;\n-        nDoS += level;\n+            return;\n+        nDoS = (DoS_SEVERITY) (((unsigned int) nDoS) + ((unsigned int) level));\n         mode = MODE_INVALID;\n-        return ret;\n     }\n-    bool Invalid(bool ret = false,\n-                 unsigned int _chRejectCode=0, const std::string &_strRejectReason=\"\",\n+public:\n+    CValidationState() : mode(MODE_VALID), nDoS(DoS_SEVERITY::NONE), chRejectCode(0), corruptionPossible(CORRUPTION_POSSIBLE::False) {}\n+    void BadBlockHeader(const std::string &_strRejectReason,\n+                 const std::string &_strDebugMessage=\"\", DoS_SEVERITY level=DoS_SEVERITY::CRITICAL, unsigned int _chRejectCode=REJECT_INVALID) {\n+        DoS(level, _chRejectCode, _strRejectReason, CORRUPTION_POSSIBLE::False, _strDebugMessage);\n+    }\n+    void CorruptBlockHeader(const std::string &_strRejectReason,\n+                 const std::string &_strDebugMessage=\"\", DoS_SEVERITY level=DoS_SEVERITY::CRITICAL) {\n+        DoS(level, REJECT_INVALID, _strRejectReason, CORRUPTION_POSSIBLE::True, _strDebugMessage);\n+    }\n+    void ForkingBlockHeaderDisallowed() {\n+        DoS(DoS_SEVERITY::CRITICAL, REJECT_CHECKPOINT, \"bad-fork-prior-to-checkpoint\");\n+    }\n+    void BadBlock(const std::string &_strRejectReason,\n+                 const std::string &_strDebugMessage=\"\", DoS_SEVERITY level=DoS_SEVERITY::CRITICAL) {\n+        DoS(level, REJECT_INVALID, _strRejectReason, CORRUPTION_POSSIBLE::False, _strDebugMessage);\n+    }\n+    void CorruptBlock(const std::string &_strRejectReason,\n+                 const std::string &_strDebugMessage=\"\", DoS_SEVERITY level=DoS_SEVERITY::CRITICAL) {\n+        DoS(level, REJECT_INVALID, _strRejectReason, CORRUPTION_POSSIBLE::True, _strDebugMessage);\n+    }\n+    void BadTx(const std::string &_strRejectReason,\n+                 const std::string &_strDebugMessage=\"\", DoS_SEVERITY level=DoS_SEVERITY::CRITICAL, unsigned int _chRejectCode=REJECT_INVALID) {\n+        DoS(level, _chRejectCode, _strRejectReason, CORRUPTION_POSSIBLE::False, _strDebugMessage);\n+    }\n+    void CorruptTx(const std::string &_strRejectReason,\n+                 const std::string &_strDebugMessage=\"\", DoS_SEVERITY level=DoS_SEVERITY::CRITICAL) {\n+        DoS(level, REJECT_INVALID, _strRejectReason, CORRUPTION_POSSIBLE::True, _strDebugMessage);\n+    }\n+    void NonStandardTx(const std::string &_strRejectReason,\n+                 const std::string &_strDebugMessage=\"\", CORRUPTION_POSSIBLE corrupted=CORRUPTION_POSSIBLE::False,\n+                 DoS_SEVERITY level=DoS_SEVERITY::NONE) {\n+        DoS(level, REJECT_NONSTANDARD, _strRejectReason, corrupted, _strDebugMessage);\n+    }\n+    void DuplicateData(const std::string &_strRejectReason,\n+                 const std::string &_strDebugMessage=\"\") {\n+        DoS(DoS_SEVERITY::NONE, REJECT_DUPLICATE, _strRejectReason, CORRUPTION_POSSIBLE::False, _strDebugMessage);\n+    }\n+    void RejectFee(unsigned int _chRejectCode, const std::string &_strRejectReason,\n                  const std::string &_strDebugMessage=\"\") {\n-        return DoS(0, ret, _chRejectCode, _strRejectReason, false, _strDebugMessage);\n+        assert(_chRejectCode == REJECT_INSUFFICIENTFEE || _chRejectCode == REJECT_HIGHFEE);\n+        DoS(DoS_SEVERITY::NONE, _chRejectCode, _strRejectReason, CORRUPTION_POSSIBLE::False, _strDebugMessage);\n     }\n-    bool Error(const std::string& strRejectReasonIn) {\n+    void Error(const std::string& strRejectReasonIn) {\n         if (mode == MODE_VALID)\n             strRejectReason = strRejectReasonIn;\n         mode = MODE_ERROR;\n-        return false;\n     }\n     bool IsValid() const {\n         return mode == MODE_VALID;\n@@ -71,22 +134,23 @@ class CValidationState {\n     bool IsError() const {\n         return mode == MODE_ERROR;\n     }\n-    bool IsInvalid(int &nDoSOut) const {\n+    bool IsInvalid(DoS_SEVERITY &nDoSOut) const {\n         if (IsInvalid()) {\n             nDoSOut = nDoS;\n             return true;\n         }\n         return false;\n     }\n     bool CorruptionPossible() const {\n-        return corruptionPossible;\n+        return corruptionPossible != CORRUPTION_POSSIBLE::False;\n     }\n     void SetCorruptionPossible() {\n-        corruptionPossible = true;\n+        corruptionPossible = CORRUPTION_POSSIBLE::True;\n     }\n     unsigned int GetRejectCode() const { return chRejectCode; }\n     std::string GetRejectReason() const { return strRejectReason; }\n     std::string GetDebugMessage() const { return strDebugMessage; }\n+    void SetDebugMessage(const std::string& msg){ strDebugMessage = msg; }\n };\n \n // These implement the weight = (stripped_size * 4) + witness_size formula,"
      },
      {
        "sha": "06cf4bd5cb1286c30b858e7a8add307c0c132418",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 31,
        "deletions": 29,
        "changes": 60,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/863748bdd99f37d655921ba220705cf0bec107fd/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/863748bdd99f37d655921ba220705cf0bec107fd/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=863748bdd99f37d655921ba220705cf0bec107fd",
        "patch": "@@ -681,8 +681,9 @@ unsigned int LimitOrphanTxSize(unsigned int nMaxOrphans) EXCLUSIVE_LOCKS_REQUIRE\n }\n \n // Requires cs_main.\n-void Misbehaving(NodeId pnode, int howmuch)\n+void Misbehaving(NodeId pnode, DoS_SEVERITY nDoS)\n {\n+    int howmuch = ToBanScore(nDoS);\n     if (howmuch == 0)\n         return;\n \n@@ -843,13 +844,13 @@ void PeerLogicValidation::BlockChecked(const CBlock& block, const CValidationSta\n     const uint256 hash(block.GetHash());\n     std::map<uint256, std::pair<NodeId, bool>>::iterator it = mapBlockSource.find(hash);\n \n-    int nDoS = 0;\n+    DoS_SEVERITY nDoS = DoS_SEVERITY::NONE;\n     if (state.IsInvalid(nDoS)) {\n         // Don't send reject message with code 0 or an internal reject code.\n         if (it != mapBlockSource.end() && State(it->second.first) && state.GetRejectCode() > 0 && state.GetRejectCode() < REJECT_INTERNAL) {\n             CBlockReject reject = {(unsigned char)state.GetRejectCode(), state.GetRejectReason().substr(0, MAX_REJECT_MESSAGE_LENGTH), hash};\n             State(it->second.first)->rejects.push_back(reject);\n-            if (nDoS > 0 && it->second.second)\n+            if (nDoS > DoS_SEVERITY::NONE && it->second.second)\n                 Misbehaving(it->second.first, nDoS);\n         }\n     }\n@@ -1152,7 +1153,7 @@ inline void static SendBlockTransactions(const CBlock& block, const BlockTransac\n     for (size_t i = 0; i < req.indexes.size(); i++) {\n         if (req.indexes[i] >= block.vtx.size()) {\n             LOCK(cs_main);\n-            Misbehaving(pfrom->GetId(), 100);\n+            Misbehaving(pfrom->GetId(), DoS_SEVERITY::CRITICAL);\n             LogPrintf(\"Peer %d sent us a getblocktxn with out-of-bounds tx indices\", pfrom->GetId());\n             return;\n         }\n@@ -1180,7 +1181,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n     {\n         if (pfrom->nVersion >= NO_BLOOM_VERSION) {\n             LOCK(cs_main);\n-            Misbehaving(pfrom->GetId(), 100);\n+            Misbehaving(pfrom->GetId(), DoS_SEVERITY::CRITICAL);\n             return false;\n         } else {\n             pfrom->fDisconnect = true;\n@@ -1219,7 +1220,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         {\n             connman->PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_DUPLICATE, std::string(\"Duplicate version message\")));\n             LOCK(cs_main);\n-            Misbehaving(pfrom->GetId(), 1);\n+            Misbehaving(pfrom->GetId(), DoS_SEVERITY::LOW);\n             return false;\n         }\n \n@@ -1394,7 +1395,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n     {\n         // Must have a version message before anything else\n         LOCK(cs_main);\n-        Misbehaving(pfrom->GetId(), 1);\n+        Misbehaving(pfrom->GetId(), DoS_SEVERITY::LOW);\n         return false;\n     }\n \n@@ -1438,7 +1439,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n     {\n         // Must have a verack message before anything else\n         LOCK(cs_main);\n-        Misbehaving(pfrom->GetId(), 1);\n+        Misbehaving(pfrom->GetId(), DoS_SEVERITY::LOW);\n         return false;\n     }\n \n@@ -1453,7 +1454,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         if (vAddr.size() > 1000)\n         {\n             LOCK(cs_main);\n-            Misbehaving(pfrom->GetId(), 20);\n+            Misbehaving(pfrom->GetId(), DoS_SEVERITY::ELEVATED);\n             return error(\"message addr size() = %u\", vAddr.size());\n         }\n \n@@ -1529,7 +1530,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         if (vInv.size() > MAX_INV_SZ)\n         {\n             LOCK(cs_main);\n-            Misbehaving(pfrom->GetId(), 20);\n+            Misbehaving(pfrom->GetId(), DoS_SEVERITY::ELEVATED);\n             return error(\"message inv size() = %u\", vInv.size());\n         }\n \n@@ -1590,7 +1591,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         if (vInv.size() > MAX_INV_SZ)\n         {\n             LOCK(cs_main);\n-            Misbehaving(pfrom->GetId(), 20);\n+            Misbehaving(pfrom->GetId(), DoS_SEVERITY::ELEVATED);\n             return error(\"message getdata size() = %u\", vInv.size());\n         }\n \n@@ -1857,11 +1858,12 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                     }\n                     else if (!fMissingInputs2)\n                     {\n-                        int nDos = 0;\n-                        if (stateDummy.IsInvalid(nDos) && nDos > 0)\n+                        DoS_SEVERITY nDoS = DoS_SEVERITY::NONE;\n+\n+                        if (stateDummy.IsInvalid(nDoS) && nDoS > DoS_SEVERITY::NONE)\n                         {\n                             // Punish peer that gave us an invalid orphan tx\n-                            Misbehaving(fromPeer, nDos);\n+                            Misbehaving(fromPeer, nDoS);\n                             setMisbehaving.insert(fromPeer);\n                             LogPrint(BCLog::MEMPOOL, \"   invalid orphan tx %s\\n\", orphanHash.ToString());\n                         }\n@@ -1937,8 +1939,8 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 // Never relay transactions that we would assign a non-zero DoS\n                 // score for, as we expect peers to do the same with us in that\n                 // case.\n-                int nDoS = 0;\n-                if (!state.IsInvalid(nDoS) || nDoS == 0) {\n+                DoS_SEVERITY nDoS = DoS_SEVERITY::NONE;\n+                if (!state.IsInvalid(nDoS) || nDoS == DoS_SEVERITY::NONE) {\n                     LogPrintf(\"Force relaying tx %s from whitelisted peer=%d\\n\", tx.GetHash().ToString(), pfrom->GetId());\n                     RelayTransaction(tx, connman);\n                 } else {\n@@ -1950,7 +1952,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         for (const CTransactionRef& removedTx : lRemovedTxn)\n             AddToCompactExtraTransactions(removedTx);\n \n-        int nDoS = 0;\n+        DoS_SEVERITY nDoS = DoS_SEVERITY::NONE;\n         if (state.IsInvalid(nDoS))\n         {\n             LogPrint(BCLog::MEMPOOLREJ, \"%s from peer=%d was not accepted: %s\\n\", tx.GetHash().ToString(),\n@@ -1959,7 +1961,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             if (state.GetRejectCode() > 0 && state.GetRejectCode() < REJECT_INTERNAL) // Never send AcceptToMemoryPool's internal codes over P2P\n                 connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::REJECT, strCommand, (unsigned char)state.GetRejectCode(),\n                                    state.GetRejectReason().substr(0, MAX_REJECT_MESSAGE_LENGTH), inv.hash));\n-            if (nDoS > 0) {\n+            if (nDoS > DoS_SEVERITY::NONE) {\n                 Misbehaving(pfrom->GetId(), nDoS);\n             }\n         }\n@@ -1985,9 +1987,9 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         const CBlockIndex *pindex = nullptr;\n         CValidationState state;\n         if (!ProcessNewBlockHeaders({cmpctblock.header}, state, chainparams, &pindex)) {\n-            int nDoS;\n+            DoS_SEVERITY nDoS = DoS_SEVERITY::NONE;\n             if (state.IsInvalid(nDoS)) {\n-                if (nDoS > 0) {\n+                if (nDoS > DoS_SEVERITY::NONE) {\n                     LOCK(cs_main);\n                     Misbehaving(pfrom->GetId(), nDoS);\n                 }\n@@ -2069,7 +2071,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 ReadStatus status = partialBlock.InitData(cmpctblock, vExtraTxnForCompact);\n                 if (status == READ_STATUS_INVALID) {\n                     MarkBlockAsReceived(pindex->GetBlockHash()); // Reset in-flight state in case of whitelist\n-                    Misbehaving(pfrom->GetId(), 100);\n+                    Misbehaving(pfrom->GetId(), DoS_SEVERITY::CRITICAL);\n                     LogPrintf(\"Peer %d sent us invalid compact block\\n\", pfrom->GetId());\n                     return true;\n                 } else if (status == READ_STATUS_FAILED) {\n@@ -2186,7 +2188,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             ReadStatus status = partialBlock.FillBlock(*pblock, resp.txn);\n             if (status == READ_STATUS_INVALID) {\n                 MarkBlockAsReceived(resp.blockhash); // Reset in-flight state in case of whitelist\n-                Misbehaving(pfrom->GetId(), 100);\n+                Misbehaving(pfrom->GetId(), DoS_SEVERITY::CRITICAL);\n                 LogPrintf(\"Peer %d sent us invalid compact block/non-matching block transactions\\n\", pfrom->GetId());\n                 return true;\n             } else if (status == READ_STATUS_FAILED) {\n@@ -2245,7 +2247,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         unsigned int nCount = ReadCompactSize(vRecv);\n         if (nCount > MAX_HEADERS_RESULTS) {\n             LOCK(cs_main);\n-            Misbehaving(pfrom->GetId(), 20);\n+            Misbehaving(pfrom->GetId(), DoS_SEVERITY::ELEVATED);\n             return error(\"headers message size = %u\", nCount);\n         }\n         headers.resize(nCount);\n@@ -2286,15 +2288,15 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             UpdateBlockAvailability(pfrom->GetId(), headers.back().GetHash());\n \n             if (nodestate->nUnconnectingHeaders % MAX_UNCONNECTING_HEADERS == 0) {\n-                Misbehaving(pfrom->GetId(), 20);\n+                Misbehaving(pfrom->GetId(), DoS_SEVERITY::ELEVATED);\n             }\n             return true;\n         }\n \n         uint256 hashLastBlock;\n         for (const CBlockHeader& header : headers) {\n             if (!hashLastBlock.IsNull() && header.hashPrevBlock != hashLastBlock) {\n-                Misbehaving(pfrom->GetId(), 20);\n+                Misbehaving(pfrom->GetId(), DoS_SEVERITY::ELEVATED);\n                 return error(\"non-continuous headers sequence\");\n             }\n             hashLastBlock = header.GetHash();\n@@ -2303,9 +2305,9 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n \n         CValidationState state;\n         if (!ProcessNewBlockHeaders(headers, state, chainparams, &pindexLast)) {\n-            int nDoS;\n+            DoS_SEVERITY nDoS = DoS_SEVERITY::NONE;\n             if (state.IsInvalid(nDoS)) {\n-                if (nDoS > 0) {\n+                if (nDoS > DoS_SEVERITY::NONE) {\n                     LOCK(cs_main);\n                     Misbehaving(pfrom->GetId(), nDoS);\n                 }\n@@ -2556,7 +2558,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         {\n             // There is no excuse for sending a too-large filter\n             LOCK(cs_main);\n-            Misbehaving(pfrom->GetId(), 100);\n+            Misbehaving(pfrom->GetId(), DoS_SEVERITY::CRITICAL);\n         }\n         else\n         {\n@@ -2589,7 +2591,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         }\n         if (bad) {\n             LOCK(cs_main);\n-            Misbehaving(pfrom->GetId(), 100);\n+            Misbehaving(pfrom->GetId(), DoS_SEVERITY::CRITICAL);\n         }\n     }\n "
      },
      {
        "sha": "9290f08169abc28ad3c2166e2197ea603eaff388",
        "filename": "src/net_processing.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/863748bdd99f37d655921ba220705cf0bec107fd/src/net_processing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/863748bdd99f37d655921ba220705cf0bec107fd/src/net_processing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.h?ref=863748bdd99f37d655921ba220705cf0bec107fd",
        "patch": "@@ -59,6 +59,7 @@ struct CNodeStateStats {\n /** Get statistics from node state */\n bool GetNodeStateStats(NodeId nodeid, CNodeStateStats &stats);\n /** Increase a node's misbehavior score. */\n-void Misbehaving(NodeId nodeid, int howmuch);\n+enum class DoS_SEVERITY;\n+void Misbehaving(NodeId nodeid, DoS_SEVERITY nDoS);\n \n #endif // BITCOIN_NET_PROCESSING_H"
      },
      {
        "sha": "9e3969e98d50e19bd2cf60af8e79ee298307c542",
        "filename": "src/test/DoS_tests.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 7,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/863748bdd99f37d655921ba220705cf0bec107fd/src/test/DoS_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/863748bdd99f37d655921ba220705cf0bec107fd/src/test/DoS_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/DoS_tests.cpp?ref=863748bdd99f37d655921ba220705cf0bec107fd",
        "patch": "@@ -4,6 +4,7 @@\n \n // Unit tests for denial-of-service detection/prevention code\n \n+#include \"consensus/validation.h\"\n #include \"chainparams.h\"\n #include \"keystore.h\"\n #include \"net.h\"\n@@ -53,7 +54,7 @@ BOOST_AUTO_TEST_CASE(DoS_banning)\n     peerLogic->InitializeNode(&dummyNode1);\n     dummyNode1.nVersion = 1;\n     dummyNode1.fSuccessfullyConnected = true;\n-    Misbehaving(dummyNode1.GetId(), 100); // Should get banned\n+    Misbehaving(dummyNode1.GetId(), DoS_SEVERITY::CRITICAL); // Should get banned\n     peerLogic->SendMessages(&dummyNode1, interruptDummy);\n     BOOST_CHECK(connman->IsBanned(addr1));\n     BOOST_CHECK(!connman->IsBanned(ip(0xa0b0c001|0x0000ff00))); // Different IP, not banned\n@@ -64,11 +65,11 @@ BOOST_AUTO_TEST_CASE(DoS_banning)\n     peerLogic->InitializeNode(&dummyNode2);\n     dummyNode2.nVersion = 1;\n     dummyNode2.fSuccessfullyConnected = true;\n-    Misbehaving(dummyNode2.GetId(), 50);\n+    Misbehaving(dummyNode2.GetId(), DoS_SEVERITY::HIGH);\n     peerLogic->SendMessages(&dummyNode2, interruptDummy);\n     BOOST_CHECK(!connman->IsBanned(addr2)); // 2 not banned yet...\n     BOOST_CHECK(connman->IsBanned(addr1));  // ... but 1 still should be\n-    Misbehaving(dummyNode2.GetId(), 50);\n+    Misbehaving(dummyNode2.GetId(), DoS_SEVERITY::HIGH);\n     peerLogic->SendMessages(&dummyNode2, interruptDummy);\n     BOOST_CHECK(connman->IsBanned(addr2));\n }\n@@ -85,13 +86,13 @@ BOOST_AUTO_TEST_CASE(DoS_banscore)\n     peerLogic->InitializeNode(&dummyNode1);\n     dummyNode1.nVersion = 1;\n     dummyNode1.fSuccessfullyConnected = true;\n-    Misbehaving(dummyNode1.GetId(), 100);\n+    Misbehaving(dummyNode1.GetId(), DoS_SEVERITY::CRITICAL);\n     peerLogic->SendMessages(&dummyNode1, interruptDummy);\n     BOOST_CHECK(!connman->IsBanned(addr1));\n-    Misbehaving(dummyNode1.GetId(), 10);\n+    Misbehaving(dummyNode1.GetId(), DoS_SEVERITY::MEDIUM);\n     peerLogic->SendMessages(&dummyNode1, interruptDummy);\n     BOOST_CHECK(!connman->IsBanned(addr1));\n-    Misbehaving(dummyNode1.GetId(), 1);\n+    Misbehaving(dummyNode1.GetId(), DoS_SEVERITY::LOW);\n     peerLogic->SendMessages(&dummyNode1, interruptDummy);\n     BOOST_CHECK(connman->IsBanned(addr1));\n     gArgs.ForceSetArg(\"-banscore\", std::to_string(DEFAULT_BANSCORE_THRESHOLD));\n@@ -112,7 +113,7 @@ BOOST_AUTO_TEST_CASE(DoS_bantime)\n     dummyNode.nVersion = 1;\n     dummyNode.fSuccessfullyConnected = true;\n \n-    Misbehaving(dummyNode.GetId(), 100);\n+    Misbehaving(dummyNode.GetId(), DoS_SEVERITY::CRITICAL);\n     peerLogic->SendMessages(&dummyNode, interruptDummy);\n     BOOST_CHECK(connman->IsBanned(addr));\n "
      },
      {
        "sha": "2d00cd69e50304ae700d11a72a7846b3e7bd16c9",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 197,
        "deletions": 112,
        "changes": 309,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/863748bdd99f37d655921ba220705cf0bec107fd/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/863748bdd99f37d655921ba220705cf0bec107fd/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=863748bdd99f37d655921ba220705cf0bec107fd",
        "patch": "@@ -459,29 +459,37 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         return false; // state filled in by CheckTransaction\n \n     // Coinbase is only valid in a block, not as a loose transaction\n-    if (tx.IsCoinBase())\n-        return state.DoS(100, false, REJECT_INVALID, \"coinbase\");\n+    if (tx.IsCoinBase()) {\n+        state.BadTx(\"coinbase\", \"coinbase is only valid in a block, not as a loose transaction\");\n+        return false;\n+    }\n \n     // Reject transactions with witness before segregated witness activates (override with -prematurewitness)\n     bool witnessEnabled = IsWitnessEnabled(chainActive.Tip(), chainparams.GetConsensus());\n     if (!gArgs.GetBoolArg(\"-prematurewitness\", false) && tx.HasWitness() && !witnessEnabled) {\n-        return state.DoS(0, false, REJECT_NONSTANDARD, \"no-witness-yet\", true);\n+        state.NonStandardTx(\"no-witness-yet\", \"\", CORRUPTION_POSSIBLE::True);\n+        return false;\n     }\n \n     // Rather not work on nonstandard transactions (unless -testnet/-regtest)\n     std::string reason;\n-    if (fRequireStandard && !IsStandardTx(tx, reason, witnessEnabled))\n-        return state.DoS(0, false, REJECT_NONSTANDARD, reason);\n+    if (fRequireStandard && !IsStandardTx(tx, reason, witnessEnabled)) {\n+        state.NonStandardTx(reason);\n+        return false;\n+    }\n \n     // Only accept nLockTime-using transactions that can be mined in the next\n     // block; we don't want our mempool filled up with transactions that can't\n     // be mined yet.\n-    if (!CheckFinalTx(tx, STANDARD_LOCKTIME_VERIFY_FLAGS))\n-        return state.DoS(0, false, REJECT_NONSTANDARD, \"non-final\");\n+    if (!CheckFinalTx(tx, STANDARD_LOCKTIME_VERIFY_FLAGS)) {\n+        state.NonStandardTx(\"non-final\");\n+        return false;\n+    }\n \n     // is it already in the memory pool?\n     if (pool.exists(hash)) {\n-        return state.Invalid(false, REJECT_DUPLICATE, \"txn-already-in-mempool\");\n+        state.DuplicateData(\"txn-already-in-mempool\");\n+        return false;\n     }\n \n     // Check for conflicts with in-memory transactions\n@@ -521,7 +529,8 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                     }\n                 }\n                 if (fReplacementOptOut) {\n-                    return state.Invalid(false, REJECT_DUPLICATE, \"txn-mempool-conflict\");\n+                    state.DuplicateData(\"txn-mempool-conflict\");\n+                    return false;\n                 }\n \n                 setConflicts.insert(ptxConflicting->GetHash());\n@@ -550,7 +559,8 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                 for (size_t out = 0; out < tx.vout.size(); out++) {\n                     // Optimistically just do efficient check of cache for outputs\n                     if (pcoinsTip->HaveCoinInCache(COutPoint(hash, out))) {\n-                        return state.Invalid(false, REJECT_DUPLICATE, \"txn-already-known\");\n+                        state.DuplicateData(\"txn-already-known\");\n+                        return false;\n                     }\n                 }\n                 // Otherwise assume this might be an orphan tx for which we just haven't seen parents yet\n@@ -572,8 +582,10 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         // be mined yet.\n         // Must keep pool.cs for this unless we change CheckSequenceLocks to take a\n         // CoinsViewCache instead of create its own\n-        if (!CheckSequenceLocks(tx, STANDARD_LOCKTIME_VERIFY_FLAGS, &lp))\n-            return state.DoS(0, false, REJECT_NONSTANDARD, \"non-BIP68-final\");\n+        if (!CheckSequenceLocks(tx, STANDARD_LOCKTIME_VERIFY_FLAGS, &lp)) {\n+            state.NonStandardTx(\"non-BIP68-final\");\n+            return false;\n+        }\n \n         } // end LOCK(pool.cs)\n \n@@ -583,12 +595,16 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         }\n \n         // Check for non-standard pay-to-script-hash in inputs\n-        if (fRequireStandard && !AreInputsStandard(tx, view))\n-            return state.Invalid(false, REJECT_NONSTANDARD, \"bad-txns-nonstandard-inputs\");\n+        if (fRequireStandard && !AreInputsStandard(tx, view)) {\n+            state.NonStandardTx(\"bad-txns-nonstandard-inputs\");\n+            return false;\n+        }\n \n         // Check for non-standard witness in P2WSH\n-        if (tx.HasWitness() && fRequireStandard && !IsWitnessStandard(tx, view))\n-            return state.DoS(0, false, REJECT_NONSTANDARD, \"bad-witness-nonstandard\", true);\n+        if (tx.HasWitness() && fRequireStandard && !IsWitnessStandard(tx, view)) {\n+            state.NonStandardTx(\"bad-witness-nonstandard\", \"\", CORRUPTION_POSSIBLE::True);\n+            return false;\n+        }\n \n         int64_t nSigOpsCost = GetTransactionSigOpCost(tx, view, STANDARD_SCRIPT_VERIFY_FLAGS);\n \n@@ -616,24 +632,28 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         // itself can contain sigops MAX_STANDARD_TX_SIGOPS is less than\n         // MAX_BLOCK_SIGOPS; we still consider this an invalid rather than\n         // merely non-standard transaction.\n-        if (nSigOpsCost > MAX_STANDARD_TX_SIGOPS_COST)\n-            return state.DoS(0, false, REJECT_NONSTANDARD, \"bad-txns-too-many-sigops\", false,\n+        if (nSigOpsCost > MAX_STANDARD_TX_SIGOPS_COST) {\n+            state.NonStandardTx(\"bad-txns-too-many-sigops\",\n                 strprintf(\"%d\", nSigOpsCost));\n+            return false;\n+        }\n \n         CAmount mempoolRejectFee = pool.GetMinFee(gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000).GetFee(nSize);\n         if (!bypass_limits && mempoolRejectFee > 0 && nModifiedFees < mempoolRejectFee) {\n-            return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"mempool min fee not met\", false, strprintf(\"%d < %d\", nFees, mempoolRejectFee));\n+            state.RejectFee(REJECT_INSUFFICIENTFEE, \"mempool min fee not met\", strprintf(\"%d < %d\", nFees, mempoolRejectFee));\n+            return false;\n         }\n \n         // No transactions are allowed below minRelayTxFee except from disconnected blocks\n         if (!bypass_limits && nModifiedFees < ::minRelayTxFee.GetFee(nSize)) {\n-            return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"min relay fee not met\");\n+            state.RejectFee(REJECT_INSUFFICIENTFEE, \"min relay fee not met\");\n+            return false;\n         }\n \n-        if (nAbsurdFee && nFees > nAbsurdFee)\n-            return state.Invalid(false,\n-                REJECT_HIGHFEE, \"absurdly-high-fee\",\n-                strprintf(\"%d > %d\", nFees, nAbsurdFee));\n+        if (nAbsurdFee && nFees > nAbsurdFee) {\n+            state.RejectFee( REJECT_HIGHFEE, \"absurdly-high-fee\", strprintf(\"%d > %d\", nFees, nAbsurdFee));\n+            return false;\n+        }\n \n         // Calculate in-mempool ancestors, up to a limit.\n         CTxMemPool::setEntries setAncestors;\n@@ -643,7 +663,8 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         size_t nLimitDescendantSize = gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000;\n         std::string errString;\n         if (!pool.CalculateMemPoolAncestors(entry, setAncestors, nLimitAncestors, nLimitAncestorSize, nLimitDescendants, nLimitDescendantSize, errString)) {\n-            return state.DoS(0, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", false, errString);\n+            state.NonStandardTx(\"too-long-mempool-chain\", errString);\n+            return false;\n         }\n \n         // A transaction that spends outputs that would be replaced by it is invalid. Now\n@@ -655,11 +676,10 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             const uint256 &hashAncestor = ancestorIt->GetTx().GetHash();\n             if (setConflicts.count(hashAncestor))\n             {\n-                return state.DoS(10, false,\n-                                 REJECT_INVALID, \"bad-txns-spends-conflicting-tx\", false,\n-                                 strprintf(\"%s spends conflicting transaction %s\",\n-                                           hash.ToString(),\n-                                           hashAncestor.ToString()));\n+                state.BadTx(\"bad-txns-spends-conflicting-tx\", strprintf(\"%s spends conflicting transaction %s\",\n+                            hash.ToString(),\n+                            hashAncestor.ToString()), DoS_SEVERITY::MEDIUM);\n+                return false;\n             }\n         }\n \n@@ -709,12 +729,12 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                 CFeeRate oldFeeRate(mi->GetModifiedFee(), mi->GetTxSize());\n                 if (newFeeRate <= oldFeeRate)\n                 {\n-                    return state.DoS(0, false,\n-                            REJECT_INSUFFICIENTFEE, \"insufficient fee\", false,\n+                    state.RejectFee(REJECT_INSUFFICIENTFEE, \"insufficient fee\",\n                             strprintf(\"rejecting replacement %s; new feerate %s <= old feerate %s\",\n                                   hash.ToString(),\n                                   newFeeRate.ToString(),\n                                   oldFeeRate.ToString()));\n+                    return false;\n                 }\n \n                 for (const CTxIn &txin : mi->GetTx().vin)\n@@ -738,12 +758,12 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                     nConflictingSize += it->GetTxSize();\n                 }\n             } else {\n-                return state.DoS(0, false,\n-                        REJECT_NONSTANDARD, \"too many potential replacements\", false,\n+                state.NonStandardTx(\"too many potential replacements\",\n                         strprintf(\"rejecting replacement %s; too many potential replacements (%d > %d)\\n\",\n                             hash.ToString(),\n                             nConflictingCount,\n                             maxDescendantsToVisit));\n+                return false;\n             }\n \n             for (unsigned int j = 0; j < tx.vin.size(); j++)\n@@ -757,11 +777,12 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                     // Rather than check the UTXO set - potentially expensive -\n                     // it's cheaper to just check if the new input refers to a\n                     // tx that's in the mempool.\n-                    if (pool.mapTx.find(tx.vin[j].prevout.hash) != pool.mapTx.end())\n-                        return state.DoS(0, false,\n-                                         REJECT_NONSTANDARD, \"replacement-adds-unconfirmed\", false,\n+                    if (pool.mapTx.find(tx.vin[j].prevout.hash) != pool.mapTx.end()) {\n+                        state.NonStandardTx(\"replacement-adds-unconfirmed\",\n                                          strprintf(\"replacement %s adds unconfirmed input, idx %d\",\n                                                   hash.ToString(), j));\n+                        return false;\n+                    }\n                 }\n             }\n \n@@ -770,23 +791,23 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             // transactions would not be paid for.\n             if (nModifiedFees < nConflictingFees)\n             {\n-                return state.DoS(0, false,\n-                                 REJECT_INSUFFICIENTFEE, \"insufficient fee\", false,\n+                state.RejectFee(REJECT_INSUFFICIENTFEE, \"insufficient fee\",\n                                  strprintf(\"rejecting replacement %s, less fees than conflicting txs; %s < %s\",\n                                           hash.ToString(), FormatMoney(nModifiedFees), FormatMoney(nConflictingFees)));\n+                return false;\n             }\n \n             // Finally in addition to paying more fees than the conflicts the\n             // new transaction must pay for its own bandwidth.\n             CAmount nDeltaFees = nModifiedFees - nConflictingFees;\n             if (nDeltaFees < ::incrementalRelayFee.GetFee(nSize))\n             {\n-                return state.DoS(0, false,\n-                        REJECT_INSUFFICIENTFEE, \"insufficient fee\", false,\n+                state.RejectFee(REJECT_INSUFFICIENTFEE, \"insufficient fee\",\n                         strprintf(\"rejecting replacement %s, not enough additional fees to relay; %s < %s\",\n                               hash.ToString(),\n                               FormatMoney(nDeltaFees),\n                               FormatMoney(::incrementalRelayFee.GetFee(nSize))));\n+                return false;\n             }\n         }\n \n@@ -871,8 +892,10 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         // trim mempool and check if tx was trimmed\n         if (!bypass_limits) {\n             LimitMempoolSize(pool, gArgs.GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000, gArgs.GetArg(\"-mempoolexpiry\", DEFAULT_MEMPOOL_EXPIRY) * 60 * 60);\n-            if (!pool.exists(hash))\n-                return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"mempool full\");\n+            if (!pool.exists(hash)) {\n+                state.RejectFee(REJECT_INSUFFICIENTFEE, \"mempool full\");\n+                return false;\n+            }\n         }\n     }\n \n@@ -1302,8 +1325,10 @@ bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsVi\n                         // non-upgraded nodes.\n                         CScriptCheck check2(coin.out, tx, i,\n                                 flags & ~STANDARD_NOT_MANDATORY_VERIFY_FLAGS, cacheSigStore, &txdata);\n-                        if (check2())\n-                            return state.Invalid(false, REJECT_NONSTANDARD, strprintf(\"non-mandatory-script-verify-flag (%s)\", ScriptErrorString(check.GetScriptError())));\n+                        if (check2()) {\n+                            state.NonStandardTx(strprintf(\"non-mandatory-script-verify-flag (%s)\", ScriptErrorString(check.GetScriptError())));\n+                            return false;\n+                        }\n                     }\n                     // Failures of other flags indicate a transaction that is\n                     // invalid in new blocks, e.g. an invalid P2SH. We DoS ban\n@@ -1312,7 +1337,8 @@ bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsVi\n                     // as to the correct behavior - we may want to continue\n                     // peering with non-upgraded nodes even after soft-fork\n                     // super-majority signaling has occurred.\n-                    return state.DoS(100,false, REJECT_INVALID, strprintf(\"mandatory-script-verify-flag-failed (%s)\", ScriptErrorString(check.GetScriptError())));\n+                    state.BadTx(strprintf(\"mandatory-script-verify-flag-failed (%s)\", ScriptErrorString(check.GetScriptError())));\n+                    return false;\n                 }\n             }\n \n@@ -1397,7 +1423,8 @@ bool AbortNode(const std::string& strMessage, const std::string& userMessage=\"\")\n bool AbortNode(CValidationState& state, const std::string& strMessage, const std::string& userMessage=\"\")\n {\n     AbortNode(strMessage, userMessage);\n-    return state.Error(strMessage);\n+    state.Error(strMessage);\n+    return false;\n }\n \n } // namespace\n@@ -1719,8 +1746,9 @@ static bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockInd\n         for (const auto& tx : block.vtx) {\n             for (size_t o = 0; o < tx->vout.size(); o++) {\n                 if (view.HaveCoin(COutPoint(tx->GetHash(), o))) {\n-                    return state.DoS(100, error(\"ConnectBlock(): tried to overwrite transaction\"),\n-                                     REJECT_INVALID, \"bad-txns-BIP30\");\n+                    error(\"ConnectBlock(): tried to overwrite transaction\");\n+                    state.BadTx(\"bad-txns-BIP30\");\n+                    return false;\n                 }\n             }\n         }\n@@ -1766,8 +1794,9 @@ static bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockInd\n             }\n             nFees += txfee;\n             if (!MoneyRange(nFees)) {\n-                return state.DoS(100, error(\"%s: accumulated fee in the block out of range.\", __func__),\n-                                 REJECT_INVALID, \"bad-txns-accumulated-fee-outofrange\");\n+                error(\"%s: accumulated fee in the block out of range.\", __func__);\n+                state.BadTx(\"bad-txns-accumulated-fee-outofrange\");\n+                return false;\n             }\n \n             // Check that transaction is BIP68 final\n@@ -1779,8 +1808,9 @@ static bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockInd\n             }\n \n             if (!SequenceLocks(tx, nLockTimeFlags, &prevheights, *pindex)) {\n-                return state.DoS(100, error(\"%s: contains a non-BIP68-final transaction\", __func__),\n-                                 REJECT_INVALID, \"bad-txns-nonfinal\");\n+                error(\"%s: contains a non-BIP68-final transaction\", __func__);\n+                state.BadTx(\"bad-txns-nonfinal\");\n+                return false;\n             }\n         }\n \n@@ -1789,9 +1819,11 @@ static bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockInd\n         // * p2sh (when P2SH enabled in flags and excludes coinbase)\n         // * witness (when witness enabled in flags and excludes coinbase)\n         nSigOpsCost += GetTransactionSigOpCost(tx, view, flags);\n-        if (nSigOpsCost > MAX_BLOCK_SIGOPS_COST)\n-            return state.DoS(100, error(\"ConnectBlock(): too many sigops\"),\n-                             REJECT_INVALID, \"bad-blk-sigops\");\n+        if (nSigOpsCost > MAX_BLOCK_SIGOPS_COST) {\n+            error(\"ConnectBlock(): too many sigops\");\n+            state.BadBlock(\"bad-blk-sigops\");\n+            return false;\n+        }\n \n         txdata.emplace_back(tx);\n         if (!tx.IsCoinBase())\n@@ -1817,14 +1849,17 @@ static bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockInd\n     LogPrint(BCLog::BENCH, \"      - Connect %u transactions: %.2fms (%.3fms/tx, %.3fms/txin) [%.2fs (%.2fms/blk)]\\n\", (unsigned)block.vtx.size(), MILLI * (nTime3 - nTime2), MILLI * (nTime3 - nTime2) / block.vtx.size(), nInputs <= 1 ? 0 : MILLI * (nTime3 - nTime2) / (nInputs-1), nTimeConnect * MICRO, nTimeConnect * MILLI / nBlocksTotal);\n \n     CAmount blockReward = nFees + GetBlockSubsidy(pindex->nHeight, chainparams.GetConsensus());\n-    if (block.vtx[0]->GetValueOut() > blockReward)\n-        return state.DoS(100,\n-                         error(\"ConnectBlock(): coinbase pays too much (actual=%d vs limit=%d)\",\n-                               block.vtx[0]->GetValueOut(), blockReward),\n-                               REJECT_INVALID, \"bad-cb-amount\");\n-\n-    if (!control.Wait())\n-        return state.DoS(100, error(\"%s: CheckQueue failed\", __func__), REJECT_INVALID, \"block-validation-failed\");\n+    if (block.vtx[0]->GetValueOut() > blockReward) {\n+        error(\"ConnectBlock(): coinbase pays too much (actual=%d vs limit=%d)\", block.vtx[0]->GetValueOut(), blockReward);\n+        state.BadBlock(\"bad-cb-amount\");\n+        return false;\n+    }\n+\n+    if (!control.Wait()) {\n+        error(\"%s: CheckQueue failed\", __func__);\n+        state.BadBlock(\"block-validation-failed\");\n+        return false;\n+    }\n     int64_t nTime4 = GetTimeMicros(); nTimeVerify += nTime4 - nTime2;\n     LogPrint(BCLog::BENCH, \"    - Verify %u txins: %.2fms (%.3fms/txin) [%.2fs (%.2fms/blk)]\\n\", nInputs - 1, MILLI * (nTime4 - nTime2), nInputs <= 1 ? 0 : MILLI * (nTime4 - nTime2) / (nInputs-1), nTimeVerify * MICRO, nTimeVerify * MILLI / nBlocksTotal);\n \n@@ -1928,8 +1963,10 @@ bool static FlushStateToDisk(const CChainParams& chainparams, CValidationState &\n         // Write blocks and block index to disk.\n         if (fDoFullFlush || fPeriodicWrite) {\n             // Depend on nMinDiskSpace to ensure we can write block index\n-            if (!CheckDiskSpace(0))\n-                return state.Error(\"out of disk space\");\n+            if (!CheckDiskSpace(0)) {\n+                state.Error(\"out of disk space\");\n+                return false;\n+            }\n             // First make sure all block and undo data is flushed to disk.\n             FlushBlockFile();\n             // Then update all block file information (which may refer to block and undo files).\n@@ -1962,8 +1999,10 @@ bool static FlushStateToDisk(const CChainParams& chainparams, CValidationState &\n             // twice (once in the log, and once in the tables). This is already\n             // an overestimation, as most will delete an existing entry or\n             // overwrite one. Still, use a conservative safety factor of 2.\n-            if (!CheckDiskSpace(48 * 2 * 2 * pcoinsTip->GetCacheSize()))\n-                return state.Error(\"out of disk space\");\n+            if (!CheckDiskSpace(48 * 2 * 2 * pcoinsTip->GetCacheSize())) {\n+                state.Error(\"out of disk space\");\n+                return false;\n+            }\n             // Flush the chainstate (which may refer to block index entries).\n             if (!pcoinsTip->Flush())\n                 return AbortNode(state, \"Failed to write to coin database\");\n@@ -2734,8 +2773,10 @@ static bool FindBlockPos(CValidationState &state, CDiskBlockPos &pos, unsigned i\n                     fclose(file);\n                 }\n             }\n-            else\n-                return state.Error(\"out of disk space\");\n+            else {\n+                state.Error(\"out of disk space\");\n+                return false;\n+            }\n         }\n     }\n \n@@ -2767,8 +2808,10 @@ static bool FindUndoPos(CValidationState &state, int nFile, CDiskBlockPos &pos,\n                 fclose(file);\n             }\n         }\n-        else\n-            return state.Error(\"out of disk space\");\n+        else {\n+            state.Error(\"out of disk space\");\n+            return false;\n+        }\n     }\n \n     return true;\n@@ -2777,8 +2820,10 @@ static bool FindUndoPos(CValidationState &state, int nFile, CDiskBlockPos &pos,\n static bool CheckBlockHeader(const CBlockHeader& block, CValidationState& state, const Consensus::Params& consensusParams, bool fCheckPOW = true)\n {\n     // Check proof of work matches claimed amount\n-    if (fCheckPOW && !CheckProofOfWork(block.GetHash(), block.nBits, consensusParams))\n-        return state.DoS(50, false, REJECT_INVALID, \"high-hash\", false, \"proof of work failed\");\n+    if (fCheckPOW && !CheckProofOfWork(block.GetHash(), block.nBits, consensusParams)) {\n+        state.BadBlockHeader(\"high-hash\", \"proof of work failed\", DoS_SEVERITY::HIGH);\n+        return false;\n+    }\n \n     return true;\n }\n@@ -2799,14 +2844,18 @@ bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::P\n     if (fCheckMerkleRoot) {\n         bool mutated;\n         uint256 hashMerkleRoot2 = BlockMerkleRoot(block, &mutated);\n-        if (block.hashMerkleRoot != hashMerkleRoot2)\n-            return state.DoS(100, false, REJECT_INVALID, \"bad-txnmrklroot\", true, \"hashMerkleRoot mismatch\");\n+        if (block.hashMerkleRoot != hashMerkleRoot2) {\n+            state.CorruptBlock(\"bad-txnmrklroot\", \"hashMerkleRoot mismatch\");\n+            return false;\n+        }\n \n         // Check for merkle tree malleability (CVE-2012-2459): repeating sequences\n         // of transactions in a block without affecting the merkle root of a block,\n         // while still invalidating it.\n-        if (mutated)\n-            return state.DoS(100, false, REJECT_INVALID, \"bad-txns-duplicate\", true, \"duplicate transaction\");\n+        if (mutated) {\n+            state.CorruptTx(\"bad-txns-duplicate\", \"duplicate transaction\");\n+            return false;\n+        }\n     }\n \n     // All potential-corruption validation must be done before we do any\n@@ -2816,29 +2865,38 @@ bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::P\n     // checks that use witness data may be performed here.\n \n     // Size limits\n-    if (block.vtx.empty() || block.vtx.size() * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT || ::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT)\n-        return state.DoS(100, false, REJECT_INVALID, \"bad-blk-length\", false, \"size limits failed\");\n+    if (block.vtx.empty() || block.vtx.size() * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT || ::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT) {\n+        state.BadBlock(\"bad-blk-length\", \"size limits failed\");\n+        return false;\n+    }\n \n     // First transaction must be coinbase, the rest must not be\n-    if (block.vtx.empty() || !block.vtx[0]->IsCoinBase())\n-        return state.DoS(100, false, REJECT_INVALID, \"bad-cb-missing\", false, \"first tx is not coinbase\");\n+    if (block.vtx.empty() || !block.vtx[0]->IsCoinBase()) {\n+        state.BadBlock(\"bad-cb-missing\", \"first tx is not coinbase\");\n+        return false;\n+    }\n     for (unsigned int i = 1; i < block.vtx.size(); i++)\n-        if (block.vtx[i]->IsCoinBase())\n-            return state.DoS(100, false, REJECT_INVALID, \"bad-cb-multiple\", false, \"more than one coinbase\");\n+        if (block.vtx[i]->IsCoinBase()) {\n+            state.BadBlock(\"bad-cb-multiple\", \"more than one coinbase\");\n+            return false;\n+        }\n \n     // Check transactions\n     for (const auto& tx : block.vtx)\n-        if (!CheckTransaction(*tx, state, false))\n-            return state.Invalid(false, state.GetRejectCode(), state.GetRejectReason(),\n-                                 strprintf(\"Transaction check failed (tx hash %s) %s\", tx->GetHash().ToString(), state.GetDebugMessage()));\n+        if (!CheckTransaction(*tx, state, false)) {\n+            state.SetDebugMessage(strprintf(\"Transaction check failed (tx hash %s) %s\", tx->GetHash().ToString(), state.GetDebugMessage()));\n+            return false;\n+        }\n \n     unsigned int nSigOps = 0;\n     for (const auto& tx : block.vtx)\n     {\n         nSigOps += GetLegacySigOpCount(*tx);\n     }\n-    if (nSigOps * WITNESS_SCALE_FACTOR > MAX_BLOCK_SIGOPS_COST)\n-        return state.DoS(100, false, REJECT_INVALID, \"bad-blk-sigops\", false, \"out-of-bounds SigOpCount\");\n+    if (nSigOps * WITNESS_SCALE_FACTOR > MAX_BLOCK_SIGOPS_COST) {\n+        state.BadBlock(\"bad-blk-sigops\", \"out-of-bounds SigOpCount\");\n+        return false;\n+    }\n \n     if (fCheckPOW && fCheckMerkleRoot)\n         block.fChecked = true;\n@@ -2918,34 +2976,46 @@ static bool ContextualCheckBlockHeader(const CBlockHeader& block, CValidationSta\n \n     // Check proof of work\n     const Consensus::Params& consensusParams = params.GetConsensus();\n-    if (block.nBits != GetNextWorkRequired(pindexPrev, &block, consensusParams))\n-        return state.DoS(100, false, REJECT_INVALID, \"bad-diffbits\", false, \"incorrect proof of work\");\n+    if (block.nBits != GetNextWorkRequired(pindexPrev, &block, consensusParams)) {\n+        state.BadBlockHeader(\"bad-diffbits\", \"incorrect proof of work\");\n+        return false;\n+    }\n \n     // Check against checkpoints\n     if (fCheckpointsEnabled) {\n         // Don't accept any forks from the main chain prior to last checkpoint.\n         // GetLastCheckpoint finds the last checkpoint in MapCheckpoints that's in our\n         // MapBlockIndex.\n         CBlockIndex* pcheckpoint = Checkpoints::GetLastCheckpoint(params.Checkpoints());\n-        if (pcheckpoint && nHeight < pcheckpoint->nHeight)\n-            return state.DoS(100, error(\"%s: forked chain older than last checkpoint (height %d)\", __func__, nHeight), REJECT_CHECKPOINT, \"bad-fork-prior-to-checkpoint\");\n+        if (pcheckpoint && nHeight < pcheckpoint->nHeight) {\n+            error(\"%s: forked chain older than last checkpoint (height %d)\", __func__, nHeight);\n+            state.ForkingBlockHeaderDisallowed();\n+            return false;\n+        }\n     }\n \n     // Check timestamp against prev\n-    if (block.GetBlockTime() <= pindexPrev->GetMedianTimePast())\n-        return state.Invalid(false, REJECT_INVALID, \"time-too-old\", \"block's timestamp is too early\");\n+    if (block.GetBlockTime() <= pindexPrev->GetMedianTimePast()) {\n+        state.BadBlockHeader(\"time-too-old\", \"block's timestamp is too early\", DoS_SEVERITY::NONE);\n+        return false;\n+    }\n \n     // Check timestamp\n-    if (block.GetBlockTime() > nAdjustedTime + MAX_FUTURE_BLOCK_TIME)\n-        return state.Invalid(false, REJECT_INVALID, \"time-too-new\", \"block timestamp too far in the future\");\n+    if (block.GetBlockTime() > nAdjustedTime + MAX_FUTURE_BLOCK_TIME) {\n+        state.BadBlockHeader(\"time-too-new\", \"block timestamp too far in the future\", DoS_SEVERITY::NONE);\n+        return false;\n+    }\n \n     // Reject outdated version blocks when 95% (75% on testnet) of the network has upgraded:\n     // check for version 2, 3 and 4 upgrades\n     if((block.nVersion < 2 && nHeight >= consensusParams.BIP34Height) ||\n        (block.nVersion < 3 && nHeight >= consensusParams.BIP66Height) ||\n-       (block.nVersion < 4 && nHeight >= consensusParams.BIP65Height))\n-            return state.Invalid(false, REJECT_OBSOLETE, strprintf(\"bad-version(0x%08x)\", block.nVersion),\n-                                 strprintf(\"rejected nVersion=0x%08x block\", block.nVersion));\n+       (block.nVersion < 4 && nHeight >= consensusParams.BIP65Height)) {\n+            state.BadBlockHeader(strprintf(\"bad-version(0x%08x)\", block.nVersion),\n+                                 strprintf(\"rejected nVersion=0x%08x block\", block.nVersion),\n+                                 DoS_SEVERITY::NONE, REJECT_OBSOLETE);\n+            return false;\n+    }\n \n     return true;\n }\n@@ -2967,7 +3037,8 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n     // Check that all transactions are finalized\n     for (const auto& tx : block.vtx) {\n         if (!IsFinalTx(*tx, nHeight, nLockTimeCutoff)) {\n-            return state.DoS(10, false, REJECT_INVALID, \"bad-txns-nonfinal\", false, \"non-final transaction\");\n+            state.BadTx(\"bad-txns-nonfinal\", \"non-final transaction\", DoS_SEVERITY::MEDIUM);\n+            return false;\n         }\n     }\n \n@@ -2977,7 +3048,8 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n         CScript expect = CScript() << nHeight;\n         if (block.vtx[0]->vin[0].scriptSig.size() < expect.size() ||\n             !std::equal(expect.begin(), expect.end(), block.vtx[0]->vin[0].scriptSig.begin())) {\n-            return state.DoS(100, false, REJECT_INVALID, \"bad-cb-height\", false, \"block height mismatch in coinbase\");\n+            state.BadBlock(\"bad-cb-height\", \"block height mismatch in coinbase\");\n+            return false;\n         }\n     }\n \n@@ -2999,11 +3071,13 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n             // already does not permit it, it is impossible to trigger in the\n             // witness tree.\n             if (block.vtx[0]->vin[0].scriptWitness.stack.size() != 1 || block.vtx[0]->vin[0].scriptWitness.stack[0].size() != 32) {\n-                return state.DoS(100, false, REJECT_INVALID, \"bad-witness-nonce-size\", true, strprintf(\"%s : invalid witness nonce size\", __func__));\n+                state.CorruptBlock(\"bad-witness-nonce-size\", strprintf(\"%s : invalid witness nonce size\", __func__));\n+                return false;\n             }\n             CHash256().Write(hashWitness.begin(), 32).Write(&block.vtx[0]->vin[0].scriptWitness.stack[0][0], 32).Finalize(hashWitness.begin());\n             if (memcmp(hashWitness.begin(), &block.vtx[0]->vout[commitpos].scriptPubKey[6], 32)) {\n-                return state.DoS(100, false, REJECT_INVALID, \"bad-witness-merkle-match\", true, strprintf(\"%s : witness merkle commitment mismatch\", __func__));\n+                state.CorruptBlock(\"bad-witness-merkle-match\", strprintf(\"%s : witness merkle commitment mismatch\", __func__));\n+                return false;\n             }\n             fHaveWitness = true;\n         }\n@@ -3013,7 +3087,8 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n     if (!fHaveWitness) {\n       for (const auto& tx : block.vtx) {\n             if (tx->HasWitness()) {\n-                return state.DoS(100, false, REJECT_INVALID, \"unexpected-witness\", true, strprintf(\"%s : unexpected witness data found\", __func__));\n+                state.CorruptBlock(\"unexpected-witness\", strprintf(\"%s : unexpected witness data found\", __func__));\n+                return false;\n             }\n         }\n     }\n@@ -3025,7 +3100,8 @@ static bool ContextualCheckBlock(const CBlock& block, CValidationState& state, c\n     // the block hash, so we couldn't mark the block as permanently\n     // failed).\n     if (GetBlockWeight(block) > MAX_BLOCK_WEIGHT) {\n-        return state.DoS(100, false, REJECT_INVALID, \"bad-blk-weight\", false, strprintf(\"%s : weight limit failed\", __func__));\n+        state.BadBlock(\"bad-blk-weight\", strprintf(\"%s : weight limit failed\", __func__));\n+        return false;\n     }\n \n     return true;\n@@ -3045,8 +3121,11 @@ static bool AcceptBlockHeader(const CBlockHeader& block, CValidationState& state\n             pindex = miSelf->second;\n             if (ppindex)\n                 *ppindex = pindex;\n-            if (pindex->nStatus & BLOCK_FAILED_MASK)\n-                return state.Invalid(error(\"%s: block %s is marked invalid\", __func__, hash.ToString()), 0, \"duplicate\");\n+            if (pindex->nStatus & BLOCK_FAILED_MASK) {\n+                error(\"%s: block %s is marked invalid\", __func__, hash.ToString());\n+                state.BadBlockHeader(\"duplicate\", \"\", DoS_SEVERITY::NONE, 0);\n+                return false;\n+            }\n             return true;\n         }\n \n@@ -3056,11 +3135,17 @@ static bool AcceptBlockHeader(const CBlockHeader& block, CValidationState& state\n         // Get prev block index\n         CBlockIndex* pindexPrev = nullptr;\n         BlockMap::iterator mi = mapBlockIndex.find(block.hashPrevBlock);\n-        if (mi == mapBlockIndex.end())\n-            return state.DoS(10, error(\"%s: prev block not found\", __func__), 0, \"prev-blk-not-found\");\n+        if (mi == mapBlockIndex.end()) {\n+            error(\"%s: prev block not found\", __func__);\n+            state.BadBlockHeader(\"prev-blk-not-found\", \"\", DoS_SEVERITY::MEDIUM);\n+            return false;\n+        }\n         pindexPrev = (*mi).second;\n-        if (pindexPrev->nStatus & BLOCK_FAILED_MASK)\n-            return state.DoS(100, error(\"%s: prev block invalid\", __func__), REJECT_INVALID, \"bad-prevblk\");\n+        if (pindexPrev->nStatus & BLOCK_FAILED_MASK) {\n+            error(\"%s: prev block invalid\", __func__);\n+            state.BadBlock(\"bad-prevblk\");\n+            return false;\n+        }\n         if (!ContextualCheckBlockHeader(block, state, chainparams, pindexPrev, GetAdjustedTime()))\n             return error(\"%s: Consensus::ContextualCheckBlockHeader: %s, %s\", __func__, hash.ToString(), FormatStateMessage(state));\n     }"
      },
      {
        "sha": "81bc19580c07f4669535c0736fda046b13b33ab4",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 0,
        "deletions": 8,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/863748bdd99f37d655921ba220705cf0bec107fd/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/863748bdd99f37d655921ba220705cf0bec107fd/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=863748bdd99f37d655921ba220705cf0bec107fd",
        "patch": "@@ -465,14 +465,6 @@ extern VersionBitsCache versionbitscache;\n  */\n int32_t ComputeBlockVersion(const CBlockIndex* pindexPrev, const Consensus::Params& params);\n \n-/** Reject codes greater or equal to this can be returned by AcceptToMemPool\n- * for transactions, to signal internal conditions. They cannot and should not\n- * be sent over the P2P network.\n- */\n-static const unsigned int REJECT_INTERNAL = 0x100;\n-/** Too high fee. Can not be triggered by P2P transactions */\n-static const unsigned int REJECT_HIGHFEE = 0x100;\n-\n /** Get block file info entry for one block file */\n CBlockFileInfo* GetBlockFileInfo(size_t n);\n "
      }
    ]
  }
]