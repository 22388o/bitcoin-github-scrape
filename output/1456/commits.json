[
  {
    "sha": "9a6ab7f1420691267e78e302ff224076945e9133",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5YTZhYjdmMTQyMDY5MTI2N2U3OGUzMDJmZjIyNDA3Njk0NWU5MTMz",
    "commit": {
      "author": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2012-06-24T21:04:50Z"
      },
      "committer": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2012-07-05T16:42:25Z"
      },
      "message": "Rework gettransaction / getblock RPC calls\n\nThis PULL reworks new (post-0.6.*) features of the\ngettransaction/getblock RPC calls as follows:\n\nIt removes the 'decompositions' object argument from getblock,\nreplacing it just a list of transaction hashes; equivalent\n(I believe) of passing the {\"tx\":\"hash\"} decomposition.\n\nIt replaces the 'decompositions' object argument of\ngettransaction with a boolean flag; if true, returns\nthe same stuff that the {\"script\":\"obj\"} decomposition\nwould return (txins/txouts as hex, disassembled, and bitcoin\naddresses).\n\nIt adds a \"rawtx\" field to the output of gettransaction,\nthat is the entire transaction serialized and hex-encoded.\n\nIt removes the \"size\" field from gettransaction, since the size\nis trivial to compute from the \"rawtx\" field (either take the\nlength after hex-decoding, or just compute it as hex-length/2).",
      "tree": {
        "sha": "932408e289103a55f057eb34751cae5fcca2b2a5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/932408e289103a55f057eb34751cae5fcca2b2a5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9a6ab7f1420691267e78e302ff224076945e9133",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9a6ab7f1420691267e78e302ff224076945e9133",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9a6ab7f1420691267e78e302ff224076945e9133",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9a6ab7f1420691267e78e302ff224076945e9133/comments",
    "author": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fe70b09c428585166f1040e9023251c9c250e894",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fe70b09c428585166f1040e9023251c9c250e894",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fe70b09c428585166f1040e9023251c9c250e894"
      }
    ],
    "stats": {
      "total": 292,
      "additions": 28,
      "deletions": 264
    },
    "files": [
      {
        "sha": "19815ef0fe780d5c364dbb18bc7fb6603301d450",
        "filename": "src/bitcoinrpc.cpp",
        "status": "modified",
        "additions": 28,
        "deletions": 264,
        "changes": 292,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9a6ab7f1420691267e78e302ff224076945e9133/src/bitcoinrpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9a6ab7f1420691267e78e302ff224076945e9133/src/bitcoinrpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoinrpc.cpp?ref=9a6ab7f1420691267e78e302ff224076945e9133",
        "patch": "@@ -137,33 +137,6 @@ EnsureWalletIsUnlocked()\n         throw JSONRPCError(-13, \"Error: Please enter the wallet passphrase with walletpassphrase first.\");\n }\n \n-enum DecomposeMode {\n-    DM_NONE = 0,\n-    DM_HASH,\n-    DM_HEX,\n-    DM_ASM,\n-    DM_OBJ,\n-};\n-\n-enum DecomposeMode\n-FindDecompose(const Object& decompositions, const char* pcType, const char* pcDefault)\n-{\n-    Value val = find_value(decompositions, pcType);\n-    std::string strDecompose = (val.type() == null_type) ? pcDefault : val.get_str();\n-\n-    if (strDecompose == \"no\")\n-        return DM_NONE;\n-    if (strDecompose == \"hash\")\n-        return DM_HASH;\n-    if (strDecompose == \"hex\")\n-        return DM_HEX;\n-    if (strDecompose == \"asm\")\n-        return DM_ASM;\n-    if (strDecompose == \"obj\")\n-        return DM_OBJ;\n-    throw JSONRPCError(-18, \"Invalid decomposition\");\n-}\n-\n void WalletTxToJSON(const CWalletTx& wtx, Object& entry)\n {\n     int confirms = wtx.GetDepthInMainChain();\n@@ -179,141 +152,6 @@ void WalletTxToJSON(const CWalletTx& wtx, Object& entry)\n         entry.push_back(Pair(item.first, item.second));\n }\n \n-void\n-ScriptSigToJSON(const CTxIn& txin, Object& out)\n-{\n-    out.push_back(Pair(\"asm\", txin.scriptSig.ToString()));\n-    out.push_back(Pair(\"hex\", HexStr(txin.scriptSig.begin(), txin.scriptSig.end())));\n-\n-    CTransaction txprev;\n-    uint256 hashTxprevBlock;\n-    if (!GetTransaction(txin.prevout.hash, txprev, hashTxprevBlock))\n-        return;\n-\n-    txnouttype type;\n-    vector<CTxDestination> addresses;\n-    int nRequired;\n-\n-    if (!ExtractDestinations(txprev.vout[txin.prevout.n].scriptPubKey, type,\n-                          addresses, nRequired))\n-    {\n-        out.push_back(Pair(\"type\", GetTxnOutputType(TX_NONSTANDARD)));\n-        return;\n-    }\n-\n-    out.push_back(Pair(\"type\", GetTxnOutputType(type)));\n-    if (type == TX_MULTISIG)\n-    {\n-        // TODO: Need to handle this specially since not all input addresses are required...\n-        return;\n-    }\n-\n-    Array a;\n-    BOOST_FOREACH(const CTxDestination& addr, addresses)\n-        a.push_back(CBitcoinAddress(addr).ToString());\n-    out.push_back(Pair(\"addresses\", a));\n-}\n-\n-void\n-ScriptPubKeyToJSON(const CScript& scriptPubKey, Object& out)\n-{\n-    txnouttype type;\n-    vector<CTxDestination> addresses;\n-    int nRequired;\n-\n-    out.push_back(Pair(\"asm\", scriptPubKey.ToString()));\n-    out.push_back(Pair(\"hex\", HexStr(scriptPubKey.begin(), scriptPubKey.end())));\n-\n-    if (!ExtractDestinations(scriptPubKey, type, addresses, nRequired))\n-    {\n-        out.push_back(Pair(\"type\", GetTxnOutputType(TX_NONSTANDARD)));\n-        return;\n-    }\n-\n-    out.push_back(Pair(\"reqSigs\", nRequired));\n-    out.push_back(Pair(\"type\", GetTxnOutputType(type)));\n-\n-    Array a;\n-    BOOST_FOREACH(const CTxDestination& addr, addresses)\n-        a.push_back(CBitcoinAddress(addr).ToString());\n-    out.push_back(Pair(\"addresses\", a));\n-}\n-\n-void TxToJSON(const CTransaction &tx, Object& entry, const Object& decompositions)\n-{\n-    entry.push_back(Pair(\"version\", tx.nVersion));\n-    entry.push_back(Pair(\"locktime\", (boost::int64_t)tx.nLockTime));\n-    entry.push_back(Pair(\"size\", (boost::int64_t)::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION)));\n-\n-    enum DecomposeMode decomposeScript = FindDecompose(decompositions, \"script\", \"asm\");\n-\n-    Array vin;\n-    BOOST_FOREACH(const CTxIn& txin, tx.vin)\n-    {\n-        Object in;\n-        if (tx.IsCoinBase())\n-            in.push_back(Pair(\"coinbase\", HexStr(txin.scriptSig.begin(), txin.scriptSig.end())));\n-        else\n-        {\n-            Object prevout;\n-            prevout.push_back(Pair(\"hash\", txin.prevout.hash.GetHex()));\n-            prevout.push_back(Pair(\"n\", (boost::int64_t)txin.prevout.n));\n-            in.push_back(Pair(\"prevout\", prevout));\n-            switch (decomposeScript) {\n-            case DM_NONE:\n-                break;\n-            case DM_HEX:\n-                in.push_back(Pair(\"scriptSig\", HexStr(txin.scriptSig.begin(), txin.scriptSig.end())));\n-                break;\n-            case DM_ASM:\n-                in.push_back(Pair(\"scriptSig\", txin.scriptSig.ToString()));\n-                break;\n-            case DM_OBJ:\n-            {\n-                Object o;\n-                ScriptSigToJSON(txin, o);\n-                in.push_back(Pair(\"scriptSig\", o));\n-                break;\n-            }\n-            default:\n-                throw JSONRPCError(-18, \"Invalid script decomposition\");\n-            }\n-        }\n-        in.push_back(Pair(\"sequence\", (boost::int64_t)txin.nSequence));\n-        vin.push_back(in);\n-    }\n-    entry.push_back(Pair(\"vin\", vin));\n-    Array vout;\n-    BOOST_FOREACH(const CTxOut& txout, tx.vout)\n-    {\n-        Object out;\n-        out.push_back(Pair(\"value\", ValueFromAmount(txout.nValue)));\n-        switch (decomposeScript) {\n-        case DM_NONE:\n-            break;\n-        case DM_HEX:\n-            out.push_back(Pair(\"scriptPubKey\", HexStr(txout.scriptPubKey.begin(), txout.scriptPubKey.end())));\n-            break;\n-        case DM_ASM:\n-            out.push_back(Pair(\"scriptPubKey\", txout.scriptPubKey.ToString()));\n-            break;\n-        case DM_OBJ:\n-        {\n-            Object o;\n-            ScriptPubKeyToJSON(txout.scriptPubKey, o);\n-            out.push_back(Pair(\"scriptPubKey\", o));\n-            break;\n-        }\n-        default:\n-            throw JSONRPCError(-18, \"Invalid script decomposition\");\n-        }\n-        vout.push_back(out);\n-    }\n-    entry.push_back(Pair(\"vout\", vout));\n-}\n-\n-void AnyTxToJSON(const uint256 hash, const CTransaction* ptx, Object& entry, const Object& decompositions);\n-\n string AccountFromValue(const Value& value)\n {\n     string strAccount = value.get_str();\n@@ -322,7 +160,7 @@ string AccountFromValue(const Value& value)\n     return strAccount;\n }\n \n-Object blockToJSON(const CBlock& block, const CBlockIndex* blockindex, const Object& decompositions)\n+Object blockToJSON(const CBlock& block, const CBlockIndex* blockindex)\n {\n     Object result;\n     result.push_back(Pair(\"hash\", block.GetHash().GetHex()));\n@@ -333,43 +171,15 @@ Object blockToJSON(const CBlock& block, const CBlockIndex* blockindex, const Obj\n     result.push_back(Pair(\"height\", blockindex->nHeight));\n     result.push_back(Pair(\"version\", block.nVersion));\n     result.push_back(Pair(\"merkleroot\", block.hashMerkleRoot.GetHex()));\n+    Array txs;\n+    BOOST_FOREACH(const CTransaction&tx, block.vtx)\n+        txs.push_back(tx.GetHash().GetHex());\n+    result.push_back(Pair(\"tx\", txs));\n     result.push_back(Pair(\"time\", (boost::int64_t)block.GetBlockTime()));\n     result.push_back(Pair(\"nonce\", (boost::uint64_t)block.nNonce));\n     result.push_back(Pair(\"bits\", HexBits(block.nBits)));\n     result.push_back(Pair(\"difficulty\", GetDifficulty(blockindex)));\n \n-    enum DecomposeMode decomposeTxn = FindDecompose(decompositions, \"tx\", \"hash\");\n-    if (decomposeTxn)\n-    {\n-        Array txs;\n-        switch (decomposeTxn) {\n-        case DM_OBJ:\n-            BOOST_FOREACH (const CTransaction&tx, block.vtx)\n-            {\n-                Object entry;\n-                AnyTxToJSON(tx.GetHash(), &tx, entry, decompositions);\n-                txs.push_back(entry);\n-            }\n-            break;\n-        case DM_HEX:\n-            BOOST_FOREACH (const CTransaction&tx, block.vtx)\n-            {\n-                CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n-                ssTx << tx;\n-\n-                txs.push_back(HexStr(ssTx.begin(), ssTx.end()));\n-            }\n-            break;\n-        case DM_HASH:\n-            BOOST_FOREACH (const CTransaction&tx, block.vtx)\n-                txs.push_back(tx.GetHash().GetHex());\n-            break;\n-        default:\n-            throw JSONRPCError(-18, \"Invalid transaction decomposition\");\n-        }\n-        result.push_back(Pair(\"tx\", txs));\n-    }\n-\n     if (blockindex->pprev)\n         result.push_back(Pair(\"previousblockhash\", blockindex->pprev->GetBlockHash().GetHex()));\n     if (blockindex->pnext)\n@@ -1651,78 +1461,35 @@ Value listsinceblock(const Array& params, bool fHelp)\n     return ret;\n }\n \n-void\n-AnyTxToJSON(const uint256 hash, const CTransaction* ptx, Object& entry, const Object& decompositions)\n-{\n-    if (pwalletMain->mapWallet.count(hash))\n-    {\n-        const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n-\n-        TxToJSON(wtx, entry, decompositions);\n-\n-        int64 nCredit = wtx.GetCredit();\n-        int64 nDebit = wtx.GetDebit();\n-        int64 nNet = nCredit - nDebit;\n-        int64 nFee = (wtx.IsFromMe() ? wtx.GetValueOut() - nDebit : 0);\n-\n-        entry.push_back(Pair(\"amount\", ValueFromAmount(nNet - nFee)));\n-        if (wtx.IsFromMe())\n-            entry.push_back(Pair(\"fee\", ValueFromAmount(nFee)));\n-\n-        WalletTxToJSON(wtx, entry);\n-\n-        Array details;\n-        ListTransactions(pwalletMain->mapWallet[hash], \"*\", 0, false, details);\n-        entry.push_back(Pair(\"details\", details));\n-    }\n-    else\n-    {\n-        CTransaction tx;\n-        uint256 hashBlock = 0;\n-        if ((!ptx) && GetTransaction(hash, tx, hashBlock))\n-            ptx = &tx;\n-        if (ptx)\n-        {\n-            entry.push_back(Pair(\"txid\", hash.GetHex()));\n-            TxToJSON(*ptx, entry, decompositions);\n-            if (hashBlock == 0)\n-                entry.push_back(Pair(\"confirmations\", 0));\n-            else\n-            {\n-                entry.push_back(Pair(\"blockhash\", hashBlock.GetHex()));\n-                map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashBlock);\n-                if (mi != mapBlockIndex.end() && (*mi).second)\n-                {\n-                    CBlockIndex* pindex = (*mi).second;\n-                    if (pindex->IsInMainChain())\n-                    {\n-                        entry.push_back(Pair(\"confirmations\", 1 + nBestHeight - pindex->nHeight));\n-                        entry.push_back(Pair(\"time\", (boost::int64_t)pindex->nTime));\n-                    }\n-                    else\n-                        entry.push_back(Pair(\"confirmations\", 0));\n-                }\n-            }\n-        }\n-        else\n-            throw JSONRPCError(-5, \"No information available about transaction\");\n-    }\n-}\n-\n Value gettransaction(const Array& params, bool fHelp)\n {\n-    if (fHelp || params.size() < 1 || params.size() > 2)\n+    if (fHelp || params.size() != 1)\n         throw runtime_error(\n-            \"gettransaction <txid> [decompositions]\\n\"\n-            \"Get detailed information about <txid>\");\n+            \"gettransaction <txid>\\n\"\n+            \"Get detailed information about in-wallet transaction <txid>\");\n \n     uint256 hash;\n     hash.SetHex(params[0].get_str());\n \n     Object entry;\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(-5, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    int64 nCredit = wtx.GetCredit();\n+    int64 nDebit = wtx.GetDebit();\n+    int64 nNet = nCredit - nDebit;\n+    int64 nFee = (wtx.IsFromMe() ? wtx.GetValueOut() - nDebit : 0);\n+\n+    entry.push_back(Pair(\"amount\", ValueFromAmount(nNet - nFee)));\n+    if (wtx.IsFromMe())\n+        entry.push_back(Pair(\"fee\", ValueFromAmount(nFee)));\n \n-    AnyTxToJSON(hash, NULL, entry,\n-                (params.size() > 1) ? params[1].get_obj() : emptyobj);\n+    WalletTxToJSON(wtx, entry);\n+\n+    Array details;\n+    ListTransactions(wtx, \"*\", 0, false, details);\n+    entry.push_back(Pair(\"details\", details));\n \n     return entry;\n }\n@@ -2226,9 +1993,9 @@ Value getblockhash(const Array& params, bool fHelp)\n \n Value getblock(const Array& params, bool fHelp)\n {\n-    if (fHelp || params.size() < 1 || params.size() > 2)\n+    if (fHelp || params.size() != 1)\n         throw runtime_error(\n-            \"getblock <hash> [decompositions]\\n\"\n+            \"getblock <hash>\\n\"\n             \"Returns details of a block with given block-hash.\");\n \n     std::string strHash = params[0].get_str();\n@@ -2241,8 +2008,7 @@ Value getblock(const Array& params, bool fHelp)\n     CBlockIndex* pblockindex = mapBlockIndex[hash];\n     block.ReadFromDisk(pblockindex, true);\n \n-    return blockToJSON(block, pblockindex,\n-                       (params.size() > 1) ? params[1].get_obj() : emptyobj);\n+    return blockToJSON(block, pblockindex);\n }\n \n Value sendrawtx(const Array& params, bool fHelp)\n@@ -3204,9 +2970,7 @@ Array RPCConvertValues(const std::string &strMethod, const std::vector<std::stri\n     if (strMethod == \"listreceivedbyaccount\"  && n > 0) ConvertTo<boost::int64_t>(params[0]);\n     if (strMethod == \"listreceivedbyaccount\"  && n > 1) ConvertTo<bool>(params[1]);\n     if (strMethod == \"getbalance\"             && n > 1) ConvertTo<boost::int64_t>(params[1]);\n-    if (strMethod == \"getblock\"               && n > 1) ConvertTo<Object>(params[1]);\n     if (strMethod == \"getblockhash\"           && n > 0) ConvertTo<boost::int64_t>(params[0]);\n-    if (strMethod == \"gettransaction\"         && n > 1) ConvertTo<Object>(params[1]);\n     if (strMethod == \"move\"                   && n > 2) ConvertTo<double>(params[2]);\n     if (strMethod == \"move\"                   && n > 3) ConvertTo<boost::int64_t>(params[3]);\n     if (strMethod == \"sendfrom\"               && n > 2) ConvertTo<double>(params[2]);"
      }
    ]
  },
  {
    "sha": "34420d655d8c1cf15e53803ca85e0ac2a2a62fe9",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozNDQyMGQ2NTVkOGMxY2YxNWU1MzgwM2NhODVlMGFjMmEyYTYyZmU5",
    "commit": {
      "author": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2012-06-21T21:05:42Z"
      },
      "committer": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2012-07-05T16:42:25Z"
      },
      "message": "Refactor: SignSignature/VerifyScript\n\nMinor refactor to support signrawtx signing/verifying transactions\nwhen it might only have the previous transaction's txid and\ntxOut.",
      "tree": {
        "sha": "df152867d93162ab6a5a6a52097bbeecc279c705",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/df152867d93162ab6a5a6a52097bbeecc279c705"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/34420d655d8c1cf15e53803ca85e0ac2a2a62fe9",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/34420d655d8c1cf15e53803ca85e0ac2a2a62fe9",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/34420d655d8c1cf15e53803ca85e0ac2a2a62fe9",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/34420d655d8c1cf15e53803ca85e0ac2a2a62fe9/comments",
    "author": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9a6ab7f1420691267e78e302ff224076945e9133",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9a6ab7f1420691267e78e302ff224076945e9133",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9a6ab7f1420691267e78e302ff224076945e9133"
      }
    ],
    "stats": {
      "total": 30,
      "additions": 17,
      "deletions": 13
    },
    "files": [
      {
        "sha": "1451747fa27cc63f2d8f913353c40a385eccf6c1",
        "filename": "src/script.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 13,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/34420d655d8c1cf15e53803ca85e0ac2a2a62fe9/src/script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/34420d655d8c1cf15e53803ca85e0ac2a2a62fe9/src/script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script.cpp?ref=34420d655d8c1cf15e53803ca85e0ac2a2a62fe9",
        "patch": "@@ -1590,19 +1590,17 @@ bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const C\n }\n \n \n-bool SignSignature(const CKeyStore &keystore, const CTransaction& txFrom, CTransaction& txTo, unsigned int nIn, int nHashType)\n+bool SignSignature(const CKeyStore &keystore, const CScript& fromPubKey, CTransaction& txTo, unsigned int nIn, int nHashType)\n {\n     assert(nIn < txTo.vin.size());\n     CTxIn& txin = txTo.vin[nIn];\n-    assert(txin.prevout.n < txFrom.vout.size());\n-    const CTxOut& txout = txFrom.vout[txin.prevout.n];\n \n     // Leave out the signature from the hash, since a signature can't sign itself.\n     // The checksig op will also drop the signatures from its hash.\n-    uint256 hash = SignatureHash(txout.scriptPubKey, txTo, nIn, nHashType);\n+    uint256 hash = SignatureHash(fromPubKey, txTo, nIn, nHashType);\n \n     txnouttype whichType;\n-    if (!Solver(keystore, txout.scriptPubKey, hash, nHashType, txin.scriptSig, whichType))\n+    if (!Solver(keystore, fromPubKey, hash, nHashType, txin.scriptSig, whichType))\n         return false;\n \n     if (whichType == TX_SCRIPTHASH)\n@@ -1623,12 +1621,18 @@ bool SignSignature(const CKeyStore &keystore, const CTransaction& txFrom, CTrans\n     }\n \n     // Test solution\n-    if (!VerifyScript(txin.scriptSig, txout.scriptPubKey, txTo, nIn, true, 0))\n-        return false;\n-\n-    return true;\n+    return VerifyScript(txin.scriptSig, fromPubKey, txTo, nIn, true, 0);\n }\n \n+bool SignSignature(const CKeyStore &keystore, const CTransaction& txFrom, CTransaction& txTo, unsigned int nIn, int nHashType)\n+{\n+    assert(nIn < txTo.vin.size());\n+    CTxIn& txin = txTo.vin[nIn];\n+    assert(txin.prevout.n < txFrom.vout.size());\n+    const CTxOut& txout = txFrom.vout[txin.prevout.n];\n+\n+    return SignSignature(keystore, txout.scriptPubKey, txTo, nIn, nHashType);\n+}\n \n bool VerifySignature(const CTransaction& txFrom, const CTransaction& txTo, unsigned int nIn, bool fValidatePayToScriptHash, int nHashType)\n {\n@@ -1641,10 +1645,7 @@ bool VerifySignature(const CTransaction& txFrom, const CTransaction& txTo, unsig\n     if (txin.prevout.hash != txFrom.GetHash())\n         return false;\n \n-    if (!VerifyScript(txin.scriptSig, txout.scriptPubKey, txTo, nIn, fValidatePayToScriptHash, nHashType))\n-        return false;\n-\n-    return true;\n+    return VerifyScript(txin.scriptSig, txout.scriptPubKey, txTo, nIn, fValidatePayToScriptHash, nHashType);\n }\n \n unsigned int CScript::GetSigOpCount(bool fAccurate) const"
      },
      {
        "sha": "38f346936493cfb1a11650476857e44d30b92630",
        "filename": "src/script.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/34420d655d8c1cf15e53803ca85e0ac2a2a62fe9/src/script.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/34420d655d8c1cf15e53803ca85e0ac2a2a62fe9/src/script.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script.h?ref=34420d655d8c1cf15e53803ca85e0ac2a2a62fe9",
        "patch": "@@ -591,7 +591,10 @@ bool IsMine(const CKeyStore& keystore, const CScript& scriptPubKey);\n bool IsMine(const CKeyStore& keystore, const CTxDestination &dest);\n bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet);\n bool ExtractDestinations(const CScript& scriptPubKey, txnouttype& typeRet, std::vector<CTxDestination>& addressRet, int& nRequiredRet);\n+bool SignSignature(const CKeyStore& keystore, const CScript& fromPubKey, CTransaction& txTo, unsigned int nIn, int nHashType=SIGHASH_ALL);\n bool SignSignature(const CKeyStore& keystore, const CTransaction& txFrom, CTransaction& txTo, unsigned int nIn, int nHashType=SIGHASH_ALL);\n+bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn,\n+                  bool fValidatePayToScriptHash, int nHashType);\n bool VerifySignature(const CTransaction& txFrom, const CTransaction& txTo, unsigned int nIn, bool fValidatePayToScriptHash, int nHashType);\n \n #endif"
      }
    ]
  },
  {
    "sha": "899d373b3ccb3003f8f6e518ba4cf7ba4028e58b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4OTlkMzczYjNjY2IzMDAzZjhmNmU1MThiYTRjZjdiYTQwMjhlNThi",
    "commit": {
      "author": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2012-06-22T22:36:42Z"
      },
      "committer": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2012-07-05T16:42:25Z"
      },
      "message": "RPCTypeCheck method to make type-checking JSON Arrays easier.",
      "tree": {
        "sha": "2e35daa5f4d32a335fee22b6a8a1b28a5a0df768",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2e35daa5f4d32a335fee22b6a8a1b28a5a0df768"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/899d373b3ccb3003f8f6e518ba4cf7ba4028e58b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/899d373b3ccb3003f8f6e518ba4cf7ba4028e58b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/899d373b3ccb3003f8f6e518ba4cf7ba4028e58b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/899d373b3ccb3003f8f6e518ba4cf7ba4028e58b/comments",
    "author": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "34420d655d8c1cf15e53803ca85e0ac2a2a62fe9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/34420d655d8c1cf15e53803ca85e0ac2a2a62fe9",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/34420d655d8c1cf15e53803ca85e0ac2a2a62fe9"
      }
    ],
    "stats": {
      "total": 52,
      "additions": 52,
      "deletions": 0
    },
    "files": [
      {
        "sha": "c9413a5b29724b2c1a854c762a0df803d20535ee",
        "filename": "src/bitcoinrpc.cpp",
        "status": "modified",
        "additions": 37,
        "deletions": 0,
        "changes": 37,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/899d373b3ccb3003f8f6e518ba4cf7ba4028e58b/src/bitcoinrpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/899d373b3ccb3003f8f6e518ba4cf7ba4028e58b/src/bitcoinrpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoinrpc.cpp?ref=899d373b3ccb3003f8f6e518ba4cf7ba4028e58b",
        "patch": "@@ -63,6 +63,43 @@ Object JSONRPCError(int code, const string& message)\n     return error;\n }\n \n+void RPCTypeCheck(const Array& params,\n+                  const list<Value_type>& typesExpected)\n+{\n+    int i = 0;\n+    BOOST_FOREACH(Value_type t, typesExpected)\n+    {\n+        if (params.size() <= i)\n+            break;\n+\n+       const Value& v = params[i];\n+        if (v.type() != t)\n+        {\n+            string err = strprintf(\"Expected type %s, got %s\",\n+                                   Value_type_name[t], Value_type_name[v.type()]);\n+            throw JSONRPCError(-3, err);\n+        }\n+        i++;\n+    }\n+}\n+\n+void RPCTypeCheck(const Object& o,\n+                  const map<string, Value_type>& typesExpected)\n+{\n+    BOOST_FOREACH(const PAIRTYPE(string, Value_type)& t, typesExpected)\n+    {\n+        const Value& v = find_value(o, t.first);\n+        if (v.type() == null_type)\n+            throw JSONRPCError(-3, strprintf(\"Missing %s\", t.first.c_str()));\n+        if (v.type() != t.second)\n+        {\n+            string err = strprintf(\"Expected type %s for %s, got %s\",\n+                                   Value_type_name[t.second], t.first.c_str(), Value_type_name[v.type()]);\n+            throw JSONRPCError(-3, err);\n+        }\n+    }\n+}\n+\n double GetDifficulty(const CBlockIndex* blockindex = NULL)\n {\n     // Floating point number that is a multiple of the minimum difficulty,"
      },
      {
        "sha": "b71d17ef29f19651a98a87417393d54f20a18a38",
        "filename": "src/bitcoinrpc.h",
        "status": "modified",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/899d373b3ccb3003f8f6e518ba4cf7ba4028e58b/src/bitcoinrpc.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/899d373b3ccb3003f8f6e518ba4cf7ba4028e58b/src/bitcoinrpc.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoinrpc.h?ref=899d373b3ccb3003f8f6e518ba4cf7ba4028e58b",
        "patch": "@@ -7,6 +7,7 @@\n #define _BITCOINRPC_H_ 1\n \n #include <string>\n+#include <list>\n #include <map>\n \n #include \"json/json_spirit_reader_template.h\"\n@@ -21,6 +22,20 @@ int CommandLineRPC(int argc, char *argv[]);\n /** Convert parameter values for RPC call from strings to command-specific JSON objects. */\n json_spirit::Array RPCConvertValues(const std::string &strMethod, const std::vector<std::string> &strParams);\n \n+/*\n+  Type-check arguments; throws JSONRPCError if wrong type given. Does not check that\n+  the right number of arguments are passed, just that any passed are the correct type.\n+  Use like:  RPCTypeCheck(params, boost::assign::list_of(str_type)(int_type)(obj_type));\n+*/\n+void RPCTypeCheck(const json_spirit::Array& params,\n+                  const std::list<json_spirit::Value_type>& typesExpected);\n+/*\n+  Check for expected keys/value types in an Object.\n+  Use like: RPCTypeCheck(object, boost::assign::map_list_of(\"name\", str_type)(\"value\", int_type));\n+*/\n+void RPCTypeCheck(const json_spirit::Object& o,\n+                  const std::map<std::string, json_spirit::Value_type>& typesExpected);\n+\n typedef json_spirit::Value(*rpcfn_type)(const json_spirit::Array& params, bool fHelp);\n \n class CRPCCommand"
      }
    ]
  },
  {
    "sha": "a2709fad7f57b000333371954016045e12fc4bed",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphMjcwOWZhZDdmNTdiMDAwMzMzMzcxOTU0MDE2MDQ1ZTEyZmM0YmVk",
    "commit": {
      "author": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2012-05-31T20:01:16Z"
      },
      "committer": {
        "name": "Gavin Andresen",
        "email": "gavinandresen@gmail.com",
        "date": "2012-07-05T16:50:09Z"
      },
      "message": "Implement raw transaction RPC calls\n\nImplement listunspent / getrawtransaction / createrawtransaction /\nsignrawtransaction, to support creation and\nsigning-on-multiple-device multisignature transactions.",
      "tree": {
        "sha": "378022e0c8b67dbd02a138b792bdb7be777e5822",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/378022e0c8b67dbd02a138b792bdb7be777e5822"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a2709fad7f57b000333371954016045e12fc4bed",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a2709fad7f57b000333371954016045e12fc4bed",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a2709fad7f57b000333371954016045e12fc4bed",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a2709fad7f57b000333371954016045e12fc4bed/comments",
    "author": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gavinandresen",
      "id": 331997,
      "node_id": "MDQ6VXNlcjMzMTk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/331997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gavinandresen",
      "html_url": "https://github.com/gavinandresen",
      "followers_url": "https://api.github.com/users/gavinandresen/followers",
      "following_url": "https://api.github.com/users/gavinandresen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gavinandresen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gavinandresen/subscriptions",
      "organizations_url": "https://api.github.com/users/gavinandresen/orgs",
      "repos_url": "https://api.github.com/users/gavinandresen/repos",
      "events_url": "https://api.github.com/users/gavinandresen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gavinandresen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "899d373b3ccb3003f8f6e518ba4cf7ba4028e58b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/899d373b3ccb3003f8f6e518ba4cf7ba4028e58b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/899d373b3ccb3003f8f6e518ba4cf7ba4028e58b"
      }
    ],
    "stats": {
      "total": 806,
      "additions": 750,
      "deletions": 56
    },
    "files": [
      {
        "sha": "22f624d59c1cec936f26cdaf2fd2378a7987987a",
        "filename": "bitcoin-qt.pro",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a2709fad7f57b000333371954016045e12fc4bed/bitcoin-qt.pro",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a2709fad7f57b000333371954016045e12fc4bed/bitcoin-qt.pro",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/bitcoin-qt.pro?ref=a2709fad7f57b000333371954016045e12fc4bed",
        "patch": "@@ -207,6 +207,7 @@ SOURCES += src/qt/bitcoin.cpp src/qt/bitcoingui.cpp \\\n     src/bitcoinrpc.cpp \\\n     src/rpcdump.cpp \\\n     src/rpcnet.cpp \\\n+    src/rpcrawtransaction.cpp \\\n     src/qt/overviewpage.cpp \\\n     src/qt/csvmodelwriter.cpp \\\n     src/crypter.cpp \\"
      },
      {
        "sha": "adcf359c9f1f2f4ccd2270d49c51ca7f05258547",
        "filename": "src/bitcoinrpc.cpp",
        "status": "modified",
        "additions": 23,
        "deletions": 43,
        "changes": 66,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a2709fad7f57b000333371954016045e12fc4bed/src/bitcoinrpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a2709fad7f57b000333371954016045e12fc4bed/src/bitcoinrpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoinrpc.cpp?ref=a2709fad7f57b000333371954016045e12fc4bed",
        "patch": "@@ -46,10 +46,16 @@ static std::string strRPCUserColonPass;\n static int64 nWalletUnlockTime;\n static CCriticalSection cs_nWalletUnlockTime;\n \n-extern Value getconnectioncount(const Array& params, bool fHelp);\n+extern Value getconnectioncount(const Array& params, bool fHelp); // in rpcnet.cpp\n extern Value getpeerinfo(const Array& params, bool fHelp);\n-extern Value dumpprivkey(const Array& params, bool fHelp);\n+extern Value dumpprivkey(const Array& params, bool fHelp); // in rpcdump.cpp\n extern Value importprivkey(const Array& params, bool fHelp);\n+extern Value getrawtransaction(const Array& params, bool fHelp); // in rcprawtransaction.cpp\n+extern Value listunspent(const Array& params, bool fHelp);\n+extern Value createrawtransaction(const Array& params, bool fHelp);\n+extern Value decoderawtransaction(const Array& params, bool fHelp);\n+extern Value signrawtransaction(const Array& params, bool fHelp);\n+extern Value sendrawtransaction(const Array& params, bool fHelp);\n \n const Object emptyobj;\n \n@@ -159,15 +165,15 @@ HexBits(unsigned int nBits)\n     return HexStr(BEGIN(uBits.cBits), END(uBits.cBits));\n }\n \n-static std::string\n+std::string\n HelpRequiringPassphrase()\n {\n     return pwalletMain->IsCrypted()\n         ? \"\\nrequires wallet passphrase to be set with walletpassphrase first\"\n         : \"\";\n }\n \n-static inline void\n+void\n EnsureWalletIsUnlocked()\n {\n     if (pwalletMain->IsLocked())\n@@ -2048,44 +2054,6 @@ Value getblock(const Array& params, bool fHelp)\n     return blockToJSON(block, pblockindex);\n }\n \n-Value sendrawtx(const Array& params, bool fHelp)\n-{\n-    if (fHelp || params.size() < 1 || params.size() > 1)\n-        throw runtime_error(\n-            \"sendrawtx <hex string>\\n\"\n-            \"Submits raw transaction (serialized, hex-encoded) to local node and network.\");\n-\n-    // parse hex string from parameter\n-    vector<unsigned char> txData(ParseHex(params[0].get_str()));\n-    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n-    CTransaction tx;\n-\n-    // deserialize binary data stream\n-    try {\n-        ssData >> tx;\n-    }\n-    catch (std::exception &e) {\n-        throw JSONRPCError(-22, \"TX decode failed\");\n-    }\n-\n-    // push to local node\n-    CTxDB txdb(\"r\");\n-    if (!tx.AcceptToMemoryPool(txdb))\n-        throw JSONRPCError(-22, \"TX rejected\");\n-\n-    SyncWithWallets(tx, NULL, true);\n-\n-    // relay to network\n-    CInv inv(MSG_TX, tx.GetHash());\n-    RelayInventory(inv);\n-\n-    return tx.GetHash().GetHex();\n-}\n-\n-\n-\n-\n-\n \n \n \n@@ -2147,7 +2115,12 @@ static const CRPCCommand vRPCCommands[] =\n     { \"listsinceblock\",         &listsinceblock,         false },\n     { \"dumpprivkey\",            &dumpprivkey,            false },\n     { \"importprivkey\",          &importprivkey,          false },\n-    { \"sendrawtx\",              &sendrawtx,              false },\n+    { \"listunspent\",            &listunspent,            false },\n+    { \"getrawtransaction\",      &getrawtransaction,      false },\n+    { \"createrawtransaction\",   &createrawtransaction,   false },\n+    { \"decoderawtransaction\",   &decoderawtransaction,   false },\n+    { \"signrawtransaction\",     &signrawtransaction,     false },\n+    { \"sendrawtransaction\",     &sendrawtransaction,     false },\n };\n \n CRPCTable::CRPCTable()\n@@ -3021,6 +2994,13 @@ Array RPCConvertValues(const std::string &strMethod, const std::vector<std::stri\n     if (strMethod == \"sendmany\"               && n > 2) ConvertTo<boost::int64_t>(params[2]);\n     if (strMethod == \"addmultisigaddress\"     && n > 0) ConvertTo<boost::int64_t>(params[0]);\n     if (strMethod == \"addmultisigaddress\"     && n > 1) ConvertTo<Array>(params[1]);\n+    if (strMethod == \"listunspent\"            && n > 0) ConvertTo<boost::int64_t>(params[0]);\n+    if (strMethod == \"listunspent\"            && n > 1) ConvertTo<boost::int64_t>(params[1]);\n+    if (strMethod == \"getrawtransaction\"      && n > 1) ConvertTo<boost::int64_t>(params[1]);\n+    if (strMethod == \"createrawtransaction\"   && n > 0) ConvertTo<Array>(params[0]);\n+    if (strMethod == \"createrawtransaction\"   && n > 1) ConvertTo<Object>(params[1]);\n+    if (strMethod == \"signrawtransaction\"     && n > 1) ConvertTo<Array>(params[1]);\n+    if (strMethod == \"signrawtransaction\"     && n > 2) ConvertTo<Array>(params[2]);\n \n     return params;\n }"
      },
      {
        "sha": "e7cbb47046b1426666ec4ead8ea1bc3c81c63c9a",
        "filename": "src/makefile.linux-mingw",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a2709fad7f57b000333371954016045e12fc4bed/src/makefile.linux-mingw",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a2709fad7f57b000333371954016045e12fc4bed/src/makefile.linux-mingw",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.linux-mingw?ref=a2709fad7f57b000333371954016045e12fc4bed",
        "patch": "@@ -61,6 +61,7 @@ OBJS= \\\n     obj/bitcoinrpc.o \\\n     obj/rpcdump.o \\\n     obj/rpcnet.o \\\n+    obj/rpcrawtransaction.o \\\n     obj/script.o \\\n     obj/sync.o \\\n     obj/util.o \\"
      },
      {
        "sha": "e60b3201ff3d3368dcf95cd455b534f9969ac622",
        "filename": "src/makefile.mingw",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a2709fad7f57b000333371954016045e12fc4bed/src/makefile.mingw",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a2709fad7f57b000333371954016045e12fc4bed/src/makefile.mingw",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.mingw?ref=a2709fad7f57b000333371954016045e12fc4bed",
        "patch": "@@ -58,6 +58,7 @@ OBJS= \\\n     obj/bitcoinrpc.o \\\n     obj/rpcdump.o \\\n     obj/rpcnet.o \\\n+    obj/rpcrawtransaction.o \\\n     obj/script.o \\\n     obj/sync.o \\\n     obj/util.o \\"
      },
      {
        "sha": "f9f28267bed664679f83c2fb8104c001e7a532ec",
        "filename": "src/makefile.osx",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a2709fad7f57b000333371954016045e12fc4bed/src/makefile.osx",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a2709fad7f57b000333371954016045e12fc4bed/src/makefile.osx",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.osx?ref=a2709fad7f57b000333371954016045e12fc4bed",
        "patch": "@@ -85,6 +85,7 @@ OBJS= \\\n     obj/bitcoinrpc.o \\\n     obj/rpcdump.o \\\n     obj/rpcnet.o \\\n+    obj/rpcrawtransaction.o \\\n     obj/script.o \\\n     obj/sync.o \\\n     obj/util.o \\"
      },
      {
        "sha": "2784335a20cfd764ef44168a40025ef4ca62024e",
        "filename": "src/makefile.unix",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a2709fad7f57b000333371954016045e12fc4bed/src/makefile.unix",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a2709fad7f57b000333371954016045e12fc4bed/src/makefile.unix",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/makefile.unix?ref=a2709fad7f57b000333371954016045e12fc4bed",
        "patch": "@@ -105,6 +105,7 @@ OBJS= \\\n     obj/bitcoinrpc.o \\\n     obj/rpcdump.o \\\n     obj/rpcnet.o \\\n+    obj/rpcrawtransaction.o \\\n     obj/script.o \\\n     obj/sync.o \\\n     obj/util.o \\"
      },
      {
        "sha": "0e8c806834c5a9f5f9f4e5c35f3a257a39fe9968",
        "filename": "src/rpcrawtransaction.cpp",
        "status": "added",
        "additions": 470,
        "deletions": 0,
        "changes": 470,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a2709fad7f57b000333371954016045e12fc4bed/src/rpcrawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a2709fad7f57b000333371954016045e12fc4bed/src/rpcrawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcrawtransaction.cpp?ref=a2709fad7f57b000333371954016045e12fc4bed",
        "patch": "@@ -0,0 +1,470 @@\n+// Copyright (c) 2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2012 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <boost/assign/list_of.hpp>\n+\n+#include \"base58.h\"\n+#include \"bitcoinrpc.h\"\n+#include \"db.h\"\n+#include \"init.h\"\n+#include \"main.h\"\n+#include \"wallet.h\"\n+\n+using namespace std;\n+using namespace boost;\n+using namespace boost::assign;\n+using namespace json_spirit;\n+\n+// These are all in bitcoinrpc.cpp:\n+extern Object JSONRPCError(int code, const string& message);\n+extern int64 AmountFromValue(const Value& value);\n+extern Value ValueFromAmount(int64 amount);\n+extern std::string HelpRequiringPassphrase();\n+extern void EnsureWalletIsUnlocked();\n+\n+void\n+ScriptPubKeyToJSON(const CScript& scriptPubKey, Object& out)\n+{\n+    txnouttype type;\n+    vector<CTxDestination> addresses;\n+    int nRequired;\n+\n+    out.push_back(Pair(\"asm\", scriptPubKey.ToString()));\n+    out.push_back(Pair(\"hex\", HexStr(scriptPubKey.begin(), scriptPubKey.end())));\n+\n+    if (!ExtractDestinations(scriptPubKey, type, addresses, nRequired))\n+    {\n+        out.push_back(Pair(\"type\", GetTxnOutputType(TX_NONSTANDARD)));\n+        return;\n+    }\n+\n+    out.push_back(Pair(\"reqSigs\", nRequired));\n+    out.push_back(Pair(\"type\", GetTxnOutputType(type)));\n+\n+    Array a;\n+    BOOST_FOREACH(const CTxDestination& addr, addresses)\n+        a.push_back(CBitcoinAddress(addr).ToString());\n+    out.push_back(Pair(\"addresses\", a));\n+}\n+\n+void\n+TxToJSON(const CTransaction& tx, const uint256 hashBlock, Object& entry)\n+{\n+    entry.push_back(Pair(\"txid\", tx.GetHash().GetHex()));\n+    entry.push_back(Pair(\"version\", tx.nVersion));\n+    entry.push_back(Pair(\"locktime\", (boost::int64_t)tx.nLockTime));\n+    Array vin;\n+    BOOST_FOREACH(const CTxIn& txin, tx.vin)\n+    {\n+        Object in;\n+        if (tx.IsCoinBase())\n+            in.push_back(Pair(\"coinbase\", HexStr(txin.scriptSig.begin(), txin.scriptSig.end())));\n+        else\n+        {\n+            in.push_back(Pair(\"txid\", txin.prevout.hash.GetHex()));\n+            in.push_back(Pair(\"vout\", (boost::int64_t)txin.prevout.n));\n+            Object o;\n+            o.push_back(Pair(\"asm\", txin.scriptSig.ToString()));\n+            o.push_back(Pair(\"hex\", HexStr(txin.scriptSig.begin(), txin.scriptSig.end())));\n+            in.push_back(Pair(\"scriptSig\", o));\n+        }\n+        in.push_back(Pair(\"sequence\", (boost::int64_t)txin.nSequence));\n+        vin.push_back(in);\n+    }\n+    entry.push_back(Pair(\"vin\", vin));\n+    Array vout;\n+    for (int i = 0; i < tx.vout.size(); i++)\n+    {\n+        const CTxOut& txout = tx.vout[i];\n+        Object out;\n+        out.push_back(Pair(\"value\", ValueFromAmount(txout.nValue)));\n+        out.push_back(Pair(\"n\", i));\n+        Object o;\n+        ScriptPubKeyToJSON(txout.scriptPubKey, o);\n+        out.push_back(Pair(\"scriptPubKey\", o));\n+        vout.push_back(out);\n+    }\n+    entry.push_back(Pair(\"vout\", vout));\n+\n+    if (hashBlock != 0)\n+    {\n+        entry.push_back(Pair(\"blockhash\", hashBlock.GetHex()));\n+        map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashBlock);\n+        if (mi != mapBlockIndex.end() && (*mi).second)\n+        {\n+            CBlockIndex* pindex = (*mi).second;\n+            if (pindex->IsInMainChain())\n+            {\n+                entry.push_back(Pair(\"confirmations\", 1 + nBestHeight - pindex->nHeight));\n+                entry.push_back(Pair(\"time\", (boost::int64_t)pindex->nTime));\n+            }\n+            else\n+                entry.push_back(Pair(\"confirmations\", 0));\n+        }\n+    }\n+}\n+\n+Value getrawtransaction(const Array& params, bool fHelp)\n+{\n+    if (fHelp || params.size() < 1 || params.size() > 2)\n+        throw runtime_error(\n+            \"getrawtransaction <txid> [verbose=0]\\n\"\n+            \"If verbose=0, returns a string that is\\n\"\n+            \"serialized, hex-encoded data for <txid>.\\n\"\n+            \"If verbose is non-zero, returns an Object\\n\"\n+            \"with information about <txid>.\");\n+\n+    uint256 hash;\n+    hash.SetHex(params[0].get_str());\n+\n+    bool fVerbose = false;\n+    if (params.size() > 1)\n+        fVerbose = (params[1].get_int() != 0);\n+\n+    CTransaction tx;\n+    uint256 hashBlock = 0;\n+    if (!GetTransaction(hash, tx, hashBlock))\n+        throw JSONRPCError(-5, \"No information available about transaction\");\n+\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << tx;\n+    string strHex = HexStr(ssTx.begin(), ssTx.end());\n+\n+    if (!fVerbose)\n+        return strHex;\n+\n+    Object result;\n+    result.push_back(Pair(\"hex\", strHex));\n+    TxToJSON(tx, hashBlock, result);\n+    return result;\n+}\n+\n+Value listunspent(const Array& params, bool fHelp)\n+{\n+    if (fHelp || params.size() > 2)\n+        throw runtime_error(\n+            \"listunspent [minconf=1] [maxconf=999999]\\n\"\n+            \"Returns array of unspent transaction outputs\\n\"\n+            \"with between minconf and maxconf (inclusive) confirmations.\\n\"\n+            \"Results are an array of Objects, each of which has:\\n\"\n+            \"{txid, vout, scriptPubKey, amount, confirmations}\");\n+\n+    RPCTypeCheck(params, list_of(int_type)(int_type));\n+\n+    int nMinDepth = 1;\n+    if (params.size() > 0)\n+        nMinDepth = params[0].get_int();\n+\n+    int nMaxDepth = 999999;\n+    if (params.size() > 1)\n+        nMaxDepth = params[1].get_int();\n+\n+    Array results;\n+    vector<COutput> vecOutputs;\n+    pwalletMain->AvailableCoins(vecOutputs, false);\n+    BOOST_FOREACH(const COutput& out, vecOutputs)\n+    {\n+        if (out.nDepth < nMinDepth || out.nDepth > nMaxDepth)\n+            continue;\n+\n+        int64 nValue = out.tx->vout[out.i].nValue;\n+        const CScript& pk = out.tx->vout[out.i].scriptPubKey;\n+        Object entry;\n+        entry.push_back(Pair(\"txid\", out.tx->GetHash().GetHex()));\n+        entry.push_back(Pair(\"vout\", out.i));\n+        entry.push_back(Pair(\"scriptPubKey\", HexStr(pk.begin(), pk.end())));\n+        entry.push_back(Pair(\"amount\",ValueFromAmount(nValue)));\n+        entry.push_back(Pair(\"confirmations\",out.nDepth));\n+        results.push_back(entry);\n+    }\n+\n+    return results;\n+}\n+\n+Value createrawtransaction(const Array& params, bool fHelp)\n+{\n+    if (fHelp || params.size() != 2)\n+        throw runtime_error(\n+            \"createrawtransaction [{\\\"txid\\\":txid,\\\"vout\\\":n},...] {address:amount,...}\\n\"\n+            \"Create a transaction spending given inputs\\n\"\n+            \"(array of objects containing transaction id and output number),\\n\"\n+            \"sending to given address(es).\\n\"\n+            \"Returns hex-encoded raw transaction.\\n\"\n+            \"Note that the transaction's inputs are not signed, and\\n\"\n+            \"it is not stored in the wallet or transmitted to the network.\");\n+\n+    RPCTypeCheck(params, list_of(array_type)(obj_type));\n+\n+    Array inputs = params[0].get_array();\n+    Object sendTo = params[1].get_obj();\n+\n+    CTransaction rawTx;\n+\n+    BOOST_FOREACH(Value& input, inputs)\n+    {\n+        const Object& o = input.get_obj();\n+\n+        const Value& txid_v = find_value(o, \"txid\");\n+        if (txid_v.type() != str_type)\n+            throw JSONRPCError(-8, \"Invalid parameter, missing txid key\");\n+        string txid = txid_v.get_str();\n+        if (!IsHex(txid))\n+            throw JSONRPCError(-8, \"Invalid parameter, expected hex txid\");\n+\n+        const Value& vout_v = find_value(o, \"vout\");\n+        if (vout_v.type() != int_type)\n+            throw JSONRPCError(-8, \"Invalid parameter, missing vout key\");\n+        int nOutput = vout_v.get_int();\n+        if (nOutput < 0)\n+            throw JSONRPCError(-8, \"Invalid parameter, vout must be positive\");\n+\n+        CTxIn in(COutPoint(uint256(txid), nOutput));\n+        rawTx.vin.push_back(in);\n+    }\n+\n+    set<CBitcoinAddress> setAddress;\n+    BOOST_FOREACH(const Pair& s, sendTo)\n+    {\n+        CBitcoinAddress address(s.name_);\n+        if (!address.IsValid())\n+            throw JSONRPCError(-5, string(\"Invalid Bitcoin address:\")+s.name_);\n+\n+        if (setAddress.count(address))\n+            throw JSONRPCError(-8, string(\"Invalid parameter, duplicated address: \")+s.name_);\n+        setAddress.insert(address);\n+\n+        CScript scriptPubKey;\n+        scriptPubKey.SetDestination(address.Get());\n+        int64 nAmount = AmountFromValue(s.value_);\n+\n+        CTxOut out(nAmount, scriptPubKey);\n+        rawTx.vout.push_back(out);\n+    }\n+\n+    CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n+    ss << rawTx;\n+    return HexStr(ss.begin(), ss.end());\n+}\n+\n+Value decoderawtransaction(const Array& params, bool fHelp)\n+{\n+    if (fHelp || params.size() != 1)\n+        throw runtime_error(\n+            \"decoderawtransaction <hex string>\\n\"\n+            \"Return a JSON object representing the serialized, hex-encoded transaction.\");\n+\n+    RPCTypeCheck(params, list_of(str_type));\n+\n+    vector<unsigned char> txData(ParseHex(params[0].get_str()));\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    CTransaction tx;\n+    try {\n+        ssData >> tx;\n+    }\n+    catch (std::exception &e) {\n+        throw JSONRPCError(-22, \"TX decode failed\");\n+    }\n+\n+    Object result;\n+    TxToJSON(tx, 0, result);\n+\n+    return result;\n+}\n+\n+Value signrawtransaction(const Array& params, bool fHelp)\n+{\n+    if (fHelp || params.size() < 1 || params.size() > 3)\n+        throw runtime_error(\n+            \"signrawtransaction <hex string> [{\\\"txid\\\":txid,\\\"vout\\\":n,\\\"scriptPubKey\\\":hex},...] [<privatekey1>,...]\\n\"\n+            \"Sign inputs for raw transaction (serialized, hex-encoded).\\n\"\n+            \"Second optional argument is an array of previous transaction outputs that\\n\"\n+            \"this transaction depends on but may not yet be in the blockchain.\\n\"\n+            \"Third optional argument is an array of base58-encoded private\\n\"\n+            \"keys that, if given, will be the only keys used to sign the transaction.\\n\"\n+            \"Returns json object with keys:\\n\"\n+            \"  hex : raw transaction with signature(s) (hex-encoded string)\\n\"\n+            \"  complete : 1 if transaction has a complete set of signature (0 if not)\"\n+            + HelpRequiringPassphrase());\n+\n+    if (params.size() < 3)\n+        EnsureWalletIsUnlocked();\n+\n+    RPCTypeCheck(params, list_of(str_type)(array_type)(array_type));\n+\n+    vector<unsigned char> txData(ParseHex(params[0].get_str()));\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    vector<CTransaction> txVariants;\n+    while (!ssData.empty())\n+    {\n+        try {\n+            CTransaction tx;\n+            ssData >> tx;\n+            txVariants.push_back(tx);\n+        }\n+        catch (std::exception &e) {\n+            throw JSONRPCError(-22, \"TX decode failed\");\n+        }\n+    }\n+\n+    if (txVariants.empty())\n+        throw JSONRPCError(-22, \"Missing transaction\");\n+\n+    // mergedTx will end up with all the signatures; it\n+    // starts as a clone of the rawtx:\n+    CTransaction mergedTx(txVariants[0]);\n+    bool fComplete = true;\n+\n+    // Fetch previous transactions (inputs):\n+    map<COutPoint, CScript> mapPrevOut;\n+    {\n+        MapPrevTx mapPrevTx;\n+        CTxDB txdb(\"r\");\n+        map<uint256, CTxIndex> unused;\n+        bool fInvalid;\n+        mergedTx.FetchInputs(txdb, unused, false, false, mapPrevTx, fInvalid);\n+\n+        // Copy results into mapPrevOut:\n+        BOOST_FOREACH(const CTxIn& txin, mergedTx.vin)\n+        {\n+            const uint256& prevHash = txin.prevout.hash;\n+            if (mapPrevTx.count(prevHash))\n+                mapPrevOut[txin.prevout] = mapPrevTx[prevHash].second.vout[txin.prevout.n].scriptPubKey;\n+        }\n+    }\n+\n+    // Add previous txouts given in the RPC call:\n+    if (params.size() > 1)\n+    {\n+        Array prevTxs = params[1].get_array();\n+        BOOST_FOREACH(Value& p, prevTxs)\n+        {\n+            if (p.type() != obj_type)\n+                throw JSONRPCError(-22, \"expected object with {\\\"txid'\\\",\\\"vout\\\",\\\"scriptPubKey\\\"}\");\n+\n+            Object prevOut = p.get_obj();\n+\n+            RPCTypeCheck(prevOut, map_list_of(\"txid\", str_type)(\"vout\", int_type)(\"scriptPubKey\", str_type));\n+\n+            string txidHex = find_value(prevOut, \"txid\").get_str();\n+            if (!IsHex(txidHex))\n+                throw JSONRPCError(-22, \"txid must be hexadecimal\");\n+            uint256 txid;\n+            txid.SetHex(txidHex);\n+\n+            int nOut = find_value(prevOut, \"vout\").get_int();\n+            if (nOut < 0)\n+                throw JSONRPCError(-22, \"vout must be positive\");\n+\n+            string pkHex = find_value(prevOut, \"scriptPubKey\").get_str();\n+            if (!IsHex(pkHex))\n+                throw JSONRPCError(-22, \"scriptPubKey must be hexadecimal\");\n+            vector<unsigned char> pkData(ParseHex(pkHex));\n+            CScript scriptPubKey(pkData.begin(), pkData.end());\n+\n+            COutPoint outpoint(txid, nOut);\n+            if (mapPrevOut.count(outpoint))\n+            {\n+                // Complain if scriptPubKey doesn't match\n+                if (mapPrevOut[outpoint] != scriptPubKey)\n+                {\n+                    string err(\"Previous output scriptPubKey mismatch:\\n\");\n+                    err = err + mapPrevOut[outpoint].ToString() + \"\\nvs:\\n\"+\n+                        scriptPubKey.ToString();\n+                    throw JSONRPCError(-22, err);\n+                }\n+            }\n+            else\n+                mapPrevOut[outpoint] = scriptPubKey;\n+        }\n+    }\n+\n+    bool fGivenKeys = false;\n+    CBasicKeyStore tempKeystore;\n+    if (params.size() > 2)\n+    {\n+        fGivenKeys = true;\n+        Array keys = params[2].get_array();\n+        BOOST_FOREACH(Value k, keys)\n+        {\n+            CBitcoinSecret vchSecret;\n+            bool fGood = vchSecret.SetString(k.get_str());\n+            if (!fGood)\n+                throw JSONRPCError(-5,\"Invalid private key\");\n+            CKey key;\n+            bool fCompressed;\n+            CSecret secret = vchSecret.GetSecret(fCompressed);\n+            key.SetSecret(secret, fCompressed);\n+            tempKeystore.AddKey(key);\n+        }\n+    }\n+    const CKeyStore& keystore = (fGivenKeys ? tempKeystore : *pwalletMain);\n+\n+    // Sign what we can:\n+    for (int i = 0; i < mergedTx.vin.size(); i++)\n+    {\n+        CTxIn& txin = mergedTx.vin[i];\n+        if (mapPrevOut.count(txin.prevout) == 0)\n+        {\n+            fComplete = false;\n+            continue;\n+        }\n+        const CScript& prevPubKey = mapPrevOut[txin.prevout];\n+\n+        txin.scriptSig.clear();\n+        SignSignature(keystore, prevPubKey, mergedTx, i);\n+\n+        // ... and merge in other signatures:\n+        BOOST_FOREACH(const CTransaction& txv, txVariants)\n+        {\n+            txin.scriptSig = CombineSignatures(prevPubKey, mergedTx, i, txin.scriptSig, txv.vin[i].scriptSig);\n+        }\n+        if (!VerifyScript(txin.scriptSig, prevPubKey, mergedTx, i, true, 0))\n+            fComplete = false;\n+    }\n+\n+    Object result;\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << mergedTx;\n+    result.push_back(Pair(\"hex\", HexStr(ssTx.begin(), ssTx.end())));\n+    result.push_back(Pair(\"complete\", fComplete));\n+\n+    return result;\n+}\n+\n+Value sendrawtransaction(const Array& params, bool fHelp)\n+{\n+    if (fHelp || params.size() < 1 || params.size() > 1)\n+        throw runtime_error(\n+            \"sendrawtransaction <hex string>\\n\"\n+            \"Submits raw transaction (serialized, hex-encoded) to local node and network.\");\n+\n+    RPCTypeCheck(params, list_of(str_type));\n+\n+    // parse hex string from parameter\n+    vector<unsigned char> txData(ParseHex(params[0].get_str()));\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    CTransaction tx;\n+\n+    // deserialize binary data stream\n+    try {\n+        ssData >> tx;\n+    }\n+    catch (std::exception &e) {\n+        throw JSONRPCError(-22, \"TX decode failed\");\n+    }\n+\n+    // push to local node\n+    CTxDB txdb(\"r\");\n+    if (!tx.AcceptToMemoryPool(txdb))\n+        throw JSONRPCError(-22, \"TX rejected\");\n+\n+    SyncWithWallets(tx, NULL, true);\n+\n+    // relay to network\n+    CInv inv(MSG_TX, tx.GetHash());\n+    RelayInventory(inv);\n+\n+    return tx.GetHash().GetHex();\n+}"
      },
      {
        "sha": "103fc0e422fc04cb47b541d525f65bea032f51cf",
        "filename": "src/script.cpp",
        "status": "modified",
        "additions": 129,
        "deletions": 10,
        "changes": 139,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a2709fad7f57b000333371954016045e12fc4bed/src/script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a2709fad7f57b000333371954016045e12fc4bed/src/script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script.cpp?ref=a2709fad7f57b000333371954016045e12fc4bed",
        "patch": "@@ -1331,15 +1331,12 @@ bool SignN(const vector<valtype>& multisigdata, const CKeyStore& keystore, uint2\n {\n     int nSigned = 0;\n     int nRequired = multisigdata.front()[0];\n-    for (vector<valtype>::const_iterator it = multisigdata.begin()+1; it != multisigdata.begin()+multisigdata.size()-1; it++)\n+    for (int i = 1; i < multisigdata.size()-1 && nSigned < nRequired; i++)\n     {\n-        const valtype& pubkey = *it;\n+        const valtype& pubkey = multisigdata[i];\n         CKeyID keyID = CPubKey(pubkey).GetID();\n         if (Sign1(keyID, keystore, hash, nHashType, scriptSigRet))\n-        {\n             ++nSigned;\n-            if (nSigned == nRequired) break;\n-        }\n     }\n     return nSigned==nRequired;\n }\n@@ -1612,12 +1609,13 @@ bool SignSignature(const CKeyStore &keystore, const CScript& fromPubKey, CTransa\n \n         // Recompute txn hash using subscript in place of scriptPubKey:\n         uint256 hash2 = SignatureHash(subscript, txTo, nIn, nHashType);\n+\n         txnouttype subType;\n-        if (!Solver(keystore, subscript, hash2, nHashType, txin.scriptSig, subType))\n-            return false;\n-        if (subType == TX_SCRIPTHASH)\n-            return false;\n-        txin.scriptSig << static_cast<valtype>(subscript); // Append serialized subscript\n+        bool fSolved =\n+            Solver(keystore, subscript, hash2, nHashType, txin.scriptSig, subType) && subType != TX_SCRIPTHASH;\n+        // Append serialized subscript whether or not it is completely signed:\n+        txin.scriptSig << static_cast<valtype>(subscript);\n+        if (!fSolved) return false;\n     }\n \n     // Test solution\n@@ -1648,6 +1646,127 @@ bool VerifySignature(const CTransaction& txFrom, const CTransaction& txTo, unsig\n     return VerifyScript(txin.scriptSig, txout.scriptPubKey, txTo, nIn, fValidatePayToScriptHash, nHashType);\n }\n \n+static CScript PushAll(const vector<valtype>& values)\n+{\n+    CScript result;\n+    BOOST_FOREACH(const valtype& v, values)\n+        result << v;\n+    return result;\n+}\n+\n+static CScript CombineMultisig(CScript scriptPubKey, const CTransaction& txTo, unsigned int nIn,\n+                               const vector<valtype>& vSolutions,\n+                               vector<valtype>& sigs1, vector<valtype>& sigs2)\n+{\n+    // Combine all the signatures we've got:\n+    set<valtype> allsigs;\n+    BOOST_FOREACH(const valtype& v, sigs1)\n+    {\n+        if (!v.empty())\n+            allsigs.insert(v);\n+    }\n+    BOOST_FOREACH(const valtype& v, sigs2)\n+    {\n+        if (!v.empty())\n+            allsigs.insert(v);\n+    }\n+\n+    // Build a map of pubkey -> signature by matching sigs to pubkeys:\n+    int nSigsRequired = vSolutions.front()[0];\n+    int nPubKeys = vSolutions.size()-2;\n+    map<valtype, valtype> sigs;\n+    BOOST_FOREACH(const valtype& sig, allsigs)\n+    {\n+        for (int i = 0; i < nPubKeys; i++)\n+        {\n+            const valtype& pubkey = vSolutions[i+1];\n+            if (sigs.count(pubkey))\n+                continue; // Already got a sig for this pubkey\n+\n+            if (CheckSig(sig, pubkey, scriptPubKey, txTo, nIn, 0))\n+            {\n+                sigs[pubkey] = sig;\n+                break;\n+            }\n+        }\n+    }\n+    // Now build a merged CScript:\n+    unsigned int nSigsHave = 0;\n+    CScript result; result << OP_0; // pop-one-too-many workaround\n+    for (int i = 0; i < nPubKeys && nSigsHave < nSigsRequired; i++)\n+    {\n+        if (sigs.count(vSolutions[i+1]))\n+        {\n+            result << sigs[vSolutions[i+1]];\n+            ++nSigsHave;\n+        }\n+    }\n+    // Fill any missing with OP_0:\n+    for (int i = nSigsHave; i < nSigsRequired; i++)\n+        result << OP_0;\n+\n+    return result;\n+}\n+\n+static CScript CombineSignatures(CScript scriptPubKey, const CTransaction& txTo, unsigned int nIn,\n+                                 const txnouttype txType, const vector<valtype>& vSolutions,\n+                                 vector<valtype>& sigs1, vector<valtype>& sigs2)\n+{\n+    switch (txType)\n+    {\n+    case TX_NONSTANDARD:\n+        // Don't know anything about this, assume bigger one is correct:\n+        if (sigs1.size() >= sigs2.size())\n+            return PushAll(sigs1);\n+        return PushAll(sigs2);\n+    case TX_PUBKEY:\n+    case TX_PUBKEYHASH:\n+        // Signatures are bigger than placeholders or empty scripts:\n+        if (sigs1.empty() || sigs1[0].empty())\n+            return PushAll(sigs2);\n+        return PushAll(sigs1);\n+    case TX_SCRIPTHASH:\n+        if (sigs1.empty() || sigs1.back().empty())\n+            return PushAll(sigs2);\n+        else if (sigs2.empty() || sigs2.back().empty())\n+            return PushAll(sigs1);\n+        else\n+        {\n+            // Recurse to combine:\n+            valtype spk = sigs1.back();\n+            CScript pubKey2(spk.begin(), spk.end());\n+\n+            txnouttype txType2;\n+            vector<vector<unsigned char> > vSolutions2;\n+            Solver(pubKey2, txType2, vSolutions2);\n+            sigs1.pop_back();\n+            sigs2.pop_back();\n+            CScript result = CombineSignatures(pubKey2, txTo, nIn, txType2, vSolutions2, sigs1, sigs2);\n+            result << spk;\n+            return result;\n+        }\n+    case TX_MULTISIG:\n+        return CombineMultisig(scriptPubKey, txTo, nIn, vSolutions, sigs1, sigs2);\n+    }\n+\n+    return CScript();\n+}\n+\n+CScript CombineSignatures(CScript scriptPubKey, const CTransaction& txTo, unsigned int nIn,\n+                          const CScript& scriptSig1, const CScript& scriptSig2)\n+{\n+    txnouttype txType;\n+    vector<vector<unsigned char> > vSolutions;\n+    Solver(scriptPubKey, txType, vSolutions);\n+\n+    vector<valtype> stack1;\n+    EvalScript(stack1, scriptSig1, CTransaction(), 0, 0);\n+    vector<valtype> stack2;\n+    EvalScript(stack2, scriptSig2, CTransaction(), 0, 0);\n+\n+    return CombineSignatures(scriptPubKey, txTo, nIn, txType, vSolutions, stack1, stack2);\n+}\n+\n unsigned int CScript::GetSigOpCount(bool fAccurate) const\n {\n     unsigned int n = 0;"
      },
      {
        "sha": "f4db112dd69fd71c1975ed43870b02020f118f4c",
        "filename": "src/script.h",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a2709fad7f57b000333371954016045e12fc4bed/src/script.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a2709fad7f57b000333371954016045e12fc4bed/src/script.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script.h?ref=a2709fad7f57b000333371954016045e12fc4bed",
        "patch": "@@ -597,4 +597,8 @@ bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const C\n                   bool fValidatePayToScriptHash, int nHashType);\n bool VerifySignature(const CTransaction& txFrom, const CTransaction& txTo, unsigned int nIn, bool fValidatePayToScriptHash, int nHashType);\n \n+// Given two sets of signatures for scriptPubKey, possibly with OP_0 placeholders,\n+// combine them intelligently and return the result.\n+CScript CombineSignatures(CScript scriptPubKey, const CTransaction& txTo, unsigned int nIn, const CScript& scriptSig1, const CScript& scriptSig2);\n+\n #endif"
      },
      {
        "sha": "61d9a64eebb2dc3158386402250072ed0182cbe5",
        "filename": "src/test/script_tests.cpp",
        "status": "modified",
        "additions": 113,
        "deletions": 0,
        "changes": 113,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a2709fad7f57b000333371954016045e12fc4bed/src/test/script_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a2709fad7f57b000333371954016045e12fc4bed/src/test/script_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_tests.cpp?ref=a2709fad7f57b000333371954016045e12fc4bed",
        "patch": "@@ -328,5 +328,118 @@ BOOST_AUTO_TEST_CASE(script_CHECKMULTISIG23)\n     BOOST_CHECK(!VerifyScript(badsig6, scriptPubKey23, txTo23, 0, true, 0));\n }    \n \n+BOOST_AUTO_TEST_CASE(script_combineSigs)\n+{\n+    // Test the CombineSignatures function\n+    CBasicKeyStore keystore;\n+    vector<CKey> keys;\n+    for (int i = 0; i < 3; i++)\n+    {\n+        CKey key;\n+        key.MakeNewKey(i%2 == 1);\n+        keys.push_back(key);\n+        keystore.AddKey(key);\n+    }\n+\n+    CTransaction txFrom;\n+    txFrom.vout.resize(1);\n+    txFrom.vout[0].scriptPubKey.SetDestination(keys[0].GetPubKey().GetID());\n+    CScript& scriptPubKey = txFrom.vout[0].scriptPubKey;\n+    CTransaction txTo;\n+    txTo.vin.resize(1);\n+    txTo.vout.resize(1);\n+    txTo.vin[0].prevout.n = 0;\n+    txTo.vin[0].prevout.hash = txFrom.GetHash();\n+    CScript& scriptSig = txTo.vin[0].scriptSig;\n+    txTo.vout[0].nValue = 1;\n+\n+    CScript empty;\n+    CScript combined = CombineSignatures(scriptPubKey, txTo, 0, empty, empty);\n+    BOOST_CHECK(combined.empty());\n+\n+    // Single signature case:\n+    SignSignature(keystore, txFrom, txTo, 0); // changes scriptSig\n+    combined = CombineSignatures(scriptPubKey, txTo, 0, scriptSig, empty);\n+    BOOST_CHECK(combined == scriptSig);\n+    combined = CombineSignatures(scriptPubKey, txTo, 0, empty, scriptSig);\n+    BOOST_CHECK(combined == scriptSig);\n+    CScript scriptSigCopy = scriptSig;\n+    // Signing again will give a different, valid signature:\n+    SignSignature(keystore, txFrom, txTo, 0);\n+    combined = CombineSignatures(scriptPubKey, txTo, 0, scriptSigCopy, scriptSig);\n+    BOOST_CHECK(combined == scriptSigCopy || combined == scriptSig);\n+\n+    // P2SH, single-signature case:\n+    CScript pkSingle; pkSingle << keys[0].GetPubKey() << OP_CHECKSIG;\n+    keystore.AddCScript(pkSingle);\n+    scriptPubKey.SetDestination(pkSingle.GetID());\n+    SignSignature(keystore, txFrom, txTo, 0);\n+    combined = CombineSignatures(scriptPubKey, txTo, 0, scriptSig, empty);\n+    BOOST_CHECK(combined == scriptSig);\n+    combined = CombineSignatures(scriptPubKey, txTo, 0, empty, scriptSig);\n+    BOOST_CHECK(combined == scriptSig);\n+    scriptSigCopy = scriptSig;\n+    SignSignature(keystore, txFrom, txTo, 0);\n+    combined = CombineSignatures(scriptPubKey, txTo, 0, scriptSigCopy, scriptSig);\n+    BOOST_CHECK(combined == scriptSigCopy || combined == scriptSig);\n+    // dummy scriptSigCopy with placeholder, should always choose non-placeholder:\n+    scriptSigCopy = CScript() << OP_0 << static_cast<vector<unsigned char> >(pkSingle);\n+    combined = CombineSignatures(scriptPubKey, txTo, 0, scriptSigCopy, scriptSig);\n+    BOOST_CHECK(combined == scriptSig);\n+    combined = CombineSignatures(scriptPubKey, txTo, 0, scriptSig, scriptSigCopy);\n+    BOOST_CHECK(combined == scriptSig);\n+\n+    // Hardest case:  Multisig 2-of-3\n+    scriptPubKey.SetMultisig(2, keys);\n+    keystore.AddCScript(scriptPubKey);\n+    SignSignature(keystore, txFrom, txTo, 0);\n+    combined = CombineSignatures(scriptPubKey, txTo, 0, scriptSig, empty);\n+    BOOST_CHECK(combined == scriptSig);\n+    combined = CombineSignatures(scriptPubKey, txTo, 0, empty, scriptSig);\n+    BOOST_CHECK(combined == scriptSig);\n+\n+    // A couple of partially-signed versions:\n+    vector<unsigned char> sig1;\n+    uint256 hash1 = SignatureHash(scriptPubKey, txTo, 0, SIGHASH_ALL);\n+    BOOST_CHECK(keys[0].Sign(hash1, sig1));\n+    sig1.push_back(SIGHASH_ALL);\n+    vector<unsigned char> sig2;\n+    uint256 hash2 = SignatureHash(scriptPubKey, txTo, 0, SIGHASH_NONE);\n+    BOOST_CHECK(keys[1].Sign(hash2, sig2));\n+    sig2.push_back(SIGHASH_NONE);\n+    vector<unsigned char> sig3;\n+    uint256 hash3 = SignatureHash(scriptPubKey, txTo, 0, SIGHASH_SINGLE);\n+    BOOST_CHECK(keys[2].Sign(hash3, sig3));\n+    sig3.push_back(SIGHASH_SINGLE);\n+\n+    // Not fussy about order (or even existence) of placeholders or signatures:\n+    CScript partial1a = CScript() << OP_0 << sig1 << OP_0;\n+    CScript partial1b = CScript() << OP_0 << OP_0 << sig1;\n+    CScript partial2a = CScript() << OP_0 << sig2;\n+    CScript partial2b = CScript() << sig2 << OP_0;\n+    CScript partial3a = CScript() << sig3;\n+    CScript partial3b = CScript() << OP_0 << OP_0 << sig3;\n+    CScript partial3c = CScript() << OP_0 << sig3 << OP_0;\n+    CScript complete12 = CScript() << OP_0 << sig1 << sig2;\n+    CScript complete13 = CScript() << OP_0 << sig1 << sig3;\n+    CScript complete23 = CScript() << OP_0 << sig2 << sig3;\n+\n+    combined = CombineSignatures(scriptPubKey, txTo, 0, partial1a, partial1b);\n+    BOOST_CHECK(combined == partial1a);\n+    combined = CombineSignatures(scriptPubKey, txTo, 0, partial1a, partial2a);\n+    BOOST_CHECK(combined == complete12);\n+    combined = CombineSignatures(scriptPubKey, txTo, 0, partial2a, partial1a);\n+    BOOST_CHECK(combined == complete12);\n+    combined = CombineSignatures(scriptPubKey, txTo, 0, partial1b, partial2b);\n+    BOOST_CHECK(combined == complete12);\n+    combined = CombineSignatures(scriptPubKey, txTo, 0, partial3b, partial1b);\n+    BOOST_CHECK(combined == complete13);\n+    combined = CombineSignatures(scriptPubKey, txTo, 0, partial2a, partial3a);\n+    BOOST_CHECK(combined == complete23);\n+    combined = CombineSignatures(scriptPubKey, txTo, 0, partial3b, partial2b);\n+    BOOST_CHECK(combined == complete23);\n+    combined = CombineSignatures(scriptPubKey, txTo, 0, partial3b, partial3a);\n+    BOOST_CHECK(combined == partial3c);\n+}\n \n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "4d99ce656050cc5ff9d80297a418cb8d950cbe00",
        "filename": "src/wallet.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 2,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a2709fad7f57b000333371954016045e12fc4bed/src/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a2709fad7f57b000333371954016045e12fc4bed/src/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.cpp?ref=a2709fad7f57b000333371954016045e12fc4bed",
        "patch": "@@ -899,7 +899,7 @@ int64 CWallet::GetImmatureBalance() const\n }\n \n // populate vCoins with vector of spendable COutputs\n-void CWallet::AvailableCoins(vector<COutput>& vCoins) const\n+void CWallet::AvailableCoins(vector<COutput>& vCoins, bool fOnlyConfirmed) const\n {\n     vCoins.clear();\n \n@@ -909,7 +909,10 @@ void CWallet::AvailableCoins(vector<COutput>& vCoins) const\n         {\n             const CWalletTx* pcoin = &(*it).second;\n \n-            if (!pcoin->IsFinal() || !pcoin->IsConfirmed())\n+            if (!pcoin->IsFinal())\n+                continue;\n+\n+            if (fOnlyConfirmed && !pcoin->IsConfirmed())\n                 continue;\n \n             if (pcoin->IsCoinBase() && pcoin->GetBlocksToMaturity() > 0)"
      },
      {
        "sha": "5bf38699ef31f1ce873d5262d544fd12cda615aa",
        "filename": "src/wallet.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a2709fad7f57b000333371954016045e12fc4bed/src/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a2709fad7f57b000333371954016045e12fc4bed/src/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.h?ref=a2709fad7f57b000333371954016045e12fc4bed",
        "patch": "@@ -61,7 +61,6 @@ class CKeyPool\n class CWallet : public CCryptoKeyStore\n {\n private:\n-    void AvailableCoins(std::vector<COutput>& vCoins) const;\n     bool SelectCoins(int64 nTargetValue, std::set<std::pair<const CWalletTx*,unsigned int> >& setCoinsRet, int64& nValueRet) const;\n \n     CWalletDB *pwalletdbEncryption;\n@@ -113,6 +112,7 @@ class CWallet : public CCryptoKeyStore\n     // check whether we are allowed to upgrade (or already support) to the named feature\n     bool CanSupportFeature(enum WalletFeature wf) { return nWalletMaxVersion >= wf; }\n \n+    void AvailableCoins(std::vector<COutput>& vCoins, bool fOnlyConfirmed=true) const;\n     bool SelectCoinsMinConf(int64 nTargetValue, int nConfMine, int nConfTheirs, std::vector<COutput> vCoins, std::set<std::pair<const CWalletTx*,unsigned int> >& setCoinsRet, int64& nValueRet) const;\n \n     // keystore implementation"
      }
    ]
  }
]