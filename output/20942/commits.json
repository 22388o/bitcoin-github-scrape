[
  {
    "sha": "9781c08a33569370f191b30cc7e2ce9b5317eb3e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5NzgxYzA4YTMzNTY5MzcwZjE5MWIzMGNjN2UyY2U5YjUzMTdlYjNl",
    "commit": {
      "author": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2020-12-23T08:14:00Z"
      },
      "committer": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2021-01-29T15:26:09Z"
      },
      "message": "net_processing: move some globals into PeerManagerImpl\n\nnSyncStarted, mapBlockSource, g_wtxid_relay_peers,\ng_outbound_peers_with_protect_from_disconnect were all only used by\nPeerManagerImpl methods already.",
      "tree": {
        "sha": "31bad38f27d056660eeb97fa7ae1a422e9ef7422",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/31bad38f27d056660eeb97fa7ae1a422e9ef7422"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9781c08a33569370f191b30cc7e2ce9b5317eb3e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9781c08a33569370f191b30cc7e2ce9b5317eb3e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9781c08a33569370f191b30cc7e2ce9b5317eb3e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9781c08a33569370f191b30cc7e2ce9b5317eb3e/comments",
    "author": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c8b83510f42c6959c2844b8b81a6590dd3a34e65",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c8b83510f42c6959c2844b8b81a6590dd3a34e65",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c8b83510f42c6959c2844b8b81a6590dd3a34e65"
      }
    ],
    "stats": {
      "total": 38,
      "additions": 19,
      "deletions": 19
    },
    "files": [
      {
        "sha": "721b4f56ec9e1ba4f13323aeb33ae9e3e3eccb0b",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 19,
        "deletions": 19,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9781c08a33569370f191b30cc7e2ce9b5317eb3e/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9781c08a33569370f191b30cc7e2ce9b5317eb3e/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=9781c08a33569370f191b30cc7e2ce9b5317eb3e",
        "patch": "@@ -345,10 +345,7 @@ class PeerManagerImpl final : public PeerManager\n      * their own locks.\n      */\n     std::map<NodeId, PeerRef> m_peer_map GUARDED_BY(m_peer_mutex);\n-};\n-} // namespace\n \n-namespace {\n     /** Number of nodes with fSyncStarted. */\n     int nSyncStarted GUARDED_BY(cs_main) = 0;\n \n@@ -360,6 +357,15 @@ namespace {\n      */\n     std::map<uint256, std::pair<NodeId, bool>> mapBlockSource GUARDED_BY(cs_main);\n \n+    /** Number of peers with wtxid relay. */\n+    int m_wtxid_relay_peers GUARDED_BY(cs_main) = 0;\n+\n+    /** Number of outbound peers with m_chain_sync.m_protect. */\n+    int m_outbound_peers_with_protect_from_disconnect GUARDED_BY(cs_main) = 0;\n+};\n+} // namespace\n+\n+namespace {\n     /**\n      * Filter for transactions that were recently rejected by\n      * AcceptToMemoryPool. These are not rerequested until the chain tip\n@@ -423,12 +429,6 @@ namespace {\n     /** Number of peers from which we're downloading blocks. */\n     int nPeersWithValidatedDownloads GUARDED_BY(cs_main) = 0;\n \n-    /** Number of peers with wtxid relay. */\n-    int g_wtxid_relay_peers GUARDED_BY(cs_main) = 0;\n-\n-    /** Number of outbound peers with m_chain_sync.m_protect. */\n-    int g_outbound_peers_with_protect_from_disconnect GUARDED_BY(cs_main) = 0;\n-\n     /** When our tip was last updated. */\n     std::atomic<int64_t> g_last_tip_update(0);\n \n@@ -911,7 +911,7 @@ void PeerManagerImpl::AddTxAnnouncement(const CNode& node, const GenTxid& gtxid,\n     auto delay = std::chrono::microseconds{0};\n     const bool preferred = state->fPreferredDownload;\n     if (!preferred) delay += NONPREF_PEER_TX_DELAY;\n-    if (!gtxid.IsWtxid() && g_wtxid_relay_peers > 0) delay += TXID_RELAY_DELAY;\n+    if (!gtxid.IsWtxid() && m_wtxid_relay_peers > 0) delay += TXID_RELAY_DELAY;\n     const bool overloaded = !node.HasPermission(PF_RELAY) &&\n         m_txrequest.CountInFlight(nodeid) >= MAX_PEER_TX_REQUEST_IN_FLIGHT;\n     if (overloaded) delay += OVERLOADED_PEER_TX_DELAY;\n@@ -1004,10 +1004,10 @@ void PeerManagerImpl::FinalizeNode(const CNode& node, bool& fUpdateConnectionTim\n     nPreferredDownload -= state->fPreferredDownload;\n     nPeersWithValidatedDownloads -= (state->nBlocksInFlightValidHeaders != 0);\n     assert(nPeersWithValidatedDownloads >= 0);\n-    g_outbound_peers_with_protect_from_disconnect -= state->m_chain_sync.m_protect;\n-    assert(g_outbound_peers_with_protect_from_disconnect >= 0);\n-    g_wtxid_relay_peers -= state->m_wtxid_relay;\n-    assert(g_wtxid_relay_peers >= 0);\n+    m_outbound_peers_with_protect_from_disconnect -= state->m_chain_sync.m_protect;\n+    assert(m_outbound_peers_with_protect_from_disconnect >= 0);\n+    m_wtxid_relay_peers -= state->m_wtxid_relay;\n+    assert(m_wtxid_relay_peers >= 0);\n \n     mapNodeState.erase(nodeid);\n \n@@ -1016,8 +1016,8 @@ void PeerManagerImpl::FinalizeNode(const CNode& node, bool& fUpdateConnectionTim\n         assert(mapBlocksInFlight.empty());\n         assert(nPreferredDownload == 0);\n         assert(nPeersWithValidatedDownloads == 0);\n-        assert(g_outbound_peers_with_protect_from_disconnect == 0);\n-        assert(g_wtxid_relay_peers == 0);\n+        assert(m_outbound_peers_with_protect_from_disconnect == 0);\n+        assert(m_wtxid_relay_peers == 0);\n         assert(m_txrequest.Size() == 0);\n     }\n     LogPrint(BCLog::NET, \"Cleared nodestate for peer=%d\\n\", nodeid);\n@@ -2146,10 +2146,10 @@ void PeerManagerImpl::ProcessHeadersMessage(CNode& pfrom, const Peer& peer,\n         // thus always subject to eviction under the bad/lagging chain logic.\n         // See ChainSyncTimeoutState.\n         if (!pfrom.fDisconnect && pfrom.IsFullOutboundConn() && nodestate->pindexBestKnownBlock != nullptr) {\n-            if (g_outbound_peers_with_protect_from_disconnect < MAX_OUTBOUND_PEERS_TO_PROTECT_FROM_DISCONNECT && nodestate->pindexBestKnownBlock->nChainWork >= ::ChainActive().Tip()->nChainWork && !nodestate->m_chain_sync.m_protect) {\n+            if (m_outbound_peers_with_protect_from_disconnect < MAX_OUTBOUND_PEERS_TO_PROTECT_FROM_DISCONNECT && nodestate->pindexBestKnownBlock->nChainWork >= ::ChainActive().Tip()->nChainWork && !nodestate->m_chain_sync.m_protect) {\n                 LogPrint(BCLog::NET, \"Protecting outbound peer=%d from eviction\\n\", pfrom.GetId());\n                 nodestate->m_chain_sync.m_protect = true;\n-                ++g_outbound_peers_with_protect_from_disconnect;\n+                ++m_outbound_peers_with_protect_from_disconnect;\n             }\n         }\n     }\n@@ -2759,7 +2759,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             LOCK(cs_main);\n             if (!State(pfrom.GetId())->m_wtxid_relay) {\n                 State(pfrom.GetId())->m_wtxid_relay = true;\n-                g_wtxid_relay_peers++;\n+                m_wtxid_relay_peers++;\n             } else {\n                 LogPrint(BCLog::NET, \"ignoring duplicate wtxidrelay from peer=%d\\n\", pfrom.GetId());\n             }"
      }
    ]
  },
  {
    "sha": "eeac5062508c98fe58daaec471cdd27f3909b6ec",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplZWFjNTA2MjUwOGM5OGZlNThkYWFlYzQ3MWNkZDI3ZjM5MDliNmVj",
    "commit": {
      "author": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2020-12-23T08:17:29Z"
      },
      "committer": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2021-01-29T15:50:02Z"
      },
      "message": "net_processing: move AlreadyHaveTx into PeerManageImpl\n\nAllows making recentRejects and g_recent_confirmed_transactions members\nrather than globals.",
      "tree": {
        "sha": "309821b953133cb7bb98164dd801308e43d7e248",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/309821b953133cb7bb98164dd801308e43d7e248"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/eeac5062508c98fe58daaec471cdd27f3909b6ec",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/eeac5062508c98fe58daaec471cdd27f3909b6ec",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/eeac5062508c98fe58daaec471cdd27f3909b6ec",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/eeac5062508c98fe58daaec471cdd27f3909b6ec/comments",
    "author": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9781c08a33569370f191b30cc7e2ce9b5317eb3e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9781c08a33569370f191b30cc7e2ce9b5317eb3e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9781c08a33569370f191b30cc7e2ce9b5317eb3e"
      }
    ],
    "stats": {
      "total": 30,
      "additions": 16,
      "deletions": 14
    },
    "files": [
      {
        "sha": "0b5e204308829b94e01c7137dbfbbd54f668efbc",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 14,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/eeac5062508c98fe58daaec471cdd27f3909b6ec/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/eeac5062508c98fe58daaec471cdd27f3909b6ec/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=eeac5062508c98fe58daaec471cdd27f3909b6ec",
        "patch": "@@ -362,10 +362,9 @@ class PeerManagerImpl final : public PeerManager\n \n     /** Number of outbound peers with m_chain_sync.m_protect. */\n     int m_outbound_peers_with_protect_from_disconnect GUARDED_BY(cs_main) = 0;\n-};\n-} // namespace\n \n-namespace {\n+    bool AlreadyHaveTx(const GenTxid& gtxid, const CTxMemPool& mempool) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+\n     /**\n      * Filter for transactions that were recently rejected by\n      * AcceptToMemoryPool. These are not rerequested until the chain tip\n@@ -408,9 +407,12 @@ namespace {\n      * We use this to avoid requesting transactions that have already been\n      * confirnmed.\n      */\n-    Mutex g_cs_recent_confirmed_transactions;\n-    std::unique_ptr<CRollingBloomFilter> g_recent_confirmed_transactions GUARDED_BY(g_cs_recent_confirmed_transactions);\n+    Mutex m_recent_confirmed_transactions_mutex;\n+    std::unique_ptr<CRollingBloomFilter> m_recent_confirmed_transactions GUARDED_BY(m_recent_confirmed_transactions_mutex);\n+};\n+} // namespace\n \n+namespace {\n     /** Blocks that are in flight, and that are in the queue to be downloaded. */\n     struct QueuedBlock {\n         uint256 hash;\n@@ -1344,7 +1346,7 @@ PeerManagerImpl::PeerManagerImpl(const CChainParams& chainparams, CConnman& conn\n     // The false positive rate of 1/1M should come out to less than 1\n     // transaction per day that would be inadvertently ignored (which is the\n     // same probability that we have in the reject filter).\n-    g_recent_confirmed_transactions.reset(new CRollingBloomFilter(48000, 0.000001));\n+    m_recent_confirmed_transactions.reset(new CRollingBloomFilter(48000, 0.000001));\n \n     // Stale tip checking and peer eviction are on two different timers, but we\n     // don't want them to get out of sync due to drift in the scheduler, so we\n@@ -1397,11 +1399,11 @@ void PeerManagerImpl::BlockConnected(const std::shared_ptr<const CBlock>& pblock\n         g_last_tip_update = GetTime();\n     }\n     {\n-        LOCK(g_cs_recent_confirmed_transactions);\n+        LOCK(m_recent_confirmed_transactions_mutex);\n         for (const auto& ptx : pblock->vtx) {\n-            g_recent_confirmed_transactions->insert(ptx->GetHash());\n+            m_recent_confirmed_transactions->insert(ptx->GetHash());\n             if (ptx->GetHash() != ptx->GetWitnessHash()) {\n-                g_recent_confirmed_transactions->insert(ptx->GetWitnessHash());\n+                m_recent_confirmed_transactions->insert(ptx->GetWitnessHash());\n             }\n         }\n     }\n@@ -1424,8 +1426,8 @@ void PeerManagerImpl::BlockDisconnected(const std::shared_ptr<const CBlock> &blo\n     // block's worth of transactions in it, but that should be fine, since\n     // presumably the most common case of relaying a confirmed transaction\n     // should be just after a new block containing it is found.\n-    LOCK(g_cs_recent_confirmed_transactions);\n-    g_recent_confirmed_transactions->reset();\n+    LOCK(m_recent_confirmed_transactions_mutex);\n+    m_recent_confirmed_transactions->reset();\n }\n \n // All of the following cache a recent block, and are protected by cs_most_recent_block\n@@ -1563,7 +1565,7 @@ void PeerManagerImpl::BlockChecked(const CBlock& block, const BlockValidationSta\n //\n \n \n-bool static AlreadyHaveTx(const GenTxid& gtxid, const CTxMemPool& mempool) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+bool PeerManagerImpl::AlreadyHaveTx(const GenTxid& gtxid, const CTxMemPool& mempool) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n     assert(recentRejects);\n     if (::ChainActive().Tip()->GetBlockHash() != hashRecentRejectsChainTip) {\n@@ -1587,8 +1589,8 @@ bool static AlreadyHaveTx(const GenTxid& gtxid, const CTxMemPool& mempool) EXCLU\n     }\n \n     {\n-        LOCK(g_cs_recent_confirmed_transactions);\n-        if (g_recent_confirmed_transactions->contains(hash)) return true;\n+        LOCK(m_recent_confirmed_transactions_mutex);\n+        if (m_recent_confirmed_transactions->contains(hash)) return true;\n     }\n \n     return recentRejects->contains(hash) || mempool.exists(gtxid);"
      }
    ]
  },
  {
    "sha": "052d9bc7e52aea373a316f08d42460ead4ed16c8",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowNTJkOWJjN2U1MmFlYTM3M2EzMTZmMDhkNDI0NjBlYWQ0ZWQxNmM4",
    "commit": {
      "author": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2020-12-23T08:50:43Z"
      },
      "committer": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2021-01-29T15:51:06Z"
      },
      "message": "net_processing: simplify AlreadyHaveTx args\n\nNo need to pass mempool to PeerManagerImpl methods.",
      "tree": {
        "sha": "4368c7cd3b15e74056eb9f2882c6d736810bf922",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4368c7cd3b15e74056eb9f2882c6d736810bf922"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/052d9bc7e52aea373a316f08d42460ead4ed16c8",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/052d9bc7e52aea373a316f08d42460ead4ed16c8",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/052d9bc7e52aea373a316f08d42460ead4ed16c8",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/052d9bc7e52aea373a316f08d42460ead4ed16c8/comments",
    "author": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "eeac5062508c98fe58daaec471cdd27f3909b6ec",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/eeac5062508c98fe58daaec471cdd27f3909b6ec",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/eeac5062508c98fe58daaec471cdd27f3909b6ec"
      }
    ],
    "stats": {
      "total": 14,
      "additions": 7,
      "deletions": 7
    },
    "files": [
      {
        "sha": "a1d8bba5197dd8ae9c891c429985f22c576ae70e",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/052d9bc7e52aea373a316f08d42460ead4ed16c8/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/052d9bc7e52aea373a316f08d42460ead4ed16c8/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=052d9bc7e52aea373a316f08d42460ead4ed16c8",
        "patch": "@@ -363,7 +363,7 @@ class PeerManagerImpl final : public PeerManager\n     /** Number of outbound peers with m_chain_sync.m_protect. */\n     int m_outbound_peers_with_protect_from_disconnect GUARDED_BY(cs_main) = 0;\n \n-    bool AlreadyHaveTx(const GenTxid& gtxid, const CTxMemPool& mempool) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    bool AlreadyHaveTx(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n     /**\n      * Filter for transactions that were recently rejected by\n@@ -1565,7 +1565,7 @@ void PeerManagerImpl::BlockChecked(const CBlock& block, const BlockValidationSta\n //\n \n \n-bool PeerManagerImpl::AlreadyHaveTx(const GenTxid& gtxid, const CTxMemPool& mempool) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+bool PeerManagerImpl::AlreadyHaveTx(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n     assert(recentRejects);\n     if (::ChainActive().Tip()->GetBlockHash() != hashRecentRejectsChainTip) {\n@@ -1593,7 +1593,7 @@ bool PeerManagerImpl::AlreadyHaveTx(const GenTxid& gtxid, const CTxMemPool& memp\n         if (m_recent_confirmed_transactions->contains(hash)) return true;\n     }\n \n-    return recentRejects->contains(hash) || mempool.exists(gtxid);\n+    return recentRejects->contains(hash) || m_mempool.exists(gtxid);\n }\n \n bool static AlreadyHaveBlock(const uint256& block_hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n@@ -2903,7 +2903,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                 }\n             } else if (inv.IsGenTxMsg()) {\n                 const GenTxid gtxid = ToGenTxid(inv);\n-                const bool fAlreadyHave = AlreadyHaveTx(gtxid, m_mempool);\n+                const bool fAlreadyHave = AlreadyHaveTx(gtxid);\n                 LogPrint(BCLog::NET, \"got inv: %s  %s peer=%d\\n\", inv.ToString(), fAlreadyHave ? \"have\" : \"new\", pfrom.GetId());\n \n                 pfrom.AddKnownTx(inv.hash);\n@@ -3184,7 +3184,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         // already; and an adversary can already relay us old transactions\n         // (older than our recency filter) if trying to DoS us, without any need\n         // for witness malleation.\n-        if (AlreadyHaveTx(GenTxid(/* is_wtxid=*/true, wtxid), m_mempool)) {\n+        if (AlreadyHaveTx(GenTxid(/* is_wtxid=*/true, wtxid))) {\n             if (pfrom.HasPermission(PF_FORCERELAY)) {\n                 // Always relay transactions received from peers with forcerelay\n                 // permission, even if they were already in the mempool, allowing\n@@ -3263,7 +3263,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                     // protocol for getting all unconfirmed parents.\n                     const GenTxid gtxid{/* is_wtxid=*/false, parent_txid};\n                     pfrom.AddKnownTx(parent_txid);\n-                    if (!AlreadyHaveTx(gtxid, m_mempool)) AddTxAnnouncement(pfrom, gtxid, current_time);\n+                    if (!AlreadyHaveTx(gtxid)) AddTxAnnouncement(pfrom, gtxid, current_time);\n                 }\n                 AddOrphanTx(ptx, pfrom.GetId());\n \n@@ -4804,7 +4804,7 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                 entry.second.GetHash().ToString(), entry.first);\n         }\n         for (const GenTxid& gtxid : requestable) {\n-            if (!AlreadyHaveTx(gtxid, m_mempool)) {\n+            if (!AlreadyHaveTx(gtxid)) {\n                 LogPrint(BCLog::NET, \"Requesting %s %s peer=%d\\n\", gtxid.IsWtxid() ? \"wtx\" : \"tx\",\n                     gtxid.GetHash().ToString(), pto->GetId());\n                 vGetData.emplace_back(gtxid.IsWtxid() ? MSG_WTX : (MSG_TX | GetFetchFlags(*pto)), gtxid.GetHash());"
      }
    ]
  },
  {
    "sha": "a490f0a056456d683dd8ef6f89a5af1a13792118",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphNDkwZjBhMDU2NDU2ZDY4M2RkOGVmNmY4OWE1YWYxYTEzNzkyMTE4",
    "commit": {
      "author": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2020-12-23T08:32:13Z"
      },
      "committer": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2021-01-29T16:06:58Z"
      },
      "message": "net_processing: move MarkBlockAs*, TipMayBeStale, FindNextBlocksToDL to PeerManagerImpl\n\nAllows converting mapBlocksInFlight and g_last_tip_update from globals\nto member variables.",
      "tree": {
        "sha": "f2a7e1fca074a0b94f6a3d20cb5dddb2927788de",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f2a7e1fca074a0b94f6a3d20cb5dddb2927788de"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a490f0a056456d683dd8ef6f89a5af1a13792118",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a490f0a056456d683dd8ef6f89a5af1a13792118",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a490f0a056456d683dd8ef6f89a5af1a13792118",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a490f0a056456d683dd8ef6f89a5af1a13792118/comments",
    "author": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "052d9bc7e52aea373a316f08d42460ead4ed16c8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/052d9bc7e52aea373a316f08d42460ead4ed16c8",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/052d9bc7e52aea373a316f08d42460ead4ed16c8"
      }
    ],
    "stats": {
      "total": 69,
      "additions": 42,
      "deletions": 27
    },
    "files": [
      {
        "sha": "77102b94583b9c6c3fad252d088d7f8d4ec7ea15",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 42,
        "deletions": 27,
        "changes": 69,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a490f0a056456d683dd8ef6f89a5af1a13792118/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a490f0a056456d683dd8ef6f89a5af1a13792118/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=a490f0a056456d683dd8ef6f89a5af1a13792118",
        "patch": "@@ -169,6 +169,14 @@ void EraseOrphansFor(NodeId peer);\n \n // Internal stuff\n namespace {\n+/** Blocks that are in flight, and that are in the queue to be downloaded. */\n+struct QueuedBlock {\n+    uint256 hash;\n+    const CBlockIndex* pindex;                               //!< Optional.\n+    bool fValidatedHeaders;                                  //!< Whether this block has validated headers at the time of request.\n+    std::unique_ptr<PartiallyDownloadedBlock> partialBlock;  //!< Optional, used for CMPCTBLOCK downloads\n+};\n+\n /**\n  * Data structure for an individual peer. This struct is not protected by\n  * cs_main since it does not contain validation-critical data.\n@@ -409,19 +417,33 @@ class PeerManagerImpl final : public PeerManager\n      */\n     Mutex m_recent_confirmed_transactions_mutex;\n     std::unique_ptr<CRollingBloomFilter> m_recent_confirmed_transactions GUARDED_BY(m_recent_confirmed_transactions_mutex);\n+\n+    /* Returns a bool indicating whether we requested this block.\n+     * Also used if a block was /not/ received and timed out or started with another peer\n+     */\n+    bool MarkBlockAsReceived(const uint256& hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+\n+    /* Mark a block as in flight\n+     * Returns false, still setting pit, if the block was already in flight from the same peer\n+     * pit will only be valid as long as the same cs_main lock is being held\n+     */\n+    bool MarkBlockAsInFlight(CTxMemPool& mempool, NodeId nodeid, const uint256& hash, const CBlockIndex* pindex = nullptr, std::list<QueuedBlock>::iterator** pit = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+\n+    bool TipMayBeStale(const Consensus::Params &consensusParams) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+\n+    /** Update pindexLastCommonBlock and add not-in-flight missing successors to vBlocks, until it has\n+     *  at most count entries.\n+     */\n+    void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<const CBlockIndex*>& vBlocks, NodeId& nodeStaller, const Consensus::Params& consensusParams) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+\n+    std::map<uint256, std::pair<NodeId, std::list<QueuedBlock>::iterator> > mapBlocksInFlight GUARDED_BY(cs_main);\n+\n+    /** When our tip was last updated. */\n+    std::atomic<int64_t> m_last_tip_update{0};\n };\n } // namespace\n \n namespace {\n-    /** Blocks that are in flight, and that are in the queue to be downloaded. */\n-    struct QueuedBlock {\n-        uint256 hash;\n-        const CBlockIndex* pindex;                               //!< Optional.\n-        bool fValidatedHeaders;                                  //!< Whether this block has validated headers at the time of request.\n-        std::unique_ptr<PartiallyDownloadedBlock> partialBlock;  //!< Optional, used for CMPCTBLOCK downloads\n-    };\n-    std::map<uint256, std::pair<NodeId, std::list<QueuedBlock>::iterator> > mapBlocksInFlight GUARDED_BY(cs_main);\n-\n     /** Stack of nodes which we have set to announce using compact blocks */\n     std::list<NodeId> lNodesAnnouncingHeaderAndIDs GUARDED_BY(cs_main);\n \n@@ -431,9 +453,6 @@ namespace {\n     /** Number of peers from which we're downloading blocks. */\n     int nPeersWithValidatedDownloads GUARDED_BY(cs_main) = 0;\n \n-    /** When our tip was last updated. */\n-    std::atomic<int64_t> g_last_tip_update(0);\n-\n     /** Relay map (txid or wtxid -> CTransactionRef) */\n     typedef std::map<uint256, CTransactionRef> MapRelay;\n     MapRelay mapRelay GUARDED_BY(cs_main);\n@@ -612,9 +631,8 @@ static void UpdatePreferredDownload(const CNode& node, CNodeState* state) EXCLUS\n     nPreferredDownload += state->fPreferredDownload;\n }\n \n-// Returns a bool indicating whether we requested this block.\n-// Also used if a block was /not/ received and timed out or started with another peer\n-static bool MarkBlockAsReceived(const uint256& hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main) {\n+bool PeerManagerImpl::MarkBlockAsReceived(const uint256& hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+{\n     std::map<uint256, std::pair<NodeId, std::list<QueuedBlock>::iterator> >::iterator itInFlight = mapBlocksInFlight.find(hash);\n     if (itInFlight != mapBlocksInFlight.end()) {\n         CNodeState *state = State(itInFlight->second.first);\n@@ -637,9 +655,8 @@ static bool MarkBlockAsReceived(const uint256& hash) EXCLUSIVE_LOCKS_REQUIRED(cs\n     return false;\n }\n \n-// returns false, still setting pit, if the block was already in flight from the same peer\n-// pit will only be valid as long as the same cs_main lock is being held\n-static bool MarkBlockAsInFlight(CTxMemPool& mempool, NodeId nodeid, const uint256& hash, const CBlockIndex* pindex = nullptr, std::list<QueuedBlock>::iterator** pit = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs_main) {\n+bool PeerManagerImpl::MarkBlockAsInFlight(CTxMemPool& mempool, NodeId nodeid, const uint256& hash, const CBlockIndex* pindex, std::list<QueuedBlock>::iterator** pit) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+{\n     CNodeState *state = State(nodeid);\n     assert(state != nullptr);\n \n@@ -752,13 +769,13 @@ static void MaybeSetPeerAsAnnouncingHeaderAndIDs(NodeId nodeid, CConnman& connma\n     }\n }\n \n-static bool TipMayBeStale(const Consensus::Params &consensusParams) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+bool PeerManagerImpl::TipMayBeStale(const Consensus::Params &consensusParams) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n     AssertLockHeld(cs_main);\n-    if (g_last_tip_update == 0) {\n-        g_last_tip_update = GetTime();\n+    if (m_last_tip_update == 0) {\n+        m_last_tip_update = GetTime();\n     }\n-    return g_last_tip_update < GetTime() - consensusParams.nPowTargetSpacing * 3 && mapBlocksInFlight.empty();\n+    return m_last_tip_update < GetTime() - consensusParams.nPowTargetSpacing * 3 && mapBlocksInFlight.empty();\n }\n \n static bool CanDirectFetch(const Consensus::Params &consensusParams) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n@@ -775,9 +792,7 @@ static bool PeerHasHeader(CNodeState *state, const CBlockIndex *pindex) EXCLUSIV\n     return false;\n }\n \n-/** Update pindexLastCommonBlock and add not-in-flight missing successors to vBlocks, until it has\n- *  at most count entries. */\n-static void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<const CBlockIndex*>& vBlocks, NodeId& nodeStaller, const Consensus::Params& consensusParams) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+void PeerManagerImpl::FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<const CBlockIndex*>& vBlocks, NodeId& nodeStaller, const Consensus::Params& consensusParams) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n     if (count == 0)\n         return;\n@@ -1396,7 +1411,7 @@ void PeerManagerImpl::BlockConnected(const std::shared_ptr<const CBlock>& pblock\n             LogPrint(BCLog::MEMPOOL, \"Erased %d orphan tx included or conflicted by block\\n\", nErased);\n         }\n \n-        g_last_tip_update = GetTime();\n+        m_last_tip_update = GetTime();\n     }\n     {\n         LOCK(m_recent_confirmed_transactions_mutex);\n@@ -4251,7 +4266,7 @@ void PeerManagerImpl::CheckForStaleTipAndEvictPeers()\n         // Check whether our tip is stale, and if so, allow using an extra\n         // outbound peer\n         if (!fImporting && !fReindex && m_connman.GetNetworkActive() && m_connman.GetUseAddrmanOutgoing() && TipMayBeStale(m_chainparams.GetConsensus())) {\n-            LogPrintf(\"Potential stale tip detected, will try using extra outbound peer (last tip update: %d seconds ago)\\n\", time_in_seconds - g_last_tip_update);\n+            LogPrintf(\"Potential stale tip detected, will try using extra outbound peer (last tip update: %d seconds ago)\\n\", time_in_seconds - m_last_tip_update);\n             m_connman.SetTryNewOutboundPeer(true);\n         } else if (m_connman.GetTryNewOutboundPeer()) {\n             m_connman.SetTryNewOutboundPeer(false);"
      }
    ]
  },
  {
    "sha": "d44084883adcf00f50d3d5a9e0c88e3a0b276817",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkNDQwODQ4ODNhZGNmMDBmNTBkM2Q1YTllMGM4OGUzYTBiMjc2ODE3",
    "commit": {
      "author": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2020-12-23T08:57:40Z"
      },
      "committer": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2021-01-29T16:11:01Z"
      },
      "message": "net_processing: simplify PeerManageImpl method args\n\nNo need to pass mempool to MarkBlockAsInFlight, or consensusParams to\nTipMayBeStale or FindNextBlocksToDownload.",
      "tree": {
        "sha": "c2d0be5865728d39ddbac94d30e1eeb27b1f18a6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c2d0be5865728d39ddbac94d30e1eeb27b1f18a6"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d44084883adcf00f50d3d5a9e0c88e3a0b276817",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d44084883adcf00f50d3d5a9e0c88e3a0b276817",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d44084883adcf00f50d3d5a9e0c88e3a0b276817",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d44084883adcf00f50d3d5a9e0c88e3a0b276817/comments",
    "author": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a490f0a056456d683dd8ef6f89a5af1a13792118",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a490f0a056456d683dd8ef6f89a5af1a13792118",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a490f0a056456d683dd8ef6f89a5af1a13792118"
      }
    ],
    "stats": {
      "total": 26,
      "additions": 14,
      "deletions": 12
    },
    "files": [
      {
        "sha": "df4d5441f51d39246dde653672ec0404ccc38d28",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 12,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d44084883adcf00f50d3d5a9e0c88e3a0b276817/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d44084883adcf00f50d3d5a9e0c88e3a0b276817/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=d44084883adcf00f50d3d5a9e0c88e3a0b276817",
        "patch": "@@ -427,14 +427,14 @@ class PeerManagerImpl final : public PeerManager\n      * Returns false, still setting pit, if the block was already in flight from the same peer\n      * pit will only be valid as long as the same cs_main lock is being held\n      */\n-    bool MarkBlockAsInFlight(CTxMemPool& mempool, NodeId nodeid, const uint256& hash, const CBlockIndex* pindex = nullptr, std::list<QueuedBlock>::iterator** pit = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    bool MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const CBlockIndex* pindex = nullptr, std::list<QueuedBlock>::iterator** pit = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n-    bool TipMayBeStale(const Consensus::Params &consensusParams) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    bool TipMayBeStale() EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n     /** Update pindexLastCommonBlock and add not-in-flight missing successors to vBlocks, until it has\n      *  at most count entries.\n      */\n-    void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<const CBlockIndex*>& vBlocks, NodeId& nodeStaller, const Consensus::Params& consensusParams) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<const CBlockIndex*>& vBlocks, NodeId& nodeStaller) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n     std::map<uint256, std::pair<NodeId, std::list<QueuedBlock>::iterator> > mapBlocksInFlight GUARDED_BY(cs_main);\n \n@@ -655,7 +655,7 @@ bool PeerManagerImpl::MarkBlockAsReceived(const uint256& hash) EXCLUSIVE_LOCKS_R\n     return false;\n }\n \n-bool PeerManagerImpl::MarkBlockAsInFlight(CTxMemPool& mempool, NodeId nodeid, const uint256& hash, const CBlockIndex* pindex, std::list<QueuedBlock>::iterator** pit) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+bool PeerManagerImpl::MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const CBlockIndex* pindex, std::list<QueuedBlock>::iterator** pit) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n     CNodeState *state = State(nodeid);\n     assert(state != nullptr);\n@@ -673,7 +673,7 @@ bool PeerManagerImpl::MarkBlockAsInFlight(CTxMemPool& mempool, NodeId nodeid, co\n     MarkBlockAsReceived(hash);\n \n     std::list<QueuedBlock>::iterator it = state->vBlocksInFlight.insert(state->vBlocksInFlight.end(),\n-            {hash, pindex, pindex != nullptr, std::unique_ptr<PartiallyDownloadedBlock>(pit ? new PartiallyDownloadedBlock(&mempool) : nullptr)});\n+            {hash, pindex, pindex != nullptr, std::unique_ptr<PartiallyDownloadedBlock>(pit ? new PartiallyDownloadedBlock(&m_mempool) : nullptr)});\n     state->nBlocksInFlight++;\n     state->nBlocksInFlightValidHeaders += it->fValidatedHeaders;\n     if (state->nBlocksInFlight == 1) {\n@@ -769,9 +769,10 @@ static void MaybeSetPeerAsAnnouncingHeaderAndIDs(NodeId nodeid, CConnman& connma\n     }\n }\n \n-bool PeerManagerImpl::TipMayBeStale(const Consensus::Params &consensusParams) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+bool PeerManagerImpl::TipMayBeStale() EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n     AssertLockHeld(cs_main);\n+    const Consensus::Params& consensusParams = m_chainparams.GetConsensus();\n     if (m_last_tip_update == 0) {\n         m_last_tip_update = GetTime();\n     }\n@@ -792,7 +793,7 @@ static bool PeerHasHeader(CNodeState *state, const CBlockIndex *pindex) EXCLUSIV\n     return false;\n }\n \n-void PeerManagerImpl::FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<const CBlockIndex*>& vBlocks, NodeId& nodeStaller, const Consensus::Params& consensusParams) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+void PeerManagerImpl::FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<const CBlockIndex*>& vBlocks, NodeId& nodeStaller) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n     if (count == 0)\n         return;\n@@ -821,6 +822,7 @@ void PeerManagerImpl::FindNextBlocksToDownload(NodeId nodeid, unsigned int count\n     if (state->pindexLastCommonBlock == state->pindexBestKnownBlock)\n         return;\n \n+    const Consensus::Params& consensusParams = m_chainparams.GetConsensus();\n     std::vector<const CBlockIndex*> vToFetch;\n     const CBlockIndex *pindexWalk = state->pindexLastCommonBlock;\n     // Never fetch further than the best block we know the peer has, or more than BLOCK_DOWNLOAD_WINDOW + 1 beyond the last\n@@ -2119,7 +2121,7 @@ void PeerManagerImpl::ProcessHeadersMessage(CNode& pfrom, const Peer& peer,\n                     }\n                     uint32_t nFetchFlags = GetFetchFlags(pfrom);\n                     vGetData.push_back(CInv(MSG_BLOCK | nFetchFlags, pindex->GetBlockHash()));\n-                    MarkBlockAsInFlight(m_mempool, pfrom.GetId(), pindex->GetBlockHash(), pindex);\n+                    MarkBlockAsInFlight(pfrom.GetId(), pindex->GetBlockHash(), pindex);\n                     LogPrint(BCLog::NET, \"Requesting block %s from  peer=%d\\n\",\n                             pindex->GetBlockHash().ToString(), pfrom.GetId());\n                 }\n@@ -3468,7 +3470,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             if ((!fAlreadyInFlight && nodestate->nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) ||\n                  (fAlreadyInFlight && blockInFlightIt->second.first == pfrom.GetId())) {\n                 std::list<QueuedBlock>::iterator* queuedBlockIt = nullptr;\n-                if (!MarkBlockAsInFlight(m_mempool, pfrom.GetId(), pindex->GetBlockHash(), pindex, &queuedBlockIt)) {\n+                if (!MarkBlockAsInFlight(pfrom.GetId(), pindex->GetBlockHash(), pindex, &queuedBlockIt)) {\n                     if (!(*queuedBlockIt)->partialBlock)\n                         (*queuedBlockIt)->partialBlock.reset(new PartiallyDownloadedBlock(&m_mempool));\n                     else {\n@@ -4265,7 +4267,7 @@ void PeerManagerImpl::CheckForStaleTipAndEvictPeers()\n     if (time_in_seconds > m_stale_tip_check_time) {\n         // Check whether our tip is stale, and if so, allow using an extra\n         // outbound peer\n-        if (!fImporting && !fReindex && m_connman.GetNetworkActive() && m_connman.GetUseAddrmanOutgoing() && TipMayBeStale(m_chainparams.GetConsensus())) {\n+        if (!fImporting && !fReindex && m_connman.GetNetworkActive() && m_connman.GetUseAddrmanOutgoing() && TipMayBeStale()) {\n             LogPrintf(\"Potential stale tip detected, will try using extra outbound peer (last tip update: %d seconds ago)\\n\", time_in_seconds - m_last_tip_update);\n             m_connman.SetTryNewOutboundPeer(true);\n         } else if (m_connman.GetTryNewOutboundPeer()) {\n@@ -4793,11 +4795,11 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n         if (!pto->fClient && ((fFetch && !pto->m_limited_node) || !::ChainstateActive().IsInitialBlockDownload()) && state.nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n             std::vector<const CBlockIndex*> vToDownload;\n             NodeId staller = -1;\n-            FindNextBlocksToDownload(pto->GetId(), MAX_BLOCKS_IN_TRANSIT_PER_PEER - state.nBlocksInFlight, vToDownload, staller, consensusParams);\n+            FindNextBlocksToDownload(pto->GetId(), MAX_BLOCKS_IN_TRANSIT_PER_PEER - state.nBlocksInFlight, vToDownload, staller);\n             for (const CBlockIndex *pindex : vToDownload) {\n                 uint32_t nFetchFlags = GetFetchFlags(*pto);\n                 vGetData.push_back(CInv(MSG_BLOCK | nFetchFlags, pindex->GetBlockHash()));\n-                MarkBlockAsInFlight(m_mempool, pto->GetId(), pindex->GetBlockHash(), pindex);\n+                MarkBlockAsInFlight(pto->GetId(), pindex->GetBlockHash(), pindex);\n                 LogPrint(BCLog::NET, \"Requesting block %s (%d) peer=%d\\n\", pindex->GetBlockHash().ToString(),\n                     pindex->nHeight, pto->GetId());\n             }"
      }
    ]
  },
  {
    "sha": "34207b9004d2069a8fcb32758cd796143eccfb4d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozNDIwN2I5MDA0ZDIwNjlhOGZjYjMyNzU4Y2Q3OTYxNDNlY2NmYjRk",
    "commit": {
      "author": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2020-12-23T08:38:48Z"
      },
      "committer": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2021-01-29T16:16:37Z"
      },
      "message": "net_processing: move FindTxForGetData and ProcessGetData to PeerManagerImpl\n\nAllows making mapRelay and vRelayExpiration members rather than globals.",
      "tree": {
        "sha": "5efbc736f8a1c439beadb1263041137335898521",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5efbc736f8a1c439beadb1263041137335898521"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/34207b9004d2069a8fcb32758cd796143eccfb4d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/34207b9004d2069a8fcb32758cd796143eccfb4d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/34207b9004d2069a8fcb32758cd796143eccfb4d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/34207b9004d2069a8fcb32758cd796143eccfb4d/comments",
    "author": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d44084883adcf00f50d3d5a9e0c88e3a0b276817",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d44084883adcf00f50d3d5a9e0c88e3a0b276817",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d44084883adcf00f50d3d5a9e0c88e3a0b276817"
      }
    ],
    "stats": {
      "total": 24,
      "additions": 15,
      "deletions": 9
    },
    "files": [
      {
        "sha": "bde67c675c1c7f211f0c6b06280da79d4dbc654c",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 9,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/34207b9004d2069a8fcb32758cd796143eccfb4d/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/34207b9004d2069a8fcb32758cd796143eccfb4d/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=34207b9004d2069a8fcb32758cd796143eccfb4d",
        "patch": "@@ -440,6 +440,19 @@ class PeerManagerImpl final : public PeerManager\n \n     /** When our tip was last updated. */\n     std::atomic<int64_t> m_last_tip_update{0};\n+\n+    /** Determine whether or not a peer can request a transaction, and return it (or nullptr if not found or not allowed). */\n+    CTransactionRef FindTxForGetData(const CTxMemPool& mempool, const CNode& peer, const GenTxid& gtxid, const std::chrono::seconds mempool_req, const std::chrono::seconds now) LOCKS_EXCLUDED(cs_main);\n+\n+    void ProcessGetData(CNode& pfrom, Peer& peer, const CChainParams& chainparams, CConnman& connman, CTxMemPool& mempool, const std::atomic<bool>& interruptMsgProc) EXCLUSIVE_LOCKS_REQUIRED(!cs_main, peer.m_getdata_requests_mutex);\n+\n+    /** Relay map (txid or wtxid -> CTransactionRef) */\n+    typedef std::map<uint256, CTransactionRef> MapRelay;\n+    MapRelay mapRelay GUARDED_BY(cs_main);\n+    /** Expiration-time ordered list of (expire time, relay map entry) pairs. */\n+    std::deque<std::pair<int64_t, MapRelay::iterator>> vRelayExpiration GUARDED_BY(cs_main);\n+\n+\n };\n } // namespace\n \n@@ -453,12 +466,6 @@ namespace {\n     /** Number of peers from which we're downloading blocks. */\n     int nPeersWithValidatedDownloads GUARDED_BY(cs_main) = 0;\n \n-    /** Relay map (txid or wtxid -> CTransactionRef) */\n-    typedef std::map<uint256, CTransactionRef> MapRelay;\n-    MapRelay mapRelay GUARDED_BY(cs_main);\n-    /** Expiration-time ordered list of (expire time, relay map entry) pairs. */\n-    std::deque<std::pair<int64_t, MapRelay::iterator>> vRelayExpiration GUARDED_BY(cs_main);\n-\n     struct IteratorComparator\n     {\n         template<typename I>\n@@ -1844,8 +1851,7 @@ void static ProcessGetBlockData(CNode& pfrom, Peer& peer, const CChainParams& ch\n     }\n }\n \n-//! Determine whether or not a peer can request a transaction, and return it (or nullptr if not found or not allowed).\n-static CTransactionRef FindTxForGetData(const CTxMemPool& mempool, const CNode& peer, const GenTxid& gtxid, const std::chrono::seconds mempool_req, const std::chrono::seconds now) LOCKS_EXCLUDED(cs_main)\n+CTransactionRef PeerManagerImpl::FindTxForGetData(const CTxMemPool& mempool, const CNode& peer, const GenTxid& gtxid, const std::chrono::seconds mempool_req, const std::chrono::seconds now) LOCKS_EXCLUDED(cs_main)\n {\n     auto txinfo = mempool.info(gtxid);\n     if (txinfo.tx) {\n@@ -1872,7 +1878,7 @@ static CTransactionRef FindTxForGetData(const CTxMemPool& mempool, const CNode&\n     return {};\n }\n \n-void static ProcessGetData(CNode& pfrom, Peer& peer, const CChainParams& chainparams, CConnman& connman, CTxMemPool& mempool, const std::atomic<bool>& interruptMsgProc) EXCLUSIVE_LOCKS_REQUIRED(!cs_main, peer.m_getdata_requests_mutex)\n+void PeerManagerImpl::ProcessGetData(CNode& pfrom, Peer& peer, const CChainParams& chainparams, CConnman& connman, CTxMemPool& mempool, const std::atomic<bool>& interruptMsgProc) EXCLUSIVE_LOCKS_REQUIRED(!cs_main, peer.m_getdata_requests_mutex)\n {\n     AssertLockNotHeld(cs_main);\n "
      }
    ]
  },
  {
    "sha": "7b7117efd00acf7609e65d3b4fe5f76e400dda12",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3YjcxMTdlZmQwMGFjZjc2MDllNjVkM2I0ZmU1Zjc2ZTQwMGRkYTEy",
    "commit": {
      "author": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2020-12-23T09:02:48Z"
      },
      "committer": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2021-01-29T16:18:49Z"
      },
      "message": "net_processing: simplify ProcessGetData and FindTxForGetData args\n\nNo need to pass mempool or connman to PeerManagerImpl methods.",
      "tree": {
        "sha": "45944e360f7c1cd58b80d72168a93df588ace72e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/45944e360f7c1cd58b80d72168a93df588ace72e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7b7117efd00acf7609e65d3b4fe5f76e400dda12",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7b7117efd00acf7609e65d3b4fe5f76e400dda12",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7b7117efd00acf7609e65d3b4fe5f76e400dda12",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7b7117efd00acf7609e65d3b4fe5f76e400dda12/comments",
    "author": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "34207b9004d2069a8fcb32758cd796143eccfb4d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/34207b9004d2069a8fcb32758cd796143eccfb4d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/34207b9004d2069a8fcb32758cd796143eccfb4d"
      }
    ],
    "stats": {
      "total": 28,
      "additions": 14,
      "deletions": 14
    },
    "files": [
      {
        "sha": "e166cb7caad7ff8affe7bc3e2848702ad0d956e9",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 14,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7b7117efd00acf7609e65d3b4fe5f76e400dda12/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7b7117efd00acf7609e65d3b4fe5f76e400dda12/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=7b7117efd00acf7609e65d3b4fe5f76e400dda12",
        "patch": "@@ -442,9 +442,9 @@ class PeerManagerImpl final : public PeerManager\n     std::atomic<int64_t> m_last_tip_update{0};\n \n     /** Determine whether or not a peer can request a transaction, and return it (or nullptr if not found or not allowed). */\n-    CTransactionRef FindTxForGetData(const CTxMemPool& mempool, const CNode& peer, const GenTxid& gtxid, const std::chrono::seconds mempool_req, const std::chrono::seconds now) LOCKS_EXCLUDED(cs_main);\n+    CTransactionRef FindTxForGetData(const CNode& peer, const GenTxid& gtxid, const std::chrono::seconds mempool_req, const std::chrono::seconds now) LOCKS_EXCLUDED(cs_main);\n \n-    void ProcessGetData(CNode& pfrom, Peer& peer, const CChainParams& chainparams, CConnman& connman, CTxMemPool& mempool, const std::atomic<bool>& interruptMsgProc) EXCLUSIVE_LOCKS_REQUIRED(!cs_main, peer.m_getdata_requests_mutex);\n+    void ProcessGetData(CNode& pfrom, Peer& peer, const std::atomic<bool>& interruptMsgProc) EXCLUSIVE_LOCKS_REQUIRED(!cs_main, peer.m_getdata_requests_mutex);\n \n     /** Relay map (txid or wtxid -> CTransactionRef) */\n     typedef std::map<uint256, CTransactionRef> MapRelay;\n@@ -1851,9 +1851,9 @@ void static ProcessGetBlockData(CNode& pfrom, Peer& peer, const CChainParams& ch\n     }\n }\n \n-CTransactionRef PeerManagerImpl::FindTxForGetData(const CTxMemPool& mempool, const CNode& peer, const GenTxid& gtxid, const std::chrono::seconds mempool_req, const std::chrono::seconds now) LOCKS_EXCLUDED(cs_main)\n+CTransactionRef PeerManagerImpl::FindTxForGetData(const CNode& peer, const GenTxid& gtxid, const std::chrono::seconds mempool_req, const std::chrono::seconds now) LOCKS_EXCLUDED(cs_main)\n {\n-    auto txinfo = mempool.info(gtxid);\n+    auto txinfo = m_mempool.info(gtxid);\n     if (txinfo.tx) {\n         // If a TX could have been INVed in reply to a MEMPOOL request,\n         // or is older than UNCONDITIONAL_RELAY_DELAY, permit the request\n@@ -1878,7 +1878,7 @@ CTransactionRef PeerManagerImpl::FindTxForGetData(const CTxMemPool& mempool, con\n     return {};\n }\n \n-void PeerManagerImpl::ProcessGetData(CNode& pfrom, Peer& peer, const CChainParams& chainparams, CConnman& connman, CTxMemPool& mempool, const std::atomic<bool>& interruptMsgProc) EXCLUSIVE_LOCKS_REQUIRED(!cs_main, peer.m_getdata_requests_mutex)\n+void PeerManagerImpl::ProcessGetData(CNode& pfrom, Peer& peer, const std::atomic<bool>& interruptMsgProc) EXCLUSIVE_LOCKS_REQUIRED(!cs_main, peer.m_getdata_requests_mutex)\n {\n     AssertLockNotHeld(cs_main);\n \n@@ -1907,17 +1907,17 @@ void PeerManagerImpl::ProcessGetData(CNode& pfrom, Peer& peer, const CChainParam\n             continue;\n         }\n \n-        CTransactionRef tx = FindTxForGetData(mempool, pfrom, ToGenTxid(inv), mempool_req, now);\n+        CTransactionRef tx = FindTxForGetData(pfrom, ToGenTxid(inv), mempool_req, now);\n         if (tx) {\n             // WTX and WITNESS_TX imply we serialize with witness\n             int nSendFlags = (inv.IsMsgTx() ? SERIALIZE_TRANSACTION_NO_WITNESS : 0);\n-            connman.PushMessage(&pfrom, msgMaker.Make(nSendFlags, NetMsgType::TX, *tx));\n-            mempool.RemoveUnbroadcastTx(tx->GetHash());\n+            m_connman.PushMessage(&pfrom, msgMaker.Make(nSendFlags, NetMsgType::TX, *tx));\n+            m_mempool.RemoveUnbroadcastTx(tx->GetHash());\n             // As we're going to send tx, make sure its unconfirmed parents are made requestable.\n             std::vector<uint256> parent_ids_to_add;\n             {\n-                LOCK(mempool.cs);\n-                auto txiter = mempool.GetIter(tx->GetHash());\n+                LOCK(m_mempool.cs);\n+                auto txiter = m_mempool.GetIter(tx->GetHash());\n                 if (txiter) {\n                     const CTxMemPoolEntry::Parents& parents = (*txiter)->GetMemPoolParentsConst();\n                     parent_ids_to_add.reserve(parents.size());\n@@ -1945,7 +1945,7 @@ void PeerManagerImpl::ProcessGetData(CNode& pfrom, Peer& peer, const CChainParam\n     if (it != peer.m_getdata_requests.end() && !pfrom.fPauseSend) {\n         const CInv &inv = *it++;\n         if (inv.IsGenBlkMsg()) {\n-            ProcessGetBlockData(pfrom, peer, chainparams, inv, connman);\n+            ProcessGetBlockData(pfrom, peer, m_chainparams, inv, m_connman);\n         }\n         // else: If the first item on the queue is an unknown type, we erase it\n         // and continue processing the queue on the next call.\n@@ -1968,7 +1968,7 @@ void PeerManagerImpl::ProcessGetData(CNode& pfrom, Peer& peer, const CChainParam\n         // In normal operation, we often send NOTFOUND messages for parents of\n         // transactions that we relay; if a peer is missing a parent, they may\n         // assume we have them and request the parents from us.\n-        connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::NOTFOUND, vNotFound));\n+        m_connman.PushMessage(&pfrom, msgMaker.Make(NetMsgType::NOTFOUND, vNotFound));\n     }\n }\n \n@@ -2968,7 +2968,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         {\n             LOCK(peer->m_getdata_requests_mutex);\n             peer->m_getdata_requests.insert(peer->m_getdata_requests.end(), vInv.begin(), vInv.end());\n-            ProcessGetData(pfrom, *peer, m_chainparams, m_connman, m_mempool, interruptMsgProc);\n+            ProcessGetData(pfrom, *peer, interruptMsgProc);\n         }\n \n         return;\n@@ -4043,7 +4043,7 @@ bool PeerManagerImpl::ProcessMessages(CNode* pfrom, std::atomic<bool>& interrupt\n     {\n         LOCK(peer->m_getdata_requests_mutex);\n         if (!peer->m_getdata_requests.empty()) {\n-            ProcessGetData(*pfrom, *peer, m_chainparams, m_connman, m_mempool, interruptMsgProc);\n+            ProcessGetData(*pfrom, *peer, interruptMsgProc);\n         }\n     }\n "
      }
    ]
  },
  {
    "sha": "39c2a69bc28eb3e3b5fa15a3965773b459bbf7ad",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozOWMyYTY5YmMyOGViM2UzYjVmYTE1YTM5NjU3NzNiNDU5YmJmN2Fk",
    "commit": {
      "author": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2020-12-23T09:23:41Z"
      },
      "committer": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2021-01-29T16:27:12Z"
      },
      "message": "net_processing: move MaybeSetPeerAsAnnouncingHeadersAndIDs into PeerManagerImpl\n\nAllows making lNodesAnnouncingHeaderAndIDs and\nnPeersWithValidatedDownloads member vars instead of globals.",
      "tree": {
        "sha": "4ae7b3478e76a8b4d6bed0c02c3b713a1ee22e39",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4ae7b3478e76a8b4d6bed0c02c3b713a1ee22e39"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/39c2a69bc28eb3e3b5fa15a3965773b459bbf7ad",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/39c2a69bc28eb3e3b5fa15a3965773b459bbf7ad",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/39c2a69bc28eb3e3b5fa15a3965773b459bbf7ad",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/39c2a69bc28eb3e3b5fa15a3965773b459bbf7ad/comments",
    "author": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7b7117efd00acf7609e65d3b4fe5f76e400dda12",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7b7117efd00acf7609e65d3b4fe5f76e400dda12",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7b7117efd00acf7609e65d3b4fe5f76e400dda12"
      }
    ],
    "stats": {
      "total": 28,
      "additions": 15,
      "deletions": 13
    },
    "files": [
      {
        "sha": "0a3cf8b3d242486d769149bf3d05b1aec35ec588",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 13,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/39c2a69bc28eb3e3b5fa15a3965773b459bbf7ad/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/39c2a69bc28eb3e3b5fa15a3965773b459bbf7ad/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=39c2a69bc28eb3e3b5fa15a3965773b459bbf7ad",
        "patch": "@@ -452,20 +452,28 @@ class PeerManagerImpl final : public PeerManager\n     /** Expiration-time ordered list of (expire time, relay map entry) pairs. */\n     std::deque<std::pair<int64_t, MapRelay::iterator>> vRelayExpiration GUARDED_BY(cs_main);\n \n+    /**\n+     * When a peer sends us a valid block, instruct it to announce blocks to us\n+     * using CMPCTBLOCK if possible by adding its nodeid to the end of\n+     * lNodesAnnouncingHeaderAndIDs, and keeping that list under a certain size by\n+     * removing the first element if necessary.\n+     */\n+    void MaybeSetPeerAsAnnouncingHeaderAndIDs(NodeId nodeid, CConnman& connman) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+\n+    /** Stack of nodes which we have set to announce using compact blocks */\n+    std::list<NodeId> lNodesAnnouncingHeaderAndIDs GUARDED_BY(cs_main);\n+\n+    /** Number of peers from which we're downloading blocks. */\n+    int nPeersWithValidatedDownloads GUARDED_BY(cs_main) = 0;\n \n };\n } // namespace\n \n namespace {\n-    /** Stack of nodes which we have set to announce using compact blocks */\n-    std::list<NodeId> lNodesAnnouncingHeaderAndIDs GUARDED_BY(cs_main);\n \n     /** Number of preferable block download peers. */\n     int nPreferredDownload GUARDED_BY(cs_main) = 0;\n \n-    /** Number of peers from which we're downloading blocks. */\n-    int nPeersWithValidatedDownloads GUARDED_BY(cs_main) = 0;\n-\n     struct IteratorComparator\n     {\n         template<typename I>\n@@ -731,13 +739,7 @@ static void UpdateBlockAvailability(NodeId nodeid, const uint256 &hash) EXCLUSIV\n     }\n }\n \n-/**\n- * When a peer sends us a valid block, instruct it to announce blocks to us\n- * using CMPCTBLOCK if possible by adding its nodeid to the end of\n- * lNodesAnnouncingHeaderAndIDs, and keeping that list under a certain size by\n- * removing the first element if necessary.\n- */\n-static void MaybeSetPeerAsAnnouncingHeaderAndIDs(NodeId nodeid, CConnman& connman) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+void PeerManagerImpl::MaybeSetPeerAsAnnouncingHeaderAndIDs(NodeId nodeid, CConnman& connman) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n     AssertLockHeld(cs_main);\n     CNodeState* nodestate = State(nodeid);\n@@ -753,7 +755,7 @@ static void MaybeSetPeerAsAnnouncingHeaderAndIDs(NodeId nodeid, CConnman& connma\n                 return;\n             }\n         }\n-        connman.ForNode(nodeid, [&connman](CNode* pfrom) EXCLUSIVE_LOCKS_REQUIRED(::cs_main) {\n+        connman.ForNode(nodeid, [this, &connman](CNode* pfrom) EXCLUSIVE_LOCKS_REQUIRED(::cs_main) {\n             AssertLockHeld(::cs_main);\n             uint64_t nCMPCTBLOCKVersion = (pfrom->GetLocalServices() & NODE_WITNESS) ? 2 : 1;\n             if (lNodesAnnouncingHeaderAndIDs.size() >= 3) {"
      }
    ]
  },
  {
    "sha": "6452190841f8da1cdaf899d064974136ab37659f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2NDUyMTkwODQxZjhkYTFjZGFmODk5ZDA2NDk3NDEzNmFiMzc2NTlm",
    "commit": {
      "author": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2021-01-15T07:39:17Z"
      },
      "committer": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2021-01-29T16:27:18Z"
      },
      "message": "net_processing: simplify MaybeSetPeerAsAnnouncingHeaderAndIDs args\n\nNo need to pass connman to PeerManagerImpl methods.",
      "tree": {
        "sha": "5844de3860df3623a1ff0a723db5874d79689210",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5844de3860df3623a1ff0a723db5874d79689210"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6452190841f8da1cdaf899d064974136ab37659f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6452190841f8da1cdaf899d064974136ab37659f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6452190841f8da1cdaf899d064974136ab37659f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6452190841f8da1cdaf899d064974136ab37659f/comments",
    "author": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "39c2a69bc28eb3e3b5fa15a3965773b459bbf7ad",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/39c2a69bc28eb3e3b5fa15a3965773b459bbf7ad",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/39c2a69bc28eb3e3b5fa15a3965773b459bbf7ad"
      }
    ],
    "stats": {
      "total": 14,
      "additions": 7,
      "deletions": 7
    },
    "files": [
      {
        "sha": "88dc9b4ffb191a8550fd4bb97d048013d87c2d39",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6452190841f8da1cdaf899d064974136ab37659f/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6452190841f8da1cdaf899d064974136ab37659f/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=6452190841f8da1cdaf899d064974136ab37659f",
        "patch": "@@ -458,7 +458,7 @@ class PeerManagerImpl final : public PeerManager\n      * lNodesAnnouncingHeaderAndIDs, and keeping that list under a certain size by\n      * removing the first element if necessary.\n      */\n-    void MaybeSetPeerAsAnnouncingHeaderAndIDs(NodeId nodeid, CConnman& connman) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    void MaybeSetPeerAsAnnouncingHeaderAndIDs(NodeId nodeid) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n     /** Stack of nodes which we have set to announce using compact blocks */\n     std::list<NodeId> lNodesAnnouncingHeaderAndIDs GUARDED_BY(cs_main);\n@@ -739,7 +739,7 @@ static void UpdateBlockAvailability(NodeId nodeid, const uint256 &hash) EXCLUSIV\n     }\n }\n \n-void PeerManagerImpl::MaybeSetPeerAsAnnouncingHeaderAndIDs(NodeId nodeid, CConnman& connman) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+void PeerManagerImpl::MaybeSetPeerAsAnnouncingHeaderAndIDs(NodeId nodeid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n     AssertLockHeld(cs_main);\n     CNodeState* nodestate = State(nodeid);\n@@ -755,21 +755,21 @@ void PeerManagerImpl::MaybeSetPeerAsAnnouncingHeaderAndIDs(NodeId nodeid, CConnm\n                 return;\n             }\n         }\n-        connman.ForNode(nodeid, [this, &connman](CNode* pfrom) EXCLUSIVE_LOCKS_REQUIRED(::cs_main) {\n+        m_connman.ForNode(nodeid, [this](CNode* pfrom) EXCLUSIVE_LOCKS_REQUIRED(::cs_main) {\n             AssertLockHeld(::cs_main);\n             uint64_t nCMPCTBLOCKVersion = (pfrom->GetLocalServices() & NODE_WITNESS) ? 2 : 1;\n             if (lNodesAnnouncingHeaderAndIDs.size() >= 3) {\n                 // As per BIP152, we only get 3 of our peers to announce\n                 // blocks using compact encodings.\n-                connman.ForNode(lNodesAnnouncingHeaderAndIDs.front(), [&connman, nCMPCTBLOCKVersion](CNode* pnodeStop){\n-                    connman.PushMessage(pnodeStop, CNetMsgMaker(pnodeStop->GetCommonVersion()).Make(NetMsgType::SENDCMPCT, /*fAnnounceUsingCMPCTBLOCK=*/false, nCMPCTBLOCKVersion));\n+                m_connman.ForNode(lNodesAnnouncingHeaderAndIDs.front(), [this, nCMPCTBLOCKVersion](CNode* pnodeStop){\n+                    m_connman.PushMessage(pnodeStop, CNetMsgMaker(pnodeStop->GetCommonVersion()).Make(NetMsgType::SENDCMPCT, /*fAnnounceUsingCMPCTBLOCK=*/false, nCMPCTBLOCKVersion));\n                     // save BIP152 bandwidth state: we select peer to be low-bandwidth\n                     pnodeStop->m_bip152_highbandwidth_to = false;\n                     return true;\n                 });\n                 lNodesAnnouncingHeaderAndIDs.pop_front();\n             }\n-            connman.PushMessage(pfrom, CNetMsgMaker(pfrom->GetCommonVersion()).Make(NetMsgType::SENDCMPCT, /*fAnnounceUsingCMPCTBLOCK=*/true, nCMPCTBLOCKVersion));\n+            m_connman.PushMessage(pfrom, CNetMsgMaker(pfrom->GetCommonVersion()).Make(NetMsgType::SENDCMPCT, /*fAnnounceUsingCMPCTBLOCK=*/true, nCMPCTBLOCKVersion));\n             // save BIP152 bandwidth state: we select peer to be high-bandwidth\n             pfrom->m_bip152_highbandwidth_to = true;\n             lNodesAnnouncingHeaderAndIDs.push_back(pfrom->GetId());\n@@ -1578,7 +1578,7 @@ void PeerManagerImpl::BlockChecked(const CBlock& block, const BlockValidationSta\n              !::ChainstateActive().IsInitialBlockDownload() &&\n              mapBlocksInFlight.count(hash) == mapBlocksInFlight.size()) {\n         if (it != mapBlockSource.end()) {\n-            MaybeSetPeerAsAnnouncingHeaderAndIDs(it->second.first, m_connman);\n+            MaybeSetPeerAsAnnouncingHeaderAndIDs(it->second.first);\n         }\n     }\n     if (it != mapBlockSource.end())"
      }
    ]
  }
]