[
  {
    "sha": "ecacfd98e657c5819a1bcb1da93b25d3ad4e5045",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplY2FjZmQ5OGU2NTdjNTgxOWExYmNiMWRhOTNiMjVkM2FkNGU1MDQ1",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-03-31T12:43:23Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-06-22T13:42:59Z"
      },
      "message": "--- [SEGWIT] begin: P2P/node/consensus ---",
      "tree": {
        "sha": "2261266d761c8747b65d9a418c2d1ebb1c90b388",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2261266d761c8747b65d9a418c2d1ebb1c90b388"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ecacfd98e657c5819a1bcb1da93b25d3ad4e5045",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ecacfd98e657c5819a1bcb1da93b25d3ad4e5045",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ecacfd98e657c5819a1bcb1da93b25d3ad4e5045",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ecacfd98e657c5819a1bcb1da93b25d3ad4e5045/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9f1807af2422e3ac2d3702242b4a47c8df0be262",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9f1807af2422e3ac2d3702242b4a47c8df0be262",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9f1807af2422e3ac2d3702242b4a47c8df0be262"
      }
    ],
    "stats": {
      "total": 0,
      "additions": 0,
      "deletions": 0
    },
    "files": []
  },
  {
    "sha": "7030d9eb47254499bba14f1c00abc6bf493efd91",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3MDMwZDllYjQ3MjU0NDk5YmJhMTRmMWMwMGFiYzZiZjQ5M2VmZDkx",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2015-11-06T00:32:04Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-06-22T13:42:59Z"
      },
      "message": "BIP144: Serialization, hashes, relay (sender side)\n\nContains refactorings by Eric Lombrozo.\nContains fixup by Nicolas Dorier.\nContains cleanup of CInv::GetCommand by Alex Morcos",
      "tree": {
        "sha": "95055978907c7418c1b96728ff09413781b9c0b7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/95055978907c7418c1b96728ff09413781b9c0b7"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7030d9eb47254499bba14f1c00abc6bf493efd91",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7030d9eb47254499bba14f1c00abc6bf493efd91",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7030d9eb47254499bba14f1c00abc6bf493efd91",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7030d9eb47254499bba14f1c00abc6bf493efd91/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ecacfd98e657c5819a1bcb1da93b25d3ad4e5045",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ecacfd98e657c5819a1bcb1da93b25d3ad4e5045",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ecacfd98e657c5819a1bcb1da93b25d3ad4e5045"
      }
    ],
    "stats": {
      "total": 429,
      "additions": 339,
      "deletions": 90
    },
    "files": [
      {
        "sha": "b559d44bf5a8a8a0b8c5a7aee66c5be152248fa3",
        "filename": "src/core_io.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7030d9eb47254499bba14f1c00abc6bf493efd91/src/core_io.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7030d9eb47254499bba14f1c00abc6bf493efd91/src/core_io.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core_io.h?ref=7030d9eb47254499bba14f1c00abc6bf493efd91",
        "patch": "@@ -17,7 +17,7 @@ class UniValue;\n // core_read.cpp\n extern CScript ParseScript(const std::string& s);\n extern std::string ScriptToAsmStr(const CScript& script, const bool fAttemptSighashDecode = false);\n-extern bool DecodeHexTx(CTransaction& tx, const std::string& strHexTx);\n+extern bool DecodeHexTx(CTransaction& tx, const std::string& strHexTx, bool fTryNoWitness = false);\n extern bool DecodeHexBlk(CBlock&, const std::string& strHexBlk);\n extern uint256 ParseHashUV(const UniValue& v, const std::string& strName);\n extern uint256 ParseHashStr(const std::string&, const std::string& strName);"
      },
      {
        "sha": "dd86f805fe457f7cb1f41cc84ff5376dcc6cad26",
        "filename": "src/core_memusage.h",
        "status": "modified",
        "additions": 22,
        "deletions": 2,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7030d9eb47254499bba14f1c00abc6bf493efd91/src/core_memusage.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7030d9eb47254499bba14f1c00abc6bf493efd91/src/core_memusage.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core_memusage.h?ref=7030d9eb47254499bba14f1c00abc6bf493efd91",
        "patch": "@@ -25,8 +25,28 @@ static inline size_t RecursiveDynamicUsage(const CTxOut& out) {\n     return RecursiveDynamicUsage(out.scriptPubKey);\n }\n \n+static inline size_t RecursiveDynamicUsage(const CScriptWitness& scriptWit) {\n+    size_t mem = memusage::DynamicUsage(scriptWit.stack);\n+    for (std::vector<std::vector<unsigned char> >::const_iterator it = scriptWit.stack.begin(); it != scriptWit.stack.end(); it++) {\n+        mem += memusage::DynamicUsage(*it);\n+    }\n+    return mem;\n+}\n+\n+static inline size_t RecursiveDynamicUsage(const CTxinWitness& txinwit) {\n+    return RecursiveDynamicUsage(txinwit.scriptWitness);\n+}\n+\n+static inline size_t RecursiveDynamicUsage(const CTxWitness& txwit) {\n+    size_t mem = memusage::DynamicUsage(txwit.vtxinwit);\n+    for (std::vector<CTxinWitness>::const_iterator it = txwit.vtxinwit.begin(); it != txwit.vtxinwit.end(); it++) {\n+        mem += RecursiveDynamicUsage(*it);\n+    }\n+    return mem;\n+}\n+\n static inline size_t RecursiveDynamicUsage(const CTransaction& tx) {\n-    size_t mem = memusage::DynamicUsage(tx.vin) + memusage::DynamicUsage(tx.vout);\n+    size_t mem = memusage::DynamicUsage(tx.vin) + memusage::DynamicUsage(tx.vout) + RecursiveDynamicUsage(tx.wit);\n     for (std::vector<CTxIn>::const_iterator it = tx.vin.begin(); it != tx.vin.end(); it++) {\n         mem += RecursiveDynamicUsage(*it);\n     }\n@@ -37,7 +57,7 @@ static inline size_t RecursiveDynamicUsage(const CTransaction& tx) {\n }\n \n static inline size_t RecursiveDynamicUsage(const CMutableTransaction& tx) {\n-    size_t mem = memusage::DynamicUsage(tx.vin) + memusage::DynamicUsage(tx.vout);\n+    size_t mem = memusage::DynamicUsage(tx.vin) + memusage::DynamicUsage(tx.vout) + RecursiveDynamicUsage(tx.wit);\n     for (std::vector<CTxIn>::const_iterator it = tx.vin.begin(); it != tx.vin.end(); it++) {\n         mem += RecursiveDynamicUsage(*it);\n     }"
      },
      {
        "sha": "7cfda6dd6d894cefa5e5cedc853338b0cefdcbbc",
        "filename": "src/core_read.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 1,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7030d9eb47254499bba14f1c00abc6bf493efd91/src/core_read.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7030d9eb47254499bba14f1c00abc6bf493efd91/src/core_read.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core_read.cpp?ref=7030d9eb47254499bba14f1c00abc6bf493efd91",
        "patch": "@@ -90,12 +90,26 @@ CScript ParseScript(const std::string& s)\n     return result;\n }\n \n-bool DecodeHexTx(CTransaction& tx, const std::string& strHexTx)\n+bool DecodeHexTx(CTransaction& tx, const std::string& strHexTx, bool fTryNoWitness)\n {\n     if (!IsHex(strHexTx))\n         return false;\n \n     vector<unsigned char> txData(ParseHex(strHexTx));\n+\n+    if (fTryNoWitness) {\n+        CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS);\n+        try {\n+            ssData >> tx;\n+            if (ssData.eof()) {\n+                return true;\n+            }\n+        }\n+        catch (const std::exception&) {\n+            // Fall through.\n+        }\n+    }\n+\n     CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n     try {\n         ssData >> tx;"
      },
      {
        "sha": "2184940232bc8cb7a638f99322d64bc1a58fcf86",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 12,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7030d9eb47254499bba14f1c00abc6bf493efd91/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7030d9eb47254499bba14f1c00abc6bf493efd91/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=7030d9eb47254499bba14f1c00abc6bf493efd91",
        "patch": "@@ -1029,8 +1029,8 @@ bool CheckTransaction(const CTransaction& tx, CValidationState &state)\n         return state.DoS(10, false, REJECT_INVALID, \"bad-txns-vin-empty\");\n     if (tx.vout.empty())\n         return state.DoS(10, false, REJECT_INVALID, \"bad-txns-vout-empty\");\n-    // Size limits\n-    if (::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION) > MAX_BLOCK_SIZE)\n+    // Size limits (this doesn't take the witness into account, as that hasn't been checked for malleability)\n+    if (::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) > MAX_BLOCK_SIZE)\n         return state.DoS(100, false, REJECT_INVALID, \"bad-txns-oversize\");\n \n     // Check for negative or overflow output values\n@@ -3396,7 +3396,7 @@ bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::P\n     // because we receive the wrong transactions for it.\n \n     // Size limits\n-    if (block.vtx.empty() || block.vtx.size() > MAX_BLOCK_SIZE || ::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION) > MAX_BLOCK_SIZE)\n+    if (block.vtx.empty() || block.vtx.size() > MAX_BLOCK_SIZE || ::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) > MAX_BLOCK_SIZE)\n         return state.DoS(100, false, REJECT_INVALID, \"bad-blk-length\", false, \"size limits failed\");\n \n     // First transaction must be coinbase, the rest must not be\n@@ -4508,6 +4508,7 @@ bool static AlreadyHave(const CInv& inv) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n     switch (inv.type)\n     {\n     case MSG_TX:\n+    case MSG_WITNESS_TX:\n         {\n             assert(recentRejects);\n             if (chainActive.Tip()->GetBlockHash() != hashRecentRejectsChainTip)\n@@ -4528,6 +4529,7 @@ bool static AlreadyHave(const CInv& inv) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n                    pcoinsTip->HaveCoinsInCache(inv.hash);\n         }\n     case MSG_BLOCK:\n+    case MSG_WITNESS_BLOCK:\n         return mapBlockIndex.count(inv.hash);\n     }\n     // Don't know what it is, just say we already got one\n@@ -4552,7 +4554,7 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n             boost::this_thread::interruption_point();\n             it++;\n \n-            if (inv.type == MSG_BLOCK || inv.type == MSG_FILTERED_BLOCK || inv.type == MSG_CMPCT_BLOCK)\n+            if (inv.type == MSG_BLOCK || inv.type == MSG_FILTERED_BLOCK || inv.type == MSG_CMPCT_BLOCK || inv.type == MSG_WITNESS_BLOCK)\n             {\n                 bool send = false;\n                 BlockMap::iterator mi = mapBlockIndex.find(inv.hash);\n@@ -4593,6 +4595,8 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n                     if (!ReadBlockFromDisk(block, (*mi).second, consensusParams))\n                         assert(!\"cannot load block from disk\");\n                     if (inv.type == MSG_BLOCK)\n+                        pfrom->PushMessageWithFlag(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::BLOCK, block);\n+                    else if (inv.type == MSG_WITNESS_BLOCK)\n                         pfrom->PushMessage(NetMsgType::BLOCK, block);\n                     else if (inv.type == MSG_FILTERED_BLOCK)\n                     {\n@@ -4609,7 +4613,7 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n                             // however we MUST always provide at least what the remote peer needs\n                             typedef std::pair<unsigned int, uint256> PairType;\n                             BOOST_FOREACH(PairType& pair, merkleBlock.vMatchedTxn)\n-                                pfrom->PushMessage(NetMsgType::TX, block.vtx[pair.first]);\n+                                pfrom->PushMessageWithFlag(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::TX, block.vtx[pair.first]);\n                         }\n                         // else\n                             // no response\n@@ -4622,9 +4626,9 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n                         // instead we respond with the full, non-compact block.\n                         if (mi->second->nHeight >= chainActive.Height() - 10) {\n                             CBlockHeaderAndShortTxIDs cmpctblock(block);\n-                            pfrom->PushMessage(NetMsgType::CMPCTBLOCK, cmpctblock);\n+                            pfrom->PushMessageWithFlag(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::CMPCTBLOCK, cmpctblock);\n                         } else\n-                            pfrom->PushMessage(NetMsgType::BLOCK, block);\n+                            pfrom->PushMessageWithFlag(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::BLOCK, block);\n                     }\n \n                     // Trigger the peer node to send a getblocks request for the next batch of inventory\n@@ -4640,20 +4644,20 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n                     }\n                 }\n             }\n-            else if (inv.type == MSG_TX)\n+            else if (inv.type == MSG_TX || inv.type == MSG_WITNESS_TX)\n             {\n                 // Send stream from relay memory\n                 bool push = false;\n                 auto mi = mapRelay.find(inv.hash);\n                 if (mi != mapRelay.end()) {\n-                    pfrom->PushMessage(NetMsgType::TX, *mi->second);\n+                    pfrom->PushMessageWithFlag(inv.type == MSG_TX ? SERIALIZE_TRANSACTION_NO_WITNESS : 0, NetMsgType::TX, *mi->second);\n                     push = true;\n                 } else if (pfrom->timeLastMempoolReq) {\n                     auto txinfo = mempool.info(inv.hash);\n                     // To protect privacy, do not answer getdata using the mempool when\n                     // that TX couldn't have been INVed in reply to a MEMPOOL request.\n                     if (txinfo.tx && txinfo.nTime <= pfrom->timeLastMempoolReq) {\n-                        pfrom->PushMessage(NetMsgType::TX, *txinfo.tx);\n+                        pfrom->PushMessageWithFlag(inv.type == MSG_TX ? SERIALIZE_TRANSACTION_NO_WITNESS : 0, NetMsgType::TX, *txinfo.tx);\n                         push = true;\n                     }\n                 }\n@@ -4665,7 +4669,7 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n             // Track requests for our stuff.\n             GetMainSignals().Inventory(inv.hash);\n \n-            if (inv.type == MSG_BLOCK || inv.type == MSG_FILTERED_BLOCK || inv.type == MSG_CMPCT_BLOCK)\n+            if (inv.type == MSG_BLOCK || inv.type == MSG_FILTERED_BLOCK || inv.type == MSG_CMPCT_BLOCK || inv.type == MSG_WITNESS_BLOCK)\n                 break;\n         }\n     }\n@@ -5146,7 +5150,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             }\n             resp.txn[i] = block.vtx[req.indexes[i]];\n         }\n-        pfrom->PushMessage(NetMsgType::BLOCKTXN, resp);\n+        pfrom->PushMessageWithFlag(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::BLOCKTXN, resp);\n     }\n \n "
      },
      {
        "sha": "cb35d8c4f28c345e8dfe2eb4faa160f4c7b07230",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 17,
        "deletions": 0,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7030d9eb47254499bba14f1c00abc6bf493efd91/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7030d9eb47254499bba14f1c00abc6bf493efd91/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=7030d9eb47254499bba14f1c00abc6bf493efd91",
        "patch": "@@ -598,6 +598,23 @@ class CNode\n         }\n     }\n \n+    /** Send a message containing a1, serialized with flag flag. */\n+    template<typename T1>\n+    void PushMessageWithFlag(int flag, const char* pszCommand, const T1& a1)\n+    {\n+        try\n+        {\n+            BeginMessage(pszCommand);\n+            WithOrVersion(&ssSend, flag) << a1;\n+            EndMessage(pszCommand);\n+        }\n+        catch (...)\n+        {\n+            AbortMessage();\n+            throw;\n+        }\n+    }\n+\n     template<typename T1, typename T2>\n     void PushMessage(const char* pszCommand, const T1& a1, const T2& a2)\n     {"
      },
      {
        "sha": "29307aed5be4803efb271634fb3af83ce15732f1",
        "filename": "src/primitives/block.h",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7030d9eb47254499bba14f1c00abc6bf493efd91/src/primitives/block.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7030d9eb47254499bba14f1c00abc6bf493efd91/src/primitives/block.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/primitives/block.h?ref=7030d9eb47254499bba14f1c00abc6bf493efd91",
        "patch": "@@ -38,7 +38,6 @@ class CBlockHeader\n     template <typename Stream, typename Operation>\n     inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n         READWRITE(this->nVersion);\n-        nVersion = this->nVersion;\n         READWRITE(hashPrevBlock);\n         READWRITE(hashMerkleRoot);\n         READWRITE(nTime);\n@@ -120,7 +119,6 @@ class CBlock : public CBlockHeader\n     std::string ToString() const;\n };\n \n-\n /** Describes a place in the block chain to another node such that if the\n  * other node doesn't have the same branch, it can find a recent common trunk.\n  * The further back it is, the further before the fork it may be."
      },
      {
        "sha": "b0230530e804f58b8d827a59d3df2fd129d4cdaf",
        "filename": "src/primitives/transaction.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 4,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7030d9eb47254499bba14f1c00abc6bf493efd91/src/primitives/transaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7030d9eb47254499bba14f1c00abc6bf493efd91/src/primitives/transaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/primitives/transaction.cpp?ref=7030d9eb47254499bba14f1c00abc6bf493efd91",
        "patch": "@@ -60,28 +60,34 @@ std::string CTxOut::ToString() const\n }\n \n CMutableTransaction::CMutableTransaction() : nVersion(CTransaction::CURRENT_VERSION), nLockTime(0) {}\n-CMutableTransaction::CMutableTransaction(const CTransaction& tx) : nVersion(tx.nVersion), vin(tx.vin), vout(tx.vout), nLockTime(tx.nLockTime) {}\n+CMutableTransaction::CMutableTransaction(const CTransaction& tx) : nVersion(tx.nVersion), vin(tx.vin), vout(tx.vout), wit(tx.wit), nLockTime(tx.nLockTime) {}\n \n uint256 CMutableTransaction::GetHash() const\n {\n-    return SerializeHash(*this);\n+    return SerializeHash(*this, SER_GETHASH, SERIALIZE_TRANSACTION_NO_WITNESS);\n }\n \n void CTransaction::UpdateHash() const\n {\n-    *const_cast<uint256*>(&hash) = SerializeHash(*this);\n+    *const_cast<uint256*>(&hash) = SerializeHash(*this, SER_GETHASH, SERIALIZE_TRANSACTION_NO_WITNESS);\n+}\n+\n+uint256 CTransaction::GetWitnessHash() const\n+{\n+    return SerializeHash(*this, SER_GETHASH, 0);\n }\n \n CTransaction::CTransaction() : nVersion(CTransaction::CURRENT_VERSION), vin(), vout(), nLockTime(0) { }\n \n-CTransaction::CTransaction(const CMutableTransaction &tx) : nVersion(tx.nVersion), vin(tx.vin), vout(tx.vout), nLockTime(tx.nLockTime) {\n+CTransaction::CTransaction(const CMutableTransaction &tx) : nVersion(tx.nVersion), vin(tx.vin), vout(tx.vout), wit(tx.wit), nLockTime(tx.nLockTime) {\n     UpdateHash();\n }\n \n CTransaction& CTransaction::operator=(const CTransaction &tx) {\n     *const_cast<int*>(&nVersion) = tx.nVersion;\n     *const_cast<std::vector<CTxIn>*>(&vin) = tx.vin;\n     *const_cast<std::vector<CTxOut>*>(&vout) = tx.vout;\n+    *const_cast<CTxWitness*>(&wit) = tx.wit;\n     *const_cast<unsigned int*>(&nLockTime) = tx.nLockTime;\n     *const_cast<uint256*>(&hash) = tx.hash;\n     return *this;\n@@ -136,6 +142,8 @@ std::string CTransaction::ToString() const\n         nLockTime);\n     for (unsigned int i = 0; i < vin.size(); i++)\n         str += \"    \" + vin[i].ToString() + \"\\n\";\n+    for (unsigned int i = 0; i < wit.vtxinwit.size(); i++)\n+        str += \"    \" + wit.vtxinwit[i].scriptWitness.ToString() + \"\\n\";\n     for (unsigned int i = 0; i < vout.size(); i++)\n         str += \"    \" + vout[i].ToString() + \"\\n\";\n     return str;"
      },
      {
        "sha": "d8ae41ad78da3ede3432db02702244c9dc849cce",
        "filename": "src/primitives/transaction.h",
        "status": "modified",
        "additions": 140,
        "deletions": 11,
        "changes": 151,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7030d9eb47254499bba14f1c00abc6bf493efd91/src/primitives/transaction.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7030d9eb47254499bba14f1c00abc6bf493efd91/src/primitives/transaction.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/primitives/transaction.h?ref=7030d9eb47254499bba14f1c00abc6bf493efd91",
        "patch": "@@ -11,6 +11,8 @@\n #include \"serialize.h\"\n #include \"uint256.h\"\n \n+static const int SERIALIZE_TRANSACTION_NO_WITNESS = 0x40000000;\n+\n /** An outpoint - a combination of a transaction hash and an index n into its vout */\n class COutPoint\n {\n@@ -194,8 +196,137 @@ class CTxOut\n     std::string ToString() const;\n };\n \n+class CTxinWitness\n+{\n+public:\n+    CScriptWitness scriptWitness;\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion)\n+    {\n+        READWRITE(scriptWitness.stack);\n+    }\n+\n+    bool IsNull() const { return scriptWitness.IsNull(); }\n+\n+    CTxinWitness() { }\n+};\n+\n+class CTxWitness\n+{\n+public:\n+    /** In case vtxinwit is missing, all entries are treated as if they were empty CTxInWitnesses */\n+    std::vector<CTxinWitness> vtxinwit;\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    bool IsEmpty() const { return vtxinwit.empty(); }\n+\n+    bool IsNull() const\n+    {\n+        for (size_t n = 0; n < vtxinwit.size(); n++) {\n+            if (!vtxinwit[n].IsNull()) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    void SetNull()\n+    {\n+        vtxinwit.clear();\n+    }\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion)\n+    {\n+        for (size_t n = 0; n < vtxinwit.size(); n++) {\n+            READWRITE(vtxinwit[n]);\n+        }\n+        if (IsNull()) {\n+            /* It's illegal to encode a witness when all vtxinwit entries are empty. */\n+            throw std::ios_base::failure(\"Superfluous witness record\");\n+        }\n+    }\n+};\n+\n struct CMutableTransaction;\n \n+/**\n+ * Basic transaction serialization format:\n+ * - int32_t nVersion\n+ * - std::vector<CTxIn> vin\n+ * - std::vector<CTxOut> vout\n+ * - uint32_t nLockTime\n+ *\n+ * Extended transaction serialization format:\n+ * - int32_t nVersion\n+ * - unsigned char dummy = 0x00\n+ * - unsigned char flags (!= 0)\n+ * - std::vector<CTxIn> vin\n+ * - std::vector<CTxOut> vout\n+ * - if (flags & 1):\n+ *   - CTxWitness wit;\n+ * - uint32_t nLockTime\n+ */\n+template<typename Stream, typename Operation, typename TxType>\n+inline void SerializeTransaction(TxType& tx, Stream& s, Operation ser_action, int nType, int nVersion) {\n+    READWRITE(*const_cast<int32_t*>(&tx.nVersion));\n+    unsigned char flags = 0;\n+    if (ser_action.ForRead()) {\n+        const_cast<std::vector<CTxIn>*>(&tx.vin)->clear();\n+        const_cast<std::vector<CTxOut>*>(&tx.vout)->clear();\n+        const_cast<CTxWitness*>(&tx.wit)->SetNull();\n+        /* Try to read the vin. In case the dummy is there, this will be read as an empty vector. */\n+        READWRITE(*const_cast<std::vector<CTxIn>*>(&tx.vin));\n+        if (tx.vin.size() == 0 && !(nVersion & SERIALIZE_TRANSACTION_NO_WITNESS)) {\n+            /* We read a dummy or an empty vin. */\n+            READWRITE(flags);\n+            if (flags != 0) {\n+                READWRITE(*const_cast<std::vector<CTxIn>*>(&tx.vin));\n+                READWRITE(*const_cast<std::vector<CTxOut>*>(&tx.vout));\n+            }\n+        } else {\n+            /* We read a non-empty vin. Assume a normal vout follows. */\n+            READWRITE(*const_cast<std::vector<CTxOut>*>(&tx.vout));\n+        }\n+        if ((flags & 1) && !(nVersion & SERIALIZE_TRANSACTION_NO_WITNESS)) {\n+            /* The witness flag is present, and we support witnesses. */\n+            flags ^= 1;\n+            const_cast<CTxWitness*>(&tx.wit)->vtxinwit.resize(tx.vin.size());\n+            READWRITE(tx.wit);\n+        }\n+        if (flags) {\n+            /* Unknown flag in the serialization */\n+            throw std::ios_base::failure(\"Unknown transaction optional data\");\n+        }\n+    } else {\n+        // Consistency check\n+        assert(tx.wit.vtxinwit.size() <= tx.vin.size());\n+        if (!(nVersion & SERIALIZE_TRANSACTION_NO_WITNESS)) {\n+            /* Check whether witnesses need to be serialized. */\n+            if (!tx.wit.IsNull()) {\n+                flags |= 1;\n+            }\n+        }\n+        if (flags) {\n+            /* Use extended format in case witnesses are to be serialized. */\n+            std::vector<CTxIn> vinDummy;\n+            READWRITE(vinDummy);\n+            READWRITE(flags);\n+        }\n+        READWRITE(*const_cast<std::vector<CTxIn>*>(&tx.vin));\n+        READWRITE(*const_cast<std::vector<CTxOut>*>(&tx.vout));\n+        if (flags & 1) {\n+            const_cast<CTxWitness*>(&tx.wit)->vtxinwit.resize(tx.vin.size());\n+            READWRITE(tx.wit);\n+        }\n+    }\n+    READWRITE(*const_cast<uint32_t*>(&tx.nLockTime));\n+}\n+\n /** The basic transaction that is broadcasted on the network and contained in\n  * blocks.  A transaction can contain multiple inputs and outputs.\n  */\n@@ -224,6 +355,7 @@ class CTransaction\n     const int32_t nVersion;\n     const std::vector<CTxIn> vin;\n     const std::vector<CTxOut> vout;\n+    CTxWitness wit; // Not const: can change without invalidating the txid cache\n     const uint32_t nLockTime;\n \n     /** Construct a CTransaction that qualifies as IsNull() */\n@@ -238,13 +370,10 @@ class CTransaction\n \n     template <typename Stream, typename Operation>\n     inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n-        READWRITE(*const_cast<int32_t*>(&this->nVersion));\n-        nVersion = this->nVersion;\n-        READWRITE(*const_cast<std::vector<CTxIn>*>(&vin));\n-        READWRITE(*const_cast<std::vector<CTxOut>*>(&vout));\n-        READWRITE(*const_cast<uint32_t*>(&nLockTime));\n-        if (ser_action.ForRead())\n+        SerializeTransaction(*this, s, ser_action, nType, nVersion);\n+        if (ser_action.ForRead()) {\n             UpdateHash();\n+        }\n     }\n \n     bool IsNull() const {\n@@ -255,6 +384,9 @@ class CTransaction\n         return hash;\n     }\n \n+    // Compute a hash that includes both transaction and witness data\n+    uint256 GetWitnessHash() const;\n+\n     // Return sum of txouts.\n     CAmount GetValueOut() const;\n     // GetValueIn() is a method on CCoinsViewCache, because\n@@ -290,6 +422,7 @@ struct CMutableTransaction\n     int32_t nVersion;\n     std::vector<CTxIn> vin;\n     std::vector<CTxOut> vout;\n+    CTxWitness wit;\n     uint32_t nLockTime;\n \n     CMutableTransaction();\n@@ -299,11 +432,7 @@ struct CMutableTransaction\n \n     template <typename Stream, typename Operation>\n     inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n-        READWRITE(this->nVersion);\n-        nVersion = this->nVersion;\n-        READWRITE(vin);\n-        READWRITE(vout);\n-        READWRITE(nLockTime);\n+        SerializeTransaction(*this, s, ser_action, nType, nVersion);\n     }\n \n     /** Compute the hash of this CMutableTransaction. This is computed on the"
      },
      {
        "sha": "247c6c212073e201007dab7d87509b7bb64ae932",
        "filename": "src/protocol.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 33,
        "changes": 46,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7030d9eb47254499bba14f1c00abc6bf493efd91/src/protocol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7030d9eb47254499bba14f1c00abc6bf493efd91/src/protocol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.cpp?ref=7030d9eb47254499bba14f1c00abc6bf493efd91",
        "patch": "@@ -41,15 +41,6 @@ const char *GETBLOCKTXN=\"getblocktxn\";\n const char *BLOCKTXN=\"blocktxn\";\n };\n \n-static const char* ppszTypeName[] =\n-{\n-    \"ERROR\", // Should never occur\n-    NetMsgType::TX,\n-    NetMsgType::BLOCK,\n-    \"filtered block\", // Should never occur\n-    \"compact block\" // Should never occur\n-};\n-\n /** All known message types. Keep this in the same order as the list of\n  * messages above and in protocol.h.\n  */\n@@ -166,37 +157,26 @@ CInv::CInv(int typeIn, const uint256& hashIn)\n     hash = hashIn;\n }\n \n-CInv::CInv(const std::string& strType, const uint256& hashIn)\n-{\n-    unsigned int i;\n-    for (i = 1; i < ARRAYLEN(ppszTypeName); i++)\n-    {\n-        if (strType == ppszTypeName[i])\n-        {\n-            type = i;\n-            break;\n-        }\n-    }\n-    if (i == ARRAYLEN(ppszTypeName))\n-        throw std::out_of_range(strprintf(\"CInv::CInv(string, uint256): unknown type '%s'\", strType));\n-    hash = hashIn;\n-}\n-\n bool operator<(const CInv& a, const CInv& b)\n {\n     return (a.type < b.type || (a.type == b.type && a.hash < b.hash));\n }\n \n-bool CInv::IsKnownType() const\n+std::string CInv::GetCommand() const\n {\n-    return (type >= 1 && type < (int)ARRAYLEN(ppszTypeName));\n-}\n-\n-const char* CInv::GetCommand() const\n-{\n-    if (!IsKnownType())\n+    std::string cmd;\n+    if (type & MSG_WITNESS_FLAG)\n+        cmd.append(\"witness-\");\n+    int masked = type & MSG_TYPE_MASK;\n+    switch (masked)\n+    {\n+    case MSG_TX:             return cmd.append(NetMsgType::TX);\n+    case MSG_BLOCK:          return cmd.append(NetMsgType::BLOCK);\n+    case MSG_FILTERED_BLOCK: return cmd.append(NetMsgType::MERKLEBLOCK);\n+    case MSG_CMPCT_BLOCK:    return cmd.append(NetMsgType::CMPCTBLOCK);\n+    default:\n         throw std::out_of_range(strprintf(\"CInv::GetCommand(): type=%d unknown type\", type));\n-    return ppszTypeName[type];\n+    }\n }\n \n std::string CInv::ToString() const"
      },
      {
        "sha": "dd07092f5f8d9873804d56283ebe50684af329a9",
        "filename": "src/protocol.h",
        "status": "modified",
        "additions": 18,
        "deletions": 12,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7030d9eb47254499bba14f1c00abc6bf493efd91/src/protocol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7030d9eb47254499bba14f1c00abc6bf493efd91/src/protocol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.h?ref=7030d9eb47254499bba14f1c00abc6bf493efd91",
        "patch": "@@ -309,13 +309,29 @@ class CAddress : public CService\n     unsigned int nTime;\n };\n \n+/** getdata message types */\n+const uint32_t MSG_WITNESS_FLAG = 1 << 30;\n+const uint32_t MSG_TYPE_MASK    = 0xffffffff >> 2;\n+enum GetDataMsg\n+{\n+    UNDEFINED = 0,\n+    MSG_TX,\n+    MSG_BLOCK,\n+    MSG_TYPE_MAX = MSG_BLOCK,\n+    // The following can only occur in getdata. Invs always use TX or BLOCK.\n+    MSG_FILTERED_BLOCK,\n+    MSG_CMPCT_BLOCK,\n+    MSG_WITNESS_BLOCK = MSG_BLOCK | MSG_WITNESS_FLAG,\n+    MSG_WITNESS_TX = MSG_TX | MSG_WITNESS_FLAG,\n+    MSG_FILTERED_WITNESS_BLOCK = MSG_FILTERED_BLOCK | MSG_WITNESS_FLAG,\n+};\n+\n /** inv message data */\n class CInv\n {\n public:\n     CInv();\n     CInv(int typeIn, const uint256& hashIn);\n-    CInv(const std::string& strType, const uint256& hashIn);\n \n     ADD_SERIALIZE_METHODS;\n \n@@ -328,8 +344,7 @@ class CInv\n \n     friend bool operator<(const CInv& a, const CInv& b);\n \n-    bool IsKnownType() const;\n-    const char* GetCommand() const;\n+    std::string GetCommand() const;\n     std::string ToString() const;\n \n     // TODO: make private (improves encapsulation)\n@@ -338,13 +353,4 @@ class CInv\n     uint256 hash;\n };\n \n-enum {\n-    MSG_TX = 1,\n-    MSG_BLOCK,\n-    // Nodes may always request a MSG_FILTERED_BLOCK/MSG_CMPCT_BLOCK in a getdata, however,\n-    // MSG_FILTERED_BLOCK/MSG_CMPCT_BLOCK should not appear in any invs except as a part of getdata.\n-    MSG_FILTERED_BLOCK,\n-    MSG_CMPCT_BLOCK,\n-};\n-\n #endif // BITCOIN_PROTOCOL_H"
      },
      {
        "sha": "837f8ba6c18f52f0e3482437b1b6e8de2b899268",
        "filename": "src/qt/coincontroldialog.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 1,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7030d9eb47254499bba14f1c00abc6bf493efd91/src/qt/coincontroldialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7030d9eb47254499bba14f1c00abc6bf493efd91/src/qt/coincontroldialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/coincontroldialog.cpp?ref=7030d9eb47254499bba14f1c00abc6bf493efd91",
        "patch": "@@ -485,6 +485,7 @@ void CoinControlDialog::updateLabels(WalletModel *model, QDialog* dialog)\n     unsigned int nQuantity      = 0;\n     int nQuantityUncompressed   = 0;\n     bool fAllowFree             = false;\n+    bool fWitness               = false;\n \n     std::vector<COutPoint> vCoinControl;\n     std::vector<COutput>   vOutputs;\n@@ -513,7 +514,14 @@ void CoinControlDialog::updateLabels(WalletModel *model, QDialog* dialog)\n \n         // Bytes\n         CTxDestination address;\n-        if(ExtractDestination(out.tx->vout[out.i].scriptPubKey, address))\n+        int witnessversion = 0;\n+        std::vector<unsigned char> witnessprogram;\n+        if (out.tx->vout[out.i].scriptPubKey.IsWitnessProgram(witnessversion, witnessprogram))\n+        {\n+            nBytesInputs += (32 + 4 + 1 + (107 / WITNESS_SCALE_FACTOR) + 4);\n+            fWitness = true;\n+        }\n+        else if(ExtractDestination(out.tx->vout[out.i].scriptPubKey, address))\n         {\n             CPubKey pubkey;\n             CKeyID *keyid = boost::get<CKeyID>(&address);\n@@ -534,6 +542,14 @@ void CoinControlDialog::updateLabels(WalletModel *model, QDialog* dialog)\n     {\n         // Bytes\n         nBytes = nBytesInputs + ((CoinControlDialog::payAmounts.size() > 0 ? CoinControlDialog::payAmounts.size() + 1 : 2) * 34) + 10; // always assume +1 output for change here\n+        if (fWitness)\n+        {\n+            // there is some fudging in these numbers related to the actual virtual transaction size calculation that will keep this estimate from being exact.\n+            // usually, the result will be an overestimate within a couple of satoshis so that the confirmation dialog ends up displaying a slightly smaller fee.\n+            // also, the witness stack size value value is a variable sized integer. usually, the number of stack items will be well under the single byte var int limit.\n+            nBytes += 2; // account for the serialized marker and flag bytes\n+            nBytes += nQuantity; // account for the witness byte that holds the number of stack items for each input.\n+        }\n \n         // Priority\n         double mempoolEstimatePriority = mempool.estimateSmartPriority(nTxConfirmTarget);"
      },
      {
        "sha": "ffadf89cc85360958f33448ba09a9d071830ba48",
        "filename": "src/qt/walletmodeltransaction.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7030d9eb47254499bba14f1c00abc6bf493efd91/src/qt/walletmodeltransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7030d9eb47254499bba14f1c00abc6bf493efd91/src/qt/walletmodeltransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletmodeltransaction.cpp?ref=7030d9eb47254499bba14f1c00abc6bf493efd91",
        "patch": "@@ -4,6 +4,7 @@\n \n #include \"walletmodeltransaction.h\"\n \n+#include \"policy/policy.h\"\n #include \"wallet/wallet.h\"\n \n WalletModelTransaction::WalletModelTransaction(const QList<SendCoinsRecipient> &recipients) :\n@@ -33,7 +34,7 @@ CWalletTx *WalletModelTransaction::getTransaction()\n \n unsigned int WalletModelTransaction::getTransactionSize()\n {\n-    return (!walletTransaction ? 0 : (::GetSerializeSize(*(CTransaction*)walletTransaction, SER_NETWORK, PROTOCOL_VERSION)));\n+    return (!walletTransaction ? 0 : ::GetVirtualTransactionSize(*walletTransaction));\n }\n \n CAmount WalletModelTransaction::getTransactionFee()"
      },
      {
        "sha": "e4a6e0f39b38847764bce0e714c387048674e115",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7030d9eb47254499bba14f1c00abc6bf493efd91/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7030d9eb47254499bba14f1c00abc6bf493efd91/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=7030d9eb47254499bba14f1c00abc6bf493efd91",
        "patch": "@@ -276,7 +276,7 @@ UniValue gettxoutproof(const UniValue& params, bool fHelp)\n     if (ntxFound != setTxids.size())\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"(Not all) transactions not found in specified block\");\n \n-    CDataStream ssMB(SER_NETWORK, PROTOCOL_VERSION);\n+    CDataStream ssMB(SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS);\n     CMerkleBlock mb(block, setTxids);\n     ssMB << mb;\n     std::string strHex = HexStr(ssMB.begin(), ssMB.end());\n@@ -296,7 +296,7 @@ UniValue verifytxoutproof(const UniValue& params, bool fHelp)\n             \"[\\\"txid\\\"]      (array, strings) The txid(s) which the proof commits to, or empty array if the proof is invalid\\n\"\n         );\n \n-    CDataStream ssMB(ParseHexV(params[0], \"proof\"), SER_NETWORK, PROTOCOL_VERSION);\n+    CDataStream ssMB(ParseHexV(params[0], \"proof\"), SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS);\n     CMerkleBlock merkleBlock;\n     ssMB >> merkleBlock;\n \n@@ -487,7 +487,7 @@ UniValue decoderawtransaction(const UniValue& params, bool fHelp)\n \n     CTransaction tx;\n \n-    if (!DecodeHexTx(tx, params[0].get_str()))\n+    if (!DecodeHexTx(tx, params[0].get_str(), true))\n         throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed\");\n \n     UniValue result(UniValue::VOBJ);"
      },
      {
        "sha": "6b1eb52bbf8c2292383e2dfdb8d957d6515607b7",
        "filename": "src/script/script.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7030d9eb47254499bba14f1c00abc6bf493efd91/src/script/script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7030d9eb47254499bba14f1c00abc6bf493efd91/src/script/script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script.cpp?ref=7030d9eb47254499bba14f1c00abc6bf493efd91",
        "patch": "@@ -231,3 +231,15 @@ bool CScript::IsPushOnly() const\n {\n     return this->IsPushOnly(begin());\n }\n+\n+std::string CScriptWitness::ToString() const\n+{\n+    std::string ret = \"CScriptWitness(\";\n+    for (unsigned int i = 0; i < stack.size(); i++) {\n+        if (i) {\n+            ret += \", \";\n+        }\n+        ret += HexStr(stack[i]);\n+    }\n+    return ret + \")\";\n+}"
      },
      {
        "sha": "0b6d822d81ae067e289ecc9143704dcd3f4d317f",
        "filename": "src/script/script.h",
        "status": "modified",
        "additions": 14,
        "deletions": 0,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7030d9eb47254499bba14f1c00abc6bf493efd91/src/script/script.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7030d9eb47254499bba14f1c00abc6bf493efd91/src/script/script.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script.h?ref=7030d9eb47254499bba14f1c00abc6bf493efd91",
        "patch": "@@ -643,6 +643,20 @@ class CScript : public CScriptBase\n     }\n };\n \n+struct CScriptWitness\n+{\n+    // Note that this encodes the data elements being pushed, rather than\n+    // encoding them as a CScript that pushes them.\n+    std::vector<std::vector<unsigned char> > stack;\n+\n+    // Some compilers complain without a default constructor\n+    CScriptWitness() { }\n+\n+    bool IsNull() const { return stack.empty(); }\n+\n+    std::string ToString() const;\n+};\n+\n class CReserveScript\n {\n public:"
      },
      {
        "sha": "7132364eb19510cb897ee3419d6e01526164ab79",
        "filename": "src/streams.h",
        "status": "modified",
        "additions": 33,
        "deletions": 0,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7030d9eb47254499bba14f1c00abc6bf493efd91/src/streams.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7030d9eb47254499bba14f1c00abc6bf493efd91/src/streams.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/streams.h?ref=7030d9eb47254499bba14f1c00abc6bf493efd91",
        "patch": "@@ -22,6 +22,39 @@\n #include <utility>\n #include <vector>\n \n+template<typename Stream>\n+class OverrideStream\n+{\n+    Stream* stream;\n+public:\n+    const int nType;\n+    const int nVersion;\n+\n+    OverrideStream(Stream* stream_, int nType_, int nVersion_) : stream(stream_), nType(nType_), nVersion(nVersion_) {}\n+\n+    template<typename T>\n+    OverrideStream<Stream>& operator<<(const T& obj)\n+    {\n+        // Serialize to this stream\n+        ::Serialize(*this->stream, obj, nType, nVersion);\n+        return (*this);\n+    }\n+\n+    template<typename T>\n+    OverrideStream<Stream>& operator>>(T& obj)\n+    {\n+        // Unserialize from this stream\n+        ::Unserialize(*this->stream, obj, nType, nVersion);\n+        return (*this);\n+    }\n+};\n+\n+template<typename S>\n+OverrideStream<S> WithOrVersion(S* s, int nVersionFlag)\n+{\n+    return OverrideStream<S>(s, s->GetType(), s->GetVersion() | nVersionFlag);\n+}\n+\n /** Double ended buffer combining vector and stream-like interfaces.\n  *\n  * >> and << read and write unformatted data using the above serialization templates."
      },
      {
        "sha": "4719f2b38877a79134ef5904db80aac27e3a55d5",
        "filename": "src/test/data/tx_invalid.json",
        "status": "modified",
        "additions": 0,
        "deletions": 4,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7030d9eb47254499bba14f1c00abc6bf493efd91/src/test/data/tx_invalid.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7030d9eb47254499bba14f1c00abc6bf493efd91/src/test/data/tx_invalid.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/data/tx_invalid.json?ref=7030d9eb47254499bba14f1c00abc6bf493efd91",
        "patch": "@@ -30,10 +30,6 @@\n \"010000000100010000000000000000000000000000000000000000000000000000000000000000000009085768617420697320ffffffff010000000000000000015100000000\", \"P2SH\"],\n \n [\"Tests for CheckTransaction()\"],\n-[\"No inputs\"],\n-[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"HASH160 0x14 0x7a052c840ba73af26755de42cf01cc9e0a49fef0 EQUAL\"]],\n-\"0100000000010000000000000000015100000000\", \"P2SH\"],\n-\n [\"No outputs\"],\n [[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"HASH160 0x14 0x05ab9e14d983742513f0f451e105ffb4198d1dd4 EQUAL\"]],\n \"01000000010001000000000000000000000000000000000000000000000000000000000000000000006d483045022100f16703104aab4e4088317c862daec83440242411b039d14280e03dd33b487ab802201318a7be236672c5c56083eb7a5a195bc57a40af7923ff8545016cd3b571e2a601232103c40e5d339df3f30bf753e7e04450ae4ef76c9e45587d1d993bdc4cd06f0651c7acffffffff0000000000\", \"P2SH\"],"
      },
      {
        "sha": "375accbac720691ef0211756f04d3cbba3932225",
        "filename": "src/test/sighash_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7030d9eb47254499bba14f1c00abc6bf493efd91/src/test/sighash_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7030d9eb47254499bba14f1c00abc6bf493efd91/src/test/sighash_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/sighash_tests.cpp?ref=7030d9eb47254499bba14f1c00abc6bf493efd91",
        "patch": "@@ -82,7 +82,7 @@ uint256 static SignatureHashOld(CScript scriptCode, const CTransaction& txTo, un\n     }\n \n     // Serialize and hash\n-    CHashWriter ss(SER_GETHASH, 0);\n+    CHashWriter ss(SER_GETHASH, SERIALIZE_TRANSACTION_NO_WITNESS);\n     ss << txTmp << nHashType;\n     return ss.GetHash();\n }"
      },
      {
        "sha": "318fddc1ae9f95c943b3df64df80de980ba4213c",
        "filename": "src/test/transaction_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7030d9eb47254499bba14f1c00abc6bf493efd91/src/test/transaction_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7030d9eb47254499bba14f1c00abc6bf493efd91/src/test/transaction_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/transaction_tests.cpp?ref=7030d9eb47254499bba14f1c00abc6bf493efd91",
        "patch": "@@ -208,7 +208,7 @@ BOOST_AUTO_TEST_CASE(tx_invalid)\n             }\n \n             string transaction = test[1].get_str();\n-            CDataStream stream(ParseHex(transaction), SER_NETWORK, PROTOCOL_VERSION);\n+            CDataStream stream(ParseHex(transaction), SER_NETWORK, PROTOCOL_VERSION );\n             CTransaction tx;\n             stream >> tx;\n "
      },
      {
        "sha": "3666c37ac3eda5f1b9d4a1f23b271f6c03f06252",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7030d9eb47254499bba14f1c00abc6bf493efd91/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7030d9eb47254499bba14f1c00abc6bf493efd91/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=7030d9eb47254499bba14f1c00abc6bf493efd91",
        "patch": "@@ -2451,7 +2451,7 @@ UniValue fundrawtransaction(const UniValue& params, bool fHelp)\n \n     // parse hex string from parameter\n     CTransaction origTx;\n-    if (!DecodeHexTx(origTx, params[0].get_str()))\n+    if (!DecodeHexTx(origTx, params[0].get_str(), true))\n         throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed\");\n \n     if (origTx.vout.size() == 0)"
      },
      {
        "sha": "d083722dd23ac9d72ef64d8ea5e64bc998aa30c0",
        "filename": "src/wallet/walletdb.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7030d9eb47254499bba14f1c00abc6bf493efd91/src/wallet/walletdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7030d9eb47254499bba14f1c00abc6bf493efd91/src/wallet/walletdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/walletdb.h?ref=7030d9eb47254499bba14f1c00abc6bf493efd91",
        "patch": "@@ -7,6 +7,7 @@\n #define BITCOIN_WALLET_WALLETDB_H\n \n #include \"amount.h\"\n+#include \"primitives/transaction.h\"\n #include \"wallet/db.h\"\n #include \"key.h\"\n "
      }
    ]
  },
  {
    "sha": "449f9b8debcceb61a92043bc7031528a53627c47",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0NDlmOWI4ZGViY2NlYjYxYTkyMDQzYmM3MDMxNTI4YTUzNjI3YzQ3",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2015-11-08T00:16:45Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-06-22T13:42:59Z"
      },
      "message": "BIP141: Witness program",
      "tree": {
        "sha": "c55434295cae8c338fe8ec128c325fa254303ecb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c55434295cae8c338fe8ec128c325fa254303ecb"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/449f9b8debcceb61a92043bc7031528a53627c47",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/449f9b8debcceb61a92043bc7031528a53627c47",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/449f9b8debcceb61a92043bc7031528a53627c47",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/449f9b8debcceb61a92043bc7031528a53627c47/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7030d9eb47254499bba14f1c00abc6bf493efd91",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7030d9eb47254499bba14f1c00abc6bf493efd91",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7030d9eb47254499bba14f1c00abc6bf493efd91"
      }
    ],
    "stats": {
      "total": 238,
      "additions": 201,
      "deletions": 37
    },
    "files": [
      {
        "sha": "82a5583dda6e50a9626c2bb522d782492b26630b",
        "filename": "src/bitcoin-tx.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/449f9b8debcceb61a92043bc7031528a53627c47/src/bitcoin-tx.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/449f9b8debcceb61a92043bc7031528a53627c47/src/bitcoin-tx.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-tx.cpp?ref=449f9b8debcceb61a92043bc7031528a53627c47",
        "patch": "@@ -472,7 +472,7 @@ static void MutateTxSign(CMutableTransaction& tx, const string& flagStr)\n         BOOST_FOREACH(const CTransaction& txv, txVariants) {\n             txin.scriptSig = CombineSignatures(prevPubKey, mergedTx, i, txin.scriptSig, txv.vin[i].scriptSig);\n         }\n-        if (!VerifyScript(txin.scriptSig, prevPubKey, STANDARD_SCRIPT_VERIFY_FLAGS, MutableTransactionSignatureChecker(&mergedTx, i)))\n+        if (!VerifyScript(txin.scriptSig, prevPubKey, mergedTx.wit.vtxinwit.size() > i ? &mergedTx.wit.vtxinwit[i].scriptWitness : NULL, STANDARD_SCRIPT_VERIFY_FLAGS, MutableTransactionSignatureChecker(&mergedTx, i)))\n             fComplete = false;\n     }\n "
      },
      {
        "sha": "d1945a509429c8617fdfe0570c4bde884cbf0d79",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/449f9b8debcceb61a92043bc7031528a53627c47/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/449f9b8debcceb61a92043bc7031528a53627c47/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=449f9b8debcceb61a92043bc7031528a53627c47",
        "patch": "@@ -1867,7 +1867,8 @@ void UpdateCoins(const CTransaction& tx, CCoinsViewCache& inputs, int nHeight)\n \n bool CScriptCheck::operator()() {\n     const CScript &scriptSig = ptxTo->vin[nIn].scriptSig;\n-    if (!VerifyScript(scriptSig, scriptPubKey, nFlags, CachingTransactionSignatureChecker(ptxTo, nIn, cacheStore), &error)) {\n+    const CScriptWitness *witness = (nIn < ptxTo->wit.vtxinwit.size()) ? &ptxTo->wit.vtxinwit[nIn].scriptWitness : NULL;\n+    if (!VerifyScript(scriptSig, scriptPubKey, witness, nFlags, CachingTransactionSignatureChecker(ptxTo, nIn, cacheStore), &error)) {\n         return false;\n     }\n     return true;"
      },
      {
        "sha": "a6bcc777ff51d21e6cbb0b422232ae70010afa53",
        "filename": "src/policy/policy.h",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/449f9b8debcceb61a92043bc7031528a53627c47/src/policy/policy.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/449f9b8debcceb61a92043bc7031528a53627c47/src/policy/policy.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/policy.h?ref=449f9b8debcceb61a92043bc7031528a53627c47",
        "patch": "@@ -41,7 +41,9 @@ static const unsigned int STANDARD_SCRIPT_VERIFY_FLAGS = MANDATORY_SCRIPT_VERIFY\n                                                          SCRIPT_VERIFY_CLEANSTACK |\n                                                          SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY |\n                                                          SCRIPT_VERIFY_CHECKSEQUENCEVERIFY |\n-                                                         SCRIPT_VERIFY_LOW_S;\n+                                                         SCRIPT_VERIFY_LOW_S |\n+                                                         SCRIPT_VERIFY_WITNESS |\n+                                                         SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM;\n \n /** For convenience, standard but not mandatory verify flags. */\n static const unsigned int STANDARD_NOT_MANDATORY_VERIFY_FLAGS = STANDARD_SCRIPT_VERIFY_FLAGS & ~MANDATORY_SCRIPT_VERIFY_FLAGS;"
      },
      {
        "sha": "17c9a84602e35b88467195556359347050f4c053",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/449f9b8debcceb61a92043bc7031528a53627c47/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/449f9b8debcceb61a92043bc7031528a53627c47/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=449f9b8debcceb61a92043bc7031528a53627c47",
        "patch": "@@ -789,7 +789,7 @@ UniValue signrawtransaction(const UniValue& params, bool fHelp)\n             txin.scriptSig = CombineSignatures(prevPubKey, txConst, i, txin.scriptSig, txv.vin[i].scriptSig);\n         }\n         ScriptError serror = SCRIPT_ERR_OK;\n-        if (!VerifyScript(txin.scriptSig, prevPubKey, STANDARD_SCRIPT_VERIFY_FLAGS, TransactionSignatureChecker(&txConst, i), &serror)) {\n+        if (!VerifyScript(txin.scriptSig, prevPubKey, mergedTx.wit.vtxinwit.size() > i ? &mergedTx.wit.vtxinwit[i].scriptWitness : NULL, STANDARD_SCRIPT_VERIFY_FLAGS, TransactionSignatureChecker(&txConst, i), &serror)) {\n             TxInErrorToJSON(txin, vErrors, ScriptErrorString(serror));\n         }\n     }"
      },
      {
        "sha": "5c9e7c0a571a5cab15c259671c496570b6020ed5",
        "filename": "src/script/bitcoinconsensus.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/449f9b8debcceb61a92043bc7031528a53627c47/src/script/bitcoinconsensus.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/449f9b8debcceb61a92043bc7031528a53627c47/src/script/bitcoinconsensus.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/bitcoinconsensus.cpp?ref=449f9b8debcceb61a92043bc7031528a53627c47",
        "patch": "@@ -85,7 +85,7 @@ int bitcoinconsensus_verify_script(const unsigned char *scriptPubKey, unsigned i\n          // Regardless of the verification result, the tx did not error.\n          set_error(err, bitcoinconsensus_ERR_OK);\n \n-        return VerifyScript(tx.vin[nIn].scriptSig, CScript(scriptPubKey, scriptPubKey + scriptPubKeyLen), flags, TransactionSignatureChecker(&tx, nIn), NULL);\n+        return VerifyScript(tx.vin[nIn].scriptSig, CScript(scriptPubKey, scriptPubKey + scriptPubKeyLen), nIn < tx.wit.vtxinwit.size() ? &tx.wit.vtxinwit[nIn].scriptWitness : NULL, flags, TransactionSignatureChecker(&tx, nIn), NULL);\n     } catch (const std::exception&) {\n         return set_error(err, bitcoinconsensus_ERR_TX_DESERIALIZE); // Error deserializing\n     }"
      },
      {
        "sha": "be649fca20d3de141c00312efb2acf67d40e0f46",
        "filename": "src/script/interpreter.cpp",
        "status": "modified",
        "additions": 109,
        "deletions": 2,
        "changes": 111,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/449f9b8debcceb61a92043bc7031528a53627c47/src/script/interpreter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/449f9b8debcceb61a92043bc7031528a53627c47/src/script/interpreter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.cpp?ref=449f9b8debcceb61a92043bc7031528a53627c47",
        "patch": "@@ -1239,8 +1239,67 @@ bool TransactionSignatureChecker::CheckSequence(const CScriptNum& nSequence) con\n     return true;\n }\n \n-bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror)\n+static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion, const std::vector<unsigned char>& program, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror)\n {\n+    vector<vector<unsigned char> > stack;\n+    CScript scriptPubKey;\n+\n+    if (witversion == 0) {\n+        if (program.size() == 32) {\n+            // Version 0 segregated witness program: SHA256(CScript) inside the program, CScript + inputs in witness\n+            if (witness.stack.size() == 0) {\n+                return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_WITNESS_EMPTY);\n+            }\n+            scriptPubKey = CScript(witness.stack.back().begin(), witness.stack.back().end());\n+            stack = std::vector<std::vector<unsigned char> >(witness.stack.begin(), witness.stack.end() - 1);\n+            uint256 hashScriptPubKey;\n+            CSHA256().Write(&scriptPubKey[0], scriptPubKey.size()).Finalize(hashScriptPubKey.begin());\n+            if (memcmp(hashScriptPubKey.begin(), &program[0], 32)) {\n+                return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH);\n+            }\n+        } else if (program.size() == 20) {\n+            // Special case for pay-to-pubkeyhash; signature + pubkey in witness\n+            if (witness.stack.size() != 2) {\n+                return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH); // 2 items in witness\n+            }\n+            scriptPubKey << OP_DUP << OP_HASH160 << program << OP_EQUALVERIFY << OP_CHECKSIG;\n+            stack = witness.stack;\n+        } else {\n+            return set_error(serror, SCRIPT_ERR_WITNESS_PROGRAM_WRONG_LENGTH);\n+        }\n+    } else if (flags & SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM) {\n+        return set_error(serror, SCRIPT_ERR_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM);\n+    } else {\n+        // Higher version witness scripts return true for future softfork compatibility\n+        return set_success(serror);\n+    }\n+\n+    // Disallow stack item size > MAX_SCRIPT_ELEMENT_SIZE in witness stack\n+    for (unsigned int i = 0; i < stack.size(); i++) {\n+        if (stack.at(i).size() > MAX_SCRIPT_ELEMENT_SIZE)\n+            return set_error(serror, SCRIPT_ERR_PUSH_SIZE);\n+    }\n+\n+    if (!EvalScript(stack, scriptPubKey, flags, checker, serror)) {\n+        return false;\n+    }\n+\n+    // Scripts inside witness implicitly require cleanstack behaviour\n+    if (stack.size() != 1)\n+        return set_error(serror, SCRIPT_ERR_EVAL_FALSE);\n+    if (!CastToBool(stack.back()))\n+        return set_error(serror, SCRIPT_ERR_EVAL_FALSE);\n+    return true;\n+}\n+\n+bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CScriptWitness* witness, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror)\n+{\n+    static const CScriptWitness emptyWitness;\n+    if (witness == NULL) {\n+        witness = &emptyWitness;\n+    }\n+    bool hadWitness = false;\n+\n     set_error(serror, SCRIPT_ERR_UNKNOWN_ERROR);\n \n     if ((flags & SCRIPT_VERIFY_SIGPUSHONLY) != 0 && !scriptSig.IsPushOnly()) {\n@@ -1261,6 +1320,25 @@ bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, unsigne\n     if (CastToBool(stack.back()) == false)\n         return set_error(serror, SCRIPT_ERR_EVAL_FALSE);\n \n+    // Bare witness programs\n+    int witnessversion;\n+    std::vector<unsigned char> witnessprogram;\n+    if (flags & SCRIPT_VERIFY_WITNESS) {\n+        if (scriptPubKey.IsWitnessProgram(witnessversion, witnessprogram)) {\n+            hadWitness = true;\n+            if (scriptSig.size() != 0) {\n+                // The scriptSig must be _exactly_ CScript(), otherwise we reintroduce malleability.\n+                return set_error(serror, SCRIPT_ERR_WITNESS_MALLEATED);\n+            }\n+            if (!VerifyWitnessProgram(*witness, witnessversion, witnessprogram, flags, checker, serror)) {\n+                return false;\n+            }\n+            // Bypass the cleanstack check at the end. The actual stack is obviously not clean\n+            // for witness programs.\n+            stack.resize(1);\n+        }\n+    }\n+\n     // Additional validation for spend-to-script-hash transactions:\n     if ((flags & SCRIPT_VERIFY_P2SH) && scriptPubKey.IsPayToScriptHash())\n     {\n@@ -1287,19 +1365,48 @@ bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, unsigne\n             return set_error(serror, SCRIPT_ERR_EVAL_FALSE);\n         if (!CastToBool(stack.back()))\n             return set_error(serror, SCRIPT_ERR_EVAL_FALSE);\n+\n+        // P2SH witness program\n+        if (flags & SCRIPT_VERIFY_WITNESS) {\n+            if (pubKey2.IsWitnessProgram(witnessversion, witnessprogram)) {\n+                hadWitness = true;\n+                if (scriptSig != CScript() << std::vector<unsigned char>(pubKey2.begin(), pubKey2.end())) {\n+                    // The scriptSig must be _exactly_ a single push of the redeemScript. Otherwise we\n+                    // reintroduce malleability.\n+                    return set_error(serror, SCRIPT_ERR_WITNESS_MALLEATED_P2SH);\n+                }\n+                if (!VerifyWitnessProgram(*witness, witnessversion, witnessprogram, flags, checker, serror)) {\n+                    return false;\n+                }\n+                // Bypass the cleanstack check at the end. The actual stack is obviously not clean\n+                // for witness programs.\n+                stack.resize(1);\n+            }\n+        }\n     }\n \n     // The CLEANSTACK check is only performed after potential P2SH evaluation,\n     // as the non-P2SH evaluation of a P2SH script will obviously not result in\n-    // a clean stack (the P2SH inputs remain).\n+    // a clean stack (the P2SH inputs remain). The same holds for witness evaluation.\n     if ((flags & SCRIPT_VERIFY_CLEANSTACK) != 0) {\n         // Disallow CLEANSTACK without P2SH, as otherwise a switch CLEANSTACK->P2SH+CLEANSTACK\n         // would be possible, which is not a softfork (and P2SH should be one).\n         assert((flags & SCRIPT_VERIFY_P2SH) != 0);\n+        assert((flags & SCRIPT_VERIFY_WITNESS) != 0);\n         if (stack.size() != 1) {\n             return set_error(serror, SCRIPT_ERR_CLEANSTACK);\n         }\n     }\n \n+    if (flags & SCRIPT_VERIFY_WITNESS) {\n+        // We can't check for correct unexpected witness data if P2SH was off, so require\n+        // that WITNESS implies P2SH. Otherwise, going from WITNESS->P2SH+WITNESS would be\n+        // possible, which is not a softfork.\n+        assert((flags & SCRIPT_VERIFY_P2SH) != 0);\n+        if (!hadWitness && !witness->IsNull()) {\n+            return set_error(serror, SCRIPT_ERR_WITNESS_UNEXPECTED);\n+        }\n+    }\n+\n     return set_success(serror);\n }"
      },
      {
        "sha": "d1459ed620f6beead773c58ea7a5cae220717a10",
        "filename": "src/script/interpreter.h",
        "status": "modified",
        "additions": 10,
        "deletions": 2,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/449f9b8debcceb61a92043bc7031528a53627c47/src/script/interpreter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/449f9b8debcceb61a92043bc7031528a53627c47/src/script/interpreter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.h?ref=449f9b8debcceb61a92043bc7031528a53627c47",
        "patch": "@@ -74,7 +74,7 @@ enum\n     // \"At least one stack element must remain, and when interpreted as a boolean, it must be true\" to\n     // \"Exactly one stack element must remain, and when interpreted as a boolean, it must be true\".\n     // (softfork safe, BIP62 rule 6)\n-    // Note: CLEANSTACK should never be used without P2SH.\n+    // Note: CLEANSTACK should never be used without P2SH or WITNESS.\n     SCRIPT_VERIFY_CLEANSTACK = (1U << 8),\n \n     // Verify CHECKLOCKTIMEVERIFY\n@@ -86,6 +86,14 @@ enum\n     //\n     // See BIP112 for details\n     SCRIPT_VERIFY_CHECKSEQUENCEVERIFY = (1U << 10),\n+\n+    // Support segregated witness\n+    //\n+    SCRIPT_VERIFY_WITNESS = (1U << 11),\n+\n+    // Making v1-v16 witness program non-standard\n+    //\n+    SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM = (1U << 12),\n };\n \n bool CheckSignatureEncoding(const std::vector<unsigned char> &vchSig, unsigned int flags, ScriptError* serror);\n@@ -139,6 +147,6 @@ class MutableTransactionSignatureChecker : public TransactionSignatureChecker\n };\n \n bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* error = NULL);\n-bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* error = NULL);\n+bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CScriptWitness* witness, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror = NULL);\n \n #endif // BITCOIN_SCRIPT_INTERPRETER_H"
      },
      {
        "sha": "73f5a61bf68bd1fb78118d10272527a82ac7bb0b",
        "filename": "src/script/script.cpp",
        "status": "modified",
        "additions": 18,
        "deletions": 0,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/449f9b8debcceb61a92043bc7031528a53627c47/src/script/script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/449f9b8debcceb61a92043bc7031528a53627c47/src/script/script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script.cpp?ref=449f9b8debcceb61a92043bc7031528a53627c47",
        "patch": "@@ -210,6 +210,24 @@ bool CScript::IsPayToScriptHash() const\n             (*this)[22] == OP_EQUAL);\n }\n \n+// A witness program is any valid CScript that consists of a 1-byte push opcode\n+// followed by a data push between 2 and 40 bytes.\n+bool CScript::IsWitnessProgram(int& version, std::vector<unsigned char>& program) const\n+{\n+    if (this->size() < 4 || this->size() > 42) {\n+        return false;\n+    }\n+    if ((*this)[0] != OP_0 && ((*this)[0] < OP_1 || (*this)[0] > OP_16)) {\n+        return false;\n+    }\n+    if ((size_t)((*this)[1] + 2) == this->size()) {\n+        version = DecodeOP_N((opcodetype)(*this)[0]);\n+        program = std::vector<unsigned char>(this->begin() + 2, this->end());\n+        return true;\n+    }\n+    return false;\n+}\n+\n bool CScript::IsPushOnly(const_iterator pc) const\n {\n     while (pc < end())"
      },
      {
        "sha": "b9b5be901389c99f8012d21f5c772424212088e7",
        "filename": "src/script/script.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/449f9b8debcceb61a92043bc7031528a53627c47/src/script/script.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/449f9b8debcceb61a92043bc7031528a53627c47/src/script/script.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script.h?ref=449f9b8debcceb61a92043bc7031528a53627c47",
        "patch": "@@ -621,6 +621,7 @@ class CScript : public CScriptBase\n     unsigned int GetSigOpCount(const CScript& scriptSig) const;\n \n     bool IsPayToScriptHash() const;\n+    bool IsWitnessProgram(int& version, std::vector<unsigned char>& program) const;\n \n     /** Called by IsStandardTx and P2SH/BIP62 VerifyScript (which makes it consensus-critical). */\n     bool IsPushOnly(const_iterator pc) const;"
      },
      {
        "sha": "cef807edcf475a5acfe61454ff2284580a630354",
        "filename": "src/script/script_error.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 0,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/449f9b8debcceb61a92043bc7031528a53627c47/src/script/script_error.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/449f9b8debcceb61a92043bc7031528a53627c47/src/script/script_error.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script_error.cpp?ref=449f9b8debcceb61a92043bc7031528a53627c47",
        "patch": "@@ -65,8 +65,22 @@ const char* ScriptErrorString(const ScriptError serror)\n             return \"Dummy CHECKMULTISIG argument must be zero\";\n         case SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS:\n             return \"NOPx reserved for soft-fork upgrades\";\n+        case SCRIPT_ERR_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM:\n+            return \"Witness version reserved for soft-fork upgrades\";\n         case SCRIPT_ERR_PUBKEYTYPE:\n             return \"Public key is neither compressed or uncompressed\";\n+        case SCRIPT_ERR_WITNESS_PROGRAM_WRONG_LENGTH:\n+            return \"Witness program has incorrect length\";\n+        case SCRIPT_ERR_WITNESS_PROGRAM_WITNESS_EMPTY:\n+            return \"Witness program was passed an empty witness\";\n+        case SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH:\n+            return \"Witness program hash mismatch\";\n+        case SCRIPT_ERR_WITNESS_MALLEATED:\n+            return \"Witness requires empty scriptSig\";\n+        case SCRIPT_ERR_WITNESS_MALLEATED_P2SH:\n+            return \"Witness requires only-redeemscript scriptSig\";\n+        case SCRIPT_ERR_WITNESS_UNEXPECTED:\n+            return \"Witness provided for non-witness script\";\n         case SCRIPT_ERR_UNKNOWN_ERROR:\n         case SCRIPT_ERR_ERROR_COUNT:\n         default: break;"
      },
      {
        "sha": "09dc6945adb45286a88f748b6da232c9af1d2069",
        "filename": "src/script/script_error.h",
        "status": "modified",
        "additions": 9,
        "deletions": 0,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/449f9b8debcceb61a92043bc7031528a53627c47/src/script/script_error.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/449f9b8debcceb61a92043bc7031528a53627c47/src/script/script_error.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script_error.h?ref=449f9b8debcceb61a92043bc7031528a53627c47",
        "patch": "@@ -51,6 +51,15 @@ typedef enum ScriptError_t\n \n     /* softfork safeness */\n     SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS,\n+    SCRIPT_ERR_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM,\n+\n+    /* segregated witness */\n+    SCRIPT_ERR_WITNESS_PROGRAM_WRONG_LENGTH,\n+    SCRIPT_ERR_WITNESS_PROGRAM_WITNESS_EMPTY,\n+    SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH,\n+    SCRIPT_ERR_WITNESS_MALLEATED,\n+    SCRIPT_ERR_WITNESS_MALLEATED_P2SH,\n+    SCRIPT_ERR_WITNESS_UNEXPECTED,\n \n     SCRIPT_ERR_ERROR_COUNT\n } ScriptError;"
      },
      {
        "sha": "37b702de17cb613f05ed6c6a7885d7a67ac74fc3",
        "filename": "src/script/sign.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/449f9b8debcceb61a92043bc7031528a53627c47/src/script/sign.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/449f9b8debcceb61a92043bc7031528a53627c47/src/script/sign.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.cpp?ref=449f9b8debcceb61a92043bc7031528a53627c47",
        "patch": "@@ -123,7 +123,7 @@ bool ProduceSignature(const BaseSignatureCreator& creator, const CScript& fromPu\n     }\n \n     // Test solution\n-    return VerifyScript(scriptSig, fromPubKey, STANDARD_SCRIPT_VERIFY_FLAGS, creator.Checker());\n+    return VerifyScript(scriptSig, fromPubKey, NULL, STANDARD_SCRIPT_VERIFY_FLAGS, creator.Checker());\n }\n \n bool SignSignature(const CKeyStore &keystore, const CScript& fromPubKey, CMutableTransaction& txTo, unsigned int nIn, int nHashType)"
      },
      {
        "sha": "a6435d94d3ad4dd7f0d98c4922244929f35e6e04",
        "filename": "src/test/multisig_tests.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/449f9b8debcceb61a92043bc7031528a53627c47/src/test/multisig_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/449f9b8debcceb61a92043bc7031528a53627c47/src/test/multisig_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/multisig_tests.cpp?ref=449f9b8debcceb61a92043bc7031528a53627c47",
        "patch": "@@ -81,20 +81,20 @@ BOOST_AUTO_TEST_CASE(multisig_verify)\n     keys.assign(1,key[0]);\n     keys.push_back(key[1]);\n     s = sign_multisig(a_and_b, keys, txTo[0], 0);\n-    BOOST_CHECK(VerifyScript(s, a_and_b, flags, MutableTransactionSignatureChecker(&txTo[0], 0), &err));\n+    BOOST_CHECK(VerifyScript(s, a_and_b, NULL, flags, MutableTransactionSignatureChecker(&txTo[0], 0), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n \n     for (int i = 0; i < 4; i++)\n     {\n         keys.assign(1,key[i]);\n         s = sign_multisig(a_and_b, keys, txTo[0], 0);\n-        BOOST_CHECK_MESSAGE(!VerifyScript(s, a_and_b, flags, MutableTransactionSignatureChecker(&txTo[0], 0), &err), strprintf(\"a&b 1: %d\", i));\n+        BOOST_CHECK_MESSAGE(!VerifyScript(s, a_and_b, NULL, flags, MutableTransactionSignatureChecker(&txTo[0], 0), &err), strprintf(\"a&b 1: %d\", i));\n         BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_INVALID_STACK_OPERATION, ScriptErrorString(err));\n \n         keys.assign(1,key[1]);\n         keys.push_back(key[i]);\n         s = sign_multisig(a_and_b, keys, txTo[0], 0);\n-        BOOST_CHECK_MESSAGE(!VerifyScript(s, a_and_b, flags, MutableTransactionSignatureChecker(&txTo[0], 0), &err), strprintf(\"a&b 2: %d\", i));\n+        BOOST_CHECK_MESSAGE(!VerifyScript(s, a_and_b, NULL, flags, MutableTransactionSignatureChecker(&txTo[0], 0), &err), strprintf(\"a&b 2: %d\", i));\n         BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n     }\n \n@@ -105,18 +105,18 @@ BOOST_AUTO_TEST_CASE(multisig_verify)\n         s = sign_multisig(a_or_b, keys, txTo[1], 0);\n         if (i == 0 || i == 1)\n         {\n-            BOOST_CHECK_MESSAGE(VerifyScript(s, a_or_b, flags, MutableTransactionSignatureChecker(&txTo[1], 0), &err), strprintf(\"a|b: %d\", i));\n+            BOOST_CHECK_MESSAGE(VerifyScript(s, a_or_b, NULL, flags, MutableTransactionSignatureChecker(&txTo[1], 0), &err), strprintf(\"a|b: %d\", i));\n             BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n         }\n         else\n         {\n-            BOOST_CHECK_MESSAGE(!VerifyScript(s, a_or_b, flags, MutableTransactionSignatureChecker(&txTo[1], 0), &err), strprintf(\"a|b: %d\", i));\n+            BOOST_CHECK_MESSAGE(!VerifyScript(s, a_or_b, NULL, flags, MutableTransactionSignatureChecker(&txTo[1], 0), &err), strprintf(\"a|b: %d\", i));\n             BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n         }\n     }\n     s.clear();\n     s << OP_0 << OP_1;\n-    BOOST_CHECK(!VerifyScript(s, a_or_b, flags, MutableTransactionSignatureChecker(&txTo[1], 0), &err));\n+    BOOST_CHECK(!VerifyScript(s, a_or_b, NULL, flags, MutableTransactionSignatureChecker(&txTo[1], 0), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_SIG_DER, ScriptErrorString(err));\n \n \n@@ -128,12 +128,12 @@ BOOST_AUTO_TEST_CASE(multisig_verify)\n             s = sign_multisig(escrow, keys, txTo[2], 0);\n             if (i < j && i < 3 && j < 3)\n             {\n-                BOOST_CHECK_MESSAGE(VerifyScript(s, escrow, flags, MutableTransactionSignatureChecker(&txTo[2], 0), &err), strprintf(\"escrow 1: %d %d\", i, j));\n+                BOOST_CHECK_MESSAGE(VerifyScript(s, escrow, NULL, flags, MutableTransactionSignatureChecker(&txTo[2], 0), &err), strprintf(\"escrow 1: %d %d\", i, j));\n                 BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n             }\n             else\n             {\n-                BOOST_CHECK_MESSAGE(!VerifyScript(s, escrow, flags, MutableTransactionSignatureChecker(&txTo[2], 0), &err), strprintf(\"escrow 2: %d %d\", i, j));\n+                BOOST_CHECK_MESSAGE(!VerifyScript(s, escrow, NULL, flags, MutableTransactionSignatureChecker(&txTo[2], 0), &err), strprintf(\"escrow 2: %d %d\", i, j));\n                 BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n             }\n         }"
      },
      {
        "sha": "d6b5f41d44ac5e9ffcf3c6dde545fd48f74f3535",
        "filename": "src/test/script_P2SH_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/449f9b8debcceb61a92043bc7031528a53627c47/src/test/script_P2SH_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/449f9b8debcceb61a92043bc7031528a53627c47/src/test/script_P2SH_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_P2SH_tests.cpp?ref=449f9b8debcceb61a92043bc7031528a53627c47",
        "patch": "@@ -42,7 +42,7 @@ Verify(const CScript& scriptSig, const CScript& scriptPubKey, bool fStrict, Scri\n     txTo.vin[0].scriptSig = scriptSig;\n     txTo.vout[0].nValue = 1;\n \n-    return VerifyScript(scriptSig, scriptPubKey, fStrict ? SCRIPT_VERIFY_P2SH : SCRIPT_VERIFY_NONE, MutableTransactionSignatureChecker(&txTo, 0), &err);\n+    return VerifyScript(scriptSig, scriptPubKey, NULL, fStrict ? SCRIPT_VERIFY_P2SH : SCRIPT_VERIFY_NONE, MutableTransactionSignatureChecker(&txTo, 0), &err);\n }\n \n "
      },
      {
        "sha": "d402ba56bbbf6d1f3699934ce28da225d57c75b0",
        "filename": "src/test/script_tests.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 16,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/449f9b8debcceb61a92043bc7031528a53627c47/src/test/script_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/449f9b8debcceb61a92043bc7031528a53627c47/src/test/script_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_tests.cpp?ref=449f9b8debcceb61a92043bc7031528a53627c47",
        "patch": "@@ -147,10 +147,14 @@ CMutableTransaction BuildSpendingTransaction(const CScript& scriptSig, const CMu\n void DoTest(const CScript& scriptPubKey, const CScript& scriptSig, int flags, const std::string& message, int scriptError)\n {\n     bool expect = (scriptError == SCRIPT_ERR_OK);\n+    if (flags & SCRIPT_VERIFY_CLEANSTACK) {\n+        flags |= SCRIPT_VERIFY_P2SH;\n+        flags |= SCRIPT_VERIFY_WITNESS;\n+    }\n     ScriptError err;\n     CMutableTransaction tx = BuildSpendingTransaction(scriptSig, BuildCreditingTransaction(scriptPubKey));\n     CMutableTransaction tx2 = tx;\n-    BOOST_CHECK_MESSAGE(VerifyScript(scriptSig, scriptPubKey, flags, MutableTransactionSignatureChecker(&tx, 0), &err) == expect, message);\n+    BOOST_CHECK_MESSAGE(VerifyScript(scriptSig, scriptPubKey, NULL, flags, MutableTransactionSignatureChecker(&tx, 0), &err) == expect, message);\n     BOOST_CHECK_MESSAGE(err == scriptError, std::string(FormatScriptError(err)) + \" where \" + std::string(FormatScriptError((ScriptError_t)scriptError)) + \" expected: \" + message);\n #if defined(HAVE_CONSENSUS_LIB)\n     CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n@@ -799,18 +803,18 @@ BOOST_AUTO_TEST_CASE(script_CHECKMULTISIG12)\n     CMutableTransaction txTo12 = BuildSpendingTransaction(CScript(), txFrom12);\n \n     CScript goodsig1 = sign_multisig(scriptPubKey12, key1, txTo12);\n-    BOOST_CHECK(VerifyScript(goodsig1, scriptPubKey12, flags, MutableTransactionSignatureChecker(&txTo12, 0), &err));\n+    BOOST_CHECK(VerifyScript(goodsig1, scriptPubKey12, NULL, flags, MutableTransactionSignatureChecker(&txTo12, 0), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n     txTo12.vout[0].nValue = 2;\n-    BOOST_CHECK(!VerifyScript(goodsig1, scriptPubKey12, flags, MutableTransactionSignatureChecker(&txTo12, 0), &err));\n+    BOOST_CHECK(!VerifyScript(goodsig1, scriptPubKey12, NULL, flags, MutableTransactionSignatureChecker(&txTo12, 0), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n \n     CScript goodsig2 = sign_multisig(scriptPubKey12, key2, txTo12);\n-    BOOST_CHECK(VerifyScript(goodsig2, scriptPubKey12, flags, MutableTransactionSignatureChecker(&txTo12, 0), &err));\n+    BOOST_CHECK(VerifyScript(goodsig2, scriptPubKey12, NULL, flags, MutableTransactionSignatureChecker(&txTo12, 0), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n \n     CScript badsig1 = sign_multisig(scriptPubKey12, key3, txTo12);\n-    BOOST_CHECK(!VerifyScript(badsig1, scriptPubKey12, flags, MutableTransactionSignatureChecker(&txTo12, 0), &err));\n+    BOOST_CHECK(!VerifyScript(badsig1, scriptPubKey12, NULL, flags, MutableTransactionSignatureChecker(&txTo12, 0), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n }\n \n@@ -832,54 +836,54 @@ BOOST_AUTO_TEST_CASE(script_CHECKMULTISIG23)\n     std::vector<CKey> keys;\n     keys.push_back(key1); keys.push_back(key2);\n     CScript goodsig1 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(VerifyScript(goodsig1, scriptPubKey23, flags, MutableTransactionSignatureChecker(&txTo23, 0), &err));\n+    BOOST_CHECK(VerifyScript(goodsig1, scriptPubKey23, NULL, flags, MutableTransactionSignatureChecker(&txTo23, 0), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n \n     keys.clear();\n     keys.push_back(key1); keys.push_back(key3);\n     CScript goodsig2 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(VerifyScript(goodsig2, scriptPubKey23, flags, MutableTransactionSignatureChecker(&txTo23, 0), &err));\n+    BOOST_CHECK(VerifyScript(goodsig2, scriptPubKey23, NULL, flags, MutableTransactionSignatureChecker(&txTo23, 0), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n \n     keys.clear();\n     keys.push_back(key2); keys.push_back(key3);\n     CScript goodsig3 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(VerifyScript(goodsig3, scriptPubKey23, flags, MutableTransactionSignatureChecker(&txTo23, 0), &err));\n+    BOOST_CHECK(VerifyScript(goodsig3, scriptPubKey23, NULL, flags, MutableTransactionSignatureChecker(&txTo23, 0), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n \n     keys.clear();\n     keys.push_back(key2); keys.push_back(key2); // Can't re-use sig\n     CScript badsig1 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(!VerifyScript(badsig1, scriptPubKey23, flags, MutableTransactionSignatureChecker(&txTo23, 0), &err));\n+    BOOST_CHECK(!VerifyScript(badsig1, scriptPubKey23, NULL, flags, MutableTransactionSignatureChecker(&txTo23, 0), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n \n     keys.clear();\n     keys.push_back(key2); keys.push_back(key1); // sigs must be in correct order\n     CScript badsig2 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(!VerifyScript(badsig2, scriptPubKey23, flags, MutableTransactionSignatureChecker(&txTo23, 0), &err));\n+    BOOST_CHECK(!VerifyScript(badsig2, scriptPubKey23, NULL, flags, MutableTransactionSignatureChecker(&txTo23, 0), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n \n     keys.clear();\n     keys.push_back(key3); keys.push_back(key2); // sigs must be in correct order\n     CScript badsig3 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(!VerifyScript(badsig3, scriptPubKey23, flags, MutableTransactionSignatureChecker(&txTo23, 0), &err));\n+    BOOST_CHECK(!VerifyScript(badsig3, scriptPubKey23, NULL, flags, MutableTransactionSignatureChecker(&txTo23, 0), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n \n     keys.clear();\n     keys.push_back(key4); keys.push_back(key2); // sigs must match pubkeys\n     CScript badsig4 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(!VerifyScript(badsig4, scriptPubKey23, flags, MutableTransactionSignatureChecker(&txTo23, 0), &err));\n+    BOOST_CHECK(!VerifyScript(badsig4, scriptPubKey23, NULL, flags, MutableTransactionSignatureChecker(&txTo23, 0), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n \n     keys.clear();\n     keys.push_back(key1); keys.push_back(key4); // sigs must match pubkeys\n     CScript badsig5 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(!VerifyScript(badsig5, scriptPubKey23, flags, MutableTransactionSignatureChecker(&txTo23, 0), &err));\n+    BOOST_CHECK(!VerifyScript(badsig5, scriptPubKey23, NULL, flags, MutableTransactionSignatureChecker(&txTo23, 0), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n \n     keys.clear(); // Must have signatures\n     CScript badsig6 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(!VerifyScript(badsig6, scriptPubKey23, flags, MutableTransactionSignatureChecker(&txTo23, 0), &err));\n+    BOOST_CHECK(!VerifyScript(badsig6, scriptPubKey23, NULL, flags, MutableTransactionSignatureChecker(&txTo23, 0), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_INVALID_STACK_OPERATION, ScriptErrorString(err));\n }\n \n@@ -999,7 +1003,7 @@ BOOST_AUTO_TEST_CASE(script_standard_push)\n         CScript script;\n         script << i;\n         BOOST_CHECK_MESSAGE(script.IsPushOnly(), \"Number \" << i << \" is not pure push.\");\n-        BOOST_CHECK_MESSAGE(VerifyScript(script, CScript() << OP_1, SCRIPT_VERIFY_MINIMALDATA, BaseSignatureChecker(), &err), \"Number \" << i << \" push is not minimal data.\");\n+        BOOST_CHECK_MESSAGE(VerifyScript(script, CScript() << OP_1, NULL, SCRIPT_VERIFY_MINIMALDATA, BaseSignatureChecker(), &err), \"Number \" << i << \" push is not minimal data.\");\n         BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n     }\n \n@@ -1008,7 +1012,7 @@ BOOST_AUTO_TEST_CASE(script_standard_push)\n         CScript script;\n         script << data;\n         BOOST_CHECK_MESSAGE(script.IsPushOnly(), \"Length \" << i << \" is not pure push.\");\n-        BOOST_CHECK_MESSAGE(VerifyScript(script, CScript() << OP_1, SCRIPT_VERIFY_MINIMALDATA, BaseSignatureChecker(), &err), \"Length \" << i << \" push is not minimal data.\");\n+        BOOST_CHECK_MESSAGE(VerifyScript(script, CScript() << OP_1, NULL, SCRIPT_VERIFY_MINIMALDATA, BaseSignatureChecker(), &err), \"Length \" << i << \" push is not minimal data.\");\n         BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n     }\n }"
      },
      {
        "sha": "9a24a613e51647bb3e1faa7f9b4ca1cef07b6d68",
        "filename": "src/test/transaction_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/449f9b8debcceb61a92043bc7031528a53627c47/src/test/transaction_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/449f9b8debcceb61a92043bc7031528a53627c47/src/test/transaction_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/transaction_tests.cpp?ref=449f9b8debcceb61a92043bc7031528a53627c47",
        "patch": "@@ -151,7 +151,7 @@ BOOST_AUTO_TEST_CASE(tx_valid)\n \n                 unsigned int verify_flags = ParseScriptFlags(test[2].get_str());\n                 BOOST_CHECK_MESSAGE(VerifyScript(tx.vin[i].scriptSig, mapprevOutScriptPubKeys[tx.vin[i].prevout],\n-                                                 verify_flags, TransactionSignatureChecker(&tx, i), &err),\n+                                                 NULL, verify_flags, TransactionSignatureChecker(&tx, i), &err),\n                                     strTest);\n                 BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n             }\n@@ -225,7 +225,7 @@ BOOST_AUTO_TEST_CASE(tx_invalid)\n \n                 unsigned int verify_flags = ParseScriptFlags(test[2].get_str());\n                 fValid = VerifyScript(tx.vin[i].scriptSig, mapprevOutScriptPubKeys[tx.vin[i].prevout],\n-                                      verify_flags, TransactionSignatureChecker(&tx, i), &err);\n+                                      NULL, verify_flags, TransactionSignatureChecker(&tx, i), &err);\n             }\n             BOOST_CHECK_MESSAGE(!fValid, strTest);\n             BOOST_CHECK_MESSAGE(err != SCRIPT_ERR_OK, ScriptErrorString(err));"
      }
    ]
  },
  {
    "sha": "8b49040854be2e26b66366aeae1cba4716f93d93",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4YjQ5MDQwODU0YmUyZTI2YjY2MzY2YWVhZTFjYmE0NzE2ZjkzZDkz",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2015-11-06T00:42:38Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-06-22T13:42:59Z"
      },
      "message": "BIP141: Commitment structure and deployment\n\nIncludes a fix by Suhas Daftuar and LongShao007",
      "tree": {
        "sha": "b217f3fb71bc0745c1f74ab239fbe0ebcf52a751",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b217f3fb71bc0745c1f74ab239fbe0ebcf52a751"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8b49040854be2e26b66366aeae1cba4716f93d93",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8b49040854be2e26b66366aeae1cba4716f93d93",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8b49040854be2e26b66366aeae1cba4716f93d93",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8b49040854be2e26b66366aeae1cba4716f93d93/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "449f9b8debcceb61a92043bc7031528a53627c47",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/449f9b8debcceb61a92043bc7031528a53627c47",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/449f9b8debcceb61a92043bc7031528a53627c47"
      }
    ],
    "stats": {
      "total": 238,
      "additions": 225,
      "deletions": 13
    },
    "files": [
      {
        "sha": "2a198e8554c9398eecc64456d6b130791898fcc9",
        "filename": "src/chainparams.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 0,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8b49040854be2e26b66366aeae1cba4716f93d93/src/chainparams.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8b49040854be2e26b66366aeae1cba4716f93d93/src/chainparams.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparams.cpp?ref=8b49040854be2e26b66366aeae1cba4716f93d93",
        "patch": "@@ -92,6 +92,11 @@ class CMainParams : public CChainParams {\n         consensus.vDeployments[Consensus::DEPLOYMENT_CSV].nStartTime = 1462060800; // May 1st, 2016\n         consensus.vDeployments[Consensus::DEPLOYMENT_CSV].nTimeout = 1493596800; // May 1st, 2017\n \n+        // Deployment of SegWit (BIP141 and BIP143)\n+        consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].bit = 1;\n+        consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].nStartTime = 0;\n+        consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].nTimeout = 0; // Never / undefined\n+\n         /**\n          * The message start string is designed to be unlikely to occur in normal data.\n          * The characters are rarely used upper ASCII, not valid as UTF-8, and produce\n@@ -183,6 +188,11 @@ class CTestNetParams : public CChainParams {\n         consensus.vDeployments[Consensus::DEPLOYMENT_CSV].nStartTime = 1456790400; // March 1st, 2016\n         consensus.vDeployments[Consensus::DEPLOYMENT_CSV].nTimeout = 1493596800; // May 1st, 2017\n \n+        // Deployment of SegWit (BIP141 and BIP143)\n+        consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].bit = 1;\n+        consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].nStartTime = 2000000000; // Far in the future\n+        consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].nTimeout = 2100000000;\n+\n         pchMessageStart[0] = 0x0b;\n         pchMessageStart[1] = 0x11;\n         pchMessageStart[2] = 0x09;\n@@ -255,6 +265,9 @@ class CRegTestParams : public CChainParams {\n         consensus.vDeployments[Consensus::DEPLOYMENT_CSV].bit = 0;\n         consensus.vDeployments[Consensus::DEPLOYMENT_CSV].nStartTime = 0;\n         consensus.vDeployments[Consensus::DEPLOYMENT_CSV].nTimeout = 999999999999ULL;\n+        consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].bit = 1;\n+        consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].nStartTime = 0;\n+        consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].nTimeout = 999999999999ULL;\n \n         pchMessageStart[0] = 0xfa;\n         pchMessageStart[1] = 0xbf;\n@@ -317,3 +330,4 @@ void SelectParams(const std::string& network)\n     SelectBaseParams(network);\n     pCurrentParams = &Params(network);\n }\n+ "
      },
      {
        "sha": "35f7d2e05a937f5f2a26382d08a2d24312216b81",
        "filename": "src/consensus/merkle.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8b49040854be2e26b66366aeae1cba4716f93d93/src/consensus/merkle.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8b49040854be2e26b66366aeae1cba4716f93d93/src/consensus/merkle.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/merkle.cpp?ref=8b49040854be2e26b66366aeae1cba4716f93d93",
        "patch": "@@ -165,6 +165,17 @@ uint256 BlockMerkleRoot(const CBlock& block, bool* mutated)\n     return ComputeMerkleRoot(leaves, mutated);\n }\n \n+uint256 BlockWitnessMerkleRoot(const CBlock& block, bool* mutated)\n+{\n+    std::vector<uint256> leaves;\n+    leaves.resize(block.vtx.size());\n+    leaves[0].SetNull(); // The witness hash of the coinbase is 0.\n+    for (size_t s = 1; s < block.vtx.size(); s++) {\n+        leaves[s] = block.vtx[s].GetWitnessHash();\n+    }\n+    return ComputeMerkleRoot(leaves, mutated);\n+}\n+\n std::vector<uint256> BlockMerkleBranch(const CBlock& block, uint32_t position)\n {\n     std::vector<uint256> leaves;"
      },
      {
        "sha": "194aea9b75dc30fbedac6450d8d938f24e9878cd",
        "filename": "src/consensus/merkle.h",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8b49040854be2e26b66366aeae1cba4716f93d93/src/consensus/merkle.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8b49040854be2e26b66366aeae1cba4716f93d93/src/consensus/merkle.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/merkle.h?ref=8b49040854be2e26b66366aeae1cba4716f93d93",
        "patch": "@@ -22,6 +22,12 @@ uint256 ComputeMerkleRootFromBranch(const uint256& leaf, const std::vector<uint2\n  */\n uint256 BlockMerkleRoot(const CBlock& block, bool* mutated = NULL);\n \n+/*\n+ * Compute the Merkle root of the witness transactions in a block.\n+ * *mutated is set to true if a duplicated subtree was found.\n+ */\n+uint256 BlockWitnessMerkleRoot(const CBlock& block, bool* mutated = NULL);\n+\n /*\n  * Compute the Merkle branch for the tree of transactions in a block, for a\n  * given position."
      },
      {
        "sha": "822ec87d69e86e62e99bfb3f44606c9ac129df46",
        "filename": "src/consensus/params.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8b49040854be2e26b66366aeae1cba4716f93d93/src/consensus/params.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8b49040854be2e26b66366aeae1cba4716f93d93/src/consensus/params.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/params.h?ref=8b49040854be2e26b66366aeae1cba4716f93d93",
        "patch": "@@ -16,6 +16,7 @@ enum DeploymentPos\n {\n     DEPLOYMENT_TESTDUMMY,\n     DEPLOYMENT_CSV, // Deployment of BIP68, BIP112, and BIP113.\n+    DEPLOYMENT_SEGWIT, // Deployment of BIP141 and BIP143\n     // NOTE: Also add new deployments to VersionBitsDeploymentInfo in versionbits.cpp\n     MAX_VERSION_BITS_DEPLOYMENTS\n };"
      },
      {
        "sha": "000b1972702718403466354b0dc47b80c36dcf8e",
        "filename": "src/consensus/validation.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8b49040854be2e26b66366aeae1cba4716f93d93/src/consensus/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8b49040854be2e26b66366aeae1cba4716f93d93/src/consensus/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/validation.h?ref=8b49040854be2e26b66366aeae1cba4716f93d93",
        "patch": "@@ -77,6 +77,9 @@ class CValidationState {\n     bool CorruptionPossible() const {\n         return corruptionPossible;\n     }\n+    void SetCorruptionPossible() {\n+        corruptionPossible = true;\n+    }\n     unsigned int GetRejectCode() const { return chRejectCode; }\n     std::string GetRejectReason() const { return strRejectReason; }\n     std::string GetDebugMessage() const { return strDebugMessage; }"
      },
      {
        "sha": "8d91d6d625b7aa3fba7a96b8a9038a8c8fb2d8a5",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 138,
        "deletions": 8,
        "changes": 146,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8b49040854be2e26b66366aeae1cba4716f93d93/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8b49040854be2e26b66366aeae1cba4716f93d93/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=8b49040854be2e26b66366aeae1cba4716f93d93",
        "patch": "@@ -293,6 +293,8 @@ struct CNodeState {\n     bool fPreferHeaderAndIDs;\n     //! Whether this peer will send us cmpctblocks if we request them\n     bool fProvidesHeaderAndIDs;\n+    //! Whether this peer can give us witnesses\n+    bool fHaveWitness;\n \n     CNodeState() {\n         fCurrentlyConnected = false;\n@@ -1119,6 +1121,11 @@ bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState& state, const C\n         return state.DoS(0, false, REJECT_NONSTANDARD, \"premature-version2-tx\");\n     }\n \n+    // Don't accept witness transactions before the final threshold passes\n+    if (!tx.wit.IsNull() && !IsWitnessEnabled(chainActive.Tip(), Params().GetConsensus())) {\n+        return state.DoS(0, false, REJECT_NONSTANDARD, \"no-witness-yet\", true);\n+    }\n+\n     // Only accept nLockTime-using transactions that can be mined in the next\n     // block; we don't want our mempool filled up with transactions that can't\n     // be mined yet.\n@@ -1459,8 +1466,17 @@ bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState& state, const C\n \n         // Check against previous transactions\n         // This is done last to help prevent CPU exhaustion denial-of-service attacks.\n-        if (!CheckInputs(tx, state, view, true, STANDARD_SCRIPT_VERIFY_FLAGS, true))\n-            return false; // state filled in by CheckInputs\n+        if (!CheckInputs(tx, state, view, true, STANDARD_SCRIPT_VERIFY_FLAGS, true)) {\n+            // SCRIPT_VERIFY_CLEANSTACK requires SCRIPT_VERIFY_WITNESS, so we\n+            // need to turn both off, and compare against just turning off CLEANSTACK\n+            // to see if the failure is specifically due to witness validation.\n+            if (CheckInputs(tx, state, view, true, STANDARD_SCRIPT_VERIFY_FLAGS & ~(SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_CLEANSTACK), true) &&\n+                !CheckInputs(tx, state, view, true, STANDARD_SCRIPT_VERIFY_FLAGS & ~SCRIPT_VERIFY_CLEANSTACK, true)) {\n+                // Only the witness is wrong, so the transaction itself may be fine.\n+                state.SetCorruptionPossible();\n+            }\n+            return false;\n+        }\n \n         // Check again against just the consensus-critical mandatory script\n         // verification flags, in case of bugs in the standard flags that cause\n@@ -2406,6 +2422,11 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin\n         nLockTimeFlags |= LOCKTIME_VERIFY_SEQUENCE;\n     }\n \n+    // Start enforcing WITNESS rules using versionbits logic.\n+    if (IsWitnessEnabled(pindex->pprev, chainparams.GetConsensus())) {\n+        flags |= SCRIPT_VERIFY_WITNESS;\n+    }\n+\n     int64_t nTime2 = GetTimeMicros(); nTimeForks += nTime2 - nTime1;\n     LogPrint(\"bench\", \"    - Fork checks: %.2fms [%.2fs]\\n\", 0.001 * (nTime2 - nTime1), nTimeForks * 0.000001);\n \n@@ -3441,6 +3462,71 @@ static bool CheckIndexAgainstCheckpoint(const CBlockIndex* pindexPrev, CValidati\n     return true;\n }\n \n+bool IsWitnessEnabled(const CBlockIndex* pindexPrev, const Consensus::Params& params)\n+{\n+    LOCK(cs_main);\n+    return (VersionBitsState(pindexPrev, params, Consensus::DEPLOYMENT_SEGWIT, versionbitscache) == THRESHOLD_ACTIVE);\n+}\n+\n+// Compute at which vout of the block's coinbase transaction the witness\n+// commitment occurs, or -1 if not found.\n+static int GetWitnessCommitmentIndex(const CBlock& block)\n+{\n+    int commitpos = -1;\n+    for (size_t o = 0; o < block.vtx[0].vout.size(); o++) {\n+        if (block.vtx[0].vout[o].scriptPubKey.size() >= 38 && block.vtx[0].vout[o].scriptPubKey[0] == OP_RETURN && block.vtx[0].vout[o].scriptPubKey[1] == 0x24 && block.vtx[0].vout[o].scriptPubKey[2] == 0xaa && block.vtx[0].vout[o].scriptPubKey[3] == 0x21 && block.vtx[0].vout[o].scriptPubKey[4] == 0xa9 && block.vtx[0].vout[o].scriptPubKey[5] == 0xed) {\n+            commitpos = o;\n+        }\n+    }\n+    return commitpos;\n+}\n+\n+void UpdateUncommittedBlockStructures(CBlock& block, const CBlockIndex* pindexPrev, const Consensus::Params& consensusParams)\n+{\n+    int commitpos = GetWitnessCommitmentIndex(block);\n+    static const std::vector<unsigned char> nonce(32, 0x00);\n+    if (commitpos != -1 && IsWitnessEnabled(pindexPrev, consensusParams) && block.vtx[0].wit.IsEmpty()) {\n+        block.vtx[0].wit.vtxinwit.resize(1);\n+        block.vtx[0].wit.vtxinwit[0].scriptWitness.stack.resize(1);\n+        block.vtx[0].wit.vtxinwit[0].scriptWitness.stack[0] = nonce;\n+    }\n+}\n+\n+std::vector<unsigned char> GenerateCoinbaseCommitment(CBlock& block, const CBlockIndex* pindexPrev, const Consensus::Params& consensusParams)\n+{\n+    std::vector<unsigned char> commitment;\n+    int commitpos = GetWitnessCommitmentIndex(block);\n+    bool fHaveWitness = false;\n+    for (size_t t = 1; t < block.vtx.size(); t++) {\n+        if (!block.vtx[t].wit.IsNull()) {\n+            fHaveWitness = true;\n+            break;\n+        }\n+    }\n+    std::vector<unsigned char> ret(32, 0x00);\n+    if (fHaveWitness && IsWitnessEnabled(pindexPrev, consensusParams)) {\n+        if (commitpos == -1) {\n+            uint256 witnessroot = BlockWitnessMerkleRoot(block, NULL);\n+            CHash256().Write(witnessroot.begin(), 32).Write(&ret[0], 32).Finalize(witnessroot.begin());\n+            CTxOut out;\n+            out.nValue = 0;\n+            out.scriptPubKey.resize(38);\n+            out.scriptPubKey[0] = OP_RETURN;\n+            out.scriptPubKey[1] = 0x24;\n+            out.scriptPubKey[2] = 0xaa;\n+            out.scriptPubKey[3] = 0x21;\n+            out.scriptPubKey[4] = 0xa9;\n+            out.scriptPubKey[5] = 0xed;\n+            memcpy(&out.scriptPubKey[6], witnessroot.begin(), 32);\n+            commitment = std::vector<unsigned char>(out.scriptPubKey.begin(), out.scriptPubKey.end());\n+            const_cast<std::vector<CTxOut>*>(&block.vtx[0].vout)->push_back(out);\n+            block.vtx[0].UpdateHash();\n+        }\n+    }\n+    UpdateUncommittedBlockStructures(block, pindexPrev, consensusParams);\n+    return commitment;\n+}\n+\n bool ContextualCheckBlockHeader(const CBlockHeader& block, CValidationState& state, const Consensus::Params& consensusParams, CBlockIndex * const pindexPrev, int64_t nAdjustedTime)\n {\n     // Check proof of work\n@@ -3497,6 +3583,43 @@ bool ContextualCheckBlock(const CBlock& block, CValidationState& state, CBlockIn\n         }\n     }\n \n+    // Validation for witness commitments.\n+    // * We compute the witness hash (which is the hash including witnesses) of all the block's transactions, except the\n+    //   coinbase (where 0x0000....0000 is used instead).\n+    // * The coinbase scriptWitness is a stack of a single 32-byte vector, containing a witness nonce (unconstrained).\n+    // * We build a merkle tree with all those witness hashes as leaves (similar to the hashMerkleRoot in the block header).\n+    // * There must be at least one output whose scriptPubKey is a single 36-byte push, the first 4 bytes of which are\n+    //   {0xaa, 0x21, 0xa9, 0xed}, and the following 32 bytes are SHA256^2(witness root, witness nonce). In case there are\n+    //   multiple, the last one is used.\n+    bool fHaveWitness = false;\n+    if (IsWitnessEnabled(pindexPrev, consensusParams)) {\n+        int commitpos = GetWitnessCommitmentIndex(block);\n+        if (commitpos != -1) {\n+            bool malleated = false;\n+            uint256 hashWitness = BlockWitnessMerkleRoot(block, &malleated);\n+            // The malleation check is ignored; as the transaction tree itself\n+            // already does not permit it, it is impossible to trigger in the\n+            // witness tree.\n+            if (block.vtx[0].wit.vtxinwit.size() != 1 || block.vtx[0].wit.vtxinwit[0].scriptWitness.stack.size() != 1 || block.vtx[0].wit.vtxinwit[0].scriptWitness.stack[0].size() != 32) {\n+                return state.DoS(100, error(\"%s : invalid witness nonce size\", __func__), REJECT_INVALID, \"bad-witness-nonce-size\", true);\n+            }\n+            CHash256().Write(hashWitness.begin(), 32).Write(&block.vtx[0].wit.vtxinwit[0].scriptWitness.stack[0][0], 32).Finalize(hashWitness.begin());\n+            if (memcmp(hashWitness.begin(), &block.vtx[0].vout[commitpos].scriptPubKey[6], 32)) {\n+                return state.DoS(100, error(\"%s : witness merkle commitment mismatch\", __func__), REJECT_INVALID, \"bad-witness-merkle-match\", true);\n+            }\n+            fHaveWitness = true;\n+        }\n+    }\n+\n+    // No witness data is allowed in blocks that don't commit to witness data, as this would otherwise leave room for spam\n+    if (!fHaveWitness) {\n+        for (size_t i = 0; i < block.vtx.size(); i++) {\n+            if (!block.vtx[i].wit.IsNull()) {\n+                return state.DoS(100, error(\"%s : unexpected witness data found\", __func__), REJECT_INVALID, \"unexpected-witness\", true);\n+            }\n+        }\n+    }\n+\n     return true;\n }\n \n@@ -5278,7 +5401,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                     else if (!fMissingInputs2)\n                     {\n                         int nDos = 0;\n-                        if (stateDummy.IsInvalid(nDos) && nDos > 0)\n+                        if (stateDummy.IsInvalid(nDos) && nDos > 0 && (!state.CorruptionPossible() || State(fromPeer)->fHaveWitness))\n                         {\n                             // Punish peer that gave us an invalid orphan tx\n                             Misbehaving(fromPeer, nDos);\n@@ -5289,8 +5412,10 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                         // Probably non-standard or insufficient fee/priority\n                         LogPrint(\"mempool\", \"   removed orphan tx %s\\n\", orphanHash.ToString());\n                         vEraseQueue.push_back(orphanHash);\n-                        assert(recentRejects);\n-                        recentRejects->insert(orphanHash);\n+                        if (!stateDummy.CorruptionPossible()) {\n+                            assert(recentRejects);\n+                            recentRejects->insert(orphanHash);\n+                        }\n                     }\n                     mempool.check(pcoinsTip);\n                 }\n@@ -5325,8 +5450,10 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                 LogPrint(\"mempool\", \"not keeping orphan with rejected parents %s\\n\",tx.GetHash().ToString());\n             }\n         } else {\n-            assert(recentRejects);\n-            recentRejects->insert(tx.GetHash());\n+            if (!state.CorruptionPossible()) {\n+                assert(recentRejects);\n+                recentRejects->insert(tx.GetHash());\n+            }\n \n             if (pfrom->fWhitelisted && GetBoolArg(\"-whitelistforcerelay\", DEFAULT_WHITELISTFORCERELAY)) {\n                 // Always relay transactions received from whitelisted peers, even\n@@ -5355,8 +5482,11 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             if (state.GetRejectCode() < REJECT_INTERNAL) // Never send AcceptToMemoryPool's internal codes over P2P\n                 pfrom->PushMessage(NetMsgType::REJECT, strCommand, (unsigned char)state.GetRejectCode(),\n                                    state.GetRejectReason().substr(0, MAX_REJECT_MESSAGE_LENGTH), inv.hash);\n-            if (nDoS > 0)\n+            if (nDoS > 0 && (!state.CorruptionPossible() || State(pfrom->id)->fHaveWitness)) {\n+                // When a non-witness-supporting peer gives us a transaction that would\n+                // be accepted if witness validation was off, we can't blame them for it.\n                 Misbehaving(pfrom->GetId(), nDoS);\n+            }\n         }\n         FlushStateToDisk(state, FLUSH_STATE_PERIODIC);\n     }"
      },
      {
        "sha": "d0dce7068700cee04e4c0f663ea50c46f4a56dc6",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 9,
        "deletions": 0,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8b49040854be2e26b66366aeae1cba4716f93d93/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8b49040854be2e26b66366aeae1cba4716f93d93/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=8b49040854be2e26b66366aeae1cba4716f93d93",
        "patch": "@@ -453,6 +453,15 @@ bool DisconnectBlock(const CBlock& block, CValidationState& state, const CBlockI\n /** Check a block is completely valid from start to finish (only works on top of our current best block, with cs_main held) */\n bool TestBlockValidity(CValidationState& state, const CChainParams& chainparams, const CBlock& block, CBlockIndex* pindexPrev, bool fCheckPOW = true, bool fCheckMerkleRoot = true);\n \n+/** Check whether witness commitments are required for block. */\n+bool IsWitnessEnabled(const CBlockIndex* pindexPrev, const Consensus::Params& params);\n+\n+/** Update uncommitted block structures (currently: only the witness nonce). This is safe for submitted blocks. */\n+void UpdateUncommittedBlockStructures(CBlock& block, const CBlockIndex* pindexPrev, const Consensus::Params& consensusParams);\n+\n+/** Produce the necessary coinbase commitment for a block (modifies the hash, don't call for mined blocks). */\n+std::vector<unsigned char> GenerateCoinbaseCommitment(CBlock& block, const CBlockIndex* pindexPrev, const Consensus::Params& consensusParams);\n+\n /** RAII wrapper for VerifyDB: Verify consistency of the block and coin databases */\n class CVerifyDB {\n public:"
      },
      {
        "sha": "a7bf9ae84ccd7c9cb9b1551a1025d9826918cef4",
        "filename": "src/miner.cpp",
        "status": "modified",
        "additions": 18,
        "deletions": 0,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8b49040854be2e26b66366aeae1cba4716f93d93/src/miner.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8b49040854be2e26b66366aeae1cba4716f93d93/src/miner.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.cpp?ref=8b49040854be2e26b66366aeae1cba4716f93d93",
        "patch": "@@ -93,6 +93,7 @@ void BlockAssembler::resetBlock()\n     // Reserve space for coinbase tx\n     nBlockSize = 1000;\n     nBlockSigOps = 100;\n+    fIncludeWitness = false;\n \n     // These counters do not include coinbase tx\n     nBlockTx = 0;\n@@ -134,6 +135,14 @@ CBlockTemplate* BlockAssembler::CreateNewBlock(const CScript& scriptPubKeyIn)\n                        ? nMedianTimePast\n                        : pblock->GetBlockTime();\n \n+    // Decide whether to include witness transactions\n+    // This is only needed in case the witness softfork activation is reverted\n+    // (which would require a very deep reorganization) or when\n+    // -promiscuousmempoolflags is used.\n+    // TODO: replace this with a call to main to assess validity of a mempool\n+    // transaction (which in most cases can be a no-op).\n+    fIncludeWitness = IsWitnessEnabled(pindexPrev, chainparams.GetConsensus());\n+\n     addPriorityTxs();\n     addPackageTxs();\n \n@@ -150,6 +159,7 @@ CBlockTemplate* BlockAssembler::CreateNewBlock(const CScript& scriptPubKeyIn)\n     coinbaseTx.vout[0].nValue = nFees + GetBlockSubsidy(nHeight, chainparams.GetConsensus());\n     coinbaseTx.vin[0].scriptSig = CScript() << nHeight << OP_0;\n     pblock->vtx[0] = coinbaseTx;\n+    pblocktemplate->vchCoinbaseCommitment = GenerateCoinbaseCommitment(*pblock, pindexPrev, chainparams.GetConsensus());\n     pblocktemplate->vTxFees[0] = -nFees;\n \n     // Fill in header\n@@ -299,6 +309,10 @@ void BlockAssembler::addScoreTxs()\n             continue;\n         }\n \n+        // cannot accept witness transactions into a non-witness block\n+        if (!fIncludeWitness && !iter->GetTx().wit.IsNull())\n+            continue;\n+\n         // If tx is dependent on other mempool txs which haven't yet been included\n         // then put it in the waitSet\n         if (isStillDependent(iter)) {\n@@ -543,6 +557,10 @@ void BlockAssembler::addPriorityTxs()\n             continue;\n         }\n \n+        // cannot accept witness transactions into a non-witness block\n+        if (!fIncludeWitness && !iter->GetTx().wit.IsNull())\n+            continue;\n+\n         // If tx is dependent on other mempool txs which haven't yet been included\n         // then put it in the waitSet\n         if (isStillDependent(iter)) {"
      },
      {
        "sha": "8bfc1493db19b39f7362b81d57ffa65e49bcd59a",
        "filename": "src/miner.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8b49040854be2e26b66366aeae1cba4716f93d93/src/miner.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8b49040854be2e26b66366aeae1cba4716f93d93/src/miner.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.h?ref=8b49040854be2e26b66366aeae1cba4716f93d93",
        "patch": "@@ -29,6 +29,7 @@ struct CBlockTemplate\n     CBlock block;\n     std::vector<CAmount> vTxFees;\n     std::vector<int64_t> vTxSigOps;\n+    std::vector<unsigned char> vchCoinbaseCommitment;\n };\n \n // Container for tracking updates to ancestor feerate as we include (parent)\n@@ -139,6 +140,7 @@ class BlockAssembler\n     CBlock* pblock;\n \n     // Configuration parameters for the block size\n+    bool fIncludeWitness;\n     unsigned int nBlockMaxSize, nBlockMinSize;\n \n     // Information on the current status of the block"
      },
      {
        "sha": "5a58241347b49f58a27265c4a9c6d3c52fd7bed2",
        "filename": "src/primitives/transaction.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8b49040854be2e26b66366aeae1cba4716f93d93/src/primitives/transaction.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8b49040854be2e26b66366aeae1cba4716f93d93/src/primitives/transaction.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/primitives/transaction.h?ref=8b49040854be2e26b66366aeae1cba4716f93d93",
        "patch": "@@ -335,7 +335,6 @@ class CTransaction\n private:\n     /** Memory only. */\n     const uint256 hash;\n-    void UpdateHash() const;\n \n public:\n     // Default transaction version.\n@@ -414,6 +413,8 @@ class CTransaction\n     }\n \n     std::string ToString() const;\n+\n+    void UpdateHash() const;\n };\n \n /** A mutable version of CTransaction. */"
      },
      {
        "sha": "dae283fb6fea7ee1c2ccf0926cbef7d227c020d1",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8b49040854be2e26b66366aeae1cba4716f93d93/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8b49040854be2e26b66366aeae1cba4716f93d93/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=8b49040854be2e26b66366aeae1cba4716f93d93",
        "patch": "@@ -930,6 +930,7 @@ UniValue getblockchaininfo(const UniValue& params, bool fHelp)\n     softforks.push_back(SoftForkDesc(\"bip66\", 3, tip, consensusParams));\n     softforks.push_back(SoftForkDesc(\"bip65\", 4, tip, consensusParams));\n     bip9_softforks.push_back(Pair(\"csv\", BIP9SoftForkDesc(consensusParams, Consensus::DEPLOYMENT_CSV)));\n+    bip9_softforks.push_back(Pair(\"segwit\", BIP9SoftForkDesc(consensusParams, Consensus::DEPLOYMENT_SEGWIT)));\n     obj.push_back(Pair(\"softforks\",             softforks));\n     obj.push_back(Pair(\"bip9_softforks\", bip9_softforks));\n "
      },
      {
        "sha": "291314b8b57fab93d9a8affe6dae46aa5158b28d",
        "filename": "src/rpc/mining.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 4,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8b49040854be2e26b66366aeae1cba4716f93d93/src/rpc/mining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8b49040854be2e26b66366aeae1cba4716f93d93/src/rpc/mining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/mining.cpp?ref=8b49040854be2e26b66366aeae1cba4716f93d93",
        "patch": "@@ -348,7 +348,8 @@ UniValue getblocktemplate(const UniValue& params, bool fHelp)\n             \"  \\\"transactions\\\" : [                (array) contents of non-coinbase transactions that should be included in the next block\\n\"\n             \"      {\\n\"\n             \"         \\\"data\\\" : \\\"xxxx\\\",          (string) transaction data encoded in hexadecimal (byte-for-byte)\\n\"\n-            \"         \\\"hash\\\" : \\\"xxxx\\\",          (string) hash/id encoded in little-endian hexadecimal\\n\"\n+            \"         \\\"txid\\\" : \\\"xxxx\\\",          (string) transaction id encoded in little-endian hexadecimal\\n\"\n+            \"         \\\"hash\\\" : \\\"xxxx\\\",          (string) hash encoded in little-endian hexadecimal\\n\"\n             \"         \\\"depends\\\" : [              (array) array of numbers \\n\"\n             \"             n                        (numeric) transactions before this one (by 1-based index in 'transactions' list) that must be present in the final block if this one is\\n\"\n             \"             ,...\\n\"\n@@ -546,7 +547,7 @@ UniValue getblocktemplate(const UniValue& params, bool fHelp)\n     UniValue transactions(UniValue::VARR);\n     map<uint256, int64_t> setTxIndex;\n     int i = 0;\n-    BOOST_FOREACH (const CTransaction& tx, pblock->vtx) {\n+    BOOST_FOREACH (CTransaction& tx, pblock->vtx) {\n         uint256 txHash = tx.GetHash();\n         setTxIndex[txHash] = i++;\n \n@@ -556,8 +557,8 @@ UniValue getblocktemplate(const UniValue& params, bool fHelp)\n         UniValue entry(UniValue::VOBJ);\n \n         entry.push_back(Pair(\"data\", EncodeHexTx(tx)));\n-\n-        entry.push_back(Pair(\"hash\", txHash.GetHex()));\n+        entry.push_back(Pair(\"txid\", txHash.GetHex()));\n+        entry.push_back(Pair(\"hash\", tx.GetWitnessHash().GetHex()));\n \n         UniValue deps(UniValue::VARR);\n         BOOST_FOREACH (const CTxIn &in, tx.vin)\n@@ -656,6 +657,9 @@ UniValue getblocktemplate(const UniValue& params, bool fHelp)\n     result.push_back(Pair(\"curtime\", pblock->GetBlockTime()));\n     result.push_back(Pair(\"bits\", strprintf(\"%08x\", pblock->nBits)));\n     result.push_back(Pair(\"height\", (int64_t)(pindexPrev->nHeight+1)));\n+    if (!pblocktemplate->vchCoinbaseCommitment.empty()) {\n+        result.push_back(Pair(\"default_witness_commitment\", HexStr(pblocktemplate->vchCoinbaseCommitment.begin(), pblocktemplate->vchCoinbaseCommitment.end())));\n+    }\n \n     return result;\n }\n@@ -719,6 +723,14 @@ UniValue submitblock(const UniValue& params, bool fHelp)\n         }\n     }\n \n+    {\n+        LOCK(cs_main);\n+        BlockMap::iterator mi = mapBlockIndex.find(block.hashPrevBlock);\n+        if (mi != mapBlockIndex.end()) {\n+            UpdateUncommittedBlockStructures(block, mi->second, Params().GetConsensus());\n+        }\n+    }\n+\n     CValidationState state;\n     submitblock_StateCatcher sc(block.GetHash());\n     RegisterValidationInterface(&sc);"
      },
      {
        "sha": "bf32ae66279457546e0fa42ccfcbe7e0fd54711d",
        "filename": "src/versionbits.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8b49040854be2e26b66366aeae1cba4716f93d93/src/versionbits.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8b49040854be2e26b66366aeae1cba4716f93d93/src/versionbits.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/versionbits.cpp?ref=8b49040854be2e26b66366aeae1cba4716f93d93",
        "patch": "@@ -14,6 +14,10 @@ const struct BIP9DeploymentInfo VersionBitsDeploymentInfo[Consensus::MAX_VERSION\n     {\n         /*.name =*/ \"csv\",\n         /*.gbt_force =*/ true,\n+    },\n+    {\n+        /*.name =*/ \"segwit\",\n+        /*.gbt_force =*/ false,\n     }\n };\n "
      }
    ]
  },
  {
    "sha": "b8a97498df1e83f8dcc49bc3fa4344f9e9799242",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiOGE5NzQ5OGRmMWU4M2Y4ZGNjNDliYzNmYTQzNDRmOWU5Nzk5MjQy",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2015-11-16T23:20:49Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-06-22T13:42:59Z"
      },
      "message": "BIP144: Handshake and relay (receiver side)\n\nService bit logic by Nicolas Dorier.\n\nOnly download blocks from witness peers after fork.",
      "tree": {
        "sha": "d14eb0cb55048583a5233b1ef25f25fb8d7651ab",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d14eb0cb55048583a5233b1ef25f25fb8d7651ab"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b8a97498df1e83f8dcc49bc3fa4344f9e9799242",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b8a97498df1e83f8dcc49bc3fa4344f9e9799242",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b8a97498df1e83f8dcc49bc3fa4344f9e9799242",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b8a97498df1e83f8dcc49bc3fa4344f9e9799242/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8b49040854be2e26b66366aeae1cba4716f93d93",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8b49040854be2e26b66366aeae1cba4716f93d93",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8b49040854be2e26b66366aeae1cba4716f93d93"
      }
    ],
    "stats": {
      "total": 69,
      "additions": 60,
      "deletions": 9
    },
    "files": [
      {
        "sha": "6bce0a9b49b5116d0be400a53e4a33de6ddd8ac5",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b8a97498df1e83f8dcc49bc3fa4344f9e9799242/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b8a97498df1e83f8dcc49bc3fa4344f9e9799242/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=b8a97498df1e83f8dcc49bc3fa4344f9e9799242",
        "patch": "@@ -1377,6 +1377,18 @@ bool AppInit2(boost::thread_group& threadGroup, CScheduler& scheduler)\n         }\n     }\n \n+    if (Params().GetConsensus().vDeployments[Consensus::DEPLOYMENT_SEGWIT].nTimeout != 0) {\n+        // Only advertize witness capabilities if they have a reasonable start time.\n+        // This allows us to have the code merged without a defined softfork, by setting its\n+        // end time to 0.\n+        // Note that setting NODE_WITNESS is never required: the only downside from not\n+        // doing so is that after activation, no upgraded nodes will fetch from you.\n+        nLocalServices = ServiceFlags(nLocalServices | NODE_WITNESS);\n+        // Only care about others providing witness capabilities if there is a softfork\n+        // defined.\n+        nRelevantServices = ServiceFlags(nRelevantServices | NODE_WITNESS);\n+    }\n+\n     // ********************************************************* Step 10: import blocks\n \n     if (mapArgs.count(\"-blocknotify\"))"
      },
      {
        "sha": "73e4c8f51c48f272ddef693443d68f46ac620d41",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 36,
        "deletions": 8,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b8a97498df1e83f8dcc49bc3fa4344f9e9799242/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b8a97498df1e83f8dcc49bc3fa4344f9e9799242/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=b8a97498df1e83f8dcc49bc3fa4344f9e9799242",
        "patch": "@@ -313,6 +313,7 @@ struct CNodeState {\n         fPreferHeaders = false;\n         fPreferHeaderAndIDs = false;\n         fProvidesHeaderAndIDs = false;\n+        fHaveWitness = false;\n     }\n };\n \n@@ -4812,6 +4813,14 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n     }\n }\n \n+uint32_t GetFetchFlags(CNode* pfrom, CBlockIndex* pprev, const Consensus::Params& chainparams) {\n+    uint32_t nFetchFlags = 0;\n+    if (IsWitnessEnabled(pprev, chainparams) && State(pfrom->GetId())->fHaveWitness) {\n+        nFetchFlags |= MSG_WITNESS_FLAG;\n+    }\n+    return nFetchFlags;\n+}\n+\n bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams)\n {\n     LogPrint(\"net\", \"received: %s (%u bytes) peer=%d\\n\", SanitizeString(strCommand), vRecv.size(), pfrom->id);\n@@ -4918,6 +4927,12 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n \n         pfrom->fClient = !(pfrom->nServices & NODE_NETWORK);\n \n+        if((pfrom->nServices & NODE_WITNESS))\n+        {\n+            LOCK(cs_main);\n+            State(pfrom->GetId())->fHaveWitness = true;\n+        }\n+\n         // Potentially mark this peer as a preferred download peer.\n         {\n         LOCK(cs_main);\n@@ -5119,17 +5134,23 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n \n         LOCK(cs_main);\n \n+        uint32_t nFetchFlags = GetFetchFlags(pfrom, chainActive.Tip(), chainparams.GetConsensus());\n+\n         std::vector<CInv> vToFetch;\n \n         for (unsigned int nInv = 0; nInv < vInv.size(); nInv++)\n         {\n-            const CInv &inv = vInv[nInv];\n+            CInv &inv = vInv[nInv];\n \n             boost::this_thread::interruption_point();\n \n             bool fAlreadyHave = AlreadyHave(inv);\n             LogPrint(\"net\", \"got inv: %s  %s peer=%d\\n\", inv.ToString(), fAlreadyHave ? \"have\" : \"new\", pfrom->id);\n \n+            if (inv.type == MSG_TX) {\n+                inv.type |= nFetchFlags;\n+            }\n+\n             if (inv.type == MSG_BLOCK) {\n                 UpdateBlockAvailability(pfrom->GetId(), inv.hash);\n                 if (!fAlreadyHave && !fImporting && !fReindex && !mapBlocksInFlight.count(inv.hash)) {\n@@ -5144,7 +5165,9 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                     pfrom->PushMessage(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), inv.hash);\n                     CNodeState *nodestate = State(pfrom->GetId());\n                     if (CanDirectFetch(chainparams.GetConsensus()) &&\n-                        nodestate->nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n+                        nodestate->nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER &&\n+                        (!IsWitnessEnabled(chainActive.Tip(), chainparams.GetConsensus()) || State(pfrom->GetId())->fHaveWitness)) {\n+                        inv.type |= nFetchFlags;\n                         if (nodestate->fProvidesHeaderAndIDs)\n                             vToFetch.push_back(CInv(MSG_CMPCT_BLOCK, inv.hash));\n                         else\n@@ -5730,7 +5753,8 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             // Calculate all the blocks we'd need to switch to pindexLast, up to a limit.\n             while (pindexWalk && !chainActive.Contains(pindexWalk) && vToFetch.size() <= MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n                 if (!(pindexWalk->nStatus & BLOCK_HAVE_DATA) &&\n-                        !mapBlocksInFlight.count(pindexWalk->GetBlockHash())) {\n+                        !mapBlocksInFlight.count(pindexWalk->GetBlockHash()) &&\n+                        (!IsWitnessEnabled(pindexWalk->pprev, chainparams.GetConsensus()) || State(pfrom->GetId())->fHaveWitness)) {\n                     // We don't have this block, and it's not yet in flight.\n                     vToFetch.push_back(pindexWalk);\n                 }\n@@ -5752,7 +5776,8 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                         // Can't download any more from this peer\n                         break;\n                     }\n-                    vGetData.push_back(CInv(MSG_BLOCK, pindex->GetBlockHash()));\n+                    uint32_t nFetchFlags = GetFetchFlags(pfrom, pindex->pprev, chainparams.GetConsensus());\n+                    vGetData.push_back(CInv(MSG_BLOCK | nFetchFlags, pindex->GetBlockHash()));\n                     MarkBlockAsInFlight(pfrom->GetId(), pindex->GetBlockHash(), chainparams.GetConsensus(), pindex);\n                     LogPrint(\"net\", \"Requesting block %s from  peer=%d\\n\",\n                             pindex->GetBlockHash().ToString(), pfrom->id);\n@@ -6598,10 +6623,13 @@ bool SendMessages(CNode* pto)\n             NodeId staller = -1;\n             FindNextBlocksToDownload(pto->GetId(), MAX_BLOCKS_IN_TRANSIT_PER_PEER - state.nBlocksInFlight, vToDownload, staller);\n             BOOST_FOREACH(CBlockIndex *pindex, vToDownload) {\n-                vGetData.push_back(CInv(MSG_BLOCK, pindex->GetBlockHash()));\n-                MarkBlockAsInFlight(pto->GetId(), pindex->GetBlockHash(), consensusParams, pindex);\n-                LogPrint(\"net\", \"Requesting block %s (%d) peer=%d\\n\", pindex->GetBlockHash().ToString(),\n-                    pindex->nHeight, pto->id);\n+                if (State(pto->GetId())->fHaveWitness || !IsWitnessEnabled(pindex->pprev, consensusParams)) {\n+                    uint32_t nFetchFlags = GetFetchFlags(pto, pindex->pprev, consensusParams);\n+                    vGetData.push_back(CInv(MSG_BLOCK | nFetchFlags, pindex->GetBlockHash()));\n+                    MarkBlockAsInFlight(pto->GetId(), pindex->GetBlockHash(), consensusParams, pindex);\n+                    LogPrint(\"net\", \"Requesting block %s (%d) peer=%d\\n\", pindex->GetBlockHash().ToString(),\n+                        pindex->nHeight, pto->id);\n+                }\n             }\n             if (state.nBlocksInFlight == 0 && staller != -1) {\n                 if (State(staller)->nStallingSince == 0) {"
      },
      {
        "sha": "dc83f19be48c82f8370e97cead20f8a15028082f",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 1,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b8a97498df1e83f8dcc49bc3fa4344f9e9799242/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b8a97498df1e83f8dcc49bc3fa4344f9e9799242/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=b8a97498df1e83f8dcc49bc3fa4344f9e9799242",
        "patch": "@@ -72,7 +72,7 @@ namespace {\n const static std::string NET_MESSAGE_COMMAND_OTHER = \"*other*\";\n \n /** Services this node implementation cares about */\n-static const ServiceFlags nRelevantServices = NODE_NETWORK;\n+ServiceFlags nRelevantServices = NODE_NETWORK;\n \n //\n // Global state variables\n@@ -1676,6 +1676,10 @@ void ThreadOpenConnections()\n             if (nANow - addr.nLastTry < 600 && nTries < 30)\n                 continue;\n \n+            // only consider nodes missing relevant services after 40 failed attemps\n+            if ((addr.nServices & nRelevantServices) != nRelevantServices && nTries < 40)\n+                continue;\n+\n             // do not allow non-default ports, unless after 50 invalid addresses selected already\n             if (addr.GetPort() != Params().GetDefaultPort() && nTries < 50)\n                 continue;"
      },
      {
        "sha": "7ed18b2050a38de5a05e17bbb40ee04c81f857eb",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b8a97498df1e83f8dcc49bc3fa4344f9e9799242/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b8a97498df1e83f8dcc49bc3fa4344f9e9799242/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=b8a97498df1e83f8dcc49bc3fa4344f9e9799242",
        "patch": "@@ -156,6 +156,7 @@ CAddress GetLocalAddress(const CNetAddr *paddrPeer = NULL);\n extern bool fDiscover;\n extern bool fListen;\n extern ServiceFlags nLocalServices;\n+extern ServiceFlags nRelevantServices;\n extern bool fRelayTxes;\n extern uint64_t nLocalHostNonce;\n extern CAddrMan addrman;"
      },
      {
        "sha": "15f27e2d2fbcb3d5e88ddd4e6fee3b04a236ac9f",
        "filename": "src/protocol.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b8a97498df1e83f8dcc49bc3fa4344f9e9799242/src/protocol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b8a97498df1e83f8dcc49bc3fa4344f9e9799242/src/protocol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.h?ref=b8a97498df1e83f8dcc49bc3fa4344f9e9799242",
        "patch": "@@ -264,6 +264,9 @@ enum ServiceFlags : uint64_t {\n     // Bitcoin Core nodes used to support this by default, without advertising this bit,\n     // but no longer do as of protocol version 70011 (= NO_BLOOM_VERSION)\n     NODE_BLOOM = (1 << 2),\n+    // Indicates that a node can be asked for blocks and transactions including\n+    // witness data.\n+    NODE_WITNESS = (1 << 3),\n \n     // Bits 24-31 are reserved for temporary experiments. Just pick a bit that\n     // isn't getting used, or one not being used much, and notify the"
      },
      {
        "sha": "4327de9b0c86d5ebb8a99f6b304690020d983aba",
        "filename": "src/qt/guiutil.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b8a97498df1e83f8dcc49bc3fa4344f9e9799242/src/qt/guiutil.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b8a97498df1e83f8dcc49bc3fa4344f9e9799242/src/qt/guiutil.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/guiutil.cpp?ref=b8a97498df1e83f8dcc49bc3fa4344f9e9799242",
        "patch": "@@ -909,6 +909,9 @@ QString formatServicesStr(quint64 mask)\n             case NODE_BLOOM:\n                 strList.append(\"BLOOM\");\n                 break;\n+            case NODE_WITNESS:\n+                strList.append(\"WITNESS\");\n+                break;\n             default:\n                 strList.append(QString(\"%1[%2]\").arg(\"UNKNOWN\").arg(check));\n             }"
      }
    ]
  },
  {
    "sha": "0ef1dd3e11dd573b6e443852ef0c72e34093ac68",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowZWYxZGQzZTExZGQ1NzNiNmU0NDM4NTJlZjBjNzJlMzQwOTNhYzY4",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-03-31T12:51:29Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-06-22T13:43:00Z"
      },
      "message": "Refactor script validation to observe amounts\n\nThis is a preparation for BIP143 support.",
      "tree": {
        "sha": "5fb4e54e732902ea296636877f2cd81dfd4f4b29",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5fb4e54e732902ea296636877f2cd81dfd4f4b29"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0ef1dd3e11dd573b6e443852ef0c72e34093ac68",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0ef1dd3e11dd573b6e443852ef0c72e34093ac68",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0ef1dd3e11dd573b6e443852ef0c72e34093ac68",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0ef1dd3e11dd573b6e443852ef0c72e34093ac68/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b8a97498df1e83f8dcc49bc3fa4344f9e9799242",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b8a97498df1e83f8dcc49bc3fa4344f9e9799242",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b8a97498df1e83f8dcc49bc3fa4344f9e9799242"
      }
    ],
    "stats": {
      "total": 84,
      "additions": 48,
      "deletions": 36
    },
    "files": [
      {
        "sha": "68c069659baca4cf41f33fece36e160c6b151940",
        "filename": "src/bitcoin-tx.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0ef1dd3e11dd573b6e443852ef0c72e34093ac68/src/bitcoin-tx.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0ef1dd3e11dd573b6e443852ef0c72e34093ac68/src/bitcoin-tx.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-tx.cpp?ref=0ef1dd3e11dd573b6e443852ef0c72e34093ac68",
        "patch": "@@ -462,6 +462,7 @@ static void MutateTxSign(CMutableTransaction& tx, const string& flagStr)\n             continue;\n         }\n         const CScript& prevPubKey = coins->vout[txin.prevout.n].scriptPubKey;\n+        const CAmount& amount = coins->vout[txin.prevout.n].nValue;\n \n         txin.scriptSig.clear();\n         // Only sign SIGHASH_SINGLE if there's a corresponding output:\n@@ -472,7 +473,7 @@ static void MutateTxSign(CMutableTransaction& tx, const string& flagStr)\n         BOOST_FOREACH(const CTransaction& txv, txVariants) {\n             txin.scriptSig = CombineSignatures(prevPubKey, mergedTx, i, txin.scriptSig, txv.vin[i].scriptSig);\n         }\n-        if (!VerifyScript(txin.scriptSig, prevPubKey, mergedTx.wit.vtxinwit.size() > i ? &mergedTx.wit.vtxinwit[i].scriptWitness : NULL, STANDARD_SCRIPT_VERIFY_FLAGS, MutableTransactionSignatureChecker(&mergedTx, i)))\n+        if (!VerifyScript(txin.scriptSig, prevPubKey, mergedTx.wit.vtxinwit.size() > i ? &mergedTx.wit.vtxinwit[i].scriptWitness : NULL, STANDARD_SCRIPT_VERIFY_FLAGS, MutableTransactionSignatureChecker(&mergedTx, i, amount)))\n             fComplete = false;\n     }\n "
      },
      {
        "sha": "c22faf6db6f5803b5b699f5bb49a9389096be911",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0ef1dd3e11dd573b6e443852ef0c72e34093ac68/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0ef1dd3e11dd573b6e443852ef0c72e34093ac68/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=0ef1dd3e11dd573b6e443852ef0c72e34093ac68",
        "patch": "@@ -1885,7 +1885,7 @@ void UpdateCoins(const CTransaction& tx, CCoinsViewCache& inputs, int nHeight)\n bool CScriptCheck::operator()() {\n     const CScript &scriptSig = ptxTo->vin[nIn].scriptSig;\n     const CScriptWitness *witness = (nIn < ptxTo->wit.vtxinwit.size()) ? &ptxTo->wit.vtxinwit[nIn].scriptWitness : NULL;\n-    if (!VerifyScript(scriptSig, scriptPubKey, witness, nFlags, CachingTransactionSignatureChecker(ptxTo, nIn, cacheStore), &error)) {\n+    if (!VerifyScript(scriptSig, scriptPubKey, witness, nFlags, CachingTransactionSignatureChecker(ptxTo, nIn, amount, cacheStore), &error)) {\n         return false;\n     }\n     return true;"
      },
      {
        "sha": "6dd4b1aa3d0a280248ac54b0f02285dae593fe0b",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0ef1dd3e11dd573b6e443852ef0c72e34093ac68/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0ef1dd3e11dd573b6e443852ef0c72e34093ac68/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=0ef1dd3e11dd573b6e443852ef0c72e34093ac68",
        "patch": "@@ -394,23 +394,25 @@ class CScriptCheck\n {\n private:\n     CScript scriptPubKey;\n+    CAmount amount;\n     const CTransaction *ptxTo;\n     unsigned int nIn;\n     unsigned int nFlags;\n     bool cacheStore;\n     ScriptError error;\n \n public:\n-    CScriptCheck(): ptxTo(0), nIn(0), nFlags(0), cacheStore(false), error(SCRIPT_ERR_UNKNOWN_ERROR) {}\n+    CScriptCheck(): amount(0), ptxTo(0), nIn(0), nFlags(0), cacheStore(false), error(SCRIPT_ERR_UNKNOWN_ERROR) {}\n     CScriptCheck(const CCoins& txFromIn, const CTransaction& txToIn, unsigned int nInIn, unsigned int nFlagsIn, bool cacheIn) :\n-        scriptPubKey(txFromIn.vout[txToIn.vin[nInIn].prevout.n].scriptPubKey),\n+        scriptPubKey(txFromIn.vout[txToIn.vin[nInIn].prevout.n].scriptPubKey), amount(txFromIn.vout[txToIn.vin[nInIn].prevout.n].nValue),\n         ptxTo(&txToIn), nIn(nInIn), nFlags(nFlagsIn), cacheStore(cacheIn), error(SCRIPT_ERR_UNKNOWN_ERROR) { }\n \n     bool operator()();\n \n     void swap(CScriptCheck &check) {\n         scriptPubKey.swap(check.scriptPubKey);\n         std::swap(ptxTo, check.ptxTo);\n+        std::swap(amount, check.amount);\n         std::swap(nIn, check.nIn);\n         std::swap(nFlags, check.nFlags);\n         std::swap(cacheStore, check.cacheStore);"
      },
      {
        "sha": "ebfc828d4585bdf4d4c7fd193f61ea35cc708392",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0ef1dd3e11dd573b6e443852ef0c72e34093ac68/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0ef1dd3e11dd573b6e443852ef0c72e34093ac68/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=0ef1dd3e11dd573b6e443852ef0c72e34093ac68",
        "patch": "@@ -778,6 +778,7 @@ UniValue signrawtransaction(const UniValue& params, bool fHelp)\n             continue;\n         }\n         const CScript& prevPubKey = coins->vout[txin.prevout.n].scriptPubKey;\n+        const CAmount& amount = coins->vout[txin.prevout.n].nValue;\n \n         txin.scriptSig.clear();\n         // Only sign SIGHASH_SINGLE if there's a corresponding output:\n@@ -789,7 +790,7 @@ UniValue signrawtransaction(const UniValue& params, bool fHelp)\n             txin.scriptSig = CombineSignatures(prevPubKey, txConst, i, txin.scriptSig, txv.vin[i].scriptSig);\n         }\n         ScriptError serror = SCRIPT_ERR_OK;\n-        if (!VerifyScript(txin.scriptSig, prevPubKey, mergedTx.wit.vtxinwit.size() > i ? &mergedTx.wit.vtxinwit[i].scriptWitness : NULL, STANDARD_SCRIPT_VERIFY_FLAGS, TransactionSignatureChecker(&txConst, i), &serror)) {\n+        if (!VerifyScript(txin.scriptSig, prevPubKey, mergedTx.wit.vtxinwit.size() > i ? &mergedTx.wit.vtxinwit[i].scriptWitness : NULL, STANDARD_SCRIPT_VERIFY_FLAGS, TransactionSignatureChecker(&txConst, i, amount), &serror)) {\n             TxInErrorToJSON(txin, vErrors, ScriptErrorString(serror));\n         }\n     }"
      },
      {
        "sha": "26e7a85b7b7229c33b01f4542996d20f4b983cf5",
        "filename": "src/script/bitcoinconsensus.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0ef1dd3e11dd573b6e443852ef0c72e34093ac68/src/script/bitcoinconsensus.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0ef1dd3e11dd573b6e443852ef0c72e34093ac68/src/script/bitcoinconsensus.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/bitcoinconsensus.cpp?ref=0ef1dd3e11dd573b6e443852ef0c72e34093ac68",
        "patch": "@@ -85,7 +85,8 @@ int bitcoinconsensus_verify_script(const unsigned char *scriptPubKey, unsigned i\n          // Regardless of the verification result, the tx did not error.\n          set_error(err, bitcoinconsensus_ERR_OK);\n \n-        return VerifyScript(tx.vin[nIn].scriptSig, CScript(scriptPubKey, scriptPubKey + scriptPubKeyLen), nIn < tx.wit.vtxinwit.size() ? &tx.wit.vtxinwit[nIn].scriptWitness : NULL, flags, TransactionSignatureChecker(&tx, nIn), NULL);\n+        CAmount am(0);\n+        return VerifyScript(tx.vin[nIn].scriptSig, CScript(scriptPubKey, scriptPubKey + scriptPubKeyLen), nIn < tx.wit.vtxinwit.size() ? &tx.wit.vtxinwit[nIn].scriptWitness : NULL, flags, TransactionSignatureChecker(&tx, nIn, am), NULL);\n     } catch (const std::exception&) {\n         return set_error(err, bitcoinconsensus_ERR_TX_DESERIALIZE); // Error deserializing\n     }"
      },
      {
        "sha": "cd3e2f773177b4d4c95db355ebbe9b9b1ac83533",
        "filename": "src/script/bitcoinconsensus.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0ef1dd3e11dd573b6e443852ef0c72e34093ac68/src/script/bitcoinconsensus.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0ef1dd3e11dd573b6e443852ef0c72e34093ac68/src/script/bitcoinconsensus.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/bitcoinconsensus.h?ref=0ef1dd3e11dd573b6e443852ef0c72e34093ac68",
        "patch": "@@ -6,6 +6,8 @@\n #ifndef BITCOIN_BITCOINCONSENSUS_H\n #define BITCOIN_BITCOINCONSENSUS_H\n \n+#include <stdint.h>\n+\n #if defined(BUILD_BITCOIN_INTERNAL) && defined(HAVE_CONFIG_H)\n #include \"config/bitcoin-config.h\"\n   #if defined(_WIN32)"
      },
      {
        "sha": "6f13e75d78f6256ce4d686075954c105d6c2b9ab",
        "filename": "src/script/interpreter.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0ef1dd3e11dd573b6e443852ef0c72e34093ac68/src/script/interpreter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0ef1dd3e11dd573b6e443852ef0c72e34093ac68/src/script/interpreter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.h?ref=0ef1dd3e11dd573b6e443852ef0c72e34093ac68",
        "patch": "@@ -131,7 +131,7 @@ class TransactionSignatureChecker : public BaseSignatureChecker\n     virtual bool VerifySignature(const std::vector<unsigned char>& vchSig, const CPubKey& vchPubKey, const uint256& sighash) const;\n \n public:\n-    TransactionSignatureChecker(const CTransaction* txToIn, unsigned int nInIn) : txTo(txToIn), nIn(nInIn) {}\n+    TransactionSignatureChecker(const CTransaction* txToIn, unsigned int nInIn, const CAmount& amount) : txTo(txToIn), nIn(nInIn) {}\n     bool CheckSig(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode) const;\n     bool CheckLockTime(const CScriptNum& nLockTime) const;\n     bool CheckSequence(const CScriptNum& nSequence) const;\n@@ -143,7 +143,7 @@ class MutableTransactionSignatureChecker : public TransactionSignatureChecker\n     const CTransaction txTo;\n \n public:\n-    MutableTransactionSignatureChecker(const CMutableTransaction* txToIn, unsigned int nInIn) : TransactionSignatureChecker(&txTo, nInIn), txTo(*txToIn) {}\n+    MutableTransactionSignatureChecker(const CMutableTransaction* txToIn, unsigned int nInIn, const CAmount& amount) : TransactionSignatureChecker(&txTo, nInIn, amount), txTo(*txToIn) {}\n };\n \n bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* error = NULL);"
      },
      {
        "sha": "050bf8cc4229089251bf3fc6d977e17ee000f193",
        "filename": "src/script/sigcache.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0ef1dd3e11dd573b6e443852ef0c72e34093ac68/src/script/sigcache.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0ef1dd3e11dd573b6e443852ef0c72e34093ac68/src/script/sigcache.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sigcache.h?ref=0ef1dd3e11dd573b6e443852ef0c72e34093ac68",
        "patch": "@@ -22,7 +22,7 @@ class CachingTransactionSignatureChecker : public TransactionSignatureChecker\n     bool store;\n \n public:\n-    CachingTransactionSignatureChecker(const CTransaction* txToIn, unsigned int nInIn, bool storeIn=true) : TransactionSignatureChecker(txToIn, nInIn), store(storeIn) {}\n+    CachingTransactionSignatureChecker(const CTransaction* txToIn, unsigned int nInIn, const CAmount& amount, bool storeIn) : TransactionSignatureChecker(txToIn, nInIn, amount), store(storeIn) {}\n \n     bool VerifySignature(const std::vector<unsigned char>& vchSig, const CPubKey& vchPubKey, const uint256& sighash) const;\n };"
      },
      {
        "sha": "62d874eed45845dbdd5548626673995d88404617",
        "filename": "src/script/sign.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0ef1dd3e11dd573b6e443852ef0c72e34093ac68/src/script/sign.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0ef1dd3e11dd573b6e443852ef0c72e34093ac68/src/script/sign.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.cpp?ref=0ef1dd3e11dd573b6e443852ef0c72e34093ac68",
        "patch": "@@ -18,7 +18,8 @@ using namespace std;\n \n typedef std::vector<unsigned char> valtype;\n \n-TransactionSignatureCreator::TransactionSignatureCreator(const CKeyStore* keystoreIn, const CTransaction* txToIn, unsigned int nInIn, int nHashTypeIn) : BaseSignatureCreator(keystoreIn), txTo(txToIn), nIn(nInIn), nHashType(nHashTypeIn), checker(txTo, nIn) {}\n+static const CAmount amountZero = 0;\n+TransactionSignatureCreator::TransactionSignatureCreator(const CKeyStore* keystoreIn, const CTransaction* txToIn, unsigned int nInIn, int nHashTypeIn) : BaseSignatureCreator(keystoreIn), txTo(txToIn), nIn(nInIn), nHashType(nHashTypeIn), checker(txTo, nIn, amountZero) {}\n \n bool TransactionSignatureCreator::CreateSig(std::vector<unsigned char>& vchSig, const CKeyID& address, const CScript& scriptCode) const\n {\n@@ -258,7 +259,7 @@ static CScript CombineSignatures(const CScript& scriptPubKey, const BaseSignatur\n CScript CombineSignatures(const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn,\n                           const CScript& scriptSig1, const CScript& scriptSig2)\n {\n-    TransactionSignatureChecker checker(&txTo, nIn);\n+    TransactionSignatureChecker checker(&txTo, nIn, amountZero);\n     return CombineSignatures(scriptPubKey, checker, scriptSig1, scriptSig2);\n }\n "
      },
      {
        "sha": "8c95601ea1a0838f5809a4a6511f555bfd4352b4",
        "filename": "src/test/multisig_tests.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 8,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0ef1dd3e11dd573b6e443852ef0c72e34093ac68/src/test/multisig_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0ef1dd3e11dd573b6e443852ef0c72e34093ac68/src/test/multisig_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/multisig_tests.cpp?ref=0ef1dd3e11dd573b6e443852ef0c72e34093ac68",
        "patch": "@@ -46,6 +46,7 @@ BOOST_AUTO_TEST_CASE(multisig_verify)\n \n     ScriptError err;\n     CKey key[4];\n+    CAmount amount = 0;\n     for (int i = 0; i < 4; i++)\n         key[i].MakeNewKey(true);\n \n@@ -81,20 +82,20 @@ BOOST_AUTO_TEST_CASE(multisig_verify)\n     keys.assign(1,key[0]);\n     keys.push_back(key[1]);\n     s = sign_multisig(a_and_b, keys, txTo[0], 0);\n-    BOOST_CHECK(VerifyScript(s, a_and_b, NULL, flags, MutableTransactionSignatureChecker(&txTo[0], 0), &err));\n+    BOOST_CHECK(VerifyScript(s, a_and_b, NULL, flags, MutableTransactionSignatureChecker(&txTo[0], 0, amount), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n \n     for (int i = 0; i < 4; i++)\n     {\n         keys.assign(1,key[i]);\n         s = sign_multisig(a_and_b, keys, txTo[0], 0);\n-        BOOST_CHECK_MESSAGE(!VerifyScript(s, a_and_b, NULL, flags, MutableTransactionSignatureChecker(&txTo[0], 0), &err), strprintf(\"a&b 1: %d\", i));\n+        BOOST_CHECK_MESSAGE(!VerifyScript(s, a_and_b, NULL, flags, MutableTransactionSignatureChecker(&txTo[0], 0, amount), &err), strprintf(\"a&b 1: %d\", i));\n         BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_INVALID_STACK_OPERATION, ScriptErrorString(err));\n \n         keys.assign(1,key[1]);\n         keys.push_back(key[i]);\n         s = sign_multisig(a_and_b, keys, txTo[0], 0);\n-        BOOST_CHECK_MESSAGE(!VerifyScript(s, a_and_b, NULL, flags, MutableTransactionSignatureChecker(&txTo[0], 0), &err), strprintf(\"a&b 2: %d\", i));\n+        BOOST_CHECK_MESSAGE(!VerifyScript(s, a_and_b, NULL, flags, MutableTransactionSignatureChecker(&txTo[0], 0, amount), &err), strprintf(\"a&b 2: %d\", i));\n         BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n     }\n \n@@ -105,18 +106,18 @@ BOOST_AUTO_TEST_CASE(multisig_verify)\n         s = sign_multisig(a_or_b, keys, txTo[1], 0);\n         if (i == 0 || i == 1)\n         {\n-            BOOST_CHECK_MESSAGE(VerifyScript(s, a_or_b, NULL, flags, MutableTransactionSignatureChecker(&txTo[1], 0), &err), strprintf(\"a|b: %d\", i));\n+            BOOST_CHECK_MESSAGE(VerifyScript(s, a_or_b, NULL, flags, MutableTransactionSignatureChecker(&txTo[1], 0, amount), &err), strprintf(\"a|b: %d\", i));\n             BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n         }\n         else\n         {\n-            BOOST_CHECK_MESSAGE(!VerifyScript(s, a_or_b, NULL, flags, MutableTransactionSignatureChecker(&txTo[1], 0), &err), strprintf(\"a|b: %d\", i));\n+            BOOST_CHECK_MESSAGE(!VerifyScript(s, a_or_b, NULL, flags, MutableTransactionSignatureChecker(&txTo[1], 0, amount), &err), strprintf(\"a|b: %d\", i));\n             BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n         }\n     }\n     s.clear();\n     s << OP_0 << OP_1;\n-    BOOST_CHECK(!VerifyScript(s, a_or_b, NULL, flags, MutableTransactionSignatureChecker(&txTo[1], 0), &err));\n+    BOOST_CHECK(!VerifyScript(s, a_or_b, NULL, flags, MutableTransactionSignatureChecker(&txTo[1], 0, amount), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_SIG_DER, ScriptErrorString(err));\n \n \n@@ -128,12 +129,12 @@ BOOST_AUTO_TEST_CASE(multisig_verify)\n             s = sign_multisig(escrow, keys, txTo[2], 0);\n             if (i < j && i < 3 && j < 3)\n             {\n-                BOOST_CHECK_MESSAGE(VerifyScript(s, escrow, NULL, flags, MutableTransactionSignatureChecker(&txTo[2], 0), &err), strprintf(\"escrow 1: %d %d\", i, j));\n+                BOOST_CHECK_MESSAGE(VerifyScript(s, escrow, NULL, flags, MutableTransactionSignatureChecker(&txTo[2], 0, amount), &err), strprintf(\"escrow 1: %d %d\", i, j));\n                 BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n             }\n             else\n             {\n-                BOOST_CHECK_MESSAGE(!VerifyScript(s, escrow, NULL, flags, MutableTransactionSignatureChecker(&txTo[2], 0), &err), strprintf(\"escrow 2: %d %d\", i, j));\n+                BOOST_CHECK_MESSAGE(!VerifyScript(s, escrow, NULL, flags, MutableTransactionSignatureChecker(&txTo[2], 0, amount), &err), strprintf(\"escrow 2: %d %d\", i, j));\n                 BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n             }\n         }"
      },
      {
        "sha": "62deb736aad2210d6ca665212a202f05c53297ca",
        "filename": "src/test/script_P2SH_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0ef1dd3e11dd573b6e443852ef0c72e34093ac68/src/test/script_P2SH_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0ef1dd3e11dd573b6e443852ef0c72e34093ac68/src/test/script_P2SH_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_P2SH_tests.cpp?ref=0ef1dd3e11dd573b6e443852ef0c72e34093ac68",
        "patch": "@@ -42,7 +42,7 @@ Verify(const CScript& scriptSig, const CScript& scriptPubKey, bool fStrict, Scri\n     txTo.vin[0].scriptSig = scriptSig;\n     txTo.vout[0].nValue = 1;\n \n-    return VerifyScript(scriptSig, scriptPubKey, NULL, fStrict ? SCRIPT_VERIFY_P2SH : SCRIPT_VERIFY_NONE, MutableTransactionSignatureChecker(&txTo, 0), &err);\n+    return VerifyScript(scriptSig, scriptPubKey, NULL, fStrict ? SCRIPT_VERIFY_P2SH : SCRIPT_VERIFY_NONE, MutableTransactionSignatureChecker(&txTo, 0, txFrom.vout[0].nValue), &err);\n }\n \n "
      },
      {
        "sha": "9587fecfdf4712d2169b58ea41a4cf9f77f87c36",
        "filename": "src/test/script_tests.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 14,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0ef1dd3e11dd573b6e443852ef0c72e34093ac68/src/test/script_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0ef1dd3e11dd573b6e443852ef0c72e34093ac68/src/test/script_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_tests.cpp?ref=0ef1dd3e11dd573b6e443852ef0c72e34093ac68",
        "patch": "@@ -154,7 +154,8 @@ void DoTest(const CScript& scriptPubKey, const CScript& scriptSig, int flags, co\n     ScriptError err;\n     CMutableTransaction tx = BuildSpendingTransaction(scriptSig, BuildCreditingTransaction(scriptPubKey));\n     CMutableTransaction tx2 = tx;\n-    BOOST_CHECK_MESSAGE(VerifyScript(scriptSig, scriptPubKey, NULL, flags, MutableTransactionSignatureChecker(&tx, 0), &err) == expect, message);\n+    static const CAmount amountZero = 0;\n+    BOOST_CHECK_MESSAGE(VerifyScript(scriptSig, scriptPubKey, NULL, flags, MutableTransactionSignatureChecker(&tx, 0, amountZero), &err) == expect, message);\n     BOOST_CHECK_MESSAGE(err == scriptError, std::string(FormatScriptError(err)) + \" where \" + std::string(FormatScriptError((ScriptError_t)scriptError)) + \" expected: \" + message);\n #if defined(HAVE_CONSENSUS_LIB)\n     CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n@@ -803,18 +804,18 @@ BOOST_AUTO_TEST_CASE(script_CHECKMULTISIG12)\n     CMutableTransaction txTo12 = BuildSpendingTransaction(CScript(), txFrom12);\n \n     CScript goodsig1 = sign_multisig(scriptPubKey12, key1, txTo12);\n-    BOOST_CHECK(VerifyScript(goodsig1, scriptPubKey12, NULL, flags, MutableTransactionSignatureChecker(&txTo12, 0), &err));\n+    BOOST_CHECK(VerifyScript(goodsig1, scriptPubKey12, NULL, flags, MutableTransactionSignatureChecker(&txTo12, 0, txFrom12.vout[0].nValue), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n     txTo12.vout[0].nValue = 2;\n-    BOOST_CHECK(!VerifyScript(goodsig1, scriptPubKey12, NULL, flags, MutableTransactionSignatureChecker(&txTo12, 0), &err));\n+    BOOST_CHECK(!VerifyScript(goodsig1, scriptPubKey12, NULL, flags, MutableTransactionSignatureChecker(&txTo12, 0, txFrom12.vout[0].nValue), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n \n     CScript goodsig2 = sign_multisig(scriptPubKey12, key2, txTo12);\n-    BOOST_CHECK(VerifyScript(goodsig2, scriptPubKey12, NULL, flags, MutableTransactionSignatureChecker(&txTo12, 0), &err));\n+    BOOST_CHECK(VerifyScript(goodsig2, scriptPubKey12, NULL, flags, MutableTransactionSignatureChecker(&txTo12, 0, txFrom12.vout[0].nValue), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n \n     CScript badsig1 = sign_multisig(scriptPubKey12, key3, txTo12);\n-    BOOST_CHECK(!VerifyScript(badsig1, scriptPubKey12, NULL, flags, MutableTransactionSignatureChecker(&txTo12, 0), &err));\n+    BOOST_CHECK(!VerifyScript(badsig1, scriptPubKey12, NULL, flags, MutableTransactionSignatureChecker(&txTo12, 0, txFrom12.vout[0].nValue), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n }\n \n@@ -836,54 +837,54 @@ BOOST_AUTO_TEST_CASE(script_CHECKMULTISIG23)\n     std::vector<CKey> keys;\n     keys.push_back(key1); keys.push_back(key2);\n     CScript goodsig1 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(VerifyScript(goodsig1, scriptPubKey23, NULL, flags, MutableTransactionSignatureChecker(&txTo23, 0), &err));\n+    BOOST_CHECK(VerifyScript(goodsig1, scriptPubKey23, NULL, flags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n \n     keys.clear();\n     keys.push_back(key1); keys.push_back(key3);\n     CScript goodsig2 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(VerifyScript(goodsig2, scriptPubKey23, NULL, flags, MutableTransactionSignatureChecker(&txTo23, 0), &err));\n+    BOOST_CHECK(VerifyScript(goodsig2, scriptPubKey23, NULL, flags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n \n     keys.clear();\n     keys.push_back(key2); keys.push_back(key3);\n     CScript goodsig3 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(VerifyScript(goodsig3, scriptPubKey23, NULL, flags, MutableTransactionSignatureChecker(&txTo23, 0), &err));\n+    BOOST_CHECK(VerifyScript(goodsig3, scriptPubKey23, NULL, flags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n \n     keys.clear();\n     keys.push_back(key2); keys.push_back(key2); // Can't re-use sig\n     CScript badsig1 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(!VerifyScript(badsig1, scriptPubKey23, NULL, flags, MutableTransactionSignatureChecker(&txTo23, 0), &err));\n+    BOOST_CHECK(!VerifyScript(badsig1, scriptPubKey23, NULL, flags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n \n     keys.clear();\n     keys.push_back(key2); keys.push_back(key1); // sigs must be in correct order\n     CScript badsig2 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(!VerifyScript(badsig2, scriptPubKey23, NULL, flags, MutableTransactionSignatureChecker(&txTo23, 0), &err));\n+    BOOST_CHECK(!VerifyScript(badsig2, scriptPubKey23, NULL, flags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n \n     keys.clear();\n     keys.push_back(key3); keys.push_back(key2); // sigs must be in correct order\n     CScript badsig3 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(!VerifyScript(badsig3, scriptPubKey23, NULL, flags, MutableTransactionSignatureChecker(&txTo23, 0), &err));\n+    BOOST_CHECK(!VerifyScript(badsig3, scriptPubKey23, NULL, flags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n \n     keys.clear();\n     keys.push_back(key4); keys.push_back(key2); // sigs must match pubkeys\n     CScript badsig4 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(!VerifyScript(badsig4, scriptPubKey23, NULL, flags, MutableTransactionSignatureChecker(&txTo23, 0), &err));\n+    BOOST_CHECK(!VerifyScript(badsig4, scriptPubKey23, NULL, flags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n \n     keys.clear();\n     keys.push_back(key1); keys.push_back(key4); // sigs must match pubkeys\n     CScript badsig5 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(!VerifyScript(badsig5, scriptPubKey23, NULL, flags, MutableTransactionSignatureChecker(&txTo23, 0), &err));\n+    BOOST_CHECK(!VerifyScript(badsig5, scriptPubKey23, NULL, flags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n \n     keys.clear(); // Must have signatures\n     CScript badsig6 = sign_multisig(scriptPubKey23, keys, txTo23);\n-    BOOST_CHECK(!VerifyScript(badsig6, scriptPubKey23, NULL, flags, MutableTransactionSignatureChecker(&txTo23, 0), &err));\n+    BOOST_CHECK(!VerifyScript(badsig6, scriptPubKey23, NULL, flags, MutableTransactionSignatureChecker(&txTo23, 0, txFrom23.vout[0].nValue), &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_INVALID_STACK_OPERATION, ScriptErrorString(err));\n }\n "
      },
      {
        "sha": "9fb23d8edfab763d3eac0ede35e038c0b01eb70c",
        "filename": "src/test/transaction_tests.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0ef1dd3e11dd573b6e443852ef0c72e34093ac68/src/test/transaction_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0ef1dd3e11dd573b6e443852ef0c72e34093ac68/src/test/transaction_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/transaction_tests.cpp?ref=0ef1dd3e11dd573b6e443852ef0c72e34093ac68",
        "patch": "@@ -149,9 +149,10 @@ BOOST_AUTO_TEST_CASE(tx_valid)\n                     break;\n                 }\n \n+                CAmount amount = 0;\n                 unsigned int verify_flags = ParseScriptFlags(test[2].get_str());\n                 BOOST_CHECK_MESSAGE(VerifyScript(tx.vin[i].scriptSig, mapprevOutScriptPubKeys[tx.vin[i].prevout],\n-                                                 NULL, verify_flags, TransactionSignatureChecker(&tx, i), &err),\n+                                                 NULL, verify_flags, TransactionSignatureChecker(&tx, i, amount), &err),\n                                     strTest);\n                 BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n             }\n@@ -224,8 +225,9 @@ BOOST_AUTO_TEST_CASE(tx_invalid)\n                 }\n \n                 unsigned int verify_flags = ParseScriptFlags(test[2].get_str());\n+                CAmount amount = 0;\n                 fValid = VerifyScript(tx.vin[i].scriptSig, mapprevOutScriptPubKeys[tx.vin[i].prevout],\n-                                      NULL, verify_flags, TransactionSignatureChecker(&tx, i), &err);\n+                                      NULL, verify_flags, TransactionSignatureChecker(&tx, i, amount), &err);\n             }\n             BOOST_CHECK_MESSAGE(!fValid, strTest);\n             BOOST_CHECK_MESSAGE(err != SCRIPT_ERR_OK, ScriptErrorString(err));"
      }
    ]
  },
  {
    "sha": "3dd410294d42f251e4808ef1dfcfcd64817edbac",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozZGQ0MTAyOTRkNDJmMjUxZTQ4MDhlZjFkZmNmY2Q2NDgxN2VkYmFj",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2015-12-27T18:49:08Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-06-22T13:43:00Z"
      },
      "message": "BIP143: Verification logic\n\nIncludes simplifications by Eric Lombrozo.",
      "tree": {
        "sha": "d6c5146772069c84ad8edbef9fce968b33d54924",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d6c5146772069c84ad8edbef9fce968b33d54924"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3dd410294d42f251e4808ef1dfcfcd64817edbac",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3dd410294d42f251e4808ef1dfcfcd64817edbac",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/3dd410294d42f251e4808ef1dfcfcd64817edbac",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3dd410294d42f251e4808ef1dfcfcd64817edbac/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "0ef1dd3e11dd573b6e443852ef0c72e34093ac68",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0ef1dd3e11dd573b6e443852ef0c72e34093ac68",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0ef1dd3e11dd573b6e443852ef0c72e34093ac68"
      }
    ],
    "stats": {
      "total": 194,
      "additions": 131,
      "deletions": 63
    },
    "files": [
      {
        "sha": "424812a6dfbc54e76902e1bec93647ce673548d8",
        "filename": "src/bitcoin-tx.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3dd410294d42f251e4808ef1dfcfcd64817edbac/src/bitcoin-tx.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3dd410294d42f251e4808ef1dfcfcd64817edbac/src/bitcoin-tx.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-tx.cpp?ref=3dd410294d42f251e4808ef1dfcfcd64817edbac",
        "patch": "@@ -471,7 +471,7 @@ static void MutateTxSign(CMutableTransaction& tx, const string& flagStr)\n \n         // ... and merge in other signatures:\n         BOOST_FOREACH(const CTransaction& txv, txVariants) {\n-            txin.scriptSig = CombineSignatures(prevPubKey, mergedTx, i, txin.scriptSig, txv.vin[i].scriptSig);\n+            txin.scriptSig = CombineSignatures(prevPubKey, mergedTx, i, amount, txin.scriptSig, txv.vin[i].scriptSig);\n         }\n         if (!VerifyScript(txin.scriptSig, prevPubKey, mergedTx.wit.vtxinwit.size() > i ? &mergedTx.wit.vtxinwit[i].scriptWitness : NULL, STANDARD_SCRIPT_VERIFY_FLAGS, MutableTransactionSignatureChecker(&mergedTx, i, amount)))\n             fComplete = false;"
      },
      {
        "sha": "67434a38fa3c178354f15536ab59aa0cee7be03b",
        "filename": "src/policy/policy.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3dd410294d42f251e4808ef1dfcfcd64817edbac/src/policy/policy.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3dd410294d42f251e4808ef1dfcfcd64817edbac/src/policy/policy.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/policy.cpp?ref=3dd410294d42f251e4808ef1dfcfcd64817edbac",
        "patch": "@@ -137,7 +137,7 @@ bool AreInputsStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)\n         {\n             std::vector<std::vector<unsigned char> > stack;\n             // convert the scriptSig into a stack, so we can inspect the redeemScript\n-            if (!EvalScript(stack, tx.vin[i].scriptSig, SCRIPT_VERIFY_NONE, BaseSignatureChecker(), 0))\n+            if (!EvalScript(stack, tx.vin[i].scriptSig, SCRIPT_VERIFY_NONE, BaseSignatureChecker(), SIGVERSION_BASE))\n                 return false;\n             if (stack.empty())\n                 return false;"
      },
      {
        "sha": "38fd98055c42fb19f4627d677c9336150f334d6b",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3dd410294d42f251e4808ef1dfcfcd64817edbac/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3dd410294d42f251e4808ef1dfcfcd64817edbac/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=3dd410294d42f251e4808ef1dfcfcd64817edbac",
        "patch": "@@ -787,7 +787,7 @@ UniValue signrawtransaction(const UniValue& params, bool fHelp)\n \n         // ... and merge in other signatures:\n         BOOST_FOREACH(const CMutableTransaction& txv, txVariants) {\n-            txin.scriptSig = CombineSignatures(prevPubKey, txConst, i, txin.scriptSig, txv.vin[i].scriptSig);\n+            txin.scriptSig = CombineSignatures(prevPubKey, txConst, i, amount, txin.scriptSig, txv.vin[i].scriptSig);\n         }\n         ScriptError serror = SCRIPT_ERR_OK;\n         if (!VerifyScript(txin.scriptSig, prevPubKey, mergedTx.wit.vtxinwit.size() > i ? &mergedTx.wit.vtxinwit[i].scriptWitness : NULL, STANDARD_SCRIPT_VERIFY_FLAGS, TransactionSignatureChecker(&txConst, i, amount), &serror)) {"
      },
      {
        "sha": "4deebd050d45eb257498c929475f1d0f98e1c00a",
        "filename": "src/script/interpreter.cpp",
        "status": "modified",
        "additions": 72,
        "deletions": 12,
        "changes": 84,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3dd410294d42f251e4808ef1dfcfcd64817edbac/src/script/interpreter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3dd410294d42f251e4808ef1dfcfcd64817edbac/src/script/interpreter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.cpp?ref=3dd410294d42f251e4808ef1dfcfcd64817edbac",
        "patch": "@@ -229,7 +229,7 @@ bool static CheckMinimalPush(const valtype& data, opcodetype opcode) {\n     return true;\n }\n \n-bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror)\n+bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* serror)\n {\n     static const CScriptNum bnZero(0);\n     static const CScriptNum bnOne(1);\n@@ -869,13 +869,15 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                     CScript scriptCode(pbegincodehash, pend);\n \n                     // Drop the signature, since there's no way for a signature to sign itself\n-                    scriptCode.FindAndDelete(CScript(vchSig));\n+                    if (sigversion == SIGVERSION_BASE) {\n+                        scriptCode.FindAndDelete(CScript(vchSig));\n+                    }\n \n                     if (!CheckSignatureEncoding(vchSig, flags, serror) || !CheckPubKeyEncoding(vchPubKey, flags, serror)) {\n                         //serror is set\n                         return false;\n                     }\n-                    bool fSuccess = checker.CheckSig(vchSig, vchPubKey, scriptCode);\n+                    bool fSuccess = checker.CheckSig(vchSig, vchPubKey, scriptCode, sigversion);\n \n                     popstack(stack);\n                     popstack(stack);\n@@ -925,7 +927,9 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                     for (int k = 0; k < nSigsCount; k++)\n                     {\n                         valtype& vchSig = stacktop(-isig-k);\n-                        scriptCode.FindAndDelete(CScript(vchSig));\n+                        if (sigversion == SIGVERSION_BASE) {\n+                            scriptCode.FindAndDelete(CScript(vchSig));\n+                        }\n                     }\n \n                     bool fSuccess = true;\n@@ -943,7 +947,7 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un\n                         }\n \n                         // Check signature\n-                        bool fOk = checker.CheckSig(vchSig, vchPubKey, scriptCode);\n+                        bool fOk = checker.CheckSig(vchSig, vchPubKey, scriptCode, sigversion);\n \n                         if (fOk) {\n                             isig++;\n@@ -1106,8 +1110,64 @@ class CTransactionSignatureSerializer {\n \n } // anon namespace\n \n-uint256 SignatureHash(const CScript& scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType)\n+uint256 SignatureHash(const CScript& scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType, const CAmount& amount, SigVersion sigversion)\n {\n+    if (sigversion == SIGVERSION_WITNESS_V0) {\n+        uint256 hashPrevouts;\n+        uint256 hashSequence;\n+        uint256 hashOutputs;\n+\n+        if (!(nHashType & SIGHASH_ANYONECANPAY)) {\n+            CHashWriter ss(SER_GETHASH, 0);\n+            for (unsigned int n = 0; n < txTo.vin.size(); n++) {\n+                ss << txTo.vin[n].prevout;\n+            }\n+            hashPrevouts = ss.GetHash(); // TODO: cache this value for all signatures in a transaction\n+        }\n+\n+        if (!(nHashType & SIGHASH_ANYONECANPAY) && (nHashType & 0x1f) != SIGHASH_SINGLE && (nHashType & 0x1f) != SIGHASH_NONE) {\n+            CHashWriter ss(SER_GETHASH, 0);\n+            for (unsigned int n = 0; n < txTo.vin.size(); n++) {\n+                ss << txTo.vin[n].nSequence;\n+            }\n+            hashSequence = ss.GetHash(); // TODO: cache this value for all signatures in a transaction\n+        }\n+\n+        if ((nHashType & 0x1f) != SIGHASH_SINGLE && (nHashType & 0x1f) != SIGHASH_NONE) {\n+            CHashWriter ss(SER_GETHASH, 0);\n+            for (unsigned int n = 0; n < txTo.vout.size(); n++) {\n+                ss << txTo.vout[n];\n+            }\n+            hashOutputs = ss.GetHash(); // TODO: cache this value for all signatures in a transaction\n+        } else if ((nHashType & 0x1f) == SIGHASH_SINGLE && nIn < txTo.vout.size()) {\n+            CHashWriter ss(SER_GETHASH, 0);\n+            ss << txTo.vout[nIn];\n+            hashOutputs = ss.GetHash();\n+        }\n+\n+        CHashWriter ss(SER_GETHASH, 0);\n+        // Version\n+        ss << txTo.nVersion;\n+        // Input prevouts/nSequence (none/all, depending on flags)\n+        ss << hashPrevouts;\n+        ss << hashSequence;\n+        // The input being signed (replacing the scriptSig with scriptCode + amount)\n+        // The prevout may already be contained in hashPrevout, and the nSequence\n+        // may already be contain in hashSequence.\n+        ss << txTo.vin[nIn].prevout;\n+        ss << static_cast<const CScriptBase&>(scriptCode);\n+        ss << amount;\n+        ss << txTo.vin[nIn].nSequence;\n+        // Outputs (none/one/all, depending on flags)\n+        ss << hashOutputs;\n+        // Locktime\n+        ss << txTo.nLockTime;\n+        // Sighash type\n+        ss << nHashType;\n+\n+        return ss.GetHash();\n+    }\n+\n     static const uint256 one(uint256S(\"0000000000000000000000000000000000000000000000000000000000000001\"));\n     if (nIn >= txTo.vin.size()) {\n         //  nIn out of range\n@@ -1136,7 +1196,7 @@ bool TransactionSignatureChecker::VerifySignature(const std::vector<unsigned cha\n     return pubkey.Verify(sighash, vchSig);\n }\n \n-bool TransactionSignatureChecker::CheckSig(const vector<unsigned char>& vchSigIn, const vector<unsigned char>& vchPubKey, const CScript& scriptCode) const\n+bool TransactionSignatureChecker::CheckSig(const vector<unsigned char>& vchSigIn, const vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const\n {\n     CPubKey pubkey(vchPubKey);\n     if (!pubkey.IsValid())\n@@ -1149,7 +1209,7 @@ bool TransactionSignatureChecker::CheckSig(const vector<unsigned char>& vchSigIn\n     int nHashType = vchSig.back();\n     vchSig.pop_back();\n \n-    uint256 sighash = SignatureHash(scriptCode, *txTo, nIn, nHashType);\n+    uint256 sighash = SignatureHash(scriptCode, *txTo, nIn, nHashType, amount, sigversion);\n \n     if (!VerifySignature(vchSig, pubkey, sighash))\n         return false;\n@@ -1280,7 +1340,7 @@ static bool VerifyWitnessProgram(const CScriptWitness& witness, int witversion,\n             return set_error(serror, SCRIPT_ERR_PUSH_SIZE);\n     }\n \n-    if (!EvalScript(stack, scriptPubKey, flags, checker, serror)) {\n+    if (!EvalScript(stack, scriptPubKey, flags, checker, SIGVERSION_WITNESS_V0, serror)) {\n         return false;\n     }\n \n@@ -1307,12 +1367,12 @@ bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const C\n     }\n \n     vector<vector<unsigned char> > stack, stackCopy;\n-    if (!EvalScript(stack, scriptSig, flags, checker, serror))\n+    if (!EvalScript(stack, scriptSig, flags, checker, SIGVERSION_BASE, serror))\n         // serror is set\n         return false;\n     if (flags & SCRIPT_VERIFY_P2SH)\n         stackCopy = stack;\n-    if (!EvalScript(stack, scriptPubKey, flags, checker, serror))\n+    if (!EvalScript(stack, scriptPubKey, flags, checker, SIGVERSION_BASE, serror))\n         // serror is set\n         return false;\n     if (stack.empty())\n@@ -1358,7 +1418,7 @@ bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const C\n         CScript pubKey2(pubKeySerialized.begin(), pubKeySerialized.end());\n         popstack(stack);\n \n-        if (!EvalScript(stack, pubKey2, flags, checker, serror))\n+        if (!EvalScript(stack, pubKey2, flags, checker, SIGVERSION_BASE, serror))\n             // serror is set\n             return false;\n         if (stack.empty())"
      },
      {
        "sha": "86437294253e9cf65ad41370ab731d8000a1a2b0",
        "filename": "src/script/interpreter.h",
        "status": "modified",
        "additions": 12,
        "deletions": 5,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3dd410294d42f251e4808ef1dfcfcd64817edbac/src/script/interpreter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3dd410294d42f251e4808ef1dfcfcd64817edbac/src/script/interpreter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.h?ref=3dd410294d42f251e4808ef1dfcfcd64817edbac",
        "patch": "@@ -98,12 +98,18 @@ enum\n \n bool CheckSignatureEncoding(const std::vector<unsigned char> &vchSig, unsigned int flags, ScriptError* serror);\n \n-uint256 SignatureHash(const CScript &scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);\n+enum SigVersion\n+{\n+    SIGVERSION_BASE = 0,\n+    SIGVERSION_WITNESS_V0 = 1,\n+};\n+\n+uint256 SignatureHash(const CScript &scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType, const CAmount& amount, SigVersion sigversion);\n \n class BaseSignatureChecker\n {\n public:\n-    virtual bool CheckSig(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode) const\n+    virtual bool CheckSig(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const\n     {\n         return false;\n     }\n@@ -126,13 +132,14 @@ class TransactionSignatureChecker : public BaseSignatureChecker\n private:\n     const CTransaction* txTo;\n     unsigned int nIn;\n+    const CAmount amount;\n \n protected:\n     virtual bool VerifySignature(const std::vector<unsigned char>& vchSig, const CPubKey& vchPubKey, const uint256& sighash) const;\n \n public:\n-    TransactionSignatureChecker(const CTransaction* txToIn, unsigned int nInIn, const CAmount& amount) : txTo(txToIn), nIn(nInIn) {}\n-    bool CheckSig(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode) const;\n+    TransactionSignatureChecker(const CTransaction* txToIn, unsigned int nInIn, const CAmount& amountIn) : txTo(txToIn), nIn(nInIn), amount(amountIn) {}\n+    bool CheckSig(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const;\n     bool CheckLockTime(const CScriptNum& nLockTime) const;\n     bool CheckSequence(const CScriptNum& nSequence) const;\n };\n@@ -146,7 +153,7 @@ class MutableTransactionSignatureChecker : public TransactionSignatureChecker\n     MutableTransactionSignatureChecker(const CMutableTransaction* txToIn, unsigned int nInIn, const CAmount& amount) : TransactionSignatureChecker(&txTo, nInIn, amount), txTo(*txToIn) {}\n };\n \n-bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* error = NULL);\n+bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* error = NULL);\n bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CScriptWitness* witness, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror = NULL);\n \n #endif // BITCOIN_SCRIPT_INTERPRETER_H"
      },
      {
        "sha": "83bb0cfa29f580e6a69f2ac67f1ff66fc615d124",
        "filename": "src/script/sign.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 9,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3dd410294d42f251e4808ef1dfcfcd64817edbac/src/script/sign.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3dd410294d42f251e4808ef1dfcfcd64817edbac/src/script/sign.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.cpp?ref=3dd410294d42f251e4808ef1dfcfcd64817edbac",
        "patch": "@@ -18,16 +18,15 @@ using namespace std;\n \n typedef std::vector<unsigned char> valtype;\n \n-static const CAmount amountZero = 0;\n-TransactionSignatureCreator::TransactionSignatureCreator(const CKeyStore* keystoreIn, const CTransaction* txToIn, unsigned int nInIn, int nHashTypeIn) : BaseSignatureCreator(keystoreIn), txTo(txToIn), nIn(nInIn), nHashType(nHashTypeIn), checker(txTo, nIn, amountZero) {}\n+TransactionSignatureCreator::TransactionSignatureCreator(const CKeyStore* keystoreIn, const CTransaction* txToIn, unsigned int nInIn, const CAmount& amountIn, int nHashTypeIn) : BaseSignatureCreator(keystoreIn), txTo(txToIn), nIn(nInIn), nHashType(nHashTypeIn), amount(amountIn), checker(txTo, nIn, amountIn) {}\n \n bool TransactionSignatureCreator::CreateSig(std::vector<unsigned char>& vchSig, const CKeyID& address, const CScript& scriptCode) const\n {\n     CKey key;\n     if (!keystore->GetKey(address, key))\n         return false;\n \n-    uint256 hash = SignatureHash(scriptCode, *txTo, nIn, nHashType);\n+    uint256 hash = SignatureHash(scriptCode, *txTo, nIn, nHashType, amount, SIGVERSION_BASE);\n     if (!key.Sign(hash, vchSig))\n         return false;\n     vchSig.push_back((unsigned char)nHashType);\n@@ -186,7 +185,7 @@ static CScript CombineMultisig(const CScript& scriptPubKey, const BaseSignatureC\n             if (sigs.count(pubkey))\n                 continue; // Already got a sig for this pubkey\n \n-            if (checker.CheckSig(sig, pubkey, scriptPubKey))\n+            if (checker.CheckSig(sig, pubkey, scriptPubKey, SIGVERSION_BASE))\n             {\n                 sigs[pubkey] = sig;\n                 break;\n@@ -256,10 +255,10 @@ static CScript CombineSignatures(const CScript& scriptPubKey, const BaseSignatur\n     return CScript();\n }\n \n-CScript CombineSignatures(const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn,\n+CScript CombineSignatures(const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn, const CAmount& amount,\n                           const CScript& scriptSig1, const CScript& scriptSig2)\n {\n-    TransactionSignatureChecker checker(&txTo, nIn, amountZero);\n+    TransactionSignatureChecker checker(&txTo, nIn, amount);\n     return CombineSignatures(scriptPubKey, checker, scriptSig1, scriptSig2);\n }\n \n@@ -271,9 +270,9 @@ CScript CombineSignatures(const CScript& scriptPubKey, const BaseSignatureChecke\n     Solver(scriptPubKey, txType, vSolutions);\n \n     vector<valtype> stack1;\n-    EvalScript(stack1, scriptSig1, SCRIPT_VERIFY_STRICTENC, BaseSignatureChecker());\n+    EvalScript(stack1, scriptSig1, SCRIPT_VERIFY_STRICTENC, BaseSignatureChecker(), SIGVERSION_BASE);\n     vector<valtype> stack2;\n-    EvalScript(stack2, scriptSig2, SCRIPT_VERIFY_STRICTENC, BaseSignatureChecker());\n+    EvalScript(stack2, scriptSig2, SCRIPT_VERIFY_STRICTENC, BaseSignatureChecker(), SIGVERSION_BASE);\n \n     return CombineSignatures(scriptPubKey, checker, txType, vSolutions, stack1, stack2);\n }\n@@ -285,7 +284,7 @@ class DummySignatureChecker : public BaseSignatureChecker\n public:\n     DummySignatureChecker() {}\n \n-    bool CheckSig(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode) const\n+    bool CheckSig(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const\n     {\n         return true;\n     }"
      },
      {
        "sha": "f54511f7a67f5d23a82b202cb2cb42f9ea1b1e14",
        "filename": "src/script/sign.h",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3dd410294d42f251e4808ef1dfcfcd64817edbac/src/script/sign.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3dd410294d42f251e4808ef1dfcfcd64817edbac/src/script/sign.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.h?ref=3dd410294d42f251e4808ef1dfcfcd64817edbac",
        "patch": "@@ -35,10 +35,11 @@ class TransactionSignatureCreator : public BaseSignatureCreator {\n     const CTransaction* txTo;\n     unsigned int nIn;\n     int nHashType;\n+    CAmount amount;\n     const TransactionSignatureChecker checker;\n \n public:\n-    TransactionSignatureCreator(const CKeyStore* keystoreIn, const CTransaction* txToIn, unsigned int nInIn, int nHashTypeIn=SIGHASH_ALL);\n+    TransactionSignatureCreator(const CKeyStore* keystoreIn, const CTransaction* txToIn, unsigned int nInIn, const CAmount& amountIn, int nHashTypeIn=SIGHASH_ALL);\n     const BaseSignatureChecker& Checker() const { return checker; }\n     bool CreateSig(std::vector<unsigned char>& vchSig, const CKeyID& keyid, const CScript& scriptCode) const;\n };\n@@ -62,6 +63,6 @@ bool SignSignature(const CKeyStore& keystore, const CTransaction& txFrom, CMutab\n CScript CombineSignatures(const CScript& scriptPubKey, const BaseSignatureChecker& checker, const CScript& scriptSig1, const CScript& scriptSig2);\n \n /** Combine two script signatures on transactions. */\n-CScript CombineSignatures(const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn, const CScript& scriptSig1, const CScript& scriptSig2);\n+CScript CombineSignatures(const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn, const CAmount& amount, const CScript& scriptSig1, const CScript& scriptSig2);\n \n #endif // BITCOIN_SCRIPT_SIGN_H"
      },
      {
        "sha": "876b90e4b99ed7e6fcfe6be5304bfb1df63e7ea5",
        "filename": "src/test/multisig_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3dd410294d42f251e4808ef1dfcfcd64817edbac/src/test/multisig_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3dd410294d42f251e4808ef1dfcfcd64817edbac/src/test/multisig_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/multisig_tests.cpp?ref=3dd410294d42f251e4808ef1dfcfcd64817edbac",
        "patch": "@@ -26,7 +26,7 @@ BOOST_FIXTURE_TEST_SUITE(multisig_tests, BasicTestingSetup)\n CScript\n sign_multisig(CScript scriptPubKey, vector<CKey> keys, CTransaction transaction, int whichIn)\n {\n-    uint256 hash = SignatureHash(scriptPubKey, transaction, whichIn, SIGHASH_ALL);\n+    uint256 hash = SignatureHash(scriptPubKey, transaction, whichIn, SIGHASH_ALL, 0, SIGVERSION_BASE);\n \n     CScript result;\n     result << OP_0; // CHECKMULTISIG bug workaround"
      },
      {
        "sha": "c56b9da4e5ab5947977fd0338416b5aa2a277254",
        "filename": "src/test/script_tests.cpp",
        "status": "modified",
        "additions": 29,
        "deletions": 28,
        "changes": 57,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3dd410294d42f251e4808ef1dfcfcd64817edbac/src/test/script_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3dd410294d42f251e4808ef1dfcfcd64817edbac/src/test/script_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_tests.cpp?ref=3dd410294d42f251e4808ef1dfcfcd64817edbac",
        "patch": "@@ -306,7 +306,7 @@ class TestBuilder\n \n     TestBuilder& PushSig(const CKey& key, int nHashType = SIGHASH_ALL, unsigned int lenR = 32, unsigned int lenS = 32)\n     {\n-        uint256 hash = SignatureHash(scriptPubKey, spendTx, 0, nHashType);\n+        uint256 hash = SignatureHash(scriptPubKey, spendTx, 0, nHashType, 0, SIGVERSION_BASE);\n         std::vector<unsigned char> vchSig, r, s;\n         uint32_t iter = 0;\n         do {\n@@ -738,29 +738,29 @@ BOOST_AUTO_TEST_CASE(script_PushData)\n \n     ScriptError err;\n     vector<vector<unsigned char> > directStack;\n-    BOOST_CHECK(EvalScript(directStack, CScript(&direct[0], &direct[sizeof(direct)]), SCRIPT_VERIFY_P2SH, BaseSignatureChecker(), &err));\n+    BOOST_CHECK(EvalScript(directStack, CScript(&direct[0], &direct[sizeof(direct)]), SCRIPT_VERIFY_P2SH, BaseSignatureChecker(), SIGVERSION_BASE, &err));\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n \n     vector<vector<unsigned char> > pushdata1Stack;\n-    BOOST_CHECK(EvalScript(pushdata1Stack, CScript(&pushdata1[0], &pushdata1[sizeof(pushdata1)]), SCRIPT_VERIFY_P2SH, BaseSignatureChecker(), &err));\n+    BOOST_CHECK(EvalScript(pushdata1Stack, CScript(&pushdata1[0], &pushdata1[sizeof(pushdata1)]), SCRIPT_VERIFY_P2SH, BaseSignatureChecker(), SIGVERSION_BASE, &err));\n     BOOST_CHECK(pushdata1Stack == directStack);\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n \n     vector<vector<unsigned char> > pushdata2Stack;\n-    BOOST_CHECK(EvalScript(pushdata2Stack, CScript(&pushdata2[0], &pushdata2[sizeof(pushdata2)]), SCRIPT_VERIFY_P2SH, BaseSignatureChecker(), &err));\n+    BOOST_CHECK(EvalScript(pushdata2Stack, CScript(&pushdata2[0], &pushdata2[sizeof(pushdata2)]), SCRIPT_VERIFY_P2SH, BaseSignatureChecker(), SIGVERSION_BASE, &err));\n     BOOST_CHECK(pushdata2Stack == directStack);\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n \n     vector<vector<unsigned char> > pushdata4Stack;\n-    BOOST_CHECK(EvalScript(pushdata4Stack, CScript(&pushdata4[0], &pushdata4[sizeof(pushdata4)]), SCRIPT_VERIFY_P2SH, BaseSignatureChecker(), &err));\n+    BOOST_CHECK(EvalScript(pushdata4Stack, CScript(&pushdata4[0], &pushdata4[sizeof(pushdata4)]), SCRIPT_VERIFY_P2SH, BaseSignatureChecker(), SIGVERSION_BASE, &err));\n     BOOST_CHECK(pushdata4Stack == directStack);\n     BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n }\n \n CScript\n sign_multisig(CScript scriptPubKey, std::vector<CKey> keys, CTransaction transaction)\n {\n-    uint256 hash = SignatureHash(scriptPubKey, transaction, 0, SIGHASH_ALL);\n+    uint256 hash = SignatureHash(scriptPubKey, transaction, 0, SIGHASH_ALL, 0, SIGVERSION_BASE);\n \n     CScript result;\n     //\n@@ -891,6 +891,7 @@ BOOST_AUTO_TEST_CASE(script_CHECKMULTISIG23)\n BOOST_AUTO_TEST_CASE(script_combineSigs)\n {\n     // Test the CombineSignatures function\n+    CAmount amount;\n     CBasicKeyStore keystore;\n     vector<CKey> keys;\n     vector<CPubKey> pubkeys;\n@@ -909,61 +910,61 @@ BOOST_AUTO_TEST_CASE(script_combineSigs)\n     CScript& scriptSig = txTo.vin[0].scriptSig;\n \n     CScript empty;\n-    CScript combined = CombineSignatures(scriptPubKey, txTo, 0, empty, empty);\n+    CScript combined = CombineSignatures(scriptPubKey, txTo, 0, amount, empty, empty);\n     BOOST_CHECK(combined.empty());\n \n     // Single signature case:\n     SignSignature(keystore, txFrom, txTo, 0); // changes scriptSig\n-    combined = CombineSignatures(scriptPubKey, txTo, 0, scriptSig, empty);\n+    combined = CombineSignatures(scriptPubKey, txTo, 0, amount, scriptSig, empty);\n     BOOST_CHECK(combined == scriptSig);\n-    combined = CombineSignatures(scriptPubKey, txTo, 0, empty, scriptSig);\n+    combined = CombineSignatures(scriptPubKey, txTo, 0, amount, empty, scriptSig);\n     BOOST_CHECK(combined == scriptSig);\n     CScript scriptSigCopy = scriptSig;\n     // Signing again will give a different, valid signature:\n     SignSignature(keystore, txFrom, txTo, 0);\n-    combined = CombineSignatures(scriptPubKey, txTo, 0, scriptSigCopy, scriptSig);\n+    combined = CombineSignatures(scriptPubKey, txTo, 0, amount, scriptSigCopy, scriptSig);\n     BOOST_CHECK(combined == scriptSigCopy || combined == scriptSig);\n \n     // P2SH, single-signature case:\n     CScript pkSingle; pkSingle << ToByteVector(keys[0].GetPubKey()) << OP_CHECKSIG;\n     keystore.AddCScript(pkSingle);\n     scriptPubKey = GetScriptForDestination(CScriptID(pkSingle));\n     SignSignature(keystore, txFrom, txTo, 0);\n-    combined = CombineSignatures(scriptPubKey, txTo, 0, scriptSig, empty);\n+    combined = CombineSignatures(scriptPubKey, txTo, 0, amount, scriptSig, empty);\n     BOOST_CHECK(combined == scriptSig);\n-    combined = CombineSignatures(scriptPubKey, txTo, 0, empty, scriptSig);\n+    combined = CombineSignatures(scriptPubKey, txTo, 0, amount, empty, scriptSig);\n     BOOST_CHECK(combined == scriptSig);\n     scriptSigCopy = scriptSig;\n     SignSignature(keystore, txFrom, txTo, 0);\n-    combined = CombineSignatures(scriptPubKey, txTo, 0, scriptSigCopy, scriptSig);\n+    combined = CombineSignatures(scriptPubKey, txTo, 0, amount, scriptSigCopy, scriptSig);\n     BOOST_CHECK(combined == scriptSigCopy || combined == scriptSig);\n     // dummy scriptSigCopy with placeholder, should always choose non-placeholder:\n     scriptSigCopy = CScript() << OP_0 << vector<unsigned char>(pkSingle.begin(), pkSingle.end());\n-    combined = CombineSignatures(scriptPubKey, txTo, 0, scriptSigCopy, scriptSig);\n+    combined = CombineSignatures(scriptPubKey, txTo, 0, amount, scriptSigCopy, scriptSig);\n     BOOST_CHECK(combined == scriptSig);\n-    combined = CombineSignatures(scriptPubKey, txTo, 0, scriptSig, scriptSigCopy);\n+    combined = CombineSignatures(scriptPubKey, txTo, 0, amount, scriptSig, scriptSigCopy);\n     BOOST_CHECK(combined == scriptSig);\n \n     // Hardest case:  Multisig 2-of-3\n     scriptPubKey = GetScriptForMultisig(2, pubkeys);\n     keystore.AddCScript(scriptPubKey);\n     SignSignature(keystore, txFrom, txTo, 0);\n-    combined = CombineSignatures(scriptPubKey, txTo, 0, scriptSig, empty);\n+    combined = CombineSignatures(scriptPubKey, txTo, 0, amount, scriptSig, empty);\n     BOOST_CHECK(combined == scriptSig);\n-    combined = CombineSignatures(scriptPubKey, txTo, 0, empty, scriptSig);\n+    combined = CombineSignatures(scriptPubKey, txTo, 0, amount, empty, scriptSig);\n     BOOST_CHECK(combined == scriptSig);\n \n     // A couple of partially-signed versions:\n     vector<unsigned char> sig1;\n-    uint256 hash1 = SignatureHash(scriptPubKey, txTo, 0, SIGHASH_ALL);\n+    uint256 hash1 = SignatureHash(scriptPubKey, txTo, 0, SIGHASH_ALL, 0, SIGVERSION_BASE);\n     BOOST_CHECK(keys[0].Sign(hash1, sig1));\n     sig1.push_back(SIGHASH_ALL);\n     vector<unsigned char> sig2;\n-    uint256 hash2 = SignatureHash(scriptPubKey, txTo, 0, SIGHASH_NONE);\n+    uint256 hash2 = SignatureHash(scriptPubKey, txTo, 0, SIGHASH_NONE, 0, SIGVERSION_BASE);\n     BOOST_CHECK(keys[1].Sign(hash2, sig2));\n     sig2.push_back(SIGHASH_NONE);\n     vector<unsigned char> sig3;\n-    uint256 hash3 = SignatureHash(scriptPubKey, txTo, 0, SIGHASH_SINGLE);\n+    uint256 hash3 = SignatureHash(scriptPubKey, txTo, 0, SIGHASH_SINGLE, 0, SIGVERSION_BASE);\n     BOOST_CHECK(keys[2].Sign(hash3, sig3));\n     sig3.push_back(SIGHASH_SINGLE);\n \n@@ -979,21 +980,21 @@ BOOST_AUTO_TEST_CASE(script_combineSigs)\n     CScript complete13 = CScript() << OP_0 << sig1 << sig3;\n     CScript complete23 = CScript() << OP_0 << sig2 << sig3;\n \n-    combined = CombineSignatures(scriptPubKey, txTo, 0, partial1a, partial1b);\n+    combined = CombineSignatures(scriptPubKey, txTo, 0, amount, partial1a, partial1b);\n     BOOST_CHECK(combined == partial1a);\n-    combined = CombineSignatures(scriptPubKey, txTo, 0, partial1a, partial2a);\n+    combined = CombineSignatures(scriptPubKey, txTo, 0, amount, partial1a, partial2a);\n     BOOST_CHECK(combined == complete12);\n-    combined = CombineSignatures(scriptPubKey, txTo, 0, partial2a, partial1a);\n+    combined = CombineSignatures(scriptPubKey, txTo, 0, amount, partial2a, partial1a);\n     BOOST_CHECK(combined == complete12);\n-    combined = CombineSignatures(scriptPubKey, txTo, 0, partial1b, partial2b);\n+    combined = CombineSignatures(scriptPubKey, txTo, 0, amount, partial1b, partial2b);\n     BOOST_CHECK(combined == complete12);\n-    combined = CombineSignatures(scriptPubKey, txTo, 0, partial3b, partial1b);\n+    combined = CombineSignatures(scriptPubKey, txTo, 0, amount, partial3b, partial1b);\n     BOOST_CHECK(combined == complete13);\n-    combined = CombineSignatures(scriptPubKey, txTo, 0, partial2a, partial3a);\n+    combined = CombineSignatures(scriptPubKey, txTo, 0, amount, partial2a, partial3a);\n     BOOST_CHECK(combined == complete23);\n-    combined = CombineSignatures(scriptPubKey, txTo, 0, partial3b, partial2b);\n+    combined = CombineSignatures(scriptPubKey, txTo, 0, amount, partial3b, partial2b);\n     BOOST_CHECK(combined == complete23);\n-    combined = CombineSignatures(scriptPubKey, txTo, 0, partial3b, partial3a);\n+    combined = CombineSignatures(scriptPubKey, txTo, 0, amount, partial3b, partial3a);\n     BOOST_CHECK(combined == partial3c);\n }\n "
      },
      {
        "sha": "4a48347b702dd3db485e6719a32a6a1135a933bb",
        "filename": "src/test/sighash_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3dd410294d42f251e4808ef1dfcfcd64817edbac/src/test/sighash_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3dd410294d42f251e4808ef1dfcfcd64817edbac/src/test/sighash_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/sighash_tests.cpp?ref=3dd410294d42f251e4808ef1dfcfcd64817edbac",
        "patch": "@@ -143,7 +143,7 @@ BOOST_AUTO_TEST_CASE(sighash_test)\n \n         uint256 sh, sho;\n         sho = SignatureHashOld(scriptCode, txTo, nIn, nHashType);\n-        sh = SignatureHash(scriptCode, txTo, nIn, nHashType);\n+        sh = SignatureHash(scriptCode, txTo, nIn, nHashType, 0, SIGVERSION_BASE);\n         #if defined(PRINT_SIGHASH_JSON)\n         CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n         ss << txTo;\n@@ -209,7 +209,7 @@ BOOST_AUTO_TEST_CASE(sighash_from_data)\n           continue;\n         }\n \n-        sh = SignatureHash(scriptCode, tx, nIn, nHashType);\n+        sh = SignatureHash(scriptCode, tx, nIn, nHashType, 0, SIGVERSION_BASE);\n         BOOST_CHECK_MESSAGE(sh.GetHex() == sigHashHex, strTest);\n     }\n }"
      },
      {
        "sha": "76e4e7a4be865fc6dd7e8e3204dfc2e8d3d30212",
        "filename": "src/test/txvalidationcache_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3dd410294d42f251e4808ef1dfcfcd64817edbac/src/test/txvalidationcache_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3dd410294d42f251e4808ef1dfcfcd64817edbac/src/test/txvalidationcache_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/txvalidationcache_tests.cpp?ref=3dd410294d42f251e4808ef1dfcfcd64817edbac",
        "patch": "@@ -48,7 +48,7 @@ BOOST_FIXTURE_TEST_CASE(tx_mempool_block_doublespend, TestChain100Setup)\n \n         // Sign:\n         std::vector<unsigned char> vchSig;\n-        uint256 hash = SignatureHash(scriptPubKey, spends[i], 0, SIGHASH_ALL);\n+        uint256 hash = SignatureHash(scriptPubKey, spends[i], 0, SIGHASH_ALL, 0, SIGVERSION_BASE);\n         BOOST_CHECK(coinbaseKey.Sign(hash, vchSig));\n         vchSig.push_back((unsigned char)SIGHASH_ALL);\n         spends[i].vin[0].scriptSig << vchSig;"
      }
    ]
  },
  {
    "sha": "7c4bf779e8b74e474551982a24f5acc265293abd",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3YzRiZjc3OWU4Yjc0ZTQ3NDU1MTk4MmEyNGY1YWNjMjY1MjkzYWJk",
    "commit": {
      "author": {
        "name": "Johnson Lau",
        "email": "jl2012@users.noreply.github.com",
        "date": "2016-01-22T17:46:11Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-06-22T13:43:00Z"
      },
      "message": "[RPC] Return witness data in blockchain RPCs\n\nIncludes RPC field name changes by Luke-jr.",
      "tree": {
        "sha": "771dd1049e432ac5016cb98a07d78a84a2fadb4f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/771dd1049e432ac5016cb98a07d78a84a2fadb4f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7c4bf779e8b74e474551982a24f5acc265293abd",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7c4bf779e8b74e474551982a24f5acc265293abd",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7c4bf779e8b74e474551982a24f5acc265293abd",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7c4bf779e8b74e474551982a24f5acc265293abd/comments",
    "author": {
      "login": "jl2012",
      "id": 8403418,
      "node_id": "MDQ6VXNlcjg0MDM0MTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8403418?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jl2012",
      "html_url": "https://github.com/jl2012",
      "followers_url": "https://api.github.com/users/jl2012/followers",
      "following_url": "https://api.github.com/users/jl2012/following{/other_user}",
      "gists_url": "https://api.github.com/users/jl2012/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jl2012/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jl2012/subscriptions",
      "organizations_url": "https://api.github.com/users/jl2012/orgs",
      "repos_url": "https://api.github.com/users/jl2012/repos",
      "events_url": "https://api.github.com/users/jl2012/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jl2012/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "3dd410294d42f251e4808ef1dfcfcd64817edbac",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3dd410294d42f251e4808ef1dfcfcd64817edbac",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3dd410294d42f251e4808ef1dfcfcd64817edbac"
      }
    ],
    "stats": {
      "total": 24,
      "additions": 22,
      "deletions": 2
    },
    "files": [
      {
        "sha": "f11af876f917cfadb4841c22efa06a9eb0b85c95",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c4bf779e8b74e474551982a24f5acc265293abd/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c4bf779e8b74e474551982a24f5acc265293abd/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=7c4bf779e8b74e474551982a24f5acc265293abd",
        "patch": "@@ -99,6 +99,7 @@ UniValue blockToJSON(const CBlock& block, const CBlockIndex* blockindex, bool tx\n     if (chainActive.Contains(blockindex))\n         confirmations = chainActive.Height() - blockindex->nHeight + 1;\n     result.push_back(Pair(\"confirmations\", confirmations));\n+    result.push_back(Pair(\"strippedsize\", (int)::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS)));\n     result.push_back(Pair(\"size\", (int)::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION)));\n     result.push_back(Pair(\"height\", blockindex->nHeight));\n     result.push_back(Pair(\"version\", block.nVersion));\n@@ -558,6 +559,7 @@ UniValue getblock(const UniValue& params, bool fHelp)\n             \"  \\\"hash\\\" : \\\"hash\\\",     (string) the block hash (same as provided)\\n\"\n             \"  \\\"confirmations\\\" : n,   (numeric) The number of confirmations, or -1 if the block is not on the main chain\\n\"\n             \"  \\\"size\\\" : n,            (numeric) The block size\\n\"\n+            \"  \\\"strippedsize\\\" : n,    (numeric) The block size excluding witness data\\n\"\n             \"  \\\"height\\\" : n,          (numeric) The block height or index\\n\"\n             \"  \\\"version\\\" : n,         (numeric) The block version\\n\"\n             \"  \\\"versionHex\\\" : \\\"00000000\\\", (string) The block version formatted in hexadecimal\\n\""
      },
      {
        "sha": "12e3eaa9201daaaff26be22b0dab2dff9081a4c6",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 2,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7c4bf779e8b74e474551982a24f5acc265293abd/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7c4bf779e8b74e474551982a24f5acc265293abd/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=7c4bf779e8b74e474551982a24f5acc265293abd",
        "patch": "@@ -62,11 +62,14 @@ void ScriptPubKeyToJSON(const CScript& scriptPubKey, UniValue& out, bool fInclud\n void TxToJSON(const CTransaction& tx, const uint256 hashBlock, UniValue& entry)\n {\n     entry.push_back(Pair(\"txid\", tx.GetHash().GetHex()));\n+    entry.push_back(Pair(\"hash\", tx.GetWitnessHash().GetHex()));\n     entry.push_back(Pair(\"size\", (int)::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION)));\n     entry.push_back(Pair(\"version\", tx.nVersion));\n     entry.push_back(Pair(\"locktime\", (int64_t)tx.nLockTime));\n+\n     UniValue vin(UniValue::VARR);\n-    BOOST_FOREACH(const CTxIn& txin, tx.vin) {\n+    for (unsigned int i = 0; i < tx.vin.size(); i++) {\n+        const CTxIn& txin = tx.vin[i];\n         UniValue in(UniValue::VOBJ);\n         if (tx.IsCoinBase())\n             in.push_back(Pair(\"coinbase\", HexStr(txin.scriptSig.begin(), txin.scriptSig.end())));\n@@ -78,6 +81,17 @@ void TxToJSON(const CTransaction& tx, const uint256 hashBlock, UniValue& entry)\n             o.push_back(Pair(\"hex\", HexStr(txin.scriptSig.begin(), txin.scriptSig.end())));\n             in.push_back(Pair(\"scriptSig\", o));\n         }\n+        if (!tx.wit.IsNull()) {\n+            if (!tx.wit.vtxinwit[i].IsNull()) {\n+                UniValue txinwitness(UniValue::VARR);\n+                for (unsigned int j = 0; j < tx.wit.vtxinwit[i].scriptWitness.stack.size(); j++) {\n+                    std::vector<unsigned char> item = tx.wit.vtxinwit[i].scriptWitness.stack[j];\n+                    txinwitness.push_back(HexStr(item.begin(), item.end()));\n+                }\n+                in.push_back(Pair(\"txinwitness\", txinwitness));\n+            }\n+\n+        }\n         in.push_back(Pair(\"sequence\", (int64_t)txin.nSequence));\n         vin.push_back(in);\n     }\n@@ -134,7 +148,8 @@ UniValue getrawtransaction(const UniValue& params, bool fHelp)\n             \"{\\n\"\n             \"  \\\"hex\\\" : \\\"data\\\",       (string) The serialized, hex-encoded data for 'txid'\\n\"\n             \"  \\\"txid\\\" : \\\"id\\\",        (string) The transaction id (same as provided)\\n\"\n-            \"  \\\"size\\\" : n,             (numeric) The transaction size\\n\"\n+            \"  \\\"hash\\\" : \\\"id\\\",        (string) The transaction hash (differs from txid for witness transactions)\\n\"\n+            \"  \\\"size\\\" : n,             (numeric) The serialized transaction size\\n\"\n             \"  \\\"version\\\" : n,          (numeric) The version\\n\"\n             \"  \\\"locktime\\\" : ttt,       (numeric) The lock time\\n\"\n             \"  \\\"vin\\\" : [               (array of json objects)\\n\"\n@@ -146,6 +161,7 @@ UniValue getrawtransaction(const UniValue& params, bool fHelp)\n             \"         \\\"hex\\\": \\\"hex\\\"   (string) hex\\n\"\n             \"       },\\n\"\n             \"       \\\"sequence\\\": n      (numeric) The script sequence number\\n\"\n+            \"       \\\"txinwitness\\\": [\\\"hex\\\", ...] (array of string) hex-encoded witness data (if any)\\n\"\n             \"     }\\n\"\n             \"     ,...\\n\"\n             \"  ],\\n\"\n@@ -443,6 +459,7 @@ UniValue decoderawtransaction(const UniValue& params, bool fHelp)\n             \"\\nResult:\\n\"\n             \"{\\n\"\n             \"  \\\"txid\\\" : \\\"id\\\",        (string) The transaction id\\n\"\n+            \"  \\\"hash\\\" : \\\"id\\\",        (string) The transaction hash (differs from txid for witness transactions)\\n\"\n             \"  \\\"size\\\" : n,             (numeric) The transaction size\\n\"\n             \"  \\\"version\\\" : n,          (numeric) The version\\n\"\n             \"  \\\"locktime\\\" : ttt,       (numeric) The lock time\\n\"\n@@ -454,6 +471,7 @@ UniValue decoderawtransaction(const UniValue& params, bool fHelp)\n             \"         \\\"asm\\\": \\\"asm\\\",  (string) asm\\n\"\n             \"         \\\"hex\\\": \\\"hex\\\"   (string) hex\\n\"\n             \"       },\\n\"\n+            \"       \\\"txinwitness\\\": [\\\"hex\\\", ...] (array of string) hex-encoded witness data (if any)\\n\"\n             \"       \\\"sequence\\\": n     (numeric) The script sequence number\\n\"\n             \"     }\\n\"\n             \"     ,...\\n\""
      }
    ]
  },
  {
    "sha": "2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyYjFmNmY5Y2NmMzZmMWUwYTJjOWQ5OTE1NGUxNjQyZjc5NmQ3YzJi",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-01-03T17:54:50Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-06-22T13:43:00Z"
      },
      "message": "BIP141: Other consensus critical limits, and BIP145\n\nIncludes changes by Suhas Daftuar, Luke-jr, and mruddy.",
      "tree": {
        "sha": "30b17fa55ea6c9ae0055c0c16d2e271a0c799d16",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/30b17fa55ea6c9ae0055c0c16d2e271a0c799d16"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7c4bf779e8b74e474551982a24f5acc265293abd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7c4bf779e8b74e474551982a24f5acc265293abd",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7c4bf779e8b74e474551982a24f5acc265293abd"
      }
    ],
    "stats": {
      "total": 480,
      "additions": 344,
      "deletions": 136
    },
    "files": [
      {
        "sha": "125d4eb275190238baa2355e93b0a05f7bc6e4ea",
        "filename": "qa/rpc-tests/maxuploadtarget.py",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b/qa/rpc-tests/maxuploadtarget.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b/qa/rpc-tests/maxuploadtarget.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/maxuploadtarget.py?ref=2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b",
        "patch": "@@ -97,7 +97,7 @@ def __init__(self):\n     def setup_network(self):\n         # Start a node with maxuploadtarget of 200 MB (/24h)\n         self.nodes = []\n-        self.nodes.append(start_node(0, self.options.tmpdir, [\"-debug\", \"-maxuploadtarget=200\", \"-blockmaxsize=999000\"]))\n+        self.nodes.append(start_node(0, self.options.tmpdir, [\"-debug\", \"-maxuploadtarget=800\", \"-blockmaxsize=999000\"]))\n \n     def mine_full_block(self, node, address):\n         # Want to create a full block\n@@ -175,13 +175,13 @@ def run_test(self):\n         getdata_request = msg_getdata()\n         getdata_request.inv.append(CInv(2, big_old_block))\n \n-        max_bytes_per_day = 200*1024*1024\n-        daily_buffer = 144 * MAX_BLOCK_SIZE\n+        max_bytes_per_day = 800*1024*1024\n+        daily_buffer = 144 * 4000000\n         max_bytes_available = max_bytes_per_day - daily_buffer\n         success_count = max_bytes_available // old_block_size\n \n-        # 144MB will be reserved for relaying new blocks, so expect this to\n-        # succeed for ~70 tries.\n+        # 576MB will be reserved for relaying new blocks, so expect this to\n+        # succeed for ~235 tries.\n         for i in range(success_count):\n             test_nodes[0].send_message(getdata_request)\n             test_nodes[0].sync_with_ping()\n@@ -198,9 +198,9 @@ def run_test(self):\n \n         # Requesting the current block on test_nodes[1] should succeed indefinitely,\n         # even when over the max upload target.\n-        # We'll try 200 times\n+        # We'll try 800 times\n         getdata_request.inv = [CInv(2, big_new_block)]\n-        for i in range(200):\n+        for i in range(800):\n             test_nodes[1].send_message(getdata_request)\n             test_nodes[1].sync_with_ping()\n             assert_equal(test_nodes[1].block_receive_map[big_new_block], i+1)"
      },
      {
        "sha": "e77aa6c72eea21e70ab0d300df859e19ed477bde",
        "filename": "src/bitcoin-tx.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b/src/bitcoin-tx.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b/src/bitcoin-tx.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-tx.cpp?ref=2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b",
        "patch": "@@ -195,7 +195,7 @@ static void MutateTxAddInput(CMutableTransaction& tx, const string& strInput)\n     uint256 txid(uint256S(strTxid));\n \n     static const unsigned int minTxOutSz = 9;\n-    static const unsigned int maxVout = MAX_BLOCK_SIZE / minTxOutSz;\n+    static const unsigned int maxVout = MAX_BLOCK_BASE_SIZE / minTxOutSz;\n \n     // extract and validate vout\n     string strVout = vStrInputParts[1];"
      },
      {
        "sha": "5c4c3bd27487cceb502dbe4d05363a24cce5ab65",
        "filename": "src/blockencodings.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b/src/blockencodings.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b/src/blockencodings.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/blockencodings.cpp?ref=2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b",
        "patch": "@@ -15,7 +15,7 @@\n \n #include <unordered_map>\n \n-#define MIN_TRANSACTION_SIZE (::GetSerializeSize(CTransaction(), SER_NETWORK, PROTOCOL_VERSION))\n+#define MIN_TRANSACTION_BASE_SIZE (::GetSerializeSize(CTransaction(), SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS))\n \n CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs(const CBlock& block) :\n         nonce(GetRand(std::numeric_limits<uint64_t>::max())),\n@@ -50,7 +50,7 @@ uint64_t CBlockHeaderAndShortTxIDs::GetShortID(const uint256& txhash) const {\n ReadStatus PartiallyDownloadedBlock::InitData(const CBlockHeaderAndShortTxIDs& cmpctblock) {\n     if (cmpctblock.header.IsNull() || (cmpctblock.shorttxids.empty() && cmpctblock.prefilledtxn.empty()))\n         return READ_STATUS_INVALID;\n-    if (cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size() > MAX_BLOCK_SIZE / MIN_TRANSACTION_SIZE)\n+    if (cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size() > MAX_BLOCK_BASE_SIZE / MIN_TRANSACTION_BASE_SIZE)\n         return READ_STATUS_INVALID;\n \n     assert(header.IsNull() && txn_available.empty());"
      },
      {
        "sha": "81f40593b21a6d36a46fc82a94715aa0646ec1a9",
        "filename": "src/consensus/consensus.h",
        "status": "modified",
        "additions": 9,
        "deletions": 3,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b/src/consensus/consensus.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b/src/consensus/consensus.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/consensus.h?ref=2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b",
        "patch": "@@ -6,10 +6,16 @@\n #ifndef BITCOIN_CONSENSUS_CONSENSUS_H\n #define BITCOIN_CONSENSUS_CONSENSUS_H\n \n-/** The maximum allowed size for a serialized block, in bytes (network rule) */\n-static const unsigned int MAX_BLOCK_SIZE = 1000000;\n+#include <stdint.h>\n+\n+/** The maximum allowed size for a serialized block, in bytes (only for buffer size limits) */\n+static const unsigned int MAX_BLOCK_SERIALIZED_SIZE = 4000000;\n+/** The maximum allowed cost for a block, see BIP 141 (network rule) */\n+static const unsigned int MAX_BLOCK_COST = 4000000;\n+/** The maximum allowed size for a block excluding witness data, in bytes (network rule) */\n+static const unsigned int MAX_BLOCK_BASE_SIZE = 1000000;\n /** The maximum allowed number of signature check operations in a block (network rule) */\n-static const unsigned int MAX_BLOCK_SIGOPS = MAX_BLOCK_SIZE/50;\n+static const int64_t MAX_BLOCK_SIGOPS_COST = 80000;\n /** Coinbase transaction outputs can only be spent after this number of new blocks (network rule) */\n static const int COINBASE_MATURITY = 100;\n "
      },
      {
        "sha": "e924d504bdd821851e5fc908caeadbb8b42c9998",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b",
        "patch": "@@ -452,6 +452,7 @@ std::string HelpMessage(HelpMessageMode mode)\n     strUsage += HelpMessageOpt(\"-mempoolreplacement\", strprintf(_(\"Enable transaction replacement in the memory pool (default: %u)\"), DEFAULT_ENABLE_REPLACEMENT));\n \n     strUsage += HelpMessageGroup(_(\"Block creation options:\"));\n+    strUsage += HelpMessageOpt(\"-blockmaxcost=<n>\", strprintf(_(\"Set maximum block cost (default: %d)\"), DEFAULT_BLOCK_MAX_COST));\n     strUsage += HelpMessageOpt(\"-blockminsize=<n>\", strprintf(_(\"Set minimum block size in bytes (default: %u)\"), DEFAULT_BLOCK_MIN_SIZE));\n     strUsage += HelpMessageOpt(\"-blockmaxsize=<n>\", strprintf(_(\"Set maximum block size in bytes (default: %d)\"), DEFAULT_BLOCK_MAX_SIZE));\n     strUsage += HelpMessageOpt(\"-blockprioritysize=<n>\", strprintf(_(\"Set maximum size of high-priority/low-fee transactions in bytes (default: %d)\"), DEFAULT_BLOCK_PRIORITY_SIZE));"
      },
      {
        "sha": "df758bc41f0b5ea2572387c882d123668f1b8f1e",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 51,
        "deletions": 27,
        "changes": 78,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b",
        "patch": "@@ -684,8 +684,8 @@ bool AddOrphanTx(const CTransaction& tx, NodeId peer) EXCLUSIVE_LOCKS_REQUIRED(c\n     // have been mined or received.\n     // 100 orphans, each of which is at most 99,999 bytes big is\n     // at most 10 megabytes of orphans and somewhat more byprev index (in the worst case):\n-    unsigned int sz = tx.GetSerializeSize(SER_NETWORK, CTransaction::CURRENT_VERSION);\n-    if (sz >= MAX_STANDARD_TX_SIZE)\n+    unsigned int sz = GetTransactionCost(tx);\n+    if (sz >= MAX_STANDARD_TX_COST)\n     {\n         LogPrint(\"mempool\", \"ignoring large orphan tx (size: %u, hash: %s)\\n\", sz, hash.ToString());\n         return false;\n@@ -1018,8 +1018,24 @@ unsigned int GetP2SHSigOpCount(const CTransaction& tx, const CCoinsViewCache& in\n     return nSigOps;\n }\n \n+int64_t GetTransactionSigOpCost(const CTransaction& tx, const CCoinsViewCache& inputs, int flags)\n+{\n+    int64_t nSigOps = GetLegacySigOpCount(tx) * WITNESS_SCALE_FACTOR;\n+\n+    if (tx.IsCoinBase())\n+        return nSigOps;\n \n+    if (flags & SCRIPT_VERIFY_P2SH) {\n+        nSigOps += GetP2SHSigOpCount(tx, inputs) * WITNESS_SCALE_FACTOR;\n+    }\n \n+    for (unsigned int i = 0; i < tx.vin.size(); i++)\n+    {\n+        const CTxOut &prevout = inputs.GetOutputFor(tx.vin[i]);\n+        nSigOps += CountWitnessSigOps(tx.vin[i].scriptSig, prevout.scriptPubKey, i < tx.wit.vtxinwit.size() ? &tx.wit.vtxinwit[i].scriptWitness : NULL, flags);\n+    }\n+    return nSigOps;\n+}\n \n \n \n@@ -1033,7 +1049,7 @@ bool CheckTransaction(const CTransaction& tx, CValidationState &state)\n     if (tx.vout.empty())\n         return state.DoS(10, false, REJECT_INVALID, \"bad-txns-vout-empty\");\n     // Size limits (this doesn't take the witness into account, as that hasn't been checked for malleability)\n-    if (::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) > MAX_BLOCK_SIZE)\n+    if (::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) > MAX_BLOCK_BASE_SIZE)\n         return state.DoS(100, false, REJECT_INVALID, \"bad-txns-oversize\");\n \n     // Check for negative or overflow output values\n@@ -1239,8 +1255,7 @@ bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState& state, const C\n         if (fRequireStandard && !AreInputsStandard(tx, view))\n             return state.Invalid(false, REJECT_NONSTANDARD, \"bad-txns-nonstandard-inputs\");\n \n-        unsigned int nSigOps = GetLegacySigOpCount(tx);\n-        nSigOps += GetP2SHSigOpCount(tx, view);\n+        int64_t nSigOpsCost = GetTransactionSigOpCost(tx, view, STANDARD_SCRIPT_VERIFY_FLAGS);\n \n         CAmount nValueOut = tx.GetValueOut();\n         CAmount nFees = nValueIn-nValueOut;\n@@ -1263,17 +1278,17 @@ bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState& state, const C\n             }\n         }\n \n-        CTxMemPoolEntry entry(tx, nFees, GetTime(), dPriority, chainActive.Height(), pool.HasNoInputsOf(tx), inChainInputValue, fSpendsCoinbase, nSigOps, lp);\n+        CTxMemPoolEntry entry(tx, nFees, GetTime(), dPriority, chainActive.Height(), pool.HasNoInputsOf(tx), inChainInputValue, fSpendsCoinbase, nSigOpsCost, lp);\n         unsigned int nSize = entry.GetTxSize();\n \n         // Check that the transaction doesn't have an excessive number of\n         // sigops, making it impossible to mine. Since the coinbase transaction\n         // itself can contain sigops MAX_STANDARD_TX_SIGOPS is less than\n         // MAX_BLOCK_SIGOPS; we still consider this an invalid rather than\n         // merely non-standard transaction.\n-        if ((nSigOps > MAX_STANDARD_TX_SIGOPS) || (nBytesPerSigOp && nSigOps > nSize / nBytesPerSigOp))\n+        if ((nSigOpsCost > MAX_STANDARD_TX_SIGOPS_COST) || (nBytesPerSigOp && nSigOpsCost > nSize * WITNESS_SCALE_FACTOR / nBytesPerSigOp))\n             return state.DoS(0, false, REJECT_NONSTANDARD, \"bad-txns-too-many-sigops\", false,\n-                strprintf(\"%d\", nSigOps));\n+                strprintf(\"%d\", nSigOpsCost));\n \n         CAmount mempoolRejectFee = pool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000).GetFee(nSize);\n         if (mempoolRejectFee > 0 && nModifiedFees < mempoolRejectFee) {\n@@ -2439,7 +2454,7 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin\n     std::vector<int> prevheights;\n     CAmount nFees = 0;\n     int nInputs = 0;\n-    unsigned int nSigOps = 0;\n+    int64_t nSigOpsCost = 0;\n     CDiskTxPos pos(pindex->GetBlockPos(), GetSizeOfCompactSize(block.vtx.size()));\n     std::vector<std::pair<uint256, CDiskTxPos> > vPos;\n     vPos.reserve(block.vtx.size());\n@@ -2449,10 +2464,6 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin\n         const CTransaction &tx = block.vtx[i];\n \n         nInputs += tx.vin.size();\n-        nSigOps += GetLegacySigOpCount(tx);\n-        if (nSigOps > MAX_BLOCK_SIGOPS)\n-            return state.DoS(100, error(\"ConnectBlock(): too many sigops\"),\n-                             REJECT_INVALID, \"bad-blk-sigops\");\n \n         if (!tx.IsCoinBase())\n         {\n@@ -2483,18 +2494,19 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin\n                 return state.DoS(100, error(\"%s: contains a non-BIP68-final transaction\", __func__),\n                                  REJECT_INVALID, \"bad-txns-nonfinal\");\n             }\n+        }\n \n-            if (fStrictPayToScriptHash)\n-            {\n-                // Add in sigops done by pay-to-script-hash inputs;\n-                // this is to prevent a \"rogue miner\" from creating\n-                // an incredibly-expensive-to-validate block.\n-                nSigOps += GetP2SHSigOpCount(tx, view);\n-                if (nSigOps > MAX_BLOCK_SIGOPS)\n-                    return state.DoS(100, error(\"ConnectBlock(): too many sigops\"),\n-                                     REJECT_INVALID, \"bad-blk-sigops\");\n-            }\n+        // GetTransactionSigOpCost counts 3 types of sigops:\n+        // * legacy (always)\n+        // * p2sh (when P2SH enabled in flags and excludes coinbase)\n+        // * witness (when witness enabled in flags and excludes coinbase)\n+        nSigOpsCost += GetTransactionSigOpCost(tx, view, flags);\n+        if (nSigOpsCost > MAX_BLOCK_SIGOPS_COST)\n+            return state.DoS(100, error(\"ConnectBlock(): too many sigops\"),\n+                             REJECT_INVALID, \"bad-blk-sigops\");\n \n+        if (!tx.IsCoinBase())\n+        {\n             nFees += view.GetValueIn(tx)-tx.GetValueOut();\n \n             std::vector<CScriptCheck> vChecks;\n@@ -3417,9 +3429,11 @@ bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::P\n     // All potential-corruption validation must be done before we do any\n     // transaction validation, as otherwise we may mark the header as invalid\n     // because we receive the wrong transactions for it.\n+    // Note that witness malleability is checked in ContextualCheckBlock, so no\n+    // checks that use witness data may be performed here.\n \n     // Size limits\n-    if (block.vtx.empty() || block.vtx.size() > MAX_BLOCK_SIZE || ::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) > MAX_BLOCK_SIZE)\n+    if (block.vtx.empty() || block.vtx.size() > MAX_BLOCK_BASE_SIZE || ::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) > MAX_BLOCK_BASE_SIZE)\n         return state.DoS(100, false, REJECT_INVALID, \"bad-blk-length\", false, \"size limits failed\");\n \n     // First transaction must be coinbase, the rest must not be\n@@ -3440,7 +3454,7 @@ bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::P\n     {\n         nSigOps += GetLegacySigOpCount(tx);\n     }\n-    if (nSigOps > MAX_BLOCK_SIGOPS)\n+    if (nSigOps * WITNESS_SCALE_FACTOR > MAX_BLOCK_SIGOPS_COST)\n         return state.DoS(100, false, REJECT_INVALID, \"bad-blk-sigops\", false, \"out-of-bounds SigOpCount\");\n \n     if (fCheckPOW && fCheckMerkleRoot)\n@@ -3621,6 +3635,16 @@ bool ContextualCheckBlock(const CBlock& block, CValidationState& state, CBlockIn\n         }\n     }\n \n+    // After the coinbase witness nonce and commitment are verified,\n+    // we can check if the block cost passes (before we've checked the\n+    // coinbase witness, it would be possible for the cost to be too\n+    // large by filling up the coinbase witness, which doesn't change\n+    // the block hash, so we couldn't mark the block as permanently\n+    // failed).\n+    if (GetBlockCost(block) > MAX_BLOCK_COST) {\n+        return state.DoS(100, error(\"ContextualCheckBlock(): cost limit failed\"), REJECT_INVALID, \"bad-blk-cost\");\n+    }\n+\n     return true;\n }\n \n@@ -4284,7 +4308,7 @@ bool LoadExternalBlockFile(const CChainParams& chainparams, FILE* fileIn, CDiskB\n     int nLoaded = 0;\n     try {\n         // This takes over fileIn and calls fclose() on it in the CBufferedFile destructor\n-        CBufferedFile blkdat(fileIn, 2*MAX_BLOCK_SIZE, MAX_BLOCK_SIZE+8, SER_DISK, CLIENT_VERSION);\n+        CBufferedFile blkdat(fileIn, 2*MAX_BLOCK_SERIALIZED_SIZE, MAX_BLOCK_SERIALIZED_SIZE+8, SER_DISK, CLIENT_VERSION);\n         uint64_t nRewind = blkdat.GetPos();\n         while (!blkdat.eof()) {\n             boost::this_thread::interruption_point();\n@@ -4303,7 +4327,7 @@ bool LoadExternalBlockFile(const CChainParams& chainparams, FILE* fileIn, CDiskB\n                     continue;\n                 // read size\n                 blkdat >> nSize;\n-                if (nSize < 80 || nSize > MAX_BLOCK_SIZE)\n+                if (nSize < 80 || nSize > MAX_BLOCK_SERIALIZED_SIZE)\n                     continue;\n             } catch (const std::exception&) {\n                 // no valid block header found; don't complain"
      },
      {
        "sha": "317470e3c86946663805b40f55349f44c8383906",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b",
        "patch": "@@ -152,6 +152,7 @@ typedef boost::unordered_map<uint256, CBlockIndex*, BlockHasher> BlockMap;\n extern BlockMap mapBlockIndex;\n extern uint64_t nLastBlockTx;\n extern uint64_t nLastBlockSize;\n+extern uint64_t nLastBlockCost;\n extern const std::string strMessageMagic;\n extern CWaitableCriticalSection csBestBlock;\n extern CConditionVariable cvBlockChange;"
      },
      {
        "sha": "31332526a916e35d327341a7c5ff0d97ea8d36eb",
        "filename": "src/merkleblock.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b/src/merkleblock.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b/src/merkleblock.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/merkleblock.cpp?ref=2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b",
        "patch": "@@ -155,7 +155,7 @@ uint256 CPartialMerkleTree::ExtractMatches(std::vector<uint256> &vMatch, std::ve\n     if (nTransactions == 0)\n         return uint256();\n     // check for excessively high numbers of transactions\n-    if (nTransactions > MAX_BLOCK_SIZE / 60) // 60 is the lower bound for the size of a serialized CTransaction\n+    if (nTransactions > MAX_BLOCK_BASE_SIZE / 60) // 60 is the lower bound for the size of a serialized CTransaction\n         return uint256();\n     // there can never be more hashes provided than one for every txid\n     if (vHash.size() > nTransactions)"
      },
      {
        "sha": "cfc2dae56ee4975ca3774f0c4aa5d8aaf6de804e",
        "filename": "src/miner.cpp",
        "status": "modified",
        "additions": 75,
        "deletions": 26,
        "changes": 101,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b/src/miner.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b/src/miner.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.cpp?ref=2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b",
        "patch": "@@ -45,6 +45,7 @@ using namespace std;\n \n uint64_t nLastBlockTx = 0;\n uint64_t nLastBlockSize = 0;\n+uint64_t nLastBlockCost = 0;\n \n class ScoreCompare\n {\n@@ -75,15 +76,36 @@ int64_t UpdateTime(CBlockHeader* pblock, const Consensus::Params& consensusParam\n BlockAssembler::BlockAssembler(const CChainParams& _chainparams)\n     : chainparams(_chainparams)\n {\n-    // Largest block you're willing to create:\n-    nBlockMaxSize = GetArg(\"-blockmaxsize\", DEFAULT_BLOCK_MAX_SIZE);\n-    // Limit to between 1K and MAX_BLOCK_SIZE-1K for sanity:\n-    nBlockMaxSize = std::max((unsigned int)1000, std::min((unsigned int)(MAX_BLOCK_SIZE-1000), nBlockMaxSize));\n+    // Block resource limits\n+    // If neither -blockmaxsize or -blockmaxcost is given, limit to DEFAULT_BLOCK_MAX_*\n+    // If only one is given, only restrict the specified resource.\n+    // If both are given, restrict both.\n+    nBlockMaxCost = DEFAULT_BLOCK_MAX_COST;\n+    nBlockMaxSize = DEFAULT_BLOCK_MAX_SIZE;\n+    bool fCostSet = false;\n+    if (mapArgs.count(\"-blockmaxcost\")) {\n+        nBlockMaxCost = GetArg(\"-blockmaxcost\", DEFAULT_BLOCK_MAX_COST);\n+        nBlockMaxSize = MAX_BLOCK_SERIALIZED_SIZE;\n+        fCostSet = true;\n+    }\n+    if (mapArgs.count(\"-blockmaxsize\")) {\n+        nBlockMaxSize = GetArg(\"-blockmaxsize\", DEFAULT_BLOCK_MAX_SIZE);\n+        if (!fCostSet) {\n+            nBlockMaxCost = nBlockMaxSize * WITNESS_SCALE_FACTOR;\n+        }\n+    }\n+    // Limit cost to between 4K and MAX_BLOCK_COST-4K for sanity:\n+    nBlockMaxCost = std::max((unsigned int)4000, std::min((unsigned int)(MAX_BLOCK_COST-4000), nBlockMaxCost));\n+    // Limit size to between 1K and MAX_BLOCK_SERIALIZED_SIZE-1K for sanity:\n+    nBlockMaxSize = std::max((unsigned int)1000, std::min((unsigned int)(MAX_BLOCK_SERIALIZED_SIZE-1000), nBlockMaxSize));\n \n     // Minimum block size you want to create; block will be filled with free transactions\n     // until there are no more or the block reaches this size:\n     nBlockMinSize = GetArg(\"-blockminsize\", DEFAULT_BLOCK_MIN_SIZE);\n     nBlockMinSize = std::min(nBlockMaxSize, nBlockMinSize);\n+\n+    // Whether we need to account for byte usage (in addition to cost usage)\n+    fNeedSizeAccounting = (nBlockMaxSize < MAX_BLOCK_SERIALIZED_SIZE-1000) || (nBlockMinSize > 0);\n }\n \n void BlockAssembler::resetBlock()\n@@ -92,7 +114,8 @@ void BlockAssembler::resetBlock()\n \n     // Reserve space for coinbase tx\n     nBlockSize = 1000;\n-    nBlockSigOps = 100;\n+    nBlockCost = 4000;\n+    nBlockSigOpsCost = 400;\n     fIncludeWitness = false;\n \n     // These counters do not include coinbase tx\n@@ -116,7 +139,7 @@ CBlockTemplate* BlockAssembler::CreateNewBlock(const CScript& scriptPubKeyIn)\n     // Add dummy coinbase tx as first transaction\n     pblock->vtx.push_back(CTransaction());\n     pblocktemplate->vTxFees.push_back(-1); // updated at end\n-    pblocktemplate->vTxSigOps.push_back(-1); // updated at end\n+    pblocktemplate->vTxSigOpsCost.push_back(-1); // updated at end\n \n     LOCK2(cs_main, mempool.cs);\n     CBlockIndex* pindexPrev = chainActive.Tip();\n@@ -144,11 +167,18 @@ CBlockTemplate* BlockAssembler::CreateNewBlock(const CScript& scriptPubKeyIn)\n     fIncludeWitness = IsWitnessEnabled(pindexPrev, chainparams.GetConsensus());\n \n     addPriorityTxs();\n-    addPackageTxs();\n+    if (fNeedSizeAccounting) {\n+        // addPackageTxs (the CPFP-based algorithm) cannot deal with size based\n+        // accounting, so fall back to the old algorithm.\n+        addScoreTxs();\n+    } else {\n+        addPackageTxs();\n+    }\n \n     nLastBlockTx = nBlockTx;\n     nLastBlockSize = nBlockSize;\n-    LogPrintf(\"CreateNewBlock(): total size %u txs: %u fees: %ld sigops %d\\n\", nBlockSize, nBlockTx, nFees, nBlockSigOps);\n+    nLastBlockCost = nBlockCost;\n+    LogPrintf(\"CreateNewBlock(): total size %u txs: %u fees: %ld sigops %d\\n\", nBlockSize, nBlockTx, nFees, nBlockSigOpsCost);\n \n     // Create coinbase transaction.\n     CMutableTransaction coinbaseTx;\n@@ -167,7 +197,7 @@ CBlockTemplate* BlockAssembler::CreateNewBlock(const CScript& scriptPubKeyIn)\n     UpdateTime(pblock, chainparams.GetConsensus(), pindexPrev);\n     pblock->nBits          = GetNextWorkRequired(pindexPrev, pblock, chainparams.GetConsensus());\n     pblock->nNonce         = 0;\n-    pblocktemplate->vTxSigOps[0] = GetLegacySigOpCount(pblock->vtx[0]);\n+    pblocktemplate->vTxSigOpsCost[0] = GetLegacySigOpCount(pblock->vtx[0]);\n \n     CValidationState state;\n     if (!TestBlockValidity(state, chainparams, *pblock, pindexPrev, false, false)) {\n@@ -201,11 +231,12 @@ void BlockAssembler::onlyUnconfirmed(CTxMemPool::setEntries& testSet)\n     }\n }\n \n-bool BlockAssembler::TestPackage(uint64_t packageSize, unsigned int packageSigOps)\n+bool BlockAssembler::TestPackage(uint64_t packageSize, int64_t packageSigOpsCost)\n {\n-    if (nBlockSize + packageSize >= nBlockMaxSize)\n+    // TODO: switch to cost-based accounting for packages instead of vsize-based accounting.\n+    if (nBlockCost + WITNESS_SCALE_FACTOR * packageSize >= nBlockMaxCost)\n         return false;\n-    if (nBlockSigOps + packageSigOps >= MAX_BLOCK_SIGOPS)\n+    if (nBlockSigOpsCost + packageSigOpsCost >= MAX_BLOCK_SIGOPS_COST)\n         return false;\n     return true;\n }\n@@ -223,26 +254,39 @@ bool BlockAssembler::TestPackageFinality(const CTxMemPool::setEntries& package)\n \n bool BlockAssembler::TestForBlock(CTxMemPool::txiter iter)\n {\n-    if (nBlockSize + iter->GetTxSize() >= nBlockMaxSize) {\n+    if (nBlockCost + iter->GetTxCost() >= nBlockMaxCost) {\n         // If the block is so close to full that no more txs will fit\n         // or if we've tried more than 50 times to fill remaining space\n         // then flag that the block is finished\n-        if (nBlockSize >  nBlockMaxSize - 100 || lastFewTxs > 50) {\n+        if (nBlockCost >  nBlockMaxCost - 400 || lastFewTxs > 50) {\n              blockFinished = true;\n              return false;\n         }\n-        // Once we're within 1000 bytes of a full block, only look at 50 more txs\n+        // Once we're within 4000 cost of a full block, only look at 50 more txs\n         // to try to fill the remaining space.\n-        if (nBlockSize > nBlockMaxSize - 1000) {\n+        if (nBlockCost > nBlockMaxCost - 4000) {\n             lastFewTxs++;\n         }\n         return false;\n     }\n \n-    if (nBlockSigOps + iter->GetSigOpCount() >= MAX_BLOCK_SIGOPS) {\n+    if (fNeedSizeAccounting) {\n+        if (nBlockSize + ::GetSerializeSize(iter->GetTx(), SER_NETWORK, PROTOCOL_VERSION) >= nBlockMaxSize) {\n+            if (nBlockSize >  nBlockMaxSize - 100 || lastFewTxs > 50) {\n+                 blockFinished = true;\n+                 return false;\n+            }\n+            if (nBlockSize > nBlockMaxSize - 1000) {\n+                lastFewTxs++;\n+            }\n+            return false;\n+        }\n+    }\n+\n+    if (nBlockSigOpsCost + iter->GetSigOpCost() >= MAX_BLOCK_SIGOPS_COST) {\n         // If the block has room for no more sig ops then\n         // flag that the block is finished\n-        if (nBlockSigOps > MAX_BLOCK_SIGOPS - 2) {\n+        if (nBlockSigOpsCost > MAX_BLOCK_SIGOPS_COST - 8) {\n             blockFinished = true;\n             return false;\n         }\n@@ -264,10 +308,13 @@ void BlockAssembler::AddToBlock(CTxMemPool::txiter iter)\n {\n     pblock->vtx.push_back(iter->GetTx());\n     pblocktemplate->vTxFees.push_back(iter->GetFee());\n-    pblocktemplate->vTxSigOps.push_back(iter->GetSigOpCount());\n-    nBlockSize += iter->GetTxSize();\n+    pblocktemplate->vTxSigOpsCost.push_back(iter->GetSigOpCost());\n+    if (fNeedSizeAccounting) {\n+        nBlockSize += ::GetSerializeSize(iter->GetTx(), SER_NETWORK, PROTOCOL_VERSION);\n+    }\n+    nBlockCost += iter->GetTxCost();\n     ++nBlockTx;\n-    nBlockSigOps += iter->GetSigOpCount();\n+    nBlockSigOpsCost += iter->GetSigOpCost();\n     nFees += iter->GetFee();\n     inBlock.insert(iter);\n \n@@ -358,7 +405,7 @@ void BlockAssembler::UpdatePackagesForAdded(const CTxMemPool::setEntries& alread\n                 CTxMemPoolModifiedEntry modEntry(desc);\n                 modEntry.nSizeWithAncestors -= it->GetTxSize();\n                 modEntry.nModFeesWithAncestors -= it->GetModifiedFee();\n-                modEntry.nSigOpCountWithAncestors -= it->GetSigOpCount();\n+                modEntry.nSigOpCostWithAncestors -= it->GetSigOpCost();\n                 mapModifiedTx.insert(modEntry);\n             } else {\n                 mapModifiedTx.modify(mit, update_for_parent_inclusion(it));\n@@ -460,19 +507,19 @@ void BlockAssembler::addPackageTxs()\n \n         uint64_t packageSize = iter->GetSizeWithAncestors();\n         CAmount packageFees = iter->GetModFeesWithAncestors();\n-        unsigned int packageSigOps = iter->GetSigOpCountWithAncestors();\n+        int64_t packageSigOpsCost = iter->GetSigOpCostWithAncestors();\n         if (fUsingModified) {\n             packageSize = modit->nSizeWithAncestors;\n             packageFees = modit->nModFeesWithAncestors;\n-            packageSigOps = modit->nSigOpCountWithAncestors;\n+            packageSigOpsCost = modit->nSigOpCostWithAncestors;\n         }\n \n-        if (packageFees < ::minRelayTxFee.GetFee(packageSize) && nBlockSize >= nBlockMinSize) {\n+        if (packageFees < ::minRelayTxFee.GetFee(packageSize)) {\n             // Everything else we might consider has a lower fee rate\n             return;\n         }\n \n-        if (!TestPackage(packageSize, packageSigOps)) {\n+        if (!TestPackage(packageSize, packageSigOpsCost)) {\n             if (fUsingModified) {\n                 // Since we always look at the best entry in mapModifiedTx,\n                 // we must erase failed entries so that we can consider the\n@@ -526,6 +573,8 @@ void BlockAssembler::addPriorityTxs()\n         return;\n     }\n \n+    fNeedSizeAccounting = true;\n+\n     // This vector will be sorted into a priority queue:\n     vector<TxCoinAgePriority> vecPriority;\n     TxCoinAgePriorityCompare pricomparer;"
      },
      {
        "sha": "b303a8fa3ceb7dcf7d891116adab0c96e5dbb881",
        "filename": "src/miner.h",
        "status": "modified",
        "additions": 9,
        "deletions": 7,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b/src/miner.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b/src/miner.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.h?ref=2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b",
        "patch": "@@ -28,7 +28,7 @@ struct CBlockTemplate\n {\n     CBlock block;\n     std::vector<CAmount> vTxFees;\n-    std::vector<int64_t> vTxSigOps;\n+    std::vector<int64_t> vTxSigOpsCost;\n     std::vector<unsigned char> vchCoinbaseCommitment;\n };\n \n@@ -40,13 +40,13 @@ struct CTxMemPoolModifiedEntry {\n         iter = entry;\n         nSizeWithAncestors = entry->GetSizeWithAncestors();\n         nModFeesWithAncestors = entry->GetModFeesWithAncestors();\n-        nSigOpCountWithAncestors = entry->GetSigOpCountWithAncestors();\n+        nSigOpCostWithAncestors = entry->GetSigOpCostWithAncestors();\n     }\n \n     CTxMemPool::txiter iter;\n     uint64_t nSizeWithAncestors;\n     CAmount nModFeesWithAncestors;\n-    unsigned int nSigOpCountWithAncestors;\n+    int64_t nSigOpCostWithAncestors;\n };\n \n /** Comparator for CTxMemPool::txiter objects.\n@@ -124,7 +124,7 @@ struct update_for_parent_inclusion\n     {\n         e.nModFeesWithAncestors -= iter->GetFee();\n         e.nSizeWithAncestors -= iter->GetTxSize();\n-        e.nSigOpCountWithAncestors -= iter->GetSigOpCount();\n+        e.nSigOpCostWithAncestors -= iter->GetSigOpCost();\n     }\n \n     CTxMemPool::txiter iter;\n@@ -141,12 +141,14 @@ class BlockAssembler\n \n     // Configuration parameters for the block size\n     bool fIncludeWitness;\n-    unsigned int nBlockMaxSize, nBlockMinSize;\n+    unsigned int nBlockMaxCost, nBlockMaxSize, nBlockMinSize;\n+    bool fNeedSizeAccounting;\n \n     // Information on the current status of the block\n+    uint64_t nBlockCost;\n     uint64_t nBlockSize;\n     uint64_t nBlockTx;\n-    unsigned int nBlockSigOps;\n+    uint64_t nBlockSigOpsCost;\n     CAmount nFees;\n     CTxMemPool::setEntries inBlock;\n \n@@ -189,7 +191,7 @@ class BlockAssembler\n     /** Remove confirmed (inBlock) entries from given set */\n     void onlyUnconfirmed(CTxMemPool::setEntries& testSet);\n     /** Test if a new package would \"fit\" in the block */\n-    bool TestPackage(uint64_t packageSize, unsigned int packageSigOps);\n+    bool TestPackage(uint64_t packageSize, int64_t packageSigOpsCost);\n     /** Test if a set of transactions are all final */\n     bool TestPackageFinality(const CTxMemPool::setEntries& package);\n     /** Return true if given transaction from mapTx has already been evaluated,"
      },
      {
        "sha": "4cbc43e4d842587f5013be33a14783308640ce6c",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b",
        "patch": "@@ -2182,7 +2182,7 @@ void CNode::RecordBytesSent(uint64_t bytes)\n void CNode::SetMaxOutboundTarget(uint64_t limit)\n {\n     LOCK(cs_totalBytesSent);\n-    uint64_t recommendedMinimum = (nMaxOutboundTimeframe / 600) * MAX_BLOCK_SIZE;\n+    uint64_t recommendedMinimum = (nMaxOutboundTimeframe / 600) * MAX_BLOCK_SERIALIZED_SIZE;\n     nMaxOutboundLimit = limit;\n \n     if (limit > 0 && limit < recommendedMinimum)\n@@ -2237,7 +2237,7 @@ bool CNode::OutboundTargetReached(bool historicalBlockServingLimit)\n     {\n         // keep a large enough buffer to at least relay each block once\n         uint64_t timeLeftInCycle = GetMaxOutboundTimeLeftInCycle();\n-        uint64_t buffer = timeLeftInCycle / 600 * MAX_BLOCK_SIZE;\n+        uint64_t buffer = timeLeftInCycle / 600 * MAX_BLOCK_SERIALIZED_SIZE;\n         if (buffer >= nMaxOutboundLimit || nMaxOutboundTotalBytesSentInCycle >= nMaxOutboundLimit - buffer)\n             return true;\n     }"
      },
      {
        "sha": "41315fc9b9fcc7af818f44cd16f6b6712e981c73",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b",
        "patch": "@@ -45,8 +45,8 @@ static const int TIMEOUT_INTERVAL = 20 * 60;\n static const unsigned int MAX_INV_SZ = 50000;\n /** The maximum number of new addresses to accumulate before announcing. */\n static const unsigned int MAX_ADDR_TO_SEND = 1000;\n-/** Maximum length of incoming protocol messages (no message over 2 MiB is currently acceptable). */\n-static const unsigned int MAX_PROTOCOL_MESSAGE_LENGTH = 2 * 1024 * 1024;\n+/** Maximum length of incoming protocol messages (no message over 4 MB is currently acceptable). */\n+static const unsigned int MAX_PROTOCOL_MESSAGE_LENGTH = 4 * 1000 * 1000;\n /** Maximum length of strSubVer in `version` message */\n static const unsigned int MAX_SUBVERSION_LENGTH = 256;\n /** -listen default */"
      },
      {
        "sha": "f2148bfe1057de09c3b3bc8c27b6dc6628eebe85",
        "filename": "src/policy/policy.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 2,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b/src/policy/policy.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b/src/policy/policy.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/policy.cpp?ref=2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b",
        "patch": "@@ -64,8 +64,8 @@ bool IsStandardTx(const CTransaction& tx, std::string& reason)\n     // almost as much to process as they cost the sender in fees, because\n     // computing signature hashes is O(ninputs*txsize). Limiting transactions\n     // to MAX_STANDARD_TX_SIZE mitigates CPU exhaustion attacks.\n-    unsigned int sz = tx.GetSerializeSize(SER_NETWORK, CTransaction::CURRENT_VERSION);\n-    if (sz >= MAX_STANDARD_TX_SIZE) {\n+    unsigned int sz = GetTransactionCost(tx);\n+    if (sz >= MAX_STANDARD_TX_COST) {\n         reason = \"tx-size\";\n         return false;\n     }\n@@ -150,3 +150,13 @@ bool AreInputsStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)\n \n     return true;\n }\n+\n+int64_t GetVirtualTransactionSize(int64_t nCost)\n+{\n+    return (nCost + WITNESS_SCALE_FACTOR - 1) / WITNESS_SCALE_FACTOR;\n+}\n+\n+int64_t GetVirtualTransactionSize(const CTransaction& tx)\n+{\n+    return GetVirtualTransactionSize(GetTransactionCost(tx));\n+}"
      },
      {
        "sha": "fefb562ff9318b77887aa5423e809161b3d1dcc3",
        "filename": "src/policy/policy.h",
        "status": "modified",
        "additions": 8,
        "deletions": 2,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b/src/policy/policy.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b/src/policy/policy.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/policy.h?ref=2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b",
        "patch": "@@ -19,12 +19,14 @@ static const unsigned int DEFAULT_BLOCK_MAX_SIZE = 750000;\n static const unsigned int DEFAULT_BLOCK_MIN_SIZE = 0;\n /** Default for -blockprioritysize, maximum space for zero/low-fee transactions **/\n static const unsigned int DEFAULT_BLOCK_PRIORITY_SIZE = 0;\n+/** Default for -blockmaxcost, which control the range of block costs the mining code will create **/\n+static const unsigned int DEFAULT_BLOCK_MAX_COST = 3000000;\n /** The maximum size for transactions we're willing to relay/mine */\n-static const unsigned int MAX_STANDARD_TX_SIZE = 100000;\n+static const unsigned int MAX_STANDARD_TX_COST = 400000;\n /** Maximum number of signature check operations in an IsStandard() P2SH script */\n static const unsigned int MAX_P2SH_SIGOPS = 15;\n /** The maximum number of sigops we're willing to relay/mine in a single tx */\n-static const unsigned int MAX_STANDARD_TX_SIGOPS = MAX_BLOCK_SIGOPS/5;\n+static const unsigned int MAX_STANDARD_TX_SIGOPS_COST = MAX_BLOCK_SIGOPS_COST/5;\n /** Default for -maxmempool, maximum megabytes of mempool memory usage */\n static const unsigned int DEFAULT_MAX_MEMPOOL_SIZE = 300;\n /**\n@@ -65,4 +67,8 @@ bool IsStandardTx(const CTransaction& tx, std::string& reason);\n      */\n bool AreInputsStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs);\n \n+/** Compute the virtual transaction size (cost reinterpreted as bytes). */\n+int64_t GetVirtualTransactionSize(int64_t nCost);\n+int64_t GetVirtualTransactionSize(const CTransaction& tx);\n+\n #endif // BITCOIN_POLICY_POLICY_H"
      },
      {
        "sha": "df900388f2678129b5e17c78498756c46c456e43",
        "filename": "src/primitives/block.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 0,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b/src/primitives/block.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b/src/primitives/block.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/primitives/block.cpp?ref=2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b",
        "patch": "@@ -31,3 +31,12 @@ std::string CBlock::ToString() const\n     }\n     return s.str();\n }\n+\n+int64_t GetBlockCost(const CBlock& block)\n+{\n+    // This implements the cost = (stripped_size * 4) + witness_size formula,\n+    // using only serialization with and without witness data. As witness_size\n+    // is equal to total_size - stripped_size, this formula is identical to:\n+    // cost = (stripped_size * 3) + total_size.\n+    return ::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * (WITNESS_SCALE_FACTOR - 1) + ::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION);\n+}"
      },
      {
        "sha": "e2a309e63d821df2ea86973e057072ff6f3aede8",
        "filename": "src/primitives/block.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b/src/primitives/block.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b/src/primitives/block.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/primitives/block.h?ref=2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b",
        "patch": "@@ -154,4 +154,7 @@ struct CBlockLocator\n     }\n };\n \n+/** Compute the consensus-critical block cost (see BIP 141). */\n+int64_t GetBlockCost(const CBlock& tx);\n+\n #endif // BITCOIN_PRIMITIVES_BLOCK_H"
      },
      {
        "sha": "7f10409c053978f9d8ceea37e5d0e9f499b571e4",
        "filename": "src/primitives/transaction.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 1,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b/src/primitives/transaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b/src/primitives/transaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/primitives/transaction.cpp?ref=2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b",
        "patch": "@@ -121,7 +121,7 @@ unsigned int CTransaction::CalculateModifiedSize(unsigned int nTxSize) const\n     // Providing any more cleanup incentive than making additional inputs free would\n     // risk encouraging people to create junk outputs to redeem later.\n     if (nTxSize == 0)\n-        nTxSize = ::GetSerializeSize(*this, SER_NETWORK, PROTOCOL_VERSION);\n+        nTxSize = (GetTransactionCost(*this) + WITNESS_SCALE_FACTOR - 1) / WITNESS_SCALE_FACTOR;\n     for (std::vector<CTxIn>::const_iterator it(vin.begin()); it != vin.end(); ++it)\n     {\n         unsigned int offset = 41U + std::min(110U, (unsigned int)it->scriptSig.size());\n@@ -148,3 +148,8 @@ std::string CTransaction::ToString() const\n         str += \"    \" + vout[i].ToString() + \"\\n\";\n     return str;\n }\n+\n+int64_t GetTransactionCost(const CTransaction& tx)\n+{\n+    return ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * (WITNESS_SCALE_FACTOR -1) + ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);\n+}"
      },
      {
        "sha": "e87ad90f0d498047743d7229ad33906daa391b55",
        "filename": "src/primitives/transaction.h",
        "status": "modified",
        "additions": 24,
        "deletions": 4,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b/src/primitives/transaction.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b/src/primitives/transaction.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/primitives/transaction.h?ref=2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b",
        "patch": "@@ -13,6 +13,8 @@\n \n static const int SERIALIZE_TRANSACTION_NO_WITNESS = 0x40000000;\n \n+static const int WITNESS_SCALE_FACTOR = 4;\n+\n /** An outpoint - a combination of a transaction hash and an index n into its vout */\n class COutPoint\n {\n@@ -166,15 +168,30 @@ class CTxOut\n         // which has units satoshis-per-kilobyte.\n         // If you'd pay more than 1/3 in fees\n         // to spend something, then we consider it dust.\n-        // A typical spendable txout is 34 bytes big, and will\n+        // A typical spendable non-segwit txout is 34 bytes big, and will\n         // need a CTxIn of at least 148 bytes to spend:\n         // so dust is a spendable txout less than\n-        // 546*minRelayTxFee/1000 (in satoshis)\n+        // 546*minRelayTxFee/1000 (in satoshis).\n+        // A typical spendable segwit txout is 31 bytes big, and will\n+        // need a CTxIn of at least 67 bytes to spend:\n+        // so dust is a spendable txout less than\n+        // 294*minRelayTxFee/1000 (in satoshis).\n         if (scriptPubKey.IsUnspendable())\n             return 0;\n \n-        size_t nSize = GetSerializeSize(SER_DISK,0)+148u;\n-        return 3*minRelayTxFee.GetFee(nSize);\n+        size_t nSize = GetSerializeSize(SER_DISK, 0);\n+        int witnessversion = 0;\n+        std::vector<unsigned char> witnessprogram;\n+\n+        if (scriptPubKey.IsWitnessProgram(witnessversion, witnessprogram)) {\n+            // sum the sizes of the parts of a transaction input\n+            // with 75% segwit discount applied to the script size.\n+            nSize += (32 + 4 + 1 + (107 / WITNESS_SCALE_FACTOR) + 4);\n+        } else {\n+            nSize += (32 + 4 + 1 + 107 + 4); // the 148 mentioned above\n+        }\n+\n+        return 3 * minRelayTxFee.GetFee(nSize);\n     }\n \n     bool IsDust(const CFeeRate &minRelayTxFee) const\n@@ -442,4 +459,7 @@ struct CMutableTransaction\n     uint256 GetHash() const;\n };\n \n+/** Compute the cost of a transaction, as defined by BIP 141 */\n+int64_t GetTransactionCost(const CTransaction &tx);\n+\n #endif // BITCOIN_PRIMITIVES_TRANSACTION_H"
      },
      {
        "sha": "43ba4edd78c19a18ed467a22356be8810e04eee1",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b",
        "patch": "@@ -101,6 +101,7 @@ UniValue blockToJSON(const CBlock& block, const CBlockIndex* blockindex, bool tx\n     result.push_back(Pair(\"confirmations\", confirmations));\n     result.push_back(Pair(\"strippedsize\", (int)::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS)));\n     result.push_back(Pair(\"size\", (int)::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION)));\n+    result.push_back(Pair(\"cost\", (int)::GetBlockCost(block)));\n     result.push_back(Pair(\"height\", blockindex->nHeight));\n     result.push_back(Pair(\"version\", block.nVersion));\n     result.push_back(Pair(\"versionHex\", strprintf(\"%08x\", block.nVersion)));\n@@ -560,6 +561,7 @@ UniValue getblock(const UniValue& params, bool fHelp)\n             \"  \\\"confirmations\\\" : n,   (numeric) The number of confirmations, or -1 if the block is not on the main chain\\n\"\n             \"  \\\"size\\\" : n,            (numeric) The block size\\n\"\n             \"  \\\"strippedsize\\\" : n,    (numeric) The block size excluding witness data\\n\"\n+            \"  \\\"cost\\\" : n             (numeric) The block cost\\n\"\n             \"  \\\"height\\\" : n,          (numeric) The block height or index\\n\"\n             \"  \\\"version\\\" : n,         (numeric) The block version\\n\"\n             \"  \\\"versionHex\\\" : \\\"00000000\\\", (string) The block version formatted in hexadecimal\\n\""
      },
      {
        "sha": "4c4e5997818ef11dd7b47020264e4ff2b7f97d63",
        "filename": "src/rpc/mining.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 6,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b/src/rpc/mining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b/src/rpc/mining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/mining.cpp?ref=2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b",
        "patch": "@@ -224,6 +224,7 @@ UniValue getmininginfo(const UniValue& params, bool fHelp)\n             \"{\\n\"\n             \"  \\\"blocks\\\": nnn,             (numeric) The current block\\n\"\n             \"  \\\"currentblocksize\\\": nnn,   (numeric) The last block size\\n\"\n+            \"  \\\"currentblockcost\\\": nnn,   (numeric) The last block cost\\n\"\n             \"  \\\"currentblocktx\\\": nnn,     (numeric) The last block transaction\\n\"\n             \"  \\\"difficulty\\\": xxx.xxxxx    (numeric) The current difficulty\\n\"\n             \"  \\\"errors\\\": \\\"...\\\"          (string) Current errors\\n\"\n@@ -242,6 +243,7 @@ UniValue getmininginfo(const UniValue& params, bool fHelp)\n     UniValue obj(UniValue::VOBJ);\n     obj.push_back(Pair(\"blocks\",           (int)chainActive.Height()));\n     obj.push_back(Pair(\"currentblocksize\", (uint64_t)nLastBlockSize));\n+    obj.push_back(Pair(\"currentblockcost\", (uint64_t)nLastBlockCost));\n     obj.push_back(Pair(\"currentblocktx\",   (uint64_t)nLastBlockTx));\n     obj.push_back(Pair(\"difficulty\",       (double)GetDifficulty()));\n     obj.push_back(Pair(\"errors\",           GetWarnings(\"statusbar\")));\n@@ -349,13 +351,14 @@ UniValue getblocktemplate(const UniValue& params, bool fHelp)\n             \"      {\\n\"\n             \"         \\\"data\\\" : \\\"xxxx\\\",          (string) transaction data encoded in hexadecimal (byte-for-byte)\\n\"\n             \"         \\\"txid\\\" : \\\"xxxx\\\",          (string) transaction id encoded in little-endian hexadecimal\\n\"\n-            \"         \\\"hash\\\" : \\\"xxxx\\\",          (string) hash encoded in little-endian hexadecimal\\n\"\n+            \"         \\\"hash\\\" : \\\"xxxx\\\",          (string) hash encoded in little-endian hexadecimal (including witness data)\\n\"\n             \"         \\\"depends\\\" : [              (array) array of numbers \\n\"\n             \"             n                        (numeric) transactions before this one (by 1-based index in 'transactions' list) that must be present in the final block if this one is\\n\"\n             \"             ,...\\n\"\n             \"         ],\\n\"\n             \"         \\\"fee\\\": n,                   (numeric) difference in value between transaction inputs and outputs (in Satoshis); for coinbase transactions, this is a negative Number of the total collected block fees (ie, not including the block subsidy); if key is not present, fee is unknown and clients MUST NOT assume there isn't one\\n\"\n-            \"         \\\"sigops\\\" : n,               (numeric) total number of SigOps, as counted for purposes of block limits; if key is not present, sigop count is unknown and clients MUST NOT assume there aren't any\\n\"\n+            \"         \\\"sigops\\\" : n,               (numeric) total SigOps cost, as counted for purposes of block limits; if key is not present, sigop cost is unknown and clients MUST NOT assume it is zero\\n\"\n+            \"         \\\"cost\\\" : n,                 (numeric) total transaction size cost, as counted for purposes of block limits\\n\"\n             \"         \\\"required\\\" : true|false     (boolean) if provided and true, this transaction must be in the final block\\n\"\n             \"      }\\n\"\n             \"      ,...\\n\"\n@@ -372,8 +375,9 @@ UniValue getblocktemplate(const UniValue& params, bool fHelp)\n             \"     ,...\\n\"\n             \"  ],\\n\"\n             \"  \\\"noncerange\\\" : \\\"00000000ffffffff\\\",   (string) A range of valid nonces\\n\"\n-            \"  \\\"sigoplimit\\\" : n,                 (numeric) limit of sigops in blocks\\n\"\n+            \"  \\\"sigoplimit\\\" : n,                 (numeric) cost limit of sigops in blocks\\n\"\n             \"  \\\"sizelimit\\\" : n,                  (numeric) limit of block size\\n\"\n+            \"  \\\"costlimit\\\" : n,                  (numeric) limit of block cost\\n\"\n             \"  \\\"curtime\\\" : ttt,                  (numeric) current timestamp in seconds since epoch (Jan 1 1970 GMT)\\n\"\n             \"  \\\"bits\\\" : \\\"xxx\\\",                 (string) compressed target of next block\\n\"\n             \"  \\\"height\\\" : n                      (numeric) The height of the next block\\n\"\n@@ -570,7 +574,8 @@ UniValue getblocktemplate(const UniValue& params, bool fHelp)\n \n         int index_in_template = i - 1;\n         entry.push_back(Pair(\"fee\", pblocktemplate->vTxFees[index_in_template]));\n-        entry.push_back(Pair(\"sigops\", pblocktemplate->vTxSigOps[index_in_template]));\n+        entry.push_back(Pair(\"sigops\", pblocktemplate->vTxSigOpsCost[index_in_template]));\n+        entry.push_back(Pair(\"cost\", GetTransactionCost(tx)));\n \n         transactions.push_back(entry);\n     }\n@@ -652,8 +657,9 @@ UniValue getblocktemplate(const UniValue& params, bool fHelp)\n     result.push_back(Pair(\"mintime\", (int64_t)pindexPrev->GetMedianTimePast()+1));\n     result.push_back(Pair(\"mutable\", aMutable));\n     result.push_back(Pair(\"noncerange\", \"00000000ffffffff\"));\n-    result.push_back(Pair(\"sigoplimit\", (int64_t)MAX_BLOCK_SIGOPS));\n-    result.push_back(Pair(\"sizelimit\", (int64_t)MAX_BLOCK_SIZE));\n+    result.push_back(Pair(\"sigoplimit\", (int64_t)MAX_BLOCK_SIGOPS_COST));\n+    result.push_back(Pair(\"sizelimit\", (int64_t)MAX_BLOCK_SERIALIZED_SIZE));\n+    result.push_back(Pair(\"costlimit\", (int64_t)MAX_BLOCK_COST));\n     result.push_back(Pair(\"curtime\", pblock->GetBlockTime()));\n     result.push_back(Pair(\"bits\", strprintf(\"%08x\", pblock->nBits)));\n     result.push_back(Pair(\"height\", (int64_t)(pindexPrev->nHeight+1)));"
      },
      {
        "sha": "b36179943f4db37d25e379c217ce35506cd60845",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b",
        "patch": "@@ -64,6 +64,7 @@ void TxToJSON(const CTransaction& tx, const uint256 hashBlock, UniValue& entry)\n     entry.push_back(Pair(\"txid\", tx.GetHash().GetHex()));\n     entry.push_back(Pair(\"hash\", tx.GetWitnessHash().GetHex()));\n     entry.push_back(Pair(\"size\", (int)::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION)));\n+    entry.push_back(Pair(\"vsize\", (int)::GetVirtualTransactionSize(tx)));\n     entry.push_back(Pair(\"version\", tx.nVersion));\n     entry.push_back(Pair(\"locktime\", (int64_t)tx.nLockTime));\n \n@@ -150,6 +151,7 @@ UniValue getrawtransaction(const UniValue& params, bool fHelp)\n             \"  \\\"txid\\\" : \\\"id\\\",        (string) The transaction id (same as provided)\\n\"\n             \"  \\\"hash\\\" : \\\"id\\\",        (string) The transaction hash (differs from txid for witness transactions)\\n\"\n             \"  \\\"size\\\" : n,             (numeric) The serialized transaction size\\n\"\n+            \"  \\\"vsize\\\" : n,            (numeric) The virtual transaction size (differs from size for witness transactions)\\n\"\n             \"  \\\"version\\\" : n,          (numeric) The version\\n\"\n             \"  \\\"locktime\\\" : ttt,       (numeric) The lock time\\n\"\n             \"  \\\"vin\\\" : [               (array of json objects)\\n\"\n@@ -461,6 +463,7 @@ UniValue decoderawtransaction(const UniValue& params, bool fHelp)\n             \"  \\\"txid\\\" : \\\"id\\\",        (string) The transaction id\\n\"\n             \"  \\\"hash\\\" : \\\"id\\\",        (string) The transaction hash (differs from txid for witness transactions)\\n\"\n             \"  \\\"size\\\" : n,             (numeric) The transaction size\\n\"\n+            \"  \\\"vsize\\\" : n,            (numeric) The virtual transaction size (differs from size for witness transactions)\\n\"\n             \"  \\\"version\\\" : n,          (numeric) The version\\n\"\n             \"  \\\"locktime\\\" : ttt,       (numeric) The lock time\\n\"\n             \"  \\\"vin\\\" : [               (array of json objects)\\n\""
      },
      {
        "sha": "bc027e9f0c11338dc1c35fc268084e9e1cbf65b9",
        "filename": "src/script/interpreter.cpp",
        "status": "modified",
        "additions": 47,
        "deletions": 0,
        "changes": 47,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b/src/script/interpreter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b/src/script/interpreter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.cpp?ref=2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b",
        "patch": "@@ -1470,3 +1470,50 @@ bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const C\n \n     return set_success(serror);\n }\n+\n+size_t static WitnessSigOps(int witversion, const std::vector<unsigned char>& witprogram, const CScriptWitness& witness, int flags)\n+{\n+    if (witversion == 0) {\n+        if (witprogram.size() == 20)\n+            return 1;\n+\n+        if (witprogram.size() == 32 && witness.stack.size() > 0) {\n+            CScript subscript(witness.stack.back().begin(), witness.stack.back().end());\n+            return subscript.GetSigOpCount(true);\n+        }\n+    }\n+\n+    // Future flags may be implemented here.\n+    return 0;\n+}\n+\n+size_t CountWitnessSigOps(const CScript& scriptSig, const CScript& scriptPubKey, const CScriptWitness* witness, unsigned int flags)\n+{\n+    static const CScriptWitness witnessEmpty;\n+\n+    if ((flags & SCRIPT_VERIFY_WITNESS) == 0) {\n+        return 0;\n+    }\n+    assert((flags & SCRIPT_VERIFY_P2SH) != 0);\n+\n+    int witnessversion;\n+    std::vector<unsigned char> witnessprogram;\n+    if (scriptPubKey.IsWitnessProgram(witnessversion, witnessprogram)) {\n+        return WitnessSigOps(witnessversion, witnessprogram, witness ? *witness : witnessEmpty, flags);\n+    }\n+\n+    if (scriptPubKey.IsPayToScriptHash() && scriptSig.IsPushOnly()) {\n+        CScript::const_iterator pc = scriptSig.begin();\n+        vector<unsigned char> data;\n+        while (pc < scriptSig.end()) {\n+            opcodetype opcode;\n+            scriptSig.GetOp(pc, opcode, data);\n+        }\n+        CScript subscript(data.begin(), data.end());\n+        if (subscript.IsWitnessProgram(witnessversion, witnessprogram)) {\n+            return WitnessSigOps(witnessversion, witnessprogram, witness ? *witness : witnessEmpty, flags);\n+        }\n+    }\n+\n+    return 0;\n+}"
      },
      {
        "sha": "bd2f21166368a98a22795b9d195b320f979d1c64",
        "filename": "src/script/interpreter.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b/src/script/interpreter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b/src/script/interpreter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.h?ref=2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b",
        "patch": "@@ -156,4 +156,6 @@ class MutableTransactionSignatureChecker : public TransactionSignatureChecker\n bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript& script, unsigned int flags, const BaseSignatureChecker& checker, SigVersion sigversion, ScriptError* error = NULL);\n bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CScriptWitness* witness, unsigned int flags, const BaseSignatureChecker& checker, ScriptError* serror = NULL);\n \n+size_t CountWitnessSigOps(const CScript& scriptSig, const CScript& scriptPubKey, const CScriptWitness* witness, unsigned int flags);\n+\n #endif // BITCOIN_SCRIPT_INTERPRETER_H"
      },
      {
        "sha": "033a50f94f578b2ef82f076d7d5b6505eda57362",
        "filename": "src/test/mempool_tests.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 5,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b/src/test/mempool_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b/src/test/mempool_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/mempool_tests.cpp?ref=2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b",
        "patch": "@@ -2,6 +2,7 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n+#include \"policy/policy.h\"\n #include \"txmempool.h\"\n #include \"util.h\"\n \n@@ -336,7 +337,7 @@ BOOST_AUTO_TEST_CASE(MempoolAncestorIndexingTest)\n     tx2.vout[0].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n     tx2.vout[0].nValue = 2 * COIN;\n     pool.addUnchecked(tx2.GetHash(), entry.Fee(20000LL).Priority(9.0).FromTx(tx2));\n-    uint64_t tx2Size = ::GetSerializeSize(tx2, SER_NETWORK, PROTOCOL_VERSION);\n+    uint64_t tx2Size = GetVirtualTransactionSize(tx2);\n \n     /* lowest fee */\n     CMutableTransaction tx3 = CMutableTransaction();\n@@ -384,7 +385,7 @@ BOOST_AUTO_TEST_CASE(MempoolAncestorIndexingTest)\n     tx6.vout.resize(1);\n     tx6.vout[0].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n     tx6.vout[0].nValue = 20 * COIN;\n-    uint64_t tx6Size = ::GetSerializeSize(tx6, SER_NETWORK, PROTOCOL_VERSION);\n+    uint64_t tx6Size = GetVirtualTransactionSize(tx6);\n \n     pool.addUnchecked(tx6.GetHash(), entry.Fee(0LL).FromTx(tx6));\n     BOOST_CHECK_EQUAL(pool.size(), 6);\n@@ -398,7 +399,7 @@ BOOST_AUTO_TEST_CASE(MempoolAncestorIndexingTest)\n     tx7.vout.resize(1);\n     tx7.vout[0].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n     tx7.vout[0].nValue = 10 * COIN;\n-    uint64_t tx7Size = ::GetSerializeSize(tx7, SER_NETWORK, PROTOCOL_VERSION);\n+    uint64_t tx7Size = GetVirtualTransactionSize(tx7);\n \n     /* set the fee to just below tx2's feerate when including ancestor */\n     CAmount fee = (20000/tx2Size)*(tx7Size + tx6Size) - 1;\n@@ -467,12 +468,12 @@ BOOST_AUTO_TEST_CASE(MempoolSizeLimitTest)\n     BOOST_CHECK(pool.exists(tx2.GetHash()));\n     BOOST_CHECK(pool.exists(tx3.GetHash()));\n \n-    pool.TrimToSize(::GetSerializeSize(CTransaction(tx1), SER_NETWORK, PROTOCOL_VERSION)); // mempool is limited to tx1's size in memory usage, so nothing fits\n+    pool.TrimToSize(GetVirtualTransactionSize(tx1)); // mempool is limited to tx1's size in memory usage, so nothing fits\n     BOOST_CHECK(!pool.exists(tx1.GetHash()));\n     BOOST_CHECK(!pool.exists(tx2.GetHash()));\n     BOOST_CHECK(!pool.exists(tx3.GetHash()));\n \n-    CFeeRate maxFeeRateRemoved(25000, ::GetSerializeSize(CTransaction(tx3), SER_NETWORK, PROTOCOL_VERSION) + ::GetSerializeSize(CTransaction(tx2), SER_NETWORK, PROTOCOL_VERSION));\n+    CFeeRate maxFeeRateRemoved(25000, GetVirtualTransactionSize(tx3) + GetVirtualTransactionSize(tx2));\n     BOOST_CHECK_EQUAL(pool.GetMinFee(1).GetFeePerK(), maxFeeRateRemoved.GetFeePerK() + 1000);\n \n     CMutableTransaction tx4 = CMutableTransaction();"
      },
      {
        "sha": "fd581db52ea284bfa060d692adcdac421a34bc2c",
        "filename": "src/test/miner_tests.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b/src/test/miner_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b/src/test/miner_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/miner_tests.cpp?ref=2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b",
        "patch": "@@ -181,6 +181,9 @@ void TestPackageSelection(const CChainParams& chainparams, CScript scriptPubKey,\n // NOTE: These tests rely on CreateNewBlock doing its own self-validation!\n BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n {\n+    // Disable size accounting (CPFP does not support it)\n+    mapArgs[\"-blockmaxsize\"] = strprintf(\"%u\", MAX_BLOCK_SERIALIZED_SIZE);\n+\n     const CChainParams& chainparams = Params(CBaseChainParams::MAIN);\n     CScript scriptPubKey = CScript() << ParseHex(\"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f\") << OP_CHECKSIG;\n     CBlockTemplate *pblocktemplate;\n@@ -264,7 +267,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n         hash = tx.GetHash();\n         bool spendsCoinbase = (i == 0) ? true : false; // only first tx spends coinbase\n         // If we do set the # of sig ops in the CTxMemPoolEntry, template creation passes\n-        mempool.addUnchecked(hash, entry.Fee(LOWFEE).Time(GetTime()).SpendsCoinbase(spendsCoinbase).SigOps(20).FromTx(tx));\n+        mempool.addUnchecked(hash, entry.Fee(LOWFEE).Time(GetTime()).SpendsCoinbase(spendsCoinbase).SigOpsCost(80).FromTx(tx));\n         tx.vin[0].prevout.hash = hash;\n     }\n     BOOST_CHECK(pblocktemplate = BlockAssembler(chainparams).CreateNewBlock(scriptPubKey));"
      },
      {
        "sha": "5c902387f12143496e636d83cb221c8cd6b1d065",
        "filename": "src/test/policyestimator_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b/src/test/policyestimator_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b/src/test/policyestimator_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/policyestimator_tests.cpp?ref=2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b",
        "patch": "@@ -2,6 +2,7 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n+#include \"policy/policy.h\"\n #include \"policy/fees.h\"\n #include \"txmempool.h\"\n #include \"uint256.h\"\n@@ -50,7 +51,7 @@ BOOST_AUTO_TEST_CASE(BlockPolicyEstimates)\n     tx.vin[0].scriptSig = garbage;\n     tx.vout.resize(1);\n     tx.vout[0].nValue=0LL;\n-    CFeeRate baseRate(basefee, ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION));\n+    CFeeRate baseRate(basefee, GetVirtualTransactionSize(tx));\n \n     // Create a fake block\n     std::vector<CTransaction> block;"
      },
      {
        "sha": "856f9b842300cdfe0ff258c32f218dafa8fe80da",
        "filename": "src/test/test_bitcoin.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b/src/test/test_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b/src/test/test_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.cpp?ref=2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b",
        "patch": "@@ -136,7 +136,7 @@ CTxMemPoolEntry TestMemPoolEntryHelper::FromTx(CTransaction &txn, CTxMemPool *po\n     CAmount inChainValue = hasNoDependencies ? txn.GetValueOut() : 0;\n \n     return CTxMemPoolEntry(txn, nFee, nTime, dPriority, nHeight,\n-                           hasNoDependencies, inChainValue, spendsCoinbase, sigOpCount, lp);\n+                           hasNoDependencies, inChainValue, spendsCoinbase, sigOpCost, lp);\n }\n \n void Shutdown(void* parg)"
      },
      {
        "sha": "bc0d2fe316aa5e6517d0077d8e07575206340d04",
        "filename": "src/test/test_bitcoin.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b/src/test/test_bitcoin.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b/src/test/test_bitcoin.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.h?ref=2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b",
        "patch": "@@ -70,12 +70,12 @@ struct TestMemPoolEntryHelper\n     unsigned int nHeight;\n     bool hadNoDependencies;\n     bool spendsCoinbase;\n-    unsigned int sigOpCount;\n+    unsigned int sigOpCost;\n     LockPoints lp;\n \n     TestMemPoolEntryHelper() :\n         nFee(0), nTime(0), dPriority(0.0), nHeight(1),\n-        hadNoDependencies(false), spendsCoinbase(false), sigOpCount(1) { }\n+        hadNoDependencies(false), spendsCoinbase(false), sigOpCost(4) { }\n     \n     CTxMemPoolEntry FromTx(CMutableTransaction &tx, CTxMemPool *pool = NULL);\n     CTxMemPoolEntry FromTx(CTransaction &tx, CTxMemPool *pool = NULL);\n@@ -87,6 +87,6 @@ struct TestMemPoolEntryHelper\n     TestMemPoolEntryHelper &Height(unsigned int _height) { nHeight = _height; return *this; }\n     TestMemPoolEntryHelper &HadNoDependencies(bool _hnd) { hadNoDependencies = _hnd; return *this; }\n     TestMemPoolEntryHelper &SpendsCoinbase(bool _flag) { spendsCoinbase = _flag; return *this; }\n-    TestMemPoolEntryHelper &SigOps(unsigned int _sigops) { sigOpCount = _sigops; return *this; }\n+    TestMemPoolEntryHelper &SigOpsCost(unsigned int _sigopsCost) { sigOpCost = _sigopsCost; return *this; }\n };\n #endif"
      },
      {
        "sha": "a48a6d94659b57adac6407b6cdd7f0fadd0dcf49",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 25,
        "deletions": 19,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b",
        "patch": "@@ -9,6 +9,7 @@\n #include \"consensus/consensus.h\"\n #include \"consensus/validation.h\"\n #include \"main.h\"\n+#include \"policy/policy.h\"\n #include \"policy/fees.h\"\n #include \"streams.h\"\n #include \"timedata.h\"\n@@ -22,27 +23,27 @@ using namespace std;\n CTxMemPoolEntry::CTxMemPoolEntry(const CTransaction& _tx, const CAmount& _nFee,\n                                  int64_t _nTime, double _entryPriority, unsigned int _entryHeight,\n                                  bool poolHasNoInputsOf, CAmount _inChainInputValue,\n-                                 bool _spendsCoinbase, unsigned int _sigOps, LockPoints lp):\n+                                 bool _spendsCoinbase, int64_t _sigOpsCost, LockPoints lp):\n     tx(std::make_shared<CTransaction>(_tx)), nFee(_nFee), nTime(_nTime), entryPriority(_entryPriority), entryHeight(_entryHeight),\n     hadNoDependencies(poolHasNoInputsOf), inChainInputValue(_inChainInputValue),\n-    spendsCoinbase(_spendsCoinbase), sigOpCount(_sigOps), lockPoints(lp)\n+    spendsCoinbase(_spendsCoinbase), sigOpCost(_sigOpsCost), lockPoints(lp)\n {\n-    nTxSize = ::GetSerializeSize(_tx, SER_NETWORK, PROTOCOL_VERSION);\n-    nModSize = _tx.CalculateModifiedSize(nTxSize);\n+    nTxCost = GetTransactionCost(_tx);\n+    nModSize = _tx.CalculateModifiedSize(GetTxSize());\n     nUsageSize = RecursiveDynamicUsage(*tx) + memusage::DynamicUsage(tx);\n \n     nCountWithDescendants = 1;\n-    nSizeWithDescendants = nTxSize;\n+    nSizeWithDescendants = GetTxSize();\n     nModFeesWithDescendants = nFee;\n     CAmount nValueIn = _tx.GetValueOut()+nFee;\n     assert(inChainInputValue <= nValueIn);\n \n     feeDelta = 0;\n \n     nCountWithAncestors = 1;\n-    nSizeWithAncestors = nTxSize;\n+    nSizeWithAncestors = GetTxSize();\n     nModFeesWithAncestors = nFee;\n-    nSigOpCountWithAncestors = sigOpCount;\n+    nSigOpCostWithAncestors = sigOpCost;\n }\n \n CTxMemPoolEntry::CTxMemPoolEntry(const CTxMemPoolEntry& other)\n@@ -72,6 +73,11 @@ void CTxMemPoolEntry::UpdateLockPoints(const LockPoints& lp)\n     lockPoints = lp;\n }\n \n+size_t CTxMemPoolEntry::GetTxSize() const\n+{\n+    return GetVirtualTransactionSize(nTxCost);\n+}\n+\n // Update the given tx for any in-mempool descendants.\n // Assumes that setMemPoolChildren is correct for the given tx and all\n // descendants.\n@@ -111,7 +117,7 @@ void CTxMemPool::UpdateForDescendants(txiter updateIt, cacheMap &cachedDescendan\n             modifyCount++;\n             cachedDescendants[updateIt].insert(cit);\n             // Update ancestor state for each descendant\n-            mapTx.modify(cit, update_ancestor_state(updateIt->GetTxSize(), updateIt->GetModifiedFee(), 1, updateIt->GetSigOpCount()));\n+            mapTx.modify(cit, update_ancestor_state(updateIt->GetTxSize(), updateIt->GetModifiedFee(), 1, updateIt->GetSigOpCost()));\n         }\n     }\n     mapTx.modify(updateIt, update_descendant_state(modifySize, modifyFee, modifyCount));\n@@ -247,13 +253,13 @@ void CTxMemPool::UpdateEntryForAncestors(txiter it, const setEntries &setAncesto\n     int64_t updateCount = setAncestors.size();\n     int64_t updateSize = 0;\n     CAmount updateFee = 0;\n-    int updateSigOps = 0;\n+    int64_t updateSigOpsCost = 0;\n     BOOST_FOREACH(txiter ancestorIt, setAncestors) {\n         updateSize += ancestorIt->GetTxSize();\n         updateFee += ancestorIt->GetModifiedFee();\n-        updateSigOps += ancestorIt->GetSigOpCount();\n+        updateSigOpsCost += ancestorIt->GetSigOpCost();\n     }\n-    mapTx.modify(it, update_ancestor_state(updateSize, updateFee, updateCount, updateSigOps));\n+    mapTx.modify(it, update_ancestor_state(updateSize, updateFee, updateCount, updateSigOpsCost));\n }\n \n void CTxMemPool::UpdateChildrenForRemoval(txiter it)\n@@ -282,7 +288,7 @@ void CTxMemPool::UpdateForRemoveFromMempool(const setEntries &entriesToRemove, b\n             setDescendants.erase(removeIt); // don't update state for self\n             int64_t modifySize = -((int64_t)removeIt->GetTxSize());\n             CAmount modifyFee = -removeIt->GetModifiedFee();\n-            int modifySigOps = -removeIt->GetSigOpCount();\n+            int modifySigOps = -removeIt->GetSigOpCost();\n             BOOST_FOREACH(txiter dit, setDescendants) {\n                 mapTx.modify(dit, update_ancestor_state(modifySize, modifyFee, -1, modifySigOps));\n             }\n@@ -338,8 +344,8 @@ void CTxMemPoolEntry::UpdateAncestorState(int64_t modifySize, CAmount modifyFee,\n     nModFeesWithAncestors += modifyFee;\n     nCountWithAncestors += modifyCount;\n     assert(int64_t(nCountWithAncestors) > 0);\n-    nSigOpCountWithAncestors += modifySigOps;\n-    assert(int(nSigOpCountWithAncestors) >= 0);\n+    nSigOpCostWithAncestors += modifySigOps;\n+    assert(int(nSigOpCostWithAncestors) >= 0);\n }\n \n CTxMemPool::CTxMemPool(const CFeeRate& _minReasonableRelayFee) :\n@@ -666,7 +672,7 @@ void CTxMemPool::check(const CCoinsViewCache *pcoins) const\n         bool fDependsWait = false;\n         setEntries setParentCheck;\n         int64_t parentSizes = 0;\n-        unsigned int parentSigOpCount = 0;\n+        int64_t parentSigOpCost = 0;\n         BOOST_FOREACH(const CTxIn &txin, tx.vin) {\n             // Check that every mempool transaction's inputs refer to available coins, or other mempool tx's.\n             indexed_transaction_set::const_iterator it2 = mapTx.find(txin.prevout.hash);\n@@ -676,7 +682,7 @@ void CTxMemPool::check(const CCoinsViewCache *pcoins) const\n                 fDependsWait = true;\n                 if (setParentCheck.insert(it2).second) {\n                     parentSizes += it2->GetTxSize();\n-                    parentSigOpCount += it2->GetSigOpCount();\n+                    parentSigOpCost += it2->GetSigOpCost();\n                 }\n             } else {\n                 const CCoins* coins = pcoins->AccessCoins(txin.prevout.hash);\n@@ -698,17 +704,17 @@ void CTxMemPool::check(const CCoinsViewCache *pcoins) const\n         uint64_t nCountCheck = setAncestors.size() + 1;\n         uint64_t nSizeCheck = it->GetTxSize();\n         CAmount nFeesCheck = it->GetModifiedFee();\n-        unsigned int nSigOpCheck = it->GetSigOpCount();\n+        int64_t nSigOpCheck = it->GetSigOpCost();\n \n         BOOST_FOREACH(txiter ancestorIt, setAncestors) {\n             nSizeCheck += ancestorIt->GetTxSize();\n             nFeesCheck += ancestorIt->GetModifiedFee();\n-            nSigOpCheck += ancestorIt->GetSigOpCount();\n+            nSigOpCheck += ancestorIt->GetSigOpCost();\n         }\n \n         assert(it->GetCountWithAncestors() == nCountCheck);\n         assert(it->GetSizeWithAncestors() == nSizeCheck);\n-        assert(it->GetSigOpCountWithAncestors() == nSigOpCheck);\n+        assert(it->GetSigOpCostWithAncestors() == nSigOpCheck);\n         assert(it->GetModFeesWithAncestors() == nFeesCheck);\n \n         // Check children against mapNextTx"
      },
      {
        "sha": "e5a500e19d43300a38807e7839bc4e7113b74545",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 12,
        "deletions": 11,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b",
        "patch": "@@ -78,7 +78,7 @@ class CTxMemPoolEntry\n private:\n     std::shared_ptr<const CTransaction> tx;\n     CAmount nFee;              //!< Cached to avoid expensive parent-transaction lookups\n-    size_t nTxSize;            //!< ... and avoid recomputing tx size\n+    size_t nTxCost;            //!< ... and avoid recomputing tx cost (also used for GetTxSize())\n     size_t nModSize;           //!< ... and modified size for priority\n     size_t nUsageSize;         //!< ... and total memory usage\n     int64_t nTime;             //!< Local time when entering the mempool\n@@ -87,7 +87,7 @@ class CTxMemPoolEntry\n     bool hadNoDependencies;    //!< Not dependent on any other txs when it entered the mempool\n     CAmount inChainInputValue; //!< Sum of all txin values that are already in blockchain\n     bool spendsCoinbase;       //!< keep track of transactions that spend a coinbase\n-    unsigned int sigOpCount;   //!< Legacy sig ops plus P2SH sig op count\n+    int64_t sigOpCost;         //!< Total sigop cost\n     int64_t feeDelta;          //!< Used for determining the priority of the transaction for mining in a block\n     LockPoints lockPoints;     //!< Track the height and time at which tx was final\n \n@@ -104,13 +104,13 @@ class CTxMemPoolEntry\n     uint64_t nCountWithAncestors;\n     uint64_t nSizeWithAncestors;\n     CAmount nModFeesWithAncestors;\n-    unsigned int nSigOpCountWithAncestors;\n+    int64_t nSigOpCostWithAncestors;\n \n public:\n     CTxMemPoolEntry(const CTransaction& _tx, const CAmount& _nFee,\n                     int64_t _nTime, double _entryPriority, unsigned int _entryHeight,\n                     bool poolHasNoInputsOf, CAmount _inChainInputValue, bool spendsCoinbase,\n-                    unsigned int nSigOps, LockPoints lp);\n+                    int64_t nSigOpsCost, LockPoints lp);\n     CTxMemPoolEntry(const CTxMemPoolEntry& other);\n \n     const CTransaction& GetTx() const { return *this->tx; }\n@@ -121,11 +121,12 @@ class CTxMemPoolEntry\n      */\n     double GetPriority(unsigned int currentHeight) const;\n     const CAmount& GetFee() const { return nFee; }\n-    size_t GetTxSize() const { return nTxSize; }\n+    size_t GetTxSize() const;\n+    size_t GetTxCost() const { return nTxCost; }\n     int64_t GetTime() const { return nTime; }\n     unsigned int GetHeight() const { return entryHeight; }\n     bool WasClearAtEntry() const { return hadNoDependencies; }\n-    unsigned int GetSigOpCount() const { return sigOpCount; }\n+    int64_t GetSigOpCost() const { return sigOpCost; }\n     int64_t GetModifiedFee() const { return nFee + feeDelta; }\n     size_t DynamicMemoryUsage() const { return nUsageSize; }\n     const LockPoints& GetLockPoints() const { return lockPoints; }\n@@ -149,7 +150,7 @@ class CTxMemPoolEntry\n     uint64_t GetCountWithAncestors() const { return nCountWithAncestors; }\n     uint64_t GetSizeWithAncestors() const { return nSizeWithAncestors; }\n     CAmount GetModFeesWithAncestors() const { return nModFeesWithAncestors; }\n-    unsigned int GetSigOpCountWithAncestors() const { return nSigOpCountWithAncestors; }\n+    int64_t GetSigOpCostWithAncestors() const { return nSigOpCostWithAncestors; }\n \n     mutable size_t vTxHashesIdx; //!< Index in mempool's vTxHashes\n };\n@@ -172,18 +173,18 @@ struct update_descendant_state\n \n struct update_ancestor_state\n {\n-    update_ancestor_state(int64_t _modifySize, CAmount _modifyFee, int64_t _modifyCount, int _modifySigOps) :\n-        modifySize(_modifySize), modifyFee(_modifyFee), modifyCount(_modifyCount), modifySigOps(_modifySigOps)\n+    update_ancestor_state(int64_t _modifySize, CAmount _modifyFee, int64_t _modifyCount, int64_t _modifySigOpsCost) :\n+        modifySize(_modifySize), modifyFee(_modifyFee), modifyCount(_modifyCount), modifySigOpsCost(_modifySigOpsCost)\n     {}\n \n     void operator() (CTxMemPoolEntry &e)\n-        { e.UpdateAncestorState(modifySize, modifyFee, modifyCount, modifySigOps); }\n+        { e.UpdateAncestorState(modifySize, modifyFee, modifyCount, modifySigOpsCost); }\n \n     private:\n         int64_t modifySize;\n         CAmount modifyFee;\n         int64_t modifyCount;\n-        int modifySigOps;\n+        int64_t modifySigOpsCost;\n };\n \n struct update_fee_delta"
      },
      {
        "sha": "babde1a02c3c4b0b1131c596b268852fcb1f7408",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b",
        "patch": "@@ -2348,7 +2348,7 @@ bool CWallet::CreateTransaction(const vector<CRecipient>& vecSend, CWalletTx& wt\n                     nIn++;\n                 }\n \n-                unsigned int nBytes = ::GetSerializeSize(txNew, SER_NETWORK, PROTOCOL_VERSION);\n+                unsigned int nBytes = GetVirtualTransactionSize(txNew);\n \n                 // Remove scriptSigs if we used dummy signatures for fee calculation\n                 if (!sign) {\n@@ -2360,7 +2360,7 @@ bool CWallet::CreateTransaction(const vector<CRecipient>& vecSend, CWalletTx& wt\n                 *static_cast<CTransaction*>(&wtxNew) = CTransaction(txNew);\n \n                 // Limit size\n-                if (nBytes >= MAX_STANDARD_TX_SIZE)\n+                if (GetTransactionCost(txNew) >= MAX_STANDARD_TX_COST)\n                 {\n                     strFailReason = _(\"Transaction too large\");\n                     return false;"
      }
    ]
  },
  {
    "sha": "b7dbeb24ebff16198b2925d906c06771e167bd9e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiN2RiZWIyNGViZmYxNjE5OGIyOTI1ZDkwNmMwNjc3MWUxNjdiZDll",
    "commit": {
      "author": {
        "name": "Thomas Kerin",
        "email": "afk11@users.noreply.github.com",
        "date": "2016-01-24T16:29:39Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-06-22T13:43:00Z"
      },
      "message": "[libconsensus] Script verification API with amounts\n\nscript_tests: always test bitcoinconsensus_verify_script_with_amount if VERIFY_WITNESS isn't set\n\nRename internal method + make it static\n\ntrim bitcoinconsensus_ prefix\n\nAdd SERIALIZE_TRANSACTION_WITNESS flag",
      "tree": {
        "sha": "a20dd281b3356bd7b74df96480a687aac430f1e3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a20dd281b3356bd7b74df96480a687aac430f1e3"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b7dbeb24ebff16198b2925d906c06771e167bd9e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b7dbeb24ebff16198b2925d906c06771e167bd9e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b7dbeb24ebff16198b2925d906c06771e167bd9e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b7dbeb24ebff16198b2925d906c06771e167bd9e/comments",
    "author": {
      "login": "afk11",
      "id": 5617245,
      "node_id": "MDQ6VXNlcjU2MTcyNDU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/5617245?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/afk11",
      "html_url": "https://github.com/afk11",
      "followers_url": "https://api.github.com/users/afk11/followers",
      "following_url": "https://api.github.com/users/afk11/following{/other_user}",
      "gists_url": "https://api.github.com/users/afk11/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/afk11/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/afk11/subscriptions",
      "organizations_url": "https://api.github.com/users/afk11/orgs",
      "repos_url": "https://api.github.com/users/afk11/repos",
      "events_url": "https://api.github.com/users/afk11/events{/privacy}",
      "received_events_url": "https://api.github.com/users/afk11/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2b1f6f9ccf36f1e0a2c9d99154e1642f796d7c2b"
      }
    ],
    "stats": {
      "total": 45,
      "additions": 38,
      "deletions": 7
    },
    "files": [
      {
        "sha": "62fd9031f853a85bb89f34ffb096460cacaeff3e",
        "filename": "src/script/bitcoinconsensus.cpp",
        "status": "modified",
        "additions": 25,
        "deletions": 5,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b7dbeb24ebff16198b2925d906c06771e167bd9e/src/script/bitcoinconsensus.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b7dbeb24ebff16198b2925d906c06771e167bd9e/src/script/bitcoinconsensus.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/bitcoinconsensus.cpp?ref=b7dbeb24ebff16198b2925d906c06771e167bd9e",
        "patch": "@@ -69,7 +69,7 @@ struct ECCryptoClosure\n ECCryptoClosure instance_of_eccryptoclosure;\n }\n \n-int bitcoinconsensus_verify_script(const unsigned char *scriptPubKey, unsigned int scriptPubKeyLen,\n+static int verify_script(const unsigned char *scriptPubKey, unsigned int scriptPubKeyLen, CAmount amount,\n                                     const unsigned char *txTo        , unsigned int txToLen,\n                                     unsigned int nIn, unsigned int flags, bitcoinconsensus_error* err)\n {\n@@ -82,16 +82,36 @@ int bitcoinconsensus_verify_script(const unsigned char *scriptPubKey, unsigned i\n         if (tx.GetSerializeSize(SER_NETWORK, PROTOCOL_VERSION) != txToLen)\n             return set_error(err, bitcoinconsensus_ERR_TX_SIZE_MISMATCH);\n \n-         // Regardless of the verification result, the tx did not error.\n-         set_error(err, bitcoinconsensus_ERR_OK);\n+        // Regardless of the verification result, the tx did not error.\n+        set_error(err, bitcoinconsensus_ERR_OK);\n \n-        CAmount am(0);\n-        return VerifyScript(tx.vin[nIn].scriptSig, CScript(scriptPubKey, scriptPubKey + scriptPubKeyLen), nIn < tx.wit.vtxinwit.size() ? &tx.wit.vtxinwit[nIn].scriptWitness : NULL, flags, TransactionSignatureChecker(&tx, nIn, am), NULL);\n+        return VerifyScript(tx.vin[nIn].scriptSig, CScript(scriptPubKey, scriptPubKey + scriptPubKeyLen), nIn < tx.wit.vtxinwit.size() ? &tx.wit.vtxinwit[nIn].scriptWitness : NULL, flags, TransactionSignatureChecker(&tx, nIn, amount), NULL);\n     } catch (const std::exception&) {\n         return set_error(err, bitcoinconsensus_ERR_TX_DESERIALIZE); // Error deserializing\n     }\n }\n \n+int bitcoinconsensus_verify_script_with_amount(const unsigned char *scriptPubKey, unsigned int scriptPubKeyLen, int64_t amount,\n+                                    const unsigned char *txTo        , unsigned int txToLen,\n+                                    unsigned int nIn, unsigned int flags, bitcoinconsensus_error* err)\n+{\n+    CAmount am(amount);\n+    return ::verify_script(scriptPubKey, scriptPubKeyLen, am, txTo, txToLen, nIn, flags, err);\n+}\n+\n+\n+int bitcoinconsensus_verify_script(const unsigned char *scriptPubKey, unsigned int scriptPubKeyLen,\n+                                   const unsigned char *txTo        , unsigned int txToLen,\n+                                   unsigned int nIn, unsigned int flags, bitcoinconsensus_error* err)\n+{\n+    if (flags & bitcoinconsensus_SCRIPT_FLAGS_VERIFY_WITNESS) {\n+        return set_error(err, bitcoinconsensus_ERR_AMOUNT_REQUIRED);\n+    }\n+\n+    CAmount am(0);\n+    return ::verify_script(scriptPubKey, scriptPubKeyLen, am, txTo, txToLen, nIn, flags, err);\n+}\n+\n unsigned int bitcoinconsensus_version()\n {\n     // Just use the API version for now"
      },
      {
        "sha": "6f868d0d6d6ab2a609da5c0db9c781454140267b",
        "filename": "src/script/bitcoinconsensus.h",
        "status": "modified",
        "additions": 7,
        "deletions": 1,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b7dbeb24ebff16198b2925d906c06771e167bd9e/src/script/bitcoinconsensus.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b7dbeb24ebff16198b2925d906c06771e167bd9e/src/script/bitcoinconsensus.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/bitcoinconsensus.h?ref=b7dbeb24ebff16198b2925d906c06771e167bd9e",
        "patch": "@@ -33,14 +33,15 @@\n extern \"C\" {\n #endif\n \n-#define BITCOINCONSENSUS_API_VER 0\n+#define BITCOINCONSENSUS_API_VER 1\n \n typedef enum bitcoinconsensus_error_t\n {\n     bitcoinconsensus_ERR_OK = 0,\n     bitcoinconsensus_ERR_TX_INDEX,\n     bitcoinconsensus_ERR_TX_SIZE_MISMATCH,\n     bitcoinconsensus_ERR_TX_DESERIALIZE,\n+    bitcoinconsensus_ERR_AMOUNT_REQUIRED,\n } bitcoinconsensus_error;\n \n /** Script verification flags */\n@@ -50,13 +51,18 @@ enum\n     bitcoinconsensus_SCRIPT_FLAGS_VERIFY_P2SH                = (1U << 0), // evaluate P2SH (BIP16) subscripts\n     bitcoinconsensus_SCRIPT_FLAGS_VERIFY_DERSIG              = (1U << 2), // enforce strict DER (BIP66) compliance\n     bitcoinconsensus_SCRIPT_FLAGS_VERIFY_CHECKLOCKTIMEVERIFY = (1U << 9), // enable CHECKLOCKTIMEVERIFY (BIP65)\n+    bitcoinconsensus_SCRIPT_FLAGS_VERIFY_WITNESS             = (1U << 11), // enable WITNESS (BIP141)\n };\n \n /// Returns 1 if the input nIn of the serialized transaction pointed to by\n /// txTo correctly spends the scriptPubKey pointed to by scriptPubKey under\n /// the additional constraints specified by flags.\n /// If not NULL, err will contain an error/success code for the operation\n EXPORT_SYMBOL int bitcoinconsensus_verify_script(const unsigned char *scriptPubKey, unsigned int scriptPubKeyLen,\n+                                                 const unsigned char *txTo        , unsigned int txToLen,\n+                                                 unsigned int nIn, unsigned int flags, bitcoinconsensus_error* err);\n+\n+EXPORT_SYMBOL int bitcoinconsensus_verify_script_with_amount(const unsigned char *scriptPubKey, unsigned int scriptPubKeyLen, int64_t amount,\n                                     const unsigned char *txTo        , unsigned int txToLen,\n                                     unsigned int nIn, unsigned int flags, bitcoinconsensus_error* err);\n "
      },
      {
        "sha": "7fd7614e2cfc00225fb4beb584769d83c5709c1a",
        "filename": "src/test/script_tests.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 1,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b7dbeb24ebff16198b2925d906c06771e167bd9e/src/test/script_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b7dbeb24ebff16198b2925d906c06771e167bd9e/src/test/script_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_tests.cpp?ref=b7dbeb24ebff16198b2925d906c06771e167bd9e",
        "patch": "@@ -160,7 +160,12 @@ void DoTest(const CScript& scriptPubKey, const CScript& scriptSig, int flags, co\n #if defined(HAVE_CONSENSUS_LIB)\n     CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n     stream << tx2;\n-    BOOST_CHECK_MESSAGE(bitcoinconsensus_verify_script(begin_ptr(scriptPubKey), scriptPubKey.size(), (const unsigned char*)&stream[0], stream.size(), 0, flags, NULL) == expect,message);\n+    if (flags & bitcoinconsensus_SCRIPT_FLAGS_VERIFY_WITNESS) {\n+        BOOST_CHECK_MESSAGE(bitcoinconsensus_verify_script_with_amount(begin_ptr(scriptPubKey), scriptPubKey.size(), amountZero, (const unsigned char*)&stream[0], stream.size(), 0, flags, NULL) == expect, message);\n+    } else {\n+        BOOST_CHECK_MESSAGE(bitcoinconsensus_verify_script_with_amount(begin_ptr(scriptPubKey), scriptPubKey.size(), 0, (const unsigned char*)&stream[0], stream.size(), 0, flags, NULL) == expect, message);\n+        BOOST_CHECK_MESSAGE(bitcoinconsensus_verify_script(begin_ptr(scriptPubKey), scriptPubKey.size(), (const unsigned char*)&stream[0], stream.size(), 0, flags, NULL) == expect,message);\n+    }\n #endif\n }\n "
      }
    ]
  },
  {
    "sha": "6032f6930a56c107dad8f30c05fec4aab79c8c22",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2MDMyZjY5MzBhNTZjMTA3ZGFkOGYzMGMwNWZlYzRhYWI3OWM4YzIy",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-03-18T16:20:12Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-06-22T13:43:00Z"
      },
      "message": "Add rewind logic to deal with post-fork software updates\n\nIncludes logic for dealing with pruning by Suhas Daftuar.",
      "tree": {
        "sha": "7fd79172fe0bb65ef533bfb24b00f567d2706930",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7fd79172fe0bb65ef533bfb24b00f567d2706930"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6032f6930a56c107dad8f30c05fec4aab79c8c22",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6032f6930a56c107dad8f30c05fec4aab79c8c22",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6032f6930a56c107dad8f30c05fec4aab79c8c22",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6032f6930a56c107dad8f30c05fec4aab79c8c22/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b7dbeb24ebff16198b2925d906c06771e167bd9e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b7dbeb24ebff16198b2925d906c06771e167bd9e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b7dbeb24ebff16198b2925d906c06771e167bd9e"
      }
    ],
    "stats": {
      "total": 145,
      "additions": 126,
      "deletions": 19
    },
    "files": [
      {
        "sha": "76a774c1238f17d9aecb0a829c2bd32628b00a02",
        "filename": "src/chain.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6032f6930a56c107dad8f30c05fec4aab79c8c22/src/chain.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6032f6930a56c107dad8f30c05fec4aab79c8c22/src/chain.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chain.h?ref=6032f6930a56c107dad8f30c05fec4aab79c8c22",
        "patch": "@@ -144,6 +144,8 @@ enum BlockStatus: uint32_t {\n     BLOCK_FAILED_VALID       =   32, //! stage after last reached validness failed\n     BLOCK_FAILED_CHILD       =   64, //! descends from failed block\n     BLOCK_FAILED_MASK        =   BLOCK_FAILED_VALID | BLOCK_FAILED_CHILD,\n+\n+    BLOCK_OPT_WITNESS       =   128, //! block data in blk*.data was received with a witness-enforcing client\n };\n \n /** The block chain is a tree shaped structure starting with the"
      },
      {
        "sha": "5d29f14eb88219e222ab966ce79d856870a19e53",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6032f6930a56c107dad8f30c05fec4aab79c8c22/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6032f6930a56c107dad8f30c05fec4aab79c8c22/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=6032f6930a56c107dad8f30c05fec4aab79c8c22",
        "patch": "@@ -1284,6 +1284,14 @@ bool AppInit2(boost::thread_group& threadGroup, CScheduler& scheduler)\n                     break;\n                 }\n \n+                if (!fReindex) {\n+                    uiInterface.InitMessage(_(\"Rewinding blocks...\"));\n+                    if (!RewindBlockIndex(chainparams)) {\n+                        strLoadError = _(\"Unable to rewind the database to a pre-fork state. You will need to redownload the blockchain\");\n+                        break;\n+                    }\n+                }\n+\n                 uiInterface.InitMessage(_(\"Verifying blocks...\"));\n                 if (fHavePruned && GetArg(\"-checkblocks\", DEFAULT_CHECKBLOCKS) > MIN_BLOCKS_TO_KEEP) {\n                     LogPrintf(\"Prune: pruned datadir may not have more than %d blocks; only checking available blocks\","
      },
      {
        "sha": "ec43a667017e3b2e5b2828d49dcb40bf948ed963",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 113,
        "deletions": 19,
        "changes": 132,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6032f6930a56c107dad8f30c05fec4aab79c8c22/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6032f6930a56c107dad8f30c05fec4aab79c8c22/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=6032f6930a56c107dad8f30c05fec4aab79c8c22",
        "patch": "@@ -658,6 +658,9 @@ CBlockIndex* FindForkInGlobalIndex(const CChain& chain, const CBlockLocator& loc\n             CBlockIndex* pindex = (*mi).second;\n             if (chain.Contains(pindex))\n                 return pindex;\n+            if (pindex->GetAncestor(chain.Height()) == chain.Tip()) {\n+                return chain.Tip();\n+            }\n         }\n     }\n     return chain.Genesis();\n@@ -2777,7 +2780,7 @@ void static UpdateTip(CBlockIndex *pindexNew, const CChainParams& chainParams) {\n }\n \n /** Disconnect chainActive's tip. You probably want to call mempool.removeForReorg and manually re-limit mempool size after this, with cs_main held. */\n-bool static DisconnectTip(CValidationState& state, const CChainParams& chainparams)\n+bool static DisconnectTip(CValidationState& state, const CChainParams& chainparams, bool fBare = false)\n {\n     CBlockIndex *pindexDelete = chainActive.Tip();\n     assert(pindexDelete);\n@@ -2797,24 +2800,28 @@ bool static DisconnectTip(CValidationState& state, const CChainParams& chainpara\n     // Write the chain state to disk, if necessary.\n     if (!FlushStateToDisk(state, FLUSH_STATE_IF_NEEDED))\n         return false;\n-    // Resurrect mempool transactions from the disconnected block.\n-    std::vector<uint256> vHashUpdate;\n-    BOOST_FOREACH(const CTransaction &tx, block.vtx) {\n-        // ignore validation errors in resurrected transactions\n-        list<CTransaction> removed;\n-        CValidationState stateDummy;\n-        if (tx.IsCoinBase() || !AcceptToMemoryPool(mempool, stateDummy, tx, false, NULL, true)) {\n-            mempool.removeRecursive(tx, removed);\n-        } else if (mempool.exists(tx.GetHash())) {\n-            vHashUpdate.push_back(tx.GetHash());\n-        }\n-    }\n-    // AcceptToMemoryPool/addUnchecked all assume that new mempool entries have\n-    // no in-mempool children, which is generally not true when adding\n-    // previously-confirmed transactions back to the mempool.\n-    // UpdateTransactionsFromBlock finds descendants of any transactions in this\n-    // block that were added back and cleans up the mempool state.\n-    mempool.UpdateTransactionsFromBlock(vHashUpdate);\n+\n+    if (!fBare) {\n+        // Resurrect mempool transactions from the disconnected block.\n+        std::vector<uint256> vHashUpdate;\n+        BOOST_FOREACH(const CTransaction &tx, block.vtx) {\n+            // ignore validation errors in resurrected transactions\n+            list<CTransaction> removed;\n+            CValidationState stateDummy;\n+            if (tx.IsCoinBase() || !AcceptToMemoryPool(mempool, stateDummy, tx, false, NULL, true)) {\n+                mempool.removeRecursive(tx, removed);\n+            } else if (mempool.exists(tx.GetHash())) {\n+                vHashUpdate.push_back(tx.GetHash());\n+            }\n+        }\n+        // AcceptToMemoryPool/addUnchecked all assume that new mempool entries have\n+        // no in-mempool children, which is generally not true when adding\n+        // previously-confirmed transactions back to the mempool.\n+        // UpdateTransactionsFromBlock finds descendants of any transactions in this\n+        // block that were added back and cleans up the mempool state.\n+        mempool.UpdateTransactionsFromBlock(vHashUpdate);\n+    }\n+\n     // Update chainActive and related variables.\n     UpdateTip(pindexDelete->pprev, chainparams);\n     // Let wallets know transactions went from 1-confirmed to\n@@ -3266,6 +3273,9 @@ bool ReceivedBlockTransactions(const CBlock &block, CValidationState& state, CBl\n     pindexNew->nDataPos = pos.nPos;\n     pindexNew->nUndoPos = 0;\n     pindexNew->nStatus |= BLOCK_HAVE_DATA;\n+    if (IsWitnessEnabled(pindexNew->pprev, Params().GetConsensus())) {\n+        pindexNew->nStatus |= BLOCK_OPT_WITNESS;\n+    }\n     pindexNew->RaiseValidity(BLOCK_VALID_TRANSACTIONS);\n     setDirtyBlockIndex.insert(pindexNew);\n \n@@ -4214,6 +4224,90 @@ bool CVerifyDB::VerifyDB(const CChainParams& chainparams, CCoinsView *coinsview,\n     return true;\n }\n \n+bool RewindBlockIndex(const CChainParams& params)\n+{\n+    LOCK(cs_main);\n+\n+    int nHeight = 1;\n+    while (nHeight <= chainActive.Height()) {\n+        if (IsWitnessEnabled(chainActive[nHeight - 1], params.GetConsensus()) && !(chainActive[nHeight]->nStatus & BLOCK_OPT_WITNESS)) {\n+            break;\n+        }\n+        nHeight++;\n+    }\n+\n+    // nHeight is now the height of the first insufficiently-validated block, or tipheight + 1\n+    CValidationState state;\n+    CBlockIndex* pindex = chainActive.Tip();\n+    while (chainActive.Height() >= nHeight) {\n+        if (fPruneMode && !(chainActive.Tip()->nStatus & BLOCK_HAVE_DATA)) {\n+            // If pruning, don't try rewinding past the HAVE_DATA point;\n+            // since older blocks can't be served anyway, there's\n+            // no need to walk further, and trying to DisconnectTip()\n+            // will fail (and require a needless reindex/redownload\n+            // of the blockchain).\n+            break;\n+        }\n+        if (!DisconnectTip(state, params, true)) {\n+            return error(\"RewindBlockIndex: unable to disconnect block at height %i\", pindex->nHeight);\n+        }\n+        // Occasionally flush state to disk.\n+        if (!FlushStateToDisk(state, FLUSH_STATE_PERIODIC))\n+            return false;\n+    }\n+\n+    // Reduce validity flag and have-data flags.\n+    // We do this after actual disconnecting, otherwise we'll end up writing the lack of data\n+    // to disk before writing the chainstate, resulting in a failure to continue if interrupted.\n+    for (BlockMap::iterator it = mapBlockIndex.begin(); it != mapBlockIndex.end(); it++) {\n+        CBlockIndex* pindexIter = it->second;\n+\n+        // Note: If we encounter an insufficiently validated block that\n+        // is on chainActive, it must be because we are a pruning node, and\n+        // this block or some successor doesn't HAVE_DATA, so we were unable to\n+        // rewind all the way.  Blocks remaining on chainActive at this point\n+        // must not have their validity reduced.\n+        if (IsWitnessEnabled(pindexIter->pprev, params.GetConsensus()) && !(pindexIter->nStatus & BLOCK_OPT_WITNESS) && !chainActive.Contains(pindexIter)) {\n+            // Reduce validity\n+            pindexIter->nStatus = std::min<unsigned int>(pindexIter->nStatus & BLOCK_VALID_MASK, BLOCK_VALID_TREE) | (pindexIter->nStatus & ~BLOCK_VALID_MASK);\n+            // Remove have-data flags.\n+            pindexIter->nStatus &= ~(BLOCK_HAVE_DATA | BLOCK_HAVE_UNDO);\n+            // Remove storage location.\n+            pindexIter->nFile = 0;\n+            pindexIter->nDataPos = 0;\n+            pindexIter->nUndoPos = 0;\n+            // Remove various other things\n+            pindexIter->nTx = 0;\n+            pindexIter->nChainTx = 0;\n+            pindexIter->nSequenceId = 0;\n+            // Make sure it gets written.\n+            setDirtyBlockIndex.insert(pindexIter);\n+            // Update indexes\n+            setBlockIndexCandidates.erase(pindexIter);\n+            std::pair<std::multimap<CBlockIndex*, CBlockIndex*>::iterator, std::multimap<CBlockIndex*, CBlockIndex*>::iterator> ret = mapBlocksUnlinked.equal_range(pindexIter->pprev);\n+            while (ret.first != ret.second) {\n+                if (ret.first->second == pindexIter) {\n+                    mapBlocksUnlinked.erase(ret.first++);\n+                } else {\n+                    ++ret.first;\n+                }\n+            }\n+        } else if (pindexIter->IsValid(BLOCK_VALID_TRANSACTIONS) && pindexIter->nChainTx) {\n+            setBlockIndexCandidates.insert(pindexIter);\n+        }\n+    }\n+\n+    PruneBlockIndexCandidates();\n+\n+    CheckBlockIndex(params.GetConsensus());\n+\n+    if (!FlushStateToDisk(state, FLUSH_STATE_ALWAYS)) {\n+        return false;\n+    }\n+\n+    return true;\n+}\n+\n void UnloadBlockIndex()\n {\n     LOCK(cs_main);"
      },
      {
        "sha": "84a6044bc9ddeef994156bb5e19e4c48d7411b07",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6032f6930a56c107dad8f30c05fec4aab79c8c22/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6032f6930a56c107dad8f30c05fec4aab79c8c22/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=6032f6930a56c107dad8f30c05fec4aab79c8c22",
        "patch": "@@ -459,6 +459,9 @@ bool TestBlockValidity(CValidationState& state, const CChainParams& chainparams,\n /** Check whether witness commitments are required for block. */\n bool IsWitnessEnabled(const CBlockIndex* pindexPrev, const Consensus::Params& params);\n \n+/** When there are blocks in the active chain with missing data, rewind the chainstate and remove them from the block index */\n+bool RewindBlockIndex(const CChainParams& params);\n+\n /** Update uncommitted block structures (currently: only the witness nonce). This is safe for submitted blocks. */\n void UpdateUncommittedBlockStructures(CBlock& block, const CBlockIndex* pindexPrev, const Consensus::Params& consensusParams);\n "
      }
    ]
  },
  {
    "sha": "af87a67eff8ce7bf2c7fb29f760da9fc610f162f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphZjg3YTY3ZWZmOGNlN2JmMmM3ZmIyOWY3NjBkYTlmYzYxMGYxNjJm",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-06-22T13:39:26Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-06-22T13:43:00Z"
      },
      "message": "Do not use compact blocks when segwit is enabled",
      "tree": {
        "sha": "e7eef0832da0672a6c0a8f50ca0ae378e0227a35",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e7eef0832da0672a6c0a8f50ca0ae378e0227a35"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/af87a67eff8ce7bf2c7fb29f760da9fc610f162f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/af87a67eff8ce7bf2c7fb29f760da9fc610f162f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/af87a67eff8ce7bf2c7fb29f760da9fc610f162f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/af87a67eff8ce7bf2c7fb29f760da9fc610f162f/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6032f6930a56c107dad8f30c05fec4aab79c8c22",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6032f6930a56c107dad8f30c05fec4aab79c8c22",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6032f6930a56c107dad8f30c05fec4aab79c8c22"
      }
    ],
    "stats": {
      "total": 8,
      "additions": 6,
      "deletions": 2
    },
    "files": [
      {
        "sha": "d1ba70313e3b3312920badf409ce9be59d02aee4",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 2,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/af87a67eff8ce7bf2c7fb29f760da9fc610f162f/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/af87a67eff8ce7bf2c7fb29f760da9fc610f162f/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=af87a67eff8ce7bf2c7fb29f760da9fc610f162f",
        "patch": "@@ -473,6 +473,10 @@ void UpdateBlockAvailability(NodeId nodeid, const uint256 &hash) {\n }\n \n void MaybeSetPeerAsAnnouncingHeaderAndIDs(const CNodeState* nodestate, CNode* pfrom) {\n+    if (nLocalServices & NODE_WITNESS) {\n+        // Don't ever request compact blocks when segwit is enabled.\n+        return;\n+    }\n     if (nodestate->fProvidesHeaderAndIDs) {\n         BOOST_FOREACH(const NodeId nodeid, lNodesAnnouncingHeaderAndIDs)\n             if (nodeid == pfrom->GetId())\n@@ -5286,7 +5290,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                         nodestate->nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER &&\n                         (!IsWitnessEnabled(chainActive.Tip(), chainparams.GetConsensus()) || State(pfrom->GetId())->fHaveWitness)) {\n                         inv.type |= nFetchFlags;\n-                        if (nodestate->fProvidesHeaderAndIDs)\n+                        if (nodestate->fProvidesHeaderAndIDs && !(nLocalServices & NODE_WITNESS))\n                             vToFetch.push_back(CInv(MSG_CMPCT_BLOCK, inv.hash));\n                         else\n                             vToFetch.push_back(inv);\n@@ -5905,7 +5909,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                             pindexLast->GetBlockHash().ToString(), pindexLast->nHeight);\n                 }\n                 if (vGetData.size() > 0) {\n-                    if (nodestate->fProvidesHeaderAndIDs && vGetData.size() == 1 && mapBlocksInFlight.size() == 1 && pindexLast->pprev->IsValid(BLOCK_VALID_CHAIN)) {\n+                    if (nodestate->fProvidesHeaderAndIDs && vGetData.size() == 1 && mapBlocksInFlight.size() == 1 && pindexLast->pprev->IsValid(BLOCK_VALID_CHAIN) && !(nLocalServices & NODE_WITNESS)) {\n                         // We seem to be rather well-synced, so it appears pfrom was the first to provide us\n                         // with this block! Let's get them to announce using compact blocks in the future.\n                         MaybeSetPeerAsAnnouncingHeaderAndIDs(nodestate, pfrom);"
      }
    ]
  },
  {
    "sha": "9757b57c25c67de611b8f5d0a19f409c2e8753a6",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5NzU3YjU3YzI1YzY3ZGU2MTFiOGY1ZDBhMTlmNDA5YzJlODc1M2E2",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-03-31T12:43:39Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-06-22T13:43:00Z"
      },
      "message": "--- [SEGWIT] begin: wallet ---",
      "tree": {
        "sha": "e7eef0832da0672a6c0a8f50ca0ae378e0227a35",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e7eef0832da0672a6c0a8f50ca0ae378e0227a35"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9757b57c25c67de611b8f5d0a19f409c2e8753a6",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9757b57c25c67de611b8f5d0a19f409c2e8753a6",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9757b57c25c67de611b8f5d0a19f409c2e8753a6",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9757b57c25c67de611b8f5d0a19f409c2e8753a6/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "af87a67eff8ce7bf2c7fb29f760da9fc610f162f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/af87a67eff8ce7bf2c7fb29f760da9fc610f162f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/af87a67eff8ce7bf2c7fb29f760da9fc610f162f"
      }
    ],
    "stats": {
      "total": 0,
      "additions": 0,
      "deletions": 0
    },
    "files": []
  },
  {
    "sha": "605e8473a7ddca13b24a4020c7bd630aa5d374e2",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2MDVlODQ3M2E3ZGRjYTEzYjI0YTQwMjBjN2JkNjMwYWE1ZDM3NGUy",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-03-31T12:54:58Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-06-22T13:43:01Z"
      },
      "message": "BIP143: Signing logic",
      "tree": {
        "sha": "8c425e851aa6c30d9edc8bccb60e731a3f053101",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8c425e851aa6c30d9edc8bccb60e731a3f053101"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/605e8473a7ddca13b24a4020c7bd630aa5d374e2",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/605e8473a7ddca13b24a4020c7bd630aa5d374e2",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/605e8473a7ddca13b24a4020c7bd630aa5d374e2",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/605e8473a7ddca13b24a4020c7bd630aa5d374e2/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9757b57c25c67de611b8f5d0a19f409c2e8753a6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9757b57c25c67de611b8f5d0a19f409c2e8753a6",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9757b57c25c67de611b8f5d0a19f409c2e8753a6"
      }
    ],
    "stats": {
      "total": 548,
      "additions": 382,
      "deletions": 166
    },
    "files": [
      {
        "sha": "f457ea2bce4d7bc116a87d05fbbdfc39c64b4fda",
        "filename": "src/bitcoin-tx.cpp",
        "status": "modified",
        "additions": 22,
        "deletions": 6,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/605e8473a7ddca13b24a4020c7bd630aa5d374e2/src/bitcoin-tx.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/605e8473a7ddca13b24a4020c7bd630aa5d374e2/src/bitcoin-tx.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-tx.cpp?ref=605e8473a7ddca13b24a4020c7bd630aa5d374e2",
        "patch": "@@ -363,6 +363,18 @@ vector<unsigned char> ParseHexUO(map<string,UniValue>& o, string strKey)\n     return ParseHexUV(o[strKey], strKey);\n }\n \n+static CAmount AmountFromValue(const UniValue& value)\n+{\n+    if (!value.isNum() && !value.isStr())\n+        throw runtime_error(\"Amount is not a number or string\");\n+    CAmount amount;\n+    if (!ParseFixedPoint(value.getValStr(), 8, &amount))\n+        throw runtime_error(\"Invalid amount\");\n+    if (!MoneyRange(amount))\n+        throw runtime_error(\"Amount out of range\");\n+    return amount;\n+}\n+\n static void MutateTxSign(CMutableTransaction& tx, const string& flagStr)\n {\n     int nHashType = SIGHASH_ALL;\n@@ -434,7 +446,10 @@ static void MutateTxSign(CMutableTransaction& tx, const string& flagStr)\n                 if ((unsigned int)nOut >= coins->vout.size())\n                     coins->vout.resize(nOut+1);\n                 coins->vout[nOut].scriptPubKey = scriptPubKey;\n-                coins->vout[nOut].nValue = 0; // we don't know the actual output value\n+                coins->vout[nOut].nValue = 0;\n+                if (prevOut.exists(\"amount\")) {\n+                    coins->vout[nOut].nValue = AmountFromValue(prevOut[\"amount\"]);\n+                }\n             }\n \n             // if redeemScript given and private keys given,\n@@ -464,15 +479,16 @@ static void MutateTxSign(CMutableTransaction& tx, const string& flagStr)\n         const CScript& prevPubKey = coins->vout[txin.prevout.n].scriptPubKey;\n         const CAmount& amount = coins->vout[txin.prevout.n].nValue;\n \n-        txin.scriptSig.clear();\n+        SignatureData sigdata;\n         // Only sign SIGHASH_SINGLE if there's a corresponding output:\n         if (!fHashSingle || (i < mergedTx.vout.size()))\n-            SignSignature(keystore, prevPubKey, mergedTx, i, nHashType);\n+            ProduceSignature(MutableTransactionSignatureCreator(&keystore, &mergedTx, i, amount, nHashType), prevPubKey, sigdata);\n \n         // ... and merge in other signatures:\n-        BOOST_FOREACH(const CTransaction& txv, txVariants) {\n-            txin.scriptSig = CombineSignatures(prevPubKey, mergedTx, i, amount, txin.scriptSig, txv.vin[i].scriptSig);\n-        }\n+        BOOST_FOREACH(const CTransaction& txv, txVariants)\n+            sigdata = CombineSignatures(prevPubKey, MutableTransactionSignatureChecker(&mergedTx, i, amount), sigdata, DataFromTransaction(txv, i));\n+        UpdateTransaction(mergedTx, i, sigdata);\n+\n         if (!VerifyScript(txin.scriptSig, prevPubKey, mergedTx.wit.vtxinwit.size() > i ? &mergedTx.wit.vtxinwit[i].scriptWitness : NULL, STANDARD_SCRIPT_VERIFY_FLAGS, MutableTransactionSignatureChecker(&mergedTx, i, amount)))\n             fComplete = false;\n     }"
      },
      {
        "sha": "56ba805b1f6ab2753418d943673490f541781910",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 5,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/605e8473a7ddca13b24a4020c7bd630aa5d374e2/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/605e8473a7ddca13b24a4020c7bd630aa5d374e2/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=605e8473a7ddca13b24a4020c7bd630aa5d374e2",
        "patch": "@@ -592,7 +592,8 @@ UniValue signrawtransaction(const UniValue& params, bool fHelp)\n             \"         \\\"txid\\\":\\\"id\\\",             (string, required) The transaction id\\n\"\n             \"         \\\"vout\\\":n,                  (numeric, required) The output number\\n\"\n             \"         \\\"scriptPubKey\\\": \\\"hex\\\",   (string, required) script key\\n\"\n-            \"         \\\"redeemScript\\\": \\\"hex\\\"    (string, required for P2SH) redeem script\\n\"\n+            \"         \\\"redeemScript\\\": \\\"hex\\\",   (string, required for P2SH) redeem script\\n\"\n+            \"         \\\"amount\\\": value            (numeric, required) The amount spent\\n\"\n             \"       }\\n\"\n             \"       ,...\\n\"\n             \"    ]\\n\"\n@@ -735,7 +736,10 @@ UniValue signrawtransaction(const UniValue& params, bool fHelp)\n                 if ((unsigned int)nOut >= coins->vout.size())\n                     coins->vout.resize(nOut+1);\n                 coins->vout[nOut].scriptPubKey = scriptPubKey;\n-                coins->vout[nOut].nValue = 0; // we don't know the actual output value\n+                coins->vout[nOut].nValue = 0;\n+                if (prevOut.exists(\"amount\")) {\n+                    coins->vout[nOut].nValue = AmountFromValue(find_value(prevOut, \"amount\"));\n+                }\n             }\n \n             // if redeemScript given and not using the local wallet (private keys\n@@ -801,15 +805,18 @@ UniValue signrawtransaction(const UniValue& params, bool fHelp)\n         const CScript& prevPubKey = coins->vout[txin.prevout.n].scriptPubKey;\n         const CAmount& amount = coins->vout[txin.prevout.n].nValue;\n \n-        txin.scriptSig.clear();\n+        SignatureData sigdata;\n         // Only sign SIGHASH_SINGLE if there's a corresponding output:\n         if (!fHashSingle || (i < mergedTx.vout.size()))\n-            SignSignature(keystore, prevPubKey, mergedTx, i, nHashType);\n+            ProduceSignature(MutableTransactionSignatureCreator(&keystore, &mergedTx, i, amount, nHashType), prevPubKey, sigdata);\n \n         // ... and merge in other signatures:\n         BOOST_FOREACH(const CMutableTransaction& txv, txVariants) {\n-            txin.scriptSig = CombineSignatures(prevPubKey, txConst, i, amount, txin.scriptSig, txv.vin[i].scriptSig);\n+            sigdata = CombineSignatures(prevPubKey, TransactionSignatureChecker(&txConst, i, amount), sigdata, DataFromTransaction(txv, i));\n         }\n+\n+        UpdateTransaction(mergedTx, i, sigdata);\n+\n         ScriptError serror = SCRIPT_ERR_OK;\n         if (!VerifyScript(txin.scriptSig, prevPubKey, mergedTx.wit.vtxinwit.size() > i ? &mergedTx.wit.vtxinwit[i].scriptWitness : NULL, STANDARD_SCRIPT_VERIFY_FLAGS, TransactionSignatureChecker(&txConst, i, amount), &serror)) {\n             TxInErrorToJSON(txin, vErrors, ScriptErrorString(serror));"
      },
      {
        "sha": "0bf180341e4ccc0d28763916903771ac698a2151",
        "filename": "src/script/ismine.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 2,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/605e8473a7ddca13b24a4020c7bd630aa5d374e2/src/script/ismine.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/605e8473a7ddca13b24a4020c7bd630aa5d374e2/src/script/ismine.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/ismine.cpp?ref=605e8473a7ddca13b24a4020c7bd630aa5d374e2",
        "patch": "@@ -57,6 +57,7 @@ isminetype IsMine(const CKeyStore &keystore, const CScript& scriptPubKey)\n             return ISMINE_SPENDABLE;\n         break;\n     case TX_PUBKEYHASH:\n+    case TX_WITNESS_V0_KEYHASH:\n         keyID = CKeyID(uint160(vSolutions[0]));\n         if (keystore.HaveKey(keyID))\n             return ISMINE_SPENDABLE;\n@@ -72,6 +73,20 @@ isminetype IsMine(const CKeyStore &keystore, const CScript& scriptPubKey)\n         }\n         break;\n     }\n+    case TX_WITNESS_V0_SCRIPTHASH:\n+    {\n+        uint160 hash;\n+        CRIPEMD160().Write(&vSolutions[0][0], vSolutions[0].size()).Finalize(hash.begin());\n+        CScriptID scriptID = CScriptID(hash);\n+        CScript subscript;\n+        if (keystore.GetCScript(scriptID, subscript)) {\n+            isminetype ret = IsMine(keystore, subscript);\n+            if (ret == ISMINE_SPENDABLE)\n+                return ret;\n+        }\n+        break;\n+    }\n+\n     case TX_MULTISIG:\n     {\n         // Only consider transactions \"mine\" if we own ALL the\n@@ -88,8 +103,8 @@ isminetype IsMine(const CKeyStore &keystore, const CScript& scriptPubKey)\n \n     if (keystore.HaveWatchOnly(scriptPubKey)) {\n         // TODO: This could be optimized some by doing some work after the above solver\n-        CScript scriptSig;\n-        return ProduceSignature(DummySignatureCreator(&keystore), scriptPubKey, scriptSig) ? ISMINE_WATCH_SOLVABLE : ISMINE_WATCH_UNSOLVABLE;\n+        SignatureData sigs;\n+        return ProduceSignature(DummySignatureCreator(&keystore), scriptPubKey, sigs) ? ISMINE_WATCH_SOLVABLE : ISMINE_WATCH_UNSOLVABLE;\n     }\n     return ISMINE_NO;\n }"
      },
      {
        "sha": "87f38d9c72565ee42e904cf194410330ea881570",
        "filename": "src/script/sign.cpp",
        "status": "modified",
        "additions": 196,
        "deletions": 83,
        "changes": 279,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/605e8473a7ddca13b24a4020c7bd630aa5d374e2/src/script/sign.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/605e8473a7ddca13b24a4020c7bd630aa5d374e2/src/script/sign.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.cpp?ref=605e8473a7ddca13b24a4020c7bd630aa5d374e2",
        "patch": "@@ -20,37 +20,37 @@ typedef std::vector<unsigned char> valtype;\n \n TransactionSignatureCreator::TransactionSignatureCreator(const CKeyStore* keystoreIn, const CTransaction* txToIn, unsigned int nInIn, const CAmount& amountIn, int nHashTypeIn) : BaseSignatureCreator(keystoreIn), txTo(txToIn), nIn(nInIn), nHashType(nHashTypeIn), amount(amountIn), checker(txTo, nIn, amountIn) {}\n \n-bool TransactionSignatureCreator::CreateSig(std::vector<unsigned char>& vchSig, const CKeyID& address, const CScript& scriptCode) const\n+bool TransactionSignatureCreator::CreateSig(std::vector<unsigned char>& vchSig, const CKeyID& address, const CScript& scriptCode, SigVersion sigversion) const\n {\n     CKey key;\n     if (!keystore->GetKey(address, key))\n         return false;\n \n-    uint256 hash = SignatureHash(scriptCode, *txTo, nIn, nHashType, amount, SIGVERSION_BASE);\n+    uint256 hash = SignatureHash(scriptCode, *txTo, nIn, nHashType, amount, sigversion);\n     if (!key.Sign(hash, vchSig))\n         return false;\n     vchSig.push_back((unsigned char)nHashType);\n     return true;\n }\n \n-static bool Sign1(const CKeyID& address, const BaseSignatureCreator& creator, const CScript& scriptCode, CScript& scriptSigRet)\n+static bool Sign1(const CKeyID& address, const BaseSignatureCreator& creator, const CScript& scriptCode, std::vector<valtype>& ret, SigVersion sigversion)\n {\n     vector<unsigned char> vchSig;\n-    if (!creator.CreateSig(vchSig, address, scriptCode))\n+    if (!creator.CreateSig(vchSig, address, scriptCode, sigversion))\n         return false;\n-    scriptSigRet << vchSig;\n+    ret.push_back(vchSig);\n     return true;\n }\n \n-static bool SignN(const vector<valtype>& multisigdata, const BaseSignatureCreator& creator, const CScript& scriptCode, CScript& scriptSigRet)\n+static bool SignN(const vector<valtype>& multisigdata, const BaseSignatureCreator& creator, const CScript& scriptCode, std::vector<valtype>& ret, SigVersion sigversion)\n {\n     int nSigned = 0;\n     int nRequired = multisigdata.front()[0];\n     for (unsigned int i = 1; i < multisigdata.size()-1 && nSigned < nRequired; i++)\n     {\n         const valtype& pubkey = multisigdata[i];\n         CKeyID keyID = CPubKey(pubkey).GetID();\n-        if (Sign1(keyID, creator, scriptCode, scriptSigRet))\n+        if (Sign1(keyID, creator, scriptCode, ret, sigversion))\n             ++nSigned;\n     }\n     return nSigned==nRequired;\n@@ -63,9 +63,11 @@ static bool SignN(const vector<valtype>& multisigdata, const BaseSignatureCreato\n  * Returns false if scriptPubKey could not be completely satisfied.\n  */\n static bool SignStep(const BaseSignatureCreator& creator, const CScript& scriptPubKey,\n-                     CScript& scriptSigRet, txnouttype& whichTypeRet)\n+                     std::vector<valtype>& ret, txnouttype& whichTypeRet, SigVersion sigversion)\n {\n-    scriptSigRet.clear();\n+    CScript scriptRet;\n+    uint160 h160;\n+    ret.clear();\n \n     vector<valtype> vSolutions;\n     if (!Solver(scriptPubKey, whichTypeRet, vSolutions))\n@@ -79,62 +81,142 @@ static bool SignStep(const BaseSignatureCreator& creator, const CScript& scriptP\n         return false;\n     case TX_PUBKEY:\n         keyID = CPubKey(vSolutions[0]).GetID();\n-        return Sign1(keyID, creator, scriptPubKey, scriptSigRet);\n+        return Sign1(keyID, creator, scriptPubKey, ret, sigversion);\n     case TX_PUBKEYHASH:\n         keyID = CKeyID(uint160(vSolutions[0]));\n-        if (!Sign1(keyID, creator, scriptPubKey, scriptSigRet))\n+        if (!Sign1(keyID, creator, scriptPubKey, ret, sigversion))\n             return false;\n         else\n         {\n             CPubKey vch;\n             creator.KeyStore().GetPubKey(keyID, vch);\n-            scriptSigRet << ToByteVector(vch);\n+            ret.push_back(ToByteVector(vch));\n         }\n         return true;\n     case TX_SCRIPTHASH:\n-        return creator.KeyStore().GetCScript(uint160(vSolutions[0]), scriptSigRet);\n+        if (creator.KeyStore().GetCScript(uint160(vSolutions[0]), scriptRet)) {\n+            ret.push_back(std::vector<unsigned char>(scriptRet.begin(), scriptRet.end()));\n+            return true;\n+        }\n+        return false;\n \n     case TX_MULTISIG:\n-        scriptSigRet << OP_0; // workaround CHECKMULTISIG bug\n-        return (SignN(vSolutions, creator, scriptPubKey, scriptSigRet));\n+        ret.push_back(valtype()); // workaround CHECKMULTISIG bug\n+        return (SignN(vSolutions, creator, scriptPubKey, ret, sigversion));\n+\n+    case TX_WITNESS_V0_KEYHASH:\n+        ret.push_back(vSolutions[0]);\n+        return true;\n+\n+    case TX_WITNESS_V0_SCRIPTHASH:\n+        CRIPEMD160().Write(&vSolutions[0][0], vSolutions[0].size()).Finalize(h160.begin());\n+        if (creator.KeyStore().GetCScript(h160, scriptRet)) {\n+            ret.push_back(std::vector<unsigned char>(scriptRet.begin(), scriptRet.end()));\n+            return true;\n+        }\n+        return false;\n+\n+    default:\n+        return false;\n     }\n-    return false;\n }\n \n-bool ProduceSignature(const BaseSignatureCreator& creator, const CScript& fromPubKey, CScript& scriptSig)\n+static CScript PushAll(const vector<valtype>& values)\n {\n+    CScript result;\n+    BOOST_FOREACH(const valtype& v, values) {\n+        if (v.size() == 0) {\n+            result << OP_0;\n+        } else if (v.size() == 1 && v[0] >= 1 && v[0] <= 16) {\n+            result << CScript::EncodeOP_N(v[0]);\n+        } else {\n+            result << v;\n+        }\n+    }\n+    return result;\n+}\n+\n+bool ProduceSignature(const BaseSignatureCreator& creator, const CScript& fromPubKey, SignatureData& sigdata)\n+{\n+    CScript script = fromPubKey;\n+    bool solved = true;\n+    std::vector<valtype> result;\n     txnouttype whichType;\n-    if (!SignStep(creator, fromPubKey, scriptSig, whichType))\n-        return false;\n+    solved = SignStep(creator, script, result, whichType, SIGVERSION_BASE);\n+    bool P2SH = false;\n+    CScript subscript;\n+    sigdata.scriptWitness.stack.clear();\n \n-    if (whichType == TX_SCRIPTHASH)\n+    if (solved && whichType == TX_SCRIPTHASH)\n     {\n-        // Solver returns the subscript that need to be evaluated;\n+        // Solver returns the subscript that needs to be evaluated;\n         // the final scriptSig is the signatures from that\n         // and then the serialized subscript:\n-        CScript subscript = scriptSig;\n+        script = subscript = CScript(result[0].begin(), result[0].end());\n+        solved = solved && SignStep(creator, script, result, whichType, SIGVERSION_BASE) && whichType != TX_SCRIPTHASH;\n+        P2SH = true;\n+    }\n \n+    if (solved && whichType == TX_WITNESS_V0_KEYHASH)\n+    {\n+        CScript witnessscript;\n+        witnessscript << OP_DUP << OP_HASH160 << ToByteVector(result[0]) << OP_EQUALVERIFY << OP_CHECKSIG;\n         txnouttype subType;\n-        bool fSolved =\n-            SignStep(creator, subscript, scriptSig, subType) && subType != TX_SCRIPTHASH;\n-        // Append serialized subscript whether or not it is completely signed:\n-        scriptSig << valtype(subscript.begin(), subscript.end());\n-        if (!fSolved) return false;\n+        solved = solved && SignStep(creator, witnessscript, result, subType, SIGVERSION_WITNESS_V0);\n+        sigdata.scriptWitness.stack = result;\n+        result.clear();\n+    }\n+    else if (solved && whichType == TX_WITNESS_V0_SCRIPTHASH)\n+    {\n+        CScript witnessscript(result[0].begin(), result[0].end());\n+        txnouttype subType;\n+        solved = solved && SignStep(creator, witnessscript, result, subType, SIGVERSION_WITNESS_V0) && subType != TX_SCRIPTHASH && subType != TX_WITNESS_V0_SCRIPTHASH && subType != TX_WITNESS_V0_KEYHASH;\n+        result.push_back(std::vector<unsigned char>(witnessscript.begin(), witnessscript.end()));\n+        sigdata.scriptWitness.stack = result;\n+        result.clear();\n     }\n \n+    if (P2SH) {\n+        result.push_back(std::vector<unsigned char>(subscript.begin(), subscript.end()));\n+    }\n+    sigdata.scriptSig = PushAll(result);\n+\n     // Test solution\n-    return VerifyScript(scriptSig, fromPubKey, NULL, STANDARD_SCRIPT_VERIFY_FLAGS, creator.Checker());\n+    return solved && VerifyScript(sigdata.scriptSig, fromPubKey, &sigdata.scriptWitness, STANDARD_SCRIPT_VERIFY_FLAGS, creator.Checker());\n+}\n+\n+SignatureData DataFromTransaction(const CMutableTransaction& tx, unsigned int nIn)\n+{\n+    SignatureData data;\n+    assert(tx.vin.size() > nIn);\n+    data.scriptSig = tx.vin[nIn].scriptSig;\n+    if (tx.wit.vtxinwit.size() > nIn) {\n+        data.scriptWitness = tx.wit.vtxinwit[nIn].scriptWitness;\n+    }\n+    return data;\n+}\n+\n+void UpdateTransaction(CMutableTransaction& tx, unsigned int nIn, const SignatureData& data)\n+{\n+    assert(tx.vin.size() > nIn);\n+    tx.vin[nIn].scriptSig = data.scriptSig;\n+    if (!data.scriptWitness.IsNull() || tx.wit.vtxinwit.size() > nIn) {\n+        tx.wit.vtxinwit.resize(tx.vin.size());\n+        tx.wit.vtxinwit[nIn].scriptWitness = data.scriptWitness;\n+    }\n }\n \n-bool SignSignature(const CKeyStore &keystore, const CScript& fromPubKey, CMutableTransaction& txTo, unsigned int nIn, int nHashType)\n+bool SignSignature(const CKeyStore &keystore, const CScript& fromPubKey, CMutableTransaction& txTo, unsigned int nIn, const CAmount& amount, int nHashType)\n {\n     assert(nIn < txTo.vin.size());\n-    CTxIn& txin = txTo.vin[nIn];\n \n     CTransaction txToConst(txTo);\n-    TransactionSignatureCreator creator(&keystore, &txToConst, nIn, nHashType);\n+    TransactionSignatureCreator creator(&keystore, &txToConst, nIn, amount, nHashType);\n \n-    return ProduceSignature(creator, fromPubKey, txin.scriptSig);\n+    SignatureData sigdata;\n+    bool ret = ProduceSignature(creator, fromPubKey, sigdata);\n+    UpdateTransaction(txTo, nIn, sigdata);\n+    return ret;\n }\n \n bool SignSignature(const CKeyStore &keystore, const CTransaction& txFrom, CMutableTransaction& txTo, unsigned int nIn, int nHashType)\n@@ -144,20 +226,12 @@ bool SignSignature(const CKeyStore &keystore, const CTransaction& txFrom, CMutab\n     assert(txin.prevout.n < txFrom.vout.size());\n     const CTxOut& txout = txFrom.vout[txin.prevout.n];\n \n-    return SignSignature(keystore, txout.scriptPubKey, txTo, nIn, nHashType);\n-}\n-\n-static CScript PushAll(const vector<valtype>& values)\n-{\n-    CScript result;\n-    BOOST_FOREACH(const valtype& v, values)\n-        result << v;\n-    return result;\n+    return SignSignature(keystore, txout.scriptPubKey, txTo, nIn, txout.nValue, nHashType);\n }\n \n-static CScript CombineMultisig(const CScript& scriptPubKey, const BaseSignatureChecker& checker,\n+static vector<valtype> CombineMultisig(const CScript& scriptPubKey, const BaseSignatureChecker& checker,\n                                const vector<valtype>& vSolutions,\n-                               const vector<valtype>& sigs1, const vector<valtype>& sigs2)\n+                               const vector<valtype>& sigs1, const vector<valtype>& sigs2, SigVersion sigversion)\n {\n     // Combine all the signatures we've got:\n     set<valtype> allsigs;\n@@ -185,7 +259,7 @@ static CScript CombineMultisig(const CScript& scriptPubKey, const BaseSignatureC\n             if (sigs.count(pubkey))\n                 continue; // Already got a sig for this pubkey\n \n-            if (checker.CheckSig(sig, pubkey, scriptPubKey, SIGVERSION_BASE))\n+            if (checker.CheckSig(sig, pubkey, scriptPubKey, sigversion))\n             {\n                 sigs[pubkey] = sig;\n                 break;\n@@ -194,87 +268,126 @@ static CScript CombineMultisig(const CScript& scriptPubKey, const BaseSignatureC\n     }\n     // Now build a merged CScript:\n     unsigned int nSigsHave = 0;\n-    CScript result; result << OP_0; // pop-one-too-many workaround\n+    std::vector<valtype> result; result.push_back(valtype()); // pop-one-too-many workaround\n     for (unsigned int i = 0; i < nPubKeys && nSigsHave < nSigsRequired; i++)\n     {\n         if (sigs.count(vSolutions[i+1]))\n         {\n-            result << sigs[vSolutions[i+1]];\n+            result.push_back(sigs[vSolutions[i+1]]);\n             ++nSigsHave;\n         }\n     }\n     // Fill any missing with OP_0:\n     for (unsigned int i = nSigsHave; i < nSigsRequired; i++)\n-        result << OP_0;\n+        result.push_back(valtype());\n \n     return result;\n }\n \n-static CScript CombineSignatures(const CScript& scriptPubKey, const BaseSignatureChecker& checker,\n+namespace\n+{\n+struct Stacks\n+{\n+    std::vector<valtype> script;\n+    std::vector<valtype> witness;\n+\n+    Stacks() {}\n+    explicit Stacks(const std::vector<valtype>& scriptSigStack_) : script(scriptSigStack_), witness() {}\n+    explicit Stacks(const SignatureData& data) : witness(data.scriptWitness.stack) {\n+        EvalScript(script, data.scriptSig, SCRIPT_VERIFY_STRICTENC, BaseSignatureChecker(), SIGVERSION_BASE);\n+    }\n+\n+    SignatureData Output() const {\n+        SignatureData result;\n+        result.scriptSig = PushAll(script);\n+        result.scriptWitness.stack = witness;\n+        return result;\n+    }\n+};\n+}\n+\n+static Stacks CombineSignatures(const CScript& scriptPubKey, const BaseSignatureChecker& checker,\n                                  const txnouttype txType, const vector<valtype>& vSolutions,\n-                                 vector<valtype>& sigs1, vector<valtype>& sigs2)\n+                                 Stacks sigs1, Stacks sigs2, SigVersion sigversion)\n {\n     switch (txType)\n     {\n     case TX_NONSTANDARD:\n     case TX_NULL_DATA:\n         // Don't know anything about this, assume bigger one is correct:\n-        if (sigs1.size() >= sigs2.size())\n-            return PushAll(sigs1);\n-        return PushAll(sigs2);\n+        if (sigs1.script.size() >= sigs2.script.size())\n+            return sigs1;\n+        return sigs2;\n     case TX_PUBKEY:\n     case TX_PUBKEYHASH:\n         // Signatures are bigger than placeholders or empty scripts:\n-        if (sigs1.empty() || sigs1[0].empty())\n-            return PushAll(sigs2);\n-        return PushAll(sigs1);\n+        if (sigs1.script.empty() || sigs1.script[0].empty())\n+            return sigs2;\n+        return sigs1;\n+    case TX_WITNESS_V0_KEYHASH:\n+        // Signatures are bigger than placeholders or empty scripts:\n+        if (sigs1.witness.empty() || sigs1.witness[0].empty())\n+            return sigs2;\n+        return sigs1;\n     case TX_SCRIPTHASH:\n-        if (sigs1.empty() || sigs1.back().empty())\n-            return PushAll(sigs2);\n-        else if (sigs2.empty() || sigs2.back().empty())\n-            return PushAll(sigs1);\n+        if (sigs1.script.empty() || sigs1.script.back().empty())\n+            return sigs2;\n+        else if (sigs2.script.empty() || sigs2.script.back().empty())\n+            return sigs1;\n         else\n         {\n             // Recur to combine:\n-            valtype spk = sigs1.back();\n+            valtype spk = sigs1.script.back();\n             CScript pubKey2(spk.begin(), spk.end());\n \n             txnouttype txType2;\n             vector<vector<unsigned char> > vSolutions2;\n             Solver(pubKey2, txType2, vSolutions2);\n-            sigs1.pop_back();\n-            sigs2.pop_back();\n-            CScript result = CombineSignatures(pubKey2, checker, txType2, vSolutions2, sigs1, sigs2);\n-            result << spk;\n+            sigs1.script.pop_back();\n+            sigs2.script.pop_back();\n+            Stacks result = CombineSignatures(pubKey2, checker, txType2, vSolutions2, sigs1, sigs2, sigversion);\n+            result.script.push_back(spk);\n             return result;\n         }\n     case TX_MULTISIG:\n-        return CombineMultisig(scriptPubKey, checker, vSolutions, sigs1, sigs2);\n+        return Stacks(CombineMultisig(scriptPubKey, checker, vSolutions, sigs1.script, sigs2.script, sigversion));\n+    case TX_WITNESS_V0_SCRIPTHASH:\n+        if (sigs1.witness.empty() || sigs1.witness.back().empty())\n+            return sigs2;\n+        else if (sigs2.witness.empty() || sigs2.witness.back().empty())\n+            return sigs1;\n+        else\n+        {\n+            // Recur to combine:\n+            CScript pubKey2(sigs1.witness.back().begin(), sigs1.witness.back().end());\n+            txnouttype txType2;\n+            vector<valtype> vSolutions2;\n+            Solver(pubKey2, txType2, vSolutions2);\n+            sigs1.witness.pop_back();\n+            sigs1.script = sigs1.witness;\n+            sigs1.witness.clear();\n+            sigs2.witness.pop_back();\n+            sigs2.script = sigs2.witness;\n+            sigs2.witness.clear();\n+            Stacks result = CombineSignatures(pubKey2, checker, txType2, vSolutions2, sigs1, sigs2, SIGVERSION_WITNESS_V0);\n+            result.witness = result.script;\n+            result.script.clear();\n+            result.witness.push_back(valtype(pubKey2.begin(), pubKey2.end()));\n+            return result;\n+        }\n+    default:\n+        return Stacks();\n     }\n-\n-    return CScript();\n }\n \n-CScript CombineSignatures(const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn, const CAmount& amount,\n-                          const CScript& scriptSig1, const CScript& scriptSig2)\n-{\n-    TransactionSignatureChecker checker(&txTo, nIn, amount);\n-    return CombineSignatures(scriptPubKey, checker, scriptSig1, scriptSig2);\n-}\n-\n-CScript CombineSignatures(const CScript& scriptPubKey, const BaseSignatureChecker& checker,\n-                          const CScript& scriptSig1, const CScript& scriptSig2)\n+SignatureData CombineSignatures(const CScript& scriptPubKey, const BaseSignatureChecker& checker,\n+                          const SignatureData& scriptSig1, const SignatureData& scriptSig2)\n {\n     txnouttype txType;\n     vector<vector<unsigned char> > vSolutions;\n     Solver(scriptPubKey, txType, vSolutions);\n \n-    vector<valtype> stack1;\n-    EvalScript(stack1, scriptSig1, SCRIPT_VERIFY_STRICTENC, BaseSignatureChecker(), SIGVERSION_BASE);\n-    vector<valtype> stack2;\n-    EvalScript(stack2, scriptSig2, SCRIPT_VERIFY_STRICTENC, BaseSignatureChecker(), SIGVERSION_BASE);\n-\n-    return CombineSignatures(scriptPubKey, checker, txType, vSolutions, stack1, stack2);\n+    return CombineSignatures(scriptPubKey, checker, txType, vSolutions, Stacks(scriptSig1), Stacks(scriptSig2), SIGVERSION_BASE).Output();\n }\n \n namespace {\n@@ -297,7 +410,7 @@ const BaseSignatureChecker& DummySignatureCreator::Checker() const\n     return dummyChecker;\n }\n \n-bool DummySignatureCreator::CreateSig(std::vector<unsigned char>& vchSig, const CKeyID& keyid, const CScript& scriptCode) const\n+bool DummySignatureCreator::CreateSig(std::vector<unsigned char>& vchSig, const CKeyID& keyid, const CScript& scriptCode, SigVersion sigversion) const\n {\n     // Create a dummy signature that is a valid DER-encoding\n     vchSig.assign(72, '\\000');"
      },
      {
        "sha": "6404b4523ecaa03440242532608929b4b9320242",
        "filename": "src/script/sign.h",
        "status": "modified",
        "additions": 25,
        "deletions": 9,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/605e8473a7ddca13b24a4020c7bd630aa5d374e2/src/script/sign.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/605e8473a7ddca13b24a4020c7bd630aa5d374e2/src/script/sign.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.h?ref=605e8473a7ddca13b24a4020c7bd630aa5d374e2",
        "patch": "@@ -27,7 +27,7 @@ class BaseSignatureCreator {\n     virtual const BaseSignatureChecker& Checker() const =0;\n \n     /** Create a singular (non-script) signature. */\n-    virtual bool CreateSig(std::vector<unsigned char>& vchSig, const CKeyID& keyid, const CScript& scriptCode) const =0;\n+    virtual bool CreateSig(std::vector<unsigned char>& vchSig, const CKeyID& keyid, const CScript& scriptCode, SigVersion sigversion) const =0;\n };\n \n /** A signature creator for transactions. */\n@@ -41,28 +41,44 @@ class TransactionSignatureCreator : public BaseSignatureCreator {\n public:\n     TransactionSignatureCreator(const CKeyStore* keystoreIn, const CTransaction* txToIn, unsigned int nInIn, const CAmount& amountIn, int nHashTypeIn=SIGHASH_ALL);\n     const BaseSignatureChecker& Checker() const { return checker; }\n-    bool CreateSig(std::vector<unsigned char>& vchSig, const CKeyID& keyid, const CScript& scriptCode) const;\n+    bool CreateSig(std::vector<unsigned char>& vchSig, const CKeyID& keyid, const CScript& scriptCode, SigVersion sigversion) const;\n+};\n+\n+class MutableTransactionSignatureCreator : public TransactionSignatureCreator {\n+    CTransaction tx;\n+\n+public:\n+    MutableTransactionSignatureCreator(const CKeyStore* keystoreIn, const CMutableTransaction* txToIn, unsigned int nInIn, const CAmount& amount, int nHashTypeIn) : TransactionSignatureCreator(keystoreIn, &tx, nInIn, amount, nHashTypeIn), tx(*txToIn) {}\n };\n \n /** A signature creator that just produces 72-byte empty signatyres. */\n class DummySignatureCreator : public BaseSignatureCreator {\n public:\n     DummySignatureCreator(const CKeyStore* keystoreIn) : BaseSignatureCreator(keystoreIn) {}\n     const BaseSignatureChecker& Checker() const;\n-    bool CreateSig(std::vector<unsigned char>& vchSig, const CKeyID& keyid, const CScript& scriptCode) const;\n+    bool CreateSig(std::vector<unsigned char>& vchSig, const CKeyID& keyid, const CScript& scriptCode, SigVersion sigversion) const;\n+};\n+\n+struct SignatureData {\n+    CScript scriptSig;\n+    CScriptWitness scriptWitness;\n+\n+    SignatureData() {}\n+    explicit SignatureData(const CScript& script) : scriptSig(script) {}\n };\n \n /** Produce a script signature using a generic signature creator. */\n-bool ProduceSignature(const BaseSignatureCreator& creator, const CScript& scriptPubKey, CScript& scriptSig);\n+bool ProduceSignature(const BaseSignatureCreator& creator, const CScript& scriptPubKey, SignatureData& sigdata);\n \n /** Produce a script signature for a transaction. */\n-bool SignSignature(const CKeyStore& keystore, const CScript& fromPubKey, CMutableTransaction& txTo, unsigned int nIn, int nHashType=SIGHASH_ALL);\n-bool SignSignature(const CKeyStore& keystore, const CTransaction& txFrom, CMutableTransaction& txTo, unsigned int nIn, int nHashType=SIGHASH_ALL);\n+bool SignSignature(const CKeyStore &keystore, const CScript& fromPubKey, CMutableTransaction& txTo, unsigned int nIn, const CAmount& amount, int nHashType);\n+bool SignSignature(const CKeyStore& keystore, const CTransaction& txFrom, CMutableTransaction& txTo, unsigned int nIn, int nHashType);\n \n /** Combine two script signatures using a generic signature checker, intelligently, possibly with OP_0 placeholders. */\n-CScript CombineSignatures(const CScript& scriptPubKey, const BaseSignatureChecker& checker, const CScript& scriptSig1, const CScript& scriptSig2);\n+SignatureData CombineSignatures(const CScript& scriptPubKey, const BaseSignatureChecker& checker, const SignatureData& scriptSig1, const SignatureData& scriptSig2);\n \n-/** Combine two script signatures on transactions. */\n-CScript CombineSignatures(const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn, const CAmount& amount, const CScript& scriptSig1, const CScript& scriptSig2);\n+/** Extract signature data from a transaction, and insert it. */\n+SignatureData DataFromTransaction(const CMutableTransaction& tx, unsigned int nIn);\n+void UpdateTransaction(CMutableTransaction& tx, unsigned int nIn, const SignatureData& data);\n \n #endif // BITCOIN_SCRIPT_SIGN_H"
      },
      {
        "sha": "bb178f49fe9f245a8359b98dc2c0fda0a0052334",
        "filename": "src/script/standard.cpp",
        "status": "modified",
        "additions": 41,
        "deletions": 0,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/605e8473a7ddca13b24a4020c7bd630aa5d374e2/src/script/standard.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/605e8473a7ddca13b24a4020c7bd630aa5d374e2/src/script/standard.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/standard.cpp?ref=605e8473a7ddca13b24a4020c7bd630aa5d374e2",
        "patch": "@@ -31,6 +31,8 @@ const char* GetTxnOutputType(txnouttype t)\n     case TX_SCRIPTHASH: return \"scripthash\";\n     case TX_MULTISIG: return \"multisig\";\n     case TX_NULL_DATA: return \"nulldata\";\n+    case TX_WITNESS_V0_KEYHASH: return \"witness_v0_keyhash\";\n+    case TX_WITNESS_V0_SCRIPTHASH: return \"witness_v0_scripthash\";\n     }\n     return NULL;\n }\n@@ -66,6 +68,22 @@ bool Solver(const CScript& scriptPubKey, txnouttype& typeRet, vector<vector<unsi\n         return true;\n     }\n \n+    int witnessversion;\n+    std::vector<unsigned char> witnessprogram;\n+    if (scriptPubKey.IsWitnessProgram(witnessversion, witnessprogram)) {\n+        if (witnessversion == 0 && witnessprogram.size() == 20) {\n+            typeRet = TX_WITNESS_V0_KEYHASH;\n+            vSolutionsRet.push_back(witnessprogram);\n+            return true;\n+        }\n+        if (witnessversion == 0 && witnessprogram.size() == 32) {\n+            typeRet = TX_WITNESS_V0_SCRIPTHASH;\n+            vSolutionsRet.push_back(witnessprogram);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n     // Provably prunable, data-carrying output\n     //\n     // So long as script passes the IsUnspendable() test and all but the first\n@@ -282,3 +300,26 @@ CScript GetScriptForMultisig(int nRequired, const std::vector<CPubKey>& keys)\n     script << CScript::EncodeOP_N(keys.size()) << OP_CHECKMULTISIG;\n     return script;\n }\n+\n+CScript GetScriptForWitness(const CScript& redeemscript)\n+{\n+    CScript ret;\n+\n+    txnouttype typ;\n+    std::vector<std::vector<unsigned char> > vSolutions;\n+    if (Solver(redeemscript, typ, vSolutions)) {\n+        if (typ == TX_PUBKEY) {\n+            unsigned char h160[20];\n+            CHash160().Write(&vSolutions[0][0], vSolutions[0].size()).Finalize(h160);\n+            ret << OP_0 << std::vector<unsigned char>(&h160[0], &h160[20]);\n+            return ret;\n+        } else if (typ == TX_PUBKEYHASH) {\n+           ret << OP_0 << vSolutions[0];\n+           return ret;\n+        }\n+    }\n+    uint256 hash;\n+    CSHA256().Write(&redeemscript[0], redeemscript.size()).Finalize(hash.begin());\n+    ret << OP_0 << ToByteVector(hash);\n+    return ret;\n+}"
      },
      {
        "sha": "72aaea0b7bebe8e9efa2df6222b70ba9e1f1c77b",
        "filename": "src/script/standard.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/605e8473a7ddca13b24a4020c7bd630aa5d374e2/src/script/standard.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/605e8473a7ddca13b24a4020c7bd630aa5d374e2/src/script/standard.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/standard.h?ref=605e8473a7ddca13b24a4020c7bd630aa5d374e2",
        "patch": "@@ -51,6 +51,8 @@ enum txnouttype\n     TX_SCRIPTHASH,\n     TX_MULTISIG,\n     TX_NULL_DATA,\n+    TX_WITNESS_V0_SCRIPTHASH,\n+    TX_WITNESS_V0_KEYHASH,\n };\n \n class CNoDestination {\n@@ -77,5 +79,6 @@ bool ExtractDestinations(const CScript& scriptPubKey, txnouttype& typeRet, std::\n CScript GetScriptForDestination(const CTxDestination& dest);\n CScript GetScriptForRawPubKey(const CPubKey& pubkey);\n CScript GetScriptForMultisig(int nRequired, const std::vector<CPubKey>& keys);\n+CScript GetScriptForWitness(const CScript& redeemscript);\n \n #endif // BITCOIN_SCRIPT_STANDARD_H"
      },
      {
        "sha": "a8c5f95ace4affae0f1bea80e2d664e7aa78dec1",
        "filename": "src/test/DoS_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/605e8473a7ddca13b24a4020c7bd630aa5d374e2/src/test/DoS_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/605e8473a7ddca13b24a4020c7bd630aa5d374e2/src/test/DoS_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/DoS_tests.cpp?ref=605e8473a7ddca13b24a4020c7bd630aa5d374e2",
        "patch": "@@ -148,7 +148,7 @@ BOOST_AUTO_TEST_CASE(DoS_mapOrphans)\n         tx.vout.resize(1);\n         tx.vout[0].nValue = 1*CENT;\n         tx.vout[0].scriptPubKey = GetScriptForDestination(key.GetPubKey().GetID());\n-        SignSignature(keystore, txPrev, tx, 0);\n+        SignSignature(keystore, txPrev, tx, 0, SIGHASH_ALL);\n \n         AddOrphanTx(tx, i);\n     }\n@@ -168,7 +168,7 @@ BOOST_AUTO_TEST_CASE(DoS_mapOrphans)\n             tx.vin[j].prevout.n = j;\n             tx.vin[j].prevout.hash = txPrev.GetHash();\n         }\n-        SignSignature(keystore, txPrev, tx, 0);\n+        SignSignature(keystore, txPrev, tx, 0, SIGHASH_ALL);\n         // Re-use same signature for other inputs\n         // (they don't have to be valid for this test)\n         for (unsigned int j = 1; j < tx.vin.size(); j++)"
      },
      {
        "sha": "581b0cee1ec876d37596b5c5be878a8fd5ad0c86",
        "filename": "src/test/multisig_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/605e8473a7ddca13b24a4020c7bd630aa5d374e2/src/test/multisig_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/605e8473a7ddca13b24a4020c7bd630aa5d374e2/src/test/multisig_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/multisig_tests.cpp?ref=605e8473a7ddca13b24a4020c7bd630aa5d374e2",
        "patch": "@@ -303,7 +303,7 @@ BOOST_AUTO_TEST_CASE(multisig_Sign)\n \n     for (int i = 0; i < 3; i++)\n     {\n-        BOOST_CHECK_MESSAGE(SignSignature(keystore, txFrom, txTo[i], 0), strprintf(\"SignSignature %d\", i));\n+        BOOST_CHECK_MESSAGE(SignSignature(keystore, txFrom, txTo[i], 0, SIGHASH_ALL), strprintf(\"SignSignature %d\", i));\n     }\n }\n "
      },
      {
        "sha": "5224b57ca4479f100472afd943d81af29e59aecd",
        "filename": "src/test/script_P2SH_tests.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 5,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/605e8473a7ddca13b24a4020c7bd630aa5d374e2/src/test/script_P2SH_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/605e8473a7ddca13b24a4020c7bd630aa5d374e2/src/test/script_P2SH_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_P2SH_tests.cpp?ref=605e8473a7ddca13b24a4020c7bd630aa5d374e2",
        "patch": "@@ -2,6 +2,7 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n+#include \"core_io.h\"\n #include \"key.h\"\n #include \"keystore.h\"\n #include \"main.h\"\n@@ -102,7 +103,7 @@ BOOST_AUTO_TEST_CASE(sign)\n     }\n     for (int i = 0; i < 8; i++)\n     {\n-        BOOST_CHECK_MESSAGE(SignSignature(keystore, txFrom, txTo[i], 0), strprintf(\"SignSignature %d\", i));\n+        BOOST_CHECK_MESSAGE(SignSignature(keystore, txFrom, txTo[i], 0, SIGHASH_ALL), strprintf(\"SignSignature %d\", i));\n     }\n     // All of the above should be OK, and the txTos have valid signatures\n     // Check to make sure signature verification fails if we use the wrong ScriptSig:\n@@ -197,7 +198,7 @@ BOOST_AUTO_TEST_CASE(set)\n     }\n     for (int i = 0; i < 4; i++)\n     {\n-        BOOST_CHECK_MESSAGE(SignSignature(keystore, txFrom, txTo[i], 0), strprintf(\"SignSignature %d\", i));\n+        BOOST_CHECK_MESSAGE(SignSignature(keystore, txFrom, txTo[i], 0, SIGHASH_ALL), strprintf(\"SignSignature %d\", i));\n         BOOST_CHECK_MESSAGE(IsStandardTx(txTo[i], reason), strprintf(\"txTo[%d].IsStandard\", i));\n     }\n }\n@@ -326,9 +327,9 @@ BOOST_AUTO_TEST_CASE(AreInputsStandard)\n         txTo.vin[i].prevout.n = i;\n         txTo.vin[i].prevout.hash = txFrom.GetHash();\n     }\n-    BOOST_CHECK(SignSignature(keystore, txFrom, txTo, 0));\n-    BOOST_CHECK(SignSignature(keystore, txFrom, txTo, 1));\n-    BOOST_CHECK(SignSignature(keystore, txFrom, txTo, 2));\n+    BOOST_CHECK(SignSignature(keystore, txFrom, txTo, 0, SIGHASH_ALL));\n+    BOOST_CHECK(SignSignature(keystore, txFrom, txTo, 1, SIGHASH_ALL));\n+    BOOST_CHECK(SignSignature(keystore, txFrom, txTo, 2, SIGHASH_ALL));\n     // SignSignature doesn't know how to sign these. We're\n     // not testing validating signatures, so just create\n     // dummy signatures that DO include the correct P2SH scripts:"
      },
      {
        "sha": "1d69194c3e89ca4b7813a3ed39b5d43cb0afa01e",
        "filename": "src/test/script_tests.cpp",
        "status": "modified",
        "additions": 50,
        "deletions": 50,
        "changes": 100,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/605e8473a7ddca13b24a4020c7bd630aa5d374e2/src/test/script_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/605e8473a7ddca13b24a4020c7bd630aa5d374e2/src/test/script_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_tests.cpp?ref=605e8473a7ddca13b24a4020c7bd630aa5d374e2",
        "patch": "@@ -152,16 +152,16 @@ void DoTest(const CScript& scriptPubKey, const CScript& scriptSig, int flags, co\n         flags |= SCRIPT_VERIFY_WITNESS;\n     }\n     ScriptError err;\n-    CMutableTransaction tx = BuildSpendingTransaction(scriptSig, BuildCreditingTransaction(scriptPubKey));\n+    CMutableTransaction txCredit = BuildCreditingTransaction(scriptPubKey);\n+    CMutableTransaction tx = BuildSpendingTransaction(scriptSig, txCredit);\n     CMutableTransaction tx2 = tx;\n-    static const CAmount amountZero = 0;\n-    BOOST_CHECK_MESSAGE(VerifyScript(scriptSig, scriptPubKey, NULL, flags, MutableTransactionSignatureChecker(&tx, 0, amountZero), &err) == expect, message);\n+    BOOST_CHECK_MESSAGE(VerifyScript(scriptSig, scriptPubKey, NULL, flags, MutableTransactionSignatureChecker(&tx, 0, txCredit.vout[0].nValue), &err) == expect, message);\n     BOOST_CHECK_MESSAGE(err == scriptError, std::string(FormatScriptError(err)) + \" where \" + std::string(FormatScriptError((ScriptError_t)scriptError)) + \" expected: \" + message);\n #if defined(HAVE_CONSENSUS_LIB)\n     CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n     stream << tx2;\n     if (flags & bitcoinconsensus_SCRIPT_FLAGS_VERIFY_WITNESS) {\n-        BOOST_CHECK_MESSAGE(bitcoinconsensus_verify_script_with_amount(begin_ptr(scriptPubKey), scriptPubKey.size(), amountZero, (const unsigned char*)&stream[0], stream.size(), 0, flags, NULL) == expect, message);\n+        BOOST_CHECK_MESSAGE(bitcoinconsensus_verify_script_with_amount(begin_ptr(scriptPubKey), scriptPubKey.size(), txCredit.vout[0].nValue, (const unsigned char*)&stream[0], stream.size(), 0, flags, NULL) == expect, message);\n     } else {\n         BOOST_CHECK_MESSAGE(bitcoinconsensus_verify_script_with_amount(begin_ptr(scriptPubKey), scriptPubKey.size(), 0, (const unsigned char*)&stream[0], stream.size(), 0, flags, NULL) == expect, message);\n         BOOST_CHECK_MESSAGE(bitcoinconsensus_verify_script(begin_ptr(scriptPubKey), scriptPubKey.size(), (const unsigned char*)&stream[0], stream.size(), 0, flags, NULL) == expect,message);\n@@ -896,7 +896,7 @@ BOOST_AUTO_TEST_CASE(script_CHECKMULTISIG23)\n BOOST_AUTO_TEST_CASE(script_combineSigs)\n {\n     // Test the CombineSignatures function\n-    CAmount amount;\n+    CAmount amount = 0;\n     CBasicKeyStore keystore;\n     vector<CKey> keys;\n     vector<CPubKey> pubkeys;\n@@ -914,50 +914,50 @@ BOOST_AUTO_TEST_CASE(script_combineSigs)\n     CScript& scriptPubKey = txFrom.vout[0].scriptPubKey;\n     CScript& scriptSig = txTo.vin[0].scriptSig;\n \n-    CScript empty;\n-    CScript combined = CombineSignatures(scriptPubKey, txTo, 0, amount, empty, empty);\n-    BOOST_CHECK(combined.empty());\n+    SignatureData empty;\n+    SignatureData combined = CombineSignatures(scriptPubKey, MutableTransactionSignatureChecker(&txTo, 0, amount), empty, empty);\n+    BOOST_CHECK(combined.scriptSig.empty());\n \n     // Single signature case:\n-    SignSignature(keystore, txFrom, txTo, 0); // changes scriptSig\n-    combined = CombineSignatures(scriptPubKey, txTo, 0, amount, scriptSig, empty);\n-    BOOST_CHECK(combined == scriptSig);\n-    combined = CombineSignatures(scriptPubKey, txTo, 0, amount, empty, scriptSig);\n-    BOOST_CHECK(combined == scriptSig);\n+    SignSignature(keystore, txFrom, txTo, 0, SIGHASH_ALL); // changes scriptSig\n+    combined = CombineSignatures(scriptPubKey, MutableTransactionSignatureChecker(&txTo, 0, amount), SignatureData(scriptSig), empty);\n+    BOOST_CHECK(combined.scriptSig == scriptSig);\n+    combined = CombineSignatures(scriptPubKey, MutableTransactionSignatureChecker(&txTo, 0, amount), empty, SignatureData(scriptSig));\n+    BOOST_CHECK(combined.scriptSig == scriptSig);\n     CScript scriptSigCopy = scriptSig;\n     // Signing again will give a different, valid signature:\n-    SignSignature(keystore, txFrom, txTo, 0);\n-    combined = CombineSignatures(scriptPubKey, txTo, 0, amount, scriptSigCopy, scriptSig);\n-    BOOST_CHECK(combined == scriptSigCopy || combined == scriptSig);\n+    SignSignature(keystore, txFrom, txTo, 0, SIGHASH_ALL);\n+    combined = CombineSignatures(scriptPubKey, MutableTransactionSignatureChecker(&txTo, 0, amount), SignatureData(scriptSigCopy), SignatureData(scriptSig));\n+    BOOST_CHECK(combined.scriptSig == scriptSigCopy || combined.scriptSig == scriptSig);\n \n     // P2SH, single-signature case:\n     CScript pkSingle; pkSingle << ToByteVector(keys[0].GetPubKey()) << OP_CHECKSIG;\n     keystore.AddCScript(pkSingle);\n     scriptPubKey = GetScriptForDestination(CScriptID(pkSingle));\n-    SignSignature(keystore, txFrom, txTo, 0);\n-    combined = CombineSignatures(scriptPubKey, txTo, 0, amount, scriptSig, empty);\n-    BOOST_CHECK(combined == scriptSig);\n-    combined = CombineSignatures(scriptPubKey, txTo, 0, amount, empty, scriptSig);\n-    BOOST_CHECK(combined == scriptSig);\n+    SignSignature(keystore, txFrom, txTo, 0, SIGHASH_ALL);\n+    combined = CombineSignatures(scriptPubKey, MutableTransactionSignatureChecker(&txTo, 0, amount), SignatureData(scriptSig), empty);\n+    BOOST_CHECK(combined.scriptSig == scriptSig);\n+    combined = CombineSignatures(scriptPubKey, MutableTransactionSignatureChecker(&txTo, 0, amount), empty, SignatureData(scriptSig));\n+    BOOST_CHECK(combined.scriptSig == scriptSig);\n     scriptSigCopy = scriptSig;\n-    SignSignature(keystore, txFrom, txTo, 0);\n-    combined = CombineSignatures(scriptPubKey, txTo, 0, amount, scriptSigCopy, scriptSig);\n-    BOOST_CHECK(combined == scriptSigCopy || combined == scriptSig);\n+    SignSignature(keystore, txFrom, txTo, 0, SIGHASH_ALL);\n+    combined = CombineSignatures(scriptPubKey, MutableTransactionSignatureChecker(&txTo, 0, amount), SignatureData(scriptSigCopy), SignatureData(scriptSig));\n+    BOOST_CHECK(combined.scriptSig == scriptSigCopy || combined.scriptSig == scriptSig);\n     // dummy scriptSigCopy with placeholder, should always choose non-placeholder:\n-    scriptSigCopy = CScript() << OP_0 << vector<unsigned char>(pkSingle.begin(), pkSingle.end());\n-    combined = CombineSignatures(scriptPubKey, txTo, 0, amount, scriptSigCopy, scriptSig);\n-    BOOST_CHECK(combined == scriptSig);\n-    combined = CombineSignatures(scriptPubKey, txTo, 0, amount, scriptSig, scriptSigCopy);\n-    BOOST_CHECK(combined == scriptSig);\n+    scriptSigCopy = CScript() << OP_0 << std::vector<unsigned char>(pkSingle.begin(), pkSingle.end());\n+    combined = CombineSignatures(scriptPubKey, MutableTransactionSignatureChecker(&txTo, 0, amount), SignatureData(scriptSigCopy), SignatureData(scriptSig));\n+    BOOST_CHECK(combined.scriptSig == scriptSig);\n+    combined = CombineSignatures(scriptPubKey, MutableTransactionSignatureChecker(&txTo, 0, amount), SignatureData(scriptSig), SignatureData(scriptSigCopy));\n+    BOOST_CHECK(combined.scriptSig == scriptSig);\n \n     // Hardest case:  Multisig 2-of-3\n     scriptPubKey = GetScriptForMultisig(2, pubkeys);\n     keystore.AddCScript(scriptPubKey);\n-    SignSignature(keystore, txFrom, txTo, 0);\n-    combined = CombineSignatures(scriptPubKey, txTo, 0, amount, scriptSig, empty);\n-    BOOST_CHECK(combined == scriptSig);\n-    combined = CombineSignatures(scriptPubKey, txTo, 0, amount, empty, scriptSig);\n-    BOOST_CHECK(combined == scriptSig);\n+    SignSignature(keystore, txFrom, txTo, 0, SIGHASH_ALL);\n+    combined = CombineSignatures(scriptPubKey, MutableTransactionSignatureChecker(&txTo, 0, amount), SignatureData(scriptSig), empty);\n+    BOOST_CHECK(combined.scriptSig == scriptSig);\n+    combined = CombineSignatures(scriptPubKey, MutableTransactionSignatureChecker(&txTo, 0, amount), empty, SignatureData(scriptSig));\n+    BOOST_CHECK(combined.scriptSig == scriptSig);\n \n     // A couple of partially-signed versions:\n     vector<unsigned char> sig1;\n@@ -985,22 +985,22 @@ BOOST_AUTO_TEST_CASE(script_combineSigs)\n     CScript complete13 = CScript() << OP_0 << sig1 << sig3;\n     CScript complete23 = CScript() << OP_0 << sig2 << sig3;\n \n-    combined = CombineSignatures(scriptPubKey, txTo, 0, amount, partial1a, partial1b);\n-    BOOST_CHECK(combined == partial1a);\n-    combined = CombineSignatures(scriptPubKey, txTo, 0, amount, partial1a, partial2a);\n-    BOOST_CHECK(combined == complete12);\n-    combined = CombineSignatures(scriptPubKey, txTo, 0, amount, partial2a, partial1a);\n-    BOOST_CHECK(combined == complete12);\n-    combined = CombineSignatures(scriptPubKey, txTo, 0, amount, partial1b, partial2b);\n-    BOOST_CHECK(combined == complete12);\n-    combined = CombineSignatures(scriptPubKey, txTo, 0, amount, partial3b, partial1b);\n-    BOOST_CHECK(combined == complete13);\n-    combined = CombineSignatures(scriptPubKey, txTo, 0, amount, partial2a, partial3a);\n-    BOOST_CHECK(combined == complete23);\n-    combined = CombineSignatures(scriptPubKey, txTo, 0, amount, partial3b, partial2b);\n-    BOOST_CHECK(combined == complete23);\n-    combined = CombineSignatures(scriptPubKey, txTo, 0, amount, partial3b, partial3a);\n-    BOOST_CHECK(combined == partial3c);\n+    combined = CombineSignatures(scriptPubKey, MutableTransactionSignatureChecker(&txTo, 0, amount), SignatureData(partial1a), SignatureData(partial1b));\n+    BOOST_CHECK(combined.scriptSig == partial1a);\n+    combined = CombineSignatures(scriptPubKey, MutableTransactionSignatureChecker(&txTo, 0, amount), SignatureData(partial1a), SignatureData(partial2a));\n+    BOOST_CHECK(combined.scriptSig == complete12);\n+    combined = CombineSignatures(scriptPubKey, MutableTransactionSignatureChecker(&txTo, 0, amount), SignatureData(partial2a), SignatureData(partial1a));\n+    BOOST_CHECK(combined.scriptSig == complete12);\n+    combined = CombineSignatures(scriptPubKey, MutableTransactionSignatureChecker(&txTo, 0, amount), SignatureData(partial1b), SignatureData(partial2b));\n+    BOOST_CHECK(combined.scriptSig == complete12);\n+    combined = CombineSignatures(scriptPubKey, MutableTransactionSignatureChecker(&txTo, 0, amount), SignatureData(partial3b), SignatureData(partial1b));\n+    BOOST_CHECK(combined.scriptSig == complete13);\n+    combined = CombineSignatures(scriptPubKey, MutableTransactionSignatureChecker(&txTo, 0, amount), SignatureData(partial2a), SignatureData(partial3a));\n+    BOOST_CHECK(combined.scriptSig == complete23);\n+    combined = CombineSignatures(scriptPubKey, MutableTransactionSignatureChecker(&txTo, 0, amount), SignatureData(partial3b), SignatureData(partial2b));\n+    BOOST_CHECK(combined.scriptSig == complete23);\n+    combined = CombineSignatures(scriptPubKey, MutableTransactionSignatureChecker(&txTo, 0, amount), SignatureData(partial3b), SignatureData(partial3a));\n+    BOOST_CHECK(combined.scriptSig == partial3c);\n }\n \n BOOST_AUTO_TEST_CASE(script_standard_push)"
      },
      {
        "sha": "b36c6f0259f68bb2cf268e1e1ddc95d981d40895",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 3,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/605e8473a7ddca13b24a4020c7bd630aa5d374e2/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/605e8473a7ddca13b24a4020c7bd630aa5d374e2/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=605e8473a7ddca13b24a4020c7bd630aa5d374e2",
        "patch": "@@ -2334,17 +2334,20 @@ bool CWallet::CreateTransaction(const vector<CRecipient>& vecSend, CWalletTx& wt\n                 {\n                     bool signSuccess;\n                     const CScript& scriptPubKey = coin.first->vout[coin.second].scriptPubKey;\n-                    CScript& scriptSigRes = txNew.vin[nIn].scriptSig;\n+                    SignatureData sigdata;\n                     if (sign)\n-                        signSuccess = ProduceSignature(TransactionSignatureCreator(this, &txNewConst, nIn, SIGHASH_ALL), scriptPubKey, scriptSigRes);\n+                        signSuccess = ProduceSignature(TransactionSignatureCreator(this, &txNewConst, nIn, coin.first->vout[coin.second].nValue, SIGHASH_ALL), scriptPubKey, sigdata);\n                     else\n-                        signSuccess = ProduceSignature(DummySignatureCreator(this), scriptPubKey, scriptSigRes);\n+                        signSuccess = ProduceSignature(DummySignatureCreator(this), scriptPubKey, sigdata);\n \n                     if (!signSuccess)\n                     {\n                         strFailReason = _(\"Signing transaction failed\");\n                         return false;\n+                    } else {\n+                        UpdateTransaction(txNew, nIn, sigdata);\n                     }\n+\n                     nIn++;\n                 }\n \n@@ -2354,6 +2357,7 @@ bool CWallet::CreateTransaction(const vector<CRecipient>& vecSend, CWalletTx& wt\n                 if (!sign) {\n                     BOOST_FOREACH (CTxIn& vin, txNew.vin)\n                         vin.scriptSig = CScript();\n+                    txNew.wit.SetNull();\n                 }\n \n                 // Embed the constructed transaction data in wtxNew."
      }
    ]
  },
  {
    "sha": "f4691ab3a9d4f3321afa024984c03fe6e10bfdbc",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmNDY5MWFiM2E5ZDRmMzMyMWFmYTAyNDk4NGMwM2ZlNmUxMGJmZGJj",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2015-12-30T00:13:08Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-06-22T13:43:01Z"
      },
      "message": "[RPC] Add wallet support for witness transactions (using P2SH)\n\nIncludes support for pushkeyhash wit v0 by Alex Morcos.",
      "tree": {
        "sha": "aa9a07a6686ab5ed4d570f471bfe530634c11425",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/aa9a07a6686ab5ed4d570f471bfe530634c11425"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f4691ab3a9d4f3321afa024984c03fe6e10bfdbc",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f4691ab3a9d4f3321afa024984c03fe6e10bfdbc",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f4691ab3a9d4f3321afa024984c03fe6e10bfdbc",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f4691ab3a9d4f3321afa024984c03fe6e10bfdbc/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "605e8473a7ddca13b24a4020c7bd630aa5d374e2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/605e8473a7ddca13b24a4020c7bd630aa5d374e2",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/605e8473a7ddca13b24a4020c7bd630aa5d374e2"
      }
    ],
    "stats": {
      "total": 118,
      "additions": 118,
      "deletions": 0
    },
    "files": [
      {
        "sha": "f2a29416e675dd0f715d19c257903fbc43a57247",
        "filename": "src/rpc/misc.cpp",
        "status": "modified",
        "additions": 38,
        "deletions": 0,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f4691ab3a9d4f3321afa024984c03fe6e10bfdbc/src/rpc/misc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f4691ab3a9d4f3321afa024984c03fe6e10bfdbc/src/rpc/misc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/misc.cpp?ref=f4691ab3a9d4f3321afa024984c03fe6e10bfdbc",
        "patch": "@@ -312,6 +312,43 @@ UniValue createmultisig(const UniValue& params, bool fHelp)\n     return result;\n }\n \n+UniValue createwitnessaddress(const UniValue& params, bool fHelp)\n+{\n+    if (fHelp || params.size() < 1 || params.size() > 1)\n+    {\n+        string msg = \"createwitnessaddress \\\"script\\\"\\n\"\n+            \"\\nCreates a witness address for a particular script.\\n\"\n+            \"It returns a json object with the address and witness script.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"script\\\"       (string, required) A hex encoded script\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"address\\\":\\\"multisigaddress\\\",  (string) The value of the new address (P2SH of witness script).\\n\"\n+            \"  \\\"witnessScript\\\":\\\"script\\\"      (string) The string value of the hex-encoded witness script.\\n\"\n+            \"}\\n\"\n+        ;\n+        throw runtime_error(msg);\n+    }\n+\n+    if (!IsHex(params[0].get_str())) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Script must be hex-encoded\");\n+    }\n+\n+    std::vector<unsigned char> code = ParseHex(params[0].get_str());\n+    CScript script(code.begin(), code.end());\n+    CScript witscript = GetScriptForWitness(script);\n+    CScriptID witscriptid(witscript);\n+    CBitcoinAddress address(witscriptid);\n+\n+    UniValue result(UniValue::VOBJ);\n+    result.push_back(Pair(\"address\", address.ToString()));\n+    result.push_back(Pair(\"witnessScript\", HexStr(witscript.begin(), witscript.end())));\n+\n+    return result;\n+}\n+\n UniValue verifymessage(const UniValue& params, bool fHelp)\n {\n     if (fHelp || params.size() != 3)\n@@ -445,6 +482,7 @@ static const CRPCCommand commands[] =\n     { \"control\",            \"getinfo\",                &getinfo,                true  }, /* uses wallet if enabled */\n     { \"util\",               \"validateaddress\",        &validateaddress,        true  }, /* uses wallet if enabled */\n     { \"util\",               \"createmultisig\",         &createmultisig,         true  },\n+    { \"util\",               \"createwitnessaddress\",   &createwitnessaddress,   true  },\n     { \"util\",               \"verifymessage\",          &verifymessage,          true  },\n     { \"util\",               \"signmessagewithprivkey\", &signmessagewithprivkey, true  },\n "
      },
      {
        "sha": "afbb9a1113f48a40fca738cf3320465340024115",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 80,
        "deletions": 0,
        "changes": 80,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f4691ab3a9d4f3321afa024984c03fe6e10bfdbc/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f4691ab3a9d4f3321afa024984c03fe6e10bfdbc/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=f4691ab3a9d4f3321afa024984c03fe6e10bfdbc",
        "patch": "@@ -1011,6 +1011,85 @@ UniValue addmultisigaddress(const UniValue& params, bool fHelp)\n     return CBitcoinAddress(innerID).ToString();\n }\n \n+class Witnessifier : public boost::static_visitor<bool>\n+{\n+public:\n+    CScriptID result;\n+\n+    bool operator()(const CNoDestination &dest) const { return false; }\n+\n+    bool operator()(const CKeyID &keyID) {\n+        CPubKey pubkey;\n+        if (pwalletMain && pwalletMain->GetPubKey(keyID, pubkey)) {\n+            CScript basescript;\n+            basescript << ToByteVector(pubkey) << OP_CHECKSIG;\n+            CScript witscript = GetScriptForWitness(basescript);\n+            pwalletMain->AddCScript(witscript);\n+            result = CScriptID(witscript);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    bool operator()(const CScriptID &scriptID) {\n+        CScript subscript;\n+        if (pwalletMain && pwalletMain->GetCScript(scriptID, subscript)) {\n+            int witnessversion;\n+            std::vector<unsigned char> witprog;\n+            if (subscript.IsWitnessProgram(witnessversion, witprog)) {\n+                result = scriptID;\n+                return true;\n+            }\n+            CScript witscript = GetScriptForWitness(subscript);\n+            pwalletMain->AddCScript(witscript);\n+            result = CScriptID(witscript);\n+            return true;\n+        }\n+        return false;\n+    }\n+};\n+\n+UniValue addwitnessaddress(const UniValue& params, bool fHelp)\n+{\n+    if (!EnsureWalletIsAvailable(fHelp))\n+        return NullUniValue;\n+\n+    if (fHelp || params.size() < 1 || params.size() > 1)\n+    {\n+        string msg = \"addwitnessaddress \\\"address\\\"\\n\"\n+            \"\\nAdd a witness address for a script (with pubkey or redeemscript known).\\n\"\n+            \"It returns the witness script.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"address\\\"       (string, required) An address known to the wallet\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"\\\"witnessaddress\\\",  (string) The value of the new address (P2SH of witness script).\\n\"\n+            \"}\\n\"\n+        ;\n+        throw runtime_error(msg);\n+    }\n+\n+    {\n+        LOCK(cs_main);\n+        if (!IsWitnessEnabled(chainActive.Tip(), Params().GetConsensus())) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Segregated witness not enabled on network\");\n+        }\n+    }\n+\n+    CBitcoinAddress address(params[0].get_str());\n+    if (!address.IsValid())\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid Bitcoin address\");\n+\n+    Witnessifier w;\n+    CTxDestination dest = address.Get();\n+    bool ret = boost::apply_visitor(w, dest);\n+    if (!ret) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Public key or redeemscript not known to wallet\");\n+    }\n+\n+    return CBitcoinAddress(w.result).ToString();\n+}\n \n struct tallyitem\n {\n@@ -2491,6 +2570,7 @@ static const CRPCCommand commands[] =\n     { \"hidden\",             \"resendwallettransactions\", &resendwallettransactions, true  },\n     { \"wallet\",             \"abandontransaction\",       &abandontransaction,       false },\n     { \"wallet\",             \"addmultisigaddress\",       &addmultisigaddress,       true  },\n+    { \"wallet\",             \"addwitnessaddress\",        &addwitnessaddress,        true  },\n     { \"wallet\",             \"backupwallet\",             &backupwallet,             true  },\n     { \"wallet\",             \"dumpprivkey\",              &dumpprivkey,              true  },\n     { \"wallet\",             \"dumpwallet\",               &dumpwallet,               true  },"
      }
    ]
  },
  {
    "sha": "745eb678ef5d52c74edcd9c322ebd1f3232a9310",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3NDVlYjY3OGVmNWQ1MmM3NGVkY2Q5YzMyMmViZDFmMzIzMmE5MzEw",
    "commit": {
      "author": {
        "name": "NicolasDorier",
        "email": "nicolas.dorier@gmail.com",
        "date": "2016-04-10T06:59:23Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-06-22T13:43:01Z"
      },
      "message": "[RPC] signrawtransaction can sign P2WSH",
      "tree": {
        "sha": "fa08a8303b9f25efb19b5fa72cde264d276e2d48",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fa08a8303b9f25efb19b5fa72cde264d276e2d48"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/745eb678ef5d52c74edcd9c322ebd1f3232a9310",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/745eb678ef5d52c74edcd9c322ebd1f3232a9310",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/745eb678ef5d52c74edcd9c322ebd1f3232a9310",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/745eb678ef5d52c74edcd9c322ebd1f3232a9310/comments",
    "author": {
      "login": "NicolasDorier",
      "id": 3020646,
      "node_id": "MDQ6VXNlcjMwMjA2NDY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3020646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/NicolasDorier",
      "html_url": "https://github.com/NicolasDorier",
      "followers_url": "https://api.github.com/users/NicolasDorier/followers",
      "following_url": "https://api.github.com/users/NicolasDorier/following{/other_user}",
      "gists_url": "https://api.github.com/users/NicolasDorier/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/NicolasDorier/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/NicolasDorier/subscriptions",
      "organizations_url": "https://api.github.com/users/NicolasDorier/orgs",
      "repos_url": "https://api.github.com/users/NicolasDorier/repos",
      "events_url": "https://api.github.com/users/NicolasDorier/events{/privacy}",
      "received_events_url": "https://api.github.com/users/NicolasDorier/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f4691ab3a9d4f3321afa024984c03fe6e10bfdbc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f4691ab3a9d4f3321afa024984c03fe6e10bfdbc",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f4691ab3a9d4f3321afa024984c03fe6e10bfdbc"
      }
    ],
    "stats": {
      "total": 15,
      "additions": 12,
      "deletions": 3
    },
    "files": [
      {
        "sha": "8e8ac47455cbe8211f2bf5bffa7de979c1b0264f",
        "filename": "src/bitcoin-tx.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/745eb678ef5d52c74edcd9c322ebd1f3232a9310/src/bitcoin-tx.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/745eb678ef5d52c74edcd9c322ebd1f3232a9310/src/bitcoin-tx.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-tx.cpp?ref=745eb678ef5d52c74edcd9c322ebd1f3232a9310",
        "patch": "@@ -454,7 +454,7 @@ static void MutateTxSign(CMutableTransaction& tx, const string& flagStr)\n \n             // if redeemScript given and private keys given,\n             // add redeemScript to the tempKeystore so it can be signed:\n-            if (fGivenKeys && scriptPubKey.IsPayToScriptHash() &&\n+            if (fGivenKeys && (scriptPubKey.IsPayToScriptHash() || scriptPubKey.IsPayToWitnessScriptHash()) &&\n                 prevOut.exists(\"redeemScript\")) {\n                 UniValue v = prevOut[\"redeemScript\"];\n                 vector<unsigned char> rsData(ParseHexUV(v, \"redeemScript\"));"
      },
      {
        "sha": "3270cd384f4b63605c53010008a45175402aa23c",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/745eb678ef5d52c74edcd9c322ebd1f3232a9310/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/745eb678ef5d52c74edcd9c322ebd1f3232a9310/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=745eb678ef5d52c74edcd9c322ebd1f3232a9310",
        "patch": "@@ -592,7 +592,7 @@ UniValue signrawtransaction(const UniValue& params, bool fHelp)\n             \"         \\\"txid\\\":\\\"id\\\",             (string, required) The transaction id\\n\"\n             \"         \\\"vout\\\":n,                  (numeric, required) The output number\\n\"\n             \"         \\\"scriptPubKey\\\": \\\"hex\\\",   (string, required) script key\\n\"\n-            \"         \\\"redeemScript\\\": \\\"hex\\\",   (string, required for P2SH) redeem script\\n\"\n+            \"         \\\"redeemScript\\\": \\\"hex\\\",   (string, required for P2SH or P2WSH) redeem script\\n\"\n             \"         \\\"amount\\\": value            (numeric, required) The amount spent\\n\"\n             \"       }\\n\"\n             \"       ,...\\n\"\n@@ -744,7 +744,7 @@ UniValue signrawtransaction(const UniValue& params, bool fHelp)\n \n             // if redeemScript given and not using the local wallet (private keys\n             // given), add redeemScript to the tempKeystore so it can be signed:\n-            if (fGivenKeys && scriptPubKey.IsPayToScriptHash()) {\n+            if (fGivenKeys && (scriptPubKey.IsPayToScriptHash() || scriptPubKey.IsPayToWitnessScriptHash())) {\n                 RPCTypeCheckObj(prevOut,\n                     {\n                         {\"txid\", UniValueType(UniValue::VSTR)},"
      },
      {
        "sha": "da551c23ee678570447fbd79dc7c617652b22a4e",
        "filename": "src/script/script.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/745eb678ef5d52c74edcd9c322ebd1f3232a9310/src/script/script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/745eb678ef5d52c74edcd9c322ebd1f3232a9310/src/script/script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script.cpp?ref=745eb678ef5d52c74edcd9c322ebd1f3232a9310",
        "patch": "@@ -210,6 +210,14 @@ bool CScript::IsPayToScriptHash() const\n             (*this)[22] == OP_EQUAL);\n }\n \n+bool CScript::IsPayToWitnessScriptHash() const\n+{\n+    // Extra-fast test for pay-to-witness-script-hash CScripts:\n+    return (this->size() == 34 &&\n+            (*this)[0] == OP_0 &&\n+            (*this)[1] == 0x20);\n+}\n+\n // A witness program is any valid CScript that consists of a 1-byte push opcode\n // followed by a data push between 2 and 40 bytes.\n bool CScript::IsWitnessProgram(int& version, std::vector<unsigned char>& program) const"
      },
      {
        "sha": "71af3754bcd17aec2bba391c74a7430d3d9ea851",
        "filename": "src/script/script.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/745eb678ef5d52c74edcd9c322ebd1f3232a9310/src/script/script.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/745eb678ef5d52c74edcd9c322ebd1f3232a9310/src/script/script.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script.h?ref=745eb678ef5d52c74edcd9c322ebd1f3232a9310",
        "patch": "@@ -621,6 +621,7 @@ class CScript : public CScriptBase\n     unsigned int GetSigOpCount(const CScript& scriptSig) const;\n \n     bool IsPayToScriptHash() const;\n+    bool IsPayToWitnessScriptHash() const;\n     bool IsWitnessProgram(int& version, std::vector<unsigned char>& program) const;\n \n     /** Called by IsStandardTx and P2SH/BIP62 VerifyScript (which makes it consensus-critical). */"
      }
    ]
  },
  {
    "sha": "978e2004ad659ad216d820dbd79e212e276405f4",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5NzhlMjAwNGFkNjU5YWQyMTZkODIwZGJkNzllMjEyZTI3NjQwNWY0",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-03-31T12:43:46Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-06-22T13:43:01Z"
      },
      "message": "--- [SEGWIT] begin: tests ---",
      "tree": {
        "sha": "fa08a8303b9f25efb19b5fa72cde264d276e2d48",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fa08a8303b9f25efb19b5fa72cde264d276e2d48"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/978e2004ad659ad216d820dbd79e212e276405f4",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/978e2004ad659ad216d820dbd79e212e276405f4",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/978e2004ad659ad216d820dbd79e212e276405f4",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/978e2004ad659ad216d820dbd79e212e276405f4/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "745eb678ef5d52c74edcd9c322ebd1f3232a9310",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/745eb678ef5d52c74edcd9c322ebd1f3232a9310",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/745eb678ef5d52c74edcd9c322ebd1f3232a9310"
      }
    ],
    "stats": {
      "total": 0,
      "additions": 0,
      "deletions": 0
    },
    "files": []
  },
  {
    "sha": "0aa92074516c37a10d4150d68918e20db91289a5",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowYWE5MjA3NDUxNmMzN2ExMGQ0MTUwZDY4OTE4ZTIwZGI5MTI4OWE1",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2015-11-20T15:22:47Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-06-22T13:43:01Z"
      },
      "message": "[qa] Witness version 0 signing unit tests",
      "tree": {
        "sha": "559e05c8f969c6b60646f7d193ebcf3137ae9505",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/559e05c8f969c6b60646f7d193ebcf3137ae9505"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0aa92074516c37a10d4150d68918e20db91289a5",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0aa92074516c37a10d4150d68918e20db91289a5",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0aa92074516c37a10d4150d68918e20db91289a5",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0aa92074516c37a10d4150d68918e20db91289a5/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "978e2004ad659ad216d820dbd79e212e276405f4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/978e2004ad659ad216d820dbd79e212e276405f4",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/978e2004ad659ad216d820dbd79e212e276405f4"
      }
    ],
    "stats": {
      "total": 276,
      "additions": 276,
      "deletions": 0
    },
    "files": [
      {
        "sha": "76f998ac24eec3c628cb28d9010197a88bc7bae0",
        "filename": "src/test/transaction_tests.cpp",
        "status": "modified",
        "additions": 276,
        "deletions": 0,
        "changes": 276,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0aa92074516c37a10d4150d68918e20db91289a5/src/test/transaction_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0aa92074516c37a10d4150d68918e20db91289a5/src/test/transaction_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/transaction_tests.cpp?ref=0aa92074516c37a10d4150d68918e20db91289a5",
        "patch": "@@ -14,7 +14,9 @@\n #include \"main.h\" // For CheckTransaction\n #include \"policy/policy.h\"\n #include \"script/script.h\"\n+#include \"script/sign.h\"\n #include \"script/script_error.h\"\n+#include \"script/standard.h\"\n #include \"utilstrencodings.h\"\n \n #include <map>\n@@ -25,11 +27,14 @@\n #include <boost/assign/list_of.hpp>\n #include <boost/test/unit_test.hpp>\n #include <boost/assign/list_of.hpp>\n+#include <boost/foreach.hpp>\n \n #include <univalue.h>\n \n using namespace std;\n \n+typedef vector<unsigned char> valtype;\n+\n // In script_tests.cpp\n extern UniValue read_json(const std::string& jsondata);\n \n@@ -315,6 +320,277 @@ BOOST_AUTO_TEST_CASE(test_Get)\n     BOOST_CHECK_EQUAL(coins.GetValueIn(t1), (50+21+22)*CENT);\n }\n \n+void CreateCreditAndSpend(const CKeyStore& keystore, const CScript& outscript, CTransaction& output, CMutableTransaction& input, bool success = true)\n+{\n+    CMutableTransaction outputm;\n+    outputm.nVersion = 1;\n+    outputm.vin.resize(1);\n+    outputm.vin[0].prevout.SetNull();\n+    outputm.vin[0].scriptSig = CScript();\n+    outputm.wit.vtxinwit.resize(1);\n+    outputm.vout.resize(1);\n+    outputm.vout[0].nValue = 1;\n+    outputm.vout[0].scriptPubKey = outscript;\n+    CDataStream ssout(SER_NETWORK, PROTOCOL_VERSION);\n+    ssout << outputm;\n+    ssout >> output;\n+    assert(output.vin.size() == 1);\n+    assert(output.vin[0] == outputm.vin[0]);\n+    assert(output.vout.size() == 1);\n+    assert(output.vout[0] == outputm.vout[0]);\n+    assert(output.wit.vtxinwit.size() == 0);\n+\n+    CMutableTransaction inputm;\n+    inputm.nVersion = 1;\n+    inputm.vin.resize(1);\n+    inputm.vin[0].prevout.hash = output.GetHash();\n+    inputm.vin[0].prevout.n = 0;\n+    inputm.wit.vtxinwit.resize(1);\n+    inputm.vout.resize(1);\n+    inputm.vout[0].nValue = 1;\n+    inputm.vout[0].scriptPubKey = CScript();\n+    bool ret = SignSignature(keystore, output, inputm, 0, SIGHASH_ALL);\n+    assert(ret == success);\n+    CDataStream ssin(SER_NETWORK, PROTOCOL_VERSION);\n+    ssin << inputm;\n+    ssin >> input;\n+    assert(input.vin.size() == 1);\n+    assert(input.vin[0] == inputm.vin[0]);\n+    assert(input.vout.size() == 1);\n+    assert(input.vout[0] == inputm.vout[0]);\n+    if (inputm.wit.IsNull()) {\n+        assert(input.wit.IsNull());\n+    } else {\n+        assert(!input.wit.IsNull());\n+        assert(input.wit.vtxinwit.size() == 1);\n+        assert(input.wit.vtxinwit[0].scriptWitness.stack == inputm.wit.vtxinwit[0].scriptWitness.stack);\n+    }\n+}\n+\n+void CheckWithFlag(const CTransaction& output, const CMutableTransaction& input, int flags, bool success)\n+{\n+    ScriptError error;\n+    CTransaction inputi(input);\n+    bool ret = VerifyScript(inputi.vin[0].scriptSig, output.vout[0].scriptPubKey, inputi.wit.vtxinwit.size() > 0 ? &inputi.wit.vtxinwit[0].scriptWitness : NULL, flags, TransactionSignatureChecker(&inputi, 0, output.vout[0].nValue), &error);\n+    assert(ret == success);\n+}\n+\n+static CScript PushAll(const vector<valtype>& values)\n+{\n+    CScript result;\n+    BOOST_FOREACH(const valtype& v, values) {\n+        if (v.size() == 0) {\n+            result << OP_0;\n+        } else if (v.size() == 1 && v[0] >= 1 && v[0] <= 16) {\n+            result << CScript::EncodeOP_N(v[0]);\n+        } else {\n+            result << v;\n+        }\n+    }\n+    return result;\n+}\n+\n+void ReplaceRedeemScript(CScript& script, const CScript& redeemScript)\n+{\n+    vector<valtype> stack;\n+    EvalScript(stack, script, SCRIPT_VERIFY_STRICTENC, BaseSignatureChecker(), SIGVERSION_BASE);\n+    assert(stack.size() > 0);\n+    stack.back() = std::vector<unsigned char>(redeemScript.begin(), redeemScript.end());\n+    script = PushAll(stack);\n+}\n+\n+BOOST_AUTO_TEST_CASE(test_witness)\n+{\n+    CBasicKeyStore keystore, keystore2;\n+    CKey key1, key2, key3, key1L, key2L;\n+    CPubKey pubkey1, pubkey2, pubkey3, pubkey1L, pubkey2L;\n+    key1.MakeNewKey(true);\n+    key2.MakeNewKey(true);\n+    key3.MakeNewKey(true);\n+    key1L.MakeNewKey(false);\n+    key2L.MakeNewKey(false);\n+    pubkey1 = key1.GetPubKey();\n+    pubkey2 = key2.GetPubKey();\n+    pubkey3 = key3.GetPubKey();\n+    pubkey1L = key1L.GetPubKey();\n+    pubkey2L = key2L.GetPubKey();\n+    keystore.AddKeyPubKey(key1, pubkey1);\n+    keystore.AddKeyPubKey(key2, pubkey2);\n+    keystore.AddKeyPubKey(key1L, pubkey1L);\n+    keystore.AddKeyPubKey(key2L, pubkey2L);\n+    CScript scriptPubkey1, scriptPubkey2, scriptPubkey1L, scriptPubkey2L, scriptMulti;\n+    scriptPubkey1 << ToByteVector(pubkey1) << OP_CHECKSIG;\n+    scriptPubkey2 << ToByteVector(pubkey2) << OP_CHECKSIG;\n+    scriptPubkey1L << ToByteVector(pubkey1L) << OP_CHECKSIG;\n+    scriptPubkey2L << ToByteVector(pubkey2L) << OP_CHECKSIG; \n+    std::vector<CPubKey> oneandthree;\n+    oneandthree.push_back(pubkey1);\n+    oneandthree.push_back(pubkey3);\n+    scriptMulti = GetScriptForMultisig(2, oneandthree);\n+    keystore.AddCScript(scriptPubkey1);\n+    keystore.AddCScript(scriptPubkey2);\n+    keystore.AddCScript(scriptPubkey1L);\n+    keystore.AddCScript(scriptPubkey2L);\n+    keystore.AddCScript(scriptMulti);\n+    keystore.AddCScript(GetScriptForWitness(scriptPubkey1));\n+    keystore.AddCScript(GetScriptForWitness(scriptPubkey2));\n+    keystore.AddCScript(GetScriptForWitness(scriptPubkey1L));\n+    keystore.AddCScript(GetScriptForWitness(scriptPubkey2L));\n+    keystore.AddCScript(GetScriptForWitness(scriptMulti));\n+    keystore2.AddCScript(scriptMulti);\n+    keystore2.AddCScript(GetScriptForWitness(scriptMulti));\n+    keystore2.AddKeyPubKey(key3, pubkey3);\n+\n+    CTransaction output1, output2;\n+    CMutableTransaction input1, input2;\n+    SignatureData sigdata;\n+\n+    // Normal pay-to-compressed-pubkey.\n+    CreateCreditAndSpend(keystore, scriptPubkey1, output1, input1);\n+    CreateCreditAndSpend(keystore, scriptPubkey2, output2, input2);\n+    CheckWithFlag(output1, input1, 0, true);\n+    CheckWithFlag(output1, input1, SCRIPT_VERIFY_P2SH, true);\n+    CheckWithFlag(output1, input1, SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true);\n+    CheckWithFlag(output1, input1, STANDARD_SCRIPT_VERIFY_FLAGS, true);\n+    CheckWithFlag(output1, input2, 0, false);\n+    CheckWithFlag(output1, input2, SCRIPT_VERIFY_P2SH, false);\n+    CheckWithFlag(output1, input2, SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false);\n+    CheckWithFlag(output1, input2, STANDARD_SCRIPT_VERIFY_FLAGS, false);\n+\n+    // P2SH pay-to-compressed-pubkey.\n+    CreateCreditAndSpend(keystore, GetScriptForDestination(CScriptID(scriptPubkey1)), output1, input1);\n+    CreateCreditAndSpend(keystore, GetScriptForDestination(CScriptID(scriptPubkey2)), output2, input2);\n+    ReplaceRedeemScript(input2.vin[0].scriptSig, scriptPubkey1);\n+    CheckWithFlag(output1, input1, 0, true);\n+    CheckWithFlag(output1, input1, SCRIPT_VERIFY_P2SH, true);\n+    CheckWithFlag(output1, input1, SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true);\n+    CheckWithFlag(output1, input1, STANDARD_SCRIPT_VERIFY_FLAGS, true);\n+    CheckWithFlag(output1, input2, 0, true);\n+    CheckWithFlag(output1, input2, SCRIPT_VERIFY_P2SH, false);\n+    CheckWithFlag(output1, input2, SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false);\n+    CheckWithFlag(output1, input2, STANDARD_SCRIPT_VERIFY_FLAGS, false);\n+\n+    // Witness pay-to-compressed-pubkey (v0).\n+    CreateCreditAndSpend(keystore, GetScriptForWitness(scriptPubkey1), output1, input1);\n+    CreateCreditAndSpend(keystore, GetScriptForWitness(scriptPubkey2), output2, input2);\n+    CheckWithFlag(output1, input1, 0, true);\n+    CheckWithFlag(output1, input1, SCRIPT_VERIFY_P2SH, true);\n+    CheckWithFlag(output1, input1, SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true);\n+    CheckWithFlag(output1, input1, STANDARD_SCRIPT_VERIFY_FLAGS, true);\n+    CheckWithFlag(output1, input2, 0, true);\n+    CheckWithFlag(output1, input2, SCRIPT_VERIFY_P2SH, true);\n+    CheckWithFlag(output1, input2, SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false);\n+    CheckWithFlag(output1, input2, STANDARD_SCRIPT_VERIFY_FLAGS, false);\n+\n+    // P2SH witness pay-to-compressed-pubkey (v0).\n+    CreateCreditAndSpend(keystore, GetScriptForDestination(CScriptID(GetScriptForWitness(scriptPubkey1))), output1, input1);\n+    CreateCreditAndSpend(keystore, GetScriptForDestination(CScriptID(GetScriptForWitness(scriptPubkey2))), output2, input2);\n+    ReplaceRedeemScript(input2.vin[0].scriptSig, GetScriptForWitness(scriptPubkey1));\n+    CheckWithFlag(output1, input1, 0, true);\n+    CheckWithFlag(output1, input1, SCRIPT_VERIFY_P2SH, true);\n+    CheckWithFlag(output1, input1, SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true);\n+    CheckWithFlag(output1, input1, STANDARD_SCRIPT_VERIFY_FLAGS, true);\n+    CheckWithFlag(output1, input2, 0, true);\n+    CheckWithFlag(output1, input2, SCRIPT_VERIFY_P2SH, true);\n+    CheckWithFlag(output1, input2, SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false);\n+    CheckWithFlag(output1, input2, STANDARD_SCRIPT_VERIFY_FLAGS, false);\n+\n+    // Normal pay-to-uncompressed-pubkey.\n+    CreateCreditAndSpend(keystore, scriptPubkey1L, output1, input1);\n+    CreateCreditAndSpend(keystore, scriptPubkey2L, output2, input2);\n+    CheckWithFlag(output1, input1, 0, true);\n+    CheckWithFlag(output1, input1, SCRIPT_VERIFY_P2SH, true);\n+    CheckWithFlag(output1, input1, SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true);\n+    CheckWithFlag(output1, input1, STANDARD_SCRIPT_VERIFY_FLAGS, true);\n+    CheckWithFlag(output1, input2, 0, false);\n+    CheckWithFlag(output1, input2, SCRIPT_VERIFY_P2SH, false);\n+    CheckWithFlag(output1, input2, SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false);\n+    CheckWithFlag(output1, input2, STANDARD_SCRIPT_VERIFY_FLAGS, false);\n+\n+    // P2SH pay-to-uncompressed-pubkey.\n+    CreateCreditAndSpend(keystore, GetScriptForDestination(CScriptID(scriptPubkey1L)), output1, input1);\n+    CreateCreditAndSpend(keystore, GetScriptForDestination(CScriptID(scriptPubkey2L)), output2, input2);\n+    ReplaceRedeemScript(input2.vin[0].scriptSig, scriptPubkey1L);\n+    CheckWithFlag(output1, input1, 0, true);\n+    CheckWithFlag(output1, input1, SCRIPT_VERIFY_P2SH, true);\n+    CheckWithFlag(output1, input1, SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true);\n+    CheckWithFlag(output1, input1, STANDARD_SCRIPT_VERIFY_FLAGS, true);\n+    CheckWithFlag(output1, input2, 0, true);\n+    CheckWithFlag(output1, input2, SCRIPT_VERIFY_P2SH, false);\n+    CheckWithFlag(output1, input2, SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false);\n+    CheckWithFlag(output1, input2, STANDARD_SCRIPT_VERIFY_FLAGS, false);\n+\n+    // Witness pay-to-uncompressed-pubkey (v1).\n+    CreateCreditAndSpend(keystore, GetScriptForWitness(scriptPubkey1L), output1, input1);\n+    CreateCreditAndSpend(keystore, GetScriptForWitness(scriptPubkey2L), output2, input2);\n+    CheckWithFlag(output1, input1, 0, true);\n+    CheckWithFlag(output1, input1, SCRIPT_VERIFY_P2SH, true);\n+    CheckWithFlag(output1, input1, SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true);\n+    CheckWithFlag(output1, input1, STANDARD_SCRIPT_VERIFY_FLAGS, true);\n+    CheckWithFlag(output1, input2, 0, true);\n+    CheckWithFlag(output1, input2, SCRIPT_VERIFY_P2SH, true);\n+    CheckWithFlag(output1, input2, SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false);\n+    CheckWithFlag(output1, input2, STANDARD_SCRIPT_VERIFY_FLAGS, false);\n+\n+    // P2SH witness pay-to-uncompressed-pubkey (v1).\n+    CreateCreditAndSpend(keystore, GetScriptForDestination(CScriptID(GetScriptForWitness(scriptPubkey1L))), output1, input1);\n+    CreateCreditAndSpend(keystore, GetScriptForDestination(CScriptID(GetScriptForWitness(scriptPubkey2L))), output2, input2);\n+    ReplaceRedeemScript(input2.vin[0].scriptSig, GetScriptForWitness(scriptPubkey1L));\n+    CheckWithFlag(output1, input1, 0, true);\n+    CheckWithFlag(output1, input1, SCRIPT_VERIFY_P2SH, true);\n+    CheckWithFlag(output1, input1, SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true);\n+    CheckWithFlag(output1, input1, STANDARD_SCRIPT_VERIFY_FLAGS, true);\n+    CheckWithFlag(output1, input2, 0, true);\n+    CheckWithFlag(output1, input2, SCRIPT_VERIFY_P2SH, true);\n+    CheckWithFlag(output1, input2, SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false);\n+    CheckWithFlag(output1, input2, STANDARD_SCRIPT_VERIFY_FLAGS, false);\n+\n+    // Normal 2-of-2 multisig\n+    CreateCreditAndSpend(keystore, scriptMulti, output1, input1, false);\n+    CheckWithFlag(output1, input1, 0, false);\n+    CreateCreditAndSpend(keystore2, scriptMulti, output2, input2, false);\n+    CheckWithFlag(output2, input2, 0, false);\n+    BOOST_CHECK(output1 == output2);\n+    UpdateTransaction(input1, 0, CombineSignatures(output1.vout[0].scriptPubKey, MutableTransactionSignatureChecker(&input1, 0, output1.vout[0].nValue), DataFromTransaction(input1, 0), DataFromTransaction(input2, 0)));\n+    CheckWithFlag(output1, input1, STANDARD_SCRIPT_VERIFY_FLAGS, true);\n+\n+    // P2SH 2-of-2 multisig\n+    CreateCreditAndSpend(keystore, GetScriptForDestination(CScriptID(scriptMulti)), output1, input1, false);\n+    CheckWithFlag(output1, input1, 0, true);\n+    CheckWithFlag(output1, input1, SCRIPT_VERIFY_P2SH, false);\n+    CreateCreditAndSpend(keystore2, GetScriptForDestination(CScriptID(scriptMulti)), output2, input2, false);\n+    CheckWithFlag(output2, input2, 0, true);\n+    CheckWithFlag(output2, input2, SCRIPT_VERIFY_P2SH, false);\n+    BOOST_CHECK(output1 == output2);\n+    UpdateTransaction(input1, 0, CombineSignatures(output1.vout[0].scriptPubKey, MutableTransactionSignatureChecker(&input1, 0, output1.vout[0].nValue), DataFromTransaction(input1, 0), DataFromTransaction(input2, 0)));\n+    CheckWithFlag(output1, input1, SCRIPT_VERIFY_P2SH, true);\n+    CheckWithFlag(output1, input1, STANDARD_SCRIPT_VERIFY_FLAGS, true);\n+\n+    // Witness 2-of-2 multisig\n+    CreateCreditAndSpend(keystore, GetScriptForWitness(scriptMulti), output1, input1, false);\n+    CheckWithFlag(output1, input1, 0, true);\n+    CheckWithFlag(output1, input1, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, false);\n+    CreateCreditAndSpend(keystore2, GetScriptForWitness(scriptMulti), output2, input2, false);\n+    CheckWithFlag(output2, input2, 0, true);\n+    CheckWithFlag(output2, input2, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, false);\n+    BOOST_CHECK(output1 == output2);\n+    UpdateTransaction(input1, 0, CombineSignatures(output1.vout[0].scriptPubKey, MutableTransactionSignatureChecker(&input1, 0, output1.vout[0].nValue), DataFromTransaction(input1, 0), DataFromTransaction(input2, 0)));\n+    CheckWithFlag(output1, input1, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, true);\n+    CheckWithFlag(output1, input1, STANDARD_SCRIPT_VERIFY_FLAGS, true);\n+\n+    // P2SH witness 2-of-2 multisig\n+    CreateCreditAndSpend(keystore, GetScriptForDestination(CScriptID(GetScriptForWitness(scriptMulti))), output1, input1, false);\n+    CheckWithFlag(output1, input1, SCRIPT_VERIFY_P2SH, true);\n+    CheckWithFlag(output1, input1, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, false);\n+    CreateCreditAndSpend(keystore2, GetScriptForDestination(CScriptID(GetScriptForWitness(scriptMulti))), output2, input2, false);\n+    CheckWithFlag(output2, input2, SCRIPT_VERIFY_P2SH, true);\n+    CheckWithFlag(output2, input2, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, false);\n+    BOOST_CHECK(output1 == output2);\n+    UpdateTransaction(input1, 0, CombineSignatures(output1.vout[0].scriptPubKey, MutableTransactionSignatureChecker(&input1, 0, output1.vout[0].nValue), DataFromTransaction(input1, 0), DataFromTransaction(input2, 0)));\n+    CheckWithFlag(output1, input1, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, true);\n+    CheckWithFlag(output1, input1, STANDARD_SCRIPT_VERIFY_FLAGS, true);\n+}\n+\n BOOST_AUTO_TEST_CASE(test_IsStandard)\n {\n     LOCK(cs_main);"
      }
    ]
  },
  {
    "sha": "00f46cbcd9d33fadfeb391e764bda3ac220be3ea",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowMGY0NmNiY2Q5ZDMzZmFkZmViMzkxZTc2NGJkYTNhYzIyMGJlM2Vh",
    "commit": {
      "author": {
        "name": "NicolasDorier",
        "email": "nicolas.dorier@gmail.com",
        "date": "2016-04-03T14:48:50Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-06-22T13:43:01Z"
      },
      "message": "[qa] Add transaction tests for segwit\n\nIncluding BIP143 P2WSH examples by jl2012.",
      "tree": {
        "sha": "3b025205b64ee6bd18a0927a927642aec344b4ff",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3b025205b64ee6bd18a0927a927642aec344b4ff"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/00f46cbcd9d33fadfeb391e764bda3ac220be3ea",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/00f46cbcd9d33fadfeb391e764bda3ac220be3ea",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/00f46cbcd9d33fadfeb391e764bda3ac220be3ea",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/00f46cbcd9d33fadfeb391e764bda3ac220be3ea/comments",
    "author": {
      "login": "NicolasDorier",
      "id": 3020646,
      "node_id": "MDQ6VXNlcjMwMjA2NDY=",
      "avatar_url": "https://avatars.githubusercontent.com/u/3020646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/NicolasDorier",
      "html_url": "https://github.com/NicolasDorier",
      "followers_url": "https://api.github.com/users/NicolasDorier/followers",
      "following_url": "https://api.github.com/users/NicolasDorier/following{/other_user}",
      "gists_url": "https://api.github.com/users/NicolasDorier/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/NicolasDorier/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/NicolasDorier/subscriptions",
      "organizations_url": "https://api.github.com/users/NicolasDorier/orgs",
      "repos_url": "https://api.github.com/users/NicolasDorier/repos",
      "events_url": "https://api.github.com/users/NicolasDorier/events{/privacy}",
      "received_events_url": "https://api.github.com/users/NicolasDorier/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "0aa92074516c37a10d4150d68918e20db91289a5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0aa92074516c37a10d4150d68918e20db91289a5",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0aa92074516c37a10d4150d68918e20db91289a5"
      }
    ],
    "stats": {
      "total": 273,
      "additions": 263,
      "deletions": 10
    },
    "files": [
      {
        "sha": "05502a83f73b1ca8fa5145d772d795eaa76a9acb",
        "filename": "src/test/data/tx_invalid.json",
        "status": "modified",
        "additions": 63,
        "deletions": 0,
        "changes": 63,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/00f46cbcd9d33fadfeb391e764bda3ac220be3ea/src/test/data/tx_invalid.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/00f46cbcd9d33fadfeb391e764bda3ac220be3ea/src/test/data/tx_invalid.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/data/tx_invalid.json?ref=00f46cbcd9d33fadfeb391e764bda3ac220be3ea",
        "patch": "@@ -251,5 +251,68 @@\n [[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"4194304 NOP3 1\"]],\n \"010000000100010000000000000000000000000000000000000000000000000000000000000000000000000040000100000000000000000000000000\", \"P2SH,CHECKSEQUENCEVERIFY\"],\n \n+[\"Unknown witness program version (with DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM)\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"0x51\", 1000],\n+[\"0000000000000000000000000000000000000000000000000000000000000100\", 1, \"0x60 0x14 0x4c9c3dfac4207d5d8cb89df5722cb3d712385e3f\", 2000],\n+[\"0000000000000000000000000000000000000000000000000000000000000100\", 2, \"0x51\", 3000]],\n+\"0100000000010300010000000000000000000000000000000000000000000000000000000000000000000000ffffffff00010000000000000000000000000000000000000000000000000000000000000100000000ffffffff00010000000000000000000000000000000000000000000000000000000000000200000000ffffffff03e8030000000000000151d0070000000000000151b80b00000000000001510002483045022100a3cec69b52cba2d2de623ffffffffff1606184ea55476c0f8189fda231bc9cbb022003181ad597f7c380a7d1c740286b1d022b8b04ded028b833282e055e03b8efef812103596d3451025c19dbbdeb932d6bf8bfb4ad499b95b6f88db8899efac102e5fc710000000000\", \"P2SH,WITNESS,DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM\"],\n+\n+[\"Unknown length for witness program v0\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"0x51\", 1000],\n+[\"0000000000000000000000000000000000000000000000000000000000000100\", 1, \"0x00 0x15 0x4c9c3dfac4207d5d8cb89df5722cb3d712385e3fff\", 2000],\n+[\"0000000000000000000000000000000000000000000000000000000000000100\", 2, \"0x51\", 3000]],\n+\"0100000000010300010000000000000000000000000000000000000000000000000000000000000000000000ffffffff00010000000000000000000000000000000000000000000000000000000000000100000000ffffffff00010000000000000000000000000000000000000000000000000000000000000200000000ffffffff04b60300000000000001519e070000000000000151860b0000000000000100960000000000000001510002473044022022fceb54f62f8feea77faac7083c3b56c4676a78f93745adc8a35800bc36adfa022026927df9abcf0a8777829bcfcce3ff0a385fa54c3f9df577405e3ef24ee56479022103596d3451025c19dbbdeb932d6bf8bfb4ad499b95b6f88db8899efac102e5fc710000000000\", \"P2SH,WITNESS\"],\n+\n+[\"Witness with SigHash Single|AnyoneCanPay (same index output value changed)\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"0x51\", 1000],\n+[\"0000000000000000000000000000000000000000000000000000000000000100\", 1, \"0x00 0x14 0x4c9c3dfac4207d5d8cb89df5722cb3d712385e3f\", 2000],\n+[\"0000000000000000000000000000000000000000000000000000000000000100\", 2, \"0x51\", 3000]],\n+\"0100000000010300010000000000000000000000000000000000000000000000000000000000000000000000ffffffff00010000000000000000000000000000000000000000000000000000000000000100000000ffffffff00010000000000000000000000000000000000000000000000000000000000000200000000ffffffff03e80300000000000001516c070000000000000151b80b0000000000000151000248304502210092f4777a0f17bf5aeb8ae768dec5f2c14feabf9d1fe2c89c78dfed0f13fdb86902206da90a86042e252bcd1e80a168c719e4a1ddcc3cebea24b9812c5453c79107e9832103596d3451025c19dbbdeb932d6bf8bfb4ad499b95b6f88db8899efac102e5fc710000000000\", \"P2SH,WITNESS\"],\n+\n+[\"Witness with SigHash None|AnyoneCanPay (input sequence changed)\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"0x51\", 1000],\n+[\"0000000000000000000000000000000000000000000000000000000000000100\", 1, \"0x00 0x14 0x4c9c3dfac4207d5d8cb89df5722cb3d712385e3f\", 2000],\n+[\"0000000000000000000000000000000000000000000000000000000000000100\", 2, \"0x51\", 3000]],\n+\"0100000000010300010000000000000000000000000000000000000000000000000000000000000000000000ffffffff000100000000000000000000000000000000000000000000000000000000000001000000000100000000010000000000000000000000000000000000000000000000000000000000000200000000ffffffff00000248304502210091b32274295c2a3fa02f5bce92fb2789e3fc6ea947fbe1a76e52ea3f4ef2381a022079ad72aefa3837a2e0c033a8652a59731da05fa4a813f4fc48e87c075037256b822103596d3451025c19dbbdeb932d6bf8bfb4ad499b95b6f88db8899efac102e5fc710000000000\", \"P2SH,WITNESS\"],\n+\n+[\"Witness with SigHash All|AnyoneCanPay (third output value changed)\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"0x51\", 1000],\n+[\"0000000000000000000000000000000000000000000000000000000000000100\", 1, \"0x00 0x14 0x4c9c3dfac4207d5d8cb89df5722cb3d712385e3f\", 2000],\n+[\"0000000000000000000000000000000000000000000000000000000000000100\", 2, \"0x51\", 3000]],\n+\"0100000000010300010000000000000000000000000000000000000000000000000000000000000000000000ffffffff00010000000000000000000000000000000000000000000000000000000000000100000000ffffffff00010000000000000000000000000000000000000000000000000000000000000200000000ffffffff03e8030000000000000151d0070000000000000151540b00000000000001510002483045022100a3cec69b52cba2d2de623eeef89e0ba1606184ea55476c0f8189fda231bc9cbb022003181ad597f7c380a7d1c740286b1d022b8b04ded028b833282e055e03b8efef812103596d3451025c19dbbdeb932d6bf8bfb4ad499b95b6f88db8899efac102e5fc710000000000\", \"P2SH,WITNESS\"],\n+\n+[\"Witness with a push of 521 bytes\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"0x00 0x20 0x33198a9bfef674ebddb9ffaa52928017b8472791e54c609cb95f278ac6b1e349\", 1000]],\n+\"0100000000010100010000000000000000000000000000000000000000000000000000000000000000000000ffffffff010000000000000000015102fd0902000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002755100000000\", \"P2SH,WITNESS\"],\n+\n+[\"Witness with unknown version which push false on the stack should be invalid (even without DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM)\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"0x60 0x02 0x0000\", 2000]],\n+\"0100000000010100010000000000000000000000000000000000000000000000000000000000000000000000ffffffff010000000000000000015101010100000000\", \"P2SH,WITNESS\"],\n+\n+[\"Witness program should leave clean stack\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"0x00 0x20 0x2f04a3aa051f1f60d695f6c44c0c3d383973dfd446ace8962664a76bb10e31a8\", 2000]],\n+\"0100000000010100010000000000000000000000000000000000000000000000000000000000000000000000ffffffff01000000000000000001510102515100000000\", \"P2SH,WITNESS\"],\n+\n+[\"Witness v0 with a push of 2 bytes\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"0x00 0x02 0x0001\", 2000]],\n+\"0100000000010100010000000000000000000000000000000000000000000000000000000000000000000000ffffffff010000000000000000015101040002000100000000\", \"P2SH,WITNESS\"],\n+\n+[\"Unknown witness version with non empty scriptSig\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"0x60 0x02 0x0001\", 2000]],\n+\"01000000010001000000000000000000000000000000000000000000000000000000000000000000000151ffffffff010000000000000000015100000000\", \"P2SH,WITNESS\"],\n+\n+[\"Non witness Single|AnyoneCanPay hash input's position (permutation)\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"0x21 0x03596d3451025c19dbbdeb932d6bf8bfb4ad499b95b6f88db8899efac102e5fc71 CHECKSIG\", 1000],\n+[\"0000000000000000000000000000000000000000000000000000000000000100\", 1, \"0x21 0x03596d3451025c19dbbdeb932d6bf8bfb4ad499b95b6f88db8899efac102e5fc71 CHECKSIG\", 1001]],\n+\"010000000200010000000000000000000000000000000000000000000000000000000000000100000049483045022100acb96cfdbda6dc94b489fd06f2d720983b5f350e31ba906cdbd800773e80b21c02200d74ea5bdf114212b4bbe9ed82c36d2e369e302dff57cb60d01c428f0bd3daab83ffffffff0001000000000000000000000000000000000000000000000000000000000000000000004847304402202a0b4b1294d70540235ae033d78e64b4897ec859c7b6f1b2b1d8a02e1d46006702201445e756d2254b0f1dfda9ab8e1e1bc26df9668077403204f32d16a49a36eb6983ffffffff02e9030000000000000151e803000000000000015100000000\", \"P2SH,WITNESS\"],\n+\n+[\"P2WSH with a redeem representing a witness scriptPubKey should fail\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"0x00 0x20 0x34b6c399093e06cf9f0f7f660a1abcfe78fcf7b576f43993208edd9518a0ae9b\", 1000]],\n+\"0100000000010100010000000000000000000000000000000000000000000000000000000000000000000000ffffffff0001045102010100000000\", \"P2SH,WITNESS\"],\n+\n+[\"33 bytes push should be considered a witness scriptPubKey\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"0x60 0x21 0xff25429251b5a84f452230a3c75fd886b7fc5a7865ce4a7bb7a9d7c5be6da3dbff\", 1000]],\n+\"010000000100010000000000000000000000000000000000000000000000000000000000000000000000ffffffff01e803000000000000015100000000\", \"P2SH,WITNESS,DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM\"],\n+\n [\"Make diffs cleaner by leaving a comment here without comma at the end\"]\n ]"
      },
      {
        "sha": "c9fe4e313a2eb28c9489f18886ac3be20ecd12fd",
        "filename": "src/test/data/tx_valid.json",
        "status": "modified",
        "additions": 170,
        "deletions": 0,
        "changes": 170,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/00f46cbcd9d33fadfeb391e764bda3ac220be3ea/src/test/data/tx_valid.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/00f46cbcd9d33fadfeb391e764bda3ac220be3ea/src/test/data/tx_valid.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/data/tx_valid.json?ref=00f46cbcd9d33fadfeb391e764bda3ac220be3ea",
        "patch": "@@ -317,5 +317,175 @@\n [[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"HASH160 0x14 0x7c17aff532f22beb54069942f9bf567a66133eaf EQUAL\"]],\n \"0200000001000100000000000000000000000000000000000000000000000000000000000000000000030251b2010000000100000000000000000000000000\", \"P2SH,CHECKSEQUENCEVERIFY\"],\n \n+[\"Valid P2WPKH (Private key of segwit tests is L5AQtV2HDm4xGsseLokK2VAT2EtYKcTm3c7HwqnJBFt9LdaQULsM)\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"0x00 0x14 0x4c9c3dfac4207d5d8cb89df5722cb3d712385e3f\", 1000]],\n+\"0100000000010100010000000000000000000000000000000000000000000000000000000000000000000000ffffffff01e8030000000000001976a9144c9c3dfac4207d5d8cb89df5722cb3d712385e3f88ac02483045022100cfb07164b36ba64c1b1e8c7720a56ad64d96f6ef332d3d37f9cb3c96477dc44502200a464cd7a9cf94cd70f66ce4f4f0625ef650052c7afcfe29d7d7e01830ff91ed012103596d3451025c19dbbdeb932d6bf8bfb4ad499b95b6f88db8899efac102e5fc7100000000\", \"P2SH,WITNESS\"],\n+\n+[\"Valid P2WSH\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"0x00 0x20 0xff25429251b5a84f452230a3c75fd886b7fc5a7865ce4a7bb7a9d7c5be6da3db\", 1000]],\n+\"0100000000010100010000000000000000000000000000000000000000000000000000000000000000000000ffffffff01e8030000000000001976a9144c9c3dfac4207d5d8cb89df5722cb3d712385e3f88ac02483045022100aa5d8aa40a90f23ce2c3d11bc845ca4a12acd99cbea37de6b9f6d86edebba8cb022022dedc2aa0a255f74d04c0b76ece2d7c691f9dd11a64a8ac49f62a99c3a05f9d01232103596d3451025c19dbbdeb932d6bf8bfb4ad499b95b6f88db8899efac102e5fc71ac00000000\", \"P2SH,WITNESS\"],\n+\n+[\"Valid P2SH(P2WPKH)\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"HASH160 0x14 0xfe9c7dacc9fcfbf7e3b7d5ad06aa2b28c5a7b7e3 EQUAL\", 1000]],\n+\"01000000000101000100000000000000000000000000000000000000000000000000000000000000000000171600144c9c3dfac4207d5d8cb89df5722cb3d712385e3fffffffff01e8030000000000001976a9144c9c3dfac4207d5d8cb89df5722cb3d712385e3f88ac02483045022100cfb07164b36ba64c1b1e8c7720a56ad64d96f6ef332d3d37f9cb3c96477dc44502200a464cd7a9cf94cd70f66ce4f4f0625ef650052c7afcfe29d7d7e01830ff91ed012103596d3451025c19dbbdeb932d6bf8bfb4ad499b95b6f88db8899efac102e5fc7100000000\", \"P2SH,WITNESS\"],\n+\n+[\"Valid P2SH(P2WSH)\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"HASH160 0x14 0x2135ab4f0981830311e35600eebc7376dce3a914 EQUAL\", 1000]],\n+\"0100000000010100010000000000000000000000000000000000000000000000000000000000000000000023220020ff25429251b5a84f452230a3c75fd886b7fc5a7865ce4a7bb7a9d7c5be6da3dbffffffff01e8030000000000001976a9144c9c3dfac4207d5d8cb89df5722cb3d712385e3f88ac02483045022100aa5d8aa40a90f23ce2c3d11bc845ca4a12acd99cbea37de6b9f6d86edebba8cb022022dedc2aa0a255f74d04c0b76ece2d7c691f9dd11a64a8ac49f62a99c3a05f9d01232103596d3451025c19dbbdeb932d6bf8bfb4ad499b95b6f88db8899efac102e5fc71ac00000000\", \"P2SH,WITNESS\"],\n+\n+[\"Witness with SigHash Single|AnyoneCanPay\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"0x51\", 1100],\n+[\"0000000000000000000000000000000000000000000000000000000000000100\", 1, \"0x00 0x14 0x4c9c3dfac4207d5d8cb89df5722cb3d712385e3f\", 2000],\n+[\"0000000000000000000000000000000000000000000000000000000000000100\", 2, \"0x51\", 3100],\n+[\"0000000000000000000000000000000000000000000000000000000000000100\", 3, \"0x51\", 4100]],\n+\"0100000000010400010000000000000000000000000000000000000000000000000000000000000200000000ffffffff00010000000000000000000000000000000000000000000000000000000000000100000000ffffffff00010000000000000000000000000000000000000000000000000000000000000000000000ffffffff00010000000000000000000000000000000000000000000000000000000000000300000000ffffffff05540b0000000000000151d0070000000000000151840300000000000001513c0f00000000000001512c010000000000000151000248304502210092f4777a0f17bf5aeb8ae768dec5f2c14feabf9d1fe2c89c78dfed0f13fdb86902206da90a86042e252bcd1e80a168c719e4a1ddcc3cebea24b9812c5453c79107e9832103596d3451025c19dbbdeb932d6bf8bfb4ad499b95b6f88db8899efac102e5fc71000000000000\", \"P2SH,WITNESS\"],\n+\n+[\"Witness with SigHash Single|AnyoneCanPay (same signature as previous)\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"0x51\", 1000],\n+[\"0000000000000000000000000000000000000000000000000000000000000100\", 1, \"0x00 0x14 0x4c9c3dfac4207d5d8cb89df5722cb3d712385e3f\", 2000],\n+[\"0000000000000000000000000000000000000000000000000000000000000100\", 2, \"0x51\", 3000]],\n+\"0100000000010300010000000000000000000000000000000000000000000000000000000000000000000000ffffffff00010000000000000000000000000000000000000000000000000000000000000100000000ffffffff00010000000000000000000000000000000000000000000000000000000000000200000000ffffffff03e8030000000000000151d0070000000000000151b80b0000000000000151000248304502210092f4777a0f17bf5aeb8ae768dec5f2c14feabf9d1fe2c89c78dfed0f13fdb86902206da90a86042e252bcd1e80a168c719e4a1ddcc3cebea24b9812c5453c79107e9832103596d3451025c19dbbdeb932d6bf8bfb4ad499b95b6f88db8899efac102e5fc710000000000\", \"P2SH,WITNESS\"],\n+\n+[\"Witness with SigHash Single\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"0x51\", 1000],\n+[\"0000000000000000000000000000000000000000000000000000000000000100\", 1, \"0x00 0x14 0x4c9c3dfac4207d5d8cb89df5722cb3d712385e3f\", 2000],\n+[\"0000000000000000000000000000000000000000000000000000000000000100\", 2, \"0x51\", 3000]],\n+\"0100000000010300010000000000000000000000000000000000000000000000000000000000000000000000ffffffff00010000000000000000000000000000000000000000000000000000000000000100000000ffffffff00010000000000000000000000000000000000000000000000000000000000000200000000ffffffff0484030000000000000151d0070000000000000151540b0000000000000151c800000000000000015100024730440220699e6b0cfe015b64ca3283e6551440a34f901ba62dd4c72fe1cb815afb2e6761022021cc5e84db498b1479de14efda49093219441adc6c543e5534979605e273d80b032103596d3451025c19dbbdeb932d6bf8bfb4ad499b95b6f88db8899efac102e5fc710000000000\", \"P2SH,WITNESS\"],\n+\n+[\"Witness with SigHash Single (same signature as previous)\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"0x51\", 1000],\n+[\"0000000000000000000000000000000000000000000000000000000000000100\", 1, \"0x00 0x14 0x4c9c3dfac4207d5d8cb89df5722cb3d712385e3f\", 2000],\n+[\"0000000000000000000000000000000000000000000000000000000000000100\", 2, \"0x51\", 3000]],\n+\"0100000000010300010000000000000000000000000000000000000000000000000000000000000000000000ffffffff00010000000000000000000000000000000000000000000000000000000000000100000000ffffffff00010000000000000000000000000000000000000000000000000000000000000200000000ffffffff03e8030000000000000151d0070000000000000151b80b000000000000015100024730440220699e6b0cfe015b64ca3283e6551440a34f901ba62dd4c72fe1cb815afb2e6761022021cc5e84db498b1479de14efda49093219441adc6c543e5534979605e273d80b032103596d3451025c19dbbdeb932d6bf8bfb4ad499b95b6f88db8899efac102e5fc710000000000\", \"P2SH,WITNESS\"],\n+\n+[\"Witness with SigHash None|AnyoneCanPay\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"0x51\", 1100],\n+[\"0000000000000000000000000000000000000000000000000000000000000100\", 1, \"0x00 0x14 0x4c9c3dfac4207d5d8cb89df5722cb3d712385e3f\", 2000],\n+[\"0000000000000000000000000000000000000000000000000000000000000100\", 2, \"0x51\", 3100],\n+[\"0000000000000000000000000000000000000000000000000000000000000100\", 3, \"0x51\", 4100]],\n+\"0100000000010400010000000000000000000000000000000000000000000000000000000000000200000000ffffffff00010000000000000000000000000000000000000000000000000000000000000000000000ffffffff00010000000000000000000000000000000000000000000000000000000000000100000000ffffffff00010000000000000000000000000000000000000000000000000000000000000300000000ffffffff04b60300000000000001519e070000000000000151860b00000000000001009600000000000000015100000248304502210091b32274295c2a3fa02f5bce92fb2789e3fc6ea947fbe1a76e52ea3f4ef2381a022079ad72aefa3837a2e0c033a8652a59731da05fa4a813f4fc48e87c075037256b822103596d3451025c19dbbdeb932d6bf8bfb4ad499b95b6f88db8899efac102e5fc710000000000\", \"P2SH,WITNESS\"],\n+\n+[\"Witness with SigHash None|AnyoneCanPay (same signature as previous)\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"0x51\", 1000],\n+[\"0000000000000000000000000000000000000000000000000000000000000100\", 1, \"0x00 0x14 0x4c9c3dfac4207d5d8cb89df5722cb3d712385e3f\", 2000],\n+[\"0000000000000000000000000000000000000000000000000000000000000100\", 2, \"0x51\", 3000]],\n+\"0100000000010300010000000000000000000000000000000000000000000000000000000000000000000000ffffffff00010000000000000000000000000000000000000000000000000000000000000100000000ffffffff00010000000000000000000000000000000000000000000000000000000000000200000000ffffffff03e8030000000000000151d0070000000000000151b80b0000000000000151000248304502210091b32274295c2a3fa02f5bce92fb2789e3fc6ea947fbe1a76e52ea3f4ef2381a022079ad72aefa3837a2e0c033a8652a59731da05fa4a813f4fc48e87c075037256b822103596d3451025c19dbbdeb932d6bf8bfb4ad499b95b6f88db8899efac102e5fc710000000000\", \"P2SH,WITNESS\"],\n+\n+[\"Witness with SigHash None\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"0x51\", 1000],\n+[\"0000000000000000000000000000000000000000000000000000000000000100\", 1, \"0x00 0x14 0x4c9c3dfac4207d5d8cb89df5722cb3d712385e3f\", 2000],\n+[\"0000000000000000000000000000000000000000000000000000000000000100\", 2, \"0x51\", 3000]],\n+\"0100000000010300010000000000000000000000000000000000000000000000000000000000000000000000ffffffff00010000000000000000000000000000000000000000000000000000000000000100000000ffffffff00010000000000000000000000000000000000000000000000000000000000000200000000ffffffff04b60300000000000001519e070000000000000151860b0000000000000100960000000000000001510002473044022022fceb54f62f8feea77faac7083c3b56c4676a78f93745adc8a35800bc36adfa022026927df9abcf0a8777829bcfcce3ff0a385fa54c3f9df577405e3ef24ee56479022103596d3451025c19dbbdeb932d6bf8bfb4ad499b95b6f88db8899efac102e5fc710000000000\", \"P2SH,WITNESS\"],\n+\n+[\"Witness with SigHash None (same signature as previous)\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"0x51\", 1000],\n+[\"0000000000000000000000000000000000000000000000000000000000000100\", 1, \"0x00 0x14 0x4c9c3dfac4207d5d8cb89df5722cb3d712385e3f\", 2000],\n+[\"0000000000000000000000000000000000000000000000000000000000000100\", 2, \"0x51\", 3000]],\n+\"0100000000010300010000000000000000000000000000000000000000000000000000000000000000000000ffffffff00010000000000000000000000000000000000000000000000000000000000000100000000ffffffff00010000000000000000000000000000000000000000000000000000000000000200000000ffffffff03e8030000000000000151d0070000000000000151b80b00000000000001510002473044022022fceb54f62f8feea77faac7083c3b56c4676a78f93745adc8a35800bc36adfa022026927df9abcf0a8777829bcfcce3ff0a385fa54c3f9df577405e3ef24ee56479022103596d3451025c19dbbdeb932d6bf8bfb4ad499b95b6f88db8899efac102e5fc710000000000\", \"P2SH,WITNESS\"],\n+\n+[\"Witness with SigHash None (same signature, only sequences changed)\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"0x51\", 1000],\n+[\"0000000000000000000000000000000000000000000000000000000000000100\", 1, \"0x00 0x14 0x4c9c3dfac4207d5d8cb89df5722cb3d712385e3f\", 2000],\n+[\"0000000000000000000000000000000000000000000000000000000000000100\", 2, \"0x51\", 3000]],\n+\"01000000000103000100000000000000000000000000000000000000000000000000000000000000000000000200000000010000000000000000000000000000000000000000000000000000000000000100000000ffffffff000100000000000000000000000000000000000000000000000000000000000002000000000200000003e8030000000000000151d0070000000000000151b80b00000000000001510002473044022022fceb54f62f8feea77faac7083c3b56c4676a78f93745adc8a35800bc36adfa022026927df9abcf0a8777829bcfcce3ff0a385fa54c3f9df577405e3ef24ee56479022103596d3451025c19dbbdeb932d6bf8bfb4ad499b95b6f88db8899efac102e5fc710000000000\", \"P2SH,WITNESS\"],\n+\n+[\"Witness with SigHash All|AnyoneCanPay\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"0x51\", 1100],\n+[\"0000000000000000000000000000000000000000000000000000000000000100\", 1, \"0x00 0x14 0x4c9c3dfac4207d5d8cb89df5722cb3d712385e3f\", 2000],\n+[\"0000000000000000000000000000000000000000000000000000000000000100\", 2, \"0x51\", 3100],\n+[\"0000000000000000000000000000000000000000000000000000000000000100\", 3, \"0x51\", 4100]],\n+\"0100000000010400010000000000000000000000000000000000000000000000000000000000000200000000ffffffff00010000000000000000000000000000000000000000000000000000000000000000000000ffffffff00010000000000000000000000000000000000000000000000000000000000000100000000ffffffff00010000000000000000000000000000000000000000000000000000000000000300000000ffffffff03e8030000000000000151d0070000000000000151b80b0000000000000151000002483045022100a3cec69b52cba2d2de623eeef89e0ba1606184ea55476c0f8189fda231bc9cbb022003181ad597f7c380a7d1c740286b1d022b8b04ded028b833282e055e03b8efef812103596d3451025c19dbbdeb932d6bf8bfb4ad499b95b6f88db8899efac102e5fc710000000000\", \"P2SH,WITNESS\"],\n+\n+[\"Witness with SigHash All|AnyoneCanPay (same signature as previous)\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"0x51\", 1000],\n+[\"0000000000000000000000000000000000000000000000000000000000000100\", 1, \"0x00 0x14 0x4c9c3dfac4207d5d8cb89df5722cb3d712385e3f\", 2000],\n+[\"0000000000000000000000000000000000000000000000000000000000000100\", 2, \"0x51\", 3000]],\n+\"0100000000010300010000000000000000000000000000000000000000000000000000000000000000000000ffffffff00010000000000000000000000000000000000000000000000000000000000000100000000ffffffff00010000000000000000000000000000000000000000000000000000000000000200000000ffffffff03e8030000000000000151d0070000000000000151b80b00000000000001510002483045022100a3cec69b52cba2d2de623eeef89e0ba1606184ea55476c0f8189fda231bc9cbb022003181ad597f7c380a7d1c740286b1d022b8b04ded028b833282e055e03b8efef812103596d3451025c19dbbdeb932d6bf8bfb4ad499b95b6f88db8899efac102e5fc710000000000\", \"P2SH,WITNESS\"],\n+\n+[\"Unknown witness program version  (without DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM)\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"0x51\", 1000],\n+[\"0000000000000000000000000000000000000000000000000000000000000100\", 1, \"0x60 0x14 0x4c9c3dfac4207d5d8cb89df5722cb3d712385e3f\", 2000],\n+[\"0000000000000000000000000000000000000000000000000000000000000100\", 2, \"0x51\", 3000]],\n+\"0100000000010300010000000000000000000000000000000000000000000000000000000000000000000000ffffffff00010000000000000000000000000000000000000000000000000000000000000100000000ffffffff00010000000000000000000000000000000000000000000000000000000000000200000000ffffffff03e8030000000000000151d0070000000000000151b80b00000000000001510002483045022100a3cec69b52cba2d2de623ffffffffff1606184ea55476c0f8189fda231bc9cbb022003181ad597f7c380a7d1c740286b1d022b8b04ded028b833282e055e03b8efef812103596d3451025c19dbbdeb932d6bf8bfb4ad499b95b6f88db8899efac102e5fc710000000000\", \"P2SH,WITNESS\"],\n+\n+[\"Witness with a push of 520 bytes\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"0x00 0x20 0x33198a9bfef674ebddb9ffaa52928017b8472791e54c609cb95f278ac6b1e349\", 1000]],\n+\"0100000000010100010000000000000000000000000000000000000000000000000000000000000000000000ffffffff010000000000000000015102fd08020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002755100000000\", \"P2SH,WITNESS\"],\n+\n+[\"Transaction mixing all SigHash, segwit and normal inputs\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"0x00 0x14 0x4c9c3dfac4207d5d8cb89df5722cb3d712385e3f\", 1000],\n+[\"0000000000000000000000000000000000000000000000000000000000000100\", 1, \"0x00 0x14 0x4c9c3dfac4207d5d8cb89df5722cb3d712385e3f\", 1001],\n+[\"0000000000000000000000000000000000000000000000000000000000000100\", 2, \"DUP HASH160 0x14 0x4c9c3dfac4207d5d8cb89df5722cb3d712385e3f EQUALVERIFY CHECKSIG\", 1002],\n+[\"0000000000000000000000000000000000000000000000000000000000000100\", 3, \"DUP HASH160 0x14 0x4c9c3dfac4207d5d8cb89df5722cb3d712385e3f EQUALVERIFY CHECKSIG\", 1003],\n+[\"0000000000000000000000000000000000000000000000000000000000000100\", 4, \"DUP HASH160 0x14 0x4c9c3dfac4207d5d8cb89df5722cb3d712385e3f EQUALVERIFY CHECKSIG\", 1004],\n+[\"0000000000000000000000000000000000000000000000000000000000000100\", 5, \"DUP HASH160 0x14 0x4c9c3dfac4207d5d8cb89df5722cb3d712385e3f EQUALVERIFY CHECKSIG\", 1005],\n+[\"0000000000000000000000000000000000000000000000000000000000000100\", 6, \"DUP HASH160 0x14 0x4c9c3dfac4207d5d8cb89df5722cb3d712385e3f EQUALVERIFY CHECKSIG\", 1006],\n+[\"0000000000000000000000000000000000000000000000000000000000000100\", 7, \"0x00 0x14 0x4c9c3dfac4207d5d8cb89df5722cb3d712385e3f\", 1007],\n+[\"0000000000000000000000000000000000000000000000000000000000000100\", 8, \"0x00 0x14 0x4c9c3dfac4207d5d8cb89df5722cb3d712385e3f\", 1008],\n+[\"0000000000000000000000000000000000000000000000000000000000000100\", 9, \"0x00 0x14 0x4c9c3dfac4207d5d8cb89df5722cb3d712385e3f\", 1009],\n+[\"0000000000000000000000000000000000000000000000000000000000000100\", 10, \"0x00 0x14 0x4c9c3dfac4207d5d8cb89df5722cb3d712385e3f\", 1010],\n+[\"0000000000000000000000000000000000000000000000000000000000000100\", 11, \"DUP HASH160 0x14 0x4c9c3dfac4207d5d8cb89df5722cb3d712385e3f EQUALVERIFY CHECKSIG\", 1011]],\n+\"0100000000010c00010000000000000000000000000000000000000000000000000000000000000000000000ffffffff00010000000000000000000000000000000000000000000000000000000000000100000000ffffffff0001000000000000000000000000000000000000000000000000000000000000020000006a473044022026c2e65b33fcd03b2a3b0f25030f0244bd23cc45ae4dec0f48ae62255b1998a00220463aa3982b718d593a6b9e0044513fd67a5009c2fdccc59992cffc2b167889f4012103596d3451025c19dbbdeb932d6bf8bfb4ad499b95b6f88db8899efac102e5fc71ffffffff0001000000000000000000000000000000000000000000000000000000000000030000006a4730440220008bd8382911218dcb4c9f2e75bf5c5c3635f2f2df49b36994fde85b0be21a1a02205a539ef10fb4c778b522c1be852352ea06c67ab74200977c722b0bc68972575a012103596d3451025c19dbbdeb932d6bf8bfb4ad499b95b6f88db8899efac102e5fc71ffffffff0001000000000000000000000000000000000000000000000000000000000000040000006b483045022100d9436c32ff065127d71e1a20e319e4fe0a103ba0272743dbd8580be4659ab5d302203fd62571ee1fe790b182d078ecfd092a509eac112bea558d122974ef9cc012c7012103596d3451025c19dbbdeb932d6bf8bfb4ad499b95b6f88db8899efac102e5fc71ffffffff0001000000000000000000000000000000000000000000000000000000000000050000006a47304402200e2c149b114ec546015c13b2b464bbcb0cdc5872e6775787527af6cbc4830b6c02207e9396c6979fb15a9a2b96ca08a633866eaf20dc0ff3c03e512c1d5a1654f148012103596d3451025c19dbbdeb932d6bf8bfb4ad499b95b6f88db8899efac102e5fc71ffffffff0001000000000000000000000000000000000000000000000000000000000000060000006b483045022100b20e70d897dc15420bccb5e0d3e208d27bdd676af109abbd3f88dbdb7721e6d6022005836e663173fbdfe069f54cde3c2decd3d0ea84378092a5d9d85ec8642e8a41012103596d3451025c19dbbdeb932d6bf8bfb4ad499b95b6f88db8899efac102e5fc71ffffffff00010000000000000000000000000000000000000000000000000000000000000700000000ffffffff00010000000000000000000000000000000000000000000000000000000000000800000000ffffffff00010000000000000000000000000000000000000000000000000000000000000900000000ffffffff00010000000000000000000000000000000000000000000000000000000000000a00000000ffffffff00010000000000000000000000000000000000000000000000000000000000000b0000006a47304402206639c6e05e3b9d2675a7f3876286bdf7584fe2bbd15e0ce52dd4e02c0092cdc60220757d60b0a61fc95ada79d23746744c72bac1545a75ff6c2c7cdb6ae04e7e9592012103596d3451025c19dbbdeb932d6bf8bfb4ad499b95b6f88db8899efac102e5fc71ffffffff0ce8030000000000000151e9030000000000000151ea030000000000000151eb030000000000000151ec030000000000000151ed030000000000000151ee030000000000000151ef030000000000000151f0030000000000000151f1030000000000000151f2030000000000000151f30300000000000001510248304502210082219a54f61bf126bfc3fa068c6e33831222d1d7138c6faa9d33ca87fd4202d6022063f9902519624254d7c2c8ea7ba2d66ae975e4e229ae38043973ec707d5d4a83012103596d3451025c19dbbdeb932d6bf8bfb4ad499b95b6f88db8899efac102e5fc7102473044022017fb58502475848c1b09f162cb1688d0920ff7f142bed0ef904da2ccc88b168f02201798afa61850c65e77889cbcd648a5703b487895517c88f85cdd18b021ee246a012103596d3451025c19dbbdeb932d6bf8bfb4ad499b95b6f88db8899efac102e5fc7100000000000247304402202830b7926e488da75782c81a54cd281720890d1af064629ebf2e31bf9f5435f30220089afaa8b455bbeb7d9b9c3fe1ed37d07685ade8455c76472cda424d93e4074a012103596d3451025c19dbbdeb932d6bf8bfb4ad499b95b6f88db8899efac102e5fc7102473044022026326fcdae9207b596c2b05921dbac11d81040c4d40378513670f19d9f4af893022034ecd7a282c0163b89aaa62c22ec202cef4736c58cd251649bad0d8139bcbf55012103596d3451025c19dbbdeb932d6bf8bfb4ad499b95b6f88db8899efac102e5fc71024730440220214978daeb2f38cd426ee6e2f44131a33d6b191af1c216247f1dd7d74c16d84a02205fdc05529b0bc0c430b4d5987264d9d075351c4f4484c16e91662e90a72aab24012103596d3451025c19dbbdeb932d6bf8bfb4ad499b95b6f88db8899efac102e5fc710247304402204a6e9f199dc9672cf2ff8094aaa784363be1eb62b679f7ff2df361124f1dca3302205eeb11f70fab5355c9c8ad1a0700ea355d315e334822fa182227e9815308ee8f012103596d3451025c19dbbdeb932d6bf8bfb4ad499b95b6f88db8899efac102e5fc710000000000\", \"P2SH,WITNESS\"],\n+\n+[\"Unknown version witness program with empty witness\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"0x60 0x14 0x4c9c3dfac4207d5d8cb89df5722cb3d712385e3f\", 1000]],\n+\"010000000100010000000000000000000000000000000000000000000000000000000000000000000000ffffffff01e803000000000000015100000000\", \"P2SH,WITNESS\"],\n+\n+[\"Witness SIGHASH_SINGLE with output out of bound\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"0x51\", 1000],\n+[\"0000000000000000000000000000000000000000000000000000000000000100\", 1, \"0x00 0x20 0x4d6c2a32c87821d68fc016fca70797abdb80df6cd84651d40a9300c6bad79e62\", 1000]],\n+\"0100000000010200010000000000000000000000000000000000000000000000000000000000000000000000ffffffff00010000000000000000000000000000000000000000000000000000000000000100000000ffffffff01d00700000000000001510003483045022100e078de4e96a0e05dcdc0a414124dd8475782b5f3f0ed3f607919e9a5eeeb22bf02201de309b3a3109adb3de8074b3610d4cf454c49b61247a2779a0bcbf31c889333032103596d3451025c19dbbdeb932d6bf8bfb4ad499b95b6f88db8899efac102e5fc711976a9144c9c3dfac4207d5d8cb89df5722cb3d712385e3f88ac00000000\", \"P2SH,WITNESS\"],\n+\n+[\"1 byte push should not be considered a witness scriptPubKey\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"0x60 0x01 0x01\", 1000]],\n+\"010000000100010000000000000000000000000000000000000000000000000000000000000000000000ffffffff01e803000000000000015100000000\", \"P2SH,WITNESS,DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM\"],\n+\n+[\"41 bytes push should not be considered a witness scriptPubKey\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"0x60 0x29 0xff25429251b5a84f452230a3c75fd886b7fc5a7865ce4a7bb7a9d7c5be6da3dbff0000000000000000\", 1000]],\n+\"010000000100010000000000000000000000000000000000000000000000000000000000000000000000ffffffff01e803000000000000015100000000\", \"P2SH,WITNESS,DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM\"],\n+\n+[\"The witness version must use OP_1 to OP_16 only\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"0x01 0x10 0x02 0x0001\", 1000]],\n+\"010000000100010000000000000000000000000000000000000000000000000000000000000000000000ffffffff01e803000000000000015100000000\", \"P2SH,WITNESS,DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM\"],\n+\n+[\"The witness program push must be canonical\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"0x60 0x4c02 0x0001\", 1000]],\n+\"010000000100010000000000000000000000000000000000000000000000000000000000000000000000ffffffff01e803000000000000015100000000\", \"P2SH,WITNESS,DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM\"],\n+\n+[\"Witness Single|AnyoneCanPay does not hash input's position\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"0x00 0x14 0x4c9c3dfac4207d5d8cb89df5722cb3d712385e3f\", 1000],\n+[\"0000000000000000000000000000000000000000000000000000000000000100\", 1, \"0x00 0x14 0x4c9c3dfac4207d5d8cb89df5722cb3d712385e3f\", 1001]],\n+\"0100000000010200010000000000000000000000000000000000000000000000000000000000000000000000ffffffff00010000000000000000000000000000000000000000000000000000000000000100000000ffffffff02e8030000000000000151e90300000000000001510247304402206d59682663faab5e4cb733c562e22cdae59294895929ec38d7c016621ff90da0022063ef0af5f970afe8a45ea836e3509b8847ed39463253106ac17d19c437d3d56b832103596d3451025c19dbbdeb932d6bf8bfb4ad499b95b6f88db8899efac102e5fc710248304502210085001a820bfcbc9f9de0298af714493f8a37b3b354bfd21a7097c3e009f2018c022050a8b4dbc8155d4d04da2f5cdd575dcf8dd0108de8bec759bd897ea01ecb3af7832103596d3451025c19dbbdeb932d6bf8bfb4ad499b95b6f88db8899efac102e5fc7100000000\", \"P2SH,WITNESS\"],\n+\n+[\"Witness Single|AnyoneCanPay does not hash input's position (permutation)\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"0x00 0x14 0x4c9c3dfac4207d5d8cb89df5722cb3d712385e3f\", 1000],\n+[\"0000000000000000000000000000000000000000000000000000000000000100\", 1, \"0x00 0x14 0x4c9c3dfac4207d5d8cb89df5722cb3d712385e3f\", 1001]],\n+\"0100000000010200010000000000000000000000000000000000000000000000000000000000000100000000ffffffff00010000000000000000000000000000000000000000000000000000000000000000000000ffffffff02e9030000000000000151e80300000000000001510248304502210085001a820bfcbc9f9de0298af714493f8a37b3b354bfd21a7097c3e009f2018c022050a8b4dbc8155d4d04da2f5cdd575dcf8dd0108de8bec759bd897ea01ecb3af7832103596d3451025c19dbbdeb932d6bf8bfb4ad499b95b6f88db8899efac102e5fc710247304402206d59682663faab5e4cb733c562e22cdae59294895929ec38d7c016621ff90da0022063ef0af5f970afe8a45ea836e3509b8847ed39463253106ac17d19c437d3d56b832103596d3451025c19dbbdeb932d6bf8bfb4ad499b95b6f88db8899efac102e5fc7100000000\", \"P2SH,WITNESS\"],\n+\n+[\"Non witness Single|AnyoneCanPay hash input's position\"],\n+[[[\"0000000000000000000000000000000000000000000000000000000000000100\", 0, \"0x21 0x03596d3451025c19dbbdeb932d6bf8bfb4ad499b95b6f88db8899efac102e5fc71 CHECKSIG\", 1000],\n+[\"0000000000000000000000000000000000000000000000000000000000000100\", 1, \"0x21 0x03596d3451025c19dbbdeb932d6bf8bfb4ad499b95b6f88db8899efac102e5fc71 CHECKSIG\", 1001]],\n+\"01000000020001000000000000000000000000000000000000000000000000000000000000000000004847304402202a0b4b1294d70540235ae033d78e64b4897ec859c7b6f1b2b1d8a02e1d46006702201445e756d2254b0f1dfda9ab8e1e1bc26df9668077403204f32d16a49a36eb6983ffffffff00010000000000000000000000000000000000000000000000000000000000000100000049483045022100acb96cfdbda6dc94b489fd06f2d720983b5f350e31ba906cdbd800773e80b21c02200d74ea5bdf114212b4bbe9ed82c36d2e369e302dff57cb60d01c428f0bd3daab83ffffffff02e8030000000000000151e903000000000000015100000000\", \"P2SH,WITNESS\"],\n+\n+[\"BIP143 examples: details and private keys are available in BIP143\"],\n+[\"BIP143 example: P2WSH with OP_CODESEPARATOR and out-of-range SIGHASH_SINGLE.\"],\n+[[[\"6eb316926b1c5d567cd6f5e6a84fec606fc53d7b474526d1fff3948020c93dfe\", 0, \"0x21 0x036d5c20fa14fb2f635474c1dc4ef5909d4568e5569b79fc94d3448486e14685f8 CHECKSIG\", 156250000],\n+[\"f825690aee1b3dc247da796cacb12687a5e802429fd291cfd63e010f02cf1508\", 0, \"0x00 0x20 0x5d1b56b63d714eebe542309525f484b7e9d6f686b3781b6f61ef925d66d6f6a0\", 4900000000]],\n+\"01000000000102fe3dc9208094f3ffd12645477b3dc56f60ec4fa8e6f5d67c565d1c6b9216b36e000000004847304402200af4e47c9b9629dbecc21f73af989bdaa911f7e6f6c2e9394588a3aa68f81e9902204f3fcf6ade7e5abb1295b6774c8e0abd94ae62217367096bc02ee5e435b67da201ffffffff0815cf020f013ed6cf91d29f4202e8a58726b1ac6c79da47c23d1bee0a6925f80000000000ffffffff0100f2052a010000001976a914a30741f8145e5acadf23f751864167f32e0963f788ac000347304402200de66acf4527789bfda55fc5459e214fa6083f936b430a762c629656216805ac0220396f550692cd347171cbc1ef1f51e15282e837bb2b30860dc77c8f78bc8501e503473044022027dc95ad6b740fe5129e7e62a75dd00f291a2aeb1200b84b09d9e3789406b6c002201a9ecd315dd6a0e632ab20bbb98948bc0c6fb204f2c286963bb48517a7058e27034721026dccc749adc2a9d0d89497ac511f760f45c47dc5ed9cf352a58ac706453880aeadab210255a9626aebf5e29c0e6538428ba0d1dcf6ca98ffdf086aa8ced5e0d0215ea465ac00000000\", \"P2SH,WITNESS\"],\n+\n+[\"BIP143 example: P2WSH with unexecuted OP_CODESEPARATOR and SINGLE|ANYONECANPAY\"],\n+[[[\"01c0cf7fba650638e55eb91261b183251fbb466f90dff17f10086817c542b5e9\", 0, \"0x00 0x20 0xba468eea561b26301e4cf69fa34bde4ad60c81e70f059f045ca9a79931004a4d\", 16777215],\n+[\"1b2a9a426ba603ba357ce7773cb5805cb9c7c2b386d100d1fc9263513188e680\", 0, \"0x00 0x20 0xd9bbfbe56af7c4b7f960a70d7ea107156913d9e5a26b0a71429df5e097ca6537\", 16777215]],\n+\"01000000000102e9b542c5176808107ff1df906f46bb1f2583b16112b95ee5380665ba7fcfc0010000000000ffffffff80e68831516392fcd100d186b3c2c7b95c80b53c77e77c35ba03a66b429a2a1b0000000000ffffffff0280969800000000001976a914de4b231626ef508c9a74a8517e6783c0546d6b2888ac80969800000000001976a9146648a8cd4531e1ec47f35916de8e259237294d1e88ac02483045022100f6a10b8604e6dc910194b79ccfc93e1bc0ec7c03453caaa8987f7d6c3413566002206216229ede9b4d6ec2d325be245c5b508ff0339bf1794078e20bfe0babc7ffe683270063ab68210392972e2eb617b2388771abe27235fd5ac44af8e61693261550447a4c3e39da98ac024730440220032521802a76ad7bf74d0e2c218b72cf0cbc867066e2e53db905ba37f130397e02207709e2188ed7f08f4c952d9d13986da504502b8c3be59617e043552f506c46ff83275163ab68210392972e2eb617b2388771abe27235fd5ac44af8e61693261550447a4c3e39da98ac00000000\", \"P2SH,WITNESS\"],\n+\n+[\"BIP143 example: Same as the previous example with input-output paris swapped\"],\n+[[[\"1b2a9a426ba603ba357ce7773cb5805cb9c7c2b386d100d1fc9263513188e680\", 0, \"0x00 0x20 0xd9bbfbe56af7c4b7f960a70d7ea107156913d9e5a26b0a71429df5e097ca6537\", 16777215],\n+[\"01c0cf7fba650638e55eb91261b183251fbb466f90dff17f10086817c542b5e9\", 0, \"0x00 0x20 0xba468eea561b26301e4cf69fa34bde4ad60c81e70f059f045ca9a79931004a4d\", 16777215]],\n+\"0100000000010280e68831516392fcd100d186b3c2c7b95c80b53c77e77c35ba03a66b429a2a1b0000000000ffffffffe9b542c5176808107ff1df906f46bb1f2583b16112b95ee5380665ba7fcfc0010000000000ffffffff0280969800000000001976a9146648a8cd4531e1ec47f35916de8e259237294d1e88ac80969800000000001976a914de4b231626ef508c9a74a8517e6783c0546d6b2888ac024730440220032521802a76ad7bf74d0e2c218b72cf0cbc867066e2e53db905ba37f130397e02207709e2188ed7f08f4c952d9d13986da504502b8c3be59617e043552f506c46ff83275163ab68210392972e2eb617b2388771abe27235fd5ac44af8e61693261550447a4c3e39da98ac02483045022100f6a10b8604e6dc910194b79ccfc93e1bc0ec7c03453caaa8987f7d6c3413566002206216229ede9b4d6ec2d325be245c5b508ff0339bf1794078e20bfe0babc7ffe683270063ab68210392972e2eb617b2388771abe27235fd5ac44af8e61693261550447a4c3e39da98ac00000000\", \"P2SH,WITNESS\"],\n+\n+[\"BIP143 example: P2SH-P2WSH 6-of-6 multisig signed with 6 different SIGHASH types\"],\n+[[[\"6eb98797a21c6c10aa74edf29d618be109f48a8e94c694f3701e08ca69186436\", 1, \"HASH160 0x14 0x9993a429037b5d912407a71c252019287b8d27a5 EQUAL\", 987654321]],\n+\"0100000000010136641869ca081e70f394c6948e8af409e18b619df2ed74aa106c1ca29787b96e0100000023220020a16b5755f7f6f96dbd65f5f0d6ab9418b89af4b1f14a1bb8a09062c35f0dcb54ffffffff0200e9a435000000001976a914389ffce9cd9ae88dcc0631e88a821ffdbe9bfe2688acc0832f05000000001976a9147480a33f950689af511e6e84c138dbbd3c3ee41588ac080047304402206ac44d672dac41f9b00e28f4df20c52eeb087207e8d758d76d92c6fab3b73e2b0220367750dbbe19290069cba53d096f44530e4f98acaa594810388cf7409a1870ce01473044022068c7946a43232757cbdf9176f009a928e1cd9a1a8c212f15c1e11ac9f2925d9002205b75f937ff2f9f3c1246e547e54f62e027f64eefa2695578cc6432cdabce271502473044022059ebf56d98010a932cf8ecfec54c48e6139ed6adb0728c09cbe1e4fa0915302e022007cd986c8fa870ff5d2b3a89139c9fe7e499259875357e20fcbb15571c76795403483045022100fbefd94bd0a488d50b79102b5dad4ab6ced30c4069f1eaa69a4b5a763414067e02203156c6a5c9cf88f91265f5a942e96213afae16d83321c8b31bb342142a14d16381483045022100a5263ea0553ba89221984bd7f0b13613db16e7a70c549a86de0cc0444141a407022005c360ef0ae5a5d4f9f2f87a56c1546cc8268cab08c73501d6b3be2e1e1a8a08824730440220525406a1482936d5a21888260dc165497a90a15669636d8edca6b9fe490d309c022032af0c646a34a44d1f4576bf6a4a74b67940f8faa84c7df9abe12a01a11e2b4783cf56210307b8ae49ac90a048e9b53357a2354b3334e9c8bee813ecb98e99a7e07e8c3ba32103b28f0c28bfab54554ae8c658ac5c3e0ce6e79ad336331f78c428dd43eea8449b21034b8113d703413d57761b8b9781957b8c0ac1dfe69f492580ca4195f50376ba4a21033400f6afecb833092a9a21cfdf1ed1376e58c5d1f47de74683123987e967a8f42103a6d48b1131e94ba04d9737d61acdaa1322008af9602b3b14862c07a1789aac162102d8b661b0b3302ee2f162b09e07a55ad5dfbe673a9f01d9f0c19617681024306b56ae00000000\", \"P2SH,WITNESS\"],\n+\n [\"Make diffs cleaner by leaving a comment here without comma at the end\"]\n ]"
      },
      {
        "sha": "fd4f174b40c808c6ac6328a1e0db7c2c4fea55b5",
        "filename": "src/test/transaction_tests.cpp",
        "status": "modified",
        "additions": 30,
        "deletions": 10,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/00f46cbcd9d33fadfeb391e764bda3ac220be3ea/src/test/transaction_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/00f46cbcd9d33fadfeb391e764bda3ac220be3ea/src/test/transaction_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/transaction_tests.cpp?ref=00f46cbcd9d33fadfeb391e764bda3ac220be3ea",
        "patch": "@@ -50,7 +50,9 @@ static std::map<string, unsigned int> mapFlagNames = boost::assign::map_list_of\n     (string(\"DISCOURAGE_UPGRADABLE_NOPS\"), (unsigned int)SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS)\n     (string(\"CLEANSTACK\"), (unsigned int)SCRIPT_VERIFY_CLEANSTACK)\n     (string(\"CHECKLOCKTIMEVERIFY\"), (unsigned int)SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY)\n-    (string(\"CHECKSEQUENCEVERIFY\"), (unsigned int)SCRIPT_VERIFY_CHECKSEQUENCEVERIFY);\n+    (string(\"CHECKSEQUENCEVERIFY\"), (unsigned int)SCRIPT_VERIFY_CHECKSEQUENCEVERIFY)\n+    (string(\"WITNESS\"), (unsigned int)SCRIPT_VERIFY_WITNESS)\n+    (string(\"DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM\"), (unsigned int)SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM);\n \n unsigned int ParseScriptFlags(string strFlags)\n {\n@@ -113,6 +115,7 @@ BOOST_AUTO_TEST_CASE(tx_valid)\n             }\n \n             map<COutPoint, CScript> mapprevOutScriptPubKeys;\n+            map<COutPoint, int64_t> mapprevOutValues;\n             UniValue inputs = test[0].get_array();\n             bool fValid = true;\n \t    for (unsigned int inpIdx = 0; inpIdx < inputs.size(); inpIdx++) {\n@@ -123,13 +126,17 @@ BOOST_AUTO_TEST_CASE(tx_valid)\n                     break;\n                 }\n                 UniValue vinput = input.get_array();\n-                if (vinput.size() != 3)\n+                if (vinput.size() < 3 || vinput.size() > 4)\n                 {\n                     fValid = false;\n                     break;\n                 }\n-\n-                mapprevOutScriptPubKeys[COutPoint(uint256S(vinput[0].get_str()), vinput[1].get_int())] = ParseScript(vinput[2].get_str());\n+                COutPoint outpoint(uint256S(vinput[0].get_str()), vinput[1].get_int());\n+                mapprevOutScriptPubKeys[outpoint] = ParseScript(vinput[2].get_str());\n+                if (vinput.size() >= 4)\n+                {\n+                    mapprevOutValues[outpoint] = vinput[3].get_int64();\n+                }\n             }\n             if (!fValid)\n             {\n@@ -155,9 +162,13 @@ BOOST_AUTO_TEST_CASE(tx_valid)\n                 }\n \n                 CAmount amount = 0;\n+                if (mapprevOutValues.count(tx.vin[i].prevout)) {\n+                    amount = mapprevOutValues[tx.vin[i].prevout];\n+                }\n                 unsigned int verify_flags = ParseScriptFlags(test[2].get_str());\n+                const CScriptWitness *witness = (i < tx.wit.vtxinwit.size()) ? &tx.wit.vtxinwit[i].scriptWitness : NULL;\n                 BOOST_CHECK_MESSAGE(VerifyScript(tx.vin[i].scriptSig, mapprevOutScriptPubKeys[tx.vin[i].prevout],\n-                                                 NULL, verify_flags, TransactionSignatureChecker(&tx, i, amount), &err),\n+                                                 witness, verify_flags, TransactionSignatureChecker(&tx, i, amount), &err),\n                                     strTest);\n                 BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n             }\n@@ -189,6 +200,7 @@ BOOST_AUTO_TEST_CASE(tx_invalid)\n             }\n \n             map<COutPoint, CScript> mapprevOutScriptPubKeys;\n+            map<COutPoint, int64_t> mapprevOutValues;\n             UniValue inputs = test[0].get_array();\n             bool fValid = true;\n \t    for (unsigned int inpIdx = 0; inpIdx < inputs.size(); inpIdx++) {\n@@ -199,13 +211,17 @@ BOOST_AUTO_TEST_CASE(tx_invalid)\n                     break;\n                 }\n                 UniValue vinput = input.get_array();\n-                if (vinput.size() != 3)\n+                if (vinput.size() < 3 || vinput.size() > 4)\n                 {\n                     fValid = false;\n                     break;\n                 }\n-\n-                mapprevOutScriptPubKeys[COutPoint(uint256S(vinput[0].get_str()), vinput[1].get_int())] = ParseScript(vinput[2].get_str());\n+                COutPoint outpoint(uint256S(vinput[0].get_str()), vinput[1].get_int());\n+                mapprevOutScriptPubKeys[outpoint] = ParseScript(vinput[2].get_str());\n+                if (vinput.size() >= 4)\n+                {\n+                    mapprevOutValues[outpoint] = vinput[3].get_int64();\n+                }\n             }\n             if (!fValid)\n             {\n@@ -231,8 +247,12 @@ BOOST_AUTO_TEST_CASE(tx_invalid)\n \n                 unsigned int verify_flags = ParseScriptFlags(test[2].get_str());\n                 CAmount amount = 0;\n+                if (mapprevOutValues.count(tx.vin[i].prevout)) {\n+                    amount = mapprevOutValues[tx.vin[i].prevout];\n+                }\n+                const CScriptWitness *witness = (i < tx.wit.vtxinwit.size()) ? &tx.wit.vtxinwit[i].scriptWitness : NULL;\n                 fValid = VerifyScript(tx.vin[i].scriptSig, mapprevOutScriptPubKeys[tx.vin[i].prevout],\n-                                      NULL, verify_flags, TransactionSignatureChecker(&tx, i, amount), &err);\n+                                      witness, verify_flags, TransactionSignatureChecker(&tx, i, amount), &err);\n             }\n             BOOST_CHECK_MESSAGE(!fValid, strTest);\n             BOOST_CHECK_MESSAGE(err != SCRIPT_ERR_OK, ScriptErrorString(err));\n@@ -422,7 +442,7 @@ BOOST_AUTO_TEST_CASE(test_witness)\n     scriptPubkey1 << ToByteVector(pubkey1) << OP_CHECKSIG;\n     scriptPubkey2 << ToByteVector(pubkey2) << OP_CHECKSIG;\n     scriptPubkey1L << ToByteVector(pubkey1L) << OP_CHECKSIG;\n-    scriptPubkey2L << ToByteVector(pubkey2L) << OP_CHECKSIG; \n+    scriptPubkey2L << ToByteVector(pubkey2L) << OP_CHECKSIG;\n     std::vector<CPubKey> oneandthree;\n     oneandthree.push_back(pubkey1);\n     oneandthree.push_back(pubkey3);"
      }
    ]
  },
  {
    "sha": "06d3805c1a44aae39ad95538063e6882249b7633",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowNmQzODA1YzFhNDRhYWUzOWFkOTU1MzgwNjNlNjg4MjI0OWI3NjMz",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-04-04T14:01:27Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-06-22T13:43:01Z"
      },
      "message": "[qa] Add segwit support to script_tests\n\nContains fix by Johnson Lau.",
      "tree": {
        "sha": "967222b169dfe955a5ea7c8e3b71681e064a4941",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/967222b169dfe955a5ea7c8e3b71681e064a4941"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/06d3805c1a44aae39ad95538063e6882249b7633",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/06d3805c1a44aae39ad95538063e6882249b7633",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/06d3805c1a44aae39ad95538063e6882249b7633",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/06d3805c1a44aae39ad95538063e6882249b7633/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "00f46cbcd9d33fadfeb391e764bda3ac220be3ea",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/00f46cbcd9d33fadfeb391e764bda3ac220be3ea",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/00f46cbcd9d33fadfeb391e764bda3ac220be3ea"
      }
    ],
    "stats": {
      "total": 61,
      "additions": 42,
      "deletions": 19
    },
    "files": [
      {
        "sha": "f6ee7ade425302e891e1d5a8386c1327e7340cb2",
        "filename": "src/test/data/script_tests.json",
        "status": "modified",
        "additions": 7,
        "deletions": 1,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/06d3805c1a44aae39ad95538063e6882249b7633/src/test/data/script_tests.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/06d3805c1a44aae39ad95538063e6882249b7633/src/test/data/script_tests.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/data/script_tests.json?ref=06d3805c1a44aae39ad95538063e6882249b7633",
        "patch": "@@ -1,5 +1,5 @@\n [\n-[\"Format is: [scriptSig, scriptPubKey, flags, expected_scripterror, ... comments]\"],\n+[\"Format is: [[wit...]?, scriptSig, scriptPubKey, flags, expected_scripterror, ... comments]\"],\n [\"It is evaluated as if there was a crediting coinbase transaction with two 0\"],\n [\"pushes as scriptSig, and one output of 0 satoshi and given scriptPubKey,\"],\n [\"followed by a spending transaction which spends this output as only input (and\"],\n@@ -1253,6 +1253,12 @@\n [\"0x17 0x3014021077777777777777777777777777777777020001\", \"0 CHECKSIG NOT\", \"DERSIG\", \"SIG_DER\", \"Zero-length S is incorrectly encoded for DERSIG\"],\n [\"0x27 0x302402107777777777777777777777777777777702108777777777777777777777777777777701\", \"0 CHECKSIG NOT\", \"DERSIG\", \"SIG_DER\", \"Negative S is incorrectly encoded for DERSIG\"],\n \n+[\"Some basic segwit checks\"],\n+[[\"00\"], \"\", \"0 0x206e340b9cffb37a989ca544e6bb780a2c78901d3fb33738768511a30617afa01d\", \"P2SH,WITNESS\", \"EVAL_FALSE\", \"Invalid witness script\"],\n+[[\"51\"], \"\", \"0 0x206e340b9cffb37a989ca544e6bb780a2c78901d3fb33738768511a30617afa01d\", \"P2SH,WITNESS\", \"WITNESS_PROGRAM_MISMATCH\", \"Witness script hash mismatch\"],\n+[[\"00\"], \"\", \"0 0x206e340b9cffb37a989ca544e6bb780a2c78901d3fb33738768511a30617afa01d\", \"\", \"OK\", \"Invalid witness script without WITNESS\"],\n+[[\"51\"], \"\", \"0 0x206e340b9cffb37a989ca544e6bb780a2c78901d3fb33738768511a30617afa01d\", \"\", \"OK\", \"Witness script hash mismatch without WITNESS\"],\n+\n [\"Automatically generated test cases\"],\n [\n     \"0x47 0x304402200a5c6163f07b8d3b013c4d1d6dba25e780b39658d79ba37af7057a3b7f15ffa102201fd9b4eaa9943f734928b99a83592c2e7bf342ea2680f6a2bb705167966b742001\","
      },
      {
        "sha": "88f1562b103b01c255e2afd620b0b8401ea82dd8",
        "filename": "src/test/script_tests.cpp",
        "status": "modified",
        "additions": 35,
        "deletions": 18,
        "changes": 53,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/06d3805c1a44aae39ad95538063e6882249b7633/src/test/script_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/06d3805c1a44aae39ad95538063e6882249b7633/src/test/script_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_tests.cpp?ref=06d3805c1a44aae39ad95538063e6882249b7633",
        "patch": "@@ -88,7 +88,14 @@ static ScriptErrorDesc script_errors[]={\n     {SCRIPT_ERR_SIG_NULLDUMMY, \"SIG_NULLDUMMY\"},\n     {SCRIPT_ERR_PUBKEYTYPE, \"PUBKEYTYPE\"},\n     {SCRIPT_ERR_CLEANSTACK, \"CLEANSTACK\"},\n-    {SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS, \"DISCOURAGE_UPGRADABLE_NOPS\"}\n+    {SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS, \"DISCOURAGE_UPGRADABLE_NOPS\"},\n+    {SCRIPT_ERR_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM, \"DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM\"},\n+    {SCRIPT_ERR_WITNESS_PROGRAM_WRONG_LENGTH, \"WITNESS_PROGRAM_WRONG_LENGTH\"},\n+    {SCRIPT_ERR_WITNESS_PROGRAM_WITNESS_EMPTY, \"WITNESS_PROGRAM_WITNESS_EMPTY\"},\n+    {SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH, \"WITNESS_PROGRAM_MISMATCH\"},\n+    {SCRIPT_ERR_WITNESS_MALLEATED, \"WITNESS_MALLEATED\"},\n+    {SCRIPT_ERR_WITNESS_MALLEATED_P2SH, \"WITNESS_MALLEATED_P2SH\"},\n+    {SCRIPT_ERR_WITNESS_UNEXPECTED, \"WITNESS_UNEXPECTED\"},\n };\n \n const char *FormatScriptError(ScriptError_t err)\n@@ -127,13 +134,15 @@ CMutableTransaction BuildCreditingTransaction(const CScript& scriptPubKey)\n     return txCredit;\n }\n \n-CMutableTransaction BuildSpendingTransaction(const CScript& scriptSig, const CMutableTransaction& txCredit)\n+CMutableTransaction BuildSpendingTransaction(const CScript& scriptSig, const CScriptWitness& scriptWitness, const CMutableTransaction& txCredit)\n {\n     CMutableTransaction txSpend;\n     txSpend.nVersion = 1;\n     txSpend.nLockTime = 0;\n     txSpend.vin.resize(1);\n     txSpend.vout.resize(1);\n+    txSpend.wit.vtxinwit.resize(1);\n+    txSpend.wit.vtxinwit[0].scriptWitness = scriptWitness;\n     txSpend.vin[0].prevout.hash = txCredit.GetHash();\n     txSpend.vin[0].prevout.n = 0;\n     txSpend.vin[0].scriptSig = scriptSig;\n@@ -144,7 +153,7 @@ CMutableTransaction BuildSpendingTransaction(const CScript& scriptSig, const CMu\n     return txSpend;\n }\n \n-void DoTest(const CScript& scriptPubKey, const CScript& scriptSig, int flags, const std::string& message, int scriptError)\n+void DoTest(const CScript& scriptPubKey, const CScript& scriptSig, const CScriptWitness& scriptWitness, int flags, const std::string& message, int scriptError)\n {\n     bool expect = (scriptError == SCRIPT_ERR_OK);\n     if (flags & SCRIPT_VERIFY_CLEANSTACK) {\n@@ -153,12 +162,12 @@ void DoTest(const CScript& scriptPubKey, const CScript& scriptSig, int flags, co\n     }\n     ScriptError err;\n     CMutableTransaction txCredit = BuildCreditingTransaction(scriptPubKey);\n-    CMutableTransaction tx = BuildSpendingTransaction(scriptSig, txCredit);\n+    CMutableTransaction tx = BuildSpendingTransaction(scriptSig, scriptWitness, txCredit);\n     CMutableTransaction tx2 = tx;\n-    BOOST_CHECK_MESSAGE(VerifyScript(scriptSig, scriptPubKey, NULL, flags, MutableTransactionSignatureChecker(&tx, 0, txCredit.vout[0].nValue), &err) == expect, message);\n+    BOOST_CHECK_MESSAGE(VerifyScript(scriptSig, scriptPubKey, &scriptWitness, flags, MutableTransactionSignatureChecker(&tx, 0, txCredit.vout[0].nValue), &err) == expect, message);\n     BOOST_CHECK_MESSAGE(err == scriptError, std::string(FormatScriptError(err)) + \" where \" + std::string(FormatScriptError((ScriptError_t)scriptError)) + \" expected: \" + message);\n #if defined(HAVE_CONSENSUS_LIB)\n-    CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n+    CDataStream stream(SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_WITNESS);\n     stream << tx2;\n     if (flags & bitcoinconsensus_SCRIPT_FLAGS_VERIFY_WITNESS) {\n         BOOST_CHECK_MESSAGE(bitcoinconsensus_verify_script_with_amount(begin_ptr(scriptPubKey), scriptPubKey.size(), txCredit.vout[0].nValue, (const unsigned char*)&stream[0], stream.size(), 0, flags, NULL) == expect, message);\n@@ -280,7 +289,7 @@ class TestBuilder\n         } else {\n             creditTx = BuildCreditingTransaction(redeemScript);\n         }\n-        spendTx = BuildSpendingTransaction(CScript(), creditTx);\n+        spendTx = BuildSpendingTransaction(CScript(), CScriptWitness(), creditTx);\n     }\n \n     TestBuilder& ScriptError(ScriptError_t err)\n@@ -363,7 +372,7 @@ class TestBuilder\n     {\n         TestBuilder copy = *this; // Make a copy so we can rollback the push.\n         DoPush();\n-        DoTest(creditTx.vout[0].scriptPubKey, spendTx.vin[0].scriptSig, flags, comment, scriptError);\n+        DoTest(creditTx.vout[0].scriptPubKey, spendTx.vin[0].scriptSig, CScriptWitness(), flags, comment, scriptError);\n         *this = copy;\n         return *this;\n     }\n@@ -706,29 +715,37 @@ BOOST_AUTO_TEST_CASE(script_json_test)\n {\n     // Read tests from test/data/script_tests.json\n     // Format is an array of arrays\n-    // Inner arrays are [ \"scriptSig\", \"scriptPubKey\", \"flags\", \"expected_scripterror\" ]\n+    // Inner arrays are [ [\"wit\"...]?, \"scriptSig\", \"scriptPubKey\", \"flags\", \"expected_scripterror\" ]\n     // ... where scriptSig and scriptPubKey are stringified\n     // scripts.\n     UniValue tests = read_json(std::string(json_tests::script_tests, json_tests::script_tests + sizeof(json_tests::script_tests)));\n \n     for (unsigned int idx = 0; idx < tests.size(); idx++) {\n         UniValue test = tests[idx];\n         string strTest = test.write();\n-        if (test.size() < 4) // Allow size > 3; extra stuff ignored (useful for comments)\n+        CScriptWitness witness;\n+        unsigned int pos = 0;\n+        if (test.size() > 0 && test[pos].isArray()) {\n+            for (unsigned int i = 0; i < test[pos].size(); i++) {\n+                witness.stack.push_back(ParseHex(test[pos][i].get_str()));\n+            }\n+            pos++;\n+        }\n+        if (test.size() < 4 + pos) // Allow size > 3; extra stuff ignored (useful for comments)\n         {\n             if (test.size() != 1) {\n                 BOOST_ERROR(\"Bad test: \" << strTest);\n             }\n             continue;\n         }\n-        string scriptSigString = test[0].get_str();\n+        string scriptSigString = test[pos++].get_str();\n         CScript scriptSig = ParseScript(scriptSigString);\n-        string scriptPubKeyString = test[1].get_str();\n+        string scriptPubKeyString = test[pos++].get_str();\n         CScript scriptPubKey = ParseScript(scriptPubKeyString);\n-        unsigned int scriptflags = ParseScriptFlags(test[2].get_str());\n-        int scriptError = ParseScriptError(test[3].get_str());\n+        unsigned int scriptflags = ParseScriptFlags(test[pos++].get_str());\n+        int scriptError = ParseScriptError(test[pos++].get_str());\n \n-        DoTest(scriptPubKey, scriptSig, scriptflags, strTest, scriptError);\n+        DoTest(scriptPubKey, scriptSig, witness, scriptflags, strTest, scriptError);\n     }\n }\n \n@@ -806,7 +823,7 @@ BOOST_AUTO_TEST_CASE(script_CHECKMULTISIG12)\n     scriptPubKey12 << OP_1 << ToByteVector(key1.GetPubKey()) << ToByteVector(key2.GetPubKey()) << OP_2 << OP_CHECKMULTISIG;\n \n     CMutableTransaction txFrom12 = BuildCreditingTransaction(scriptPubKey12);\n-    CMutableTransaction txTo12 = BuildSpendingTransaction(CScript(), txFrom12);\n+    CMutableTransaction txTo12 = BuildSpendingTransaction(CScript(), CScriptWitness(), txFrom12);\n \n     CScript goodsig1 = sign_multisig(scriptPubKey12, key1, txTo12);\n     BOOST_CHECK(VerifyScript(goodsig1, scriptPubKey12, NULL, flags, MutableTransactionSignatureChecker(&txTo12, 0, txFrom12.vout[0].nValue), &err));\n@@ -837,7 +854,7 @@ BOOST_AUTO_TEST_CASE(script_CHECKMULTISIG23)\n     scriptPubKey23 << OP_2 << ToByteVector(key1.GetPubKey()) << ToByteVector(key2.GetPubKey()) << ToByteVector(key3.GetPubKey()) << OP_3 << OP_CHECKMULTISIG;\n \n     CMutableTransaction txFrom23 = BuildCreditingTransaction(scriptPubKey23);\n-    CMutableTransaction txTo23 = BuildSpendingTransaction(CScript(), txFrom23);\n+    CMutableTransaction txTo23 = BuildSpendingTransaction(CScript(), CScriptWitness(), txFrom23);\n \n     std::vector<CKey> keys;\n     keys.push_back(key1); keys.push_back(key2);\n@@ -910,7 +927,7 @@ BOOST_AUTO_TEST_CASE(script_combineSigs)\n     }\n \n     CMutableTransaction txFrom = BuildCreditingTransaction(GetScriptForDestination(keys[0].GetPubKey().GetID()));\n-    CMutableTransaction txTo = BuildSpendingTransaction(CScript(), txFrom);\n+    CMutableTransaction txTo = BuildSpendingTransaction(CScript(), CScriptWitness(), txFrom);\n     CScript& scriptPubKey = txFrom.vout[0].scriptPubKey;\n     CScript& scriptSig = txTo.vin[0].scriptSig;\n "
      }
    ]
  },
  {
    "sha": "66cca79130a204277e61088b7844b405dc3868a5",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2NmNjYTc5MTMwYTIwNDI3N2U2MTA4OGI3ODQ0YjQwNWRjMzg2OGE1",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-04-05T11:37:24Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-06-22T13:43:01Z"
      },
      "message": "[qa] Autogeneration support for witness in script_tests",
      "tree": {
        "sha": "5cb40f5a03b568f7e9918d556d117359a5b624cb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5cb40f5a03b568f7e9918d556d117359a5b624cb"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/66cca79130a204277e61088b7844b405dc3868a5",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/66cca79130a204277e61088b7844b405dc3868a5",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/66cca79130a204277e61088b7844b405dc3868a5",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/66cca79130a204277e61088b7844b405dc3868a5/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "06d3805c1a44aae39ad95538063e6882249b7633",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/06d3805c1a44aae39ad95538063e6882249b7633",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/06d3805c1a44aae39ad95538063e6882249b7633"
      }
    ],
    "stats": {
      "total": 237,
      "additions": 227,
      "deletions": 10
    },
    "files": [
      {
        "sha": "4311b0923fbece64532a852ddbaf081b8ee17f1d",
        "filename": "src/test/data/script_tests.json",
        "status": "modified",
        "additions": 132,
        "deletions": 0,
        "changes": 132,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/66cca79130a204277e61088b7844b405dc3868a5/src/test/data/script_tests.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/66cca79130a204277e61088b7844b405dc3868a5/src/test/data/script_tests.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/data/script_tests.json?ref=66cca79130a204277e61088b7844b405dc3868a5",
        "patch": "@@ -1834,6 +1834,138 @@\n     \"OK\",\n     \"P2SH with CLEANSTACK\"\n ],\n+[\n+    [\n+        \"3044022039105b995a5f448639a997a5c90fda06f50b49df30c3bdb6663217bf79323db002206fecd54269dec569fcc517178880eb58bb40f381a282bb75766ff3637d5f4b4301\",\n+        \"410479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8ac\"\n+    ],\n+    \"\",\n+    \"0 0x20 0xb95237b48faaa69eb078e1170be3b5cbb3fddf16d0a991e14ad274f7b33a4f64\",\n+    \"P2SH,WITNESS\",\n+    \"OK\",\n+    \"Basic P2WSH\"\n+],\n+[\n+    [\n+        \"304402201a96950593cb0af32d080b0f193517f4559241a8ebd1e95e414533ad64a3f423022047f4f6d3095c23235bdff3aeff480d0529c027a3f093cb265b7cbf148553b85101\",\n+        \"0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8\"\n+    ],\n+    \"\",\n+    \"0 0x14 0x91b24bf9f5288532960ac687abb035127b1d28a5\",\n+    \"P2SH,WITNESS\",\n+    \"OK\",\n+    \"Basic P2WPKH\"\n+],\n+[\n+    [\n+        \"3044022061fc1a144e221ec77a58a4281936eb6a1b715b9349e446e74d106ec26c8633ba022008064a0d112e8ad514440fcdfaa1006e48305d6844f50a65873fb4b2cf9c035f01\",\n+        \"410479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8ac\"\n+    ],\n+    \"0x22 0x0020b95237b48faaa69eb078e1170be3b5cbb3fddf16d0a991e14ad274f7b33a4f64\",\n+    \"HASH160 0x14 0xf386c2ba255cc56d20cfa6ea8b062f8b59945518 EQUAL\",\n+    \"P2SH,WITNESS\",\n+    \"OK\",\n+    \"Basic P2SH(P2WSH)\"\n+],\n+[\n+    [\n+        \"3044022014e69768e174972f21d32d93002ca6fc26133cb9e819ceef7efb970798bde7b4022078b86849dbbec692ec9355aa2a763fce7ea11bf72fdd8ea5ea8083de6f8a77fe01\",\n+        \"0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8\"\n+    ],\n+    \"0x16 0x001491b24bf9f5288532960ac687abb035127b1d28a5\",\n+    \"HASH160 0x14 0x17743beb429c55c942d2ec703b98c4d57c2df5c6 EQUAL\",\n+    \"P2SH,WITNESS\",\n+    \"OK\",\n+    \"Basic P2SH(P2WPKH)\"\n+],\n+[\n+    [\n+        \"304402202589f0512cb2408fb08ed9bd24f85eb3059744d9e4f2262d0b7f1338cff6e8b902206c0978f449693e0578c71bc543b11079fd0baae700ee5e9a6bee94db490af9fc01\",\n+        \"41048282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f5150811f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26cafac\"\n+    ],\n+    \"\",\n+    \"0 0x20 0xac8ebd9e52c17619a381fa4f71aebb696087c6ef17c960fd0587addad99c0610\",\n+    \"P2SH,WITNESS\",\n+    \"EVAL_FALSE\",\n+    \"Basic P2WSH with the wrong key\"\n+],\n+[\n+    [\n+        \"304402206ef7fdb2986325d37c6eb1a8bb24aeb46dede112ed8fc76c7d7500b9b83c0d3d02201edc2322c794fe2d6b0bd73ed319e714aa9b86d8891961530d5c9b7156b60d4e01\",\n+        \"048282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f5150811f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf\"\n+    ],\n+    \"\",\n+    \"0 0x14 0x7cf9c846cd4882efec4bf07e44ebdad495c94f4b\",\n+    \"P2SH,WITNESS\",\n+    \"EVAL_FALSE\",\n+    \"Basic P2WPKH with the wrong key\"\n+],\n+[\n+    [\n+        \"30440220069ea3581afaf8187f63feee1fd2bd1f9c0dc71ea7d6e8a8b07ee2ebcf824bf402201a4fdef4c532eae59223be1eda6a397fc835142d4ddc6c74f4aa85b766a5c16f01\",\n+        \"41048282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f5150811f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26cafac\"\n+    ],\n+    \"0x22 0x0020ac8ebd9e52c17619a381fa4f71aebb696087c6ef17c960fd0587addad99c0610\",\n+    \"HASH160 0x14 0x61039a003883787c0d6ebc66d97fdabe8e31449d EQUAL\",\n+    \"P2SH,WITNESS\",\n+    \"EVAL_FALSE\",\n+    \"Basic P2SH(P2WSH) with the wrong key\"\n+],\n+[\n+    [\n+        \"304402204209e49457c2358f80d0256bc24535b8754c14d08840fc4be762d6f5a0aed80b02202eaf7d8fc8d62f60c67adcd99295528d0e491ae93c195cec5a67e7a09532a88001\",\n+        \"048282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f5150811f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf\"\n+    ],\n+    \"0x16 0x00147cf9c846cd4882efec4bf07e44ebdad495c94f4b\",\n+    \"HASH160 0x14 0x4e0c2aed91315303fc6a1dc4c7bc21c88f75402e EQUAL\",\n+    \"P2SH,WITNESS\",\n+    \"EVAL_FALSE\",\n+    \"Basic P2SH(P2WPKH) with the wrong key\"\n+],\n+[\n+    [\n+        \"304402202589f0512cb2408fb08ed9bd24f85eb3059744d9e4f2262d0b7f1338cff6e8b902206c0978f449693e0578c71bc543b11079fd0baae700ee5e9a6bee94db490af9fc01\",\n+        \"41048282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f5150811f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26cafac\"\n+    ],\n+    \"\",\n+    \"0 0x20 0xac8ebd9e52c17619a381fa4f71aebb696087c6ef17c960fd0587addad99c0610\",\n+    \"P2SH\",\n+    \"OK\",\n+    \"Basic P2WSH with the wrong key but no WITNESS\"\n+],\n+[\n+    [\n+        \"304402206ef7fdb2986325d37c6eb1a8bb24aeb46dede112ed8fc76c7d7500b9b83c0d3d02201edc2322c794fe2d6b0bd73ed319e714aa9b86d8891961530d5c9b7156b60d4e01\",\n+        \"048282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f5150811f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf\"\n+    ],\n+    \"\",\n+    \"0 0x14 0x7cf9c846cd4882efec4bf07e44ebdad495c94f4b\",\n+    \"P2SH\",\n+    \"OK\",\n+    \"Basic P2WPKH with the wrong key but no WITNESS\"\n+],\n+[\n+    [\n+        \"30440220069ea3581afaf8187f63feee1fd2bd1f9c0dc71ea7d6e8a8b07ee2ebcf824bf402201a4fdef4c532eae59223be1eda6a397fc835142d4ddc6c74f4aa85b766a5c16f01\",\n+        \"41048282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f5150811f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26cafac\"\n+    ],\n+    \"0x22 0x0020ac8ebd9e52c17619a381fa4f71aebb696087c6ef17c960fd0587addad99c0610\",\n+    \"HASH160 0x14 0x61039a003883787c0d6ebc66d97fdabe8e31449d EQUAL\",\n+    \"P2SH\",\n+    \"OK\",\n+    \"Basic P2SH(P2WSH) with the wrong key but no WITNESS\"\n+],\n+[\n+    [\n+        \"304402204209e49457c2358f80d0256bc24535b8754c14d08840fc4be762d6f5a0aed80b02202eaf7d8fc8d62f60c67adcd99295528d0e491ae93c195cec5a67e7a09532a88001\",\n+        \"048282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f5150811f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf\"\n+    ],\n+    \"0x16 0x00147cf9c846cd4882efec4bf07e44ebdad495c94f4b\",\n+    \"HASH160 0x14 0x4e0c2aed91315303fc6a1dc4c7bc21c88f75402e EQUAL\",\n+    \"P2SH\",\n+    \"OK\",\n+    \"Basic P2SH(P2WPKH) with the wrong key but no WITNESS\"\n+],\n \n [\"CHECKSEQUENCEVERIFY tests\"], \n [\"\", \"NOP3\", \"CHECKSEQUENCEVERIFY\", \"INVALID_STACK_OPERATION\", \"CSV automatically fails on a empty stack\"],"
      },
      {
        "sha": "ab373edc90cf582cf7e21010b8408a83920fcf28",
        "filename": "src/test/script_tests.cpp",
        "status": "modified",
        "additions": 95,
        "deletions": 10,
        "changes": 105,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/66cca79130a204277e61088b7844b405dc3868a5/src/test/script_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/66cca79130a204277e61088b7844b405dc3868a5/src/test/script_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_tests.cpp?ref=66cca79130a204277e61088b7844b405dc3868a5",
        "patch": "@@ -167,7 +167,7 @@ void DoTest(const CScript& scriptPubKey, const CScript& scriptSig, const CScript\n     BOOST_CHECK_MESSAGE(VerifyScript(scriptSig, scriptPubKey, &scriptWitness, flags, MutableTransactionSignatureChecker(&tx, 0, txCredit.vout[0].nValue), &err) == expect, message);\n     BOOST_CHECK_MESSAGE(err == scriptError, std::string(FormatScriptError(err)) + \" where \" + std::string(FormatScriptError((ScriptError_t)scriptError)) + \" expected: \" + message);\n #if defined(HAVE_CONSENSUS_LIB)\n-    CDataStream stream(SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_WITNESS);\n+    CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n     stream << tx2;\n     if (flags & bitcoinconsensus_SCRIPT_FLAGS_VERIFY_WITNESS) {\n         BOOST_CHECK_MESSAGE(bitcoinconsensus_verify_script_with_amount(begin_ptr(scriptPubKey), scriptPubKey.size(), txCredit.vout[0].nValue, (const unsigned char*)&stream[0], stream.size(), 0, flags, NULL) == expect, message);\n@@ -253,11 +253,22 @@ struct KeyData\n     }\n };\n \n+enum WitnessMode {\n+    WITNESS_NONE,\n+    WITNESS_PKH,\n+    WITNESS_SH\n+};\n \n class TestBuilder\n {\n private:\n-    CScript scriptPubKey;\n+    //! Actually executed script\n+    CScript script;\n+    //! The P2SH redeemscript\n+    CScript redeemscript;\n+    //! The Witness embedded script\n+    CScript witscript;\n+    CScriptWitness scriptWitness;\n     CTransaction creditTx;\n     CMutableTransaction spendTx;\n     bool havePush;\n@@ -282,13 +293,25 @@ class TestBuilder\n     }\n \n public:\n-    TestBuilder(const CScript& redeemScript, const std::string& comment_, int flags_, bool P2SH = false) : scriptPubKey(redeemScript), havePush(false), comment(comment_), flags(flags_), scriptError(SCRIPT_ERR_OK)\n+    TestBuilder(const CScript& script_, const std::string& comment_, int flags_, bool P2SH = false, WitnessMode wm = WITNESS_NONE) : script(script_), havePush(false), comment(comment_), flags(flags_), scriptError(SCRIPT_ERR_OK)\n     {\n+        CScript scriptPubKey = script;\n+        if (wm == WITNESS_PKH) {\n+            uint160 hash;\n+            CHash160().Write(&script[1], script.size() - 1).Finalize(hash.begin());\n+            script = CScript() << OP_DUP << OP_HASH160 << ToByteVector(hash) << OP_EQUALVERIFY << OP_CHECKSIG;\n+            scriptPubKey = CScript() << OP_0 << ToByteVector(hash);\n+        } else if (wm == WITNESS_SH) {\n+            witscript = scriptPubKey;\n+            uint256 hash;\n+            CSHA256().Write(&witscript[0], witscript.size()).Finalize(hash.begin());\n+            scriptPubKey = CScript() << OP_0 << ToByteVector(hash);\n+        }\n         if (P2SH) {\n-            creditTx = BuildCreditingTransaction(CScript() << OP_HASH160 << ToByteVector(CScriptID(redeemScript)) << OP_EQUAL);\n-        } else {\n-            creditTx = BuildCreditingTransaction(redeemScript);\n+            redeemscript = scriptPubKey;\n+            scriptPubKey = CScript() << OP_HASH160 << ToByteVector(CScriptID(redeemscript)) << OP_EQUAL;\n         }\n+        creditTx = BuildCreditingTransaction(scriptPubKey);\n         spendTx = BuildSpendingTransaction(CScript(), CScriptWitness(), creditTx);\n     }\n \n@@ -318,9 +341,9 @@ class TestBuilder\n         return *this;\n     }\n \n-    TestBuilder& PushSig(const CKey& key, int nHashType = SIGHASH_ALL, unsigned int lenR = 32, unsigned int lenS = 32)\n+    TestBuilder& PushSig(const CKey& key, int nHashType = SIGHASH_ALL, unsigned int lenR = 32, unsigned int lenS = 32, SigVersion sigversion = SIGVERSION_BASE)\n     {\n-        uint256 hash = SignatureHash(scriptPubKey, spendTx, 0, nHashType, 0, SIGVERSION_BASE);\n+        uint256 hash = SignatureHash(script, spendTx, 0, nHashType, 0, sigversion);\n         std::vector<unsigned char> vchSig, r, s;\n         uint32_t iter = 0;\n         do {\n@@ -336,6 +359,11 @@ class TestBuilder\n         return *this;\n     }\n \n+    TestBuilder& PushWitSig(const CKey& key, int nHashType = SIGHASH_ALL, unsigned int lenR = 32, unsigned int lenS = 32, SigVersion sigversion = SIGVERSION_WITNESS_V0)\n+    {\n+        return PushSig(key, nHashType, lenR, lenS, sigversion).AsWit();\n+    }\n+\n     TestBuilder& Push(const CPubKey& pubkey)\n     {\n         DoPush(std::vector<unsigned char>(pubkey.begin(), pubkey.end()));\n@@ -344,10 +372,16 @@ class TestBuilder\n \n     TestBuilder& PushRedeem()\n     {\n-        DoPush(std::vector<unsigned char>(scriptPubKey.begin(), scriptPubKey.end()));\n+        DoPush(std::vector<unsigned char>(redeemscript.begin(), redeemscript.end()));\n         return *this;\n     }\n \n+    TestBuilder& PushWitRedeem()\n+    {\n+        DoPush(std::vector<unsigned char>(witscript.begin(), witscript.end()));\n+        return AsWit();\n+    }\n+\n     TestBuilder& EditPush(unsigned int pos, const std::string& hexin, const std::string& hexout)\n     {\n         assert(havePush);\n@@ -372,15 +406,30 @@ class TestBuilder\n     {\n         TestBuilder copy = *this; // Make a copy so we can rollback the push.\n         DoPush();\n-        DoTest(creditTx.vout[0].scriptPubKey, spendTx.vin[0].scriptSig, CScriptWitness(), flags, comment, scriptError);\n+        DoTest(creditTx.vout[0].scriptPubKey, spendTx.vin[0].scriptSig, scriptWitness, flags, comment, scriptError);\n         *this = copy;\n         return *this;\n     }\n \n+    TestBuilder& AsWit()\n+    {\n+        assert(havePush);\n+        scriptWitness.stack.push_back(push);\n+        havePush = false;\n+        return *this;\n+    }\n+\n     UniValue GetJSON()\n     {\n         DoPush();\n         UniValue array(UniValue::VARR);\n+        if (!scriptWitness.stack.empty()) {\n+            UniValue wit(UniValue::VARR);\n+            for (unsigned i = 0; i < scriptWitness.stack.size(); i++) {\n+                wit.push_back(HexStr(scriptWitness.stack[i]));\n+            }\n+            array.push_back(wit);\n+        }\n         array.push_back(FormatScript(spendTx.vin[0].scriptSig));\n         array.push_back(FormatScript(creditTx.vout[0].scriptPubKey));\n         array.push_back(FormatScriptFlags(flags));\n@@ -679,6 +728,42 @@ BOOST_AUTO_TEST_CASE(script_build)\n                                 \"P2SH with CLEANSTACK\", SCRIPT_VERIFY_CLEANSTACK | SCRIPT_VERIFY_P2SH, true\n                                ).PushSig(keys.key0).PushRedeem());\n \n+    tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0) << OP_CHECKSIG,\n+                                \"Basic P2WSH\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_SH\n+                               ).PushWitSig(keys.key0).PushWitRedeem());\n+    tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0),\n+                                \"Basic P2WPKH\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_PKH\n+                               ).PushWitSig(keys.key0).Push(keys.pubkey0).AsWit());\n+    tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0) << OP_CHECKSIG,\n+                                \"Basic P2SH(P2WSH)\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WITNESS_SH\n+                               ).PushWitSig(keys.key0).PushWitRedeem().PushRedeem());\n+    tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0),\n+                                \"Basic P2SH(P2WPKH)\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WITNESS_PKH\n+                               ).PushWitSig(keys.key0).Push(keys.pubkey0).AsWit().PushRedeem());\n+    tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1) << OP_CHECKSIG,\n+                                \"Basic P2WSH with the wrong key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_SH\n+                               ).PushWitSig(keys.key0).PushWitRedeem().ScriptError(SCRIPT_ERR_EVAL_FALSE));\n+    tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1),\n+                                \"Basic P2WPKH with the wrong key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_PKH\n+                               ).PushWitSig(keys.key0).Push(keys.pubkey1).AsWit().ScriptError(SCRIPT_ERR_EVAL_FALSE));\n+    tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1) << OP_CHECKSIG,\n+                                \"Basic P2SH(P2WSH) with the wrong key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WITNESS_SH\n+                               ).PushWitSig(keys.key0).PushWitRedeem().PushRedeem().ScriptError(SCRIPT_ERR_EVAL_FALSE));\n+    tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1),\n+                                \"Basic P2SH(P2WPKH) with the wrong key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WITNESS_PKH\n+                               ).PushWitSig(keys.key0).Push(keys.pubkey1).AsWit().PushRedeem().ScriptError(SCRIPT_ERR_EVAL_FALSE));\n+    tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1) << OP_CHECKSIG,\n+                                \"Basic P2WSH with the wrong key but no WITNESS\", SCRIPT_VERIFY_P2SH, false, WITNESS_SH\n+                               ).PushWitSig(keys.key0).PushWitRedeem());\n+    tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1),\n+                                \"Basic P2WPKH with the wrong key but no WITNESS\", SCRIPT_VERIFY_P2SH, false, WITNESS_PKH\n+                               ).PushWitSig(keys.key0).Push(keys.pubkey1).AsWit());\n+    tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1) << OP_CHECKSIG,\n+                                \"Basic P2SH(P2WSH) with the wrong key but no WITNESS\", SCRIPT_VERIFY_P2SH, true, WITNESS_SH\n+                               ).PushWitSig(keys.key0).PushWitRedeem().PushRedeem());\n+    tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1),\n+                                \"Basic P2SH(P2WPKH) with the wrong key but no WITNESS\", SCRIPT_VERIFY_P2SH, true, WITNESS_PKH\n+                               ).PushWitSig(keys.key0).Push(keys.pubkey1).AsWit().PushRedeem());\n \n     std::set<std::string> tests_set;\n "
      }
    ]
  },
  {
    "sha": "4f7ff00497803fddc5a0fb5340502a73e395134d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0ZjdmZjAwNDk3ODAzZmRkYzVhMGZiNTM0MDUwMmE3M2UzOTUxMzRk",
    "commit": {
      "author": {
        "name": "Alex Morcos",
        "email": "morcos@chaincode.com",
        "date": "2016-01-02T05:18:34Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-06-22T13:43:01Z"
      },
      "message": "[qa] Add rpc test for segwit\n\nAmended by Pieter Wuille to use multisig 1-of-1 for P2WSH tests, and BIP9\nbased switchover logic.\n\nFixes and py3 conversion by Marco Falke.",
      "tree": {
        "sha": "9b457d5396f5972e70bdafef67775462ef954f7c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9b457d5396f5972e70bdafef67775462ef954f7c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4f7ff00497803fddc5a0fb5340502a73e395134d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4f7ff00497803fddc5a0fb5340502a73e395134d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4f7ff00497803fddc5a0fb5340502a73e395134d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4f7ff00497803fddc5a0fb5340502a73e395134d/comments",
    "author": {
      "login": "morcos",
      "id": 4360349,
      "node_id": "MDQ6VXNlcjQzNjAzNDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4360349?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morcos",
      "html_url": "https://github.com/morcos",
      "followers_url": "https://api.github.com/users/morcos/followers",
      "following_url": "https://api.github.com/users/morcos/following{/other_user}",
      "gists_url": "https://api.github.com/users/morcos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morcos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
      "organizations_url": "https://api.github.com/users/morcos/orgs",
      "repos_url": "https://api.github.com/users/morcos/repos",
      "events_url": "https://api.github.com/users/morcos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morcos/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "66cca79130a204277e61088b7844b405dc3868a5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/66cca79130a204277e61088b7844b405dc3868a5",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/66cca79130a204277e61088b7844b405dc3868a5"
      }
    ],
    "stats": {
      "total": 229,
      "additions": 222,
      "deletions": 7
    },
    "files": [
      {
        "sha": "06c9551cebae5bf4aaac785a49e967052ce267d7",
        "filename": "contrib/devtools/check-doc.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4f7ff00497803fddc5a0fb5340502a73e395134d/contrib/devtools/check-doc.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4f7ff00497803fddc5a0fb5340502a73e395134d/contrib/devtools/check-doc.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/check-doc.py?ref=4f7ff00497803fddc5a0fb5340502a73e395134d",
        "patch": "@@ -21,7 +21,7 @@\n REGEX_ARG = re.compile(r'(?:map(?:Multi)?Args(?:\\.count\\(|\\[)|Get(?:Bool)?Arg\\()\\\"(\\-[^\\\"]+?)\\\"')\n REGEX_DOC = re.compile(r'HelpMessageOpt\\(\\\"(\\-[^\\\"=]+?)(?:=|\\\")')\n # list unsupported, deprecated and duplicate args as they need no documentation\n-SET_DOC_OPTIONAL = set(['-rpcssl', '-benchmark', '-h', '-help', '-socks', '-tor', '-debugnet', '-whitelistalwaysrelay'])\n+SET_DOC_OPTIONAL = set(['-rpcssl', '-benchmark', '-h', '-help', '-socks', '-tor', '-debugnet', '-whitelistalwaysrelay', '-prematurewitness', '-walletprematurewitness', '-promiscuousmempoolflags'])\n \n def main():\n   used = check_output(CMD_GREP_ARGS, shell=True)"
      },
      {
        "sha": "8fa20945e665bacc30f51ea0d37135e6171b8d3d",
        "filename": "qa/pull-tester/rpc-tests.py",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4f7ff00497803fddc5a0fb5340502a73e395134d/qa/pull-tester/rpc-tests.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4f7ff00497803fddc5a0fb5340502a73e395134d/qa/pull-tester/rpc-tests.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/pull-tester/rpc-tests.py?ref=4f7ff00497803fddc5a0fb5340502a73e395134d",
        "patch": "@@ -136,6 +136,7 @@\n     'invalidtxrequest.py',\n     'abandonconflict.py',\n     'p2p-versionbits-warning.py',\n+    'segwit.py',\n     'importprunedfunds.py',\n     'signmessages.py',\n ]"
      },
      {
        "sha": "d4c9a8afed32cd621fad6d72ac8ea8fff0d17850",
        "filename": "qa/rpc-tests/segwit.py",
        "status": "added",
        "additions": 209,
        "deletions": 0,
        "changes": 209,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4f7ff00497803fddc5a0fb5340502a73e395134d/qa/rpc-tests/segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4f7ff00497803fddc5a0fb5340502a73e395134d/qa/rpc-tests/segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/segwit.py?ref=4f7ff00497803fddc5a0fb5340502a73e395134d",
        "patch": "@@ -0,0 +1,209 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2016 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#\n+# Test the SegWit changeover logic\n+#\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+from test_framework.mininode import sha256, ripemd160\n+import os\n+import shutil\n+\n+NODE_0 = 0\n+NODE_1 = 1\n+NODE_2 = 2\n+WIT_V0 = 0\n+WIT_V1 = 1\n+\n+def witness_script(version, pubkey):\n+    if (version == 0):\n+        pubkeyhash = bytes_to_hex_str(ripemd160(sha256(hex_str_to_bytes(pubkey))))\n+        pkscript = \"0014\" + pubkeyhash\n+    elif (version == 1):\n+        # 1-of-1 multisig\n+        scripthash = bytes_to_hex_str(sha256(hex_str_to_bytes(\"5121\" + pubkey + \"51ae\")))\n+        pkscript = \"0020\" + scripthash\n+    else:\n+        assert(\"Wrong version\" == \"0 or 1\")\n+    return pkscript\n+\n+def addlength(script):\n+    scriptlen = format(len(script)//2, 'x')\n+    assert(len(scriptlen) == 2)\n+    return scriptlen + script\n+\n+def create_witnessprogram(version, node, utxo, pubkey, encode_p2sh, amount):\n+    pkscript = witness_script(version, pubkey);\n+    if (encode_p2sh):\n+        p2sh_hash = bytes_to_hex_str(ripemd160(sha256(hex_str_to_bytes(pkscript))))\n+        pkscript = \"a914\"+p2sh_hash+\"87\"\n+    inputs = []\n+    outputs = {}\n+    inputs.append({ \"txid\" : utxo[\"txid\"], \"vout\" : utxo[\"vout\"]} )\n+    DUMMY_P2SH = \"2MySexEGVzZpRgNQ1JdjdP5bRETznm3roQ2\" # P2SH of \"OP_1 OP_DROP\"\n+    outputs[DUMMY_P2SH] = amount\n+    tx_to_witness = node.createrawtransaction(inputs,outputs)\n+    #replace dummy output with our own\n+    tx_to_witness = tx_to_witness[0:110] + addlength(pkscript) + tx_to_witness[-8:]\n+    return tx_to_witness\n+\n+def send_to_witness(version, node, utxo, pubkey, encode_p2sh, amount, sign=True, insert_redeem_script=\"\"):\n+    tx_to_witness = create_witnessprogram(version, node, utxo, pubkey, encode_p2sh, amount)\n+    if (sign):\n+        signed = node.signrawtransaction(tx_to_witness)\n+        assert(\"errors\" not in signed or len([\"errors\"]) == 0)\n+        return node.sendrawtransaction(signed[\"hex\"])\n+    else:\n+        if (insert_redeem_script):\n+            tx_to_witness = tx_to_witness[0:82] + addlength(insert_redeem_script) + tx_to_witness[84:]\n+\n+    return node.sendrawtransaction(tx_to_witness)\n+\n+def getutxo(txid):\n+    utxo = {}\n+    utxo[\"vout\"] = 0\n+    utxo[\"txid\"] = txid\n+    return utxo\n+\n+class SegWitTest(BitcoinTestFramework):\n+\n+    def setup_chain(self):\n+        print(\"Initializing test directory \"+self.options.tmpdir)\n+        initialize_chain_clean(self.options.tmpdir, 3)\n+\n+    def setup_network(self):\n+        self.nodes = []\n+        self.nodes.append(start_node(0, self.options.tmpdir, [\"-logtimemicros\", \"-debug\", \"-walletprematurewitness\"]))\n+        self.nodes.append(start_node(1, self.options.tmpdir, [\"-logtimemicros\", \"-debug\", \"-blockversion=4\", \"-promiscuousmempoolflags=517\", \"-prematurewitness\", \"-walletprematurewitness\"]))\n+        self.nodes.append(start_node(2, self.options.tmpdir, [\"-logtimemicros\", \"-debug\", \"-blockversion=536870915\", \"-promiscuousmempoolflags=517\", \"-prematurewitness\", \"-walletprematurewitness\"]))\n+        connect_nodes(self.nodes[1], 0)\n+        connect_nodes(self.nodes[2], 1)\n+        connect_nodes(self.nodes[0], 2)\n+        self.is_network_split = False\n+        self.sync_all()\n+\n+    def success_mine(self, node, txid, sign, redeem_script=\"\"):\n+        send_to_witness(1, node, getutxo(txid), self.pubkey[0], False, Decimal(\"49.998\"), sign, redeem_script)\n+        block = node.generate(1)\n+        assert_equal(len(node.getblock(block[0])[\"tx\"]), 2)\n+        sync_blocks(self.nodes)\n+\n+    def skip_mine(self, node, txid, sign, redeem_script=\"\"):\n+        send_to_witness(1, node, getutxo(txid), self.pubkey[0], False, Decimal(\"49.998\"), sign, redeem_script)\n+        block = node.generate(1)\n+        assert_equal(len(node.getblock(block[0])[\"tx\"]), 1)\n+        sync_blocks(self.nodes)\n+\n+    def fail_accept(self, node, txid, sign, redeem_script=\"\"):\n+        try:\n+            send_to_witness(1, node, getutxo(txid), self.pubkey[0], False, Decimal(\"49.998\"), sign, redeem_script)\n+        except JSONRPCException as exp:\n+            assert(exp.error[\"code\"] == -26)\n+        else:\n+            raise AssertionError(\"Tx should not have been accepted\")\n+\n+    def fail_mine(self, node, txid, sign, redeem_script=\"\"):\n+        send_to_witness(1, node, getutxo(txid), self.pubkey[0], False, Decimal(\"49.998\"), sign, redeem_script)\n+        try:\n+            node.generate(1)\n+        except JSONRPCException as exp:\n+            assert(exp.error[\"code\"] == -1)\n+        else:\n+            raise AssertionError(\"Created valid block when TestBlockValidity should have failed\")\n+        sync_blocks(self.nodes)\n+\n+    def run_test(self):\n+        self.nodes[0].generate(160) #block 160\n+\n+        self.pubkey = []\n+        p2sh_ids = [] # p2sh_ids[NODE][VER] is an array of txids that spend to a witness version VER pkscript to an address for NODE embedded in p2sh\n+        wit_ids = [] # wit_ids[NODE][VER] is an array of txids that spend to a witness version VER pkscript to an address for NODE via bare witness\n+        for i in range(3):\n+            newaddress = self.nodes[i].getnewaddress()\n+            self.pubkey.append(self.nodes[i].validateaddress(newaddress)[\"pubkey\"])\n+            multiaddress = self.nodes[i].addmultisigaddress(1, [self.pubkey[-1]])\n+            self.nodes[i].addwitnessaddress(newaddress)\n+            self.nodes[i].addwitnessaddress(multiaddress)\n+            p2sh_ids.append([])\n+            wit_ids.append([])\n+            for v in range(2):\n+                p2sh_ids[i].append([])\n+                wit_ids[i].append([])\n+\n+        for i in range(5):\n+            for n in range(3):\n+                for v in range(2):\n+                    wit_ids[n][v].append(send_to_witness(v, self.nodes[0], self.nodes[0].listunspent()[0], self.pubkey[n], False, Decimal(\"49.999\")))\n+                    p2sh_ids[n][v].append(send_to_witness(v, self.nodes[0], self.nodes[0].listunspent()[0], self.pubkey[n], True, Decimal(\"49.999\")))\n+\n+        self.nodes[0].generate(1) #block 161\n+        sync_blocks(self.nodes)\n+\n+        # Make sure all nodes recognize the transactions as theirs\n+        assert_equal(self.nodes[0].getbalance(), 60*50 - 60*50 + 20*Decimal(\"49.999\") + 50)\n+        assert_equal(self.nodes[1].getbalance(), 20*Decimal(\"49.999\"))\n+        assert_equal(self.nodes[2].getbalance(), 20*Decimal(\"49.999\"))\n+\n+        self.nodes[0].generate(262) #block 423\n+        sync_blocks(self.nodes)\n+\n+        print(\"Verify default node can't accept any witness format txs before fork\")\n+        # unsigned, no scriptsig\n+        self.fail_accept(self.nodes[0], wit_ids[NODE_0][WIT_V0][0], False)\n+        self.fail_accept(self.nodes[0], wit_ids[NODE_0][WIT_V1][0], False)\n+        self.fail_accept(self.nodes[0], p2sh_ids[NODE_0][WIT_V0][0], False)\n+        self.fail_accept(self.nodes[0], p2sh_ids[NODE_0][WIT_V1][0], False)\n+        # unsigned with redeem script\n+        self.fail_accept(self.nodes[0], p2sh_ids[NODE_0][WIT_V0][0], False, addlength(witness_script(0, self.pubkey[0])))\n+        self.fail_accept(self.nodes[0], p2sh_ids[NODE_0][WIT_V1][0], False, addlength(witness_script(1, self.pubkey[0])))\n+        # signed\n+        self.fail_accept(self.nodes[0], wit_ids[NODE_0][WIT_V0][0], True)\n+        self.fail_accept(self.nodes[0], wit_ids[NODE_0][WIT_V1][0], True)\n+        self.fail_accept(self.nodes[0], p2sh_ids[NODE_0][WIT_V0][0], True)\n+        self.fail_accept(self.nodes[0], p2sh_ids[NODE_0][WIT_V1][0], True)\n+\n+        print(\"Verify witness txs are skipped for mining before the fork\")\n+        self.skip_mine(self.nodes[2], wit_ids[NODE_2][WIT_V0][0], True) #block 424\n+        self.skip_mine(self.nodes[2], wit_ids[NODE_2][WIT_V1][0], True) #block 425\n+        self.skip_mine(self.nodes[2], p2sh_ids[NODE_2][WIT_V0][0], True) #block 426\n+        self.skip_mine(self.nodes[2], p2sh_ids[NODE_2][WIT_V1][0], True) #block 427\n+\n+        # TODO: An old node would see these txs without witnesses and be able to mine them\n+\n+        print(\"Verify unsigned bare witness txs in versionbits-setting blocks are valid before the fork\")\n+        self.success_mine(self.nodes[2], wit_ids[NODE_2][WIT_V0][1], False) #block 428\n+        self.success_mine(self.nodes[2], wit_ids[NODE_2][WIT_V1][1], False) #block 429\n+\n+        print(\"Verify unsigned p2sh witness txs without a redeem script are invalid\")\n+        self.fail_accept(self.nodes[2], p2sh_ids[NODE_2][WIT_V0][1], False)\n+        self.fail_accept(self.nodes[2], p2sh_ids[NODE_2][WIT_V1][1], False)\n+\n+        print(\"Verify unsigned p2sh witness txs with a redeem script in versionbits-settings blocks are valid before the fork\")\n+        self.success_mine(self.nodes[2], p2sh_ids[NODE_2][WIT_V0][1], False, addlength(witness_script(0, self.pubkey[2]))) #block 430\n+        self.success_mine(self.nodes[2], p2sh_ids[NODE_2][WIT_V1][1], False, addlength(witness_script(1, self.pubkey[2]))) #block 431\n+\n+        print(\"Verify previous witness txs skipped for mining can now be mined\")\n+        assert_equal(len(self.nodes[2].getrawmempool()), 4)\n+        block = self.nodes[2].generate(1) #block 432 (first block with new rules; 432 = 144 * 3)\n+        sync_blocks(self.nodes)\n+        assert_equal(len(self.nodes[2].getrawmempool()), 0)\n+        assert_equal(len(self.nodes[2].getblock(block[0])[\"tx\"]), 5)\n+\n+        print(\"Verify witness txs without witness data are invalid after the fork\")\n+        self.fail_mine(self.nodes[2], wit_ids[NODE_2][WIT_V0][2], False)\n+        self.fail_mine(self.nodes[2], wit_ids[NODE_2][WIT_V1][2], False)\n+        self.fail_mine(self.nodes[2], p2sh_ids[NODE_2][WIT_V0][2], False, addlength(witness_script(0, self.pubkey[2])))\n+        self.fail_mine(self.nodes[2], p2sh_ids[NODE_2][WIT_V1][2], False, addlength(witness_script(1, self.pubkey[2])))\n+\n+        print(\"Verify default node can now use witness txs\")\n+        self.success_mine(self.nodes[0], wit_ids[NODE_0][WIT_V0][0], True) #block 432\n+        self.success_mine(self.nodes[0], wit_ids[NODE_0][WIT_V1][0], True) #block 433\n+        self.success_mine(self.nodes[0], p2sh_ids[NODE_0][WIT_V0][0], True) #block 434\n+        self.success_mine(self.nodes[0], p2sh_ids[NODE_0][WIT_V1][0], True) #block 435\n+\n+if __name__ == '__main__':\n+    SegWitTest().main()"
      },
      {
        "sha": "6cdd55e3979dfb528f6b67a9c8a5d865b36e63e4",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 5,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4f7ff00497803fddc5a0fb5340502a73e395134d/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4f7ff00497803fddc5a0fb5340502a73e395134d/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=4f7ff00497803fddc5a0fb5340502a73e395134d",
        "patch": "@@ -1145,8 +1145,8 @@ bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState& state, const C\n         return state.DoS(0, false, REJECT_NONSTANDARD, \"premature-version2-tx\");\n     }\n \n-    // Don't accept witness transactions before the final threshold passes\n-    if (!tx.wit.IsNull() && !IsWitnessEnabled(chainActive.Tip(), Params().GetConsensus())) {\n+    // Reject transactions with witness before segregated witness activates (override with -prematurewitness)\n+    if (!GetBoolArg(\"-prematurewitness\",false) && !tx.wit.IsNull() && !IsWitnessEnabled(chainActive.Tip(), Params().GetConsensus())) {\n         return state.DoS(0, false, REJECT_NONSTANDARD, \"no-witness-yet\", true);\n     }\n \n@@ -1487,14 +1487,19 @@ bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState& state, const C\n             }\n         }\n \n+        unsigned int scriptVerifyFlags = STANDARD_SCRIPT_VERIFY_FLAGS;\n+        if (!Params().RequireStandard()) {\n+            scriptVerifyFlags = GetArg(\"-promiscuousmempoolflags\", scriptVerifyFlags);\n+        }\n+\n         // Check against previous transactions\n         // This is done last to help prevent CPU exhaustion denial-of-service attacks.\n-        if (!CheckInputs(tx, state, view, true, STANDARD_SCRIPT_VERIFY_FLAGS, true)) {\n+        if (!CheckInputs(tx, state, view, true, scriptVerifyFlags, true)) {\n             // SCRIPT_VERIFY_CLEANSTACK requires SCRIPT_VERIFY_WITNESS, so we\n             // need to turn both off, and compare against just turning off CLEANSTACK\n             // to see if the failure is specifically due to witness validation.\n-            if (CheckInputs(tx, state, view, true, STANDARD_SCRIPT_VERIFY_FLAGS & ~(SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_CLEANSTACK), true) &&\n-                !CheckInputs(tx, state, view, true, STANDARD_SCRIPT_VERIFY_FLAGS & ~SCRIPT_VERIFY_CLEANSTACK, true)) {\n+            if (CheckInputs(tx, state, view, true, scriptVerifyFlags & ~(SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_CLEANSTACK), true) &&\n+                !CheckInputs(tx, state, view, true, scriptVerifyFlags & ~SCRIPT_VERIFY_CLEANSTACK, true)) {\n                 // Only the witness is wrong, so the transaction itself may be fine.\n                 state.SetCorruptionPossible();\n             }"
      },
      {
        "sha": "8538f880ff6363bb19fd27c3e29783d061415eca",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4f7ff00497803fddc5a0fb5340502a73e395134d/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4f7ff00497803fddc5a0fb5340502a73e395134d/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=4f7ff00497803fddc5a0fb5340502a73e395134d",
        "patch": "@@ -1072,7 +1072,7 @@ UniValue addwitnessaddress(const UniValue& params, bool fHelp)\n \n     {\n         LOCK(cs_main);\n-        if (!IsWitnessEnabled(chainActive.Tip(), Params().GetConsensus())) {\n+        if (!IsWitnessEnabled(chainActive.Tip(), Params().GetConsensus()) && !GetBoolArg(\"-walletprematurewitness\", false)) {\n             throw JSONRPCError(RPC_WALLET_ERROR, \"Segregated witness not enabled on network\");\n         }\n     }"
      }
    ]
  },
  {
    "sha": "330b0f31ee5719d94f9e52dfc83c5d82168241f9",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozMzBiMGYzMWVlNTcxOWQ5NGY5ZTUyZGZjODNjNWQ4MjE2ODI0MWY5",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2016-04-09T01:02:24Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-06-22T13:43:02Z"
      },
      "message": "[qa] p2p segwit tests\n\nmininode now supports witness transactions/blocks, blocktools\nhas a helper for adding witness commitments to blocks, and script\nhas a function to calculate hashes for signature under sigversion\n1, used by segwit.\n\nPy3 conversion by Marco Falke\n\nTest to make sure upgraded nodes don't ask for non-wit blocks by\nGregory Sanders.",
      "tree": {
        "sha": "df211a86536bc2692b0559083de6df2d54eaa72e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/df211a86536bc2692b0559083de6df2d54eaa72e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/330b0f31ee5719d94f9e52dfc83c5d82168241f9",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/330b0f31ee5719d94f9e52dfc83c5d82168241f9",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/330b0f31ee5719d94f9e52dfc83c5d82168241f9",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/330b0f31ee5719d94f9e52dfc83c5d82168241f9/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4f7ff00497803fddc5a0fb5340502a73e395134d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4f7ff00497803fddc5a0fb5340502a73e395134d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4f7ff00497803fddc5a0fb5340502a73e395134d"
      }
    ],
    "stats": {
      "total": 2067,
      "additions": 2037,
      "deletions": 30
    },
    "files": [
      {
        "sha": "37979a933fc29bdd0a39b2c4d36291c2543e2caf",
        "filename": "qa/pull-tester/rpc-tests.py",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/330b0f31ee5719d94f9e52dfc83c5d82168241f9/qa/pull-tester/rpc-tests.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/330b0f31ee5719d94f9e52dfc83c5d82168241f9/qa/pull-tester/rpc-tests.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/pull-tester/rpc-tests.py?ref=330b0f31ee5719d94f9e52dfc83c5d82168241f9",
        "patch": "@@ -136,6 +136,7 @@\n     'invalidtxrequest.py',\n     'abandonconflict.py',\n     'p2p-versionbits-warning.py',\n+    'p2p-segwit.py',\n     'segwit.py',\n     'importprunedfunds.py',\n     'signmessages.py',"
      },
      {
        "sha": "cf78954f286bcab6ca27c2697e1942bd0a0d2148",
        "filename": "qa/rpc-tests/p2p-segwit.py",
        "status": "added",
        "additions": 1646,
        "deletions": 0,
        "changes": 1646,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/330b0f31ee5719d94f9e52dfc83c5d82168241f9/qa/rpc-tests/p2p-segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/330b0f31ee5719d94f9e52dfc83c5d82168241f9/qa/rpc-tests/p2p-segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/p2p-segwit.py?ref=330b0f31ee5719d94f9e52dfc83c5d82168241f9",
        "patch": "@@ -0,0 +1,1646 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2016 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.mininode import *\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+from test_framework.script import *\n+from test_framework.blocktools import create_block, create_coinbase, add_witness_commitment, WITNESS_COMMITMENT_HEADER\n+from test_framework.key import CECKey, CPubKey\n+import time\n+import random\n+from binascii import hexlify\n+\n+# The versionbit bit used to signal activation of SegWit\n+VB_WITNESS_BIT = 1\n+VB_PERIOD = 144\n+VB_ACTIVATION_THRESHOLD = 108\n+VB_TOP_BITS = 0x20000000\n+\n+MAX_SIGOP_COST = 80000\n+\n+'''\n+SegWit p2p test.\n+'''\n+\n+# Calculate the virtual size of a witness block:\n+# (base + witness/4)\n+def get_virtual_size(witness_block):\n+    base_size = len(witness_block.serialize())\n+    total_size = len(witness_block.serialize(with_witness=True))\n+    # the \"+3\" is so we round up\n+    vsize = int((3*base_size + total_size + 3)/4)\n+    return vsize\n+\n+# Note: we can reduce code by using SingleNodeConnCB (in master, not 0.12)\n+class TestNode(NodeConnCB):\n+    def __init__(self):\n+        NodeConnCB.__init__(self)\n+        self.connection = None\n+        self.ping_counter = 1\n+        self.last_pong = msg_pong(0)\n+        self.sleep_time = 0.05\n+        self.getdataset = set()\n+\n+    def add_connection(self, conn):\n+        self.connection = conn\n+\n+    # Wrapper for the NodeConn's send_message function\n+    def send_message(self, message):\n+        self.connection.send_message(message)\n+\n+    def on_inv(self, conn, message):\n+        self.last_inv = message\n+\n+    def on_block(self, conn, message):\n+        self.last_block = message.block\n+        self.last_block.calc_sha256()\n+\n+    def on_getdata(self, conn, message):\n+        for inv in message.inv:\n+            self.getdataset.add(inv.hash)\n+        self.last_getdata = message\n+\n+    def on_pong(self, conn, message):\n+        self.last_pong = message\n+\n+    def on_reject(self, conn, message):\n+        self.last_reject = message\n+        #print message\n+\n+    # Syncing helpers\n+    def sync(self, test_function, timeout=60):\n+        while timeout > 0:\n+            with mininode_lock:\n+                if test_function():\n+                    return\n+            time.sleep(self.sleep_time)\n+            timeout -= self.sleep_time\n+        raise AssertionError(\"Sync failed to complete\")\n+        \n+    def sync_with_ping(self, timeout=60):\n+        self.send_message(msg_ping(nonce=self.ping_counter))\n+        test_function = lambda: self.last_pong.nonce == self.ping_counter\n+        self.sync(test_function, timeout)\n+        self.ping_counter += 1\n+        return\n+\n+    def wait_for_block(self, blockhash, timeout=60):\n+        test_function = lambda: self.last_block != None and self.last_block.sha256 == blockhash\n+        self.sync(test_function, timeout)\n+        return\n+\n+    def wait_for_getdata(self, timeout=60):\n+        test_function = lambda: self.last_getdata != None\n+        self.sync(test_function, timeout)\n+\n+    def wait_for_inv(self, expected_inv, timeout=60):\n+        test_function = lambda: self.last_inv != expected_inv\n+        self.sync(test_function, timeout)\n+\n+    def announce_tx_and_wait_for_getdata(self, tx, timeout=60):\n+        with mininode_lock:\n+            self.last_getdata = None\n+        self.send_message(msg_inv(inv=[CInv(1, tx.sha256)]))\n+        self.wait_for_getdata(timeout)\n+        return\n+\n+    def announce_block_and_wait_for_getdata(self, block, use_header, timeout=60):\n+        with mininode_lock:\n+            self.last_getdata = None\n+        if use_header:\n+            msg = msg_headers()\n+            msg.headers = [ CBlockHeader(block) ]\n+            self.send_message(msg)\n+        else:\n+            self.send_message(msg_inv(inv=[CInv(2, block.sha256)]))\n+        self.wait_for_getdata()\n+        return\n+\n+    def announce_block(self, block, use_header):\n+        with mininode_lock:\n+            self.last_getdata = None\n+        if use_header:\n+            msg = msg_headers()\n+            msg.headers = [ CBlockHeader(block) ]\n+            self.send_message(msg)\n+        else:\n+            self.send_message(msg_inv(inv=[CInv(2, block.sha256)]))\n+\n+    def request_block(self, blockhash, inv_type, timeout=60):\n+        with mininode_lock:\n+            self.last_block = None\n+        self.send_message(msg_getdata(inv=[CInv(inv_type, blockhash)]))\n+        self.wait_for_block(blockhash, timeout)\n+        return self.last_block\n+\n+    def test_transaction_acceptance(self, tx, with_witness, accepted):\n+        tx_message = msg_tx(tx)\n+        if with_witness:\n+            tx_message = msg_witness_tx(tx)\n+        self.send_message(tx_message)\n+        self.sync_with_ping()\n+        assert_equal(tx.hash in self.connection.rpc.getrawmempool(), accepted)\n+\n+    # Test whether a witness block had the correct effect on the tip\n+    def test_witness_block(self, block, accepted, with_witness=True):\n+        if with_witness:\n+            self.send_message(msg_witness_block(block))\n+        else:\n+            self.send_message(msg_block(block))\n+        self.sync_with_ping()\n+        assert_equal(self.connection.rpc.getbestblockhash() == block.hash, accepted)\n+\n+\n+# Used to keep track of anyone-can-spend outputs that we can use in the tests\n+class UTXO(object):\n+    def __init__(self, sha256, n, nValue):\n+        self.sha256 = sha256\n+        self.n = n\n+        self.nValue = nValue\n+\n+\n+class SegWitTest(BitcoinTestFramework):\n+    def setup_chain(self):\n+        initialize_chain_clean(self.options.tmpdir, 3)\n+\n+    def add_options(self, parser):\n+        parser.add_option(\"--oldbinary\", dest=\"oldbinary\",\n+                          default=None,\n+                          help=\"pre-segwit bitcoind binary for upgrade testing\")\n+\n+    def setup_network(self):\n+        self.nodes = []\n+        self.nodes.append(start_node(0, self.options.tmpdir, [\"-debug\", \"-logtimemicros=1\", \"-whitelist=127.0.0.1\"]))\n+        # Start a node for testing IsStandard rules.\n+        self.nodes.append(start_node(1, self.options.tmpdir, [\"-debug\", \"-logtimemicros=1\", \"-whitelist=127.0.0.1\", \"-acceptnonstdtxn=0\"]))\n+        connect_nodes(self.nodes[0], 1)\n+\n+        # If an old bitcoind is given, do the upgrade-after-activation test.\n+        self.test_upgrade = False\n+        if (self.options.oldbinary != None):\n+            self.nodes.append(start_node(2, self.options.tmpdir, [\"-debug\", \"-whitelist=127.0.0.1\"], binary=self.options.oldbinary))\n+            connect_nodes(self.nodes[0], 2)\n+            self.test_upgrade = True\n+\n+    ''' Helpers '''\n+    # Build a block on top of node0's tip.\n+    def build_next_block(self, nVersion=4):\n+        tip = self.nodes[0].getbestblockhash()\n+        height = self.nodes[0].getblockcount() + 1\n+        block_time = self.nodes[0].getblockheader(tip)[\"mediantime\"] + 1\n+        block = create_block(int(tip, 16), create_coinbase(height), block_time)\n+        block.nVersion = nVersion\n+        block.rehash()\n+        return block\n+\n+    # Adds list of transactions to block, adds witness commitment, then solves.\n+    def update_witness_block_with_transactions(self, block, tx_list, nonce=0):\n+        block.vtx.extend(tx_list)\n+        add_witness_commitment(block, nonce)\n+        block.solve()\n+        return\n+\n+    ''' Individual tests '''\n+    def test_witness_services(self):\n+        print(\"\\tVerifying NODE_WITNESS service bit\")\n+        assert((self.test_node.connection.nServices & NODE_WITNESS) != 0)\n+\n+\n+    # See if sending a regular transaction works, and create a utxo\n+    # to use in later tests.\n+    def test_non_witness_transaction(self):\n+        # Mine a block with an anyone-can-spend coinbase,\n+        # let it mature, then try to spend it.\n+        print(\"\\tTesting non-witness transaction\")\n+        block = self.build_next_block(nVersion=1)\n+        block.solve()\n+        self.test_node.send_message(msg_block(block))\n+        self.test_node.sync_with_ping() # make sure the block was processed\n+        txid = block.vtx[0].sha256\n+\n+        self.nodes[0].generate(99) # let the block mature\n+\n+        # Create a transaction that spends the coinbase\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(txid, 0), b\"\"))\n+        tx.vout.append(CTxOut(49*100000000, CScript([OP_TRUE])))\n+        tx.calc_sha256()\n+\n+        # Check that serializing it with or without witness is the same\n+        # This is a sanity check of our testing framework.\n+        assert_equal(msg_tx(tx).serialize(), msg_witness_tx(tx).serialize())\n+\n+        self.test_node.send_message(msg_witness_tx(tx))\n+        self.test_node.sync_with_ping() # make sure the tx was processed\n+        assert(tx.hash in self.nodes[0].getrawmempool())\n+        # Save this transaction for later\n+        self.utxo.append(UTXO(tx.sha256, 0, 49*100000000))\n+        self.nodes[0].generate(1)\n+\n+\n+    # Verify that blocks with witnesses are rejected before activation.\n+    def test_unnecessary_witness_before_segwit_activation(self):\n+        print(\"\\tTesting behavior of unnecessary witnesses\")\n+        # For now, rely on earlier tests to have created at least one utxo for\n+        # us to use\n+        assert(len(self.utxo) > 0)\n+        assert(get_bip9_status(self.nodes[0], 'segwit')['status'] != 'active')\n+\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n+        tx.vout.append(CTxOut(self.utxo[0].nValue-1000, CScript([OP_TRUE])))\n+        tx.wit.vtxinwit.append(CTxinWitness())\n+        tx.wit.vtxinwit[0].scriptWitness.stack = [CScript([CScriptNum(1)])]\n+\n+        # Verify the hash with witness differs from the txid\n+        # (otherwise our testing framework must be broken!)\n+        tx.rehash()\n+        assert(tx.sha256 != tx.calc_sha256(with_witness=True))\n+\n+        # Construct a segwit-signaling block that includes the transaction.\n+        block = self.build_next_block(nVersion=(VB_TOP_BITS|(1 << VB_WITNESS_BIT)))\n+        self.update_witness_block_with_transactions(block, [tx])\n+        # Sending witness data before activation is not allowed (anti-spam\n+        # rule).\n+        self.test_node.test_witness_block(block, accepted=False)\n+        # TODO: fix synchronization so we can test reject reason\n+        # Right now, bitcoind delays sending reject messages for blocks\n+        # until the future, making synchronization here difficult.\n+        #assert_equal(self.test_node.last_reject.reason, \"unexpected-witness\")\n+\n+        # But it should not be permanently marked bad...\n+        # Resend without witness information.\n+        self.test_node.send_message(msg_block(block))\n+        self.test_node.sync_with_ping()\n+        assert_equal(self.nodes[0].getbestblockhash(), block.hash)\n+\n+        # Update our utxo list; we spent the first entry.\n+        self.utxo.pop(0)\n+        self.utxo.append(UTXO(tx.sha256, 0, tx.vout[0].nValue))\n+\n+\n+    # Mine enough blocks for segwit's vb state to be 'started'.\n+    def advance_to_segwit_started(self):\n+        height = self.nodes[0].getblockcount()\n+        # Will need to rewrite the tests here if we are past the first period\n+        assert(height < VB_PERIOD - 1)\n+        # Genesis block is 'defined'.\n+        assert_equal(get_bip9_status(self.nodes[0], 'segwit')['status'], 'defined')\n+        # Advance to end of period, status should now be 'started'\n+        self.nodes[0].generate(VB_PERIOD-height-1)\n+        assert_equal(get_bip9_status(self.nodes[0], 'segwit')['status'], 'started')\n+\n+    # Mine enough blocks to lock in segwit, but don't activate.\n+    # TODO: we could verify that lockin only happens at the right threshold of\n+    # signalling blocks, rather than just at the right period boundary.\n+    def advance_to_segwit_lockin(self):\n+        height = self.nodes[0].getblockcount()\n+        assert_equal(get_bip9_status(self.nodes[0], 'segwit')['status'], 'started')\n+        # Advance to end of period, and verify lock-in happens at the end\n+        self.nodes[0].generate(VB_PERIOD-1)\n+        height = self.nodes[0].getblockcount()\n+        assert((height % VB_PERIOD) == VB_PERIOD - 2)\n+        assert_equal(get_bip9_status(self.nodes[0], 'segwit')['status'], 'started')\n+        self.nodes[0].generate(1)\n+        assert_equal(get_bip9_status(self.nodes[0], 'segwit')['status'], 'locked_in')\n+\n+\n+    # Mine enough blocks to activate segwit.\n+    # TODO: we could verify that activation only happens at the right threshold\n+    # of signalling blocks, rather than just at the right period boundary.\n+    def advance_to_segwit_active(self):\n+        assert_equal(get_bip9_status(self.nodes[0], 'segwit')['status'], 'locked_in')\n+        height = self.nodes[0].getblockcount()\n+        self.nodes[0].generate(VB_PERIOD - (height%VB_PERIOD) - 2)\n+        assert_equal(get_bip9_status(self.nodes[0], 'segwit')['status'], 'locked_in')\n+        self.nodes[0].generate(1)\n+        assert_equal(get_bip9_status(self.nodes[0], 'segwit')['status'], 'active')\n+\n+\n+    # This test can only be run after segwit has activated\n+    def test_witness_commitments(self):\n+        print(\"\\tTesting witness commitments\")\n+\n+        # First try a correct witness commitment.\n+        block = self.build_next_block()\n+        add_witness_commitment(block)\n+        block.solve()\n+\n+        # Test the test -- witness serialization should be different\n+        assert(msg_witness_block(block).serialize() != msg_block(block).serialize())\n+\n+        # This empty block should be valid.\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+        # Try to tweak the nonce\n+        block_2 = self.build_next_block()\n+        add_witness_commitment(block_2, nonce=28)\n+        block_2.solve()\n+\n+        # The commitment should have changed!\n+        assert(block_2.vtx[0].vout[-1] != block.vtx[0].vout[-1])\n+\n+        # This should also be valid.\n+        self.test_node.test_witness_block(block_2, accepted=True)\n+\n+        # Now test commitments with actual transactions\n+        assert (len(self.utxo) > 0)\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n+\n+        # Let's construct a witness program\n+        witness_program = CScript([OP_TRUE])\n+        witness_hash = sha256(witness_program)\n+        scriptPubKey = CScript([OP_0, witness_hash])\n+        tx.vout.append(CTxOut(self.utxo[0].nValue-1000, scriptPubKey))\n+        tx.rehash()\n+\n+        # tx2 will spend tx1, and send back to a regular anyone-can-spend address\n+        tx2 = CTransaction()\n+        tx2.vin.append(CTxIn(COutPoint(tx.sha256, 0), b\"\"))\n+        tx2.vout.append(CTxOut(tx.vout[0].nValue-1000, witness_program))\n+        tx2.wit.vtxinwit.append(CTxinWitness())\n+        tx2.wit.vtxinwit[0].scriptWitness.stack = [witness_program]\n+        tx2.rehash()\n+\n+        block_3 = self.build_next_block()\n+        self.update_witness_block_with_transactions(block_3, [tx, tx2], nonce=1)\n+        # Add an extra OP_RETURN output that matches the witness commitment template,\n+        # even though it has extra data after the incorrect commitment.\n+        # This block should fail.\n+        block_3.vtx[0].vout.append(CTxOut(0, CScript([OP_RETURN, WITNESS_COMMITMENT_HEADER + ser_uint256(2), 10])))\n+        block_3.vtx[0].rehash()\n+        block_3.hashMerkleRoot = block_3.calc_merkle_root()\n+        block_3.rehash()\n+        block_3.solve()\n+\n+        self.test_node.test_witness_block(block_3, accepted=False)\n+\n+        # Add a different commitment with different nonce, but in the\n+        # right location, and with some funds burned(!).\n+        # This should succeed (nValue shouldn't affect finding the\n+        # witness commitment).\n+        add_witness_commitment(block_3, nonce=0)\n+        block_3.vtx[0].vout[0].nValue -= 1\n+        block_3.vtx[0].vout[-1].nValue += 1\n+        block_3.vtx[0].rehash()\n+        block_3.hashMerkleRoot = block_3.calc_merkle_root()\n+        block_3.rehash()\n+        assert(len(block_3.vtx[0].vout) == 4) # 3 OP_returns\n+        block_3.solve()\n+        self.test_node.test_witness_block(block_3, accepted=True)\n+\n+        # Finally test that a block with no witness transactions can\n+        # omit the commitment.\n+        block_4 = self.build_next_block()\n+        tx3 = CTransaction()\n+        tx3.vin.append(CTxIn(COutPoint(tx2.sha256, 0), b\"\"))\n+        tx3.vout.append(CTxOut(tx.vout[0].nValue-1000, witness_program))\n+        tx3.rehash()\n+        block_4.vtx.append(tx3)\n+        block_4.hashMerkleRoot = block_4.calc_merkle_root()\n+        block_4.solve()\n+        self.test_node.test_witness_block(block_4, with_witness=False, accepted=True)\n+\n+        # Update available utxo's for use in later test.\n+        self.utxo.pop(0)\n+        self.utxo.append(UTXO(tx3.sha256, 0, tx3.vout[0].nValue))\n+\n+\n+    def test_block_malleability(self):\n+        print(\"\\tTesting witness block malleability\")\n+\n+        # Make sure that a block that has too big a virtual size\n+        # because of a too-large coinbase witness is not permanently\n+        # marked bad.\n+        block = self.build_next_block()\n+        add_witness_commitment(block)\n+        block.solve()\n+\n+        block.vtx[0].wit.vtxinwit[0].scriptWitness.stack.append(b'a'*5000000)\n+        assert(get_virtual_size(block) > MAX_BLOCK_SIZE)\n+\n+        # We can't send over the p2p network, because this is too big to relay\n+        # TODO: repeat this test with a block that can be relayed\n+        self.nodes[0].submitblock(bytes_to_hex_str(block.serialize(True)))\n+\n+        assert(self.nodes[0].getbestblockhash() != block.hash)\n+\n+        block.vtx[0].wit.vtxinwit[0].scriptWitness.stack.pop()\n+        assert(get_virtual_size(block) < MAX_BLOCK_SIZE)\n+        self.nodes[0].submitblock(bytes_to_hex_str(block.serialize(True)))\n+\n+        assert(self.nodes[0].getbestblockhash() == block.hash)\n+\n+        # Now make sure that malleating the witness nonce doesn't\n+        # result in a block permanently marked bad.\n+        block = self.build_next_block()\n+        add_witness_commitment(block)\n+        block.solve()\n+\n+        # Change the nonce -- should not cause the block to be permanently\n+        # failed\n+        block.vtx[0].wit.vtxinwit[0].scriptWitness.stack = [ ser_uint256(1) ]\n+        self.test_node.test_witness_block(block, accepted=False)\n+\n+        # Changing the witness nonce doesn't change the block hash\n+        block.vtx[0].wit.vtxinwit[0].scriptWitness.stack = [ ser_uint256(0) ]\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+\n+    def test_witness_block_size(self):\n+        print(\"\\tTesting witness block size limit\")\n+        # TODO: Test that non-witness carrying blocks can't exceed 1MB\n+        # Skipping this test for now; this is covered in p2p-fullblocktest.py\n+\n+        # Test that witness-bearing blocks are limited at ceil(base + wit/4) <= 1MB.\n+        block = self.build_next_block()\n+\n+        assert(len(self.utxo) > 0)\n+        \n+        # Create a P2WSH transaction.\n+        # The witness program will be a bunch of OP_2DROP's, followed by OP_TRUE.\n+        # This should give us plenty of room to tweak the spending tx's\n+        # virtual size.\n+        NUM_DROPS = 200 # 201 max ops per script!\n+        NUM_OUTPUTS = 50\n+\n+        witness_program = CScript([OP_2DROP]*NUM_DROPS + [OP_TRUE])\n+        witness_hash = uint256_from_str(sha256(witness_program))\n+        scriptPubKey = CScript([OP_0, ser_uint256(witness_hash)])\n+\n+        prevout = COutPoint(self.utxo[0].sha256, self.utxo[0].n)\n+        value = self.utxo[0].nValue\n+\n+        parent_tx = CTransaction()\n+        parent_tx.vin.append(CTxIn(prevout, b\"\"))\n+        child_value = int(value/NUM_OUTPUTS)\n+        for i in range(NUM_OUTPUTS):\n+            parent_tx.vout.append(CTxOut(child_value, scriptPubKey))\n+        parent_tx.vout[0].nValue -= 50000\n+        assert(parent_tx.vout[0].nValue > 0)\n+        parent_tx.rehash()\n+\n+        child_tx = CTransaction()\n+        for i in range(NUM_OUTPUTS):\n+            child_tx.vin.append(CTxIn(COutPoint(parent_tx.sha256, i), b\"\"))\n+        child_tx.vout = [CTxOut(value - 100000, CScript([OP_TRUE]))]\n+        for i in range(NUM_OUTPUTS):\n+            child_tx.wit.vtxinwit.append(CTxinWitness())\n+            child_tx.wit.vtxinwit[-1].scriptWitness.stack = [b'a'*195]*(2*NUM_DROPS) + [witness_program]\n+        child_tx.rehash()\n+        self.update_witness_block_with_transactions(block, [parent_tx, child_tx])\n+\n+        vsize = get_virtual_size(block)\n+        additional_bytes = (MAX_BLOCK_SIZE - vsize)*4\n+        i = 0\n+        while additional_bytes > 0:\n+            # Add some more bytes to each input until we hit MAX_BLOCK_SIZE+1\n+            extra_bytes = min(additional_bytes+1, 55)\n+            block.vtx[-1].wit.vtxinwit[int(i/(2*NUM_DROPS))].scriptWitness.stack[i%(2*NUM_DROPS)] = b'a'*(195+extra_bytes)\n+            additional_bytes -= extra_bytes\n+            i += 1\n+\n+        block.vtx[0].vout.pop()  # Remove old commitment\n+        add_witness_commitment(block)\n+        block.solve()\n+        vsize = get_virtual_size(block)\n+        assert_equal(vsize, MAX_BLOCK_SIZE + 1)\n+        # Make sure that our test case would exceed the old max-network-message\n+        # limit\n+        assert(len(block.serialize(True)) > 2*1024*1024)\n+\n+        self.test_node.test_witness_block(block, accepted=False)\n+\n+        # Now resize the second transaction to make the block fit.\n+        cur_length = len(block.vtx[-1].wit.vtxinwit[0].scriptWitness.stack[0])\n+        block.vtx[-1].wit.vtxinwit[0].scriptWitness.stack[0] = b'a'*(cur_length-1)\n+        block.vtx[0].vout.pop()\n+        add_witness_commitment(block)\n+        block.solve()\n+        assert(get_virtual_size(block) == MAX_BLOCK_SIZE)\n+\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+        # Update available utxo's\n+        self.utxo.pop(0)\n+        self.utxo.append(UTXO(block.vtx[-1].sha256, 0, block.vtx[-1].vout[0].nValue))\n+\n+\n+    # submitblock will try to add the nonce automatically, so that mining\n+    # software doesn't need to worry about doing so itself.\n+    def test_submit_block(self):\n+        block = self.build_next_block()\n+\n+        # Try using a custom nonce and then don't supply it.\n+        # This shouldn't possibly work.\n+        add_witness_commitment(block, nonce=1)\n+        block.vtx[0].wit = CTxWitness() # drop the nonce\n+        block.solve()\n+        self.nodes[0].submitblock(bytes_to_hex_str(block.serialize(True)))\n+        assert(self.nodes[0].getbestblockhash() != block.hash)\n+\n+        # Now redo commitment with the standard nonce, but let bitcoind fill it in.\n+        add_witness_commitment(block, nonce=0)\n+        block.vtx[0].wit = CTxWitness()\n+        block.solve()\n+        self.nodes[0].submitblock(bytes_to_hex_str(block.serialize(True)))\n+        assert_equal(self.nodes[0].getbestblockhash(), block.hash)\n+\n+        # This time, add a tx with non-empty witness, but don't supply\n+        # the commitment.\n+        block_2 = self.build_next_block()\n+\n+        add_witness_commitment(block_2)\n+\n+        block_2.solve()\n+\n+        # Drop commitment and nonce -- submitblock should not fill in.\n+        block_2.vtx[0].vout.pop()\n+        block_2.vtx[0].wit = CTxWitness()\n+\n+        self.nodes[0].submitblock(bytes_to_hex_str(block_2.serialize(True)))\n+        # Tip should not advance!\n+        assert(self.nodes[0].getbestblockhash() != block_2.hash)\n+\n+\n+    # Consensus tests of extra witness data in a transaction.\n+    def test_extra_witness_data(self):\n+        print(\"\\tTesting extra witness data in tx\")\n+\n+        assert(len(self.utxo) > 0)\n+        \n+        block = self.build_next_block()\n+\n+        witness_program = CScript([OP_DROP, OP_TRUE])\n+        witness_hash = sha256(witness_program)\n+        scriptPubKey = CScript([OP_0, witness_hash])\n+\n+        # First try extra witness data on a tx that doesn't require a witness\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n+        tx.vout.append(CTxOut(self.utxo[0].nValue-2000, scriptPubKey))\n+        tx.vout.append(CTxOut(1000, CScript([OP_TRUE]))) # non-witness output\n+        tx.wit.vtxinwit.append(CTxinWitness())\n+        tx.wit.vtxinwit[0].scriptWitness.stack = [CScript([])]\n+        tx.rehash()\n+        self.update_witness_block_with_transactions(block, [tx])\n+\n+        # Extra witness data should not be allowed.\n+        self.test_node.test_witness_block(block, accepted=False)\n+\n+        # Try extra signature data.  Ok if we're not spending a witness output.\n+        block.vtx[1].wit.vtxinwit = []\n+        block.vtx[1].vin[0].scriptSig = CScript([OP_0])\n+        block.vtx[1].rehash()\n+        add_witness_commitment(block)\n+        block.solve()\n+\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+        # Now try extra witness/signature data on an input that DOES require a\n+        # witness\n+        tx2 = CTransaction()\n+        tx2.vin.append(CTxIn(COutPoint(tx.sha256, 0), b\"\")) # witness output\n+        tx2.vin.append(CTxIn(COutPoint(tx.sha256, 1), b\"\")) # non-witness\n+        tx2.vout.append(CTxOut(tx.vout[0].nValue, CScript([OP_TRUE])))\n+        tx2.wit.vtxinwit.extend([CTxinWitness(), CTxinWitness()])\n+        tx2.wit.vtxinwit[0].scriptWitness.stack = [ CScript([CScriptNum(1)]), CScript([CScriptNum(1)]), witness_program ]\n+        tx2.wit.vtxinwit[1].scriptWitness.stack = [ CScript([OP_TRUE]) ]\n+\n+        block = self.build_next_block()\n+        self.update_witness_block_with_transactions(block, [tx2])\n+\n+        # This has extra witness data, so it should fail.\n+        self.test_node.test_witness_block(block, accepted=False)\n+\n+        # Now get rid of the extra witness, but add extra scriptSig data\n+        tx2.vin[0].scriptSig = CScript([OP_TRUE])\n+        tx2.vin[1].scriptSig = CScript([OP_TRUE])\n+        tx2.wit.vtxinwit[0].scriptWitness.stack.pop(0)\n+        tx2.wit.vtxinwit[1].scriptWitness.stack = []\n+        tx2.rehash()\n+        add_witness_commitment(block)\n+        block.solve()\n+\n+        # This has extra signature data for a witness input, so it should fail.\n+        self.test_node.test_witness_block(block, accepted=False)\n+\n+        # Now get rid of the extra scriptsig on the witness input, and verify\n+        # success (even with extra scriptsig data in the non-witness input)\n+        tx2.vin[0].scriptSig = b\"\"\n+        tx2.rehash()\n+        add_witness_commitment(block)\n+        block.solve()\n+\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+        # Update utxo for later tests\n+        self.utxo.pop(0)\n+        self.utxo.append(UTXO(tx2.sha256, 0, tx2.vout[0].nValue))\n+\n+\n+    def test_max_witness_push_length(self):\n+        ''' Should only allow up to 520 byte pushes in witness stack '''\n+        print(\"\\tTesting maximum witness push size\")\n+        MAX_SCRIPT_ELEMENT_SIZE = 520\n+        assert(len(self.utxo))\n+\n+        block = self.build_next_block()\n+\n+        witness_program = CScript([OP_DROP, OP_TRUE])\n+        witness_hash = sha256(witness_program)\n+        scriptPubKey = CScript([OP_0, witness_hash])\n+\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n+        tx.vout.append(CTxOut(self.utxo[0].nValue-1000, scriptPubKey))\n+        tx.rehash()\n+\n+        tx2 = CTransaction()\n+        tx2.vin.append(CTxIn(COutPoint(tx.sha256, 0), b\"\"))\n+        tx2.vout.append(CTxOut(tx.vout[0].nValue-1000, CScript([OP_TRUE])))\n+        tx2.wit.vtxinwit.append(CTxinWitness())\n+        # First try a 521-byte stack element\n+        tx2.wit.vtxinwit[0].scriptWitness.stack = [ b'a'*(MAX_SCRIPT_ELEMENT_SIZE+1), witness_program ]\n+        tx2.rehash()\n+\n+        self.update_witness_block_with_transactions(block, [tx, tx2])\n+        self.test_node.test_witness_block(block, accepted=False)\n+\n+        # Now reduce the length of the stack element\n+        tx2.wit.vtxinwit[0].scriptWitness.stack[0] = b'a'*(MAX_SCRIPT_ELEMENT_SIZE)\n+\n+        add_witness_commitment(block)\n+        block.solve()\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+        # Update the utxo for later tests\n+        self.utxo.pop()\n+        self.utxo.append(UTXO(tx2.sha256, 0, tx2.vout[0].nValue))\n+\n+    def test_max_witness_program_length(self):\n+        # Can create witness outputs that are long, but can't be greater than\n+        # 10k bytes to successfully spend\n+        print(\"\\tTesting maximum witness program length\")\n+        assert(len(self.utxo))\n+        MAX_PROGRAM_LENGTH = 10000\n+\n+        # This program is 19 max pushes (9937 bytes), then 64 more opcode-bytes.\n+        long_witness_program = CScript([b'a'*520]*19 + [OP_DROP]*63 + [OP_TRUE])\n+        assert(len(long_witness_program) == MAX_PROGRAM_LENGTH+1)\n+        long_witness_hash = sha256(long_witness_program)\n+        long_scriptPubKey = CScript([OP_0, long_witness_hash])\n+\n+        block = self.build_next_block()\n+\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n+        tx.vout.append(CTxOut(self.utxo[0].nValue-1000, long_scriptPubKey))\n+        tx.rehash()\n+\n+        tx2 = CTransaction()\n+        tx2.vin.append(CTxIn(COutPoint(tx.sha256, 0), b\"\"))\n+        tx2.vout.append(CTxOut(tx.vout[0].nValue-1000, CScript([OP_TRUE])))\n+        tx2.wit.vtxinwit.append(CTxinWitness())\n+        tx2.wit.vtxinwit[0].scriptWitness.stack = [b'a']*44 + [long_witness_program]\n+        tx2.rehash()\n+\n+        self.update_witness_block_with_transactions(block, [tx, tx2])\n+\n+        self.test_node.test_witness_block(block, accepted=False)\n+\n+        # Try again with one less byte in the witness program\n+        witness_program = CScript([b'a'*520]*19 + [OP_DROP]*62 + [OP_TRUE])\n+        assert(len(witness_program) == MAX_PROGRAM_LENGTH)\n+        witness_hash = sha256(witness_program)\n+        scriptPubKey = CScript([OP_0, witness_hash])\n+\n+        tx.vout[0] = CTxOut(tx.vout[0].nValue, scriptPubKey)\n+        tx.rehash()\n+        tx2.vin[0].prevout.hash = tx.sha256\n+        tx2.wit.vtxinwit[0].scriptWitness.stack = [b'a']*43 + [witness_program]\n+        tx2.rehash()\n+        block.vtx = [block.vtx[0]]\n+        self.update_witness_block_with_transactions(block, [tx, tx2])\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+        self.utxo.pop()\n+        self.utxo.append(UTXO(tx2.sha256, 0, tx2.vout[0].nValue))\n+\n+\n+    def test_witness_input_length(self):\n+        ''' Ensure that vin length must match vtxinwit length '''\n+        print(\"\\tTesting witness input length\")\n+        assert(len(self.utxo))\n+\n+        witness_program = CScript([OP_DROP, OP_TRUE])\n+        witness_hash = sha256(witness_program)\n+        scriptPubKey = CScript([OP_0, witness_hash])\n+        \n+        # Create a transaction that splits our utxo into many outputs\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n+        nValue = self.utxo[0].nValue\n+        for i in range(10):\n+            tx.vout.append(CTxOut(int(nValue/10), scriptPubKey))\n+        tx.vout[0].nValue -= 1000\n+        assert(tx.vout[0].nValue >= 0)\n+\n+        block = self.build_next_block()\n+        self.update_witness_block_with_transactions(block, [tx])\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+        # Try various ways to spend tx that should all break.\n+        # This \"broken\" transaction serializer will not normalize\n+        # the length of vtxinwit.\n+        class BrokenCTransaction(CTransaction):\n+            def serialize_with_witness(self):\n+                flags = 0\n+                if not self.wit.is_null():\n+                    flags |= 1\n+                r = b\"\"\n+                r += struct.pack(\"<i\", self.nVersion)\n+                if flags:\n+                    dummy = []\n+                    r += ser_vector(dummy)\n+                    r += struct.pack(\"<B\", flags)\n+                r += ser_vector(self.vin)\n+                r += ser_vector(self.vout)\n+                if flags & 1:\n+                    r += self.wit.serialize()\n+                r += struct.pack(\"<I\", self.nLockTime)\n+                return r\n+\n+        tx2 = BrokenCTransaction()\n+        for i in range(10):\n+            tx2.vin.append(CTxIn(COutPoint(tx.sha256, i), b\"\"))\n+        tx2.vout.append(CTxOut(nValue-3000, CScript([OP_TRUE])))\n+\n+        # First try using a too long vtxinwit\n+        for i in range(11):\n+            tx2.wit.vtxinwit.append(CTxinWitness())\n+            tx2.wit.vtxinwit[i].scriptWitness.stack = [b'a', witness_program]\n+\n+        block = self.build_next_block()\n+        self.update_witness_block_with_transactions(block, [tx2])\n+        self.test_node.test_witness_block(block, accepted=False)\n+\n+        # Now try using a too short vtxinwit\n+        tx2.wit.vtxinwit.pop()\n+        tx2.wit.vtxinwit.pop()\n+\n+        block.vtx = [block.vtx[0]]\n+        self.update_witness_block_with_transactions(block, [tx2])\n+        self.test_node.test_witness_block(block, accepted=False)\n+\n+        # Now make one of the intermediate witnesses be incorrect\n+        tx2.wit.vtxinwit.append(CTxinWitness())\n+        tx2.wit.vtxinwit[-1].scriptWitness.stack = [b'a', witness_program]\n+        tx2.wit.vtxinwit[5].scriptWitness.stack = [ witness_program ]\n+\n+        block.vtx = [block.vtx[0]]\n+        self.update_witness_block_with_transactions(block, [tx2])\n+        self.test_node.test_witness_block(block, accepted=False)\n+\n+        # Fix the broken witness and the block should be accepted.\n+        tx2.wit.vtxinwit[5].scriptWitness.stack = [b'a', witness_program]\n+        block.vtx = [block.vtx[0]]\n+        self.update_witness_block_with_transactions(block, [tx2])\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+        self.utxo.pop()\n+        self.utxo.append(UTXO(tx2.sha256, 0, tx2.vout[0].nValue))\n+\n+\n+    def test_witness_tx_relay_before_segwit_activation(self):\n+        print(\"\\tTesting relay of witness transactions\")\n+        # Generate a transaction that doesn't require a witness, but send it\n+        # with a witness.  Should be rejected for premature-witness, but should\n+        # not be added to recently rejected list.\n+        assert(len(self.utxo))\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n+        tx.vout.append(CTxOut(self.utxo[0].nValue-1000, CScript([OP_TRUE])))\n+        tx.wit.vtxinwit.append(CTxinWitness())\n+        tx.wit.vtxinwit[0].scriptWitness.stack = [ b'a' ]\n+        tx.rehash()\n+\n+        tx_hash = tx.sha256\n+        tx_value = tx.vout[0].nValue\n+\n+        # Verify that if a peer doesn't set nServices to include NODE_WITNESS,\n+        # the getdata is just for the non-witness portion.\n+        self.old_node.announce_tx_and_wait_for_getdata(tx)\n+        assert(self.old_node.last_getdata.inv[0].type == 1)\n+\n+        # Since we haven't delivered the tx yet, inv'ing the same tx from\n+        # a witness transaction ought not result in a getdata.\n+        try:\n+            self.test_node.announce_tx_and_wait_for_getdata(tx, timeout=2)\n+            print(\"Error: duplicate tx getdata!\")\n+            assert(False)\n+        except AssertionError as e:\n+            pass\n+\n+        # Delivering this transaction with witness should fail (no matter who\n+        # its from)\n+        assert_equal(len(self.nodes[0].getrawmempool()), 0)\n+        assert_equal(len(self.nodes[1].getrawmempool()), 0)\n+        self.old_node.test_transaction_acceptance(tx, with_witness=True, accepted=False)\n+        self.test_node.test_transaction_acceptance(tx, with_witness=True, accepted=False)\n+\n+        # But eliminating the witness should fix it\n+        self.test_node.test_transaction_acceptance(tx, with_witness=False, accepted=True)\n+\n+        # Verify that inv's to test_node come with getdata's for non-witness tx's\n+        # Just tweak the transaction, announce it, and verify we get a getdata\n+        # for a normal tx\n+        tx.vout[0].scriptPubKey = CScript([OP_TRUE, OP_TRUE])\n+        tx.rehash()\n+        self.test_node.announce_tx_and_wait_for_getdata(tx)\n+        assert(self.test_node.last_getdata.inv[0].type == 1)\n+\n+        # Cleanup: mine the first transaction and update utxo\n+        self.nodes[0].generate(1)\n+        assert_equal(len(self.nodes[0].getrawmempool()),  0)\n+\n+        self.utxo.pop(0)\n+        self.utxo.append(UTXO(tx_hash, 0, tx_value))\n+\n+\n+    # After segwit activates, verify that mempool:\n+    # - rejects transactions with unnecessary/extra witnesses\n+    # - accepts transactions with valid witnesses\n+    # and that witness transactions are relayed to non-upgraded peers.\n+    def test_tx_relay_after_segwit_activation(self):\n+        print(\"\\tTesting relay of witness transactions\")\n+        # Generate a transaction that doesn't require a witness, but send it\n+        # with a witness.  Should be rejected because we can't use a witness\n+        # when spending a non-witness output.\n+        assert(len(self.utxo))\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n+        tx.vout.append(CTxOut(self.utxo[0].nValue-1000, CScript([OP_TRUE])))\n+        tx.wit.vtxinwit.append(CTxinWitness())\n+        tx.wit.vtxinwit[0].scriptWitness.stack = [ b'a' ]\n+        tx.rehash()\n+\n+        tx_hash = tx.sha256\n+        tx_value = tx.vout[0].nValue\n+\n+        # Verify that unnecessary witnesses are rejected.\n+        self.test_node.announce_tx_and_wait_for_getdata(tx)\n+        assert_equal(len(self.nodes[0].getrawmempool()), 0)\n+        self.test_node.test_transaction_acceptance(tx, with_witness=True, accepted=False)\n+\n+        # Verify that removing the witness succeeds.\n+        # Re-announcing won't result in a getdata for ~2.5 minutes, so just\n+        # deliver the modified transaction.\n+        self.test_node.test_transaction_acceptance(tx, with_witness=False, accepted=True)\n+\n+        # Now try to add extra witness data to a valid witness tx.\n+        witness_program = CScript([OP_TRUE])\n+        witness_hash = sha256(witness_program)\n+        scriptPubKey = CScript([OP_0, witness_hash])\n+        tx2 = CTransaction()\n+        tx2.vin.append(CTxIn(COutPoint(tx_hash, 0), b\"\"))\n+        tx2.vout.append(CTxOut(tx.vout[0].nValue-1000, scriptPubKey))\n+        tx2.rehash()\n+\n+        tx3 = CTransaction()\n+        tx3.vin.append(CTxIn(COutPoint(tx2.sha256, 0), b\"\"))\n+        tx3.vout.append(CTxOut(tx2.vout[0].nValue-1000, CScript([OP_TRUE])))\n+        tx3.wit.vtxinwit.append(CTxinWitness())\n+        tx3.wit.vtxinwit[0].scriptWitness.stack = [CScript([CScriptNum(1)]), witness_program ]\n+        tx3.rehash()\n+\n+        self.test_node.test_transaction_acceptance(tx2, with_witness=True, accepted=True)\n+        self.test_node.test_transaction_acceptance(tx3, with_witness=True, accepted=False)\n+\n+        # Get rid of the extra witness, and verify acceptance.\n+        tx3.wit.vtxinwit[0].scriptWitness.stack = [ witness_program ]\n+        # Also check that old_node gets a tx announcement, even though this is\n+        # a witness transaction.\n+        self.old_node.wait_for_inv(CInv(1, tx2.sha256)) # wait until tx2 was inv'ed\n+        self.test_node.test_transaction_acceptance(tx3, with_witness=True, accepted=True)\n+        self.old_node.wait_for_inv(CInv(1, tx3.sha256))\n+\n+        # Test that getrawtransaction returns correct witness information\n+        # hash, size, vsize\n+        raw_tx = self.nodes[0].getrawtransaction(tx3.hash, 1)\n+        assert_equal(int(raw_tx[\"hash\"], 16), tx3.calc_sha256(True))\n+        assert_equal(raw_tx[\"size\"], len(tx3.serialize_with_witness()))\n+        vsize = (len(tx3.serialize_with_witness()) + 3*len(tx3.serialize_without_witness()) + 3) / 4\n+        assert_equal(raw_tx[\"vsize\"], vsize)\n+        assert_equal(len(raw_tx[\"vin\"][0][\"txinwitness\"]), 1)\n+        assert_equal(raw_tx[\"vin\"][0][\"txinwitness\"][0], hexlify(witness_program).decode('ascii'))\n+        assert(vsize != raw_tx[\"size\"])\n+\n+        # Cleanup: mine the transactions and update utxo for next test\n+        self.nodes[0].generate(1)\n+        assert_equal(len(self.nodes[0].getrawmempool()),  0)\n+\n+        self.utxo.pop(0)\n+        self.utxo.append(UTXO(tx3.sha256, 0, tx3.vout[0].nValue))\n+\n+\n+    # Test that block requests to NODE_WITNESS peer are with MSG_WITNESS_FLAG\n+    # This is true regardless of segwit activation.\n+    # Also test that we don't ask for blocks from unupgraded peers\n+    def test_block_relay(self, segwit_activated):\n+        print(\"\\tTesting block relay\")\n+\n+        blocktype = 2|MSG_WITNESS_FLAG if segwit_activated else 2\n+\n+        # test_node has set NODE_WITNESS, so all getdata requests should be for\n+        # witness blocks.\n+        # Test announcing a block via inv results in a getdata, and that\n+        # announcing a version 4 or random VB block with a header results in a getdata\n+        block1 = self.build_next_block()\n+        block1.solve()\n+\n+        self.test_node.announce_block_and_wait_for_getdata(block1, use_header=False)\n+        assert(self.test_node.last_getdata.inv[0].type == blocktype)\n+        self.test_node.test_witness_block(block1, True)\n+\n+        block2 = self.build_next_block(nVersion=4)\n+        block2.solve()\n+\n+        self.test_node.announce_block_and_wait_for_getdata(block2, use_header=True)\n+        assert(self.test_node.last_getdata.inv[0].type == blocktype)\n+        self.test_node.test_witness_block(block2, True)\n+\n+        block3 = self.build_next_block(nVersion=(VB_TOP_BITS | (1<<15)))\n+        block3.solve()\n+        self.test_node.announce_block_and_wait_for_getdata(block3, use_header=True)\n+        assert(self.test_node.last_getdata.inv[0].type == blocktype)\n+        self.test_node.test_witness_block(block3, True)\n+\n+        # Check that we can getdata for witness blocks or regular blocks,\n+        # and the right thing happens.\n+        if segwit_activated == False:\n+            # Before activation, we should be able to request old blocks with\n+            # or without witness, and they should be the same.\n+            chain_height = self.nodes[0].getblockcount()\n+            # Pick 10 random blocks on main chain, and verify that getdata's\n+            # for MSG_BLOCK, MSG_WITNESS_BLOCK, and rpc getblock() are equal.\n+            all_heights = list(range(chain_height+1))\n+            random.shuffle(all_heights)\n+            all_heights = all_heights[0:10]\n+            for height in all_heights:\n+                block_hash = self.nodes[0].getblockhash(height)\n+                rpc_block = self.nodes[0].getblock(block_hash, False)\n+                block_hash = int(block_hash, 16)\n+                block = self.test_node.request_block(block_hash, 2)\n+                wit_block = self.test_node.request_block(block_hash, 2|MSG_WITNESS_FLAG)\n+                assert_equal(block.serialize(True), wit_block.serialize(True))\n+                assert_equal(block.serialize(), hex_str_to_bytes(rpc_block))\n+        else:\n+            # After activation, witness blocks and non-witness blocks should\n+            # be different.  Verify rpc getblock() returns witness blocks, while\n+            # getdata respects the requested type.\n+            block = self.build_next_block()\n+            self.update_witness_block_with_transactions(block, [])\n+            # This gives us a witness commitment.\n+            assert(len(block.vtx[0].wit.vtxinwit) == 1)\n+            assert(len(block.vtx[0].wit.vtxinwit[0].scriptWitness.stack) == 1)\n+            self.test_node.test_witness_block(block, accepted=True)\n+            # Now try to retrieve it...\n+            rpc_block = self.nodes[0].getblock(block.hash, False)\n+            non_wit_block = self.test_node.request_block(block.sha256, 2)\n+            wit_block = self.test_node.request_block(block.sha256, 2|MSG_WITNESS_FLAG)\n+            assert_equal(wit_block.serialize(True), hex_str_to_bytes(rpc_block))\n+            assert_equal(wit_block.serialize(False), non_wit_block.serialize())\n+            assert_equal(wit_block.serialize(True), block.serialize(True))\n+\n+            # Test size, vsize, cost\n+            rpc_details = self.nodes[0].getblock(block.hash, True)\n+            assert_equal(rpc_details[\"size\"], len(block.serialize(True)))\n+            assert_equal(rpc_details[\"strippedsize\"], len(block.serialize(False)))\n+            cost = 3*len(block.serialize(False)) + len(block.serialize(True))\n+            assert_equal(rpc_details[\"cost\"], cost)\n+\n+            # Upgraded node should not ask for blocks from unupgraded\n+            block4 = self.build_next_block(nVersion=4)\n+            block4.solve()\n+            self.old_node.getdataset = set()\n+            # Blocks can be requested via direct-fetch (immediately upon processing the announcement)\n+            # or via parallel download (with an indeterminate delay from processing the announcement)\n+            # so to test that a block is NOT requested, we could guess a time period to sleep for,\n+            # and then check. We can avoid the sleep() by taking advantage of transaction getdata's\n+            # being processed after block getdata's, and announce a transaction as well,\n+            # and then check to see if that particular getdata has been received.\n+            self.old_node.announce_block(block4, use_header=False)\n+            self.old_node.announce_tx_and_wait_for_getdata(block4.vtx[0])\n+            assert(block4.sha256 not in self.old_node.getdataset)\n+\n+    # Verify that future segwit upgraded transactions are non-standard,\n+    # but valid in blocks. Can run this before and after segwit activation.\n+    def test_segwit_versions(self):\n+        print(\"\\tTesting standardness/consensus for segwit versions (0-16)\")\n+        assert(len(self.utxo))\n+        NUM_TESTS = 17 # will test OP_0, OP1, ..., OP_16\n+        if (len(self.utxo) < NUM_TESTS):\n+            tx = CTransaction()\n+            tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n+            split_value = (self.utxo[0].nValue - 4000) // NUM_TESTS\n+            for i in range(NUM_TESTS):\n+                tx.vout.append(CTxOut(split_value, CScript([OP_TRUE])))\n+            tx.rehash()\n+            block = self.build_next_block()\n+            self.update_witness_block_with_transactions(block, [tx])\n+            self.test_node.test_witness_block(block, accepted=True)\n+            self.utxo.pop(0)\n+            for i in range(NUM_TESTS):\n+                self.utxo.append(UTXO(tx.sha256, i, split_value))\n+\n+        sync_blocks(self.nodes)\n+        temp_utxo = []\n+        tx = CTransaction()\n+        count = 0\n+        witness_program = CScript([OP_TRUE])\n+        witness_hash = sha256(witness_program)\n+        assert_equal(len(self.nodes[1].getrawmempool()), 0)\n+        for version in list(range(OP_1, OP_16+1)) + [OP_0]:\n+            count += 1\n+            # First try to spend to a future version segwit scriptPubKey.\n+            scriptPubKey = CScript([CScriptOp(version), witness_hash])\n+            tx.vin = [CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\")]\n+            tx.vout = [CTxOut(self.utxo[0].nValue-1000, scriptPubKey)]\n+            tx.rehash()\n+            self.std_node.test_transaction_acceptance(tx, with_witness=True, accepted=False)\n+            self.test_node.test_transaction_acceptance(tx, with_witness=True, accepted=True)\n+            self.utxo.pop(0)\n+            temp_utxo.append(UTXO(tx.sha256, 0, tx.vout[0].nValue))\n+\n+        self.nodes[0].generate(1) # Mine all the transactions\n+        sync_blocks(self.nodes)\n+        assert(len(self.nodes[0].getrawmempool()) == 0)\n+\n+        # Finally, verify that version 0 -> version 1 transactions\n+        # are non-standard\n+        scriptPubKey = CScript([CScriptOp(OP_1), witness_hash])\n+        tx2 = CTransaction()\n+        tx2.vin = [CTxIn(COutPoint(tx.sha256, 0), b\"\")]\n+        tx2.vout = [CTxOut(tx.vout[0].nValue-1000, scriptPubKey)]\n+        tx2.wit.vtxinwit.append(CTxinWitness())\n+        tx2.wit.vtxinwit[0].scriptWitness.stack = [ witness_program ]\n+        tx2.rehash()\n+        # Gets accepted to test_node, because standardness of outputs isn't\n+        # checked with fRequireStandard\n+        self.test_node.test_transaction_acceptance(tx2, with_witness=True, accepted=True)\n+        self.std_node.test_transaction_acceptance(tx2, with_witness=True, accepted=False)\n+        temp_utxo.pop() # last entry in temp_utxo was the output we just spent\n+        temp_utxo.append(UTXO(tx2.sha256, 0, tx2.vout[0].nValue))\n+\n+        # Spend everything in temp_utxo back to an OP_TRUE output.\n+        tx3 = CTransaction()\n+        total_value = 0\n+        for i in temp_utxo:\n+            tx3.vin.append(CTxIn(COutPoint(i.sha256, i.n), b\"\"))\n+            tx3.wit.vtxinwit.append(CTxinWitness())\n+            total_value += i.nValue\n+        tx3.wit.vtxinwit[-1].scriptWitness.stack = [witness_program]\n+        tx3.vout.append(CTxOut(total_value - 1000, CScript([OP_TRUE])))\n+        tx3.rehash()\n+        # Spending a higher version witness output is not allowed by policy,\n+        # even with fRequireStandard=false.\n+        self.test_node.test_transaction_acceptance(tx3, with_witness=True, accepted=False)\n+        self.test_node.sync_with_ping()\n+        with mininode_lock:\n+            assert(b\"reserved for soft-fork upgrades\" in self.test_node.last_reject.reason)\n+\n+        # Building a block with the transaction must be valid, however.\n+        block = self.build_next_block()\n+        self.update_witness_block_with_transactions(block, [tx2, tx3])\n+        self.test_node.test_witness_block(block, accepted=True)\n+        sync_blocks(self.nodes)\n+\n+        # Add utxo to our list\n+        self.utxo.append(UTXO(tx3.sha256, 0, tx3.vout[0].nValue))\n+\n+\n+    def test_premature_coinbase_witness_spend(self):\n+        print(\"\\tTesting premature coinbase witness spend\")\n+        block = self.build_next_block()\n+        # Change the output of the block to be a witness output.\n+        witness_program = CScript([OP_TRUE])\n+        witness_hash = sha256(witness_program)\n+        scriptPubKey = CScript([OP_0, witness_hash])\n+        block.vtx[0].vout[0].scriptPubKey = scriptPubKey\n+        # This next line will rehash the coinbase and update the merkle\n+        # root, and solve.\n+        self.update_witness_block_with_transactions(block, [])\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+        spend_tx = CTransaction()\n+        spend_tx.vin = [CTxIn(COutPoint(block.vtx[0].sha256, 0), b\"\")]\n+        spend_tx.vout = [CTxOut(block.vtx[0].vout[0].nValue, witness_program)]\n+        spend_tx.wit.vtxinwit.append(CTxinWitness())\n+        spend_tx.wit.vtxinwit[0].scriptWitness.stack = [ witness_program ]\n+        spend_tx.rehash()\n+\n+        # Now test a premature spend.\n+        self.nodes[0].generate(98)\n+        sync_blocks(self.nodes)\n+        block2 = self.build_next_block()\n+        self.update_witness_block_with_transactions(block2, [spend_tx])\n+        self.test_node.test_witness_block(block2, accepted=False)\n+\n+        # Advancing one more block should allow the spend.\n+        self.nodes[0].generate(1)\n+        block2 = self.build_next_block()\n+        self.update_witness_block_with_transactions(block2, [spend_tx])\n+        self.test_node.test_witness_block(block2, accepted=True)\n+        sync_blocks(self.nodes)\n+\n+\n+    def test_signature_version_1(self):\n+        print(\"\\tTesting segwit signature hash version 1\")\n+        key = CECKey()\n+        key.set_secretbytes(b\"9\")\n+        pubkey = CPubKey(key.get_pubkey())\n+\n+        witness_program = CScript([pubkey, CScriptOp(OP_CHECKSIG)])\n+        witness_hash = sha256(witness_program)\n+        scriptPubKey = CScript([OP_0, witness_hash])\n+\n+        # First create a witness output for use in the tests.\n+        assert(len(self.utxo))\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n+        tx.vout.append(CTxOut(self.utxo[0].nValue-1000, scriptPubKey))\n+        tx.rehash()\n+\n+        self.test_node.test_transaction_acceptance(tx, with_witness=True, accepted=True)\n+        # Mine this transaction in preparation for following tests.\n+        block = self.build_next_block()\n+        self.update_witness_block_with_transactions(block, [tx])\n+        self.test_node.test_witness_block(block, accepted=True)\n+        sync_blocks(self.nodes)\n+        self.utxo.pop(0)\n+\n+        # Add signature for a P2PK witness program.\n+        def sign_P2PK_witness_input(script, txTo, inIdx, hashtype, value, key):\n+            tx_hash = SegwitVersion1SignatureHash(script, txTo, inIdx, hashtype, value)\n+            signature = key.sign(tx_hash) + chr(hashtype).encode('latin-1')\n+            txTo.wit.vtxinwit[inIdx].scriptWitness.stack = [signature, script]\n+            txTo.rehash()\n+\n+        # Test each hashtype\n+        prev_utxo = UTXO(tx.sha256, 0, tx.vout[0].nValue)\n+        for sigflag in [ 0, SIGHASH_ANYONECANPAY ]:\n+            for hashtype in [SIGHASH_ALL, SIGHASH_NONE, SIGHASH_SINGLE]:\n+                hashtype |= sigflag\n+                block = self.build_next_block()\n+                tx = CTransaction()\n+                tx.vin.append(CTxIn(COutPoint(prev_utxo.sha256, prev_utxo.n), b\"\"))\n+                tx.vout.append(CTxOut(prev_utxo.nValue - 1000, scriptPubKey))\n+                tx.wit.vtxinwit.append(CTxinWitness())\n+                # Too-large input value\n+                sign_P2PK_witness_input(witness_program, tx, 0, hashtype, prev_utxo.nValue+1, key)\n+                self.update_witness_block_with_transactions(block, [tx])\n+                self.test_node.test_witness_block(block, accepted=False)\n+\n+                # Too-small input value\n+                sign_P2PK_witness_input(witness_program, tx, 0, hashtype, prev_utxo.nValue-1, key)\n+                block.vtx.pop() # remove last tx\n+                self.update_witness_block_with_transactions(block, [tx])\n+                self.test_node.test_witness_block(block, accepted=False)\n+\n+                # Now try correct value\n+                sign_P2PK_witness_input(witness_program, tx, 0, hashtype, prev_utxo.nValue, key)\n+                block.vtx.pop()\n+                self.update_witness_block_with_transactions(block, [tx])\n+                self.test_node.test_witness_block(block, accepted=True)\n+\n+                prev_utxo = UTXO(tx.sha256, 0, tx.vout[0].nValue)\n+\n+        # Test combinations of signature hashes.\n+        # Split the utxo into a lot of outputs.\n+        # Randomly choose up to 10 to spend, sign with different hashtypes, and\n+        # output to a random number of outputs.  Repeat NUM_TESTS times.\n+        # Ensure that we've tested a situation where we use SIGHASH_SINGLE with\n+        # an input index > number of outputs.\n+        NUM_TESTS = 500\n+        temp_utxos = []\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(prev_utxo.sha256, prev_utxo.n), b\"\"))\n+        split_value = prev_utxo.nValue // NUM_TESTS\n+        for i in range(NUM_TESTS):\n+            tx.vout.append(CTxOut(split_value, scriptPubKey))\n+        tx.wit.vtxinwit.append(CTxinWitness())\n+        sign_P2PK_witness_input(witness_program, tx, 0, SIGHASH_ALL, prev_utxo.nValue, key)\n+        for i in range(NUM_TESTS):\n+            temp_utxos.append(UTXO(tx.sha256, i, split_value))\n+\n+        block = self.build_next_block()\n+        self.update_witness_block_with_transactions(block, [tx])\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+        block = self.build_next_block()\n+        used_sighash_single_out_of_bounds = False\n+        for i in range(NUM_TESTS):\n+            # Choose random number of inputs to use.\n+            num_inputs = random.randint(1, 10)\n+            # Create a slight bias for producing more utxos\n+            num_outputs = random.randint(1, 11)\n+            random.shuffle(temp_utxos)\n+            assert(len(temp_utxos) > num_inputs)\n+            tx = CTransaction()\n+            total_value = 0\n+            for i in range(num_inputs):\n+                tx.vin.append(CTxIn(COutPoint(temp_utxos[i].sha256, temp_utxos[i].n), b\"\"))\n+                tx.wit.vtxinwit.append(CTxinWitness())\n+                total_value += temp_utxos[i].nValue\n+            split_value = total_value // num_outputs\n+            for i in range(num_outputs):\n+                tx.vout.append(CTxOut(split_value, scriptPubKey))\n+            for i in range(num_inputs):\n+                # Now try to sign each input, using a random hashtype.\n+                anyonecanpay = 0\n+                if random.randint(0, 1):\n+                    anyonecanpay = SIGHASH_ANYONECANPAY\n+                hashtype = random.randint(1, 3) | anyonecanpay\n+                sign_P2PK_witness_input(witness_program, tx, i, hashtype, temp_utxos[i].nValue, key)\n+                if (hashtype == SIGHASH_SINGLE and i >= num_outputs):\n+                    used_sighash_single_out_of_bounds = True\n+            tx.rehash()\n+            for i in range(num_outputs):\n+                temp_utxos.append(UTXO(tx.sha256, i, split_value))\n+            temp_utxos = temp_utxos[num_inputs:]\n+\n+            block.vtx.append(tx)\n+\n+            # Test the block periodically, if we're close to maxblocksize\n+            if (get_virtual_size(block) > MAX_BLOCK_SIZE - 1000):\n+                self.update_witness_block_with_transactions(block, [])\n+                self.test_node.test_witness_block(block, accepted=True)\n+                block = self.build_next_block()\n+\n+        if (not used_sighash_single_out_of_bounds):\n+            print(\"WARNING: this test run didn't attempt SIGHASH_SINGLE with out-of-bounds index value\")\n+        # Test the transactions we've added to the block\n+        if (len(block.vtx) > 1):\n+            self.update_witness_block_with_transactions(block, [])\n+            self.test_node.test_witness_block(block, accepted=True)\n+\n+        # Now test witness version 0 P2PKH transactions\n+        pubkeyhash = hash160(pubkey)\n+        scriptPKH = CScript([OP_0, pubkeyhash])\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(temp_utxos[0].sha256, temp_utxos[0].n), b\"\"))\n+        tx.vout.append(CTxOut(temp_utxos[0].nValue, scriptPKH))\n+        tx.wit.vtxinwit.append(CTxinWitness())\n+        sign_P2PK_witness_input(witness_program, tx, 0, SIGHASH_ALL, temp_utxos[0].nValue, key)\n+        tx2 = CTransaction()\n+        tx2.vin.append(CTxIn(COutPoint(tx.sha256, 0), b\"\"))\n+        tx2.vout.append(CTxOut(tx.vout[0].nValue, CScript([OP_TRUE])))\n+\n+        script = CScript([CScriptOp(OP_DUP), CScriptOp(OP_HASH160), pubkeyhash, CScriptOp(OP_EQUALVERIFY), CScriptOp(OP_CHECKSIG)])\n+        sig_hash = SegwitVersion1SignatureHash(script, tx2, 0, SIGHASH_ALL, tx.vout[0].nValue)\n+        signature = key.sign(sig_hash) + b'\\x01' # 0x1 is SIGHASH_ALL\n+\n+        # Check that we can't have a scriptSig\n+        tx2.vin[0].scriptSig = CScript([signature, pubkey])\n+        block = self.build_next_block()\n+        self.update_witness_block_with_transactions(block, [tx, tx2])\n+        self.test_node.test_witness_block(block, accepted=False)\n+\n+        # Move the signature to the witness.\n+        block.vtx.pop()\n+        tx2.wit.vtxinwit.append(CTxinWitness())\n+        tx2.wit.vtxinwit[0].scriptWitness.stack = [signature, pubkey]\n+        tx2.vin[0].scriptSig = b\"\"\n+        tx2.rehash()\n+\n+        self.update_witness_block_with_transactions(block, [tx2])\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+        temp_utxos.pop(0)\n+\n+        # Update self.utxos for later tests. Just spend everything in\n+        # temp_utxos to a corresponding entry in self.utxos\n+        tx = CTransaction()\n+        index = 0\n+        for i in temp_utxos:\n+            # Just spend to our usual anyone-can-spend output\n+            # Use SIGHASH_SINGLE|SIGHASH_ANYONECANPAY so we can build up\n+            # the signatures as we go.\n+            tx.vin.append(CTxIn(COutPoint(i.sha256, i.n), b\"\"))\n+            tx.vout.append(CTxOut(i.nValue, CScript([OP_TRUE])))\n+            tx.wit.vtxinwit.append(CTxinWitness())\n+            sign_P2PK_witness_input(witness_program, tx, index, SIGHASH_SINGLE|SIGHASH_ANYONECANPAY, i.nValue, key)\n+            index += 1\n+        block = self.build_next_block()\n+        self.update_witness_block_with_transactions(block, [tx])\n+        self.test_node.test_witness_block(block, accepted=True)\n+\n+        for i in range(len(tx.vout)):\n+            self.utxo.append(UTXO(tx.sha256, i, tx.vout[i].nValue))\n+\n+\n+    # Test P2SH wrapped witness programs.\n+    def test_p2sh_witness(self, segwit_activated):\n+        print(\"\\tTesting P2SH witness transactions\")\n+\n+        assert(len(self.utxo))\n+\n+        # Prepare the p2sh-wrapped witness output\n+        witness_program = CScript([OP_DROP, OP_TRUE])\n+        witness_hash = sha256(witness_program)\n+        p2wsh_pubkey = CScript([OP_0, witness_hash])\n+        p2sh_witness_hash = hash160(p2wsh_pubkey)\n+        scriptPubKey = CScript([OP_HASH160, p2sh_witness_hash, OP_EQUAL])\n+        scriptSig = CScript([p2wsh_pubkey]) # a push of the redeem script\n+\n+        # Fund the P2SH output\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n+        tx.vout.append(CTxOut(self.utxo[0].nValue-1000, scriptPubKey))\n+        tx.rehash()\n+\n+        # Verify mempool acceptance and block validity\n+        self.test_node.test_transaction_acceptance(tx, with_witness=False, accepted=True)\n+        block = self.build_next_block()\n+        self.update_witness_block_with_transactions(block, [tx])\n+        self.test_node.test_witness_block(block, accepted=True, with_witness=segwit_activated)\n+        sync_blocks(self.nodes)\n+\n+        # Now test attempts to spend the output.\n+        spend_tx = CTransaction()\n+        spend_tx.vin.append(CTxIn(COutPoint(tx.sha256, 0), scriptSig))\n+        spend_tx.vout.append(CTxOut(tx.vout[0].nValue-1000, CScript([OP_TRUE])))\n+        spend_tx.rehash()\n+\n+        # This transaction should not be accepted into the mempool pre- or\n+        # post-segwit.  Mempool acceptance will use SCRIPT_VERIFY_WITNESS which\n+        # will require a witness to spend a witness program regardless of\n+        # segwit activation.  Note that older bitcoind's that are not\n+        # segwit-aware would also reject this for failing CLEANSTACK.\n+        self.test_node.test_transaction_acceptance(spend_tx, with_witness=False, accepted=False)\n+\n+        # Try to put the witness script in the scriptSig, should also fail.\n+        spend_tx.vin[0].scriptSig = CScript([p2wsh_pubkey, b'a'])\n+        spend_tx.rehash()\n+        self.test_node.test_transaction_acceptance(spend_tx, with_witness=False, accepted=False)\n+\n+        # Now put the witness script in the witness, should succeed after\n+        # segwit activates.\n+        spend_tx.vin[0].scriptSig = scriptSig\n+        spend_tx.rehash()\n+        spend_tx.wit.vtxinwit.append(CTxinWitness())\n+        spend_tx.wit.vtxinwit[0].scriptWitness.stack = [ b'a', witness_program ]\n+\n+        # Verify mempool acceptance\n+        self.test_node.test_transaction_acceptance(spend_tx, with_witness=True, accepted=segwit_activated)\n+        block = self.build_next_block()\n+        self.update_witness_block_with_transactions(block, [spend_tx])\n+\n+        # If we're before activation, then sending this without witnesses\n+        # should be valid.  If we're after activation, then sending this with\n+        # witnesses should be valid.\n+        if segwit_activated:\n+            self.test_node.test_witness_block(block, accepted=True)\n+        else:\n+            self.test_node.test_witness_block(block, accepted=True, with_witness=False)\n+\n+        # Update self.utxo\n+        self.utxo.pop(0)\n+        self.utxo.append(UTXO(spend_tx.sha256, 0, spend_tx.vout[0].nValue))\n+\n+    # Test the behavior of starting up a segwit-aware node after the softfork\n+    # has activated.  As segwit requires different block data than pre-segwit\n+    # nodes would have stored, this requires special handling.\n+    # To enable this test, pass --oldbinary=<path-to-pre-segwit-bitcoind> to\n+    # the test.\n+    def test_upgrade_after_activation(self, node, node_id):\n+        print(\"\\tTesting software upgrade after softfork activation\")\n+\n+        assert(node_id != 0) # node0 is assumed to be a segwit-active bitcoind\n+\n+        # Make sure the nodes are all up\n+        sync_blocks(self.nodes)\n+\n+        # Restart with the new binary\n+        stop_node(node, node_id)\n+        self.nodes[node_id] = start_node(node_id, self.options.tmpdir, [\"-debug\"])\n+        connect_nodes(self.nodes[0], node_id)\n+\n+        sync_blocks(self.nodes)\n+\n+        # Make sure that this peer thinks segwit has activated.\n+        assert(get_bip9_status(node, 'segwit')['status'] == \"active\")\n+\n+        # Make sure this peers blocks match those of node0.\n+        height = node.getblockcount()\n+        while height >= 0:\n+            block_hash = node.getblockhash(height)\n+            assert_equal(block_hash, self.nodes[0].getblockhash(height))\n+            assert_equal(self.nodes[0].getblock(block_hash), node.getblock(block_hash))\n+            height -= 1\n+\n+\n+    def test_witness_sigops(self):\n+        '''Ensure sigop counting is correct inside witnesses.'''\n+        print(\"\\tTesting sigops limit\")\n+\n+        assert(len(self.utxo))\n+\n+        # Keep this under MAX_OPS_PER_SCRIPT (201)\n+        witness_program = CScript([OP_TRUE, OP_IF, OP_TRUE, OP_ELSE] + [OP_CHECKMULTISIG]*5 + [OP_CHECKSIG]*193 + [OP_ENDIF])\n+        witness_hash = sha256(witness_program)\n+        scriptPubKey = CScript([OP_0, witness_hash])\n+\n+        sigops_per_script = 20*5 + 193*1\n+        # We'll produce 2 extra outputs, one with a program that would take us\n+        # over max sig ops, and one with a program that would exactly reach max\n+        # sig ops\n+        outputs = (MAX_SIGOP_COST // sigops_per_script) + 2\n+        extra_sigops_available = MAX_SIGOP_COST % sigops_per_script\n+\n+        # We chose the number of checkmultisigs/checksigs to make this work:\n+        assert(extra_sigops_available < 100) # steer clear of MAX_OPS_PER_SCRIPT\n+\n+        # This script, when spent with the first\n+        # N(=MAX_SIGOP_COST//sigops_per_script) outputs of our transaction,\n+        # would push us just over the block sigop limit.\n+        witness_program_toomany = CScript([OP_TRUE, OP_IF, OP_TRUE, OP_ELSE] + [OP_CHECKSIG]*(extra_sigops_available + 1) + [OP_ENDIF])\n+        witness_hash_toomany = sha256(witness_program_toomany)\n+        scriptPubKey_toomany = CScript([OP_0, witness_hash_toomany])\n+\n+        # If we spend this script instead, we would exactly reach our sigop\n+        # limit (for witness sigops).\n+        witness_program_justright = CScript([OP_TRUE, OP_IF, OP_TRUE, OP_ELSE] + [OP_CHECKSIG]*(extra_sigops_available) + [OP_ENDIF])\n+        witness_hash_justright = sha256(witness_program_justright)\n+        scriptPubKey_justright = CScript([OP_0, witness_hash_justright])\n+\n+        # First split our available utxo into a bunch of outputs\n+        split_value = self.utxo[0].nValue // outputs\n+        tx = CTransaction()\n+        tx.vin.append(CTxIn(COutPoint(self.utxo[0].sha256, self.utxo[0].n), b\"\"))\n+        for i in range(outputs):\n+            tx.vout.append(CTxOut(split_value, scriptPubKey))\n+        tx.vout[-2].scriptPubKey = scriptPubKey_toomany\n+        tx.vout[-1].scriptPubKey = scriptPubKey_justright\n+        tx.rehash()\n+\n+        block_1 = self.build_next_block()\n+        self.update_witness_block_with_transactions(block_1, [tx])\n+        self.test_node.test_witness_block(block_1, accepted=True)\n+\n+        tx2 = CTransaction()\n+        # If we try to spend the first n-1 outputs from tx, that should be\n+        # too many sigops.\n+        total_value = 0\n+        for i in range(outputs-1):\n+            tx2.vin.append(CTxIn(COutPoint(tx.sha256, i), b\"\"))\n+            tx2.wit.vtxinwit.append(CTxinWitness())\n+            tx2.wit.vtxinwit[-1].scriptWitness.stack = [ witness_program ]\n+            total_value += tx.vout[i].nValue\n+        tx2.wit.vtxinwit[-1].scriptWitness.stack = [ witness_program_toomany ] \n+        tx2.vout.append(CTxOut(total_value, CScript([OP_TRUE])))\n+        tx2.rehash()\n+\n+        block_2 = self.build_next_block()\n+        self.update_witness_block_with_transactions(block_2, [tx2])\n+        self.test_node.test_witness_block(block_2, accepted=False)\n+\n+        # Try dropping the last input in tx2, and add an output that has\n+        # too many sigops (contributing to legacy sigop count).\n+        checksig_count = (extra_sigops_available // 4) + 1\n+        scriptPubKey_checksigs = CScript([OP_CHECKSIG]*checksig_count)\n+        tx2.vout.append(CTxOut(0, scriptPubKey_checksigs));\n+        tx2.vin.pop()\n+        tx2.wit.vtxinwit.pop()\n+        tx2.vout[0].nValue -= tx.vout[-2].nValue\n+        tx2.rehash()\n+        block_3 = self.build_next_block()\n+        self.update_witness_block_with_transactions(block_3, [tx2])\n+        self.test_node.test_witness_block(block_3, accepted=False)\n+\n+        # If we drop the last checksig in this output, the tx should succeed.\n+        block_4 = self.build_next_block()\n+        tx2.vout[-1].scriptPubKey = CScript([OP_CHECKSIG]*(checksig_count-1))\n+        tx2.rehash()\n+        self.update_witness_block_with_transactions(block_4, [tx2])\n+        self.test_node.test_witness_block(block_4, accepted=True)\n+\n+        # Reset the tip back down for the next test\n+        sync_blocks(self.nodes)\n+        for x in self.nodes:\n+            x.invalidateblock(block_4.hash)\n+\n+        # Try replacing the last input of tx2 to be spending the last\n+        # output of tx\n+        block_5 = self.build_next_block()\n+        tx2.vout.pop()\n+        tx2.vin.append(CTxIn(COutPoint(tx.sha256, outputs-1), b\"\"))\n+        tx2.wit.vtxinwit.append(CTxinWitness())\n+        tx2.wit.vtxinwit[-1].scriptWitness.stack = [ witness_program_justright ]\n+        tx2.rehash()\n+        self.update_witness_block_with_transactions(block_5, [tx2])\n+        self.test_node.test_witness_block(block_5, accepted=True)\n+\n+        # TODO: test p2sh sigop counting\n+\n+    def test_getblocktemplate_before_lockin(self):\n+        print(\"\\tTesting getblocktemplate setting of segwit versionbit (before lockin)\")\n+        block_version = (self.nodes[0].getblocktemplate())['version']\n+        assert_equal(block_version & (1 << VB_WITNESS_BIT), 0)\n+\n+        # Workaround:\n+        # Can either change the tip, or change the mempool and wait 5 seconds\n+        # to trigger a recomputation of getblocktemplate.\n+        self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 1)\n+        # Using mocktime lets us avoid sleep()\n+        self.nodes[0].setmocktime(int(time.time())+10)\n+\n+        block_version = self.nodes[0].getblocktemplate({\"rules\" : [\"segwit\"]})['version']\n+        assert(block_version & (1 << VB_WITNESS_BIT) != 0)\n+        self.nodes[0].setmocktime(0) # undo mocktime\n+\n+    def run_test(self):\n+        # Setup the p2p connections and start up the network thread.\n+        self.test_node = TestNode() # sets NODE_WITNESS|NODE_NETWORK\n+        self.old_node = TestNode()  # only NODE_NETWORK\n+        self.std_node = TestNode() # for testing node1 (fRequireStandard=true)\n+\n+        self.p2p_connections = [self.test_node, self.old_node]\n+\n+        self.connections = []\n+        self.connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], self.test_node, services=NODE_NETWORK|NODE_WITNESS))\n+        self.connections.append(NodeConn('127.0.0.1', p2p_port(0), self.nodes[0], self.old_node, services=NODE_NETWORK))\n+        self.connections.append(NodeConn('127.0.0.1', p2p_port(1), self.nodes[1], self.std_node, services=NODE_NETWORK|NODE_WITNESS))\n+        self.test_node.add_connection(self.connections[0])\n+        self.old_node.add_connection(self.connections[1])\n+        self.std_node.add_connection(self.connections[2])\n+\n+        NetworkThread().start() # Start up network handling in another thread\n+\n+        # Keep a place to store utxo's that can be used in later tests\n+        self.utxo = []\n+\n+        # Test logic begins here\n+        self.test_node.wait_for_verack()\n+\n+        print(\"\\nStarting tests before segwit lock in:\")\n+\n+        self.test_witness_services() # Verifies NODE_WITNESS\n+        self.test_non_witness_transaction() # non-witness tx's are accepted\n+        self.test_unnecessary_witness_before_segwit_activation()\n+        self.test_block_relay(segwit_activated=False)\n+\n+        # Advance to segwit being 'started'\n+        self.advance_to_segwit_started()\n+        self.test_getblocktemplate_before_lockin()\n+\n+        sync_blocks(self.nodes)\n+\n+        # At lockin, nothing should change.\n+        print(\"\\nTesting behavior post lockin, pre-activation\")\n+        self.advance_to_segwit_lockin()\n+\n+        # Retest unnecessary witnesses\n+        self.test_unnecessary_witness_before_segwit_activation()\n+        self.test_witness_tx_relay_before_segwit_activation()\n+        self.test_block_relay(segwit_activated=False)\n+        self.test_p2sh_witness(segwit_activated=False)\n+\n+        sync_blocks(self.nodes)\n+\n+        # Now activate segwit\n+        print(\"\\nTesting behavior after segwit activation\")\n+        self.advance_to_segwit_active()\n+\n+        sync_blocks(self.nodes)\n+\n+        # Test P2SH witness handling again\n+        self.test_p2sh_witness(segwit_activated=True)\n+        self.test_witness_commitments()\n+        self.test_block_malleability()\n+        self.test_witness_block_size()\n+        self.test_submit_block()\n+        self.test_extra_witness_data()\n+        self.test_max_witness_push_length()\n+        self.test_max_witness_program_length()\n+        self.test_witness_input_length()\n+        self.test_block_relay(segwit_activated=True)\n+        self.test_tx_relay_after_segwit_activation()\n+        self.test_segwit_versions()\n+        self.test_premature_coinbase_witness_spend()\n+        self.test_signature_version_1()\n+        sync_blocks(self.nodes)\n+        if self.test_upgrade:\n+            self.test_upgrade_after_activation(self.nodes[2], 2)\n+        else:\n+            print(\"\\tSkipping upgrade-after-activation test (use --oldbinary to enable)\")\n+        self.test_witness_sigops()\n+\n+\n+if __name__ == '__main__':\n+    SegWitTest().main()"
      },
      {
        "sha": "df4fe13e5c1c6ede900cefd307629c70210dc234",
        "filename": "qa/rpc-tests/test_framework/blocktools.py",
        "status": "modified",
        "additions": 24,
        "deletions": 1,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/330b0f31ee5719d94f9e52dfc83c5d82168241f9/qa/rpc-tests/test_framework/blocktools.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/330b0f31ee5719d94f9e52dfc83c5d82168241f9/qa/rpc-tests/test_framework/blocktools.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/test_framework/blocktools.py?ref=330b0f31ee5719d94f9e52dfc83c5d82168241f9",
        "patch": "@@ -5,7 +5,7 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n from .mininode import *\n-from .script import CScript, OP_TRUE, OP_CHECKSIG\n+from .script import CScript, OP_TRUE, OP_CHECKSIG, OP_RETURN\n \n # Create a block (with regtest difficulty)\n def create_block(hashprev, coinbase, nTime=None):\n@@ -22,6 +22,29 @@ def create_block(hashprev, coinbase, nTime=None):\n     block.calc_sha256()\n     return block\n \n+# From BIP141\n+WITNESS_COMMITMENT_HEADER = b\"\\xaa\\x21\\xa9\\xed\"\n+\n+# According to BIP141, blocks with witness rules active must commit to the\n+# hash of all in-block transactions including witness.\n+def add_witness_commitment(block, nonce=0):\n+    # First calculate the merkle root of the block's\n+    # transactions, with witnesses.\n+    witness_nonce = nonce\n+    witness_root = block.calc_witness_merkle_root()\n+    witness_commitment = uint256_from_str(hash256(ser_uint256(witness_root)+ser_uint256(witness_nonce)))\n+    # witness_nonce should go to coinbase witness.\n+    block.vtx[0].wit.vtxinwit = [CTxinWitness()]\n+    block.vtx[0].wit.vtxinwit[0].scriptWitness.stack = [ser_uint256(witness_nonce)]\n+\n+    # witness commitment is the last OP_RETURN output in coinbase\n+    output_data = WITNESS_COMMITMENT_HEADER + ser_uint256(witness_commitment)\n+    block.vtx[0].vout.append(CTxOut(0, CScript([OP_RETURN, output_data])))\n+    block.vtx[0].rehash()\n+    block.hashMerkleRoot = block.calc_merkle_root()\n+    block.rehash()\n+\n+\n def serialize_script_num(value):\n     r = bytearray(0)\n     if value == 0:"
      },
      {
        "sha": "4548e2e7c080f391c82e1bdae705d161f16935a6",
        "filename": "qa/rpc-tests/test_framework/mininode.py",
        "status": "modified",
        "additions": 187,
        "deletions": 25,
        "changes": 212,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/330b0f31ee5719d94f9e52dfc83c5d82168241f9/qa/rpc-tests/test_framework/mininode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/330b0f31ee5719d94f9e52dfc83c5d82168241f9/qa/rpc-tests/test_framework/mininode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/test_framework/mininode.py?ref=330b0f31ee5719d94f9e52dfc83c5d82168241f9",
        "patch": "@@ -28,7 +28,7 @@\n import time\n import sys\n import random\n-from binascii import hexlify, unhexlify\n+from .util import hex_str_to_bytes, bytes_to_hex_str\n from io import BytesIO\n from codecs import encode\n import hashlib\n@@ -46,6 +46,11 @@\n \n COIN = 100000000 # 1 btc in satoshis\n \n+NODE_NETWORK = (1 << 0)\n+NODE_GETUTXO = (1 << 1)\n+NODE_BLOOM = (1 << 2)\n+NODE_WITNESS = (1 << 3)\n+\n # Keep our own socket map for asyncore, so that we can track disconnects\n # ourselves (to workaround an issue with closing an asyncore socket when \n # using select)\n@@ -63,6 +68,8 @@\n def sha256(s):\n     return hashlib.new('sha256', s).digest()\n \n+def ripemd160(s):\n+    return hashlib.new('ripemd160', s).digest()\n \n def hash256(s):\n     return sha256(sha256(s))\n@@ -133,7 +140,10 @@ def deser_vector(f, c):\n     return r\n \n \n-def ser_vector(l):\n+# ser_function_name: Allow for an alternate serialization function on the\n+# entries in the vector (we use this for serializing the vector of transactions\n+# for a witness block).\n+def ser_vector(l, ser_function_name=None):\n     r = b\"\"\n     if len(l) < 253:\n         r = struct.pack(\"B\", len(l))\n@@ -144,7 +154,10 @@ def ser_vector(l):\n     else:\n         r = struct.pack(\"<BQ\", 255, len(l))\n     for i in l:\n-        r += i.serialize()\n+        if ser_function_name:\n+            r += getattr(i, ser_function_name)()\n+        else:\n+            r += i.serialize()\n     return r\n \n \n@@ -239,12 +252,12 @@ def ser_int_vector(l):\n \n # Deserialize from a hex string representation (eg from RPC)\n def FromHex(obj, hex_string):\n-    obj.deserialize(BytesIO(unhexlify(hex_string.encode('ascii'))))\n+    obj.deserialize(BytesIO(hex_str_to_bytes(hex_string)))\n     return obj\n \n # Convert a binary-serializable object to hex (eg for submission via RPC)\n def ToHex(obj):\n-    return hexlify(obj.serialize()).decode('ascii')\n+    return bytes_to_hex_str(obj.serialize())\n \n # Objects that map to bitcoind objects, which can be serialized/deserialized\n \n@@ -273,12 +286,16 @@ def __repr__(self):\n         return \"CAddress(nServices=%i ip=%s port=%i)\" % (self.nServices,\n                                                          self.ip, self.port)\n \n+MSG_WITNESS_FLAG = 1<<30\n \n class CInv(object):\n     typemap = {\n         0: \"Error\",\n         1: \"TX\",\n-        2: \"Block\"}\n+        2: \"Block\",\n+        1|MSG_WITNESS_FLAG: \"WitnessTx\",\n+        2|MSG_WITNESS_FLAG : \"WitnessBlock\"\n+    }\n \n     def __init__(self, t=0, h=0):\n         self.type = t\n@@ -362,7 +379,7 @@ def serialize(self):\n \n     def __repr__(self):\n         return \"CTxIn(prevout=%s scriptSig=%s nSequence=%i)\" \\\n-            % (repr(self.prevout), hexlify(self.scriptSig),\n+            % (repr(self.prevout), bytes_to_hex_str(self.scriptSig),\n                self.nSequence)\n \n \n@@ -384,7 +401,67 @@ def serialize(self):\n     def __repr__(self):\n         return \"CTxOut(nValue=%i.%08i scriptPubKey=%s)\" \\\n             % (self.nValue // COIN, self.nValue % COIN,\n-               hexlify(self.scriptPubKey))\n+               bytes_to_hex_str(self.scriptPubKey))\n+\n+\n+class CScriptWitness(object):\n+    def __init__(self):\n+        # stack is a vector of strings\n+        self.stack = []\n+\n+    def __repr__(self):\n+        return \"CScriptWitness(%s)\" % \\\n+               (\",\".join([bytes_to_hex_str(x) for x in self.stack]))\n+\n+    def is_null(self):\n+        if self.stack:\n+            return False\n+        return True\n+\n+\n+class CTxinWitness(object):\n+    def __init__(self):\n+        self.scriptWitness = CScriptWitness()\n+\n+    def deserialize(self, f):\n+        self.scriptWitness.stack = deser_string_vector(f)\n+\n+    def serialize(self):\n+        return ser_string_vector(self.scriptWitness.stack)\n+\n+    def __repr__(self):\n+        return repr(self.scriptWitness)\n+\n+    def is_null(self):\n+        return self.scriptWitness.is_null()\n+\n+\n+class CTxWitness(object):\n+    def __init__(self):\n+        self.vtxinwit = []\n+\n+    def deserialize(self, f):\n+        for i in range(len(self.vtxinwit)):\n+            self.vtxinwit[i].deserialize(f)\n+\n+    def serialize(self):\n+        r = b\"\"\n+        # This is different than the usual vector serialization --\n+        # we omit the length of the vector, which is required to be\n+        # the same length as the transaction's vin vector.\n+        for x in self.vtxinwit:\n+            r += x.serialize()\n+        return r\n+\n+    def __repr__(self):\n+        return \"CTxWitness(%s)\" % \\\n+               (';'.join([repr(x) for x in self.vtxinwit]))\n+\n+    def is_null(self):\n+        for x in self.vtxinwit:\n+            if not x.is_null():\n+                return False\n+        return True\n \n \n class CTransaction(object):\n@@ -393,6 +470,7 @@ def __init__(self, tx=None):\n             self.nVersion = 1\n             self.vin = []\n             self.vout = []\n+            self.wit = CTxWitness()\n             self.nLockTime = 0\n             self.sha256 = None\n             self.hash = None\n@@ -401,32 +479,80 @@ def __init__(self, tx=None):\n             self.vin = copy.deepcopy(tx.vin)\n             self.vout = copy.deepcopy(tx.vout)\n             self.nLockTime = tx.nLockTime\n-            self.sha256 = None\n-            self.hash = None\n+            self.sha256 = tx.sha256\n+            self.hash = tx.hash\n+            self.wit = copy.deepcopy(tx.wit)\n \n     def deserialize(self, f):\n         self.nVersion = struct.unpack(\"<i\", f.read(4))[0]\n         self.vin = deser_vector(f, CTxIn)\n-        self.vout = deser_vector(f, CTxOut)\n+        flags = 0\n+        if len(self.vin) == 0:\n+            flags = struct.unpack(\"<B\", f.read(1))[0]\n+            # Not sure why flags can't be zero, but this\n+            # matches the implementation in bitcoind\n+            if (flags != 0):\n+                self.vin = deser_vector(f, CTxIn)\n+                self.vout = deser_vector(f, CTxOut)\n+        else:\n+            self.vout = deser_vector(f, CTxOut)\n+        if flags != 0:\n+            self.wit.vtxinwit = [CTxinWitness()]*len(self.vin)\n+            self.wit.deserialize(f)\n         self.nLockTime = struct.unpack(\"<I\", f.read(4))[0]\n         self.sha256 = None\n         self.hash = None\n \n-    def serialize(self):\n+    def serialize_without_witness(self):\n+        r = b\"\"\n+        r += struct.pack(\"<i\", self.nVersion)\n+        r += ser_vector(self.vin)\n+        r += ser_vector(self.vout)\n+        r += struct.pack(\"<I\", self.nLockTime)\n+        return r\n+\n+    # Only serialize with witness when explicitly called for\n+    def serialize_with_witness(self):\n+        flags = 0\n+        if not self.wit.is_null():\n+            flags |= 1\n         r = b\"\"\n         r += struct.pack(\"<i\", self.nVersion)\n+        if flags:\n+            dummy = []\n+            r += ser_vector(dummy)\n+            r += struct.pack(\"<B\", flags)\n         r += ser_vector(self.vin)\n         r += ser_vector(self.vout)\n+        if flags & 1:\n+            if (len(self.wit.vtxinwit) != len(self.vin)):\n+                # vtxinwit must have the same length as vin\n+                self.wit.vtxinwit = self.wit.vtxinwit[:len(self.vin)]\n+                for i in range(len(self.wit.vtxinwit), len(self.vin)):\n+                    self.wit.vtxinwit.append(CTxinWitness())\n+            r += self.wit.serialize()\n         r += struct.pack(\"<I\", self.nLockTime)\n         return r\n \n+    # Regular serialization is without witness -- must explicitly\n+    # call serialize_with_witness to include witness data.\n+    def serialize(self):\n+        return self.serialize_without_witness()\n+\n+    # Recalculate the txid (transaction hash without witness)\n     def rehash(self):\n         self.sha256 = None\n         self.calc_sha256()\n \n-    def calc_sha256(self):\n+    # We will only cache the serialization without witness in\n+    # self.sha256 and self.hash -- those are expected to be the txid.\n+    def calc_sha256(self, with_witness=False):\n+        if with_witness:\n+            # Don't cache the result, just return it\n+            return uint256_from_str(hash256(self.serialize_with_witness()))\n+\n         if self.sha256 is None:\n-            self.sha256 = uint256_from_str(hash256(self.serialize()))\n+            self.sha256 = uint256_from_str(hash256(self.serialize_without_witness()))\n         self.hash = encode(hash256(self.serialize())[::-1], 'hex_codec').decode('ascii')\n \n     def is_valid(self):\n@@ -518,17 +644,17 @@ def deserialize(self, f):\n         super(CBlock, self).deserialize(f)\n         self.vtx = deser_vector(f, CTransaction)\n \n-    def serialize(self):\n+    def serialize(self, with_witness=False):\n         r = b\"\"\n         r += super(CBlock, self).serialize()\n-        r += ser_vector(self.vtx)\n+        if with_witness:\n+            r += ser_vector(self.vtx, \"serialize_with_witness\")\n+        else:\n+            r += ser_vector(self.vtx)\n         return r\n \n-    def calc_merkle_root(self):\n-        hashes = []\n-        for tx in self.vtx:\n-            tx.calc_sha256()\n-            hashes.append(ser_uint256(tx.sha256))\n+    # Calculate the merkle root given a vector of transaction hashes\n+    def get_merkle_root(self, hashes):\n         while len(hashes) > 1:\n             newhashes = []\n             for i in range(0, len(hashes), 2):\n@@ -537,6 +663,24 @@ def calc_merkle_root(self):\n             hashes = newhashes\n         return uint256_from_str(hashes[0])\n \n+    def calc_merkle_root(self):\n+        hashes = []\n+        for tx in self.vtx:\n+            tx.calc_sha256()\n+            hashes.append(ser_uint256(tx.sha256))\n+        return self.get_merkle_root(hashes)\n+\n+    def calc_witness_merkle_root(self):\n+        # For witness root purposes, the hash of the\n+        # coinbase, with witness, is defined to be 0...0\n+        hashes = [ser_uint256(0)]\n+\n+        for tx in self.vtx[1:]:\n+            # Calculate the hashes with witness data\n+            hashes.append(ser_uint256(tx.calc_sha256(True)))\n+\n+        return self.get_merkle_root(hashes)\n+\n     def is_valid(self):\n         self.calc_sha256()\n         target = uint256_from_compact(self.nBits)\n@@ -812,11 +956,16 @@ def deserialize(self, f):\n         self.tx.deserialize(f)\n \n     def serialize(self):\n-        return self.tx.serialize()\n+        return self.tx.serialize_without_witness()\n \n     def __repr__(self):\n         return \"msg_tx(tx=%s)\" % (repr(self.tx))\n \n+class msg_witness_tx(msg_tx):\n+\n+    def serialize(self):\n+        return self.tx.serialize_with_witness()\n+\n \n class msg_block(object):\n     command = b\"block\"\n@@ -849,6 +998,12 @@ def serialize(self):\n     def __repr__(self):\n         return \"msg_generic()\"\n \n+class msg_witness_block(msg_block):\n+\n+    def serialize(self):\n+        r = self.block.serialize(with_witness=True)\n+        return r\n+\n class msg_getaddr(object):\n     command = b\"getaddr\"\n \n@@ -947,6 +1102,7 @@ def serialize(self):\n     def __repr__(self):\n         return \"msg_sendheaders()\"\n \n+\n # getheaders message has\n # number of entries\n # vector of hashes\n@@ -1068,6 +1224,8 @@ def __init__(self):\n         # tests; it causes message delivery to sleep for the specified time\n         # before acquiring the global lock and delivering the next message.\n         self.deliver_sleep_time = None\n+        # Remember the services our peer has advertised\n+        self.peer_services = None\n \n     def set_deliver_sleep_time(self, value):\n         with mininode_lock:\n@@ -1105,6 +1263,7 @@ def on_version(self, conn, message):\n         conn.ver_send = min(MY_VERSION, message.nVersion)\n         if message.nVersion < 209:\n             conn.ver_recv = conn.ver_send\n+        conn.nServices = message.nServices\n \n     def on_verack(self, conn, message):\n         conn.ver_recv = conn.ver_send\n@@ -1135,6 +1294,7 @@ def on_close(self, conn): pass\n     def on_mempool(self, conn): pass\n     def on_pong(self, conn, message): pass\n     def on_feefilter(self, conn, message): pass\n+    def on_sendheaders(self, conn, message): pass\n \n # More useful callbacks and functions for NodeConnCB's which have a single NodeConn\n class SingleNodeConnCB(NodeConnCB):\n@@ -1183,15 +1343,16 @@ class NodeConn(asyncore.dispatcher):\n         b\"getheaders\": msg_getheaders,\n         b\"reject\": msg_reject,\n         b\"mempool\": msg_mempool,\n-        b\"feefilter\": msg_feefilter\n+        b\"feefilter\": msg_feefilter,\n+        b\"sendheaders\": msg_sendheaders\n     }\n     MAGIC_BYTES = {\n         \"mainnet\": b\"\\xf9\\xbe\\xb4\\xd9\",   # mainnet\n         \"testnet3\": b\"\\x0b\\x11\\x09\\x07\",  # testnet3\n-        \"regtest\": b\"\\xfa\\xbf\\xb5\\xda\"    # regtest\n+        \"regtest\": b\"\\xfa\\xbf\\xb5\\xda\",   # regtest\n     }\n \n-    def __init__(self, dstaddr, dstport, rpc, callback, net=\"regtest\", services=1):\n+    def __init__(self, dstaddr, dstport, rpc, callback, net=\"regtest\", services=NODE_NETWORK):\n         asyncore.dispatcher.__init__(self, map=mininode_socket_map)\n         self.log = logging.getLogger(\"NodeConn(%s:%d)\" % (dstaddr, dstport))\n         self.dstaddr = dstaddr\n@@ -1206,6 +1367,7 @@ def __init__(self, dstaddr, dstport, rpc, callback, net=\"regtest\", services=1):\n         self.network = net\n         self.cb = callback\n         self.disconnect = False\n+        self.nServices = 0\n \n         # stuff version msg into sendbuf\n         vt = msg_version()"
      },
      {
        "sha": "7678228c42bb5722f4479e6a77ae474d54e021ad",
        "filename": "qa/rpc-tests/test_framework/script.py",
        "status": "modified",
        "additions": 51,
        "deletions": 1,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/330b0f31ee5719d94f9e52dfc83c5d82168241f9/qa/rpc-tests/test_framework/script.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/330b0f31ee5719d94f9e52dfc83c5d82168241f9/qa/rpc-tests/test_framework/script.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/test_framework/script.py?ref=330b0f31ee5719d94f9e52dfc83c5d82168241f9",
        "patch": "@@ -15,8 +15,9 @@\n \"\"\"\n \n \n-from .mininode import CTransaction, CTxOut, hash256\n+from .mininode import CTransaction, CTxOut, sha256, hash256, uint256_from_str, ser_uint256, ser_string\n from binascii import hexlify\n+import hashlib\n \n import sys\n bchr = chr\n@@ -36,6 +37,10 @@\n \n OPCODE_NAMES = {}\n \n+def hash160(s):\n+    return hashlib.new('ripemd160', sha256(s)).digest()\n+\n+\n _opcode_instances = []\n class CScriptOp(int):\n     \"\"\"A single script opcode\"\"\"\n@@ -895,3 +900,48 @@ def SignatureHash(script, txTo, inIdx, hashtype):\n     hash = hash256(s)\n \n     return (hash, None)\n+\n+# TODO: Allow cached hashPrevouts/hashSequence/hashOutputs to be provided.\n+# Performance optimization probably not necessary for python tests, however.\n+# Note that this corresponds to sigversion == 1 in EvalScript, which is used\n+# for version 0 witnesses.\n+def SegwitVersion1SignatureHash(script, txTo, inIdx, hashtype, amount):\n+\n+    hashPrevouts = 0\n+    hashSequence = 0\n+    hashOutputs = 0\n+\n+    if not (hashtype & SIGHASH_ANYONECANPAY):\n+        serialize_prevouts = bytes()\n+        for i in txTo.vin:\n+            serialize_prevouts += i.prevout.serialize()\n+        hashPrevouts = uint256_from_str(hash256(serialize_prevouts))\n+\n+    if (not (hashtype & SIGHASH_ANYONECANPAY) and (hashtype & 0x1f) != SIGHASH_SINGLE and (hashtype & 0x1f) != SIGHASH_NONE):\n+        serialize_sequence = bytes()\n+        for i in txTo.vin:\n+            serialize_sequence += struct.pack(\"<I\", i.nSequence)\n+        hashSequence = uint256_from_str(hash256(serialize_sequence))\n+\n+    if ((hashtype & 0x1f) != SIGHASH_SINGLE and (hashtype & 0x1f) != SIGHASH_NONE):\n+        serialize_outputs = bytes()\n+        for o in txTo.vout:\n+            serialize_outputs += o.serialize()\n+        hashOutputs = uint256_from_str(hash256(serialize_outputs))\n+    elif ((hashtype & 0x1f) == SIGHASH_SINGLE and inIdx < len(txTo.vout)):\n+        serialize_outputs = txTo.vout[inIdx].serialize()\n+        hashOutputs = uint256_from_str(hash256(serialize_outputs))\n+\n+    ss = bytes()\n+    ss += struct.pack(\"<i\", txTo.nVersion)\n+    ss += ser_uint256(hashPrevouts)\n+    ss += ser_uint256(hashSequence)\n+    ss += txTo.vin[inIdx].prevout.serialize()\n+    ss += ser_string(script)\n+    ss += struct.pack(\"<q\", amount)\n+    ss += struct.pack(\"<I\", txTo.vin[inIdx].nSequence)\n+    ss += ser_uint256(hashOutputs)\n+    ss += struct.pack(\"<i\", txTo.nLockTime)\n+    ss += struct.pack(\"<I\", hashtype)\n+\n+    return hash256(ss)"
      },
      {
        "sha": "a59e1389f9bfbdc4c284fd5cdadc721c0552bf7c",
        "filename": "src/test/data/script_tests.json",
        "status": "modified",
        "additions": 84,
        "deletions": 0,
        "changes": 84,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/330b0f31ee5719d94f9e52dfc83c5d82168241f9/src/test/data/script_tests.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/330b0f31ee5719d94f9e52dfc83c5d82168241f9/src/test/data/script_tests.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/data/script_tests.json?ref=330b0f31ee5719d94f9e52dfc83c5d82168241f9",
        "patch": "@@ -1966,6 +1966,90 @@\n     \"OK\",\n     \"Basic P2SH(P2WPKH) with the wrong key but no WITNESS\"\n ],\n+[\n+    [\n+        \"304402205ae57ae0534c05ca9981c8a6cdf353b505eaacb7375f96681a2d1a4ba6f02f84022056248e68643b7d8ce7c7d128c9f1f348bcab8be15d094ad5cadd24251a28df8001\",\n+        \"0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8\"\n+    ],\n+    \"\",\n+    \"1 0x14 0x91b24bf9f5288532960ac687abb035127b1d28a5\",\n+    \"DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM,P2SH,WITNESS\",\n+    \"DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM\",\n+    \"P2WPKH with future witness version\"\n+],\n+[\n+    [\n+        \"3044022064100ca0e2a33332136775a86cd83d0230e58b9aebb889c5ac952abff79a46ef02205f1bf900e022039ad3091bdaf27ac2aef3eae9ed9f190d821d3e508405b9513101\",\n+        \"0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8\"\n+    ],\n+    \"\",\n+    \"0 0x1f 0xb34b78da162751647974d5cb7410aa428ad339dbf7d1e16e833f68a0cbf1c3\",\n+    \"P2SH,WITNESS\",\n+    \"WITNESS_PROGRAM_WRONG_LENGTH\",\n+    \"P2WPKH with wrong witness program length\"\n+],\n+[\n+    \"\",\n+    \"0 0x20 0xb95237b48faaa69eb078e1170be3b5cbb3fddf16d0a991e14ad274f7b33a4f64\",\n+    \"P2SH,WITNESS\",\n+    \"WITNESS_PROGRAM_WITNESS_EMPTY\",\n+    \"P2WSH with empty witness\"\n+],\n+[\n+    [\n+        \"3044022039105b995a5f448639a997a5c90fda06f50b49df30c3bdb6663217bf79323db002206fecd54269dec569fcc517178880eb58bb40f381a282bb75766ff3637d5f4b4301\",\n+        \"400479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8ac\"\n+    ],\n+    \"\",\n+    \"0 0x20 0xb95237b48faaa69eb078e1170be3b5cbb3fddf16d0a991e14ad274f7b33a4f64\",\n+    \"P2SH,WITNESS\",\n+    \"WITNESS_PROGRAM_MISMATCH\",\n+    \"P2WSH with witness program mismatch\"\n+],\n+[\n+    [\n+        \"304402201a96950593cb0af32d080b0f193517f4559241a8ebd1e95e414533ad64a3f423022047f4f6d3095c23235bdff3aeff480d0529c027a3f093cb265b7cbf148553b85101\",\n+        \"0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8\",\n+        \"\"\n+    ],\n+    \"\",\n+    \"0 0x14 0x91b24bf9f5288532960ac687abb035127b1d28a5\",\n+    \"P2SH,WITNESS\",\n+    \"WITNESS_PROGRAM_MISMATCH\",\n+    \"P2WPKH with witness program mismatch\"\n+],\n+[\n+    [\n+        \"304402201a96950593cb0af32d080b0f193517f4559241a8ebd1e95e414533ad64a3f423022047f4f6d3095c23235bdff3aeff480d0529c027a3f093cb265b7cbf148553b85101\",\n+        \"0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8\"\n+    ],\n+    \"11\",\n+    \"0 0x14 0x91b24bf9f5288532960ac687abb035127b1d28a5\",\n+    \"P2SH,WITNESS\",\n+    \"WITNESS_MALLEATED\",\n+    \"P2WPKH with non-empty scriptSig\"\n+],\n+[\n+    [\n+        \"304402204209e49457c2358f80d0256bc24535b8754c14d08840fc4be762d6f5a0aed80b02202eaf7d8fc8d62f60c67adcd99295528d0e491ae93c195cec5a67e7a09532a88001\",\n+        \"048282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f5150811f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf\"\n+    ],\n+    \"11 0x16 0x00147cf9c846cd4882efec4bf07e44ebdad495c94f4b\",\n+    \"HASH160 0x14 0x4e0c2aed91315303fc6a1dc4c7bc21c88f75402e EQUAL\",\n+    \"P2SH,WITNESS\",\n+    \"WITNESS_MALLEATED_P2SH\",\n+    \"P2SH(P2WPKH) with superfluous push in scriptSig\"\n+],\n+[\n+    [\n+        \"\"\n+    ],\n+    \"0x47 0x304402200a5c6163f07b8d3b013c4d1d6dba25e780b39658d79ba37af7057a3b7f15ffa102201fd9b4eaa9943f734928b99a83592c2e7bf342ea2680f6a2bb705167966b742001\",\n+    \"0x41 0x0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8 CHECKSIG\",\n+    \"P2SH,WITNESS\",\n+    \"WITNESS_UNEXPECTED\",\n+    \"P2PK with witness\"\n+],\n \n [\"CHECKSEQUENCEVERIFY tests\"], \n [\"\", \"NOP3\", \"CHECKSEQUENCEVERIFY\", \"INVALID_STACK_OPERATION\", \"CSV automatically fails on a empty stack\"],"
      },
      {
        "sha": "1497bde9d15509a40839fb495949c8bf061a89f3",
        "filename": "src/test/script_tests.cpp",
        "status": "modified",
        "additions": 44,
        "deletions": 3,
        "changes": 47,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/330b0f31ee5719d94f9e52dfc83c5d82168241f9/src/test/script_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/330b0f31ee5719d94f9e52dfc83c5d82168241f9/src/test/script_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_tests.cpp?ref=330b0f31ee5719d94f9e52dfc83c5d82168241f9",
        "patch": "@@ -293,19 +293,19 @@ class TestBuilder\n     }\n \n public:\n-    TestBuilder(const CScript& script_, const std::string& comment_, int flags_, bool P2SH = false, WitnessMode wm = WITNESS_NONE) : script(script_), havePush(false), comment(comment_), flags(flags_), scriptError(SCRIPT_ERR_OK)\n+    TestBuilder(const CScript& script_, const std::string& comment_, int flags_, bool P2SH = false, WitnessMode wm = WITNESS_NONE, int witnessversion = 0) : script(script_), havePush(false), comment(comment_), flags(flags_), scriptError(SCRIPT_ERR_OK)\n     {\n         CScript scriptPubKey = script;\n         if (wm == WITNESS_PKH) {\n             uint160 hash;\n             CHash160().Write(&script[1], script.size() - 1).Finalize(hash.begin());\n             script = CScript() << OP_DUP << OP_HASH160 << ToByteVector(hash) << OP_EQUALVERIFY << OP_CHECKSIG;\n-            scriptPubKey = CScript() << OP_0 << ToByteVector(hash);\n+            scriptPubKey = CScript() << witnessversion << ToByteVector(hash);\n         } else if (wm == WITNESS_SH) {\n             witscript = scriptPubKey;\n             uint256 hash;\n             CSHA256().Write(&witscript[0], witscript.size()).Finalize(hash.begin());\n-            scriptPubKey = CScript() << OP_0 << ToByteVector(hash);\n+            scriptPubKey = CScript() << witnessversion << ToByteVector(hash);\n         }\n         if (P2SH) {\n             redeemscript = scriptPubKey;\n@@ -341,6 +341,11 @@ class TestBuilder\n         return *this;\n     }\n \n+    TestBuilder& Push(const CScript& script) {\n+         DoPush(std::vector<unsigned char>(script.begin(), script.end()));\n+        return *this;\n+    }\n+\n     TestBuilder& PushSig(const CKey& key, int nHashType = SIGHASH_ALL, unsigned int lenR = 32, unsigned int lenS = 32, SigVersion sigversion = SIGVERSION_BASE)\n     {\n         uint256 hash = SignatureHash(script, spendTx, 0, nHashType, 0, sigversion);\n@@ -765,6 +770,42 @@ BOOST_AUTO_TEST_CASE(script_build)\n                                 \"Basic P2SH(P2WPKH) with the wrong key but no WITNESS\", SCRIPT_VERIFY_P2SH, true, WITNESS_PKH\n                                ).PushWitSig(keys.key0).Push(keys.pubkey1).AsWit().PushRedeem());\n \n+    tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0),\n+                                \"P2WPKH with future witness version\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH |\n+                                SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM, false, WITNESS_PKH, 1\n+                               ).PushWitSig(keys.key0).Push(keys.pubkey0).AsWit().ScriptError(SCRIPT_ERR_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM));\n+    {\n+        CScript witscript = CScript() << ToByteVector(keys.pubkey0);\n+        uint256 hash;\n+        CSHA256().Write(&witscript[0], witscript.size()).Finalize(hash.begin());\n+        vector<unsigned char> hashBytes = ToByteVector(hash);\n+        hashBytes.pop_back();\n+        tests.push_back(TestBuilder(CScript() << OP_0 << hashBytes,\n+                                    \"P2WPKH with wrong witness program length\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false\n+                                   ).PushWitSig(keys.key0).Push(keys.pubkey0).AsWit().ScriptError(SCRIPT_ERR_WITNESS_PROGRAM_WRONG_LENGTH));\n+    }\n+    tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0) << OP_CHECKSIG,\n+                                \"P2WSH with empty witness\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_SH\n+                               ).ScriptError(SCRIPT_ERR_WITNESS_PROGRAM_WITNESS_EMPTY));\n+    {\n+        CScript witscript = CScript() << ToByteVector(keys.pubkey0) << OP_CHECKSIG;\n+        tests.push_back(TestBuilder(witscript,\n+                                    \"P2WSH with witness program mismatch\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_SH\n+                                   ).PushWitSig(keys.key0).Push(witscript).DamagePush(0).AsWit().ScriptError(SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH));\n+    }\n+    tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0),\n+                                \"P2WPKH with witness program mismatch\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_PKH\n+                               ).PushWitSig(keys.key0).Push(keys.pubkey0).AsWit().Push(\"0\").AsWit().ScriptError(SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH));\n+    tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0),\n+                                \"P2WPKH with non-empty scriptSig\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_PKH\n+                               ).PushWitSig(keys.key0).Push(keys.pubkey0).AsWit().Num(11).ScriptError(SCRIPT_ERR_WITNESS_MALLEATED));\n+    tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1),\n+                                \"P2SH(P2WPKH) with superfluous push in scriptSig\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WITNESS_PKH\n+                               ).PushWitSig(keys.key0).Push(keys.pubkey1).AsWit().Num(11).PushRedeem().ScriptError(SCRIPT_ERR_WITNESS_MALLEATED_P2SH));\n+    tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0) << OP_CHECKSIG,\n+                                \"P2PK with witness\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH\n+                               ).PushSig(keys.key0).Push(\"0\").AsWit().ScriptError(SCRIPT_ERR_WITNESS_UNEXPECTED));\n+\n     std::set<std::string> tests_set;\n \n     {"
      }
    ]
  },
  {
    "sha": "d846e0237256a4105199673d2eb90ed1dbb55b35",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkODQ2ZTAyMzcyNTZhNDEwNTE5OTY3M2QyZWI5MGVkMWRiYjU1YjM1",
    "commit": {
      "author": {
        "name": "Suhas Daftuar",
        "email": "sdaftuar@chaincode.com",
        "date": "2016-05-22T11:35:43Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-06-22T13:43:02Z"
      },
      "message": "[qa] script_tests: witness tests can specify tx amount\n\nAdd tests that witness signatures cover value",
      "tree": {
        "sha": "69aa2f709eeeccaec5b4ba52b91ba1aa049e0e26",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/69aa2f709eeeccaec5b4ba52b91ba1aa049e0e26"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d846e0237256a4105199673d2eb90ed1dbb55b35",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d846e0237256a4105199673d2eb90ed1dbb55b35",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d846e0237256a4105199673d2eb90ed1dbb55b35",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d846e0237256a4105199673d2eb90ed1dbb55b35/comments",
    "author": {
      "login": "sdaftuar",
      "id": 7463573,
      "node_id": "MDQ6VXNlcjc0NjM1NzM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sdaftuar",
      "html_url": "https://github.com/sdaftuar",
      "followers_url": "https://api.github.com/users/sdaftuar/followers",
      "following_url": "https://api.github.com/users/sdaftuar/following{/other_user}",
      "gists_url": "https://api.github.com/users/sdaftuar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
      "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
      "repos_url": "https://api.github.com/users/sdaftuar/repos",
      "events_url": "https://api.github.com/users/sdaftuar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "330b0f31ee5719d94f9e52dfc83c5d82168241f9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/330b0f31ee5719d94f9e52dfc83c5d82168241f9",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/330b0f31ee5719d94f9e52dfc83c5d82168241f9"
      }
    ],
    "stats": {
      "total": 191,
      "additions": 140,
      "deletions": 51
    },
    "files": [
      {
        "sha": "9b81e0c77ddf7af025580242a8f3087008879879",
        "filename": "src/test/data/script_tests.json",
        "status": "modified",
        "additions": 95,
        "deletions": 28,
        "changes": 123,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d846e0237256a4105199673d2eb90ed1dbb55b35/src/test/data/script_tests.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d846e0237256a4105199673d2eb90ed1dbb55b35/src/test/data/script_tests.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/data/script_tests.json?ref=d846e0237256a4105199673d2eb90ed1dbb55b35",
        "patch": "@@ -1,5 +1,5 @@\n [\n-[\"Format is: [[wit...]?, scriptSig, scriptPubKey, flags, expected_scripterror, ... comments]\"],\n+[\"Format is: [[wit..., amount]?, scriptSig, scriptPubKey, flags, expected_scripterror, ... comments]\"],\n [\"It is evaluated as if there was a crediting coinbase transaction with two 0\"],\n [\"pushes as scriptSig, and one output of 0 satoshi and given scriptPubKey,\"],\n [\"followed by a spending transaction which spends this output as only input (and\"],\n@@ -1254,10 +1254,10 @@\n [\"0x27 0x302402107777777777777777777777777777777702108777777777777777777777777777777701\", \"0 CHECKSIG NOT\", \"DERSIG\", \"SIG_DER\", \"Negative S is incorrectly encoded for DERSIG\"],\n \n [\"Some basic segwit checks\"],\n-[[\"00\"], \"\", \"0 0x206e340b9cffb37a989ca544e6bb780a2c78901d3fb33738768511a30617afa01d\", \"P2SH,WITNESS\", \"EVAL_FALSE\", \"Invalid witness script\"],\n-[[\"51\"], \"\", \"0 0x206e340b9cffb37a989ca544e6bb780a2c78901d3fb33738768511a30617afa01d\", \"P2SH,WITNESS\", \"WITNESS_PROGRAM_MISMATCH\", \"Witness script hash mismatch\"],\n-[[\"00\"], \"\", \"0 0x206e340b9cffb37a989ca544e6bb780a2c78901d3fb33738768511a30617afa01d\", \"\", \"OK\", \"Invalid witness script without WITNESS\"],\n-[[\"51\"], \"\", \"0 0x206e340b9cffb37a989ca544e6bb780a2c78901d3fb33738768511a30617afa01d\", \"\", \"OK\", \"Witness script hash mismatch without WITNESS\"],\n+[[\"00\", 0.00000000 ], \"\", \"0 0x206e340b9cffb37a989ca544e6bb780a2c78901d3fb33738768511a30617afa01d\", \"P2SH,WITNESS\", \"EVAL_FALSE\", \"Invalid witness script\"],\n+[[\"51\", 0.00000000 ], \"\", \"0 0x206e340b9cffb37a989ca544e6bb780a2c78901d3fb33738768511a30617afa01d\", \"P2SH,WITNESS\", \"WITNESS_PROGRAM_MISMATCH\", \"Witness script hash mismatch\"],\n+[[\"00\", 0.00000000 ], \"\", \"0 0x206e340b9cffb37a989ca544e6bb780a2c78901d3fb33738768511a30617afa01d\", \"\", \"OK\", \"Invalid witness script without WITNESS\"],\n+[[\"51\", 0.00000000 ], \"\", \"0 0x206e340b9cffb37a989ca544e6bb780a2c78901d3fb33738768511a30617afa01d\", \"\", \"OK\", \"Witness script hash mismatch without WITNESS\"],\n \n [\"Automatically generated test cases\"],\n [\n@@ -1836,8 +1836,9 @@\n ],\n [\n     [\n-        \"3044022039105b995a5f448639a997a5c90fda06f50b49df30c3bdb6663217bf79323db002206fecd54269dec569fcc517178880eb58bb40f381a282bb75766ff3637d5f4b4301\",\n-        \"410479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8ac\"\n+        \"304402200d461c140cfdfcf36b94961db57ae8c18d1cb80e9d95a9e47ac22470c1bf125502201c8dc1cbfef6a3ef90acbbb992ca22fe9466ee6f9d4898eda277a7ac3ab4b25101\",\n+        \"410479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8ac\",\n+        0.00000001\n     ],\n     \"\",\n     \"0 0x20 0xb95237b48faaa69eb078e1170be3b5cbb3fddf16d0a991e14ad274f7b33a4f64\",\n@@ -1847,8 +1848,9 @@\n ],\n [\n     [\n-        \"304402201a96950593cb0af32d080b0f193517f4559241a8ebd1e95e414533ad64a3f423022047f4f6d3095c23235bdff3aeff480d0529c027a3f093cb265b7cbf148553b85101\",\n-        \"0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8\"\n+        \"304402201e7216e5ccb3b61d46946ec6cc7e8c4e0117d13ac2fd4b152197e4805191c74202203e9903e33e84d9ee1dd13fb057afb7ccfb47006c23f6a067185efbc9dd780fc501\",\n+        \"0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8\",\n+        0.00000001\n     ],\n     \"\",\n     \"0 0x14 0x91b24bf9f5288532960ac687abb035127b1d28a5\",\n@@ -1858,8 +1860,9 @@\n ],\n [\n     [\n-        \"3044022061fc1a144e221ec77a58a4281936eb6a1b715b9349e446e74d106ec26c8633ba022008064a0d112e8ad514440fcdfaa1006e48305d6844f50a65873fb4b2cf9c035f01\",\n-        \"410479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8ac\"\n+        \"3044022066e02c19a513049d49349cf5311a1b012b7c4fae023795a18ab1d91c23496c22022025e216342c8e07ce8ef51e8daee88f84306a9de66236cab230bb63067ded1ad301\",\n+        \"410479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8ac\",\n+        0.00000001\n     ],\n     \"0x22 0x0020b95237b48faaa69eb078e1170be3b5cbb3fddf16d0a991e14ad274f7b33a4f64\",\n     \"HASH160 0x14 0xf386c2ba255cc56d20cfa6ea8b062f8b59945518 EQUAL\",\n@@ -1869,8 +1872,9 @@\n ],\n [\n     [\n-        \"3044022014e69768e174972f21d32d93002ca6fc26133cb9e819ceef7efb970798bde7b4022078b86849dbbec692ec9355aa2a763fce7ea11bf72fdd8ea5ea8083de6f8a77fe01\",\n-        \"0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8\"\n+        \"304402200929d11561cd958460371200f82e9cae64c727a495715a31828e27a7ad57b36d0220361732ced04a6f97351ecca21a56d0b8cd4932c1da1f8f569a2b68e5e48aed7801\",\n+        \"0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8\",\n+        0.00000001\n     ],\n     \"0x16 0x001491b24bf9f5288532960ac687abb035127b1d28a5\",\n     \"HASH160 0x14 0x17743beb429c55c942d2ec703b98c4d57c2df5c6 EQUAL\",\n@@ -1881,7 +1885,8 @@\n [\n     [\n         \"304402202589f0512cb2408fb08ed9bd24f85eb3059744d9e4f2262d0b7f1338cff6e8b902206c0978f449693e0578c71bc543b11079fd0baae700ee5e9a6bee94db490af9fc01\",\n-        \"41048282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f5150811f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26cafac\"\n+        \"41048282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f5150811f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26cafac\",\n+        0.00000000\n     ],\n     \"\",\n     \"0 0x20 0xac8ebd9e52c17619a381fa4f71aebb696087c6ef17c960fd0587addad99c0610\",\n@@ -1892,7 +1897,8 @@\n [\n     [\n         \"304402206ef7fdb2986325d37c6eb1a8bb24aeb46dede112ed8fc76c7d7500b9b83c0d3d02201edc2322c794fe2d6b0bd73ed319e714aa9b86d8891961530d5c9b7156b60d4e01\",\n-        \"048282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f5150811f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf\"\n+        \"048282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f5150811f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf\",\n+        0.00000000\n     ],\n     \"\",\n     \"0 0x14 0x7cf9c846cd4882efec4bf07e44ebdad495c94f4b\",\n@@ -1903,7 +1909,8 @@\n [\n     [\n         \"30440220069ea3581afaf8187f63feee1fd2bd1f9c0dc71ea7d6e8a8b07ee2ebcf824bf402201a4fdef4c532eae59223be1eda6a397fc835142d4ddc6c74f4aa85b766a5c16f01\",\n-        \"41048282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f5150811f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26cafac\"\n+        \"41048282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f5150811f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26cafac\",\n+        0.00000000\n     ],\n     \"0x22 0x0020ac8ebd9e52c17619a381fa4f71aebb696087c6ef17c960fd0587addad99c0610\",\n     \"HASH160 0x14 0x61039a003883787c0d6ebc66d97fdabe8e31449d EQUAL\",\n@@ -1914,7 +1921,8 @@\n [\n     [\n         \"304402204209e49457c2358f80d0256bc24535b8754c14d08840fc4be762d6f5a0aed80b02202eaf7d8fc8d62f60c67adcd99295528d0e491ae93c195cec5a67e7a09532a88001\",\n-        \"048282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f5150811f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf\"\n+        \"048282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f5150811f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf\",\n+        0.00000000\n     ],\n     \"0x16 0x00147cf9c846cd4882efec4bf07e44ebdad495c94f4b\",\n     \"HASH160 0x14 0x4e0c2aed91315303fc6a1dc4c7bc21c88f75402e EQUAL\",\n@@ -1925,7 +1933,8 @@\n [\n     [\n         \"304402202589f0512cb2408fb08ed9bd24f85eb3059744d9e4f2262d0b7f1338cff6e8b902206c0978f449693e0578c71bc543b11079fd0baae700ee5e9a6bee94db490af9fc01\",\n-        \"41048282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f5150811f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26cafac\"\n+        \"41048282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f5150811f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26cafac\",\n+        0.00000000\n     ],\n     \"\",\n     \"0 0x20 0xac8ebd9e52c17619a381fa4f71aebb696087c6ef17c960fd0587addad99c0610\",\n@@ -1936,7 +1945,8 @@\n [\n     [\n         \"304402206ef7fdb2986325d37c6eb1a8bb24aeb46dede112ed8fc76c7d7500b9b83c0d3d02201edc2322c794fe2d6b0bd73ed319e714aa9b86d8891961530d5c9b7156b60d4e01\",\n-        \"048282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f5150811f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf\"\n+        \"048282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f5150811f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf\",\n+        0.00000000\n     ],\n     \"\",\n     \"0 0x14 0x7cf9c846cd4882efec4bf07e44ebdad495c94f4b\",\n@@ -1947,7 +1957,8 @@\n [\n     [\n         \"30440220069ea3581afaf8187f63feee1fd2bd1f9c0dc71ea7d6e8a8b07ee2ebcf824bf402201a4fdef4c532eae59223be1eda6a397fc835142d4ddc6c74f4aa85b766a5c16f01\",\n-        \"41048282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f5150811f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26cafac\"\n+        \"41048282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f5150811f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26cafac\",\n+        0.00000000\n     ],\n     \"0x22 0x0020ac8ebd9e52c17619a381fa4f71aebb696087c6ef17c960fd0587addad99c0610\",\n     \"HASH160 0x14 0x61039a003883787c0d6ebc66d97fdabe8e31449d EQUAL\",\n@@ -1958,18 +1969,68 @@\n [\n     [\n         \"304402204209e49457c2358f80d0256bc24535b8754c14d08840fc4be762d6f5a0aed80b02202eaf7d8fc8d62f60c67adcd99295528d0e491ae93c195cec5a67e7a09532a88001\",\n-        \"048282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f5150811f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf\"\n+        \"048282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f5150811f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf\",\n+        0.00000000\n     ],\n     \"0x16 0x00147cf9c846cd4882efec4bf07e44ebdad495c94f4b\",\n     \"HASH160 0x14 0x4e0c2aed91315303fc6a1dc4c7bc21c88f75402e EQUAL\",\n     \"P2SH\",\n     \"OK\",\n     \"Basic P2SH(P2WPKH) with the wrong key but no WITNESS\"\n ],\n+[\n+    [\n+        \"3044022066faa86e74e8b30e82691b985b373de4f9e26dc144ec399c4f066aa59308e7c202204712b86f28c32503faa051dbeabff2c238ece861abc36c5e0b40b1139ca222f001\",\n+        \"410479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8ac\",\n+        0.00000000\n+    ],\n+    \"\",\n+    \"0 0x20 0xb95237b48faaa69eb078e1170be3b5cbb3fddf16d0a991e14ad274f7b33a4f64\",\n+    \"P2SH,WITNESS\",\n+    \"EVAL_FALSE\",\n+    \"Basic P2WSH with wrong value\"\n+],\n+[\n+    [\n+        \"304402203b3389b87448d7dfdb5e82fb854fcf92d7925f9938ea5444e36abef02c3d6a9602202410bc3265049abb07fd2e252c65ab7034d95c9d5acccabe9fadbdc63a52712601\",\n+        \"0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8\",\n+        0.00000000\n+    ],\n+    \"\",\n+    \"0 0x14 0x91b24bf9f5288532960ac687abb035127b1d28a5\",\n+    \"P2SH,WITNESS\",\n+    \"EVAL_FALSE\",\n+    \"Basic P2WPKH with wrong value\"\n+],\n+[\n+    [\n+        \"3044022000a30c4cfc10e4387be528613575434826ad3c15587475e0df8ce3b1746aa210022008149265e4f8e9dafe1f3ea50d90cb425e9e40ea7ebdd383069a7cfa2b77004701\",\n+        \"410479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8ac\",\n+        0.00000000\n+    ],\n+    \"0x22 0x0020b95237b48faaa69eb078e1170be3b5cbb3fddf16d0a991e14ad274f7b33a4f64\",\n+    \"HASH160 0x14 0xf386c2ba255cc56d20cfa6ea8b062f8b59945518 EQUAL\",\n+    \"P2SH,WITNESS\",\n+    \"EVAL_FALSE\",\n+    \"Basic P2SH(P2WSH) with wrong value\"\n+],\n+[\n+    [\n+        \"304402204fc3a2cd61a47913f2a5f9107d0ad4a504c7b31ee2d6b3b2f38c2b10ee031e940220055d58b7c3c281aaa381d8f486ac0f3e361939acfd568046cb6a311cdfa974cf01\",\n+        \"0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8\",\n+        0.00000000\n+    ],\n+    \"0x16 0x001491b24bf9f5288532960ac687abb035127b1d28a5\",\n+    \"HASH160 0x14 0x17743beb429c55c942d2ec703b98c4d57c2df5c6 EQUAL\",\n+    \"P2SH,WITNESS\",\n+    \"EVAL_FALSE\",\n+    \"Basic P2SH(P2WPKH) with wrong value\"\n+],\n [\n     [\n         \"304402205ae57ae0534c05ca9981c8a6cdf353b505eaacb7375f96681a2d1a4ba6f02f84022056248e68643b7d8ce7c7d128c9f1f348bcab8be15d094ad5cadd24251a28df8001\",\n-        \"0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8\"\n+        \"0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8\",\n+        0.00000000\n     ],\n     \"\",\n     \"1 0x14 0x91b24bf9f5288532960ac687abb035127b1d28a5\",\n@@ -1980,7 +2041,8 @@\n [\n     [\n         \"3044022064100ca0e2a33332136775a86cd83d0230e58b9aebb889c5ac952abff79a46ef02205f1bf900e022039ad3091bdaf27ac2aef3eae9ed9f190d821d3e508405b9513101\",\n-        \"0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8\"\n+        \"0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8\",\n+        0.00000000\n     ],\n     \"\",\n     \"0 0x1f 0xb34b78da162751647974d5cb7410aa428ad339dbf7d1e16e833f68a0cbf1c3\",\n@@ -1998,7 +2060,8 @@\n [\n     [\n         \"3044022039105b995a5f448639a997a5c90fda06f50b49df30c3bdb6663217bf79323db002206fecd54269dec569fcc517178880eb58bb40f381a282bb75766ff3637d5f4b4301\",\n-        \"400479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8ac\"\n+        \"400479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8ac\",\n+        0.00000000\n     ],\n     \"\",\n     \"0 0x20 0xb95237b48faaa69eb078e1170be3b5cbb3fddf16d0a991e14ad274f7b33a4f64\",\n@@ -2010,7 +2073,8 @@\n     [\n         \"304402201a96950593cb0af32d080b0f193517f4559241a8ebd1e95e414533ad64a3f423022047f4f6d3095c23235bdff3aeff480d0529c027a3f093cb265b7cbf148553b85101\",\n         \"0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8\",\n-        \"\"\n+        \"\",\n+        0.00000000\n     ],\n     \"\",\n     \"0 0x14 0x91b24bf9f5288532960ac687abb035127b1d28a5\",\n@@ -2021,7 +2085,8 @@\n [\n     [\n         \"304402201a96950593cb0af32d080b0f193517f4559241a8ebd1e95e414533ad64a3f423022047f4f6d3095c23235bdff3aeff480d0529c027a3f093cb265b7cbf148553b85101\",\n-        \"0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8\"\n+        \"0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8\",\n+        0.00000000\n     ],\n     \"11\",\n     \"0 0x14 0x91b24bf9f5288532960ac687abb035127b1d28a5\",\n@@ -2032,7 +2097,8 @@\n [\n     [\n         \"304402204209e49457c2358f80d0256bc24535b8754c14d08840fc4be762d6f5a0aed80b02202eaf7d8fc8d62f60c67adcd99295528d0e491ae93c195cec5a67e7a09532a88001\",\n-        \"048282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f5150811f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf\"\n+        \"048282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f5150811f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf\",\n+        0.00000000\n     ],\n     \"11 0x16 0x00147cf9c846cd4882efec4bf07e44ebdad495c94f4b\",\n     \"HASH160 0x14 0x4e0c2aed91315303fc6a1dc4c7bc21c88f75402e EQUAL\",\n@@ -2042,7 +2108,8 @@\n ],\n [\n     [\n-        \"\"\n+        \"\",\n+        0.00000000\n     ],\n     \"0x47 0x304402200a5c6163f07b8d3b013c4d1d6dba25e780b39658d79ba37af7057a3b7f15ffa102201fd9b4eaa9943f734928b99a83592c2e7bf342ea2680f6a2bb705167966b742001\",\n     \"0x41 0x0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8 CHECKSIG\","
      },
      {
        "sha": "5a9aaf9bc0738b493347fd4cf471d555d6a28423",
        "filename": "src/test/script_tests.cpp",
        "status": "modified",
        "additions": 45,
        "deletions": 23,
        "changes": 68,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d846e0237256a4105199673d2eb90ed1dbb55b35/src/test/script_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d846e0237256a4105199673d2eb90ed1dbb55b35/src/test/script_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_tests.cpp?ref=d846e0237256a4105199673d2eb90ed1dbb55b35",
        "patch": "@@ -13,6 +13,7 @@\n #include \"util.h\"\n #include \"utilstrencodings.h\"\n #include \"test/test_bitcoin.h\"\n+#include \"rpc/server.h\"\n \n #if defined(HAVE_CONSENSUS_LIB)\n #include \"script/bitcoinconsensus.h\"\n@@ -118,7 +119,7 @@ ScriptError_t ParseScriptError(const std::string &name)\n \n BOOST_FIXTURE_TEST_SUITE(script_tests, BasicTestingSetup)\n \n-CMutableTransaction BuildCreditingTransaction(const CScript& scriptPubKey)\n+CMutableTransaction BuildCreditingTransaction(const CScript& scriptPubKey, int nValue = 0)\n {\n     CMutableTransaction txCredit;\n     txCredit.nVersion = 1;\n@@ -129,7 +130,7 @@ CMutableTransaction BuildCreditingTransaction(const CScript& scriptPubKey)\n     txCredit.vin[0].scriptSig = CScript() << CScriptNum(0) << CScriptNum(0);\n     txCredit.vin[0].nSequence = CTxIn::SEQUENCE_FINAL;\n     txCredit.vout[0].scriptPubKey = scriptPubKey;\n-    txCredit.vout[0].nValue = 0;\n+    txCredit.vout[0].nValue = nValue;\n \n     return txCredit;\n }\n@@ -148,20 +149,20 @@ CMutableTransaction BuildSpendingTransaction(const CScript& scriptSig, const CSc\n     txSpend.vin[0].scriptSig = scriptSig;\n     txSpend.vin[0].nSequence = CTxIn::SEQUENCE_FINAL;\n     txSpend.vout[0].scriptPubKey = CScript();\n-    txSpend.vout[0].nValue = 0;\n+    txSpend.vout[0].nValue = txCredit.vout[0].nValue;\n \n     return txSpend;\n }\n \n-void DoTest(const CScript& scriptPubKey, const CScript& scriptSig, const CScriptWitness& scriptWitness, int flags, const std::string& message, int scriptError)\n+void DoTest(const CScript& scriptPubKey, const CScript& scriptSig, const CScriptWitness& scriptWitness, int flags, const std::string& message, int scriptError, CAmount nValue = 0)\n {\n     bool expect = (scriptError == SCRIPT_ERR_OK);\n     if (flags & SCRIPT_VERIFY_CLEANSTACK) {\n         flags |= SCRIPT_VERIFY_P2SH;\n         flags |= SCRIPT_VERIFY_WITNESS;\n     }\n     ScriptError err;\n-    CMutableTransaction txCredit = BuildCreditingTransaction(scriptPubKey);\n+    CMutableTransaction txCredit = BuildCreditingTransaction(scriptPubKey, nValue);\n     CMutableTransaction tx = BuildSpendingTransaction(scriptSig, scriptWitness, txCredit);\n     CMutableTransaction tx2 = tx;\n     BOOST_CHECK_MESSAGE(VerifyScript(scriptSig, scriptPubKey, &scriptWitness, flags, MutableTransactionSignatureChecker(&tx, 0, txCredit.vout[0].nValue), &err) == expect, message);\n@@ -276,6 +277,7 @@ class TestBuilder\n     std::string comment;\n     int flags;\n     int scriptError;\n+    CAmount nValue;\n \n     void DoPush()\n     {\n@@ -293,7 +295,7 @@ class TestBuilder\n     }\n \n public:\n-    TestBuilder(const CScript& script_, const std::string& comment_, int flags_, bool P2SH = false, WitnessMode wm = WITNESS_NONE, int witnessversion = 0) : script(script_), havePush(false), comment(comment_), flags(flags_), scriptError(SCRIPT_ERR_OK)\n+    TestBuilder(const CScript& script_, const std::string& comment_, int flags_, bool P2SH = false, WitnessMode wm = WITNESS_NONE, int witnessversion = 0, CAmount nValue_ = 0) : script(script_), havePush(false), comment(comment_), flags(flags_), scriptError(SCRIPT_ERR_OK), nValue(nValue_)\n     {\n         CScript scriptPubKey = script;\n         if (wm == WITNESS_PKH) {\n@@ -311,7 +313,7 @@ class TestBuilder\n             redeemscript = scriptPubKey;\n             scriptPubKey = CScript() << OP_HASH160 << ToByteVector(CScriptID(redeemscript)) << OP_EQUAL;\n         }\n-        creditTx = BuildCreditingTransaction(scriptPubKey);\n+        creditTx = BuildCreditingTransaction(scriptPubKey, nValue);\n         spendTx = BuildSpendingTransaction(CScript(), CScriptWitness(), creditTx);\n     }\n \n@@ -346,9 +348,9 @@ class TestBuilder\n         return *this;\n     }\n \n-    TestBuilder& PushSig(const CKey& key, int nHashType = SIGHASH_ALL, unsigned int lenR = 32, unsigned int lenS = 32, SigVersion sigversion = SIGVERSION_BASE)\n+    TestBuilder& PushSig(const CKey& key, int nHashType = SIGHASH_ALL, unsigned int lenR = 32, unsigned int lenS = 32, SigVersion sigversion = SIGVERSION_BASE, CAmount amount = 0)\n     {\n-        uint256 hash = SignatureHash(script, spendTx, 0, nHashType, 0, sigversion);\n+        uint256 hash = SignatureHash(script, spendTx, 0, nHashType, amount, sigversion);\n         std::vector<unsigned char> vchSig, r, s;\n         uint32_t iter = 0;\n         do {\n@@ -364,9 +366,11 @@ class TestBuilder\n         return *this;\n     }\n \n-    TestBuilder& PushWitSig(const CKey& key, int nHashType = SIGHASH_ALL, unsigned int lenR = 32, unsigned int lenS = 32, SigVersion sigversion = SIGVERSION_WITNESS_V0)\n+    TestBuilder& PushWitSig(const CKey& key, CAmount amount = -1, int nHashType = SIGHASH_ALL, unsigned int lenR = 32, unsigned int lenS = 32, SigVersion sigversion = SIGVERSION_WITNESS_V0)\n     {\n-        return PushSig(key, nHashType, lenR, lenS, sigversion).AsWit();\n+        if (amount == -1)\n+            amount = nValue;\n+        return PushSig(key, nHashType, lenR, lenS, sigversion, amount).AsWit();\n     }\n \n     TestBuilder& Push(const CPubKey& pubkey)\n@@ -411,7 +415,7 @@ class TestBuilder\n     {\n         TestBuilder copy = *this; // Make a copy so we can rollback the push.\n         DoPush();\n-        DoTest(creditTx.vout[0].scriptPubKey, spendTx.vin[0].scriptSig, scriptWitness, flags, comment, scriptError);\n+        DoTest(creditTx.vout[0].scriptPubKey, spendTx.vin[0].scriptSig, scriptWitness, flags, comment, scriptError, nValue);\n         *this = copy;\n         return *this;\n     }\n@@ -433,6 +437,7 @@ class TestBuilder\n             for (unsigned i = 0; i < scriptWitness.stack.size(); i++) {\n                 wit.push_back(HexStr(scriptWitness.stack[i]));\n             }\n+            wit.push_back(ValueFromAmount(nValue));\n             array.push_back(wit);\n         }\n         array.push_back(FormatScript(spendTx.vin[0].scriptSig));\n@@ -734,17 +739,17 @@ BOOST_AUTO_TEST_CASE(script_build)\n                                ).PushSig(keys.key0).PushRedeem());\n \n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0) << OP_CHECKSIG,\n-                                \"Basic P2WSH\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_SH\n-                               ).PushWitSig(keys.key0).PushWitRedeem());\n+                                \"Basic P2WSH\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_SH,\n+                                0, 1).PushWitSig(keys.key0).PushWitRedeem());\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0),\n-                                \"Basic P2WPKH\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_PKH\n-                               ).PushWitSig(keys.key0).Push(keys.pubkey0).AsWit());\n+                                \"Basic P2WPKH\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_PKH,\n+                                0, 1).PushWitSig(keys.key0).Push(keys.pubkey0).AsWit());\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0) << OP_CHECKSIG,\n-                                \"Basic P2SH(P2WSH)\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WITNESS_SH\n-                               ).PushWitSig(keys.key0).PushWitRedeem().PushRedeem());\n+                                \"Basic P2SH(P2WSH)\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WITNESS_SH,\n+                                0, 1).PushWitSig(keys.key0).PushWitRedeem().PushRedeem());\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0),\n-                                \"Basic P2SH(P2WPKH)\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WITNESS_PKH\n-                               ).PushWitSig(keys.key0).Push(keys.pubkey0).AsWit().PushRedeem());\n+                                \"Basic P2SH(P2WPKH)\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WITNESS_PKH,\n+                                0, 1).PushWitSig(keys.key0).Push(keys.pubkey0).AsWit().PushRedeem());\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1) << OP_CHECKSIG,\n                                 \"Basic P2WSH with the wrong key\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_SH\n                                ).PushWitSig(keys.key0).PushWitRedeem().ScriptError(SCRIPT_ERR_EVAL_FALSE));\n@@ -769,6 +774,18 @@ BOOST_AUTO_TEST_CASE(script_build)\n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey1),\n                                 \"Basic P2SH(P2WPKH) with the wrong key but no WITNESS\", SCRIPT_VERIFY_P2SH, true, WITNESS_PKH\n                                ).PushWitSig(keys.key0).Push(keys.pubkey1).AsWit().PushRedeem());\n+    tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0) << OP_CHECKSIG,\n+                                \"Basic P2WSH with wrong value\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_SH,\n+                                0, 0).PushWitSig(keys.key0, 1).PushWitRedeem().ScriptError(SCRIPT_ERR_EVAL_FALSE));\n+    tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0),\n+                                \"Basic P2WPKH with wrong value\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false, WITNESS_PKH,\n+                                0, 0).PushWitSig(keys.key0, 1).Push(keys.pubkey0).AsWit().ScriptError(SCRIPT_ERR_EVAL_FALSE));\n+    tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0) << OP_CHECKSIG,\n+                                \"Basic P2SH(P2WSH) with wrong value\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WITNESS_SH,\n+                                0, 0).PushWitSig(keys.key0, 1).PushWitRedeem().PushRedeem().ScriptError(SCRIPT_ERR_EVAL_FALSE));\n+    tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0),\n+                                \"Basic P2SH(P2WPKH) with wrong value\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true, WITNESS_PKH,\n+                                0, 0).PushWitSig(keys.key0, 1).Push(keys.pubkey0).AsWit().PushRedeem().ScriptError(SCRIPT_ERR_EVAL_FALSE));\n \n     tests.push_back(TestBuilder(CScript() << ToByteVector(keys.pubkey0),\n                                 \"P2WPKH with future witness version\", SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH |\n@@ -841,20 +858,25 @@ BOOST_AUTO_TEST_CASE(script_json_test)\n {\n     // Read tests from test/data/script_tests.json\n     // Format is an array of arrays\n-    // Inner arrays are [ [\"wit\"...]?, \"scriptSig\", \"scriptPubKey\", \"flags\", \"expected_scripterror\" ]\n+    // Inner arrays are [ [\"wit\"..., nValue]?, \"scriptSig\", \"scriptPubKey\", \"flags\", \"expected_scripterror\" ]\n     // ... where scriptSig and scriptPubKey are stringified\n     // scripts.\n+    // If a witness is given, then the last value in the array should be the\n+    // amount (nValue) to use in the crediting tx\n     UniValue tests = read_json(std::string(json_tests::script_tests, json_tests::script_tests + sizeof(json_tests::script_tests)));\n \n     for (unsigned int idx = 0; idx < tests.size(); idx++) {\n         UniValue test = tests[idx];\n         string strTest = test.write();\n         CScriptWitness witness;\n+        CAmount nValue = 0;\n         unsigned int pos = 0;\n         if (test.size() > 0 && test[pos].isArray()) {\n-            for (unsigned int i = 0; i < test[pos].size(); i++) {\n+            unsigned int i=0;\n+            for (i = 0; i < test[pos].size()-1; i++) {\n                 witness.stack.push_back(ParseHex(test[pos][i].get_str()));\n             }\n+            nValue = AmountFromValue(test[pos][i]);\n             pos++;\n         }\n         if (test.size() < 4 + pos) // Allow size > 3; extra stuff ignored (useful for comments)\n@@ -871,7 +893,7 @@ BOOST_AUTO_TEST_CASE(script_json_test)\n         unsigned int scriptflags = ParseScriptFlags(test[pos++].get_str());\n         int scriptError = ParseScriptError(test[pos++].get_str());\n \n-        DoTest(scriptPubKey, scriptSig, witness, scriptflags, strTest, scriptError);\n+        DoTest(scriptPubKey, scriptSig, witness, scriptflags, strTest, scriptError, nValue);\n     }\n }\n "
      }
    ]
  },
  {
    "sha": "fdb43df23eb507d1c79b7ae9cc2e61c3e52c8988",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmZGI0M2RmMjNlYjUwN2QxYzc5YjdhZTljYzJlNjFjM2U1MmM4OTg4",
    "commit": {
      "author": {
        "name": "Jonas Nick",
        "email": "jonasd.nick@gmail.com",
        "date": "2016-05-28T17:22:13Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-06-22T13:43:02Z"
      },
      "message": "[qa] Add GetTransactionSigOpCost unit tests",
      "tree": {
        "sha": "990cfcd4b9bd765d300ff2b523f29017395e6c81",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/990cfcd4b9bd765d300ff2b523f29017395e6c81"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fdb43df23eb507d1c79b7ae9cc2e61c3e52c8988",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fdb43df23eb507d1c79b7ae9cc2e61c3e52c8988",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fdb43df23eb507d1c79b7ae9cc2e61c3e52c8988",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fdb43df23eb507d1c79b7ae9cc2e61c3e52c8988/comments",
    "author": {
      "login": "jonasnick",
      "id": 2582071,
      "node_id": "MDQ6VXNlcjI1ODIwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasnick",
      "html_url": "https://github.com/jonasnick",
      "followers_url": "https://api.github.com/users/jonasnick/followers",
      "following_url": "https://api.github.com/users/jonasnick/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasnick/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasnick/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasnick/orgs",
      "repos_url": "https://api.github.com/users/jonasnick/repos",
      "events_url": "https://api.github.com/users/jonasnick/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasnick/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d846e0237256a4105199673d2eb90ed1dbb55b35",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d846e0237256a4105199673d2eb90ed1dbb55b35",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d846e0237256a4105199673d2eb90ed1dbb55b35"
      }
    ],
    "stats": {
      "total": 185,
      "additions": 185,
      "deletions": 0
    },
    "files": [
      {
        "sha": "2ffe5770dccb031556cfb86d13053cf4c858a296",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fdb43df23eb507d1c79b7ae9cc2e61c3e52c8988/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fdb43df23eb507d1c79b7ae9cc2e61c3e52c8988/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=fdb43df23eb507d1c79b7ae9cc2e61c3e52c8988",
        "patch": "@@ -333,6 +333,14 @@ unsigned int GetLegacySigOpCount(const CTransaction& tx);\n  */\n unsigned int GetP2SHSigOpCount(const CTransaction& tx, const CCoinsViewCache& mapInputs);\n \n+/**\n+ * Compute total signature operation cost of a transaction.\n+ * @param[in] tx     Transaction for which we are computing the cost\n+ * @param[in] inputs Map of previous transactions that have outputs we're spending\n+ * @param[out] flags Script verification flags\n+ * @return Total signature operation cost of tx\n+ */\n+int64_t GetTransactionSigOpCost(const CTransaction& tx, const CCoinsViewCache& inputs, int flags);\n \n /**\n  * Check whether all inputs of this transaction are valid (no double spends, scripts & sigs, amounts)"
      },
      {
        "sha": "8dea388332b211c362393ec9e3a5c156baf40c42",
        "filename": "src/test/sigopcount_tests.cpp",
        "status": "modified",
        "additions": 177,
        "deletions": 0,
        "changes": 177,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fdb43df23eb507d1c79b7ae9cc2e61c3e52c8988/src/test/sigopcount_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fdb43df23eb507d1c79b7ae9cc2e61c3e52c8988/src/test/sigopcount_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/sigopcount_tests.cpp?ref=fdb43df23eb507d1c79b7ae9cc2e61c3e52c8988",
        "patch": "@@ -2,6 +2,7 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n+#include \"main.h\"\n #include \"pubkey.h\"\n #include \"key.h\"\n #include \"script/script.h\"\n@@ -64,4 +65,180 @@ BOOST_AUTO_TEST_CASE(GetSigOpCount)\n     BOOST_CHECK_EQUAL(p2sh.GetSigOpCount(scriptSig2), 3U);\n }\n \n+/**\n+ * Verifies script execution of the zeroth scriptPubKey of tx output and\n+ * zeroth scriptSig and witness of tx input.\n+ */\n+ScriptError VerifyWithFlag(const CTransaction& output, const CMutableTransaction& input, int flags)\n+{\n+    ScriptError error;\n+    CTransaction inputi(input);\n+    bool ret = VerifyScript(inputi.vin[0].scriptSig, output.vout[0].scriptPubKey, inputi.wit.vtxinwit.size() > 0 ? &inputi.wit.vtxinwit[0].scriptWitness : NULL, flags, TransactionSignatureChecker(&inputi, 0, output.vout[0].nValue), &error);\n+    BOOST_CHECK((ret == true) == (error == SCRIPT_ERR_OK));\n+\n+    return error;\n+}\n+\n+/**\n+ * Builds a creationTx from scriptPubKey and a spendingTx from scriptSig\n+ * and witness such that spendingTx spends output zero of creationTx.\n+ * Also inserts creationTx's output into the coins view.\n+ */\n+void BuildTxs(CMutableTransaction& spendingTx, CCoinsViewCache& coins, CMutableTransaction& creationTx, const CScript& scriptPubKey, const CScript& scriptSig, const CTxinWitness& witness)\n+{\n+    creationTx.nVersion = 1;\n+    creationTx.vin.resize(1);\n+    creationTx.vin[0].prevout.SetNull();\n+    creationTx.vin[0].scriptSig = CScript();\n+    creationTx.wit.vtxinwit.resize(1);\n+    creationTx.vout.resize(1);\n+    creationTx.vout[0].nValue = 1;\n+    creationTx.vout[0].scriptPubKey = scriptPubKey;\n+\n+    spendingTx.nVersion = 1;\n+    spendingTx.vin.resize(1);\n+    spendingTx.vin[0].prevout.hash = creationTx.GetHash();\n+    spendingTx.vin[0].prevout.n = 0;\n+    spendingTx.vin[0].scriptSig = scriptSig;\n+    spendingTx.wit.vtxinwit.resize(1);\n+    spendingTx.wit.vtxinwit[0] = witness;\n+    spendingTx.vout.resize(1);\n+    spendingTx.vout[0].nValue = 1;\n+    spendingTx.vout[0].scriptPubKey = CScript();\n+\n+    coins.ModifyCoins(creationTx.GetHash())->FromTx(creationTx, 0);\n+}\n+\n+BOOST_AUTO_TEST_CASE(GetTxSigOpCost)\n+{\n+    // Transaction creates outputs\n+    CMutableTransaction creationTx;\n+    // Transaction that spends outputs and whose\n+    // sig op cost is going to be tested\n+    CMutableTransaction spendingTx;\n+\n+    // Create utxo set\n+    CCoinsView coinsDummy;\n+    CCoinsViewCache coins(&coinsDummy);\n+    // Create key\n+    CKey key;\n+    key.MakeNewKey(true);\n+    CPubKey pubkey = key.GetPubKey();\n+    // Default flags\n+    int flags = SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH;\n+\n+    // Multisig script (legacy counting)\n+    {\n+        CScript scriptPubKey = CScript() << 1 << ToByteVector(pubkey) << ToByteVector(pubkey) << 2 << OP_CHECKMULTISIGVERIFY;\n+        // Do not use a valid signature to avoid using wallet operations.\n+        CScript scriptSig = CScript() << OP_0 << OP_0;\n+\n+        BuildTxs(spendingTx, coins, creationTx, scriptPubKey, scriptSig, CTxinWitness());\n+        // Legacy counting only includes signature operations in scriptSigs and scriptPubKeys\n+        // of a transaction and does not take the actual executed sig operations into account.\n+        // spendingTx in itself does not contain a signature operation.\n+        assert(GetTransactionSigOpCost(CTransaction(spendingTx), coins, flags) == 0);\n+        // creationTx contains two signature operations in its scriptPubKey, but legacy counting\n+        // is not accurate.\n+        assert(GetTransactionSigOpCost(CTransaction(creationTx), coins, flags) == MAX_PUBKEYS_PER_MULTISIG * WITNESS_SCALE_FACTOR);\n+        // Sanity check: script verification fails because of an invalid signature.\n+        assert(VerifyWithFlag(creationTx, spendingTx, flags) == SCRIPT_ERR_CHECKMULTISIGVERIFY);\n+    }\n+\n+    // Multisig nested in P2SH\n+    {\n+        CScript redeemScript = CScript() << 1 << ToByteVector(pubkey) << ToByteVector(pubkey) << 2 << OP_CHECKMULTISIGVERIFY;\n+        CScript scriptPubKey = GetScriptForDestination(CScriptID(redeemScript));\n+        CScript scriptSig = CScript() << OP_0 << OP_0 << ToByteVector(redeemScript);\n+\n+        BuildTxs(spendingTx, coins, creationTx, scriptPubKey, scriptSig, CTxinWitness());\n+        assert(GetTransactionSigOpCost(CTransaction(spendingTx), coins, flags) == 2 * WITNESS_SCALE_FACTOR);\n+        assert(VerifyWithFlag(creationTx, spendingTx, flags) == SCRIPT_ERR_CHECKMULTISIGVERIFY);\n+    }\n+\n+    // P2WPKH witness program\n+    {\n+        CScript p2pk = CScript() << ToByteVector(pubkey) << OP_CHECKSIG;\n+        CScript scriptPubKey = GetScriptForWitness(p2pk);\n+        CScript scriptSig = CScript();\n+        CTxinWitness witness;\n+        CScriptWitness scriptWitness;\n+        scriptWitness.stack.push_back(vector<unsigned char>(0));\n+        scriptWitness.stack.push_back(vector<unsigned char>(0));\n+        witness.scriptWitness = scriptWitness;\n+\n+\n+        BuildTxs(spendingTx, coins, creationTx, scriptPubKey, scriptSig, witness);\n+        assert(GetTransactionSigOpCost(CTransaction(spendingTx), coins, flags) == 1);\n+        // No signature operations if we don't verify the witness.\n+        assert(GetTransactionSigOpCost(CTransaction(spendingTx), coins, flags & ~SCRIPT_VERIFY_WITNESS) == 0);\n+        assert(VerifyWithFlag(creationTx, spendingTx, flags) == SCRIPT_ERR_EQUALVERIFY);\n+\n+        // The sig op cost for witness version != 0 is zero.\n+        assert(scriptPubKey[0] == 0x00);\n+        scriptPubKey[0] = 0x51;\n+        BuildTxs(spendingTx, coins, creationTx, scriptPubKey, scriptSig, witness);\n+        assert(GetTransactionSigOpCost(CTransaction(spendingTx), coins, flags) == 0);\n+        scriptPubKey[0] = 0x00;\n+        BuildTxs(spendingTx, coins, creationTx, scriptPubKey, scriptSig, witness);\n+\n+        // The witness of a coinbase transaction is not taken into account.\n+        spendingTx.vin[0].prevout.SetNull();\n+        assert(GetTransactionSigOpCost(CTransaction(spendingTx), coins, flags) == 0);\n+    }\n+\n+    // P2WPKH nested in P2SH\n+    {\n+        CScript p2pk = CScript() << ToByteVector(pubkey) << OP_CHECKSIG;\n+        CScript scriptSig = GetScriptForWitness(p2pk);\n+        CScript scriptPubKey = GetScriptForDestination(CScriptID(scriptSig));\n+        scriptSig = CScript() << ToByteVector(scriptSig);\n+        CTxinWitness witness;\n+        CScriptWitness scriptWitness;\n+        scriptWitness.stack.push_back(vector<unsigned char>(0));\n+        scriptWitness.stack.push_back(vector<unsigned char>(0));\n+        witness.scriptWitness = scriptWitness;\n+\n+        BuildTxs(spendingTx, coins, creationTx, scriptPubKey, scriptSig, witness);\n+        assert(GetTransactionSigOpCost(CTransaction(spendingTx), coins, flags) == 1);\n+        assert(VerifyWithFlag(creationTx, spendingTx, flags) == SCRIPT_ERR_EQUALVERIFY);\n+    }\n+\n+    // P2WSH witness program\n+    {\n+        CScript witnessScript = CScript() << 1 << ToByteVector(pubkey) << ToByteVector(pubkey) << 2 << OP_CHECKMULTISIGVERIFY;\n+        CScript scriptPubKey = GetScriptForWitness(witnessScript);\n+        CScript scriptSig = CScript();\n+        CTxinWitness witness;\n+        CScriptWitness scriptWitness;\n+        scriptWitness.stack.push_back(vector<unsigned char>(0));\n+        scriptWitness.stack.push_back(vector<unsigned char>(0));\n+        scriptWitness.stack.push_back(vector<unsigned char>(witnessScript.begin(), witnessScript.end()));\n+        witness.scriptWitness = scriptWitness;\n+\n+        BuildTxs(spendingTx, coins, creationTx, scriptPubKey, scriptSig, witness);\n+        assert(GetTransactionSigOpCost(CTransaction(spendingTx), coins, flags) == 2);\n+        assert(GetTransactionSigOpCost(CTransaction(spendingTx), coins, flags & ~SCRIPT_VERIFY_WITNESS) == 0);\n+        assert(VerifyWithFlag(creationTx, spendingTx, flags) == SCRIPT_ERR_CHECKMULTISIGVERIFY);\n+    }\n+\n+    // P2WSH nested in P2SH\n+    {\n+        CScript witnessScript = CScript() << 1 << ToByteVector(pubkey) << ToByteVector(pubkey) << 2 << OP_CHECKMULTISIGVERIFY;\n+        CScript redeemScript = GetScriptForWitness(witnessScript);\n+        CScript scriptPubKey = GetScriptForDestination(CScriptID(redeemScript));\n+        CScript scriptSig = CScript() << ToByteVector(redeemScript);\n+        CTxinWitness witness;\n+        CScriptWitness scriptWitness;\n+        scriptWitness.stack.push_back(vector<unsigned char>(0));\n+        scriptWitness.stack.push_back(vector<unsigned char>(0));\n+        scriptWitness.stack.push_back(vector<unsigned char>(witnessScript.begin(), witnessScript.end()));\n+        witness.scriptWitness = scriptWitness;\n+\n+        BuildTxs(spendingTx, coins, creationTx, scriptPubKey, scriptSig, witness);\n+        assert(GetTransactionSigOpCost(CTransaction(spendingTx), coins, flags) == 2);\n+        assert(VerifyWithFlag(creationTx, spendingTx, flags) == SCRIPT_ERR_CHECKMULTISIGVERIFY);\n+    }\n+}\n+\n BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  },
  {
    "sha": "070dbc48a9338375fd7ce0a86ee05b476cf487a4",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowNzBkYmM0OGE5MzM4Mzc1ZmQ3Y2UwYTg2ZWUwNWI0NzZjZjQ4N2E0",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-06-04T20:38:36Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-06-22T13:43:02Z"
      },
      "message": "--- [SEGWIT] begin: deployment ---",
      "tree": {
        "sha": "990cfcd4b9bd765d300ff2b523f29017395e6c81",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/990cfcd4b9bd765d300ff2b523f29017395e6c81"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/070dbc48a9338375fd7ce0a86ee05b476cf487a4",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/070dbc48a9338375fd7ce0a86ee05b476cf487a4",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/070dbc48a9338375fd7ce0a86ee05b476cf487a4",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/070dbc48a9338375fd7ce0a86ee05b476cf487a4/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fdb43df23eb507d1c79b7ae9cc2e61c3e52c8988",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fdb43df23eb507d1c79b7ae9cc2e61c3e52c8988",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fdb43df23eb507d1c79b7ae9cc2e61c3e52c8988"
      }
    ],
    "stats": {
      "total": 0,
      "additions": 0,
      "deletions": 0
    },
    "files": []
  },
  {
    "sha": "f8528134fc188abc5c7175a19680206964a8fade",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmODUyODEzNGZjMTg4YWJjNWM3MTc1YTE5NjgwMjA2OTY0YThmYWRl",
    "commit": {
      "author": {
        "name": "Johnson Lau",
        "email": "jl2012@users.noreply.github.com",
        "date": "2016-05-06T05:29:34Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-06-22T13:43:02Z"
      },
      "message": "BIP9 parameters for testnet",
      "tree": {
        "sha": "435e8d4b828e1bf3aced2b8f1799a315afdd05a5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/435e8d4b828e1bf3aced2b8f1799a315afdd05a5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f8528134fc188abc5c7175a19680206964a8fade",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f8528134fc188abc5c7175a19680206964a8fade",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f8528134fc188abc5c7175a19680206964a8fade",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f8528134fc188abc5c7175a19680206964a8fade/comments",
    "author": {
      "login": "jl2012",
      "id": 8403418,
      "node_id": "MDQ6VXNlcjg0MDM0MTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/8403418?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jl2012",
      "html_url": "https://github.com/jl2012",
      "followers_url": "https://api.github.com/users/jl2012/followers",
      "following_url": "https://api.github.com/users/jl2012/following{/other_user}",
      "gists_url": "https://api.github.com/users/jl2012/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jl2012/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jl2012/subscriptions",
      "organizations_url": "https://api.github.com/users/jl2012/orgs",
      "repos_url": "https://api.github.com/users/jl2012/repos",
      "events_url": "https://api.github.com/users/jl2012/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jl2012/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "070dbc48a9338375fd7ce0a86ee05b476cf487a4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/070dbc48a9338375fd7ce0a86ee05b476cf487a4",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/070dbc48a9338375fd7ce0a86ee05b476cf487a4"
      }
    ],
    "stats": {
      "total": 4,
      "additions": 2,
      "deletions": 2
    },
    "files": [
      {
        "sha": "69d4a9ecbeb6eb3a6144f6a16fd3d5ef29e6e23d",
        "filename": "src/chainparams.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f8528134fc188abc5c7175a19680206964a8fade/src/chainparams.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f8528134fc188abc5c7175a19680206964a8fade/src/chainparams.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparams.cpp?ref=f8528134fc188abc5c7175a19680206964a8fade",
        "patch": "@@ -190,8 +190,8 @@ class CTestNetParams : public CChainParams {\n \n         // Deployment of SegWit (BIP141 and BIP143)\n         consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].bit = 1;\n-        consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].nStartTime = 2000000000; // Far in the future\n-        consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].nTimeout = 2100000000;\n+        consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].nStartTime = 1462060800; // May 1st 2016\n+        consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].nTimeout = 1493596800; // May 1st 2017\n \n         pchMessageStart[0] = 0x0b;\n         pchMessageStart[1] = 0x11;"
      }
    ]
  }
]