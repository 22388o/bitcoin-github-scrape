[
  {
    "sha": "7f073594c9f5b518dc1fb66dfb0189e8803e3545",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3ZjA3MzU5NGM5ZjViNTE4ZGMxZmI2NmRmYjAxODllODgwM2UzNTQ1",
    "commit": {
      "author": {
        "name": "Jon Atack",
        "email": "jon@atack.com",
        "date": "2021-07-11T10:18:43Z"
      },
      "committer": {
        "name": "Jon Atack",
        "email": "jon@atack.com",
        "date": "2021-08-31T18:51:17Z"
      },
      "message": "Test src/node/transaction::GetTransaction() without -txindex",
      "tree": {
        "sha": "ef102320d229f1fe85ad92262f29931c970e9e67",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ef102320d229f1fe85ad92262f29931c970e9e67"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7f073594c9f5b518dc1fb66dfb0189e8803e3545",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEd6u7+MhX7zEv6RP5T1chs9Djkh0FAmEueiUACgkQT1chs9Dj\nkh1kjhAAu5TZNK3ryxukfDtEzD5t8m2eSsC14/z+jQmRWdskm+jJ/drvYZVrNYVZ\nwnbcgFqglyvZeKhsPV13D9LXzdDIpbdp2bWlx9qH+12TI5Mhds2S1vHzknONE6V/\nA5V1P7xq2i5LKmR1KEpbc4NRvuUPizZr8ex6y2D1VZmGaFmIOsJ2FhXjPRzJvV8l\nHSofSGUnXHWuB+DvhX/3CqaV6+loxLu6668EmQXUsJWZm4gK2SgemWW2A4koyBAf\nz9n0T+2+Tgh5tsnfH4QuVSUV1fdzbsFAeGmdiuiDQI1wrA72Xphlw2drnBOafW54\nzdxE992MAsXoZHemf8JwPDTYVMZlm8uzC2tPQxZAi3lKwHtXbmklIEC1xDF/tyWC\ng+3bZuE15bW2b8NkW9O7Ppsspa9Vo6K8z9kAdHxEcxMo9kV0ivcke1HiXs6S/OV+\ncFze1Y+gUXHNebHhA+4q69XOLvi4Tg5YpEOPtD6oWafrc0TMk5pAjIz2xRHiIIEn\n4yyn6/YUQUvMubUvFJcqzanSC/wKi9E+ysQDYlt3QGlOkTTHSpD4SjYNVQRsfQZG\n72cKaxWGrAhtuyqJFERhxae2lYx5xekjigooPc9wf74o/aU46NSEIcfSlIqs7C0W\nhHkqMCzi5idXaeTHflJUo6kSz1VSW2VMlO3sYqa/K4Gf7EX6cDs=\n=VTp2\n-----END PGP SIGNATURE-----\n-----BEGIN OPENTIMESTAMPS GIT TIMESTAMP-----\n\nAQHwIMAFqPNjXHztwIT9UdMeieOqIiqP1q13BqTwlXK8ZdlrCP/wEFkLjkn+EB7N\nczj93SpJQtsI8QRhLnon8Ai8GHwAWKHn5wCD3+MNLvkMjiwraHR0cHM6Ly9ib2Iu\nYnRjLmNhbGVuZGFyLm9wZW50aW1lc3RhbXBzLm9yZ//wELzlPxdOtDI7RdRpcWAW\nn/0I8QRhLnom8Ais+SunkjxnIQCD3+MNLvkMji4taHR0cHM6Ly9hbGljZS5idGMu\nY2FsZW5kYXIub3BlbnRpbWVzdGFtcHMub3Jn//AQxk5S4DQNB0EREIHlwSQeigjx\nBGEueifwCOEW9rhnRuuPAIPf4w0u+QyOKShodHRwczovL2Zpbm5leS5jYWxlbmRh\nci5ldGVybml0eXdhbGwuY29t8BDTCncpr+dbTgMfSmOKc2jqCPEEYS56J/AIIdgC\nngiBxYQAg9/jDS75DI4jImh0dHBzOi8vYnRjLmNhbGVuZGFyLmNhdGFsbGF4eS5j\nb20=\n-----END OPENTIMESTAMPS GIT TIMESTAMP-----",
        "payload": "tree ef102320d229f1fe85ad92262f29931c970e9e67\nparent db94d74f241410d6577b695d73184740797448e6\nauthor Jon Atack <jon@atack.com> 1625998723 +0200\ncommitter Jon Atack <jon@atack.com> 1630435877 +0200\n\nTest src/node/transaction::GetTransaction() without -txindex\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7f073594c9f5b518dc1fb66dfb0189e8803e3545",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7f073594c9f5b518dc1fb66dfb0189e8803e3545",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7f073594c9f5b518dc1fb66dfb0189e8803e3545/comments",
    "author": {
      "login": "jonatack",
      "id": 2415484,
      "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonatack",
      "html_url": "https://github.com/jonatack",
      "followers_url": "https://api.github.com/users/jonatack/followers",
      "following_url": "https://api.github.com/users/jonatack/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonatack/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
      "organizations_url": "https://api.github.com/users/jonatack/orgs",
      "repos_url": "https://api.github.com/users/jonatack/repos",
      "events_url": "https://api.github.com/users/jonatack/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonatack/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jonatack",
      "id": 2415484,
      "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonatack",
      "html_url": "https://github.com/jonatack",
      "followers_url": "https://api.github.com/users/jonatack/followers",
      "following_url": "https://api.github.com/users/jonatack/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonatack/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
      "organizations_url": "https://api.github.com/users/jonatack/orgs",
      "repos_url": "https://api.github.com/users/jonatack/repos",
      "events_url": "https://api.github.com/users/jonatack/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonatack/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "db94d74f241410d6577b695d73184740797448e6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/db94d74f241410d6577b695d73184740797448e6",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/db94d74f241410d6577b695d73184740797448e6"
      }
    ],
    "stats": {
      "total": 59,
      "additions": 36,
      "deletions": 23
    },
    "files": [
      {
        "sha": "4c3dcac04652adf2fb4daff579667e44601bd09f",
        "filename": "test/functional/rpc_rawtransaction.py",
        "status": "modified",
        "additions": 36,
        "deletions": 23,
        "changes": 59,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7f073594c9f5b518dc1fb66dfb0189e8803e3545/test/functional/rpc_rawtransaction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7f073594c9f5b518dc1fb66dfb0189e8803e3545/test/functional/rpc_rawtransaction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_rawtransaction.py?ref=7f073594c9f5b518dc1fb66dfb0189e8803e3545",
        "patch": "@@ -50,11 +50,12 @@ def items(self):\n class RawTransactionsTest(BitcoinTestFramework):\n     def set_test_params(self):\n         self.setup_clean_chain = True\n-        self.num_nodes = 3\n+        self.num_nodes = 4\n         self.extra_args = [\n             [\"-txindex\"],\n             [\"-txindex\"],\n             [\"-txindex\"],\n+            [],\n         ]\n         # whitelist all peers to speed up tx relay / mempool sync\n         for args in self.extra_args:\n@@ -226,28 +227,40 @@ def run_test(self):\n         tx = self.nodes[2].sendtoaddress(self.nodes[1].getnewaddress(), 1)\n         block1, block2 = self.nodes[2].generate(2)\n         self.sync_all()\n-        # We should be able to get the raw transaction by providing the correct block\n-        gottx = self.nodes[0].getrawtransaction(tx, True, block1)\n-        assert_equal(gottx['txid'], tx)\n-        assert_equal(gottx['in_active_chain'], True)\n-        # We should not have the 'in_active_chain' flag when we don't provide a block\n-        gottx = self.nodes[0].getrawtransaction(tx, True)\n-        assert_equal(gottx['txid'], tx)\n-        assert 'in_active_chain' not in gottx\n-        # We should not get the tx if we provide an unrelated block\n-        assert_raises_rpc_error(-5, \"No such transaction found\", self.nodes[0].getrawtransaction, tx, True, block2)\n-        # An invalid block hash should raise the correct errors\n-        assert_raises_rpc_error(-1, \"JSON value is not a string as expected\", self.nodes[0].getrawtransaction, tx, True, True)\n-        assert_raises_rpc_error(-8, \"parameter 3 must be of length 64 (not 6, for 'foobar')\", self.nodes[0].getrawtransaction, tx, True, \"foobar\")\n-        assert_raises_rpc_error(-8, \"parameter 3 must be of length 64 (not 8, for 'abcd1234')\", self.nodes[0].getrawtransaction, tx, True, \"abcd1234\")\n-        assert_raises_rpc_error(-8, \"parameter 3 must be hexadecimal string (not 'ZZZ0000000000000000000000000000000000000000000000000000000000000')\", self.nodes[0].getrawtransaction, tx, True, \"ZZZ0000000000000000000000000000000000000000000000000000000000000\")\n-        assert_raises_rpc_error(-5, \"Block hash not found\", self.nodes[0].getrawtransaction, tx, True, \"0000000000000000000000000000000000000000000000000000000000000000\")\n-        # Undo the blocks and check in_active_chain\n-        self.nodes[0].invalidateblock(block1)\n-        gottx = self.nodes[0].getrawtransaction(txid=tx, verbose=True, blockhash=block1)\n-        assert_equal(gottx['in_active_chain'], False)\n-        self.nodes[0].reconsiderblock(block1)\n-        assert_equal(self.nodes[0].getbestblockhash(), block2)\n+        for n in [0, 3]:\n+            self.log.info(f\"Test getrawtransaction {'with' if n == 0 else 'without'} -txindex, with blockhash\")\n+            # We should be able to get the raw transaction by providing the correct block\n+            gottx = self.nodes[n].getrawtransaction(txid=tx, verbose=True, blockhash=block1)\n+            assert_equal(gottx['txid'], tx)\n+            assert_equal(gottx['in_active_chain'], True)\n+            if n == 0:\n+                self.log.info(\"Test getrawtransaction with -txindex, without blockhash: 'in_active_chain' should be absent\")\n+                gottx = self.nodes[n].getrawtransaction(txid=tx, verbose=True)\n+                assert_equal(gottx['txid'], tx)\n+                assert 'in_active_chain' not in gottx\n+            else:\n+                self.log.info(\"Test getrawtransaction without -txindex, without blockhash: expect the call to raise\")\n+                err_msg = (\n+                    \"No such mempool transaction. Use -txindex or provide a block hash to enable\"\n+                    \" blockchain transaction queries. Use gettransaction for wallet transactions.\"\n+                )\n+                assert_raises_rpc_error(-5, err_msg, self.nodes[n].getrawtransaction, txid=tx, verbose=True)\n+            # We should not get the tx if we provide an unrelated block\n+            assert_raises_rpc_error(-5, \"No such transaction found\", self.nodes[n].getrawtransaction, txid=tx, blockhash=block2)\n+            # An invalid block hash should raise the correct errors\n+            assert_raises_rpc_error(-1, \"JSON value is not a string as expected\", self.nodes[n].getrawtransaction, txid=tx, blockhash=True)\n+            assert_raises_rpc_error(-8, \"parameter 3 must be of length 64 (not 6, for 'foobar')\", self.nodes[n].getrawtransaction, txid=tx, blockhash=\"foobar\")\n+            assert_raises_rpc_error(-8, \"parameter 3 must be of length 64 (not 8, for 'abcd1234')\", self.nodes[n].getrawtransaction, txid=tx, blockhash=\"abcd1234\")\n+            foo = \"ZZZ0000000000000000000000000000000000000000000000000000000000000\"\n+            assert_raises_rpc_error(-8, f\"parameter 3 must be hexadecimal string (not '{foo}')\", self.nodes[n].getrawtransaction, txid=tx, blockhash=foo)\n+            bar = \"0000000000000000000000000000000000000000000000000000000000000000\"\n+            assert_raises_rpc_error(-5, \"Block hash not found\", self.nodes[n].getrawtransaction, txid=tx, blockhash=bar)\n+            # Undo the blocks and verify that \"in_active_chain\" is false.\n+            self.nodes[n].invalidateblock(block1)\n+            gottx = self.nodes[n].getrawtransaction(txid=tx, verbose=True, blockhash=block1)\n+            assert_equal(gottx['in_active_chain'], False)\n+            self.nodes[n].reconsiderblock(block1)\n+            assert_equal(self.nodes[n].getbestblockhash(), block2)\n \n         if not self.options.descriptors:\n             # The traditional multisig workflow does not work with descriptor wallets so these are legacy only."
      }
    ]
  },
  {
    "sha": "8c19d1329f1f28000ca32d826cecf04680c6be69",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4YzE5ZDEzMjlmMWYyODAwMGNhMzJkODI2Y2VjZjA0NjgwYzZiZTY5",
    "commit": {
      "author": {
        "name": "Jon Atack",
        "email": "jon@atack.com",
        "date": "2021-07-12T12:48:54Z"
      },
      "committer": {
        "name": "Jon Atack",
        "email": "jon@atack.com",
        "date": "2021-08-31T18:51:20Z"
      },
      "message": "refactor: dedup/reorg createrawtransaction sequence number tests",
      "tree": {
        "sha": "098151cbe21c50edfb24269564d168b9b35f5424",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/098151cbe21c50edfb24269564d168b9b35f5424"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8c19d1329f1f28000ca32d826cecf04680c6be69",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEd6u7+MhX7zEv6RP5T1chs9Djkh0FAmEueigACgkQT1chs9Dj\nkh0N5A/8Ct8YTuubyeskI2JxJ4hpD3bU1Yh+V3NodBLkI+GkR1cy/nK+OP7zormG\n/cY4e6umAt6O2gusgtPW61cOTP46g12RYfAzNBZ6iHm8uxFcTPYhBWDu0DjFWrHA\n/Utj+zzvpPehHeTXEedS1qDIpKjW1o3bgjxrrHTIpZ0gugrTwPVPwYviZ0sTi53S\nhDCa4bI/sm1synTtFHJb97qJOxRlpMwq2bvcJBxHoh32opaRn6O3f81ff+p+JQvY\nHqQrfUaJzXTgLHmjhFFuSuT5ePvbH24UcC9MA8i+QYhqKRiJbHUN125W4Hcnegd7\nD6yF9tIOoWwX/f9rJKVtuRszPRSLCAouxi67b39ozq02yqxihJpIY/aSq9/nnDKq\nnlQHKPSRS+vSzkNdh+1y65JbS4XNPcTDv/UwGd82Rbf5PAipXzJ3SSPa/hGkMJMA\n33nG+3w+99nQxPVIPi9SKR95dp4MRDaAEU1qE+cMVkgp7TAMN1gS5iT8tutYKSR4\nq8neJXRDZ8vjW+NtRISmhLV0Xp6oT7Ur/lnuc4RqtdcJW3rvLHkZXeZ8sjrCnKrl\nvuqvvfsPIo+vMcZ7pYHI4mIdzEZzuTuvGGBIintzn1gQ5NfbY6f4ke0h2fp5sJo7\npUplk4H+BIwmPJBy0dgACX3Vf+HcsUaC4YED+QqHEL8b5ge+7aM=\n=HhZl\n-----END PGP SIGNATURE-----\n-----BEGIN OPENTIMESTAMPS GIT TIMESTAMP-----\n\nAQHwIFJnShjWTfPkm0Y3iBcIa7QQ+U700f5biYqo8OlyJyHgCP/wEA3sNEPayCZT\n4aWRi/PRDO8I8QRhLnoq8Ag3DFzaBPi7dgCD3+MNLvkMjiwraHR0cHM6Ly9ib2Iu\nYnRjLmNhbGVuZGFyLm9wZW50aW1lc3RhbXBzLm9yZ//wEEeEiNFsYU6LAcxPppCZ\nbF8I8QRhLnoq8AjyEqUCesf1NgCD3+MNLvkMjikoaHR0cHM6Ly9maW5uZXkuY2Fs\nZW5kYXIuZXRlcm5pdHl3YWxsLmNvbf/wEFARktQ11T3eOUQ4neaerGQI8QRhLnoq\n8AhOgQWrn36KdgCD3+MNLvkMjiMiaHR0cHM6Ly9idGMuY2FsZW5kYXIuY2F0YWxs\nYXh5LmNvbfAQjdsP2/HwloO3wGitmEij7QjxBGEueirwCHYxEgPovnNdAIPf4w0u\n+QyOLi1odHRwczovL2FsaWNlLmJ0Yy5jYWxlbmRhci5vcGVudGltZXN0YW1wcy5v\ncmc=\n-----END OPENTIMESTAMPS GIT TIMESTAMP-----",
        "payload": "tree 098151cbe21c50edfb24269564d168b9b35f5424\nparent 7f073594c9f5b518dc1fb66dfb0189e8803e3545\nauthor Jon Atack <jon@atack.com> 1626094134 +0200\ncommitter Jon Atack <jon@atack.com> 1630435880 +0200\n\nrefactor: dedup/reorg createrawtransaction sequence number tests\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8c19d1329f1f28000ca32d826cecf04680c6be69",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8c19d1329f1f28000ca32d826cecf04680c6be69",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8c19d1329f1f28000ca32d826cecf04680c6be69/comments",
    "author": {
      "login": "jonatack",
      "id": 2415484,
      "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonatack",
      "html_url": "https://github.com/jonatack",
      "followers_url": "https://api.github.com/users/jonatack/followers",
      "following_url": "https://api.github.com/users/jonatack/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonatack/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
      "organizations_url": "https://api.github.com/users/jonatack/orgs",
      "repos_url": "https://api.github.com/users/jonatack/repos",
      "events_url": "https://api.github.com/users/jonatack/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonatack/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jonatack",
      "id": 2415484,
      "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonatack",
      "html_url": "https://github.com/jonatack",
      "followers_url": "https://api.github.com/users/jonatack/followers",
      "following_url": "https://api.github.com/users/jonatack/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonatack/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
      "organizations_url": "https://api.github.com/users/jonatack/orgs",
      "repos_url": "https://api.github.com/users/jonatack/repos",
      "events_url": "https://api.github.com/users/jonatack/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonatack/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7f073594c9f5b518dc1fb66dfb0189e8803e3545",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7f073594c9f5b518dc1fb66dfb0189e8803e3545",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7f073594c9f5b518dc1fb66dfb0189e8803e3545"
      }
    ],
    "stats": {
      "total": 36,
      "additions": 13,
      "deletions": 23
    },
    "files": [
      {
        "sha": "deb2a668af0975e4c00ea5dddc4f432c19342e0f",
        "filename": "test/functional/rpc_rawtransaction.py",
        "status": "modified",
        "additions": 13,
        "deletions": 23,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8c19d1329f1f28000ca32d826cecf04680c6be69/test/functional/rpc_rawtransaction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8c19d1329f1f28000ca32d826cecf04680c6be69/test/functional/rpc_rawtransaction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_rawtransaction.py?ref=8c19d1329f1f28000ca32d826cecf04680c6be69",
        "patch": "@@ -105,7 +105,19 @@ def run_test(self):\n         assert_raises_rpc_error(-8, \"Invalid parameter, missing vout key\", self.nodes[0].createrawtransaction, [{'txid': txid}], {})\n         assert_raises_rpc_error(-8, \"Invalid parameter, missing vout key\", self.nodes[0].createrawtransaction, [{'txid': txid, 'vout': 'foo'}], {})\n         assert_raises_rpc_error(-8, \"Invalid parameter, vout cannot be negative\", self.nodes[0].createrawtransaction, [{'txid': txid, 'vout': -1}], {})\n-        assert_raises_rpc_error(-8, \"Invalid parameter, sequence number is out of range\", self.nodes[0].createrawtransaction, [{'txid': txid, 'vout': 0, 'sequence': -1}], {})\n+        # sequence number out of range\n+        for invalid_seq in [-1, 4294967296]:\n+            inputs = [{'txid': txid, 'vout': 1, 'sequence': invalid_seq}]\n+            outputs = {self.nodes[0].getnewaddress(): 1}\n+            assert_raises_rpc_error(-8, 'Invalid parameter, sequence number is out of range',\n+                                    self.nodes[0].createrawtransaction, inputs, outputs)\n+        # with valid sequence number\n+        for valid_seq in [1000, 4294967294]:\n+            inputs = [{'txid': txid, 'vout': 1, 'sequence': valid_seq}]\n+            outputs = {self.nodes[0].getnewaddress(): 1}\n+            rawtx = self.nodes[0].createrawtransaction(inputs, outputs)\n+            decrawtx = self.nodes[0].decoderawtransaction(rawtx)\n+            assert_equal(decrawtx['vin'][0]['sequence'], valid_seq)\n \n         # Test `createrawtransaction` invalid `outputs`\n         address = self.nodes[0].getnewaddress()\n@@ -437,28 +449,6 @@ def run_test(self):\n         # 8. invalid parameters - supply txid and empty dict\n         assert_raises_rpc_error(-1, \"not a boolean\", self.nodes[0].getrawtransaction, txId, {})\n \n-        inputs  = [ {'txid' : \"1d1d4e24ed99057e84c3f80fd8fbec79ed9e1acee37da269356ecea000000000\", 'vout' : 1, 'sequence' : 1000}]\n-        outputs = { self.nodes[0].getnewaddress() : 1 }\n-        rawtx   = self.nodes[0].createrawtransaction(inputs, outputs)\n-        decrawtx= self.nodes[0].decoderawtransaction(rawtx)\n-        assert_equal(decrawtx['vin'][0]['sequence'], 1000)\n-\n-        # 9. invalid parameters - sequence number out of range\n-        inputs  = [ {'txid' : \"1d1d4e24ed99057e84c3f80fd8fbec79ed9e1acee37da269356ecea000000000\", 'vout' : 1, 'sequence' : -1}]\n-        outputs = { self.nodes[0].getnewaddress() : 1 }\n-        assert_raises_rpc_error(-8, 'Invalid parameter, sequence number is out of range', self.nodes[0].createrawtransaction, inputs, outputs)\n-\n-        # 10. invalid parameters - sequence number out of range\n-        inputs  = [ {'txid' : \"1d1d4e24ed99057e84c3f80fd8fbec79ed9e1acee37da269356ecea000000000\", 'vout' : 1, 'sequence' : 4294967296}]\n-        outputs = { self.nodes[0].getnewaddress() : 1 }\n-        assert_raises_rpc_error(-8, 'Invalid parameter, sequence number is out of range', self.nodes[0].createrawtransaction, inputs, outputs)\n-\n-        inputs  = [ {'txid' : \"1d1d4e24ed99057e84c3f80fd8fbec79ed9e1acee37da269356ecea000000000\", 'vout' : 1, 'sequence' : 4294967294}]\n-        outputs = { self.nodes[0].getnewaddress() : 1 }\n-        rawtx   = self.nodes[0].createrawtransaction(inputs, outputs)\n-        decrawtx= self.nodes[0].decoderawtransaction(rawtx)\n-        assert_equal(decrawtx['vin'][0]['sequence'], 4294967294)\n-\n         ####################################\n         # TRANSACTION VERSION NUMBER TESTS #\n         ####################################"
      }
    ]
  },
  {
    "sha": "00977407732969593800d15de39abbb7e0250abc",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowMDk3NzQwNzczMjk2OTU5MzgwMGQxNWRlMzlhYmJiN2UwMjUwYWJj",
    "commit": {
      "author": {
        "name": "Jon Atack",
        "email": "jon@atack.com",
        "date": "2021-07-12T14:12:21Z"
      },
      "committer": {
        "name": "Jon Atack",
        "email": "jon@atack.com",
        "date": "2021-08-31T18:51:23Z"
      },
      "message": "refactor: txid to constant in rpc_rawtransaction to isolate tests",
      "tree": {
        "sha": "f5d0ae6d187eafe4c30c30bb6701e63b9097f3d1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f5d0ae6d187eafe4c30c30bb6701e63b9097f3d1"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/00977407732969593800d15de39abbb7e0250abc",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEd6u7+MhX7zEv6RP5T1chs9Djkh0FAmEueisACgkQT1chs9Dj\nkh0USA//XDdjyuliC5x6d18Mg+JMO+cpU4JCAkd1yDF1MHmTiv1A4acD0ruJh4tZ\n85WKsZISBhATAM7mPrN6RJu3+Bva5tM9HQ/SApdMP6puQlYdsBmXmsHEs0LEqQHY\nSMCL7ToaoVm6HNIclfVt8qptsKmxe7Ova483nXppnjRkcthHKL+4IHoFyxCAR+/9\nbjiZ+3/hZ9JQ9EZBvcF37krCxrSc1Uia/m1iRaj6+qDyUYLNmPjKmtizsIeQxRaf\nGzvhq4iD4SlnEcOODuDSNgcw8J8xVkS2jIXo32OM0GoopuZOJbrsngKddhVPkhpc\nEdJPM0TlaqL8UsnKVAnyKPShdRe8ry1dvd8L67+7NNFxiv6iJB4fCOAoFyy9dY1G\nxF9s8bIJZ7AD+7gMfk0tbCPHzOHdh8xyExbbIMBx6wxUBEOztahiHyCXGqR2UgaK\nePmob1BLsbYSUVSuW60dyFIi04deiFoFFNplbNz8bC1KulS0vjpU8OuO+IRBS2wv\nx/aA+L9aM9TtL8HtC7/6B9zphqGGOY9SaNCZNMV9BeW8FrOPzp4CwX2CB3YVin9r\nHxC7PwHXw025sGoXtKFjX5nh8iB/z+KQ96ZTwWrzBgb4DqF0OfAmhuJmNfG8p85f\ncNapFpLp5ReHh/3QUm0jNQxwSW454OyvSTzOTTYtsmY0V2Uf0Uw=\n=OthW\n-----END PGP SIGNATURE-----\n-----BEGIN OPENTIMESTAMPS GIT TIMESTAMP-----\n\nAQHwIM2+47Y92OaOnzkdcq5Qag+v3dQoEqPeqxMTe0sIyBzdCP/wEAtsAcKKtmTS\naY7HU2tkSfUI8CD9EVwdtQcdP5VrlxGtzUVh0ttNIfGobng5s+mGGCm2uQjwIM9Q\nwEUyxoQOmtwq3s+Qx6Tx6VD7VuAfWsXj+BcpF+/vCPEEYS56LfAIDdltIMwTueEA\ng9/jDS75DI4pKGh0dHBzOi8vZmlubmV5LmNhbGVuZGFyLmV0ZXJuaXR5d2FsbC5j\nb23/8BAixKcLzNgjk5i7G6OD90u8CPEEYS56LfAIdNx7ajxh7YMAg9/jDS75DI4s\nK2h0dHBzOi8vYm9iLmJ0Yy5jYWxlbmRhci5vcGVudGltZXN0YW1wcy5vcmf/8BBt\naxPLnY3qOZ9Pj9Bm7iEtCPAgdeex9AAVtDuYR+3xGEdQ+d9lB/07LZMUylWQph9B\n3UEI8QRhLnot8AiUHf4cDDOQ8QCD3+MNLvkMjiMiaHR0cHM6Ly9idGMuY2FsZW5k\nYXIuY2F0YWxsYXh5LmNvbfAQjKN63DEm/bu9GISV+Rf+RQjxBGEueizwCOcJepVn\nZdicAIPf4w0u+QyOLi1odHRwczovL2FsaWNlLmJ0Yy5jYWxlbmRhci5vcGVudGlt\nZXN0YW1wcy5vcmc=\n-----END OPENTIMESTAMPS GIT TIMESTAMP-----",
        "payload": "tree f5d0ae6d187eafe4c30c30bb6701e63b9097f3d1\nparent 8c19d1329f1f28000ca32d826cecf04680c6be69\nauthor Jon Atack <jon@atack.com> 1626099141 +0200\ncommitter Jon Atack <jon@atack.com> 1630435883 +0200\n\nrefactor: txid to constant in rpc_rawtransaction to isolate tests\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/00977407732969593800d15de39abbb7e0250abc",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/00977407732969593800d15de39abbb7e0250abc",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/00977407732969593800d15de39abbb7e0250abc/comments",
    "author": {
      "login": "jonatack",
      "id": 2415484,
      "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonatack",
      "html_url": "https://github.com/jonatack",
      "followers_url": "https://api.github.com/users/jonatack/followers",
      "following_url": "https://api.github.com/users/jonatack/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonatack/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
      "organizations_url": "https://api.github.com/users/jonatack/orgs",
      "repos_url": "https://api.github.com/users/jonatack/repos",
      "events_url": "https://api.github.com/users/jonatack/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonatack/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jonatack",
      "id": 2415484,
      "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonatack",
      "html_url": "https://github.com/jonatack",
      "followers_url": "https://api.github.com/users/jonatack/followers",
      "following_url": "https://api.github.com/users/jonatack/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonatack/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
      "organizations_url": "https://api.github.com/users/jonatack/orgs",
      "repos_url": "https://api.github.com/users/jonatack/repos",
      "events_url": "https://api.github.com/users/jonatack/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonatack/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8c19d1329f1f28000ca32d826cecf04680c6be69",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8c19d1329f1f28000ca32d826cecf04680c6be69",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8c19d1329f1f28000ca32d826cecf04680c6be69"
      }
    ],
    "stats": {
      "total": 38,
      "additions": 20,
      "deletions": 18
    },
    "files": [
      {
        "sha": "619ad1bcd78f85f6b3bb70486596f52d4928fc9f",
        "filename": "test/functional/rpc_rawtransaction.py",
        "status": "modified",
        "additions": 20,
        "deletions": 18,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/00977407732969593800d15de39abbb7e0250abc/test/functional/rpc_rawtransaction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/00977407732969593800d15de39abbb7e0250abc/test/functional/rpc_rawtransaction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_rawtransaction.py?ref=00977407732969593800d15de39abbb7e0250abc",
        "patch": "@@ -28,6 +28,9 @@\n )\n \n \n+TXID = \"1d1d4e24ed99057e84c3f80fd8fbec79ed9e1acee37da269356ecea000000000\"\n+\n+\n class multidict(dict):\n     \"\"\"Dictionary that allows duplicate keys.\n \n@@ -96,24 +99,23 @@ def run_test(self):\n         assert_raises_rpc_error(-1, \"createrawtransaction\", self.nodes[0].createrawtransaction, [], {}, 0, False, 'foo')\n \n         # Test `createrawtransaction` invalid `inputs`\n-        txid = '1d1d4e24ed99057e84c3f80fd8fbec79ed9e1acee37da269356ecea000000000'\n         assert_raises_rpc_error(-3, \"Expected type array\", self.nodes[0].createrawtransaction, 'foo', {})\n         assert_raises_rpc_error(-1, \"JSON value is not an object as expected\", self.nodes[0].createrawtransaction, ['foo'], {})\n         assert_raises_rpc_error(-1, \"JSON value is not a string as expected\", self.nodes[0].createrawtransaction, [{}], {})\n         assert_raises_rpc_error(-8, \"txid must be of length 64 (not 3, for 'foo')\", self.nodes[0].createrawtransaction, [{'txid': 'foo'}], {})\n         assert_raises_rpc_error(-8, \"txid must be hexadecimal string (not 'ZZZ7bb8b1697ea987f3b223ba7819250cae33efacb068d23dc24859824a77844')\", self.nodes[0].createrawtransaction, [{'txid': 'ZZZ7bb8b1697ea987f3b223ba7819250cae33efacb068d23dc24859824a77844'}], {})\n-        assert_raises_rpc_error(-8, \"Invalid parameter, missing vout key\", self.nodes[0].createrawtransaction, [{'txid': txid}], {})\n-        assert_raises_rpc_error(-8, \"Invalid parameter, missing vout key\", self.nodes[0].createrawtransaction, [{'txid': txid, 'vout': 'foo'}], {})\n-        assert_raises_rpc_error(-8, \"Invalid parameter, vout cannot be negative\", self.nodes[0].createrawtransaction, [{'txid': txid, 'vout': -1}], {})\n+        assert_raises_rpc_error(-8, \"Invalid parameter, missing vout key\", self.nodes[0].createrawtransaction, [{'txid': TXID}], {})\n+        assert_raises_rpc_error(-8, \"Invalid parameter, missing vout key\", self.nodes[0].createrawtransaction, [{'txid': TXID, 'vout': 'foo'}], {})\n+        assert_raises_rpc_error(-8, \"Invalid parameter, vout cannot be negative\", self.nodes[0].createrawtransaction, [{'txid': TXID, 'vout': -1}], {})\n         # sequence number out of range\n         for invalid_seq in [-1, 4294967296]:\n-            inputs = [{'txid': txid, 'vout': 1, 'sequence': invalid_seq}]\n+            inputs = [{'txid': TXID, 'vout': 1, 'sequence': invalid_seq}]\n             outputs = {self.nodes[0].getnewaddress(): 1}\n             assert_raises_rpc_error(-8, 'Invalid parameter, sequence number is out of range',\n                                     self.nodes[0].createrawtransaction, inputs, outputs)\n         # with valid sequence number\n         for valid_seq in [1000, 4294967294]:\n-            inputs = [{'txid': txid, 'vout': 1, 'sequence': valid_seq}]\n+            inputs = [{'txid': TXID, 'vout': 1, 'sequence': valid_seq}]\n             outputs = {self.nodes[0].getnewaddress(): 1}\n             rawtx = self.nodes[0].createrawtransaction(inputs, outputs)\n             decrawtx = self.nodes[0].decoderawtransaction(rawtx)\n@@ -146,25 +148,25 @@ def run_test(self):\n \n         self.log.info('Check that createrawtransaction accepts an array and object as outputs')\n         # One output\n-        tx = tx_from_hex(self.nodes[2].createrawtransaction(inputs=[{'txid': txid, 'vout': 9}], outputs={address: 99}))\n+        tx = tx_from_hex(self.nodes[2].createrawtransaction(inputs=[{'txid': TXID, 'vout': 9}], outputs={address: 99}))\n         assert_equal(len(tx.vout), 1)\n         assert_equal(\n             tx.serialize().hex(),\n-            self.nodes[2].createrawtransaction(inputs=[{'txid': txid, 'vout': 9}], outputs=[{address: 99}]),\n+            self.nodes[2].createrawtransaction(inputs=[{'txid': TXID, 'vout': 9}], outputs=[{address: 99}]),\n         )\n         # Two outputs\n-        tx = tx_from_hex(self.nodes[2].createrawtransaction(inputs=[{'txid': txid, 'vout': 9}], outputs=OrderedDict([(address, 99), (address2, 99)])))\n+        tx = tx_from_hex(self.nodes[2].createrawtransaction(inputs=[{'txid': TXID, 'vout': 9}], outputs=OrderedDict([(address, 99), (address2, 99)])))\n         assert_equal(len(tx.vout), 2)\n         assert_equal(\n             tx.serialize().hex(),\n-            self.nodes[2].createrawtransaction(inputs=[{'txid': txid, 'vout': 9}], outputs=[{address: 99}, {address2: 99}]),\n+            self.nodes[2].createrawtransaction(inputs=[{'txid': TXID, 'vout': 9}], outputs=[{address: 99}, {address2: 99}]),\n         )\n         # Multiple mixed outputs\n-        tx = tx_from_hex(self.nodes[2].createrawtransaction(inputs=[{'txid': txid, 'vout': 9}], outputs=multidict([(address, 99), (address2, 99), ('data', '99')])))\n+        tx = tx_from_hex(self.nodes[2].createrawtransaction(inputs=[{'txid': TXID, 'vout': 9}], outputs=multidict([(address, 99), (address2, 99), ('data', '99')])))\n         assert_equal(len(tx.vout), 3)\n         assert_equal(\n             tx.serialize().hex(),\n-            self.nodes[2].createrawtransaction(inputs=[{'txid': txid, 'vout': 9}], outputs=[{address: 99}, {address2: 99}, {'data': '99'}]),\n+            self.nodes[2].createrawtransaction(inputs=[{'txid': TXID, 'vout': 9}], outputs=[{address: 99}, {address2: 99}, {'data': '99'}]),\n         )\n \n         for type in [\"bech32\", \"p2sh-segwit\", \"legacy\"]:\n@@ -175,11 +177,11 @@ def run_test(self):\n             self.log.info('sendrawtransaction with missing prevtx info (%s)' %(type))\n \n             # Test `signrawtransactionwithwallet` invalid `prevtxs`\n-            inputs  = [ {'txid' : txid, 'vout' : 3, 'sequence' : 1000}]\n+            inputs  = [ {'txid' : TXID, 'vout' : 3, 'sequence' : 1000}]\n             outputs = { self.nodes[0].getnewaddress() : 1 }\n             rawtx   = self.nodes[0].createrawtransaction(inputs, outputs)\n \n-            prevtx = dict(txid=txid, scriptPubKey=pubkey, vout=3, amount=1)\n+            prevtx = dict(txid=TXID, scriptPubKey=pubkey, vout=3, amount=1)\n             succ = self.nodes[0].signrawtransactionwithwallet(rawtx, [prevtx])\n             assert succ[\"complete\"]\n             if type == \"legacy\":\n@@ -190,15 +192,15 @@ def run_test(self):\n             if type != \"legacy\":\n                 assert_raises_rpc_error(-3, \"Missing amount\", self.nodes[0].signrawtransactionwithwallet, rawtx, [\n                     {\n-                        \"txid\": txid,\n+                        \"txid\": TXID,\n                         \"scriptPubKey\": pubkey,\n                         \"vout\": 3,\n                     }\n                 ])\n \n             assert_raises_rpc_error(-3, \"Missing vout\", self.nodes[0].signrawtransactionwithwallet, rawtx, [\n                 {\n-                    \"txid\": txid,\n+                    \"txid\": TXID,\n                     \"scriptPubKey\": pubkey,\n                     \"amount\": 1,\n                 }\n@@ -212,7 +214,7 @@ def run_test(self):\n             ])\n             assert_raises_rpc_error(-3, \"Missing scriptPubKey\", self.nodes[0].signrawtransactionwithwallet, rawtx, [\n                 {\n-                    \"txid\": txid,\n+                    \"txid\": TXID,\n                     \"vout\": 3,\n                     \"amount\": 1\n                 }\n@@ -223,7 +225,7 @@ def run_test(self):\n         #########################################\n \n         self.log.info('sendrawtransaction with missing input')\n-        inputs  = [ {'txid' : \"1d1d4e24ed99057e84c3f80fd8fbec79ed9e1acee37da269356ecea000000000\", 'vout' : 1}] #won't exists\n+        inputs  = [{'txid' : TXID, 'vout' : 1}]  # won't exist\n         outputs = { self.nodes[0].getnewaddress() : 4.998 }\n         rawtx   = self.nodes[2].createrawtransaction(inputs, outputs)\n         rawtx   = self.nodes[2].signrawtransactionwithwallet(rawtx)"
      }
    ]
  },
  {
    "sha": "85d8869cf89fedf243748e3e15b3ed39de1b0385",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4NWQ4ODY5Y2Y4OWZlZGYyNDM3NDhlM2UxNWIzZWQzOWRlMWIwMzg1",
    "commit": {
      "author": {
        "name": "Jon Atack",
        "email": "jon@atack.com",
        "date": "2021-07-11T13:42:42Z"
      },
      "committer": {
        "name": "Jon Atack",
        "email": "jon@atack.com",
        "date": "2021-08-31T18:51:26Z"
      },
      "message": "test: run 2nd getrawtransaction section with/without -txindex\n\n(and make the 'string \"Flase\"' test clearer as requested by reviewers)",
      "tree": {
        "sha": "9d85b4dbb534d3dc05601014b0ad75aaafe8015d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9d85b4dbb534d3dc05601014b0ad75aaafe8015d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/85d8869cf89fedf243748e3e15b3ed39de1b0385",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEd6u7+MhX7zEv6RP5T1chs9Djkh0FAmEuei4ACgkQT1chs9Dj\nkh1Ldg/8CO493aw3F1ifZvUAlwHB400m3F4bRzobC6Im/Ms0KMZgWILw0eAS5wF4\n94P5UN4dTwCzoSKHVWfK43HF3GK9D0yoj290Lu8g1EgrD+EFcycdgAxBcJV8QZR8\nVyZYTUGF+/40Cht3eHPxpsaCCoxElJ4na6qYTv4ApsRzCtWAPFy3RTG/Nj61ujVg\nlgNfRhgFPzscIXJEWLzDYlFRP7YqUsqddP6FdN+T0J9sRv5syJsFO7ErwPuv5U9/\nSxLGoQZUflehFkTnffVPND8P71PHhFmh6AZqx3SRkjyZJ9/svAN1vmHJjRH6Qs2h\nccK1JOt4Qrf0mO5ZSki1dufxKJkjdksciqxbU9sYrbMV4JF0+fHdtNrYwb+VxdZr\n/E7nFbAY4vInwi4JssjCE7bxQL5wKYnnLbzpGZDWAaJhVZJbC0h/ms/+LT0v26bS\nW81TPb6YRXZ4Ff5xm72anCA6Iwu09x1v4q6wlXdTYn971KTcycWAOFgLCXOle6Oj\nWZk3bglYgzNGgXJ/d64hy/nIlsyIUK9DgQT/fgUqKxgyaK1y6I7eFq//T/P7CqCp\nXtu6mHu0MgUKbJMiilYLg3EKeJteABdAYrtwUdsFJjf3iXXbo24tFeQ21v8x8UAx\n6Lxc/dN/syDpY4ZoIzt9cMbuYd03YnfTPbBtMre9uaOL05W16FE=\n=yd5x\n-----END PGP SIGNATURE-----\n-----BEGIN OPENTIMESTAMPS GIT TIMESTAMP-----\n\nAQHwIOxIox5OFKVPTxRVnHrKs7yrWNd0yu9hDvE+/7Oxp1kcCP/wEDoTpaypjVAK\n6zu2T7kxZ48I8CBikV/MRfuLFzoDXQaGgi2Wzj0G3j4IbAopUftwGjRDdAjxBGEu\nejHwCILHd61oJG3tAIPf4w0u+QyOKShodHRwczovL2Zpbm5leS5jYWxlbmRhci5l\ndGVybml0eXdhbGwuY29t//AQwFTMyTr1avh14zDAikvMOwjwIOCEj4dOt4KwK5iR\n2tpP2MaMw1g1QYWOQkFqIn30jptwCPEEYS56MPAIUFLv+qNBoKoAg9/jDS75DI4s\nK2h0dHBzOi8vYm9iLmJ0Yy5jYWxlbmRhci5vcGVudGltZXN0YW1wcy5vcmf/8BDG\nd6orjo2Z82dHOGZMcbKVCPAgmKh1pa+zJw06wNT/KgM2YnHmgRA0BC/bagLlcWlU\nwPcI8QRhLnow8AgbPAg6/HPucACD3+MNLvkMjiMiaHR0cHM6Ly9idGMuY2FsZW5k\nYXIuY2F0YWxsYXh5LmNvbfAQ89o+QeHRn4rtnxYgOlaU7gjxIJOxacu2fD0Ke8ic\n7J6LUdbS4Ku1FupHgJdPpPIbHpTwCPEEYS56L/AIgg6qZnSag3oAg9/jDS75DI4u\nLWh0dHBzOi8vYWxpY2UuYnRjLmNhbGVuZGFyLm9wZW50aW1lc3RhbXBzLm9yZw==\n-----END OPENTIMESTAMPS GIT TIMESTAMP-----",
        "payload": "tree 9d85b4dbb534d3dc05601014b0ad75aaafe8015d\nparent 00977407732969593800d15de39abbb7e0250abc\nauthor Jon Atack <jon@atack.com> 1626010962 +0200\ncommitter Jon Atack <jon@atack.com> 1630435886 +0200\n\ntest: run 2nd getrawtransaction section with/without -txindex\n\n(and make the 'string \"Flase\"' test clearer as requested by reviewers)\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/85d8869cf89fedf243748e3e15b3ed39de1b0385",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/85d8869cf89fedf243748e3e15b3ed39de1b0385",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/85d8869cf89fedf243748e3e15b3ed39de1b0385/comments",
    "author": {
      "login": "jonatack",
      "id": 2415484,
      "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonatack",
      "html_url": "https://github.com/jonatack",
      "followers_url": "https://api.github.com/users/jonatack/followers",
      "following_url": "https://api.github.com/users/jonatack/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonatack/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
      "organizations_url": "https://api.github.com/users/jonatack/orgs",
      "repos_url": "https://api.github.com/users/jonatack/repos",
      "events_url": "https://api.github.com/users/jonatack/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonatack/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jonatack",
      "id": 2415484,
      "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonatack",
      "html_url": "https://github.com/jonatack",
      "followers_url": "https://api.github.com/users/jonatack/followers",
      "following_url": "https://api.github.com/users/jonatack/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonatack/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
      "organizations_url": "https://api.github.com/users/jonatack/orgs",
      "repos_url": "https://api.github.com/users/jonatack/repos",
      "events_url": "https://api.github.com/users/jonatack/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonatack/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "00977407732969593800d15de39abbb7e0250abc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/00977407732969593800d15de39abbb7e0250abc",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/00977407732969593800d15de39abbb7e0250abc"
      }
    ],
    "stats": {
      "total": 37,
      "additions": 20,
      "deletions": 17
    },
    "files": [
      {
        "sha": "89088e9fc6b9855cc8db4d112c3459f22b50e375",
        "filename": "test/functional/rpc_rawtransaction.py",
        "status": "modified",
        "additions": 20,
        "deletions": 17,
        "changes": 37,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/85d8869cf89fedf243748e3e15b3ed39de1b0385/test/functional/rpc_rawtransaction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/85d8869cf89fedf243748e3e15b3ed39de1b0385/test/functional/rpc_rawtransaction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_rawtransaction.py?ref=85d8869cf89fedf243748e3e15b3ed39de1b0385",
        "patch": "@@ -426,30 +426,33 @@ def run_test(self):\n         self.sync_all()\n \n         # getrawtransaction tests\n-        # 1. valid parameters - only supply txid\n-        assert_equal(self.nodes[0].getrawtransaction(txId), rawTxSigned['hex'])\n+        for n in [0, 3]:\n+            self.log.info(f\"Test getrawtransaction {'with' if n == 0 else 'without'} -txindex\")\n+            # 1. valid parameters - only supply txid\n+            assert_equal(self.nodes[n].getrawtransaction(txId), rawTxSigned['hex'])\n \n-        # 2. valid parameters - supply txid and 0 for non-verbose\n-        assert_equal(self.nodes[0].getrawtransaction(txId, 0), rawTxSigned['hex'])\n+            # 2. valid parameters - supply txid and 0 for non-verbose\n+            assert_equal(self.nodes[n].getrawtransaction(txId, 0), rawTxSigned['hex'])\n \n-        # 3. valid parameters - supply txid and False for non-verbose\n-        assert_equal(self.nodes[0].getrawtransaction(txId, False), rawTxSigned['hex'])\n+            # 3. valid parameters - supply txid and False for non-verbose\n+            assert_equal(self.nodes[n].getrawtransaction(txId, False), rawTxSigned['hex'])\n \n-        # 4. valid parameters - supply txid and 1 for verbose.\n-        # We only check the \"hex\" field of the output so we don't need to update this test every time the output format changes.\n-        assert_equal(self.nodes[0].getrawtransaction(txId, 1)[\"hex\"], rawTxSigned['hex'])\n+            # 4. valid parameters - supply txid and 1 for verbose.\n+            # We only check the \"hex\" field of the output so we don't need to update this test every time the output format changes.\n+            assert_equal(self.nodes[n].getrawtransaction(txId, 1)[\"hex\"], rawTxSigned['hex'])\n \n-        # 5. valid parameters - supply txid and True for non-verbose\n-        assert_equal(self.nodes[0].getrawtransaction(txId, True)[\"hex\"], rawTxSigned['hex'])\n+            # 5. valid parameters - supply txid and True for non-verbose\n+            assert_equal(self.nodes[n].getrawtransaction(txId, True)[\"hex\"], rawTxSigned['hex'])\n \n-        # 6. invalid parameters - supply txid and string \"Flase\"\n-        assert_raises_rpc_error(-1, \"not a boolean\", self.nodes[0].getrawtransaction, txId, \"Flase\")\n+            # 6. invalid parameters - supply txid and invalid boolean values (strings) for verbose\n+            for value in [\"True\", \"False\"]:\n+                assert_raises_rpc_error(-1, \"not a boolean\", self.nodes[n].getrawtransaction, txid=txId, verbose=value)\n \n-        # 7. invalid parameters - supply txid and empty array\n-        assert_raises_rpc_error(-1, \"not a boolean\", self.nodes[0].getrawtransaction, txId, [])\n+            # 7. invalid parameters - supply txid and empty array\n+            assert_raises_rpc_error(-1, \"not a boolean\", self.nodes[n].getrawtransaction, txId, [])\n \n-        # 8. invalid parameters - supply txid and empty dict\n-        assert_raises_rpc_error(-1, \"not a boolean\", self.nodes[0].getrawtransaction, txId, {})\n+            # 8. invalid parameters - supply txid and empty dict\n+            assert_raises_rpc_error(-1, \"not a boolean\", self.nodes[n].getrawtransaction, txId, {})\n \n         ####################################\n         # TRANSACTION VERSION NUMBER TESTS #"
      }
    ]
  },
  {
    "sha": "14398b30d6242db14670b3286f988b2badda83fb",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxNDM5OGIzMGQ2MjQyZGIxNDY3MGIzMjg2Zjk4OGIyYmFkZGE4M2Zi",
    "commit": {
      "author": {
        "name": "Jon Atack",
        "email": "jon@atack.com",
        "date": "2021-07-12T13:13:29Z"
      },
      "committer": {
        "name": "Jon Atack",
        "email": "jon@atack.com",
        "date": "2021-08-31T19:55:00Z"
      },
      "message": "test: add and harmonize getrawtransaction logging",
      "tree": {
        "sha": "3ee00a69523c49d3cfc66a72ce6253dbedd815b5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3ee00a69523c49d3cfc66a72ce6253dbedd815b5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/14398b30d6242db14670b3286f988b2badda83fb",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEd6u7+MhX7zEv6RP5T1chs9Djkh0FAmEuiR8ACgkQT1chs9Dj\nkh2azBAAwWWMS8XCc8G5w29BkG8FR2lX6dIzXkzhhRhgGV5GTs+H3nF/onZd+BTG\nD+VpNRwDb0DyelrYvMcC9AIj25TwTUdKEjSJyUbQPZJB2cjzEPfchVlnfAW6ni1o\nt1GyJYY4f15xSEhKTR8HkJdlj/8TV1YBCyHK49YnRL47C6QAC5RnGNl7UqEL7red\nLzepdiEKQb9m3c97T4MI78YdmGxqMEHLunDlxmMT5g5g4rsw/omuuqiZOuYnu6ET\nF1emfZWmCOYWNCbjUd0zEAASiW1K/Zlo3X806IqXfu5DyvVeEUSBWZUuLT+djwax\nqToV9EKKE2dOfgfHnucSrDhnT66/P+pGrDRWRm71Pp1ya8rh3QIumq2gXFZHa0fH\nBwhEBOasDT1xzlsOkmz0C9ZBWmwC/PrcKVpSRz9xfEf+QTAiPtorVqh1qrIu8UEj\npD81GJZ+2evPske3/ZOo26/b9uzfPrxuGr9IfaTyWc1eOoUIYFjcDkNVQRtwFj/l\nxSRIq0tENKocyvartsTPoe4S5dapQhSY1EkUHFc8pjYQnT5mK8VMLp0d6x7ej6LE\ny2TVYWtdR6UtvJ2tpn+cetF+nzuL37SCCp0pifXvDVdJPcJlQWEboGh/h0x38uQ1\n1khGdumZEQ/KWGbO/1r4cCZ/eJTeT9X/cdSxGY8XFjkuNeSI7ck=\n=9iZ0\n-----END PGP SIGNATURE-----\n-----BEGIN OPENTIMESTAMPS GIT TIMESTAMP-----\n\nAQHwIDjhxQeOnocyMoWFf+apBjL21s5mDNoI+jzykwYAiYRkCP/wEGdg2xYVawPd\nrwnyziE0ElEI8QRhLoki8AjaHJn4wZSs2QCD3+MNLvkMjikoaHR0cHM6Ly9maW5u\nZXkuY2FsZW5kYXIuZXRlcm5pdHl3YWxsLmNvbf/wEHiHU4GmDt3A03Y3A7XNEqoI\n8QRhLokh8Ag3A/F6bQTFWACD3+MNLvkMjiwraHR0cHM6Ly9ib2IuYnRjLmNhbGVu\nZGFyLm9wZW50aW1lc3RhbXBzLm9yZ//wEOMi5/qUyzpjmRrC3rnR/bMI8QRhLokh\n8AhZ6mBMUsf9ZQCD3+MNLvkMji4taHR0cHM6Ly9hbGljZS5idGMuY2FsZW5kYXIu\nb3BlbnRpbWVzdGFtcHMub3Jn8BDuJhGXJrbXmDr25XhTpDW6CPEEYS6JIvAI8Itv\n2v8r1cIAg9/jDS75DI4jImh0dHBzOi8vYnRjLmNhbGVuZGFyLmNhdGFsbGF4eS5j\nb20=\n-----END OPENTIMESTAMPS GIT TIMESTAMP-----",
        "payload": "tree 3ee00a69523c49d3cfc66a72ce6253dbedd815b5\nparent 85d8869cf89fedf243748e3e15b3ed39de1b0385\nauthor Jon Atack <jon@atack.com> 1626095609 +0200\ncommitter Jon Atack <jon@atack.com> 1630439700 +0200\n\ntest: add and harmonize getrawtransaction logging\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/14398b30d6242db14670b3286f988b2badda83fb",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/14398b30d6242db14670b3286f988b2badda83fb",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/14398b30d6242db14670b3286f988b2badda83fb/comments",
    "author": {
      "login": "jonatack",
      "id": 2415484,
      "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonatack",
      "html_url": "https://github.com/jonatack",
      "followers_url": "https://api.github.com/users/jonatack/followers",
      "following_url": "https://api.github.com/users/jonatack/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonatack/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
      "organizations_url": "https://api.github.com/users/jonatack/orgs",
      "repos_url": "https://api.github.com/users/jonatack/repos",
      "events_url": "https://api.github.com/users/jonatack/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonatack/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jonatack",
      "id": 2415484,
      "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonatack",
      "html_url": "https://github.com/jonatack",
      "followers_url": "https://api.github.com/users/jonatack/followers",
      "following_url": "https://api.github.com/users/jonatack/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonatack/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
      "organizations_url": "https://api.github.com/users/jonatack/orgs",
      "repos_url": "https://api.github.com/users/jonatack/repos",
      "events_url": "https://api.github.com/users/jonatack/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonatack/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "85d8869cf89fedf243748e3e15b3ed39de1b0385",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/85d8869cf89fedf243748e3e15b3ed39de1b0385",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/85d8869cf89fedf243748e3e15b3ed39de1b0385"
      }
    ],
    "stats": {
      "total": 28,
      "additions": 14,
      "deletions": 14
    },
    "files": [
      {
        "sha": "2aa80de90da58aea9412ab25307de69d9c93f30c",
        "filename": "test/functional/rpc_rawtransaction.py",
        "status": "modified",
        "additions": 14,
        "deletions": 14,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/14398b30d6242db14670b3286f988b2badda83fb/test/functional/rpc_rawtransaction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/14398b30d6242db14670b3286f988b2badda83fb/test/functional/rpc_rawtransaction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_rawtransaction.py?ref=14398b30d6242db14670b3286f988b2badda83fb",
        "patch": "@@ -74,7 +74,7 @@ def setup_network(self):\n         self.connect_nodes(0, 2)\n \n     def run_test(self):\n-        self.log.info('prepare some coins for multiple *rawtransaction commands')\n+        self.log.info(\"Prepare some coins for multiple *rawtransaction commands\")\n         self.nodes[2].generate(1)\n         self.sync_all()\n         self.nodes[0].generate(COINBASE_MATURITY + 1)\n@@ -86,11 +86,11 @@ def run_test(self):\n         self.nodes[0].generate(5)\n         self.sync_all()\n \n-        self.log.info('Test getrawtransaction on genesis block coinbase returns an error')\n+        self.log.info(\"Test getrawtransaction on genesis block coinbase returns an error\")\n         block = self.nodes[0].getblock(self.nodes[0].getblockhash(0))\n         assert_raises_rpc_error(-5, \"The genesis block coinbase is not considered an ordinary transaction\", self.nodes[0].getrawtransaction, block['merkleroot'])\n \n-        self.log.info('Check parameter types and required parameters of createrawtransaction')\n+        self.log.info(\"Test createrawtransaction\")\n         # Test `createrawtransaction` required parameters\n         assert_raises_rpc_error(-1, \"createrawtransaction\", self.nodes[0].createrawtransaction)\n         assert_raises_rpc_error(-1, \"createrawtransaction\", self.nodes[0].createrawtransaction, [])\n@@ -146,7 +146,7 @@ def run_test(self):\n         # Test `createrawtransaction` invalid `replaceable`\n         assert_raises_rpc_error(-3, \"Expected type bool\", self.nodes[0].createrawtransaction, [], {}, 0, 'foo')\n \n-        self.log.info('Check that createrawtransaction accepts an array and object as outputs')\n+        # Test that createrawtransaction accepts an array and object as outputs\n         # One output\n         tx = tx_from_hex(self.nodes[2].createrawtransaction(inputs=[{'txid': TXID, 'vout': 9}], outputs={address: 99}))\n         assert_equal(len(tx.vout), 1)\n@@ -170,13 +170,10 @@ def run_test(self):\n         )\n \n         for type in [\"bech32\", \"p2sh-segwit\", \"legacy\"]:\n+            self.log.info(f\"Test signrawtransactionwithwallet with missing prevtx info ({type})\")\n             addr = self.nodes[0].getnewaddress(\"\", type)\n             addrinfo = self.nodes[0].getaddressinfo(addr)\n             pubkey = addrinfo[\"scriptPubKey\"]\n-\n-            self.log.info('sendrawtransaction with missing prevtx info (%s)' %(type))\n-\n-            # Test `signrawtransactionwithwallet` invalid `prevtxs`\n             inputs  = [ {'txid' : TXID, 'vout' : 3, 'sequence' : 1000}]\n             outputs = { self.nodes[0].getnewaddress() : 1 }\n             rawtx   = self.nodes[0].createrawtransaction(inputs, outputs)\n@@ -224,7 +221,7 @@ def run_test(self):\n         # sendrawtransaction with missing input #\n         #########################################\n \n-        self.log.info('sendrawtransaction with missing input')\n+        self.log.info(\"Test sendrawtransaction with missing input\")\n         inputs  = [{'txid' : TXID, 'vout' : 1}]  # won't exist\n         outputs = { self.nodes[0].getnewaddress() : 4.998 }\n         rawtx   = self.nodes[2].createrawtransaction(inputs, outputs)\n@@ -237,7 +234,7 @@ def run_test(self):\n         # getrawtransaction with block hash #\n         #####################################\n \n-        # make a tx by sending then generate 2 blocks; block1 has the tx in it\n+        # Make a tx by sending, then generate 2 blocks; block1 has the tx in it\n         tx = self.nodes[2].sendtoaddress(self.nodes[1].getnewaddress(), 1)\n         block1, block2 = self.nodes[2].generate(2)\n         self.sync_all()\n@@ -277,6 +274,7 @@ def run_test(self):\n             assert_equal(self.nodes[n].getbestblockhash(), block2)\n \n         if not self.options.descriptors:\n+            self.log.info(\"Test raw multisig transactions (legacy)\")\n             # The traditional multisig workflow does not work with descriptor wallets so these are legacy only.\n             # The multisig workflow with descriptor wallets uses PSBTs and is tested elsewhere, no need to do them here.\n             #########################\n@@ -395,7 +393,7 @@ def run_test(self):\n             self.sync_all()\n             assert_equal(self.nodes[0].getbalance(), bal+Decimal('50.00000000')+Decimal('2.19000000')) #block reward + tx\n \n-        # decoderawtransaction tests\n+        self.log.info(\"Test decoderawtransaction\")\n         # witness transaction\n         encrawtx = \"010000000001010000000000000072c1a6a246ae63f74f931e8365e15a089c68d61900000000000000000000ffffffff0100e1f50500000000000102616100000000\"\n         decrawtx = self.nodes[0].decoderawtransaction(encrawtx, True) # decode as witness transaction\n@@ -413,7 +411,7 @@ def run_test(self):\n         assert_equal(decrawtx, decrawtx_wit) # the witness interpretation should be chosen\n         assert_equal(decrawtx['vin'][0]['coinbase'], \"03c68708046ff8415c622f4254432e434f4d2ffabe6d6de1965d02c68f928e5b244ab1965115a36f56eb997633c7f690124bbf43644e23080000000ca3d3af6d005a65ff0200fd00000000\")\n \n-        # Basic signrawtransaction test\n+        self.log.info(\"Test signrawtransactionwithwallet\")\n         addr = self.nodes[1].getnewaddress()\n         txid = self.nodes[0].sendtoaddress(addr, 10)\n         self.nodes[0].generate(1)\n@@ -458,6 +456,8 @@ def run_test(self):\n         # TRANSACTION VERSION NUMBER TESTS #\n         ####################################\n \n+        self.log.info(\"Test transaction version numbers\")\n+\n         # Test the minimum transaction version number that fits in a signed 32-bit integer.\n         # As transaction version is unsigned, this should convert to its unsigned equivalent.\n         tx = CTransaction()\n@@ -473,7 +473,7 @@ def run_test(self):\n         decrawtx = self.nodes[0].decoderawtransaction(rawtx)\n         assert_equal(decrawtx['version'], 0x7fffffff)\n \n-        self.log.info('sendrawtransaction/testmempoolaccept with maxfeerate')\n+        self.log.info(\"Test sendrawtransaction/testmempoolaccept with maxfeerate\")\n \n         # Test a transaction with a small fee.\n         txId = self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(), 1.0)\n@@ -523,7 +523,7 @@ def run_test(self):\n         assert_equal(testres['allowed'], True)\n         self.nodes[2].sendrawtransaction(hexstring=rawTxSigned['hex'], maxfeerate='0.20000000')\n \n-        self.log.info('sendrawtransaction/testmempoolaccept with tx that is already in the chain')\n+        self.log.info(\"Test sendrawtransaction/testmempoolaccept with tx already in the chain\")\n         self.nodes[2].generate(1)\n         self.sync_blocks()\n         for node in self.nodes:"
      }
    ]
  },
  {
    "sha": "d861040dd24a321e1ceec1f07c7bb80d59779081",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkODYxMDQwZGQyNGEzMjFlMWNlZWMxZjA3YzdiYjgwZDU5Nzc5MDgx",
    "commit": {
      "author": {
        "name": "Jon Atack",
        "email": "jon@atack.com",
        "date": "2021-07-12T13:16:43Z"
      },
      "committer": {
        "name": "Jon Atack",
        "email": "jon@atack.com",
        "date": "2021-08-31T19:55:15Z"
      },
      "message": "test: remove no longer needed (ASCII art) comments",
      "tree": {
        "sha": "a8a25656f9f4157df13ffb96e13627c7bd38d005",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a8a25656f9f4157df13ffb96e13627c7bd38d005"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d861040dd24a321e1ceec1f07c7bb80d59779081",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEd6u7+MhX7zEv6RP5T1chs9Djkh0FAmEuiSMACgkQT1chs9Dj\nkh3A+w/+NQC4VCr+nKMhez3E0AXr2zloPNtohHgHj6Vnj28mUVqVKK9sA9XzBIJe\nU2h/KmmC9z81KCljnJh7Wj/7na0cBXV6kZkOcnlgVC9izzmzl/fMSHU7Y3soPspe\nr69eUJzm9ZO4i4BOyrNDc7/G2/8nxDlOlKGvsD/S14ZO2TlkGDdPUgAS1OrY8N/d\nTep+fgrmveBwv409bPsM4XOJcaDB3ubkE9UYwcq27I8PI4tyd0mAacRRNSUydrQi\nk5S/tw95NhmLeQcFKhhN9u9lqm8Y2Xy1jTT+8+V/zMMEio8IQe/2lYU2VUnZ+BGH\nxBx2Y/bAc9vNwoGBTOl2Kr3MNjPZfzEY0KWdZ+2PbCJq86opRDSxDJKt/qB2yuFK\nvGiqeGiPrMu62TAtfjrGR1Q4cgnryIg/Xyt/Jsvz4F7iAPPIv+dXM7ne0zh2jbOH\nOlzfJjqEmN2drAcqSn1BuX4Yd/TIaUIKd1c3HSg0uSnD3taDpSpqM/SStRz5hftL\nkXbxDtccztofSHEiRLSUzVIJfA2qYCNlJrbJ0pVAv4fnXiKm9SXL3ZoxQ1gzgCQ4\neeF6oevcip778pIWn5hZqxjY8AVc/UfF4QRcAbwSqM5mvrYxsvbDwas/CFnyIDij\nEduC3V1ZCO1nqModLkwuy1pmcmywNuexDSaXtL0EdJ2jTi7pVGs=\n=3uKG\n-----END PGP SIGNATURE-----\n-----BEGIN OPENTIMESTAMPS GIT TIMESTAMP-----\n\nAQHwIBR/3Vzn4dv2A2IMGb0lA2xNThaDTSBwoMv70otvBqSrCP/wEDC87myLTjtb\nyel6UlSynYkI8CAcX9vkrF229z+3vEc/ooCun66sRWw3u+WuaA9iyChtqwjwIDmY\nRJOpYP3FSGRdZrWS8a75gyWWzQLlEtHnKn2GopnaCPEEYS6JJfAI5GJVCqENMIUA\ng9/jDS75DI4sK2h0dHBzOi8vYm9iLmJ0Yy5jYWxlbmRhci5vcGVudGltZXN0YW1w\ncy5vcmf/8BBGUBnf1F5Ln86YRAn5989qCPEEYS6JJfAIm5FoMYDlZmsAg9/jDS75\nDI4pKGh0dHBzOi8vZmlubmV5LmNhbGVuZGFyLmV0ZXJuaXR5d2FsbC5jb23/8BCt\nX+WZIAXZrrvci9hzKhmGCPEEYS6JJvAI3e0/ijKc0P0Ag9/jDS75DI4uLWh0dHBz\nOi8vYWxpY2UuYnRjLmNhbGVuZGFyLm9wZW50aW1lc3RhbXBzLm9yZ/AQ8+kQgw3/\n1D4ugowCTuhE0QjxBGEuiSTwCDTOcPYyXo67AIPf4w0u+QyOIyJodHRwczovL2J0\nYy5jYWxlbmRhci5jYXRhbGxheHkuY29t\n-----END OPENTIMESTAMPS GIT TIMESTAMP-----",
        "payload": "tree a8a25656f9f4157df13ffb96e13627c7bd38d005\nparent 14398b30d6242db14670b3286f988b2badda83fb\nauthor Jon Atack <jon@atack.com> 1626095803 +0200\ncommitter Jon Atack <jon@atack.com> 1630439715 +0200\n\ntest: remove no longer needed (ASCII art) comments\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d861040dd24a321e1ceec1f07c7bb80d59779081",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d861040dd24a321e1ceec1f07c7bb80d59779081",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d861040dd24a321e1ceec1f07c7bb80d59779081/comments",
    "author": {
      "login": "jonatack",
      "id": 2415484,
      "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonatack",
      "html_url": "https://github.com/jonatack",
      "followers_url": "https://api.github.com/users/jonatack/followers",
      "following_url": "https://api.github.com/users/jonatack/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonatack/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
      "organizations_url": "https://api.github.com/users/jonatack/orgs",
      "repos_url": "https://api.github.com/users/jonatack/repos",
      "events_url": "https://api.github.com/users/jonatack/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonatack/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jonatack",
      "id": 2415484,
      "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonatack",
      "html_url": "https://github.com/jonatack",
      "followers_url": "https://api.github.com/users/jonatack/followers",
      "following_url": "https://api.github.com/users/jonatack/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonatack/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
      "organizations_url": "https://api.github.com/users/jonatack/orgs",
      "repos_url": "https://api.github.com/users/jonatack/repos",
      "events_url": "https://api.github.com/users/jonatack/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonatack/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "14398b30d6242db14670b3286f988b2badda83fb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/14398b30d6242db14670b3286f988b2badda83fb",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/14398b30d6242db14670b3286f988b2badda83fb"
      }
    ],
    "stats": {
      "total": 16,
      "additions": 0,
      "deletions": 16
    },
    "files": [
      {
        "sha": "f354d4faaace88d4fa29aa345cf406294edf8228",
        "filename": "test/functional/rpc_rawtransaction.py",
        "status": "modified",
        "additions": 0,
        "deletions": 16,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d861040dd24a321e1ceec1f07c7bb80d59779081/test/functional/rpc_rawtransaction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d861040dd24a321e1ceec1f07c7bb80d59779081/test/functional/rpc_rawtransaction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_rawtransaction.py?ref=d861040dd24a321e1ceec1f07c7bb80d59779081",
        "patch": "@@ -49,7 +49,6 @@ def items(self):\n         return self.x\n \n \n-# Create one-input, one-output, no-fee transaction:\n class RawTransactionsTest(BitcoinTestFramework):\n     def set_test_params(self):\n         self.setup_clean_chain = True\n@@ -217,10 +216,6 @@ def run_test(self):\n                 }\n             ])\n \n-        #########################################\n-        # sendrawtransaction with missing input #\n-        #########################################\n-\n         self.log.info(\"Test sendrawtransaction with missing input\")\n         inputs  = [{'txid' : TXID, 'vout' : 1}]  # won't exist\n         outputs = { self.nodes[0].getnewaddress() : 4.998 }\n@@ -230,10 +225,6 @@ def run_test(self):\n         # This will raise an exception since there are missing inputs\n         assert_raises_rpc_error(-25, \"bad-txns-inputs-missingorspent\", self.nodes[2].sendrawtransaction, rawtx['hex'])\n \n-        #####################################\n-        # getrawtransaction with block hash #\n-        #####################################\n-\n         # Make a tx by sending, then generate 2 blocks; block1 has the tx in it\n         tx = self.nodes[2].sendtoaddress(self.nodes[1].getnewaddress(), 1)\n         block1, block2 = self.nodes[2].generate(2)\n@@ -277,9 +268,6 @@ def run_test(self):\n             self.log.info(\"Test raw multisig transactions (legacy)\")\n             # The traditional multisig workflow does not work with descriptor wallets so these are legacy only.\n             # The multisig workflow with descriptor wallets uses PSBTs and is tested elsewhere, no need to do them here.\n-            #########################\n-            # RAW TX MULTISIG TESTS #\n-            #########################\n             # 2of2 test\n             addr1 = self.nodes[2].getnewaddress()\n             addr2 = self.nodes[2].getnewaddress()\n@@ -452,10 +440,6 @@ def run_test(self):\n             # 8. invalid parameters - supply txid and empty dict\n             assert_raises_rpc_error(-1, \"not a boolean\", self.nodes[n].getrawtransaction, txId, {})\n \n-        ####################################\n-        # TRANSACTION VERSION NUMBER TESTS #\n-        ####################################\n-\n         self.log.info(\"Test transaction version numbers\")\n \n         # Test the minimum transaction version number that fits in a signed 32-bit integer."
      }
    ]
  },
  {
    "sha": "409779df95f886b08dbf6d44219e2fbeb3405a43",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0MDk3NzlkZjk1Zjg4NmIwOGRiZjZkNDQyMTllMmZiZWIzNDA1YTQz",
    "commit": {
      "author": {
        "name": "Jon Atack",
        "email": "jon@atack.com",
        "date": "2021-07-12T13:42:21Z"
      },
      "committer": {
        "name": "Jon Atack",
        "email": "jon@atack.com",
        "date": "2021-08-31T19:57:27Z"
      },
      "message": "move-only: regroup similar rpc_rawtransaction tests together",
      "tree": {
        "sha": "92ea97a5c10e57d0f8ead5fb28ac813ffceaa7cf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/92ea97a5c10e57d0f8ead5fb28ac813ffceaa7cf"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/409779df95f886b08dbf6d44219e2fbeb3405a43",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEd6u7+MhX7zEv6RP5T1chs9Djkh0FAmEuibIACgkQT1chs9Dj\nkh2c6g/+L+1hNLTd3F8YVdrxqmFFwp5VLmA16uMPbaZ68OIe62lKGF1n/aKiG2Lv\nQ9zU4HQXMuRwxbHdMSIYbU8rBOaznPrZgqjPGL/GlNND/mIMNrskF9FJ7mUtXSlE\ngQ7hVXlrBrMEjL2SzVCIUhH4dsJrAj3GM63W+stuqvLyISQGGiZ15WI4Ga1uyL+I\nMgksfZHKpWHj2qaEImX6utHa8LqVJqptVr9xy7OrHoeAAgeMNuy7s6eMTokmBi1c\nAi2QAS8fEmJX+xPQxQPEVkUHjrzXPLQYSE1e1UKywolgkOUl/bthK7fCcZxRbQA2\nRG6SG5DyasKCrZcFxZFOMrd1dIYdIgOcASdowdx0DlC4qmf4dbaBAdDb5f2n3EeK\n85ZNOtxDwimPYk8/t1PxpSyCyfDUHBw2Ojg6WLB5wYDZXcEhkD91rDd2pHBsxxyu\noAAsyzXzRImKvFn+BnmCuYd9QETFsEMTerAl+2jRl30qUAVnwMJK/NfJFKctb/Z4\nLuLIuhlIZzb8DIHYcS8Mxc6fuIOBZe7ZPY9hBLlfedzEsV1lJGEHZUxaKFsDzO80\n6nDVDTrpy9wssYaLlgfzXLS8YGRQ/7pQqeqbrbpVqZ31Zj9hs0nA38pI9BsO6qat\nS7+i1I2/hOnGLJVsn8O54JiOUYB6YsFRw8F5z9CmQgm0YnVpXJA=\n=zpqu\n-----END PGP SIGNATURE-----\n-----BEGIN OPENTIMESTAMPS GIT TIMESTAMP-----\n\nAQHwIFN702KIx0xMs4MdGLLtryqVzO1aeP+pJXeof0JrNV+MCP/wECD18wRiCe92\ndSQ21a2iYM8I8QRhLomz8AjCHd1o8L/VnQCD3+MNLvkMjiMiaHR0cHM6Ly9idGMu\nY2FsZW5kYXIuY2F0YWxsYXh5LmNvbf/wEIicQWCl7i720S5rd/CFiBoI8QRhLomz\n8AhJKUOdSE62YQCD3+MNLvkMji4taHR0cHM6Ly9hbGljZS5idGMuY2FsZW5kYXIu\nb3BlbnRpbWVzdGFtcHMub3Jn//AQtt89WGPV7gLxWl2h5GF1BAjxIJwMgfK3jcnN\nC0ueZTSlldBrLhB8AOalHrx5DQcFeRADCPEEYS6JtPAI0zqTUECZlkIAg9/jDS75\nDI4pKGh0dHBzOi8vZmlubmV5LmNhbGVuZGFyLmV0ZXJuaXR5d2FsbC5jb23wEMAv\nSPbtMRZ0rIgijKfIC9kI8QRhLom08AiOmkjnW/GV7gCD3+MNLvkMjiwraHR0cHM6\nLy9ib2IuYnRjLmNhbGVuZGFyLm9wZW50aW1lc3RhbXBzLm9yZw==\n-----END OPENTIMESTAMPS GIT TIMESTAMP-----",
        "payload": "tree 92ea97a5c10e57d0f8ead5fb28ac813ffceaa7cf\nparent d861040dd24a321e1ceec1f07c7bb80d59779081\nauthor Jon Atack <jon@atack.com> 1626097341 +0200\ncommitter Jon Atack <jon@atack.com> 1630439847 +0200\n\nmove-only: regroup similar rpc_rawtransaction tests together\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/409779df95f886b08dbf6d44219e2fbeb3405a43",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/409779df95f886b08dbf6d44219e2fbeb3405a43",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/409779df95f886b08dbf6d44219e2fbeb3405a43/comments",
    "author": {
      "login": "jonatack",
      "id": 2415484,
      "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonatack",
      "html_url": "https://github.com/jonatack",
      "followers_url": "https://api.github.com/users/jonatack/followers",
      "following_url": "https://api.github.com/users/jonatack/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonatack/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
      "organizations_url": "https://api.github.com/users/jonatack/orgs",
      "repos_url": "https://api.github.com/users/jonatack/repos",
      "events_url": "https://api.github.com/users/jonatack/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonatack/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jonatack",
      "id": 2415484,
      "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonatack",
      "html_url": "https://github.com/jonatack",
      "followers_url": "https://api.github.com/users/jonatack/followers",
      "following_url": "https://api.github.com/users/jonatack/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonatack/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
      "organizations_url": "https://api.github.com/users/jonatack/orgs",
      "repos_url": "https://api.github.com/users/jonatack/repos",
      "events_url": "https://api.github.com/users/jonatack/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonatack/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d861040dd24a321e1ceec1f07c7bb80d59779081",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d861040dd24a321e1ceec1f07c7bb80d59779081",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d861040dd24a321e1ceec1f07c7bb80d59779081"
      }
    ],
    "stats": {
      "total": 344,
      "additions": 170,
      "deletions": 174
    },
    "files": [
      {
        "sha": "a7d86ae4fdf8c79df52f712e4b832e6ced60921f",
        "filename": "test/functional/rpc_rawtransaction.py",
        "status": "modified",
        "additions": 170,
        "deletions": 174,
        "changes": 344,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/409779df95f886b08dbf6d44219e2fbeb3405a43/test/functional/rpc_rawtransaction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/409779df95f886b08dbf6d44219e2fbeb3405a43/test/functional/rpc_rawtransaction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_rawtransaction.py?ref=409779df95f886b08dbf6d44219e2fbeb3405a43",
        "patch": "@@ -85,6 +85,85 @@ def run_test(self):\n         self.nodes[0].generate(5)\n         self.sync_all()\n \n+        # getrawtransaction tests\n+        addr = self.nodes[1].getnewaddress()\n+        txid = self.nodes[0].sendtoaddress(addr, 10)\n+        self.nodes[0].generate(1)\n+        self.sync_all()\n+        vout = find_vout_for_address(self.nodes[1], txid, addr)\n+        rawTx = self.nodes[1].createrawtransaction([{'txid': txid, 'vout': vout}], {self.nodes[1].getnewaddress(): 9.999})\n+        rawTxSigned = self.nodes[1].signrawtransactionwithwallet(rawTx)\n+        txId = self.nodes[1].sendrawtransaction(rawTxSigned['hex'])\n+        self.nodes[0].generate(1)\n+        self.sync_all()\n+\n+        for n in [0, 3]:\n+            self.log.info(f\"Test getrawtransaction {'with' if n == 0 else 'without'} -txindex\")\n+            # 1. valid parameters - only supply txid\n+            assert_equal(self.nodes[n].getrawtransaction(txId), rawTxSigned['hex'])\n+\n+            # 2. valid parameters - supply txid and 0 for non-verbose\n+            assert_equal(self.nodes[n].getrawtransaction(txId, 0), rawTxSigned['hex'])\n+\n+            # 3. valid parameters - supply txid and False for non-verbose\n+            assert_equal(self.nodes[n].getrawtransaction(txId, False), rawTxSigned['hex'])\n+\n+            # 4. valid parameters - supply txid and 1 for verbose.\n+            # We only check the \"hex\" field of the output so we don't need to update this test every time the output format changes.\n+            assert_equal(self.nodes[n].getrawtransaction(txId, 1)[\"hex\"], rawTxSigned['hex'])\n+\n+            # 5. valid parameters - supply txid and True for non-verbose\n+            assert_equal(self.nodes[n].getrawtransaction(txId, True)[\"hex\"], rawTxSigned['hex'])\n+\n+            # 6. invalid parameters - supply txid and invalid boolean values (strings) for verbose\n+            for value in [\"True\", \"False\"]:\n+                assert_raises_rpc_error(-1, \"not a boolean\", self.nodes[n].getrawtransaction, txid=txId, verbose=value)\n+\n+            # 7. invalid parameters - supply txid and empty array\n+            assert_raises_rpc_error(-1, \"not a boolean\", self.nodes[n].getrawtransaction, txId, [])\n+\n+            # 8. invalid parameters - supply txid and empty dict\n+            assert_raises_rpc_error(-1, \"not a boolean\", self.nodes[n].getrawtransaction, txId, {})\n+\n+        # Make a tx by sending, then generate 2 blocks; block1 has the tx in it\n+        tx = self.nodes[2].sendtoaddress(self.nodes[1].getnewaddress(), 1)\n+        block1, block2 = self.nodes[2].generate(2)\n+        self.sync_all()\n+        for n in [0, 3]:\n+            self.log.info(f\"Test getrawtransaction {'with' if n == 0 else 'without'} -txindex, with blockhash\")\n+            # We should be able to get the raw transaction by providing the correct block\n+            gottx = self.nodes[n].getrawtransaction(txid=tx, verbose=True, blockhash=block1)\n+            assert_equal(gottx['txid'], tx)\n+            assert_equal(gottx['in_active_chain'], True)\n+            if n == 0:\n+                self.log.info(\"Test getrawtransaction with -txindex, without blockhash: 'in_active_chain' should be absent\")\n+                gottx = self.nodes[n].getrawtransaction(txid=tx, verbose=True)\n+                assert_equal(gottx['txid'], tx)\n+                assert 'in_active_chain' not in gottx\n+            else:\n+                self.log.info(\"Test getrawtransaction without -txindex, without blockhash: expect the call to raise\")\n+                err_msg = (\n+                    \"No such mempool transaction. Use -txindex or provide a block hash to enable\"\n+                    \" blockchain transaction queries. Use gettransaction for wallet transactions.\"\n+                )\n+                assert_raises_rpc_error(-5, err_msg, self.nodes[n].getrawtransaction, txid=tx, verbose=True)\n+            # We should not get the tx if we provide an unrelated block\n+            assert_raises_rpc_error(-5, \"No such transaction found\", self.nodes[n].getrawtransaction, txid=tx, blockhash=block2)\n+            # An invalid block hash should raise the correct errors\n+            assert_raises_rpc_error(-1, \"JSON value is not a string as expected\", self.nodes[n].getrawtransaction, txid=tx, blockhash=True)\n+            assert_raises_rpc_error(-8, \"parameter 3 must be of length 64 (not 6, for 'foobar')\", self.nodes[n].getrawtransaction, txid=tx, blockhash=\"foobar\")\n+            assert_raises_rpc_error(-8, \"parameter 3 must be of length 64 (not 8, for 'abcd1234')\", self.nodes[n].getrawtransaction, txid=tx, blockhash=\"abcd1234\")\n+            foo = \"ZZZ0000000000000000000000000000000000000000000000000000000000000\"\n+            assert_raises_rpc_error(-8, f\"parameter 3 must be hexadecimal string (not '{foo}')\", self.nodes[n].getrawtransaction, txid=tx, blockhash=foo)\n+            bar = \"0000000000000000000000000000000000000000000000000000000000000000\"\n+            assert_raises_rpc_error(-5, \"Block hash not found\", self.nodes[n].getrawtransaction, txid=tx, blockhash=bar)\n+            # Undo the blocks and verify that \"in_active_chain\" is false.\n+            self.nodes[n].invalidateblock(block1)\n+            gottx = self.nodes[n].getrawtransaction(txid=tx, verbose=True, blockhash=block1)\n+            assert_equal(gottx['in_active_chain'], False)\n+            self.nodes[n].reconsiderblock(block1)\n+            assert_equal(self.nodes[n].getbestblockhash(), block2)\n+\n         self.log.info(\"Test getrawtransaction on genesis block coinbase returns an error\")\n         block = self.nodes[0].getblock(self.nodes[0].getblockhash(0))\n         assert_raises_rpc_error(-5, \"The genesis block coinbase is not considered an ordinary transaction\", self.nodes[0].getrawtransaction, block['merkleroot'])\n@@ -221,48 +300,100 @@ def run_test(self):\n         outputs = { self.nodes[0].getnewaddress() : 4.998 }\n         rawtx   = self.nodes[2].createrawtransaction(inputs, outputs)\n         rawtx   = self.nodes[2].signrawtransactionwithwallet(rawtx)\n-\n-        # This will raise an exception since there are missing inputs\n         assert_raises_rpc_error(-25, \"bad-txns-inputs-missingorspent\", self.nodes[2].sendrawtransaction, rawtx['hex'])\n \n-        # Make a tx by sending, then generate 2 blocks; block1 has the tx in it\n-        tx = self.nodes[2].sendtoaddress(self.nodes[1].getnewaddress(), 1)\n-        block1, block2 = self.nodes[2].generate(2)\n+        self.log.info(\"Test sendrawtransaction/testmempoolaccept with maxfeerate\")\n+        # Test a transaction with a small fee.\n+        txId = self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(), 1.0)\n+        rawTx = self.nodes[0].getrawtransaction(txId, True)\n+        vout = next(o for o in rawTx['vout'] if o['value'] == Decimal('1.00000000'))\n+\n         self.sync_all()\n-        for n in [0, 3]:\n-            self.log.info(f\"Test getrawtransaction {'with' if n == 0 else 'without'} -txindex, with blockhash\")\n-            # We should be able to get the raw transaction by providing the correct block\n-            gottx = self.nodes[n].getrawtransaction(txid=tx, verbose=True, blockhash=block1)\n-            assert_equal(gottx['txid'], tx)\n-            assert_equal(gottx['in_active_chain'], True)\n-            if n == 0:\n-                self.log.info(\"Test getrawtransaction with -txindex, without blockhash: 'in_active_chain' should be absent\")\n-                gottx = self.nodes[n].getrawtransaction(txid=tx, verbose=True)\n-                assert_equal(gottx['txid'], tx)\n-                assert 'in_active_chain' not in gottx\n-            else:\n-                self.log.info(\"Test getrawtransaction without -txindex, without blockhash: expect the call to raise\")\n-                err_msg = (\n-                    \"No such mempool transaction. Use -txindex or provide a block hash to enable\"\n-                    \" blockchain transaction queries. Use gettransaction for wallet transactions.\"\n-                )\n-                assert_raises_rpc_error(-5, err_msg, self.nodes[n].getrawtransaction, txid=tx, verbose=True)\n-            # We should not get the tx if we provide an unrelated block\n-            assert_raises_rpc_error(-5, \"No such transaction found\", self.nodes[n].getrawtransaction, txid=tx, blockhash=block2)\n-            # An invalid block hash should raise the correct errors\n-            assert_raises_rpc_error(-1, \"JSON value is not a string as expected\", self.nodes[n].getrawtransaction, txid=tx, blockhash=True)\n-            assert_raises_rpc_error(-8, \"parameter 3 must be of length 64 (not 6, for 'foobar')\", self.nodes[n].getrawtransaction, txid=tx, blockhash=\"foobar\")\n-            assert_raises_rpc_error(-8, \"parameter 3 must be of length 64 (not 8, for 'abcd1234')\", self.nodes[n].getrawtransaction, txid=tx, blockhash=\"abcd1234\")\n-            foo = \"ZZZ0000000000000000000000000000000000000000000000000000000000000\"\n-            assert_raises_rpc_error(-8, f\"parameter 3 must be hexadecimal string (not '{foo}')\", self.nodes[n].getrawtransaction, txid=tx, blockhash=foo)\n-            bar = \"0000000000000000000000000000000000000000000000000000000000000000\"\n-            assert_raises_rpc_error(-5, \"Block hash not found\", self.nodes[n].getrawtransaction, txid=tx, blockhash=bar)\n-            # Undo the blocks and verify that \"in_active_chain\" is false.\n-            self.nodes[n].invalidateblock(block1)\n-            gottx = self.nodes[n].getrawtransaction(txid=tx, verbose=True, blockhash=block1)\n-            assert_equal(gottx['in_active_chain'], False)\n-            self.nodes[n].reconsiderblock(block1)\n-            assert_equal(self.nodes[n].getbestblockhash(), block2)\n+        inputs = [{ \"txid\" : txId, \"vout\" : vout['n'] }]\n+        # Fee 10,000 satoshis, (1 - (10000 sat * 0.00000001 BTC/sat)) = 0.9999\n+        outputs = { self.nodes[0].getnewaddress() : Decimal(\"0.99990000\") }\n+        rawTx = self.nodes[2].createrawtransaction(inputs, outputs)\n+        rawTxSigned = self.nodes[2].signrawtransactionwithwallet(rawTx)\n+        assert_equal(rawTxSigned['complete'], True)\n+        # Fee 10,000 satoshis, ~100 b transaction, fee rate should land around 100 sat/byte = 0.00100000 BTC/kB\n+        # Thus, testmempoolaccept should reject\n+        testres = self.nodes[2].testmempoolaccept([rawTxSigned['hex']], 0.00001000)[0]\n+        assert_equal(testres['allowed'], False)\n+        assert_equal(testres['reject-reason'], 'max-fee-exceeded')\n+        # and sendrawtransaction should throw\n+        assert_raises_rpc_error(-25, 'Fee exceeds maximum configured by user (e.g. -maxtxfee, maxfeerate)', self.nodes[2].sendrawtransaction, rawTxSigned['hex'], 0.00001000)\n+        # and the following calls should both succeed\n+        testres = self.nodes[2].testmempoolaccept(rawtxs=[rawTxSigned['hex']])[0]\n+        assert_equal(testres['allowed'], True)\n+        self.nodes[2].sendrawtransaction(hexstring=rawTxSigned['hex'])\n+\n+        # Test a transaction with a large fee.\n+        txId = self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(), 1.0)\n+        rawTx = self.nodes[0].getrawtransaction(txId, True)\n+        vout = next(o for o in rawTx['vout'] if o['value'] == Decimal('1.00000000'))\n+\n+        self.sync_all()\n+        inputs = [{ \"txid\" : txId, \"vout\" : vout['n'] }]\n+        # Fee 2,000,000 satoshis, (1 - (2000000 sat * 0.00000001 BTC/sat)) = 0.98\n+        outputs = { self.nodes[0].getnewaddress() : Decimal(\"0.98000000\") }\n+        rawTx = self.nodes[2].createrawtransaction(inputs, outputs)\n+        rawTxSigned = self.nodes[2].signrawtransactionwithwallet(rawTx)\n+        assert_equal(rawTxSigned['complete'], True)\n+        # Fee 2,000,000 satoshis, ~100 b transaction, fee rate should land around 20,000 sat/byte = 0.20000000 BTC/kB\n+        # Thus, testmempoolaccept should reject\n+        testres = self.nodes[2].testmempoolaccept([rawTxSigned['hex']])[0]\n+        assert_equal(testres['allowed'], False)\n+        assert_equal(testres['reject-reason'], 'max-fee-exceeded')\n+        # and sendrawtransaction should throw\n+        assert_raises_rpc_error(-25, 'Fee exceeds maximum configured by user (e.g. -maxtxfee, maxfeerate)', self.nodes[2].sendrawtransaction, rawTxSigned['hex'])\n+        # and the following calls should both succeed\n+        testres = self.nodes[2].testmempoolaccept(rawtxs=[rawTxSigned['hex']], maxfeerate='0.20000000')[0]\n+        assert_equal(testres['allowed'], True)\n+        self.nodes[2].sendrawtransaction(hexstring=rawTxSigned['hex'], maxfeerate='0.20000000')\n+\n+        self.log.info(\"Test sendrawtransaction/testmempoolaccept with tx already in the chain\")\n+        self.nodes[2].generate(1)\n+        self.sync_blocks()\n+        for node in self.nodes:\n+            testres = node.testmempoolaccept([rawTxSigned['hex']])[0]\n+            assert_equal(testres['allowed'], False)\n+            assert_equal(testres['reject-reason'], 'txn-already-known')\n+            assert_raises_rpc_error(-27, 'Transaction already in block chain', node.sendrawtransaction, rawTxSigned['hex'])\n+\n+        self.log.info(\"Test decoderawtransaction\")\n+        # witness transaction\n+        encrawtx = \"010000000001010000000000000072c1a6a246ae63f74f931e8365e15a089c68d61900000000000000000000ffffffff0100e1f50500000000000102616100000000\"\n+        decrawtx = self.nodes[0].decoderawtransaction(encrawtx, True) # decode as witness transaction\n+        assert_equal(decrawtx['vout'][0]['value'], Decimal('1.00000000'))\n+        assert_raises_rpc_error(-22, 'TX decode failed', self.nodes[0].decoderawtransaction, encrawtx, False) # force decode as non-witness transaction\n+        # non-witness transaction\n+        encrawtx = \"01000000010000000000000072c1a6a246ae63f74f931e8365e15a089c68d61900000000000000000000ffffffff0100e1f505000000000000000000\"\n+        decrawtx = self.nodes[0].decoderawtransaction(encrawtx, False) # decode as non-witness transaction\n+        assert_equal(decrawtx['vout'][0]['value'], Decimal('1.00000000'))\n+        # known ambiguous transaction in the chain (see https://github.com/bitcoin/bitcoin/issues/20579)\n+        encrawtx = \"020000000001010000000000000000000000000000000000000000000000000000000000000000ffffffff4b03c68708046ff8415c622f4254432e434f4d2ffabe6d6de1965d02c68f928e5b244ab1965115a36f56eb997633c7f690124bbf43644e23080000000ca3d3af6d005a65ff0200fd00000000ffffffff03f4c1fb4b0000000016001497cfc76442fe717f2a3f0cc9c175f7561b6619970000000000000000266a24aa21a9ed957d1036a80343e0d1b659497e1b48a38ebe876a056d45965fac4a85cda84e1900000000000000002952534b424c4f434b3a8e092581ab01986cbadc84f4b43f4fa4bb9e7a2e2a0caf9b7cf64d939028e22c0120000000000000000000000000000000000000000000000000000000000000000000000000\"\n+        decrawtx = self.nodes[0].decoderawtransaction(encrawtx)\n+        decrawtx_wit = self.nodes[0].decoderawtransaction(encrawtx, True)\n+        assert_raises_rpc_error(-22, 'TX decode failed', self.nodes[0].decoderawtransaction, encrawtx, False) # fails to decode as non-witness transaction\n+        assert_equal(decrawtx, decrawtx_wit) # the witness interpretation should be chosen\n+        assert_equal(decrawtx['vin'][0]['coinbase'], \"03c68708046ff8415c622f4254432e434f4d2ffabe6d6de1965d02c68f928e5b244ab1965115a36f56eb997633c7f690124bbf43644e23080000000ca3d3af6d005a65ff0200fd00000000\")\n+\n+        self.log.info(\"Test transaction version numbers\")\n+\n+        # Test the minimum transaction version number that fits in a signed 32-bit integer.\n+        # As transaction version is unsigned, this should convert to its unsigned equivalent.\n+        tx = CTransaction()\n+        tx.nVersion = -0x80000000\n+        rawtx = tx.serialize().hex()\n+        decrawtx = self.nodes[0].decoderawtransaction(rawtx)\n+        assert_equal(decrawtx['version'], 0x80000000)\n+\n+        # Test the maximum transaction version number that fits in a signed 32-bit integer.\n+        tx = CTransaction()\n+        tx.nVersion = 0x7fffffff\n+        rawtx = tx.serialize().hex()\n+        decrawtx = self.nodes[0].decoderawtransaction(rawtx)\n+        assert_equal(decrawtx['version'], 0x7fffffff)\n \n         if not self.options.descriptors:\n             self.log.info(\"Test raw multisig transactions (legacy)\")\n@@ -381,141 +512,6 @@ def run_test(self):\n             self.sync_all()\n             assert_equal(self.nodes[0].getbalance(), bal+Decimal('50.00000000')+Decimal('2.19000000')) #block reward + tx\n \n-        self.log.info(\"Test decoderawtransaction\")\n-        # witness transaction\n-        encrawtx = \"010000000001010000000000000072c1a6a246ae63f74f931e8365e15a089c68d61900000000000000000000ffffffff0100e1f50500000000000102616100000000\"\n-        decrawtx = self.nodes[0].decoderawtransaction(encrawtx, True) # decode as witness transaction\n-        assert_equal(decrawtx['vout'][0]['value'], Decimal('1.00000000'))\n-        assert_raises_rpc_error(-22, 'TX decode failed', self.nodes[0].decoderawtransaction, encrawtx, False) # force decode as non-witness transaction\n-        # non-witness transaction\n-        encrawtx = \"01000000010000000000000072c1a6a246ae63f74f931e8365e15a089c68d61900000000000000000000ffffffff0100e1f505000000000000000000\"\n-        decrawtx = self.nodes[0].decoderawtransaction(encrawtx, False) # decode as non-witness transaction\n-        assert_equal(decrawtx['vout'][0]['value'], Decimal('1.00000000'))\n-        # known ambiguous transaction in the chain (see https://github.com/bitcoin/bitcoin/issues/20579)\n-        encrawtx = \"020000000001010000000000000000000000000000000000000000000000000000000000000000ffffffff4b03c68708046ff8415c622f4254432e434f4d2ffabe6d6de1965d02c68f928e5b244ab1965115a36f56eb997633c7f690124bbf43644e23080000000ca3d3af6d005a65ff0200fd00000000ffffffff03f4c1fb4b0000000016001497cfc76442fe717f2a3f0cc9c175f7561b6619970000000000000000266a24aa21a9ed957d1036a80343e0d1b659497e1b48a38ebe876a056d45965fac4a85cda84e1900000000000000002952534b424c4f434b3a8e092581ab01986cbadc84f4b43f4fa4bb9e7a2e2a0caf9b7cf64d939028e22c0120000000000000000000000000000000000000000000000000000000000000000000000000\"\n-        decrawtx = self.nodes[0].decoderawtransaction(encrawtx)\n-        decrawtx_wit = self.nodes[0].decoderawtransaction(encrawtx, True)\n-        assert_raises_rpc_error(-22, 'TX decode failed', self.nodes[0].decoderawtransaction, encrawtx, False) # fails to decode as non-witness transaction\n-        assert_equal(decrawtx, decrawtx_wit) # the witness interpretation should be chosen\n-        assert_equal(decrawtx['vin'][0]['coinbase'], \"03c68708046ff8415c622f4254432e434f4d2ffabe6d6de1965d02c68f928e5b244ab1965115a36f56eb997633c7f690124bbf43644e23080000000ca3d3af6d005a65ff0200fd00000000\")\n-\n-        self.log.info(\"Test signrawtransactionwithwallet\")\n-        addr = self.nodes[1].getnewaddress()\n-        txid = self.nodes[0].sendtoaddress(addr, 10)\n-        self.nodes[0].generate(1)\n-        self.sync_all()\n-        vout = find_vout_for_address(self.nodes[1], txid, addr)\n-        rawTx = self.nodes[1].createrawtransaction([{'txid': txid, 'vout': vout}], {self.nodes[1].getnewaddress(): 9.999})\n-        rawTxSigned = self.nodes[1].signrawtransactionwithwallet(rawTx)\n-        txId = self.nodes[1].sendrawtransaction(rawTxSigned['hex'])\n-        self.nodes[0].generate(1)\n-        self.sync_all()\n-\n-        # getrawtransaction tests\n-        for n in [0, 3]:\n-            self.log.info(f\"Test getrawtransaction {'with' if n == 0 else 'without'} -txindex\")\n-            # 1. valid parameters - only supply txid\n-            assert_equal(self.nodes[n].getrawtransaction(txId), rawTxSigned['hex'])\n-\n-            # 2. valid parameters - supply txid and 0 for non-verbose\n-            assert_equal(self.nodes[n].getrawtransaction(txId, 0), rawTxSigned['hex'])\n-\n-            # 3. valid parameters - supply txid and False for non-verbose\n-            assert_equal(self.nodes[n].getrawtransaction(txId, False), rawTxSigned['hex'])\n-\n-            # 4. valid parameters - supply txid and 1 for verbose.\n-            # We only check the \"hex\" field of the output so we don't need to update this test every time the output format changes.\n-            assert_equal(self.nodes[n].getrawtransaction(txId, 1)[\"hex\"], rawTxSigned['hex'])\n-\n-            # 5. valid parameters - supply txid and True for non-verbose\n-            assert_equal(self.nodes[n].getrawtransaction(txId, True)[\"hex\"], rawTxSigned['hex'])\n-\n-            # 6. invalid parameters - supply txid and invalid boolean values (strings) for verbose\n-            for value in [\"True\", \"False\"]:\n-                assert_raises_rpc_error(-1, \"not a boolean\", self.nodes[n].getrawtransaction, txid=txId, verbose=value)\n-\n-            # 7. invalid parameters - supply txid and empty array\n-            assert_raises_rpc_error(-1, \"not a boolean\", self.nodes[n].getrawtransaction, txId, [])\n-\n-            # 8. invalid parameters - supply txid and empty dict\n-            assert_raises_rpc_error(-1, \"not a boolean\", self.nodes[n].getrawtransaction, txId, {})\n-\n-        self.log.info(\"Test transaction version numbers\")\n-\n-        # Test the minimum transaction version number that fits in a signed 32-bit integer.\n-        # As transaction version is unsigned, this should convert to its unsigned equivalent.\n-        tx = CTransaction()\n-        tx.nVersion = -0x80000000\n-        rawtx = tx.serialize().hex()\n-        decrawtx = self.nodes[0].decoderawtransaction(rawtx)\n-        assert_equal(decrawtx['version'], 0x80000000)\n-\n-        # Test the maximum transaction version number that fits in a signed 32-bit integer.\n-        tx = CTransaction()\n-        tx.nVersion = 0x7fffffff\n-        rawtx = tx.serialize().hex()\n-        decrawtx = self.nodes[0].decoderawtransaction(rawtx)\n-        assert_equal(decrawtx['version'], 0x7fffffff)\n-\n-        self.log.info(\"Test sendrawtransaction/testmempoolaccept with maxfeerate\")\n-\n-        # Test a transaction with a small fee.\n-        txId = self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(), 1.0)\n-        rawTx = self.nodes[0].getrawtransaction(txId, True)\n-        vout = next(o for o in rawTx['vout'] if o['value'] == Decimal('1.00000000'))\n-\n-        self.sync_all()\n-        inputs = [{ \"txid\" : txId, \"vout\" : vout['n'] }]\n-        # Fee 10,000 satoshis, (1 - (10000 sat * 0.00000001 BTC/sat)) = 0.9999\n-        outputs = { self.nodes[0].getnewaddress() : Decimal(\"0.99990000\") }\n-        rawTx = self.nodes[2].createrawtransaction(inputs, outputs)\n-        rawTxSigned = self.nodes[2].signrawtransactionwithwallet(rawTx)\n-        assert_equal(rawTxSigned['complete'], True)\n-        # Fee 10,000 satoshis, ~100 b transaction, fee rate should land around 100 sat/byte = 0.00100000 BTC/kB\n-        # Thus, testmempoolaccept should reject\n-        testres = self.nodes[2].testmempoolaccept([rawTxSigned['hex']], 0.00001000)[0]\n-        assert_equal(testres['allowed'], False)\n-        assert_equal(testres['reject-reason'], 'max-fee-exceeded')\n-        # and sendrawtransaction should throw\n-        assert_raises_rpc_error(-25, 'Fee exceeds maximum configured by user (e.g. -maxtxfee, maxfeerate)', self.nodes[2].sendrawtransaction, rawTxSigned['hex'], 0.00001000)\n-        # and the following calls should both succeed\n-        testres = self.nodes[2].testmempoolaccept(rawtxs=[rawTxSigned['hex']])[0]\n-        assert_equal(testres['allowed'], True)\n-        self.nodes[2].sendrawtransaction(hexstring=rawTxSigned['hex'])\n-\n-        # Test a transaction with a large fee.\n-        txId = self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(), 1.0)\n-        rawTx = self.nodes[0].getrawtransaction(txId, True)\n-        vout = next(o for o in rawTx['vout'] if o['value'] == Decimal('1.00000000'))\n-\n-        self.sync_all()\n-        inputs = [{ \"txid\" : txId, \"vout\" : vout['n'] }]\n-        # Fee 2,000,000 satoshis, (1 - (2000000 sat * 0.00000001 BTC/sat)) = 0.98\n-        outputs = { self.nodes[0].getnewaddress() : Decimal(\"0.98000000\") }\n-        rawTx = self.nodes[2].createrawtransaction(inputs, outputs)\n-        rawTxSigned = self.nodes[2].signrawtransactionwithwallet(rawTx)\n-        assert_equal(rawTxSigned['complete'], True)\n-        # Fee 2,000,000 satoshis, ~100 b transaction, fee rate should land around 20,000 sat/byte = 0.20000000 BTC/kB\n-        # Thus, testmempoolaccept should reject\n-        testres = self.nodes[2].testmempoolaccept([rawTxSigned['hex']])[0]\n-        assert_equal(testres['allowed'], False)\n-        assert_equal(testres['reject-reason'], 'max-fee-exceeded')\n-        # and sendrawtransaction should throw\n-        assert_raises_rpc_error(-25, 'Fee exceeds maximum configured by user (e.g. -maxtxfee, maxfeerate)', self.nodes[2].sendrawtransaction, rawTxSigned['hex'])\n-        # and the following calls should both succeed\n-        testres = self.nodes[2].testmempoolaccept(rawtxs=[rawTxSigned['hex']], maxfeerate='0.20000000')[0]\n-        assert_equal(testres['allowed'], True)\n-        self.nodes[2].sendrawtransaction(hexstring=rawTxSigned['hex'], maxfeerate='0.20000000')\n-\n-        self.log.info(\"Test sendrawtransaction/testmempoolaccept with tx already in the chain\")\n-        self.nodes[2].generate(1)\n-        self.sync_blocks()\n-        for node in self.nodes:\n-            testres = node.testmempoolaccept([rawTxSigned['hex']])[0]\n-            assert_equal(testres['allowed'], False)\n-            assert_equal(testres['reject-reason'], 'txn-already-known')\n-            assert_raises_rpc_error(-27, 'Transaction already in block chain', node.sendrawtransaction, rawTxSigned['hex'])\n-\n \n if __name__ == '__main__':\n     RawTransactionsTest().main()"
      }
    ]
  },
  {
    "sha": "7d5cec2e498dc059ff1d74a2b60764db45923264",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3ZDVjZWMyZTQ5OGRjMDU5ZmYxZDc0YTJiNjA3NjRkYjQ1OTIzMjY0",
    "commit": {
      "author": {
        "name": "Jon Atack",
        "email": "jon@atack.com",
        "date": "2021-07-12T14:04:48Z"
      },
      "committer": {
        "name": "Jon Atack",
        "email": "jon@atack.com",
        "date": "2021-08-31T19:59:38Z"
      },
      "message": "refactor: separate the rpc_rawtransaction tests into functions",
      "tree": {
        "sha": "9baae38f9ce7e5372910cdffa41ef69b59922338",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9baae38f9ce7e5372910cdffa41ef69b59922338"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7d5cec2e498dc059ff1d74a2b60764db45923264",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEd6u7+MhX7zEv6RP5T1chs9Djkh0FAmEuijQACgkQT1chs9Dj\nkh38bw//UwWvS+aF8loy4AiJaUcAWuILrUuEKQ/0iHl9rnBkL5/TWO7CfCeBuUp+\ncAOHw75zcjkCnuBVBGGFECJcTzj7axncZ8AX4FmbC3VppGdl+C2AVSkGrnlVOVNw\nBoGnSSKpI+SwQyFA514w4DdDp43ZNXaWSps5CvnKP4Bg+sq+Xt2hZIQOdP4wCGjr\nurY37yGidx/JmDF1yDcyT7qmyk3Eg5zbI/pC768/M6n5nq85Xn2vZ56ZhJLX+F59\nMjeR9EZysKFhsvGI2qtHbqGcUc0gMEmmeY0BsIEmu3WA7lXQ8GaIhma0BTVT8Jf+\nzomvcIMzTgvpAXW+QC5nAbGwZgTJrsEnY2+o5nXjjtVSduhbZponJVl+JODe8FD+\neJyup9rSV1Jni8XiqyZ00rQq4TMQelnaNr/0exWavqjSrAAxipzMHOa0qyyG5a0N\nhS5s7SIYJU6DgXB9GNGlT7zikF0s8AdbpCipzPGuR0Rzo5wQxfCAFjMkfWOe8ygx\nTG43K5C7PRvd9sEpD16/B20vfkf5qxrl7jfpDDFMmVG5Qe0ro4pszAJVpS/EXAhH\n9earXk2SatH+C/E8rrLuv9zbrNFjJG37fERKCqbLwIx5bOnneI5zejvSTkFuD+wR\nRsGZ7uX6/JJ8/zczbVXCr++YIHHIUeVhklmUVrDaS7Wu03bNnOM=\n=A6gc\n-----END PGP SIGNATURE-----\n-----BEGIN OPENTIMESTAMPS GIT TIMESTAMP-----\n\nAQHwIOa88DKNg4I5W0oMayZe83MSZVnO+y6Kcy/JsWevhb0DCP/wEDYH0GDCywb4\noDszyyP+X3cI8QRhLoo28AjFZ4JGTIs5mwCD3+MNLvkMjiwraHR0cHM6Ly9ib2Iu\nYnRjLmNhbGVuZGFyLm9wZW50aW1lc3RhbXBzLm9yZ//wEE1ZexIqHlqaqdzAoKvZ\n8IgI8SCI/PmP+i1s2LbYPi3OGWB/ZOBrr6WNn3gYXxlzxPlozQjxBGEuijbwCFCQ\nO+ZKNQOBAIPf4w0u+QyOKShodHRwczovL2Zpbm5leS5jYWxlbmRhci5ldGVybml0\neXdhbGwuY29t//AQbvd4lpjkJJSEOEg83K4VqgjxICY4xmSqKfYCKWJcCEHkwmVM\nxpQtCXvBuVLhr9N40Z3ZCPEEYS6KNvAIptYI/gYTc30Ag9/jDS75DI4uLWh0dHBz\nOi8vYWxpY2UuYnRjLmNhbGVuZGFyLm9wZW50aW1lc3RhbXBzLm9yZ/AQ0M8ZskgW\necrDtjCzUE0uLAjxBGEuijXwCKK9Q22VPZ+YAIPf4w0u+QyOIyJodHRwczovL2J0\nYy5jYWxlbmRhci5jYXRhbGxheHkuY29t\n-----END OPENTIMESTAMPS GIT TIMESTAMP-----",
        "payload": "tree 9baae38f9ce7e5372910cdffa41ef69b59922338\nparent 409779df95f886b08dbf6d44219e2fbeb3405a43\nauthor Jon Atack <jon@atack.com> 1626098688 +0200\ncommitter Jon Atack <jon@atack.com> 1630439978 +0200\n\nrefactor: separate the rpc_rawtransaction tests into functions\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7d5cec2e498dc059ff1d74a2b60764db45923264",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7d5cec2e498dc059ff1d74a2b60764db45923264",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7d5cec2e498dc059ff1d74a2b60764db45923264/comments",
    "author": {
      "login": "jonatack",
      "id": 2415484,
      "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonatack",
      "html_url": "https://github.com/jonatack",
      "followers_url": "https://api.github.com/users/jonatack/followers",
      "following_url": "https://api.github.com/users/jonatack/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonatack/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
      "organizations_url": "https://api.github.com/users/jonatack/orgs",
      "repos_url": "https://api.github.com/users/jonatack/repos",
      "events_url": "https://api.github.com/users/jonatack/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonatack/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jonatack",
      "id": 2415484,
      "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonatack",
      "html_url": "https://github.com/jonatack",
      "followers_url": "https://api.github.com/users/jonatack/followers",
      "following_url": "https://api.github.com/users/jonatack/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonatack/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
      "organizations_url": "https://api.github.com/users/jonatack/orgs",
      "repos_url": "https://api.github.com/users/jonatack/repos",
      "events_url": "https://api.github.com/users/jonatack/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonatack/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "409779df95f886b08dbf6d44219e2fbeb3405a43",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/409779df95f886b08dbf6d44219e2fbeb3405a43",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/409779df95f886b08dbf6d44219e2fbeb3405a43"
      }
    ],
    "stats": {
      "total": 256,
      "additions": 136,
      "deletions": 120
    },
    "files": [
      {
        "sha": "25e345a8d1b5103503467f05e86d5b71dd36c2c0",
        "filename": "test/functional/rpc_rawtransaction.py",
        "status": "modified",
        "additions": 136,
        "deletions": 120,
        "changes": 256,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7d5cec2e498dc059ff1d74a2b60764db45923264/test/functional/rpc_rawtransaction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7d5cec2e498dc059ff1d74a2b60764db45923264/test/functional/rpc_rawtransaction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_rawtransaction.py?ref=7d5cec2e498dc059ff1d74a2b60764db45923264",
        "patch": "@@ -5,11 +5,11 @@\n \"\"\"Test the rawtransaction RPCs.\n \n Test the following RPCs:\n+   - getrawtransaction\n    - createrawtransaction\n    - signrawtransactionwithwallet\n    - sendrawtransaction\n    - decoderawtransaction\n-   - getrawtransaction\n \"\"\"\n \n from collections import OrderedDict\n@@ -85,7 +85,17 @@ def run_test(self):\n         self.nodes[0].generate(5)\n         self.sync_all()\n \n-        # getrawtransaction tests\n+        self.getrawtransaction_tests()\n+        self.createrawtransaction_tests()\n+        self.signrawtransactionwithwallet_tests()\n+        self.sendrawtransaction_tests()\n+        self.sendrawtransaction_testmempoolaccept_tests()\n+        self.decoderawtransaction_tests()\n+        self.transaction_version_number_tests()\n+        if not self.options.descriptors:\n+            self.raw_multisig_transaction_legacy_tests()\n+\n+    def getrawtransaction_tests(self):\n         addr = self.nodes[1].getnewaddress()\n         txid = self.nodes[0].sendtoaddress(addr, 10)\n         self.nodes[0].generate(1)\n@@ -168,6 +178,7 @@ def run_test(self):\n         block = self.nodes[0].getblock(self.nodes[0].getblockhash(0))\n         assert_raises_rpc_error(-5, \"The genesis block coinbase is not considered an ordinary transaction\", self.nodes[0].getrawtransaction, block['merkleroot'])\n \n+    def createrawtransaction_tests(self):\n         self.log.info(\"Test createrawtransaction\")\n         # Test `createrawtransaction` required parameters\n         assert_raises_rpc_error(-1, \"createrawtransaction\", self.nodes[0].createrawtransaction)\n@@ -247,6 +258,7 @@ def run_test(self):\n             self.nodes[2].createrawtransaction(inputs=[{'txid': TXID, 'vout': 9}], outputs=[{address: 99}, {address2: 99}, {'data': '99'}]),\n         )\n \n+    def signrawtransactionwithwallet_tests(self):\n         for type in [\"bech32\", \"p2sh-segwit\", \"legacy\"]:\n             self.log.info(f\"Test signrawtransactionwithwallet with missing prevtx info ({type})\")\n             addr = self.nodes[0].getnewaddress(\"\", type)\n@@ -259,12 +271,12 @@ def run_test(self):\n             prevtx = dict(txid=TXID, scriptPubKey=pubkey, vout=3, amount=1)\n             succ = self.nodes[0].signrawtransactionwithwallet(rawtx, [prevtx])\n             assert succ[\"complete\"]\n+\n             if type == \"legacy\":\n                 del prevtx[\"amount\"]\n                 succ = self.nodes[0].signrawtransactionwithwallet(rawtx, [prevtx])\n                 assert succ[\"complete\"]\n-\n-            if type != \"legacy\":\n+            else:\n                 assert_raises_rpc_error(-3, \"Missing amount\", self.nodes[0].signrawtransactionwithwallet, rawtx, [\n                     {\n                         \"txid\": TXID,\n@@ -295,13 +307,15 @@ def run_test(self):\n                 }\n             ])\n \n+    def sendrawtransaction_tests(self):\n         self.log.info(\"Test sendrawtransaction with missing input\")\n         inputs  = [{'txid' : TXID, 'vout' : 1}]  # won't exist\n         outputs = { self.nodes[0].getnewaddress() : 4.998 }\n         rawtx   = self.nodes[2].createrawtransaction(inputs, outputs)\n         rawtx   = self.nodes[2].signrawtransactionwithwallet(rawtx)\n         assert_raises_rpc_error(-25, \"bad-txns-inputs-missingorspent\", self.nodes[2].sendrawtransaction, rawtx['hex'])\n \n+    def sendrawtransaction_testmempoolaccept_tests(self):\n         self.log.info(\"Test sendrawtransaction/testmempoolaccept with maxfeerate\")\n         # Test a transaction with a small fee.\n         txId = self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(), 1.0)\n@@ -360,6 +374,7 @@ def run_test(self):\n             assert_equal(testres['reject-reason'], 'txn-already-known')\n             assert_raises_rpc_error(-27, 'Transaction already in block chain', node.sendrawtransaction, rawTxSigned['hex'])\n \n+    def decoderawtransaction_tests(self):\n         self.log.info(\"Test decoderawtransaction\")\n         # witness transaction\n         encrawtx = \"010000000001010000000000000072c1a6a246ae63f74f931e8365e15a089c68d61900000000000000000000ffffffff0100e1f50500000000000102616100000000\"\n@@ -378,6 +393,7 @@ def run_test(self):\n         assert_equal(decrawtx, decrawtx_wit) # the witness interpretation should be chosen\n         assert_equal(decrawtx['vin'][0]['coinbase'], \"03c68708046ff8415c622f4254432e434f4d2ffabe6d6de1965d02c68f928e5b244ab1965115a36f56eb997633c7f690124bbf43644e23080000000ca3d3af6d005a65ff0200fd00000000\")\n \n+    def transaction_version_number_tests(self):\n         self.log.info(\"Test transaction version numbers\")\n \n         # Test the minimum transaction version number that fits in a signed 32-bit integer.\n@@ -395,122 +411,122 @@ def run_test(self):\n         decrawtx = self.nodes[0].decoderawtransaction(rawtx)\n         assert_equal(decrawtx['version'], 0x7fffffff)\n \n-        if not self.options.descriptors:\n-            self.log.info(\"Test raw multisig transactions (legacy)\")\n-            # The traditional multisig workflow does not work with descriptor wallets so these are legacy only.\n-            # The multisig workflow with descriptor wallets uses PSBTs and is tested elsewhere, no need to do them here.\n-            # 2of2 test\n-            addr1 = self.nodes[2].getnewaddress()\n-            addr2 = self.nodes[2].getnewaddress()\n-\n-            addr1Obj = self.nodes[2].getaddressinfo(addr1)\n-            addr2Obj = self.nodes[2].getaddressinfo(addr2)\n-\n-            # Tests for createmultisig and addmultisigaddress\n-            assert_raises_rpc_error(-5, \"Invalid public key\", self.nodes[0].createmultisig, 1, [\"01020304\"])\n-            self.nodes[0].createmultisig(2, [addr1Obj['pubkey'], addr2Obj['pubkey']]) # createmultisig can only take public keys\n-            assert_raises_rpc_error(-5, \"Invalid public key\", self.nodes[0].createmultisig, 2, [addr1Obj['pubkey'], addr1]) # addmultisigaddress can take both pubkeys and addresses so long as they are in the wallet, which is tested here.\n-\n-            mSigObj = self.nodes[2].addmultisigaddress(2, [addr1Obj['pubkey'], addr1])['address']\n-\n-            #use balance deltas instead of absolute values\n-            bal = self.nodes[2].getbalance()\n-\n-            # send 1.2 BTC to msig adr\n-            txId = self.nodes[0].sendtoaddress(mSigObj, 1.2)\n-            self.sync_all()\n-            self.nodes[0].generate(1)\n-            self.sync_all()\n-            assert_equal(self.nodes[2].getbalance(), bal+Decimal('1.20000000')) #node2 has both keys of the 2of2 ms addr., tx should affect the balance\n-\n-\n-            # 2of3 test from different nodes\n-            bal = self.nodes[2].getbalance()\n-            addr1 = self.nodes[1].getnewaddress()\n-            addr2 = self.nodes[2].getnewaddress()\n-            addr3 = self.nodes[2].getnewaddress()\n-\n-            addr1Obj = self.nodes[1].getaddressinfo(addr1)\n-            addr2Obj = self.nodes[2].getaddressinfo(addr2)\n-            addr3Obj = self.nodes[2].getaddressinfo(addr3)\n-\n-            mSigObj = self.nodes[2].addmultisigaddress(2, [addr1Obj['pubkey'], addr2Obj['pubkey'], addr3Obj['pubkey']])['address']\n-\n-            txId = self.nodes[0].sendtoaddress(mSigObj, 2.2)\n-            decTx = self.nodes[0].gettransaction(txId)\n-            rawTx = self.nodes[0].decoderawtransaction(decTx['hex'])\n-            self.sync_all()\n-            self.nodes[0].generate(1)\n-            self.sync_all()\n-\n-            #THIS IS AN INCOMPLETE FEATURE\n-            #NODE2 HAS TWO OF THREE KEY AND THE FUNDS SHOULD BE SPENDABLE AND COUNT AT BALANCE CALCULATION\n-            assert_equal(self.nodes[2].getbalance(), bal) #for now, assume the funds of a 2of3 multisig tx are not marked as spendable\n-\n-            txDetails = self.nodes[0].gettransaction(txId, True)\n-            rawTx = self.nodes[0].decoderawtransaction(txDetails['hex'])\n-            vout = next(o for o in rawTx['vout'] if o['value'] == Decimal('2.20000000'))\n-\n-            bal = self.nodes[0].getbalance()\n-            inputs = [{ \"txid\" : txId, \"vout\" : vout['n'], \"scriptPubKey\" : vout['scriptPubKey']['hex'], \"amount\" : vout['value']}]\n-            outputs = { self.nodes[0].getnewaddress() : 2.19 }\n-            rawTx = self.nodes[2].createrawtransaction(inputs, outputs)\n-            rawTxPartialSigned = self.nodes[1].signrawtransactionwithwallet(rawTx, inputs)\n-            assert_equal(rawTxPartialSigned['complete'], False) #node1 only has one key, can't comp. sign the tx\n-\n-            rawTxSigned = self.nodes[2].signrawtransactionwithwallet(rawTx, inputs)\n-            assert_equal(rawTxSigned['complete'], True) #node2 can sign the tx compl., own two of three keys\n-            self.nodes[2].sendrawtransaction(rawTxSigned['hex'])\n-            rawTx = self.nodes[0].decoderawtransaction(rawTxSigned['hex'])\n-            self.sync_all()\n-            self.nodes[0].generate(1)\n-            self.sync_all()\n-            assert_equal(self.nodes[0].getbalance(), bal+Decimal('50.00000000')+Decimal('2.19000000')) #block reward + tx\n-\n-            # 2of2 test for combining transactions\n-            bal = self.nodes[2].getbalance()\n-            addr1 = self.nodes[1].getnewaddress()\n-            addr2 = self.nodes[2].getnewaddress()\n-\n-            addr1Obj = self.nodes[1].getaddressinfo(addr1)\n-            addr2Obj = self.nodes[2].getaddressinfo(addr2)\n-\n-            self.nodes[1].addmultisigaddress(2, [addr1Obj['pubkey'], addr2Obj['pubkey']])['address']\n-            mSigObj = self.nodes[2].addmultisigaddress(2, [addr1Obj['pubkey'], addr2Obj['pubkey']])['address']\n-            mSigObjValid = self.nodes[2].getaddressinfo(mSigObj)\n-\n-            txId = self.nodes[0].sendtoaddress(mSigObj, 2.2)\n-            decTx = self.nodes[0].gettransaction(txId)\n-            rawTx2 = self.nodes[0].decoderawtransaction(decTx['hex'])\n-            self.sync_all()\n-            self.nodes[0].generate(1)\n-            self.sync_all()\n-\n-            assert_equal(self.nodes[2].getbalance(), bal) # the funds of a 2of2 multisig tx should not be marked as spendable\n-\n-            txDetails = self.nodes[0].gettransaction(txId, True)\n-            rawTx2 = self.nodes[0].decoderawtransaction(txDetails['hex'])\n-            vout = next(o for o in rawTx2['vout'] if o['value'] == Decimal('2.20000000'))\n-\n-            bal = self.nodes[0].getbalance()\n-            inputs = [{ \"txid\" : txId, \"vout\" : vout['n'], \"scriptPubKey\" : vout['scriptPubKey']['hex'], \"redeemScript\" : mSigObjValid['hex'], \"amount\" : vout['value']}]\n-            outputs = { self.nodes[0].getnewaddress() : 2.19 }\n-            rawTx2 = self.nodes[2].createrawtransaction(inputs, outputs)\n-            rawTxPartialSigned1 = self.nodes[1].signrawtransactionwithwallet(rawTx2, inputs)\n-            self.log.debug(rawTxPartialSigned1)\n-            assert_equal(rawTxPartialSigned1['complete'], False) #node1 only has one key, can't comp. sign the tx\n-\n-            rawTxPartialSigned2 = self.nodes[2].signrawtransactionwithwallet(rawTx2, inputs)\n-            self.log.debug(rawTxPartialSigned2)\n-            assert_equal(rawTxPartialSigned2['complete'], False) #node2 only has one key, can't comp. sign the tx\n-            rawTxComb = self.nodes[2].combinerawtransaction([rawTxPartialSigned1['hex'], rawTxPartialSigned2['hex']])\n-            self.log.debug(rawTxComb)\n-            self.nodes[2].sendrawtransaction(rawTxComb)\n-            rawTx2 = self.nodes[0].decoderawtransaction(rawTxComb)\n-            self.sync_all()\n-            self.nodes[0].generate(1)\n-            self.sync_all()\n-            assert_equal(self.nodes[0].getbalance(), bal+Decimal('50.00000000')+Decimal('2.19000000')) #block reward + tx\n+    def raw_multisig_transaction_legacy_tests(self):\n+        self.log.info(\"Test raw multisig transactions (legacy)\")\n+        # The traditional multisig workflow does not work with descriptor wallets so these are legacy only.\n+        # The multisig workflow with descriptor wallets uses PSBTs and is tested elsewhere, no need to do them here.\n+        # 2of2 test\n+        addr1 = self.nodes[2].getnewaddress()\n+        addr2 = self.nodes[2].getnewaddress()\n+\n+        addr1Obj = self.nodes[2].getaddressinfo(addr1)\n+        addr2Obj = self.nodes[2].getaddressinfo(addr2)\n+\n+        # Tests for createmultisig and addmultisigaddress\n+        assert_raises_rpc_error(-5, \"Invalid public key\", self.nodes[0].createmultisig, 1, [\"01020304\"])\n+        self.nodes[0].createmultisig(2, [addr1Obj['pubkey'], addr2Obj['pubkey']]) # createmultisig can only take public keys\n+        assert_raises_rpc_error(-5, \"Invalid public key\", self.nodes[0].createmultisig, 2, [addr1Obj['pubkey'], addr1]) # addmultisigaddress can take both pubkeys and addresses so long as they are in the wallet, which is tested here.\n+\n+        mSigObj = self.nodes[2].addmultisigaddress(2, [addr1Obj['pubkey'], addr1])['address']\n+\n+        #use balance deltas instead of absolute values\n+        bal = self.nodes[2].getbalance()\n+\n+        # send 1.2 BTC to msig adr\n+        txId = self.nodes[0].sendtoaddress(mSigObj, 1.2)\n+        self.sync_all()\n+        self.nodes[0].generate(1)\n+        self.sync_all()\n+        assert_equal(self.nodes[2].getbalance(), bal+Decimal('1.20000000')) #node2 has both keys of the 2of2 ms addr., tx should affect the balance\n+\n+\n+        # 2of3 test from different nodes\n+        bal = self.nodes[2].getbalance()\n+        addr1 = self.nodes[1].getnewaddress()\n+        addr2 = self.nodes[2].getnewaddress()\n+        addr3 = self.nodes[2].getnewaddress()\n+\n+        addr1Obj = self.nodes[1].getaddressinfo(addr1)\n+        addr2Obj = self.nodes[2].getaddressinfo(addr2)\n+        addr3Obj = self.nodes[2].getaddressinfo(addr3)\n+\n+        mSigObj = self.nodes[2].addmultisigaddress(2, [addr1Obj['pubkey'], addr2Obj['pubkey'], addr3Obj['pubkey']])['address']\n+\n+        txId = self.nodes[0].sendtoaddress(mSigObj, 2.2)\n+        decTx = self.nodes[0].gettransaction(txId)\n+        rawTx = self.nodes[0].decoderawtransaction(decTx['hex'])\n+        self.sync_all()\n+        self.nodes[0].generate(1)\n+        self.sync_all()\n+\n+        #THIS IS AN INCOMPLETE FEATURE\n+        #NODE2 HAS TWO OF THREE KEY AND THE FUNDS SHOULD BE SPENDABLE AND COUNT AT BALANCE CALCULATION\n+        assert_equal(self.nodes[2].getbalance(), bal) #for now, assume the funds of a 2of3 multisig tx are not marked as spendable\n+\n+        txDetails = self.nodes[0].gettransaction(txId, True)\n+        rawTx = self.nodes[0].decoderawtransaction(txDetails['hex'])\n+        vout = next(o for o in rawTx['vout'] if o['value'] == Decimal('2.20000000'))\n+\n+        bal = self.nodes[0].getbalance()\n+        inputs = [{ \"txid\" : txId, \"vout\" : vout['n'], \"scriptPubKey\" : vout['scriptPubKey']['hex'], \"amount\" : vout['value']}]\n+        outputs = { self.nodes[0].getnewaddress() : 2.19 }\n+        rawTx = self.nodes[2].createrawtransaction(inputs, outputs)\n+        rawTxPartialSigned = self.nodes[1].signrawtransactionwithwallet(rawTx, inputs)\n+        assert_equal(rawTxPartialSigned['complete'], False) #node1 only has one key, can't comp. sign the tx\n+\n+        rawTxSigned = self.nodes[2].signrawtransactionwithwallet(rawTx, inputs)\n+        assert_equal(rawTxSigned['complete'], True) #node2 can sign the tx compl., own two of three keys\n+        self.nodes[2].sendrawtransaction(rawTxSigned['hex'])\n+        rawTx = self.nodes[0].decoderawtransaction(rawTxSigned['hex'])\n+        self.sync_all()\n+        self.nodes[0].generate(1)\n+        self.sync_all()\n+        assert_equal(self.nodes[0].getbalance(), bal+Decimal('50.00000000')+Decimal('2.19000000')) #block reward + tx\n+\n+        # 2of2 test for combining transactions\n+        bal = self.nodes[2].getbalance()\n+        addr1 = self.nodes[1].getnewaddress()\n+        addr2 = self.nodes[2].getnewaddress()\n+\n+        addr1Obj = self.nodes[1].getaddressinfo(addr1)\n+        addr2Obj = self.nodes[2].getaddressinfo(addr2)\n+\n+        self.nodes[1].addmultisigaddress(2, [addr1Obj['pubkey'], addr2Obj['pubkey']])['address']\n+        mSigObj = self.nodes[2].addmultisigaddress(2, [addr1Obj['pubkey'], addr2Obj['pubkey']])['address']\n+        mSigObjValid = self.nodes[2].getaddressinfo(mSigObj)\n+\n+        txId = self.nodes[0].sendtoaddress(mSigObj, 2.2)\n+        decTx = self.nodes[0].gettransaction(txId)\n+        rawTx2 = self.nodes[0].decoderawtransaction(decTx['hex'])\n+        self.sync_all()\n+        self.nodes[0].generate(1)\n+        self.sync_all()\n+\n+        assert_equal(self.nodes[2].getbalance(), bal) # the funds of a 2of2 multisig tx should not be marked as spendable\n+\n+        txDetails = self.nodes[0].gettransaction(txId, True)\n+        rawTx2 = self.nodes[0].decoderawtransaction(txDetails['hex'])\n+        vout = next(o for o in rawTx2['vout'] if o['value'] == Decimal('2.20000000'))\n+\n+        bal = self.nodes[0].getbalance()\n+        inputs = [{ \"txid\" : txId, \"vout\" : vout['n'], \"scriptPubKey\" : vout['scriptPubKey']['hex'], \"redeemScript\" : mSigObjValid['hex'], \"amount\" : vout['value']}]\n+        outputs = { self.nodes[0].getnewaddress() : 2.19 }\n+        rawTx2 = self.nodes[2].createrawtransaction(inputs, outputs)\n+        rawTxPartialSigned1 = self.nodes[1].signrawtransactionwithwallet(rawTx2, inputs)\n+        self.log.debug(rawTxPartialSigned1)\n+        assert_equal(rawTxPartialSigned1['complete'], False) #node1 only has one key, can't comp. sign the tx\n+\n+        rawTxPartialSigned2 = self.nodes[2].signrawtransactionwithwallet(rawTx2, inputs)\n+        self.log.debug(rawTxPartialSigned2)\n+        assert_equal(rawTxPartialSigned2['complete'], False) #node2 only has one key, can't comp. sign the tx\n+        rawTxComb = self.nodes[2].combinerawtransaction([rawTxPartialSigned1['hex'], rawTxPartialSigned2['hex']])\n+        self.log.debug(rawTxComb)\n+        self.nodes[2].sendrawtransaction(rawTxComb)\n+        rawTx2 = self.nodes[0].decoderawtransaction(rawTxComb)\n+        self.sync_all()\n+        self.nodes[0].generate(1)\n+        self.sync_all()\n+        assert_equal(self.nodes[0].getbalance(), bal+Decimal('50.00000000')+Decimal('2.19000000')) #block reward + tx\n \n \n if __name__ == '__main__':"
      }
    ]
  },
  {
    "sha": "387355bb9482a09c1fc9b137bea56745a93b7dfd",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozODczNTViYjk0ODJhMDljMWZjOWIxMzdiZWE1Njc0NWE5M2I3ZGZk",
    "commit": {
      "author": {
        "name": "Jon Atack",
        "email": "jon@atack.com",
        "date": "2021-07-12T14:38:36Z"
      },
      "committer": {
        "name": "Jon Atack",
        "email": "jon@atack.com",
        "date": "2021-08-31T19:59:51Z"
      },
      "message": "test, refactor: rpc_rawtransaction PEP8",
      "tree": {
        "sha": "ac8214d1b3ba3f5cbf3195296358a1f9dd3a9c26",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ac8214d1b3ba3f5cbf3195296358a1f9dd3a9c26"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/387355bb9482a09c1fc9b137bea56745a93b7dfd",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEd6u7+MhX7zEv6RP5T1chs9Djkh0FAmEuijcACgkQT1chs9Dj\nkh3Rqg//R9J+vy37ypt31RkBjNUk2QIYn+2cHWcG3FsXhcWTMob7q9iW8gvoccXi\nvwFJjU8Eet/58vhbKeqy4nLBJmshftEyjJlgcIZ5be2uUoV+gb4ryUDKwRdm2jp7\nwbihG1dvJ7Zp4o0IOcQeih0rcS93CL/jM3X9tQp2qoaksmjWHMhNIHmggkj2Tmp5\nW/UUN1HFPpIhwHOiVNPXCoTmK0h0Ki0RBGj7aXzeJnO++zJXcfDL901Np4jUNeSO\nKzsnuB35q7r/0IYmNmBUQAavgatnyRorg6yVOcauO+Jgref6ACjJav1VTT0istKN\nj7iLV08wcnfEkK+5qHp4ueiSGfn/yVcyuHn9q/o6p38Pqks+qTMFLjmwJ2PsuhG3\nTh3j4v/VeqEy+H9kIPCqJfGcIA5dB8zKU1MqhSUbmNGq7m25AD3OpqbqaLpPkAp7\nIYChSd0AVTKb3yLtxp9zrzbpcJosLfVfx3RMl1IfRun44RbRk/MYZ79jz8K5NmsU\nZ7m+TRrZVVymrhED/3EhMPCy1W1dhKJapnrRa2svRJTQIFXtne8Z0m7I3IfpxlOE\nPglROBxv/Lazj+wgP+U9ydCllzaN61UiMRhbI/7vOW0roHGTCQdJulS2lLQKL7/k\nC7YrVJcdq1/59bpwUsSCF9C38OhU9vZOejscaw+Tb1jaTKsKMQs=\n=KOc7\n-----END PGP SIGNATURE-----\n-----BEGIN OPENTIMESTAMPS GIT TIMESTAMP-----\n\nAQHwIGimXQgdFMHZTg7rJPzLv6FUV2iIJSITcs0Fimvssi3SCP/wEDAUoUjIsQKr\nEV8AazAS2ZEI8QRhLoo48AijZ3Svzk4iJQCD3+MNLvkMjiwraHR0cHM6Ly9ib2Iu\nYnRjLmNhbGVuZGFyLm9wZW50aW1lc3RhbXBzLm9yZ//wEJWRSQTzOYme215ghhQF\nKIoI8QRhLoo58Aibxo3T64W4PwCD3+MNLvkMjiMiaHR0cHM6Ly9idGMuY2FsZW5k\nYXIuY2F0YWxsYXh5LmNvbf/wEOWdBWEFcZmFF860kApG1ScI8CDoIEEqCyLpbY9/\nNCLwuErnFJAYPAWrIQ/vVnmC6DnfEwjxBGEuijnwCA5Ogerb/1WdAIPf4w0u+QyO\nKShodHRwczovL2Zpbm5leS5jYWxlbmRhci5ldGVybml0eXdhbGwuY29t8BDzRtKW\nL4KnbnT0hQkmNqBhCPEEYS6KOfAIH0cExnlrerkAg9/jDS75DI4uLWh0dHBzOi8v\nYWxpY2UuYnRjLmNhbGVuZGFyLm9wZW50aW1lc3RhbXBzLm9yZw==\n-----END OPENTIMESTAMPS GIT TIMESTAMP-----",
        "payload": "tree ac8214d1b3ba3f5cbf3195296358a1f9dd3a9c26\nparent 7d5cec2e498dc059ff1d74a2b60764db45923264\nauthor Jon Atack <jon@atack.com> 1626100716 +0200\ncommitter Jon Atack <jon@atack.com> 1630439991 +0200\n\ntest, refactor: rpc_rawtransaction PEP8\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/387355bb9482a09c1fc9b137bea56745a93b7dfd",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/387355bb9482a09c1fc9b137bea56745a93b7dfd",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/387355bb9482a09c1fc9b137bea56745a93b7dfd/comments",
    "author": {
      "login": "jonatack",
      "id": 2415484,
      "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonatack",
      "html_url": "https://github.com/jonatack",
      "followers_url": "https://api.github.com/users/jonatack/followers",
      "following_url": "https://api.github.com/users/jonatack/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonatack/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
      "organizations_url": "https://api.github.com/users/jonatack/orgs",
      "repos_url": "https://api.github.com/users/jonatack/repos",
      "events_url": "https://api.github.com/users/jonatack/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonatack/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jonatack",
      "id": 2415484,
      "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonatack",
      "html_url": "https://github.com/jonatack",
      "followers_url": "https://api.github.com/users/jonatack/followers",
      "following_url": "https://api.github.com/users/jonatack/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonatack/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
      "organizations_url": "https://api.github.com/users/jonatack/orgs",
      "repos_url": "https://api.github.com/users/jonatack/repos",
      "events_url": "https://api.github.com/users/jonatack/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonatack/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7d5cec2e498dc059ff1d74a2b60764db45923264",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7d5cec2e498dc059ff1d74a2b60764db45923264",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7d5cec2e498dc059ff1d74a2b60764db45923264"
      }
    ],
    "stats": {
      "total": 90,
      "additions": 49,
      "deletions": 41
    },
    "files": [
      {
        "sha": "fbf8c6ef15384e336e5a660cdc6a80914f0889c4",
        "filename": "test/functional/rpc_rawtransaction.py",
        "status": "modified",
        "additions": 49,
        "deletions": 41,
        "changes": 90,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/387355bb9482a09c1fc9b137bea56745a93b7dfd/test/functional/rpc_rawtransaction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/387355bb9482a09c1fc9b137bea56745a93b7dfd/test/functional/rpc_rawtransaction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_rawtransaction.py?ref=387355bb9482a09c1fc9b137bea56745a93b7dfd",
        "patch": "@@ -78,9 +78,8 @@ def run_test(self):\n         self.sync_all()\n         self.nodes[0].generate(COINBASE_MATURITY + 1)\n         self.sync_all()\n-        self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(),1.5)\n-        self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(),1.0)\n-        self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(),5.0)\n+        for amount in [1.5, 1.0, 5.0]:\n+            self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(), amount)\n         self.sync_all()\n         self.nodes[0].generate(5)\n         self.sync_all()\n@@ -192,7 +191,8 @@ def createrawtransaction_tests(self):\n         assert_raises_rpc_error(-1, \"JSON value is not an object as expected\", self.nodes[0].createrawtransaction, ['foo'], {})\n         assert_raises_rpc_error(-1, \"JSON value is not a string as expected\", self.nodes[0].createrawtransaction, [{}], {})\n         assert_raises_rpc_error(-8, \"txid must be of length 64 (not 3, for 'foo')\", self.nodes[0].createrawtransaction, [{'txid': 'foo'}], {})\n-        assert_raises_rpc_error(-8, \"txid must be hexadecimal string (not 'ZZZ7bb8b1697ea987f3b223ba7819250cae33efacb068d23dc24859824a77844')\", self.nodes[0].createrawtransaction, [{'txid': 'ZZZ7bb8b1697ea987f3b223ba7819250cae33efacb068d23dc24859824a77844'}], {})\n+        txid = \"ZZZ7bb8b1697ea987f3b223ba7819250cae33efacb068d23dc24859824a77844\"\n+        assert_raises_rpc_error(-8, f\"txid must be hexadecimal string (not '{txid}')\", self.nodes[0].createrawtransaction, [{'txid': txid}], {})\n         assert_raises_rpc_error(-8, \"Invalid parameter, missing vout key\", self.nodes[0].createrawtransaction, [{'txid': TXID}], {})\n         assert_raises_rpc_error(-8, \"Invalid parameter, missing vout key\", self.nodes[0].createrawtransaction, [{'txid': TXID, 'vout': 'foo'}], {})\n         assert_raises_rpc_error(-8, \"Invalid parameter, vout cannot be negative\", self.nodes[0].createrawtransaction, [{'txid': TXID, 'vout': -1}], {})\n@@ -264,9 +264,9 @@ def signrawtransactionwithwallet_tests(self):\n             addr = self.nodes[0].getnewaddress(\"\", type)\n             addrinfo = self.nodes[0].getaddressinfo(addr)\n             pubkey = addrinfo[\"scriptPubKey\"]\n-            inputs  = [ {'txid' : TXID, 'vout' : 3, 'sequence' : 1000}]\n-            outputs = { self.nodes[0].getnewaddress() : 1 }\n-            rawtx   = self.nodes[0].createrawtransaction(inputs, outputs)\n+            inputs = [{'txid': TXID, 'vout': 3, 'sequence': 1000}]\n+            outputs = {self.nodes[0].getnewaddress(): 1}\n+            rawtx = self.nodes[0].createrawtransaction(inputs, outputs)\n \n             prevtx = dict(txid=TXID, scriptPubKey=pubkey, vout=3, amount=1)\n             succ = self.nodes[0].signrawtransactionwithwallet(rawtx, [prevtx])\n@@ -309,23 +309,25 @@ def signrawtransactionwithwallet_tests(self):\n \n     def sendrawtransaction_tests(self):\n         self.log.info(\"Test sendrawtransaction with missing input\")\n-        inputs  = [{'txid' : TXID, 'vout' : 1}]  # won't exist\n-        outputs = { self.nodes[0].getnewaddress() : 4.998 }\n-        rawtx   = self.nodes[2].createrawtransaction(inputs, outputs)\n-        rawtx   = self.nodes[2].signrawtransactionwithwallet(rawtx)\n+        inputs = [{'txid': TXID, 'vout': 1}]  # won't exist\n+        outputs = {self.nodes[0].getnewaddress(): 4.998}\n+        rawtx = self.nodes[2].createrawtransaction(inputs, outputs)\n+        rawtx = self.nodes[2].signrawtransactionwithwallet(rawtx)\n         assert_raises_rpc_error(-25, \"bad-txns-inputs-missingorspent\", self.nodes[2].sendrawtransaction, rawtx['hex'])\n \n     def sendrawtransaction_testmempoolaccept_tests(self):\n         self.log.info(\"Test sendrawtransaction/testmempoolaccept with maxfeerate\")\n+        fee_exceeds_max = \"Fee exceeds maximum configured by user (e.g. -maxtxfee, maxfeerate)\"\n+\n         # Test a transaction with a small fee.\n         txId = self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(), 1.0)\n         rawTx = self.nodes[0].getrawtransaction(txId, True)\n         vout = next(o for o in rawTx['vout'] if o['value'] == Decimal('1.00000000'))\n \n         self.sync_all()\n-        inputs = [{ \"txid\" : txId, \"vout\" : vout['n'] }]\n+        inputs = [{\"txid\": txId, \"vout\": vout['n']}]\n         # Fee 10,000 satoshis, (1 - (10000 sat * 0.00000001 BTC/sat)) = 0.9999\n-        outputs = { self.nodes[0].getnewaddress() : Decimal(\"0.99990000\") }\n+        outputs = {self.nodes[0].getnewaddress(): Decimal(\"0.99990000\")}\n         rawTx = self.nodes[2].createrawtransaction(inputs, outputs)\n         rawTxSigned = self.nodes[2].signrawtransactionwithwallet(rawTx)\n         assert_equal(rawTxSigned['complete'], True)\n@@ -335,7 +337,7 @@ def sendrawtransaction_testmempoolaccept_tests(self):\n         assert_equal(testres['allowed'], False)\n         assert_equal(testres['reject-reason'], 'max-fee-exceeded')\n         # and sendrawtransaction should throw\n-        assert_raises_rpc_error(-25, 'Fee exceeds maximum configured by user (e.g. -maxtxfee, maxfeerate)', self.nodes[2].sendrawtransaction, rawTxSigned['hex'], 0.00001000)\n+        assert_raises_rpc_error(-25, fee_exceeds_max, self.nodes[2].sendrawtransaction, rawTxSigned['hex'], 0.00001000)\n         # and the following calls should both succeed\n         testres = self.nodes[2].testmempoolaccept(rawtxs=[rawTxSigned['hex']])[0]\n         assert_equal(testres['allowed'], True)\n@@ -347,9 +349,9 @@ def sendrawtransaction_testmempoolaccept_tests(self):\n         vout = next(o for o in rawTx['vout'] if o['value'] == Decimal('1.00000000'))\n \n         self.sync_all()\n-        inputs = [{ \"txid\" : txId, \"vout\" : vout['n'] }]\n+        inputs = [{\"txid\": txId, \"vout\": vout['n']}]\n         # Fee 2,000,000 satoshis, (1 - (2000000 sat * 0.00000001 BTC/sat)) = 0.98\n-        outputs = { self.nodes[0].getnewaddress() : Decimal(\"0.98000000\") }\n+        outputs = {self.nodes[0].getnewaddress() : Decimal(\"0.98000000\")}\n         rawTx = self.nodes[2].createrawtransaction(inputs, outputs)\n         rawTxSigned = self.nodes[2].signrawtransactionwithwallet(rawTx)\n         assert_equal(rawTxSigned['complete'], True)\n@@ -359,7 +361,7 @@ def sendrawtransaction_testmempoolaccept_tests(self):\n         assert_equal(testres['allowed'], False)\n         assert_equal(testres['reject-reason'], 'max-fee-exceeded')\n         # and sendrawtransaction should throw\n-        assert_raises_rpc_error(-25, 'Fee exceeds maximum configured by user (e.g. -maxtxfee, maxfeerate)', self.nodes[2].sendrawtransaction, rawTxSigned['hex'])\n+        assert_raises_rpc_error(-25, fee_exceeds_max, self.nodes[2].sendrawtransaction, rawTxSigned['hex'])\n         # and the following calls should both succeed\n         testres = self.nodes[2].testmempoolaccept(rawtxs=[rawTxSigned['hex']], maxfeerate='0.20000000')[0]\n         assert_equal(testres['allowed'], True)\n@@ -378,20 +380,22 @@ def decoderawtransaction_tests(self):\n         self.log.info(\"Test decoderawtransaction\")\n         # witness transaction\n         encrawtx = \"010000000001010000000000000072c1a6a246ae63f74f931e8365e15a089c68d61900000000000000000000ffffffff0100e1f50500000000000102616100000000\"\n-        decrawtx = self.nodes[0].decoderawtransaction(encrawtx, True) # decode as witness transaction\n+        decrawtx = self.nodes[0].decoderawtransaction(encrawtx, True)  # decode as witness transaction\n         assert_equal(decrawtx['vout'][0]['value'], Decimal('1.00000000'))\n         assert_raises_rpc_error(-22, 'TX decode failed', self.nodes[0].decoderawtransaction, encrawtx, False) # force decode as non-witness transaction\n         # non-witness transaction\n         encrawtx = \"01000000010000000000000072c1a6a246ae63f74f931e8365e15a089c68d61900000000000000000000ffffffff0100e1f505000000000000000000\"\n-        decrawtx = self.nodes[0].decoderawtransaction(encrawtx, False) # decode as non-witness transaction\n+        decrawtx = self.nodes[0].decoderawtransaction(encrawtx, False)  # decode as non-witness transaction\n         assert_equal(decrawtx['vout'][0]['value'], Decimal('1.00000000'))\n         # known ambiguous transaction in the chain (see https://github.com/bitcoin/bitcoin/issues/20579)\n-        encrawtx = \"020000000001010000000000000000000000000000000000000000000000000000000000000000ffffffff4b03c68708046ff8415c622f4254432e434f4d2ffabe6d6de1965d02c68f928e5b244ab1965115a36f56eb997633c7f690124bbf43644e23080000000ca3d3af6d005a65ff0200fd00000000ffffffff03f4c1fb4b0000000016001497cfc76442fe717f2a3f0cc9c175f7561b6619970000000000000000266a24aa21a9ed957d1036a80343e0d1b659497e1b48a38ebe876a056d45965fac4a85cda84e1900000000000000002952534b424c4f434b3a8e092581ab01986cbadc84f4b43f4fa4bb9e7a2e2a0caf9b7cf64d939028e22c0120000000000000000000000000000000000000000000000000000000000000000000000000\"\n+        coinbase = \"03c68708046ff8415c622f4254432e434f4d2ffabe6d6de1965d02c68f928e5b244ab1965115a36f56eb997633c7f690124bbf43644e23080000000ca3d3af6d005a65ff0200fd00000000\"\n+        encrawtx = f\"020000000001010000000000000000000000000000000000000000000000000000000000000000ffffffff4b{coinbase}\" \\\n+                   \"ffffffff03f4c1fb4b0000000016001497cfc76442fe717f2a3f0cc9c175f7561b6619970000000000000000266a24aa21a9ed957d1036a80343e0d1b659497e1b48a38ebe876a056d45965fac4a85cda84e1900000000000000002952534b424c4f434b3a8e092581ab01986cbadc84f4b43f4fa4bb9e7a2e2a0caf9b7cf64d939028e22c0120000000000000000000000000000000000000000000000000000000000000000000000000\"\n         decrawtx = self.nodes[0].decoderawtransaction(encrawtx)\n         decrawtx_wit = self.nodes[0].decoderawtransaction(encrawtx, True)\n-        assert_raises_rpc_error(-22, 'TX decode failed', self.nodes[0].decoderawtransaction, encrawtx, False) # fails to decode as non-witness transaction\n-        assert_equal(decrawtx, decrawtx_wit) # the witness interpretation should be chosen\n-        assert_equal(decrawtx['vin'][0]['coinbase'], \"03c68708046ff8415c622f4254432e434f4d2ffabe6d6de1965d02c68f928e5b244ab1965115a36f56eb997633c7f690124bbf43644e23080000000ca3d3af6d005a65ff0200fd00000000\")\n+        assert_raises_rpc_error(-22, 'TX decode failed', self.nodes[0].decoderawtransaction, encrawtx, False)  # fails to decode as non-witness transaction\n+        assert_equal(decrawtx, decrawtx_wit)  # the witness interpretation should be chosen\n+        assert_equal(decrawtx['vin'][0]['coinbase'], coinbase)\n \n     def transaction_version_number_tests(self):\n         self.log.info(\"Test transaction version numbers\")\n@@ -415,6 +419,7 @@ def raw_multisig_transaction_legacy_tests(self):\n         self.log.info(\"Test raw multisig transactions (legacy)\")\n         # The traditional multisig workflow does not work with descriptor wallets so these are legacy only.\n         # The multisig workflow with descriptor wallets uses PSBTs and is tested elsewhere, no need to do them here.\n+\n         # 2of2 test\n         addr1 = self.nodes[2].getnewaddress()\n         addr2 = self.nodes[2].getnewaddress()\n@@ -424,20 +429,23 @@ def raw_multisig_transaction_legacy_tests(self):\n \n         # Tests for createmultisig and addmultisigaddress\n         assert_raises_rpc_error(-5, \"Invalid public key\", self.nodes[0].createmultisig, 1, [\"01020304\"])\n-        self.nodes[0].createmultisig(2, [addr1Obj['pubkey'], addr2Obj['pubkey']]) # createmultisig can only take public keys\n-        assert_raises_rpc_error(-5, \"Invalid public key\", self.nodes[0].createmultisig, 2, [addr1Obj['pubkey'], addr1]) # addmultisigaddress can take both pubkeys and addresses so long as they are in the wallet, which is tested here.\n+        # createmultisig can only take public keys\n+        self.nodes[0].createmultisig(2, [addr1Obj['pubkey'], addr2Obj['pubkey']])\n+        # addmultisigaddress can take both pubkeys and addresses so long as they are in the wallet, which is tested here\n+        assert_raises_rpc_error(-5, \"Invalid public key\", self.nodes[0].createmultisig, 2, [addr1Obj['pubkey'], addr1])\n \n         mSigObj = self.nodes[2].addmultisigaddress(2, [addr1Obj['pubkey'], addr1])['address']\n \n-        #use balance deltas instead of absolute values\n+        # use balance deltas instead of absolute values\n         bal = self.nodes[2].getbalance()\n \n         # send 1.2 BTC to msig adr\n         txId = self.nodes[0].sendtoaddress(mSigObj, 1.2)\n         self.sync_all()\n         self.nodes[0].generate(1)\n         self.sync_all()\n-        assert_equal(self.nodes[2].getbalance(), bal+Decimal('1.20000000')) #node2 has both keys of the 2of2 ms addr., tx should affect the balance\n+        # node2 has both keys of the 2of2 ms addr, tx should affect the balance\n+        assert_equal(self.nodes[2].getbalance(), bal + Decimal('1.20000000'))\n \n \n         # 2of3 test from different nodes\n@@ -459,29 +467,29 @@ def raw_multisig_transaction_legacy_tests(self):\n         self.nodes[0].generate(1)\n         self.sync_all()\n \n-        #THIS IS AN INCOMPLETE FEATURE\n-        #NODE2 HAS TWO OF THREE KEY AND THE FUNDS SHOULD BE SPENDABLE AND COUNT AT BALANCE CALCULATION\n-        assert_equal(self.nodes[2].getbalance(), bal) #for now, assume the funds of a 2of3 multisig tx are not marked as spendable\n+        # THIS IS AN INCOMPLETE FEATURE\n+        # NODE2 HAS TWO OF THREE KEYS AND THE FUNDS SHOULD BE SPENDABLE AND COUNT AT BALANCE CALCULATION\n+        assert_equal(self.nodes[2].getbalance(), bal)  # for now, assume the funds of a 2of3 multisig tx are not marked as spendable\n \n         txDetails = self.nodes[0].gettransaction(txId, True)\n         rawTx = self.nodes[0].decoderawtransaction(txDetails['hex'])\n         vout = next(o for o in rawTx['vout'] if o['value'] == Decimal('2.20000000'))\n \n         bal = self.nodes[0].getbalance()\n-        inputs = [{ \"txid\" : txId, \"vout\" : vout['n'], \"scriptPubKey\" : vout['scriptPubKey']['hex'], \"amount\" : vout['value']}]\n-        outputs = { self.nodes[0].getnewaddress() : 2.19 }\n+        inputs = [{\"txid\": txId, \"vout\": vout['n'], \"scriptPubKey\": vout['scriptPubKey']['hex'], \"amount\": vout['value']}]\n+        outputs = {self.nodes[0].getnewaddress(): 2.19}\n         rawTx = self.nodes[2].createrawtransaction(inputs, outputs)\n         rawTxPartialSigned = self.nodes[1].signrawtransactionwithwallet(rawTx, inputs)\n-        assert_equal(rawTxPartialSigned['complete'], False) #node1 only has one key, can't comp. sign the tx\n+        assert_equal(rawTxPartialSigned['complete'], False)  # node1 only has one key, can't comp. sign the tx\n \n         rawTxSigned = self.nodes[2].signrawtransactionwithwallet(rawTx, inputs)\n-        assert_equal(rawTxSigned['complete'], True) #node2 can sign the tx compl., own two of three keys\n+        assert_equal(rawTxSigned['complete'], True)  # node2 can sign the tx compl., own two of three keys\n         self.nodes[2].sendrawtransaction(rawTxSigned['hex'])\n         rawTx = self.nodes[0].decoderawtransaction(rawTxSigned['hex'])\n         self.sync_all()\n         self.nodes[0].generate(1)\n         self.sync_all()\n-        assert_equal(self.nodes[0].getbalance(), bal+Decimal('50.00000000')+Decimal('2.19000000')) #block reward + tx\n+        assert_equal(self.nodes[0].getbalance(), bal + Decimal('50.00000000') + Decimal('2.19000000'))  # block reward + tx\n \n         # 2of2 test for combining transactions\n         bal = self.nodes[2].getbalance()\n@@ -502,31 +510,31 @@ def raw_multisig_transaction_legacy_tests(self):\n         self.nodes[0].generate(1)\n         self.sync_all()\n \n-        assert_equal(self.nodes[2].getbalance(), bal) # the funds of a 2of2 multisig tx should not be marked as spendable\n+        assert_equal(self.nodes[2].getbalance(), bal)  # the funds of a 2of2 multisig tx should not be marked as spendable\n \n         txDetails = self.nodes[0].gettransaction(txId, True)\n         rawTx2 = self.nodes[0].decoderawtransaction(txDetails['hex'])\n         vout = next(o for o in rawTx2['vout'] if o['value'] == Decimal('2.20000000'))\n \n         bal = self.nodes[0].getbalance()\n-        inputs = [{ \"txid\" : txId, \"vout\" : vout['n'], \"scriptPubKey\" : vout['scriptPubKey']['hex'], \"redeemScript\" : mSigObjValid['hex'], \"amount\" : vout['value']}]\n-        outputs = { self.nodes[0].getnewaddress() : 2.19 }\n+        inputs = [{\"txid\": txId, \"vout\": vout['n'], \"scriptPubKey\": vout['scriptPubKey']['hex'], \"redeemScript\": mSigObjValid['hex'], \"amount\": vout['value']}]\n+        outputs = {self.nodes[0].getnewaddress(): 2.19}\n         rawTx2 = self.nodes[2].createrawtransaction(inputs, outputs)\n         rawTxPartialSigned1 = self.nodes[1].signrawtransactionwithwallet(rawTx2, inputs)\n         self.log.debug(rawTxPartialSigned1)\n-        assert_equal(rawTxPartialSigned1['complete'], False) #node1 only has one key, can't comp. sign the tx\n+        assert_equal(rawTxPartialSigned1['complete'], False)  # node1 only has one key, can't comp. sign the tx\n \n         rawTxPartialSigned2 = self.nodes[2].signrawtransactionwithwallet(rawTx2, inputs)\n         self.log.debug(rawTxPartialSigned2)\n-        assert_equal(rawTxPartialSigned2['complete'], False) #node2 only has one key, can't comp. sign the tx\n+        assert_equal(rawTxPartialSigned2['complete'], False)  # node2 only has one key, can't comp. sign the tx\n         rawTxComb = self.nodes[2].combinerawtransaction([rawTxPartialSigned1['hex'], rawTxPartialSigned2['hex']])\n         self.log.debug(rawTxComb)\n         self.nodes[2].sendrawtransaction(rawTxComb)\n         rawTx2 = self.nodes[0].decoderawtransaction(rawTxComb)\n         self.sync_all()\n         self.nodes[0].generate(1)\n         self.sync_all()\n-        assert_equal(self.nodes[0].getbalance(), bal+Decimal('50.00000000')+Decimal('2.19000000')) #block reward + tx\n+        assert_equal(self.nodes[0].getbalance(), bal + Decimal('50.00000000') + Decimal('2.19000000'))  # block reward + tx\n \n \n if __name__ == '__main__':"
      }
    ]
  }
]