[
  {
    "sha": "b42ace679c7247b11f6428d9c5eea55af90c1cbf",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiNDJhY2U2NzljNzI0N2IxMWY2NDI4ZDljNWVlYTU1YWY5MGMxY2Jm",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-05-27T17:07:34Z"
      },
      "committer": {
        "name": "Jonas Schnelli",
        "email": "jonas.schnelli@include7.ch",
        "date": "2015-02-05T08:40:33Z"
      },
      "message": "logdb: an safe append-only key-value store\n\nConflicts:\n\tsrc/makefile.unix",
      "tree": {
        "sha": "3632d14769c2e9d8c1d3c9062d91da4f5df87e42",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3632d14769c2e9d8c1d3c9062d91da4f5df87e42"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b42ace679c7247b11f6428d9c5eea55af90c1cbf",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b42ace679c7247b11f6428d9c5eea55af90c1cbf",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b42ace679c7247b11f6428d9c5eea55af90c1cbf",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b42ace679c7247b11f6428d9c5eea55af90c1cbf/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1c4e3f99f05273e4d0fae7246d3afe5a33c52ee0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1c4e3f99f05273e4d0fae7246d3afe5a33c52ee0",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1c4e3f99f05273e4d0fae7246d3afe5a33c52ee0"
      }
    ],
    "stats": {
      "total": 665,
      "additions": 665,
      "deletions": 0
    },
    "files": [
      {
        "sha": "8f65036befdddc7558251958e3d56a27e2994d6b",
        "filename": "src/logdb.cpp",
        "status": "added",
        "additions": 488,
        "deletions": 0,
        "changes": 488,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b42ace679c7247b11f6428d9c5eea55af90c1cbf/src/logdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b42ace679c7247b11f6428d9c5eea55af90c1cbf/src/logdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/logdb.cpp?ref=b42ace679c7247b11f6428d9c5eea55af90c1cbf",
        "patch": "@@ -0,0 +1,488 @@\n+// Copyright (c) 2012 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file license.txt or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <stdio.h>\n+#include <unistd.h>\n+\n+#include \"logdb.h\"\n+\n+using namespace std;\n+\n+// Compact integers: least-significant digit first base-128 encoding.\n+// The high bit in each byte signifies whether another digit follows.\n+// To avoid redundancy, one is subtracted from all but the first digit.\n+// Thus, the byte sequence a[] where all but the last has bit 128 set,\n+// encodes the number (a[0] & 0x7F) + sum(i=1..n, 128^i*((a[i] & 0x7F)+1))\n+\n+size_t static WriteInt(FILE* file, uint64 n)\n+{\n+    int nRet = 0;\n+    do\n+    {\n+        nRet++;\n+        putc((n % 128) | (n>127)*128, file);\n+        if (n<128)\n+            break;\n+        n = (n / 128)-1;\n+    } while(1);\n+    return nRet;\n+}\n+\n+int static ReadInt(FILE *file)\n+{\n+    uint64_t nRet = 0;\n+    uint64_t nBase = 1;\n+    while (nBase)\n+    {\n+        int nByte = getc(file);\n+        nRet += nBase * ((nByte & 127) + (nBase>1));\n+        if (nByte < 128)\n+            break;\n+        nBase *= 128;\n+    }\n+    return nRet;\n+}\n+\n+// File format\n+// \n+// The file consists of a list of frames, each of which consists of:\n+// 4 bytes magic: 0xCC 0xC4 0xE6 0xB0\n+// N records, each of which consists of:\n+//   1 byte mode: 1=insert/overwrite, 2=erase\n+//   integer: key length (max 4 KiB)\n+//   key\n+//   if mode==1: integer: data length (max 1 MiB)\n+//   if mode==1: data\n+// 0 byte\n+// 8 bytes checksum: first 8 bytes of running SHA256\n+\n+class CModEntry\n+{\n+public:\n+    unsigned char nMode;\n+    data_t key;\n+    data_t value;\n+};\n+\n+void CLogDBFile::Init_()\n+{\n+    file = NULL;\n+    SHA256_Init(&ctxState);\n+    mapData.clear();\n+    nUsed = 0;\n+    nWritten = 0;\n+    setDirty.clear();\n+}\n+\n+bool CLogDBFile::Write_(const data_t &key, const data_t &value, bool fOverwrite, bool fLoad)\n+{\n+    if (!fLoad)\n+        return false;\n+\n+    // update nUsed\n+    std::map<data_t, data_t>::iterator it = mapData.find(key);\n+    if (it != mapData.end())\n+    {\n+        if ((*it).second == value)\n+            return true;\n+\n+        if (!fOverwrite)\n+            return false;\n+        nUsed -= (*it).first.size() + (*it).second.size();\n+    }\n+    nUsed += key.size() + value.size();\n+\n+    // update data\n+    mapData.insert(make_pair(key, value));\n+    if (!fLoad)\n+        setDirty.insert(key);\n+\n+    return true;\n+}\n+\n+bool CLogDBFile::Read_(const data_t &key, data_t &value) const\n+{\n+    std::map<data_t, data_t>::const_iterator it = mapData.find(key);\n+    if (it == mapData.end())\n+        return false;\n+\n+    value = (*it).second;\n+\n+    return true;\n+}\n+\n+bool CLogDBFile::Exists_(const data_t &key) const\n+{\n+    return mapData.count(key) > 0;\n+}\n+\n+bool CLogDBFile::Erase_(const data_t &key, bool fLoad)\n+{\n+    if (!fLoad)\n+        return false;\n+\n+    std::map<data_t, data_t>::iterator it = mapData.find(key);\n+    if (it != mapData.end())\n+    {\n+        nUsed -= (*it).first.size() + (*it).second.size();\n+        mapData.erase(it);\n+        if (!fLoad)\n+            setDirty.insert(key);\n+    }\n+\n+    return true;\n+}\n+\n+bool CLogDBFile::Close_()\n+{\n+    if (file)\n+    {\n+        Flush_();\n+        fclose(file);\n+        Init_();\n+    }\n+    return true;\n+}\n+\n+bool CLogDBFile::Load_()\n+{\n+    do\n+    {\n+        if (feof(file))\n+            return true;\n+        if (getc(file) != 0xCC) return feof(file);\n+        if (getc(file) != 0xC4) return false;\n+        if (getc(file) != 0xE6) return false;\n+        if (getc(file) != 0xB0) return false;\n+\n+        printf(\"CLogDB::Load(): frame header found\\n\");\n+\n+        vector<CModEntry> vMod;\n+\n+        // update a copy of the state, so we can revert in case of error\n+        SHA256_CTX ctx = ctxState;\n+\n+        do\n+        {\n+            if (feof(file))\n+            {\n+                printf(\"CLogDB::Load(): unexpected eof at record start\\n\");\n+                return false;\n+            }\n+\n+            CModEntry entry;\n+            entry.nMode = getc(file);\n+            if (entry.nMode > 2)\n+            {\n+                printf(\"CLogDB::Load(): unknown record mode\\n\");\n+                return false;\n+            }\n+\n+            SHA256_Update(&ctx, &entry.nMode, 1);\n+\n+            if (entry.nMode == 0)\n+                break;\n+\n+            printf(\"CLogDB::Load(): loading record mode %i\\n\", entry.nMode);\n+\n+            uint32_t nKeySize = ReadInt(file);\n+            if (nKeySize >= 0x1000)\n+            {\n+                printf(\"CLogDB::Load(): oversizes key (%lu bytes)\\n\", (unsigned long)nKeySize);\n+                return false;\n+            }\n+            entry.key.resize(nKeySize);\n+            if (fread(&entry.key[0], nKeySize, 1, file) != 1)\n+            {\n+                printf(\"CLogDB::Load(): unable to read key (%lu bytes)\\n\", (unsigned long)nKeySize);\n+                return false;\n+            }\n+\n+            printf(\"CLogDB::load(): loading key (%.*s)\\n\", nKeySize, &entry.key[0]);\n+\n+            SHA256_Update(&ctx, &nKeySize, 4);\n+            SHA256_Update(&ctx, &entry.key[0], nKeySize);\n+\n+            if (entry.nMode == 1)\n+            {\n+                int nValueSize = ReadInt(file);\n+                if (nValueSize >= 0x100000)\n+                {\n+                    printf(\"CLogDB::Load(): oversized value (%lu bytes)\\n\", (unsigned long)nValueSize);\n+                    return false;\n+                }\n+                entry.value.resize(nValueSize);\n+                if (fread(&entry.value[0], nValueSize, 1, file) != 1)\n+                {\n+                    printf(\"CLogDB::Load(): unable to read value (%lu bytes)\\n\", (unsigned long)nValueSize);\n+                    return false;\n+                }\n+\n+                SHA256_Update(&ctx, &nValueSize, 4);\n+                SHA256_Update(&ctx, &entry.value[0], nValueSize);\n+            }\n+\n+            vMod.push_back(entry);\n+        } while(true);\n+\n+        unsigned char check[8];\n+        if (fread(check, 8, 1, file)!=1)\n+        {\n+            printf(\"CLogDB::Load(): unable to read checksum\\n\");\n+            return false;\n+        }\n+\n+        SHA256_CTX ctxFinal = ctx;\n+\n+        unsigned char checkx[32];\n+        SHA256_Final(checkx, &ctxFinal);\n+        if (memcmp(check,checkx,8))\n+        {\n+            printf(\"CLogDB::Load(): checksum failed\\n\");\n+            return false;\n+        }\n+\n+        // if we reach this point, the entire read frame was valid\n+        ctxState = ctx;\n+\n+        for (vector<CModEntry>::iterator it = vMod.begin(); it != vMod.end(); it++)\n+        {\n+            CModEntry &mod = *it;\n+            nWritten += mod.key.size() + mod.value.size();\n+            switch (mod.nMode)\n+            {\n+                case 1:\n+                    Write_(mod.key, mod.value, true, true);\n+                    break;\n+\n+                case 2:\n+                    Erase_(mod.key, true);\n+                    break;\n+            }\n+        }\n+\n+    } while(true);\n+\n+    printf(\"CLogDB::Load(): done\\n\");\n+}\n+\n+bool CLogDBFile::Flush_()\n+{\n+    printf(\"CLogDB::Flush_()\\n\");\n+\n+    if (setDirty.empty())\n+        return true;\n+\n+    printf(\"CLogDB::Flush_(): not dirty\\n\");\n+\n+    unsigned char magic[4]={0xCC,0xC4,0xE6,0xB0};\n+\n+    if (fwrite(magic, 4, 1, file) != 1)\n+    {\n+        printf(\"CLogDB::Flush_(): error writing magic: %s\\n\", strerror(errno));\n+    }\n+\n+    SHA256_CTX ctx = ctxState;\n+\n+    for (set<data_t>::iterator it = setDirty.begin(); it != setDirty.end(); it++)\n+    {\n+        map<data_t, data_t>::iterator it2 = mapData.find(*it);\n+\n+        if (it2 != mapData.end())\n+        {\n+            // update\n+            unsigned char nMode = 1;\n+            uint32_t nKeySize = (*it).size();\n+            uint32_t nDataSize = (*it2).second.size();\n+            nWritten += nKeySize + nDataSize;\n+\n+            printf(\"CLogDB::Flush(): writing update(%.*s)\\n\", nKeySize, &(*it)[0]);\n+\n+            putc(nMode, file);\n+            WriteInt(file, nKeySize);\n+            fwrite(&(*it)[0], nKeySize, 1, file);\n+            WriteInt(file, nDataSize);\n+            fwrite(&(*it2).second[0], nDataSize, 1, file);\n+\n+            SHA256_Update(&ctx, &nMode, 1);\n+            SHA256_Update(&ctx, &nKeySize, 4);\n+            SHA256_Update(&ctx, &(*it)[0], nKeySize);\n+            SHA256_Update(&ctx, &nDataSize, 4);\n+            SHA256_Update(&ctx, &(*it2).second[0], nDataSize);\n+        }\n+        else\n+        {\n+            // erase\n+            unsigned char nMode = 2;\n+            uint32_t nKeySize = (*it).size();\n+            nWritten += nKeySize;\n+\n+            printf(\"CLogDB::Flush(): writing erase(%.*s)\\n\", nKeySize, &(*it)[0]);\n+\n+            putc(nMode, file);\n+            WriteInt(file, nKeySize);\n+            fwrite(&(*it)[0], nKeySize, 1, file);\n+\n+            SHA256_Update(&ctx, &nMode, 1);\n+            SHA256_Update(&ctx, &nKeySize, 4);\n+            SHA256_Update(&ctx, &(*it)[0], nKeySize);\n+        }\n+    }\n+\n+    unsigned char nMode = 0;\n+    putc(nMode, file);\n+    SHA256_Update(&ctx, &nMode, 1);\n+\n+    SHA256_CTX ctxFinal = ctx;\n+    unsigned char buf[32];\n+    SHA256_Final(buf, &ctxFinal);\n+    fwrite(buf, 8, 1, file);\n+    fflush(file);\n+    fdatasync(fileno(file));\n+    ctxState = ctx;\n+\n+    printf(\"CLogDB::Flush(): wrote frame\\n\");\n+\n+    setDirty.clear();\n+\n+    return true;\n+}\n+\n+bool CLogDB::TxnAbort() {\n+    LOCK(cs);\n+\n+    if (!fTransaction)\n+        return false;\n+\n+    mapData.clear();\n+    setDirty.clear();\n+\n+    fTransaction = false;\n+    if (fReadOnly)\n+        db->mutex.unlock_shared();\n+    else\n+        db->mutex.unlock();\n+\n+    return true;\n+}\n+\n+bool CLogDB::TxnBegin() {\n+    LOCK(cs);\n+\n+    if (fTransaction)\n+        return false;\n+\n+    if (fReadOnly)\n+        db->mutex.lock_shared();\n+    else\n+        db->mutex.lock();\n+\n+    fTransaction = true;\n+    return true;\n+}\n+\n+bool CLogDB::TxnCommit() {\n+    LOCK(cs);\n+\n+    if (!fTransaction)\n+        return false;\n+\n+    // commit modifications to backing CLogDBFile\n+    for (std::set<data_t>::const_iterator it = setDirty.begin(); it != setDirty.end(); it++) {\n+         std::map<data_t, data_t>::const_iterator it2 = mapData.find(*it);\n+         if (it2 != mapData.end()) {\n+             db->Erase_(*it);\n+         } else {\n+             db->Write_(*it, (*it2).second);\n+         }\n+    }\n+    mapData.clear();\n+    setDirty.clear();\n+    if (!fReadOnly)\n+        db->Flush_();\n+\n+    fTransaction = false;\n+    if (fReadOnly)\n+        db->mutex.unlock_shared();\n+    else\n+        db->mutex.unlock();\n+\n+    return true;\n+}\n+\n+bool CLogDB::Write(const data_t &key, const data_t &value) {\n+    if (fReadOnly)\n+        return false;\n+\n+    LOCK(cs);\n+\n+    bool fAutoTransaction = TxnBegin();\n+\n+    mapData[key] = value;\n+    setDirty.insert(key);\n+\n+    if (fAutoTransaction)\n+        return TxnCommit();\n+\n+    return true;\n+}\n+\n+bool CLogDB::Erase(const data_t &key) {\n+    if (fReadOnly)\n+        return false;\n+\n+    LOCK(cs);\n+\n+    bool fAutoTransaction = TxnBegin();\n+\n+    mapData.erase(key);\n+    setDirty.insert(key);\n+\n+    if (fAutoTransaction)\n+        return TxnCommit();\n+    return true;\n+}\n+\n+bool CLogDB::Read(const data_t &key, data_t &value) {\n+    LOCK(cs);\n+\n+    bool fAutoTransaction = TxnBegin();\n+    bool fOk = true;\n+\n+    // in readonly mode: no need to check for local modifications\n+    if (!fReadOnly && setDirty.count(key)) {\n+        std::map<data_t, data_t>::const_iterator it = mapData.find(key);\n+        if (it != mapData.end()) {\n+            value = (*it).second;\n+        } else {\n+            fOk = false;\n+        }\n+    } else {\n+        fOk = db->Read_(key, value);\n+    }\n+\n+    if (fAutoTransaction)\n+        fOk &= TxnCommit();\n+\n+    return fOk;\n+}\n+\n+bool CLogDB::Exists(const data_t &key) {\n+    LOCK(cs);\n+\n+    bool fAutoTransaction = TxnBegin();\n+\n+    bool fRet;\n+    // in readonly mode: no need to check for local modifications\n+    if (!fReadOnly && setDirty.count(key) != 0) {\n+        fRet = (mapData.count(key) != 0);\n+    } else {\n+        fRet = db->Exists_(key);\n+    }\n+\n+    if (fAutoTransaction)\n+        TxnCommit();\n+\n+    return fRet;\n+}"
      },
      {
        "sha": "ddc78a0ec4e2ed2a62f0fb0bde763b59cfdb1ae1",
        "filename": "src/logdb.h",
        "status": "added",
        "additions": 177,
        "deletions": 0,
        "changes": 177,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b42ace679c7247b11f6428d9c5eea55af90c1cbf/src/logdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b42ace679c7247b11f6428d9c5eea55af90c1cbf/src/logdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/logdb.h?ref=b42ace679c7247b11f6428d9c5eea55af90c1cbf",
        "patch": "@@ -0,0 +1,177 @@\n+// Copyright (c) 2012 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file license.txt or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _BITCOIN_LOGDB_H_\n+#define _BITCOIN_LOGDB_H_\n+\n+#include <map>\n+#include <set>\n+\n+#include <openssl/sha.h>\n+#include <boost/thread/shared_mutex.hpp>\n+#include <boost/thread/locks.hpp>\n+\n+#include \"sync.h\"\n+#include \"serialize.h\"\n+\n+typedef std::vector<unsigned char> data_t;\n+\n+class CLogDB;\n+\n+class CLogDBFile\n+{\n+private:\n+    mutable boost::shared_mutex mutex;\n+\n+    FILE *file;\n+    SHA256_CTX ctxState;\n+\n+    // database\n+    std::map<data_t, data_t> mapData;\n+    size_t nUsed; // continuously updated\n+    size_t nWritten; // updated when writing a new block\n+\n+    // cached changes\n+    std::set<data_t> setDirty;\n+\n+    friend class CLogDB;\n+\n+protected:\n+    void Init_();\n+    bool Load_();\n+    bool Write_(const data_t &key, const data_t &value, bool fOverwrite = true, bool fLoad = false);\n+    bool Read_(const data_t &key, data_t &value) const;\n+    bool Exists_(const data_t &key) const;\n+    bool Erase_(const data_t &key, bool fLoad = false);\n+    bool Flush_();\n+    bool Close_();\n+\n+public:\n+    CLogDBFile()\n+    {\n+        Init_();\n+    }\n+\n+    ~CLogDBFile()\n+    {\n+        Close_();\n+    }\n+\n+    bool Open(const char *pszFile, bool fCreate = true)\n+    {\n+        boost::lock_guard<boost::shared_mutex> lock(mutex);\n+        Close_();\n+\n+        file = fopen(pszFile, fCreate ? \"a+b\" : \"r+b\");\n+\n+        if (file == NULL) {\n+            printf(\"Error opening %s: %s\\n\", pszFile, strerror(errno));\n+                return false;\n+        }\n+\n+        return Load_();\n+    }\n+\n+/*\n+    template<typename K, typename V>\n+    bool Write(const K &key, const V &value, bool fOverwrite = true)\n+    {\n+        CDataStream ssk(SER_DISK);\n+        ssk << key;\n+        data_t datak(ssk.begin(), ssk.end());\n+        CDataStream ssv(SER_DISK);\n+        ssv << value;\n+        data_t datav(ssv.begin(), ssv.end());\n+        CRITICAL_BLOCK(cs)\n+            return Write_(datak, datav, fOverwrite);\n+        return false;\n+    }\n+\n+    template<typename K, typename V>\n+    bool Read(const K &key, V &value) const\n+    {\n+        CDataStream ssk(SER_DISK);\n+        ssk << key;\n+        data_t datak(ssk.begin(), ssk.end());\n+        data_t datav;\n+        CRITICAL_BLOCK(cs)\n+            if (!Read_(datak,datav))\n+                return false;\n+        CDataStream ssv(datav, SER_DISK);\n+        ssv >> value;\n+        return true;\n+    }\n+\n+    template<typename K>\n+    bool Exists(const K &key) const\n+    {\n+        CDataStream ssk(SER_DISK);\n+        ssk << key;\n+        data_t datak(ssk.begin(), ssk.end());\n+        CRITICAL_BLOCK(cs)\n+            return Exists_(datak);\n+        return false;\n+    }\n+\n+    template<typename K>\n+    bool Erase(const K &key)\n+    { \n+        CDataStream ssk(SER_DISK);\n+        ssk << key;\n+        data_t datak(ssk.begin(), ssk.end());\n+        CRITICAL_BLOCK(cs)\n+            return Erase_(datak);\n+        return false;\n+    }\n+*/\n+\n+//    bool Flush()            { CRITICAL_BLOCK(cs) return Flush_();          return false; }\n+//    bool Close()            { CRITICAL_BLOCK(cs) return Close_();          return false; }\n+//    bool IsDirty() const    { CRITICAL_BLOCK(cs) return !setDirty.empty(); return false; }\n+//    bool IsOpen() const     { return file != NULL; }\n+\n+    bool Close() {\n+        boost::lock_guard<boost::shared_mutex> lock(mutex);\n+        return Close_();\n+    }\n+};\n+\n+class CLogDB\n+{\n+public:\n+    typedef data_t key_type;\n+    typedef data_t value_type;\n+    typedef std::map<key_type, value_type>::const_iterator const_iterator;\n+\n+private:\n+    mutable CCriticalSection cs;\n+    CLogDBFile * const db; // const pointer to non-const db\n+    const bool fReadOnly; // readonly CLogDB's use a shared lock instead of a normal\n+\n+    bool fTransaction; // true inside a transaction\n+    std::map<data_t, data_t> mapData; // must be empty outside transactions\n+    std::set<data_t> setDirty;\n+\n+public:\n+    bool TxnAbort();\n+    bool TxnBegin();\n+    bool TxnCommit();\n+\n+    CLogDB(CLogDBFile *dbIn, bool fReadOnlyIn = false) : db(dbIn), fReadOnly(fReadOnlyIn), fTransaction(false) { }\n+\n+    ~CLogDB() {\n+        TxnAbort();\n+    }\n+\n+    bool Write(const data_t &key, const data_t &value);\n+    bool Erase(const data_t &key);\n+    bool Read(const data_t &key, data_t &value);\n+    bool Exists(const data_t &key);\n+\n+    // only reads committed data, no local modifications\n+    const_iterator begin() const { return db->mapData.begin(); }\n+    const_iterator end() const   { return db->mapData.end(); }\n+};\n+\n+#endif"
      }
    ]
  },
  {
    "sha": "0f7be5e753801eb7add5ce73d6b39b25bcca9283",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowZjdiZTVlNzUzODAxZWI3YWRkNWNlNzNkNmIzOWIyNWJjY2E5Mjgz",
    "commit": {
      "author": {
        "name": "Jonas Schnelli",
        "email": "jonas.schnelli@include7.ch",
        "date": "2014-12-27T19:32:11Z"
      },
      "committer": {
        "name": "Jonas Schnelli",
        "email": "jonas.schnelli@include7.ch",
        "date": "2015-02-05T08:43:52Z"
      },
      "message": "[Wallet] integrate internal file backend \"logdb\"\n\n- basic integration (needs sanity, etc.)\n- remove openssl SHA256 depenencies and use internal SHA256 methods\n- use internal logging\n\nConflicts:\n\tsrc/init.cpp",
      "tree": {
        "sha": "a94d5a9a3ac66a158d6a51846d71935741c468b9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a94d5a9a3ac66a158d6a51846d71935741c468b9"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0f7be5e753801eb7add5ce73d6b39b25bcca9283",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0f7be5e753801eb7add5ce73d6b39b25bcca9283",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0f7be5e753801eb7add5ce73d6b39b25bcca9283",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0f7be5e753801eb7add5ce73d6b39b25bcca9283/comments",
    "author": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b42ace679c7247b11f6428d9c5eea55af90c1cbf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b42ace679c7247b11f6428d9c5eea55af90c1cbf",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b42ace679c7247b11f6428d9c5eea55af90c1cbf"
      }
    ],
    "stats": {
      "total": 992,
      "additions": 697,
      "deletions": 295
    },
    "files": [
      {
        "sha": "461619c6507b50f93888889a8516ba9de58d93fb",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0f7be5e753801eb7add5ce73d6b39b25bcca9283/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0f7be5e753801eb7add5ce73d6b39b25bcca9283/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=0f7be5e753801eb7add5ce73d6b39b25bcca9283",
        "patch": "@@ -195,6 +195,7 @@ libbitcoin_wallet_a_CPPFLAGS = $(BITCOIN_INCLUDES)\n libbitcoin_wallet_a_SOURCES = \\\n   db.cpp \\\n   crypter.cpp \\\n+  logdb.cpp \\\n   rpcdump.cpp \\\n   rpcwallet.cpp \\\n   wallet.cpp \\"
      },
      {
        "sha": "19e8b83ee1866df9232fd6e736a82e5d03efd5a4",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 45,
        "changes": 49,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0f7be5e753801eb7add5ce73d6b39b25bcca9283/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0f7be5e753801eb7add5ce73d6b39b25bcca9283/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=0f7be5e753801eb7add5ce73d6b39b25bcca9283",
        "patch": "@@ -24,7 +24,6 @@\n #include \"util.h\"\n #include \"utilmoneystr.h\"\n #ifdef ENABLE_WALLET\n-#include \"db.h\"\n #include \"wallet.h\"\n #include \"walletdb.h\"\n #endif\n@@ -151,7 +150,7 @@ void Shutdown()\n     StopRPCThreads();\n #ifdef ENABLE_WALLET\n     if (pwalletMain)\n-        bitdb.Flush(false);\n+        pwalletMain->Flush(false);\n     GenerateBitcoins(false, NULL, 0);\n #endif\n     StopNode();\n@@ -184,7 +183,7 @@ void Shutdown()\n     }\n #ifdef ENABLE_WALLET\n     if (pwalletMain)\n-        bitdb.Flush(true);\n+        pwalletMain->Flush(true);\n #endif\n #ifndef WIN32\n     boost::filesystem::remove(GetPidFile());\n@@ -798,7 +797,7 @@ bool AppInit2(boost::thread_group& threadGroup)\n     LogPrintf(\"Bitcoin version %s (%s)\\n\", FormatFullVersion(), CLIENT_DATE);\n     LogPrintf(\"Using OpenSSL version %s\\n\", SSLeay_version(SSLEAY_VERSION));\n #ifdef ENABLE_WALLET\n-    LogPrintf(\"Using BerkeleyDB version %s\\n\", DbEnv::version(0, 0, 0));\n+    LogPrintf(\"Using internal logdb as wallet backend\");\n #endif\n     if (!fLogTimestamps)\n         LogPrintf(\"Startup time: %s\\n\", DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", GetTime()));\n@@ -835,47 +834,7 @@ bool AppInit2(boost::thread_group& threadGroup)\n         LogPrintf(\"Using wallet %s\\n\", strWalletFile);\n         uiInterface.InitMessage(_(\"Verifying wallet...\"));\n \n-        if (!bitdb.Open(GetDataDir()))\n-        {\n-            // try moving the database env out of the way\n-            boost::filesystem::path pathDatabase = GetDataDir() / \"database\";\n-            boost::filesystem::path pathDatabaseBak = GetDataDir() / strprintf(\"database.%d.bak\", GetTime());\n-            try {\n-                boost::filesystem::rename(pathDatabase, pathDatabaseBak);\n-                LogPrintf(\"Moved old %s to %s. Retrying.\\n\", pathDatabase.string(), pathDatabaseBak.string());\n-            } catch (const boost::filesystem::filesystem_error&) {\n-                 // failure is ok (well, not really, but it's not worse than what we started with)\n-            }\n-\n-            // try again\n-            if (!bitdb.Open(GetDataDir())) {\n-                // if it still fails, it probably means we can't even create the database env\n-                string msg = strprintf(_(\"Error initializing wallet database environment %s!\"), strDataDir);\n-                return InitError(msg);\n-            }\n-        }\n-\n-        if (GetBoolArg(\"-salvagewallet\", false))\n-        {\n-            // Recover readable keypairs:\n-            if (!CWalletDB::Recover(bitdb, strWalletFile, true))\n-                return false;\n-        }\n-\n-        if (boost::filesystem::exists(GetDataDir() / strWalletFile))\n-        {\n-            CDBEnv::VerifyResult r = bitdb.Verify(strWalletFile, CWalletDB::Recover);\n-            if (r == CDBEnv::RECOVER_OK)\n-            {\n-                string msg = strprintf(_(\"Warning: wallet.dat corrupt, data salvaged!\"\n-                                         \" Original wallet.dat saved as wallet.{timestamp}.bak in %s; if\"\n-                                         \" your balance or transactions are incorrect you should\"\n-                                         \" restore from a backup.\"), strDataDir);\n-                InitWarning(msg);\n-            }\n-            if (r == CDBEnv::RECOVER_FAIL)\n-                return InitError(_(\"wallet.dat corrupt, salvage failed\"));\n-        }\n+        CWalletDB::Verify(strWalletFile, GetBoolArg(\"-salvagewallet\", false));\n     } // (!fDisableWallet)\n #endif // ENABLE_WALLET\n     // ********************************************************* Step 6: network initialization"
      },
      {
        "sha": "6614e39debb8d47add31e318fcc73d83b2b55191",
        "filename": "src/logdb.cpp",
        "status": "modified",
        "additions": 57,
        "deletions": 56,
        "changes": 113,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0f7be5e753801eb7add5ce73d6b39b25bcca9283/src/logdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0f7be5e753801eb7add5ce73d6b39b25bcca9283/src/logdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/logdb.cpp?ref=0f7be5e753801eb7add5ce73d6b39b25bcca9283",
        "patch": "@@ -6,6 +6,7 @@\n #include <unistd.h>\n \n #include \"logdb.h\"\n+#include \"util.h\"\n \n using namespace std;\n \n@@ -15,7 +16,7 @@ using namespace std;\n // Thus, the byte sequence a[] where all but the last has bit 128 set,\n // encodes the number (a[0] & 0x7F) + sum(i=1..n, 128^i*((a[i] & 0x7F)+1))\n \n-size_t static WriteInt(FILE* file, uint64 n)\n+size_t static WriteInt(FILE* file, uint64_t n)\n {\n     int nRet = 0;\n     do\n@@ -29,7 +30,7 @@ size_t static WriteInt(FILE* file, uint64 n)\n     return nRet;\n }\n \n-int static ReadInt(FILE *file)\n+uint64_t static ReadInt(FILE *file)\n {\n     uint64_t nRet = 0;\n     uint64_t nBase = 1;\n@@ -68,18 +69,16 @@ class CModEntry\n void CLogDBFile::Init_()\n {\n     file = NULL;\n-    SHA256_Init(&ctxState);\n+    ctxState.Reset();\n     mapData.clear();\n     nUsed = 0;\n     nWritten = 0;\n+    nRefCount = 0;\n     setDirty.clear();\n }\n \n bool CLogDBFile::Write_(const data_t &key, const data_t &value, bool fOverwrite, bool fLoad)\n {\n-    if (!fLoad)\n-        return false;\n-\n     // update nUsed\n     std::map<data_t, data_t>::iterator it = mapData.find(key);\n     if (it != mapData.end())\n@@ -119,9 +118,6 @@ bool CLogDBFile::Exists_(const data_t &key) const\n \n bool CLogDBFile::Erase_(const data_t &key, bool fLoad)\n {\n-    if (!fLoad)\n-        return false;\n-\n     std::map<data_t, data_t>::iterator it = mapData.find(key);\n     if (it != mapData.end())\n     {\n@@ -156,71 +152,71 @@ bool CLogDBFile::Load_()\n         if (getc(file) != 0xE6) return false;\n         if (getc(file) != 0xB0) return false;\n \n-        printf(\"CLogDB::Load(): frame header found\\n\");\n+        LogPrintf(\"CLogDB::Load(): frame header found\\n\");\n \n         vector<CModEntry> vMod;\n \n         // update a copy of the state, so we can revert in case of error\n-        SHA256_CTX ctx = ctxState;\n+        CSHA256 ctx = ctxState;\n \n         do\n         {\n             if (feof(file))\n             {\n-                printf(\"CLogDB::Load(): unexpected eof at record start\\n\");\n+                LogPrintf(\"CLogDBFile::Load(): unexpected eof at record start\\n\");\n                 return false;\n             }\n \n             CModEntry entry;\n             entry.nMode = getc(file);\n             if (entry.nMode > 2)\n             {\n-                printf(\"CLogDB::Load(): unknown record mode\\n\");\n+                LogPrintf(\"CLogDBFile::Load(): unknown record mode\\n\");\n                 return false;\n             }\n \n-            SHA256_Update(&ctx, &entry.nMode, 1);\n-\n+            ctx.Write((const unsigned char *)&entry.nMode, 1);\n+            \n             if (entry.nMode == 0)\n                 break;\n \n-            printf(\"CLogDB::Load(): loading record mode %i\\n\", entry.nMode);\n+            LogPrintf(\"CLogDBFile::Load(): loading record mode %i\\n\", entry.nMode);\n \n             uint32_t nKeySize = ReadInt(file);\n             if (nKeySize >= 0x1000)\n             {\n-                printf(\"CLogDB::Load(): oversizes key (%lu bytes)\\n\", (unsigned long)nKeySize);\n+                LogPrintf(\"CLogDBFile::Load(): oversizes key (%lu bytes)\\n\", (unsigned long)nKeySize);\n                 return false;\n             }\n             entry.key.resize(nKeySize);\n             if (fread(&entry.key[0], nKeySize, 1, file) != 1)\n             {\n-                printf(\"CLogDB::Load(): unable to read key (%lu bytes)\\n\", (unsigned long)nKeySize);\n+                LogPrintf(\"CLogDBFile::Load(): unable to read key (%lu bytes)\\n\", (unsigned long)nKeySize);\n                 return false;\n             }\n \n-            printf(\"CLogDB::load(): loading key (%.*s)\\n\", nKeySize, &entry.key[0]);\n+            LogPrintf(\"CLogDBFile::load(): loading key (%.*s)\\n\", nKeySize, &entry.key[0]);\n \n-            SHA256_Update(&ctx, &nKeySize, 4);\n-            SHA256_Update(&ctx, &entry.key[0], nKeySize);\n+            ctx.Write((const unsigned char *)&nKeySize, 4);\n+            ctx.Write((const unsigned char *)&entry.key[0], nKeySize);\n \n             if (entry.nMode == 1)\n             {\n                 int nValueSize = ReadInt(file);\n                 if (nValueSize >= 0x100000)\n                 {\n-                    printf(\"CLogDB::Load(): oversized value (%lu bytes)\\n\", (unsigned long)nValueSize);\n+                    LogPrintf(\"CLogDBFile::Load(): oversized value (%lu bytes)\\n\", (unsigned long)nValueSize);\n                     return false;\n                 }\n                 entry.value.resize(nValueSize);\n                 if (fread(&entry.value[0], nValueSize, 1, file) != 1)\n                 {\n-                    printf(\"CLogDB::Load(): unable to read value (%lu bytes)\\n\", (unsigned long)nValueSize);\n+                    LogPrintf(\"CLogDBFile::Load(): unable to read value (%lu bytes)\\n\", (unsigned long)nValueSize);\n                     return false;\n                 }\n \n-                SHA256_Update(&ctx, &nValueSize, 4);\n-                SHA256_Update(&ctx, &entry.value[0], nValueSize);\n+                ctx.Write((const unsigned char *)&nValueSize, 4);\n+                ctx.Write((const unsigned char *)&entry.value[0], nValueSize);\n             }\n \n             vMod.push_back(entry);\n@@ -229,19 +225,23 @@ bool CLogDBFile::Load_()\n         unsigned char check[8];\n         if (fread(check, 8, 1, file)!=1)\n         {\n-            printf(\"CLogDB::Load(): unable to read checksum\\n\");\n+            LogPrintf(\"CLogDBFile::Load(): unable to read checksum\\n\");\n             return false;\n         }\n \n-        SHA256_CTX ctxFinal = ctx;\n+        CSHA256 ctxFinal = ctx;\n \n         unsigned char checkx[32];\n-        SHA256_Final(checkx, &ctxFinal);\n+        ctxFinal.Finalize(checkx);\n         if (memcmp(check,checkx,8))\n         {\n-            printf(\"CLogDB::Load(): checksum failed\\n\");\n+            LogPrintf(\"CLogDBFile::Load(): checksum failed\\n\");\n             return false;\n         }\n+        else\n+        {\n+            LogPrintf(\"CLogDBFile::Load(): checksum OK\\n\");\n+        }\n \n         // if we reach this point, the entire read frame was valid\n         ctxState = ctx;\n@@ -264,26 +264,26 @@ bool CLogDBFile::Load_()\n \n     } while(true);\n \n-    printf(\"CLogDB::Load(): done\\n\");\n+    LogPrintf(\"CLogDBFile::Load(): done\\n\");\n }\n \n bool CLogDBFile::Flush_()\n {\n-    printf(\"CLogDB::Flush_()\\n\");\n+    LogPrintf(\"CLogDBFile::Flush_()\\n\");\n \n     if (setDirty.empty())\n         return true;\n \n-    printf(\"CLogDB::Flush_(): not dirty\\n\");\n+    LogPrintf(\"CLogDBFile::Flush_(): dirty entries found\\n\");\n \n     unsigned char magic[4]={0xCC,0xC4,0xE6,0xB0};\n \n     if (fwrite(magic, 4, 1, file) != 1)\n     {\n-        printf(\"CLogDB::Flush_(): error writing magic: %s\\n\", strerror(errno));\n+        LogPrintf(\"CLogDBFile::Flush_(): error writing magic: %s\\n\", strerror(errno));\n     }\n \n-    SHA256_CTX ctx = ctxState;\n+    CSHA256 ctx = ctxState;\n \n     for (set<data_t>::iterator it = setDirty.begin(); it != setDirty.end(); it++)\n     {\n@@ -297,19 +297,19 @@ bool CLogDBFile::Flush_()\n             uint32_t nDataSize = (*it2).second.size();\n             nWritten += nKeySize + nDataSize;\n \n-            printf(\"CLogDB::Flush(): writing update(%.*s)\\n\", nKeySize, &(*it)[0]);\n+            LogPrintf(\"CLogDBFile::Flush(): writing update(%.*s)\\n\", nKeySize, &(*it)[0]);\n \n             putc(nMode, file);\n             WriteInt(file, nKeySize);\n             fwrite(&(*it)[0], nKeySize, 1, file);\n             WriteInt(file, nDataSize);\n             fwrite(&(*it2).second[0], nDataSize, 1, file);\n \n-            SHA256_Update(&ctx, &nMode, 1);\n-            SHA256_Update(&ctx, &nKeySize, 4);\n-            SHA256_Update(&ctx, &(*it)[0], nKeySize);\n-            SHA256_Update(&ctx, &nDataSize, 4);\n-            SHA256_Update(&ctx, &(*it2).second[0], nDataSize);\n+            ctx.Write((const unsigned char *)&nMode, 1);\n+            ctx.Write((const unsigned char *)&nKeySize, 4);\n+            ctx.Write((const unsigned char *)&(*it)[0], nKeySize);\n+            ctx.Write((const unsigned char *)&nDataSize, 4);\n+            ctx.Write((const unsigned char *)&(*it2).second[0], nDataSize);\n         }\n         else\n         {\n@@ -318,31 +318,31 @@ bool CLogDBFile::Flush_()\n             uint32_t nKeySize = (*it).size();\n             nWritten += nKeySize;\n \n-            printf(\"CLogDB::Flush(): writing erase(%.*s)\\n\", nKeySize, &(*it)[0]);\n+            LogPrintf(\"CLogDBFile::Flush(): writing erase(%.*s)\\n\", nKeySize, &(*it)[0]);\n \n             putc(nMode, file);\n             WriteInt(file, nKeySize);\n             fwrite(&(*it)[0], nKeySize, 1, file);\n \n-            SHA256_Update(&ctx, &nMode, 1);\n-            SHA256_Update(&ctx, &nKeySize, 4);\n-            SHA256_Update(&ctx, &(*it)[0], nKeySize);\n+            ctx.Write((const unsigned char *)&nMode, 1);\n+            ctx.Write((const unsigned char *)&nKeySize, 4);\n+            ctx.Write((const unsigned char *)&(*it)[0], nKeySize);\n         }\n     }\n \n     unsigned char nMode = 0;\n     putc(nMode, file);\n-    SHA256_Update(&ctx, &nMode, 1);\n+    ctx.Write((const unsigned char *)&nMode, 1);\n \n-    SHA256_CTX ctxFinal = ctx;\n+    CSHA256 ctxFinal = ctx;\n     unsigned char buf[32];\n-    SHA256_Final(buf, &ctxFinal);\n+    ctxFinal.Finalize(buf);\n     fwrite(buf, 8, 1, file);\n     fflush(file);\n-    fdatasync(fileno(file));\n+    FileCommit(file);\n     ctxState = ctx;\n \n-    printf(\"CLogDB::Flush(): wrote frame\\n\");\n+    LogPrintf(\"CLogDBFile::Flush(): wrote frame\\n\");\n \n     setDirty.clear();\n \n@@ -391,16 +391,14 @@ bool CLogDB::TxnCommit() {\n     // commit modifications to backing CLogDBFile\n     for (std::set<data_t>::const_iterator it = setDirty.begin(); it != setDirty.end(); it++) {\n          std::map<data_t, data_t>::const_iterator it2 = mapData.find(*it);\n-         if (it2 != mapData.end()) {\n+         if (it2 == mapData.end()) {\n              db->Erase_(*it);\n          } else {\n              db->Write_(*it, (*it2).second);\n          }\n     }\n     mapData.clear();\n     setDirty.clear();\n-    if (!fReadOnly)\n-        db->Flush_();\n \n     fTransaction = false;\n     if (fReadOnly)\n@@ -411,14 +409,17 @@ bool CLogDB::TxnCommit() {\n     return true;\n }\n \n-bool CLogDB::Write(const data_t &key, const data_t &value) {\n+bool CLogDB::Write_(const data_t &key, const data_t &value, bool fOverwrite) {\n     if (fReadOnly)\n         return false;\n \n     LOCK(cs);\n \n     bool fAutoTransaction = TxnBegin();\n \n+    if (!fOverwrite && Exists_(key))\n+        return false;\n+    \n     mapData[key] = value;\n     setDirty.insert(key);\n \n@@ -428,7 +429,7 @@ bool CLogDB::Write(const data_t &key, const data_t &value) {\n     return true;\n }\n \n-bool CLogDB::Erase(const data_t &key) {\n+bool CLogDB::Erase_(const data_t &key) {\n     if (fReadOnly)\n         return false;\n \n@@ -444,7 +445,7 @@ bool CLogDB::Erase(const data_t &key) {\n     return true;\n }\n \n-bool CLogDB::Read(const data_t &key, data_t &value) {\n+bool CLogDB::Read_(const data_t &key, data_t &value) {\n     LOCK(cs);\n \n     bool fAutoTransaction = TxnBegin();\n@@ -468,7 +469,7 @@ bool CLogDB::Read(const data_t &key, data_t &value) {\n     return fOk;\n }\n \n-bool CLogDB::Exists(const data_t &key) {\n+bool CLogDB::Exists_(const data_t &key) {\n     LOCK(cs);\n \n     bool fAutoTransaction = TxnBegin();"
      },
      {
        "sha": "b0ccb9484ceea26dcf966aa6856df54301d7f8c4",
        "filename": "src/logdb.h",
        "status": "modified",
        "additions": 101,
        "deletions": 61,
        "changes": 162,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0f7be5e753801eb7add5ce73d6b39b25bcca9283/src/logdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0f7be5e753801eb7add5ce73d6b39b25bcca9283/src/logdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/logdb.h?ref=0f7be5e753801eb7add5ce73d6b39b25bcca9283",
        "patch": "@@ -8,12 +8,18 @@\n #include <map>\n #include <set>\n \n-#include <openssl/sha.h>\n-#include <boost/thread/shared_mutex.hpp>\n-#include <boost/thread/locks.hpp>\n-\n-#include \"sync.h\"\n+#include \"clientversion.h\"\n #include \"serialize.h\"\n+#include \"streams.h\"\n+#include \"sync.h\"\n+#include \"version.h\"\n+\n+#include <boost/filesystem.hpp>\n+#include <boost/thread.hpp>\n+\n+#include \"crypto/sha256.h\"\n+\n+extern unsigned int nWalletDBUpdated;\n \n typedef std::vector<unsigned char> data_t;\n \n@@ -25,13 +31,16 @@ class CLogDBFile\n     mutable boost::shared_mutex mutex;\n \n     FILE *file;\n-    SHA256_CTX ctxState;\n+    CSHA256 ctxState;\n \n     // database\n     std::map<data_t, data_t> mapData;\n     size_t nUsed; // continuously updated\n     size_t nWritten; // updated when writing a new block\n \n+    mutable CCriticalSection cs_nRefCount;\n+    int nRefCount; // number of attached CLogDB's\n+    \n     // cached changes\n     std::set<data_t> setDirty;\n \n@@ -73,59 +82,6 @@ class CLogDBFile\n         return Load_();\n     }\n \n-/*\n-    template<typename K, typename V>\n-    bool Write(const K &key, const V &value, bool fOverwrite = true)\n-    {\n-        CDataStream ssk(SER_DISK);\n-        ssk << key;\n-        data_t datak(ssk.begin(), ssk.end());\n-        CDataStream ssv(SER_DISK);\n-        ssv << value;\n-        data_t datav(ssv.begin(), ssv.end());\n-        CRITICAL_BLOCK(cs)\n-            return Write_(datak, datav, fOverwrite);\n-        return false;\n-    }\n-\n-    template<typename K, typename V>\n-    bool Read(const K &key, V &value) const\n-    {\n-        CDataStream ssk(SER_DISK);\n-        ssk << key;\n-        data_t datak(ssk.begin(), ssk.end());\n-        data_t datav;\n-        CRITICAL_BLOCK(cs)\n-            if (!Read_(datak,datav))\n-                return false;\n-        CDataStream ssv(datav, SER_DISK);\n-        ssv >> value;\n-        return true;\n-    }\n-\n-    template<typename K>\n-    bool Exists(const K &key) const\n-    {\n-        CDataStream ssk(SER_DISK);\n-        ssk << key;\n-        data_t datak(ssk.begin(), ssk.end());\n-        CRITICAL_BLOCK(cs)\n-            return Exists_(datak);\n-        return false;\n-    }\n-\n-    template<typename K>\n-    bool Erase(const K &key)\n-    { \n-        CDataStream ssk(SER_DISK);\n-        ssk << key;\n-        data_t datak(ssk.begin(), ssk.end());\n-        CRITICAL_BLOCK(cs)\n-            return Erase_(datak);\n-        return false;\n-    }\n-*/\n-\n //    bool Flush()            { CRITICAL_BLOCK(cs) return Flush_();          return false; }\n //    bool Close()            { CRITICAL_BLOCK(cs) return Close_();          return false; }\n //    bool IsDirty() const    { CRITICAL_BLOCK(cs) return !setDirty.empty(); return false; }\n@@ -137,6 +93,9 @@ class CLogDBFile\n     }\n };\n \n+\n+static std::vector<std::pair<std::string, CLogDBFile *> > openDbs;\n+\n class CLogDB\n {\n public:\n@@ -146,7 +105,7 @@ class CLogDB\n \n private:\n     mutable CCriticalSection cs;\n-    CLogDBFile * const db; // const pointer to non-const db\n+    CLogDBFile *db; // pointer to non-const db\n     const bool fReadOnly; // readonly CLogDB's use a shared lock instead of a normal\n \n     bool fTransaction; // true inside a transaction\n@@ -158,20 +117,101 @@ class CLogDB\n     bool TxnBegin();\n     bool TxnCommit();\n \n-    CLogDB(CLogDBFile *dbIn, bool fReadOnlyIn = false) : db(dbIn), fReadOnly(fReadOnlyIn), fTransaction(false) { }\n+    CLogDB(std::string pathAndFile, bool fReadOnlyIn = false) : fReadOnly(fReadOnlyIn), fTransaction(false)\n+    {\n+        //check if this db is already open\n+        bool found = false;\n+        for(std::vector<std::pair<std::string, CLogDBFile *> >::iterator it = openDbs.begin(); it != openDbs.end(); ++it) {\n+            if(it->first == pathAndFile)\n+            {\n+                db = it->second;\n+                found = true;\n+                break;\n+            }\n+            /* std::cout << *it; ... */\n+        }\n+        if(!found)\n+        {\n+            db = new CLogDBFile();\n+            bool createFile = true;\n+            if(boost::filesystem::exists(pathAndFile))\n+                createFile = false;\n+            \n+            db->Open(pathAndFile.c_str(), createFile);\n+            openDbs.push_back(make_pair(pathAndFile, db));\n+        }\n+\n+        LOCK(db->cs_nRefCount);\n+            db->nRefCount++;\n+    }\n \n     ~CLogDB() {\n         TxnAbort();\n+        LOCK(db->cs_nRefCount);\n+        db->nRefCount--;\n+        if (db->nRefCount == 0)\n+        {\n+            boost::lock_guard<boost::shared_mutex> lock(db->mutex);\n+            db->Flush_();\n+        }\n     }\n \n     bool Write(const data_t &key, const data_t &value);\n     bool Erase(const data_t &key);\n     bool Read(const data_t &key, data_t &value);\n     bool Exists(const data_t &key);\n \n+protected:\n+    bool Write_(const data_t &key, const data_t &value, bool fOverwrite = true);\n+    bool Erase_(const data_t &key);\n+    bool Read_(const data_t &key, data_t &value);\n+    bool Exists_(const data_t &key);\n+\n+public:\n     // only reads committed data, no local modifications\n     const_iterator begin() const { return db->mapData.begin(); }\n     const_iterator end() const   { return db->mapData.end(); }\n+    \n+template<typename K, typename V>\n+bool Write(const K &key, const V &value, bool fOverwrite = true)\n+{\n+    CDataStream ssk(SER_DISK, CLIENT_VERSION);\n+    ssk << key;\n+    data_t datak(ssk.begin(), ssk.end());\n+    CDataStream ssv(SER_DISK, CLIENT_VERSION);\n+    ssv << value;\n+    data_t datav(ssv.begin(), ssv.end());\n+    return Write_(datak, datav, fOverwrite);\n+}\n+template<typename K, typename V>\n+bool Read(const K &key, V &value)\n+{\n+    CDataStream ssk(SER_DISK, CLIENT_VERSION);\n+    ssk << key;\n+    data_t datak(ssk.begin(), ssk.end());\n+    data_t datav;\n+    if (!Read_(datak,datav))\n+        return false;\n+    CDataStream ssv(datav, SER_DISK, CLIENT_VERSION);\n+    ssv >> value;\n+    return true;\n+}\n+template<typename K>\n+bool Exists(const K &key)\n+{\n+    CDataStream ssk(SER_DISK, CLIENT_VERSION);\n+    ssk << key;\n+    data_t datak(ssk.begin(), ssk.end());\n+    return Exists_(datak);\n+}\n+template<typename K>\n+bool Erase(const K &key)\n+{\n+    CDataStream ssk(SER_DISK, CLIENT_VERSION);\n+    ssk << key;\n+    data_t datak(ssk.begin(), ssk.end());\n+    return Erase_(datak);\n+}\n };\n \n #endif"
      },
      {
        "sha": "d9a703c30376b688ab4e3923dda21acd88e5a70e",
        "filename": "src/wallet.cpp",
        "status": "modified",
        "additions": 26,
        "deletions": 17,
        "changes": 43,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0f7be5e753801eb7add5ce73d6b39b25bcca9283/src/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0f7be5e753801eb7add5ce73d6b39b25bcca9283/src/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.cpp?ref=0f7be5e753801eb7add5ce73d6b39b25bcca9283",
        "patch": "@@ -501,7 +501,8 @@ bool CWallet::EncryptWallet(const SecureString& strWalletPassphrase)\n \n         // Need to completely rewrite the wallet file; if we don't, bdb might keep\n         // bits of the unencrypted private key in slack space in the database file.\n-        CDB::Rewrite(strWalletFile);\n+        //CDB::Rewrite(strWalletFile);\n+        //^^TODO\n \n     }\n     NotifyStatusChanged(this);\n@@ -786,6 +787,12 @@ bool CWallet::IsChange(const CTxOut& txout) const\n     return false;\n }\n \n+bool CWallet::Flush(bool shutdown)\n+{\n+    //TODO: implement\n+    return true;\n+}\n+\n int64_t CWalletTx::GetTxTime() const\n {\n     int64_t n = nTimeSmart;\n@@ -1849,14 +1856,15 @@ DBErrors CWallet::LoadWallet(bool& fFirstRunRet)\n     DBErrors nLoadWalletRet = CWalletDB(strWalletFile,\"cr+\").LoadWallet(this);\n     if (nLoadWalletRet == DB_NEED_REWRITE)\n     {\n-        if (CDB::Rewrite(strWalletFile, \"\\x04pool\"))\n-        {\n-            LOCK(cs_wallet);\n-            setKeyPool.clear();\n-            // Note: can't top-up keypool here, because wallet is locked.\n-            // User will be prompted to unlock wallet the next operation\n-            // the requires a new key.\n-        }\n+        // TODO\n+//        if (CDB::Rewrite(strWalletFile, \"\\x04pool\"))\n+//        {\n+//            LOCK(cs_wallet);\n+//            setKeyPool.clear();\n+//            // Note: can't top-up keypool here, because wallet is locked.\n+//            // User will be prompted to unlock wallet the next operation\n+//            // the requires a new key.\n+//        }\n     }\n \n     if (nLoadWalletRet != DB_LOAD_OK)\n@@ -1876,14 +1884,15 @@ DBErrors CWallet::ZapWalletTx(std::vector<CWalletTx>& vWtx)\n     DBErrors nZapWalletTxRet = CWalletDB(strWalletFile,\"cr+\").ZapWalletTx(this, vWtx);\n     if (nZapWalletTxRet == DB_NEED_REWRITE)\n     {\n-        if (CDB::Rewrite(strWalletFile, \"\\x04pool\"))\n-        {\n-            LOCK(cs_wallet);\n-            setKeyPool.clear();\n-            // Note: can't top-up keypool here, because wallet is locked.\n-            // User will be prompted to unlock wallet the next operation\n-            // that requires a new key.\n-        }\n+        // TODO\n+//        if (CDB::Rewrite(strWalletFile, \"\\x04pool\"))\n+//        {\n+//            LOCK(cs_wallet);\n+//            setKeyPool.clear();\n+//            // Note: can't top-up keypool here, because wallet is locked.\n+//            // User will be prompted to unlock wallet the next operation\n+//            // that requires a new key.\n+//        }\n     }\n \n     if (nZapWalletTxRet != DB_LOAD_OK)"
      },
      {
        "sha": "7d7e37daf45c2e171ef60abbbb4d451b79bf18fa",
        "filename": "src/wallet.h",
        "status": "modified",
        "additions": 368,
        "deletions": 0,
        "changes": 368,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0f7be5e753801eb7add5ce73d6b39b25bcca9283/src/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0f7be5e753801eb7add5ce73d6b39b25bcca9283/src/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.h?ref=0f7be5e753801eb7add5ce73d6b39b25bcca9283",
        "patch": "@@ -634,6 +634,374 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n \n     std::set<CTxDestination> GetAccountAddresses(std::string strAccount) const;\n \n+    isminetype IsMine(const CTxIn& txin) const;\n+    CAmount GetDebit(const CTxIn& txin, const isminefilter& filter) const;\n+    isminetype IsMine(const CTxOut& txout) const\n+    {\n+        return ::IsMine(*this, txout.scriptPubKey);\n+    }\n+    CAmount GetCredit(const CTxOut& txout, const isminefilter& filter) const\n+    {\n+        if (!MoneyRange(txout.nValue))\n+            throw std::runtime_error(\"CWallet::GetCredit() : value out of range\");\n+        return ((IsMine(txout) & filter) ? txout.nValue : 0);\n+    }\n+    bool IsChange(const CTxOut& txout) const;\n+    CAmount GetChange(const CTxOut& txout) const\n+    {\n+        if (!MoneyRange(txout.nValue))\n+            throw std::runtime_error(\"CWallet::GetChange() : value out of range\");\n+        return (IsChange(txout) ? txout.nValue : 0);\n+    }\n+    bool IsMine(const CTransaction& tx) const\n+    {\n+        BOOST_FOREACH(const CTxOut& txout, tx.vout)\n+            if (IsMine(txout))\n+                return true;\n+        return false;\n+    }\n+    /** should probably be renamed to IsRelevantToMe */\n+    bool IsFromMe(const CTransaction& tx) const\n+    {\n+        return (GetDebit(tx, ISMINE_ALL) > 0);\n+    }\n+    CAmount GetDebit(const CTransaction& tx, const isminefilter& filter) const\n+    {\n+        CAmount nDebit = 0;\n+        BOOST_FOREACH(const CTxIn& txin, tx.vin)\n+        {\n+            nDebit += GetDebit(txin, filter);\n+            if (!MoneyRange(nDebit))\n+                throw std::runtime_error(\"CWallet::GetDebit() : value out of range\");\n+        }\n+        return nDebit;\n+    }\n+    CAmount GetCredit(const CTransaction& tx, const isminefilter& filter) const\n+    {\n+        CAmount nCredit = 0;\n+        BOOST_FOREACH(const CTxOut& txout, tx.vout)\n+        {\n+            nCredit += GetCredit(txout, filter);\n+            if (!MoneyRange(nCredit))\n+                throw std::runtime_error(\"CWallet::GetCredit() : value out of range\");\n+        }\n+        return nCredit;\n+    }\n+    CAmount GetChange(const CTransaction& tx) const\n+    {\n+        CAmount nChange = 0;\n+        BOOST_FOREACH(const CTxOut& txout, tx.vout)\n+        {\n+            nChange += GetChange(txout);\n+            if (!MoneyRange(nChange))\n+                throw std::runtime_error(\"CWallet::GetChange() : value out of range\");\n+        }\n+        return nChange;\n+    }\n+    void SetBestChain(const CBlockLocator& loc);\n+\n+    DBErrors LoadWallet(bool& fFirstRunRet);\n+    DBErrors ZapWalletTx(std::vector<CWalletTx>& vWtx);\n+\n+    bool SetAddressBook(const CTxDestination& address, const std::string& strName, const std::string& purpose);\n+\n+    bool DelAddressBook(const CTxDestination& address);\n+\n+    void UpdatedTransaction(const uint256 &hashTx);\n+\n+    void Inventory(const uint256 &hash)\n+    {\n+        {\n+            LOCK(cs_wallet);\n+            std::map<uint256, int>::iterator mi = mapRequestCount.find(hash);\n+            if (mi != mapRequestCount.end())\n+                (*mi).second++;\n+        }\n+    }\n+\n+    unsigned int GetKeyPoolSize()\n+    {\n+        AssertLockHeld(cs_wallet); // setKeyPool\n+        return setKeyPool.size();\n+    }\n+\n+    bool SetDefaultKey(const CPubKey &vchPubKey);\n+\n+    //! signify that a particular wallet feature is now used. this may change nWalletVersion and nWalletMaxVersion if those are lower\n+    bool SetMinVersion(enum WalletFeature, CWalletDB* pwalletdbIn = NULL, bool fExplicit = false);\n+\n+    //! change which version we're allowed to upgrade to (note that this does not immediately imply upgrading to that format)\n+    bool SetMaxVersion(int nVersion);\n+\n+    //! get the current wallet format (the oldest client version guaranteed to understand this wallet)\n+    int GetVersion() { LOCK(cs_wallet); return nWalletVersion; }\n+\n+    //! Get wallet transactions that conflict with given transaction (spend same outputs)\n+    std::set<uint256> GetConflicts(const uint256& txid) const;\n+\n+    //! Flush wallet\n+    bool Flush(bool shutdown);\n+    \n+    /** \n+     * Address book entry changed.\n+     * @note called with lock cs_wallet held.\n+     */\n+    boost::signals2::signal<void (CWallet *wallet, const CTxDestination\n+            &address, const std::string &label, bool isMine,\n+            const std::string &purpose,\n+            ChangeType status)> NotifyAddressBookChanged;\n+\n+    /** \n+     * Wallet transaction added, removed or updated.\n+     * @note called with lock cs_wallet held.\n+     */\n+    boost::signals2::signal<void (CWallet *wallet, const uint256 &hashTx,\n+            ChangeType status)> NotifyTransactionChanged;\n+\n+    /** Show progress e.g. for rescan */\n+    boost::signals2::signal<void (const std::string &title, int nProgress)> ShowProgress;\n+\n+    /** Watch-only address added */\n+    boost::signals2::signal<void (bool fHaveWatchOnly)> NotifyWatchonlyChanged;\n+};\n+\n+/** A key allocated from the key pool. */\n+class CReserveKey\n+{\n+protected:\n+    CWallet* pwallet;\n+    int64_t nIndex;\n+    CPubKey vchPubKey;\n+public:\n+    CReserveKey(CWallet* pwalletIn)\n+    {\n+        nIndex = -1;\n+        pwallet = pwalletIn;\n+    }\n+\n+    ~CReserveKey()\n+    {\n+        ReturnKey();\n+    }\n+\n+    void ReturnKey();\n+    bool GetReservedKey(CPubKey &pubkey);\n+    void KeepKey();\n+};\n+\n+\n+typedef std::map<std::string, std::string> mapValue_t;\n+\n+\n+static void ReadOrderPos(int64_t& nOrderPos, mapValue_t& mapValue)\n+{\n+    if (!mapValue.count(\"n\"))\n+    {\n+        nOrderPos = -1; // TODO: calculate elsewhere\n+        return;\n+    }\n+    nOrderPos = atoi64(mapValue[\"n\"].c_str());\n+}\n+\n+\n+static void WriteOrderPos(const int64_t& nOrderPos, mapValue_t& mapValue)\n+{\n+    if (nOrderPos == -1)\n+        return;\n+    mapValue[\"n\"] = i64tostr(nOrderPos);\n+}\n+\n+struct COutputEntry\n+{\n+    CTxDestination destination;\n+    CAmount amount;\n+    int vout;\n+};\n+\n+/** A transaction with a merkle branch linking it to the block chain. */\n+class CMerkleTx : public CTransaction\n+{\n+private:\n+    int GetDepthInMainChainINTERNAL(const CBlockIndex* &pindexRet) const;\n+\n+public:\n+    uint256 hashBlock;\n+    std::vector<uint256> vMerkleBranch;\n+    int nIndex;\n+\n+    // memory only\n+    mutable bool fMerkleVerified;\n+\n+\n+    CMerkleTx()\n+    {\n+        Init();\n+    }\n+\n+    CMerkleTx(const CTransaction& txIn) : CTransaction(txIn)\n+    {\n+        Init();\n+    }\n+\n+    void Init()\n+    {\n+        hashBlock = uint256();\n+        nIndex = -1;\n+        fMerkleVerified = false;\n+    }\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        READWRITE(*(CTransaction*)this);\n+        nVersion = this->nVersion;\n+        READWRITE(hashBlock);\n+        READWRITE(vMerkleBranch);\n+        READWRITE(nIndex);\n+    }\n+\n+    int SetMerkleBranch(const CBlock& block);\n+\n+\n+    /**\n+     * Return depth of transaction in blockchain:\n+     * -1  : not in blockchain, and not in memory pool (conflicted transaction)\n+     *  0  : in memory pool, waiting to be included in a block\n+     * >=1 : this many blocks deep in the main chain\n+     */\n+    int GetDepthInMainChain(const CBlockIndex* &pindexRet) const;\n+    int GetDepthInMainChain() const { const CBlockIndex *pindexRet; return GetDepthInMainChain(pindexRet); }\n+    bool IsInMainChain() const { const CBlockIndex *pindexRet; return GetDepthInMainChainINTERNAL(pindexRet) > 0; }\n+    int GetBlocksToMaturity() const;\n+    bool AcceptToMemoryPool(bool fLimitFree=true, bool fRejectInsaneFee=true);\n+};\n+\n+/** \n+ * A transaction with a bunch of additional info that only the owner cares about.\n+ * It includes any unrecorded transactions needed to link it back to the block chain.\n+ */\n+class CWalletTx : public CMerkleTx\n+{\n+private:\n+    const CWallet* pwallet;\n+\n+public:\n+    mapValue_t mapValue;\n+    std::vector<std::pair<std::string, std::string> > vOrderForm;\n+    unsigned int fTimeReceivedIsTxTime;\n+    unsigned int nTimeReceived; //! time received by this node\n+    unsigned int nTimeSmart;\n+    char fFromMe;\n+    std::string strFromAccount;\n+    int64_t nOrderPos; //! position in ordered transaction list\n+\n+    // memory only\n+    mutable bool fDebitCached;\n+    mutable bool fCreditCached;\n+    mutable bool fImmatureCreditCached;\n+    mutable bool fAvailableCreditCached;\n+    mutable bool fWatchDebitCached;\n+    mutable bool fWatchCreditCached;\n+    mutable bool fImmatureWatchCreditCached;\n+    mutable bool fAvailableWatchCreditCached;\n+    mutable bool fChangeCached;\n+    mutable CAmount nDebitCached;\n+    mutable CAmount nCreditCached;\n+    mutable CAmount nImmatureCreditCached;\n+    mutable CAmount nAvailableCreditCached;\n+    mutable CAmount nWatchDebitCached;\n+    mutable CAmount nWatchCreditCached;\n+    mutable CAmount nImmatureWatchCreditCached;\n+    mutable CAmount nAvailableWatchCreditCached;\n+    mutable CAmount nChangeCached;\n+\n+    CWalletTx()\n+    {\n+        Init(NULL);\n+    }\n+\n+    CWalletTx(const CWallet* pwalletIn)\n+    {\n+        Init(pwalletIn);\n+    }\n+\n+    CWalletTx(const CWallet* pwalletIn, const CMerkleTx& txIn) : CMerkleTx(txIn)\n+    {\n+        Init(pwalletIn);\n+    }\n+\n+    CWalletTx(const CWallet* pwalletIn, const CTransaction& txIn) : CMerkleTx(txIn)\n+    {\n+        Init(pwalletIn);\n+    }\n+\n+    void Init(const CWallet* pwalletIn)\n+    {\n+        pwallet = pwalletIn;\n+        mapValue.clear();\n+        vOrderForm.clear();\n+        fTimeReceivedIsTxTime = false;\n+        nTimeReceived = 0;\n+        nTimeSmart = 0;\n+        fFromMe = false;\n+        strFromAccount.clear();\n+        fDebitCached = false;\n+        fCreditCached = false;\n+        fImmatureCreditCached = false;\n+        fAvailableCreditCached = false;\n+        fWatchDebitCached = false;\n+        fWatchCreditCached = false;\n+        fImmatureWatchCreditCached = false;\n+        fAvailableWatchCreditCached = false;\n+        fChangeCached = false;\n+        nDebitCached = 0;\n+        nCreditCached = 0;\n+        nImmatureCreditCached = 0;\n+        nAvailableCreditCached = 0;\n+        nWatchDebitCached = 0;\n+        nWatchCreditCached = 0;\n+        nAvailableWatchCreditCached = 0;\n+        nImmatureWatchCreditCached = 0;\n+        nChangeCached = 0;\n+        nOrderPos = -1;\n+    }\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        if (ser_action.ForRead())\n+            Init(NULL);\n+        char fSpent = false;\n+\n+        if (!ser_action.ForRead())\n+        {\n+            mapValue[\"fromaccount\"] = strFromAccount;\n+\n+            WriteOrderPos(nOrderPos, mapValue);\n+\n+            if (nTimeSmart)\n+                mapValue[\"timesmart\"] = strprintf(\"%u\", nTimeSmart);\n+        }\n+\n+    static CFeeRate minTxFee;\n+    static CAmount GetMinimumFee(unsigned int nTxBytes, unsigned int nConfirmTarget, const CTxMemPool& pool);\n+\n+    bool NewKeyPool();\n+    bool TopUpKeyPool(unsigned int kpSize = 0);\n+    void ReserveKeyFromKeyPool(int64_t& nIndex, CKeyPool& keypool);\n+    void KeepKey(int64_t nIndex);\n+    void ReturnKey(int64_t nIndex);\n+    bool GetKeyFromPool(CPubKey &key);\n+    int64_t GetOldestKeyPoolTime();\n+    void GetAllReserveKeys(std::set<CKeyID>& setAddress) const;\n+\n+    std::set< std::set<CTxDestination> > GetAddressGroupings();\n+    std::map<CTxDestination, CAmount> GetAddressBalances();\n+\n+    std::set<CTxDestination> GetAccountAddresses(std::string strAccount) const;\n+\n     isminetype IsMine(const CTxIn& txin) const;\n     CAmount GetDebit(const CTxIn& txin, const isminefilter& filter) const;\n     isminetype IsMine(const CTxOut& txout) const"
      },
      {
        "sha": "1aa7566008b320c2988a79cf5ab61275e8a23c61",
        "filename": "src/walletdb.cpp",
        "status": "modified",
        "additions": 130,
        "deletions": 110,
        "changes": 240,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0f7be5e753801eb7add5ce73d6b39b25bcca9283/src/walletdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0f7be5e753801eb7add5ce73d6b39b25bcca9283/src/walletdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/walletdb.cpp?ref=0f7be5e753801eb7add5ce73d6b39b25bcca9283",
        "patch": "@@ -206,6 +206,7 @@ CAmount CWalletDB::GetAccountCreditDebit(const string& strAccount)\n \n void CWalletDB::ListAccountCreditDebit(const string& strAccount, list<CAccountingEntry>& entries)\n {\n+    /*\n     bool fAllAccounts = (strAccount == \"*\");\n \n     Dbc* pcursor = GetCursor();\n@@ -245,6 +246,7 @@ void CWalletDB::ListAccountCreditDebit(const string& strAccount, list<CAccountin\n     }\n \n     pcursor->close();\n+     */\n }\n \n DBErrors CWalletDB::ReorderTransactions(CWallet* pwallet)\n@@ -609,6 +611,8 @@ DBErrors CWalletDB::LoadWallet(CWallet* pwallet)\n     bool fNoncriticalErrors = false;\n     DBErrors result = DB_LOAD_OK;\n \n+    bool fAutoTransaction = TxnBegin();\n+    \n     try {\n         LOCK(pwallet->cs_wallet);\n         int nMinVersion = 0;\n@@ -619,27 +623,11 @@ DBErrors CWalletDB::LoadWallet(CWallet* pwallet)\n             pwallet->LoadMinVersion(nMinVersion);\n         }\n \n-        // Get cursor\n-        Dbc* pcursor = GetCursor();\n-        if (!pcursor)\n-        {\n-            LogPrintf(\"Error getting wallet database cursor\\n\");\n-            return DB_CORRUPT;\n-        }\n-\n-        while (true)\n+        for (CWalletDB::const_iterator it = begin(); it != end(); it++)\n         {\n             // Read next record\n-            CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n-            CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n-            int ret = ReadAtCursor(pcursor, ssKey, ssValue);\n-            if (ret == DB_NOTFOUND)\n-                break;\n-            else if (ret != 0)\n-            {\n-                LogPrintf(\"Error reading next record from wallet database\\n\");\n-                return DB_CORRUPT;\n-            }\n+            CDataStream ssKey((*it).first, SER_DISK, CLIENT_VERSION);\n+            CDataStream ssValue((*it).second, SER_DISK, CLIENT_VERSION);\n \n             // Try to be tolerant of single corrupt records:\n             string strType, strErr;\n@@ -661,7 +649,6 @@ DBErrors CWalletDB::LoadWallet(CWallet* pwallet)\n             if (!strErr.empty())\n                 LogPrintf(\"%s\\n\", strErr);\n         }\n-        pcursor->close();\n     }\n     catch (const boost::thread_interrupted&) {\n         throw;\n@@ -690,16 +677,12 @@ DBErrors CWalletDB::LoadWallet(CWallet* pwallet)\n     BOOST_FOREACH(uint256 hash, wss.vWalletUpgrade)\n         WriteTx(hash, pwallet->mapWallet[hash]);\n \n-    // Rewrite encrypted wallets of versions 0.4.0 and 0.5.0rc:\n-    if (wss.fIsEncrypted && (wss.nFileVersion == 40000 || wss.nFileVersion == 50000))\n-        return DB_NEED_REWRITE;\n-\n-    if (wss.nFileVersion < CLIENT_VERSION) // Update\n-        WriteVersion(CLIENT_VERSION);\n-\n     if (wss.fAnyUnordered)\n         result = ReorderTransactions(pwallet);\n \n+    if (fAutoTransaction)\n+        TxnCommit();\n+        \n     return result;\n }\n \n@@ -719,28 +702,12 @@ DBErrors CWalletDB::FindWalletTx(CWallet* pwallet, vector<uint256>& vTxHash, vec\n             pwallet->LoadMinVersion(nMinVersion);\n         }\n \n-        // Get cursor\n-        Dbc* pcursor = GetCursor();\n-        if (!pcursor)\n-        {\n-            LogPrintf(\"Error getting wallet database cursor\\n\");\n-            return DB_CORRUPT;\n-        }\n-\n-        while (true)\n+        for (CWalletDB::const_iterator it = begin(); it != end(); it++)\n         {\n             // Read next record\n-            CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n-            CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n-            int ret = ReadAtCursor(pcursor, ssKey, ssValue);\n-            if (ret == DB_NOTFOUND)\n-                break;\n-            else if (ret != 0)\n-            {\n-                LogPrintf(\"Error reading next record from wallet database\\n\");\n-                return DB_CORRUPT;\n-            }\n-\n+            CDataStream ssKey((*it).first, SER_DISK, CLIENT_VERSION);\n+            CDataStream ssValue((*it).second, SER_DISK, CLIENT_VERSION);\n+            \n             string strType;\n             ssKey >> strType;\n             if (strType == \"tx\") {\n@@ -754,7 +721,6 @@ DBErrors CWalletDB::FindWalletTx(CWallet* pwallet, vector<uint256>& vTxHash, vec\n                 vWtx.push_back(wtx);\n             }\n         }\n-        pcursor->close();\n     }\n     catch (const boost::thread_interrupted&) {\n         throw;\n@@ -788,68 +754,69 @@ DBErrors CWalletDB::ZapWalletTx(CWallet* pwallet, vector<CWalletTx>& vWtx)\n \n void ThreadFlushWalletDB(const string& strFile)\n {\n-    // Make this thread recognisable as the wallet flushing thread\n-    RenameThread(\"bitcoin-wallet\");\n-\n-    static bool fOneThread;\n-    if (fOneThread)\n-        return;\n-    fOneThread = true;\n-    if (!GetBoolArg(\"-flushwallet\", true))\n-        return;\n-\n-    unsigned int nLastSeen = nWalletDBUpdated;\n-    unsigned int nLastFlushed = nWalletDBUpdated;\n-    int64_t nLastWalletUpdate = GetTime();\n-    while (true)\n-    {\n-        MilliSleep(500);\n-\n-        if (nLastSeen != nWalletDBUpdated)\n-        {\n-            nLastSeen = nWalletDBUpdated;\n-            nLastWalletUpdate = GetTime();\n-        }\n-\n-        if (nLastFlushed != nWalletDBUpdated && GetTime() - nLastWalletUpdate >= 2)\n-        {\n-            TRY_LOCK(bitdb.cs_db,lockDb);\n-            if (lockDb)\n-            {\n-                // Don't do this if any databases are in use\n-                int nRefCount = 0;\n-                map<string, int>::iterator mi = bitdb.mapFileUseCount.begin();\n-                while (mi != bitdb.mapFileUseCount.end())\n-                {\n-                    nRefCount += (*mi).second;\n-                    mi++;\n-                }\n-\n-                if (nRefCount == 0)\n-                {\n-                    boost::this_thread::interruption_point();\n-                    map<string, int>::iterator mi = bitdb.mapFileUseCount.find(strFile);\n-                    if (mi != bitdb.mapFileUseCount.end())\n-                    {\n-                        LogPrint(\"db\", \"Flushing wallet.dat\\n\");\n-                        nLastFlushed = nWalletDBUpdated;\n-                        int64_t nStart = GetTimeMillis();\n-\n-                        // Flush wallet.dat so it's self contained\n-                        bitdb.CloseDb(strFile);\n-                        bitdb.CheckpointLSN(strFile);\n-\n-                        bitdb.mapFileUseCount.erase(mi++);\n-                        LogPrint(\"db\", \"Flushed wallet.dat %dms\\n\", GetTimeMillis() - nStart);\n-                    }\n-                }\n-            }\n-        }\n-    }\n+//    // Make this thread recognisable as the wallet flushing thread\n+//    RenameThread(\"bitcoin-wallet\");\n+//\n+//    static bool fOneThread;\n+//    if (fOneThread)\n+//        return;\n+//    fOneThread = true;\n+//    if (!GetBoolArg(\"-flushwallet\", true))\n+//        return;\n+//\n+//    unsigned int nLastSeen = nWalletDBUpdated;\n+//    unsigned int nLastFlushed = nWalletDBUpdated;\n+//    int64_t nLastWalletUpdate = GetTime();\n+//    while (true)\n+//    {\n+//        MilliSleep(500);\n+//\n+//        if (nLastSeen != nWalletDBUpdated)\n+//        {\n+//            nLastSeen = nWalletDBUpdated;\n+//            nLastWalletUpdate = GetTime();\n+//        }\n+//\n+//        if (nLastFlushed != nWalletDBUpdated && GetTime() - nLastWalletUpdate >= 2)\n+//        {\n+//            TRY_LOCK(bitdb.cs_db,lockDb);\n+//            if (lockDb)\n+//            {\n+//                // Don't do this if any databases are in use\n+//                int nRefCount = 0;\n+//                map<string, int>::iterator mi = bitdb.mapFileUseCount.begin();\n+//                while (mi != bitdb.mapFileUseCount.end())\n+//                {\n+//                    nRefCount += (*mi).second;\n+//                    mi++;\n+//                }\n+//\n+//                if (nRefCount == 0)\n+//                {\n+//                    boost::this_thread::interruption_point();\n+//                    map<string, int>::iterator mi = bitdb.mapFileUseCount.find(strFile);\n+//                    if (mi != bitdb.mapFileUseCount.end())\n+//                    {\n+//                        LogPrint(\"db\", \"Flushing wallet.dat\\n\");\n+//                        nLastFlushed = nWalletDBUpdated;\n+//                        int64_t nStart = GetTimeMillis();\n+//\n+//                        // Flush wallet.dat so it's self contained\n+//                        bitdb.CloseDb(strFile);\n+//                        bitdb.CheckpointLSN(strFile);\n+//\n+//                        bitdb.mapFileUseCount.erase(mi++);\n+//                        LogPrint(\"db\", \"Flushed wallet.dat %dms\\n\", GetTimeMillis() - nStart);\n+//                    }\n+//                }\n+//            }\n+//        }\n+//    }\n }\n \n bool BackupWallet(const CWallet& wallet, const string& strDest)\n {\n+    /*\n     if (!wallet.fFileBacked)\n         return false;\n     while (true)\n@@ -885,14 +852,16 @@ bool BackupWallet(const CWallet& wallet, const string& strDest)\n         }\n         MilliSleep(100);\n     }\n+     */\n     return false;\n }\n \n //\n // Try to (very carefully!) recover wallet.dat if there is a problem.\n //\n-bool CWalletDB::Recover(CDBEnv& dbenv, std::string filename, bool fOnlyKeys)\n+bool CWalletDB::Recover(std::string filename, bool fOnlyKeys)\n {\n+    /*\n     // Recovery procedure:\n     // move wallet.dat to wallet.timestamp.bak\n     // Call Salvage with fAggressive=true to\n@@ -966,11 +935,62 @@ bool CWalletDB::Recover(CDBEnv& dbenv, std::string filename, bool fOnlyKeys)\n     pdbCopy->close(0);\n \n     return fSuccess;\n+     */\n+    return false;\n }\n \n-bool CWalletDB::Recover(CDBEnv& dbenv, std::string filename)\n-{\n-    return CWalletDB::Recover(dbenv, filename, false);\n+bool CWalletDB::Recover(std::string filename)\n+{\n+    return CWalletDB::Recover(filename, false);\n+}\n+\n+bool CWalletDB::Verify(std::string filename, bool salvage)\n+{\n+    //TODO: implement\n+    \n+    //        if (!bitdb.Open(GetDataDir()))\n+    //        {\n+    //            // try moving the database env out of the way\n+    //            boost::filesystem::path pathDatabase = GetDataDir() / \"database\";\n+    //            boost::filesystem::path pathDatabaseBak = GetDataDir() / strprintf(\"database.%d.bak\", GetTime());\n+    //            try {\n+    //                boost::filesystem::rename(pathDatabase, pathDatabaseBak);\n+    //                LogPrintf(\"Moved old %s to %s. Retrying.\\n\", pathDatabase.string(), pathDatabaseBak.string());\n+    //            } catch (const boost::filesystem::filesystem_error&) {\n+    //                 // failure is ok (well, not really, but it's not worse than what we started with)\n+    //            }\n+    //\n+    //            // try again\n+    //            if (!bitdb.Open(GetDataDir())) {\n+    //                // if it still fails, it probably means we can't even create the database env\n+    //                string msg = strprintf(_(\"Error initializing wallet database environment %s!\"), strDataDir);\n+    //                return InitError(msg);\n+    //            }\n+    //        }\n+    //\n+    //        if (GetBoolArg(\"-salvagewallet\", false))\n+    //        {\n+    //            // Recover readable keypairs:\n+    //            if (!CWalletDB::Recover(strWalletFile, true))\n+    //                return false;\n+    //        }\n+    //\n+    //        if (filesystem::exists(GetDataDir() / strWalletFile))\n+    //        {\n+    //            CDBEnv::VerifyResult r = bitdb.Verify(strWalletFile, CWalletDB::Recover);\n+    //            if (r == CDBEnv::RECOVER_OK)\n+    //            {\n+    //                string msg = strprintf(_(\"Warning: wallet.dat corrupt, data salvaged!\"\n+    //                                         \" Original wallet.dat saved as wallet.{timestamp}.bak in %s; if\"\n+    //                                         \" your balance or transactions are incorrect you should\"\n+    //                                         \" restore from a backup.\"), strDataDir);\n+    //                InitWarning(msg);\n+    //            }\n+    //            if (r == CDBEnv::RECOVER_FAIL)\n+    //                return InitError(_(\"wallet.dat corrupt, salvage failed\"));\n+    //        }\n+    \n+    return true;\n }\n \n bool CWalletDB::WriteDestData(const std::string &address, const std::string &key, const std::string &value)"
      },
      {
        "sha": "c6fca2c8a5870a1e3df762dc732dae31eb7358be",
        "filename": "src/walletdb.h",
        "status": "modified",
        "additions": 10,
        "deletions": 6,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0f7be5e753801eb7add5ce73d6b39b25bcca9283/src/walletdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0f7be5e753801eb7add5ce73d6b39b25bcca9283/src/walletdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/walletdb.h?ref=0f7be5e753801eb7add5ce73d6b39b25bcca9283",
        "patch": "@@ -7,9 +7,10 @@\n #define BITCOIN_WALLETDB_H\n \n #include \"amount.h\"\n-#include \"db.h\"\n #include \"key.h\"\n #include \"keystore.h\"\n+#include \"logdb.h\"\n+#include \"util.h\"\n \n #include <list>\n #include <stdint.h>\n@@ -72,11 +73,11 @@ class CKeyMetadata\n     }\n };\n \n-/** Access to the wallet database (wallet.dat) */\n-class CWalletDB : public CDB\n+/** Access to the wallet database */\n+class CWalletDB : public CLogDB\n {\n public:\n-    CWalletDB(const std::string& strFilename, const char* pszMode = \"r+\", bool fFlushOnClose = true) : CDB(strFilename, pszMode, fFlushOnClose)\n+    CWalletDB(const std::string& strFilename, const char* pszMode = \"r+\", bool fFlushOnClose = true) : CLogDB( (GetDataDir() / strFilename).string(), (!strchr(pszMode, '+') && !strchr(pszMode, 'w')))\n     {\n     }\n \n@@ -127,8 +128,10 @@ class CWalletDB : public CDB\n     DBErrors LoadWallet(CWallet* pwallet);\n     DBErrors FindWalletTx(CWallet* pwallet, std::vector<uint256>& vTxHash, std::vector<CWalletTx>& vWtx);\n     DBErrors ZapWalletTx(CWallet* pwallet, std::vector<CWalletTx>& vWtx);\n-    static bool Recover(CDBEnv& dbenv, std::string filename, bool fOnlyKeys);\n-    static bool Recover(CDBEnv& dbenv, std::string filename);\n+    static bool Recover(std::string filename, bool fOnlyKeys);\n+    static bool Recover(std::string filename);\n+    \n+    static bool Verify(std::string filename, bool salvage);\n \n private:\n     CWalletDB(const CWalletDB&);\n@@ -138,5 +141,6 @@ class CWalletDB : public CDB\n };\n \n bool BackupWallet(const CWallet& wallet, const std::string& strDest);\n+void ThreadFlushWalletDB(const std::string& strWalletFile);\n \n #endif // BITCOIN_WALLETDB_H"
      }
    ]
  },
  {
    "sha": "34119f6de954627f33a4b3cd201a97f9086cf2d3",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozNDExOWY2ZGU5NTQ2MjdmMzNhNGIzY2QyMDFhOTdmOTA4NmNmMmQz",
    "commit": {
      "author": {
        "name": "Jonas Schnelli",
        "email": "jonas.schnelli@include7.ch",
        "date": "2015-01-07T12:42:42Z"
      },
      "committer": {
        "name": "Jonas Schnelli",
        "email": "jonas.schnelli@include7.ch",
        "date": "2015-02-05T08:43:52Z"
      },
      "message": "[Wallet] remove hard coded wallet.dat filename",
      "tree": {
        "sha": "94e1ada62b5b2817750bbbac2e88175c3b40e889",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/94e1ada62b5b2817750bbbac2e88175c3b40e889"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/34119f6de954627f33a4b3cd201a97f9086cf2d3",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/34119f6de954627f33a4b3cd201a97f9086cf2d3",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/34119f6de954627f33a4b3cd201a97f9086cf2d3",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/34119f6de954627f33a4b3cd201a97f9086cf2d3/comments",
    "author": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "0f7be5e753801eb7add5ce73d6b39b25bcca9283",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0f7be5e753801eb7add5ce73d6b39b25bcca9283",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0f7be5e753801eb7add5ce73d6b39b25bcca9283"
      }
    ],
    "stats": {
      "total": 19,
      "additions": 10,
      "deletions": 9
    },
    "files": [
      {
        "sha": "9cd99e2a9bd4568db0d4a85628204178087fbbb0",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 9,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/34119f6de954627f33a4b3cd201a97f9086cf2d3/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/34119f6de954627f33a4b3cd201a97f9086cf2d3/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=34119f6de954627f33a4b3cd201a97f9086cf2d3",
        "patch": "@@ -67,6 +67,7 @@ enum BindFlags {\n };\n \n static const char* FEE_ESTIMATES_FILENAME=\"fee_estimates.dat\";\n+static const char* DEFAULT_WALLET_FILENAME=\"wallet.wal\";\n CClientUIInterface uiInterface;\n \n //////////////////////////////////////////////////////////////////////////////\n@@ -324,13 +325,13 @@ std::string HelpMessage(HelpMessageMode mode)\n         strUsage += \"  -mintxfee=<amt>        \" + strprintf(_(\"Fees (in BTC/Kb) smaller than this are considered zero fee for transaction creation (default: %s)\"), FormatMoney(CWallet::minTxFee.GetFeePerK())) + \"\\n\";\n     strUsage += \"  -paytxfee=<amt>        \" + strprintf(_(\"Fee (in BTC/kB) to add to transactions you send (default: %s)\"), FormatMoney(payTxFee.GetFeePerK())) + \"\\n\";\n     strUsage += \"  -rescan                \" + _(\"Rescan the block chain for missing wallet transactions\") + \" \" + _(\"on startup\") + \"\\n\";\n-    strUsage += \"  -salvagewallet         \" + _(\"Attempt to recover private keys from a corrupt wallet.dat\") + \" \" + _(\"on startup\") + \"\\n\";\n+    strUsage += \"  -salvagewallet         \" + _(\"Attempt to recover private keys from a corrupt wallet file\") + \" \" + _(\"on startup\") + \"\\n\";\n     strUsage += \"  -sendfreetransactions  \" + strprintf(_(\"Send transactions as zero-fee transactions if possible (default: %u)\"), 0) + \"\\n\";\n     strUsage += \"  -spendzeroconfchange   \" + strprintf(_(\"Spend unconfirmed change when sending transactions (default: %u)\"), 1) + \"\\n\";\n     strUsage += \"  -txconfirmtarget=<n>   \" + strprintf(_(\"If paytxfee is not set, include enough fee so transactions begin confirmation on average within n blocks (default: %u)\"), 1) + \"\\n\";\n     strUsage += \"  -maxtxfee=<amt>        \" + strprintf(_(\"Maximum total fees to use in a single wallet transaction, setting too low may abort large transactions (default: %s)\"), FormatMoney(maxTxFee)) + \"\\n\";\n     strUsage += \"  -upgradewallet         \" + _(\"Upgrade wallet to latest format\") + \" \" + _(\"on startup\") + \"\\n\";\n-    strUsage += \"  -wallet=<file>         \" + _(\"Specify wallet file (within data directory)\") + \" \" + strprintf(_(\"(default: %s)\"), \"wallet.dat\") + \"\\n\";\n+    strUsage += \"  -wallet=<file>         \" + _(\"Specify wallet file (within data directory)\") + \" \" + strprintf(_(\"(default: %s)\"), DEFAULT_WALLET_FILENAME) + \"\\n\";\n     strUsage += \"  -walletnotify=<cmd>    \" + _(\"Execute command when a wallet transaction changes (%s in cmd is replaced by TxID)\") + \"\\n\";\n     strUsage += \"  -zapwallettxes=<mode>  \" + _(\"Delete all wallet transactions and only recover those parts of the blockchain through -rescan on startup\") + \"\\n\";\n     strUsage += \"                         \" + _(\"(1 = keep tx meta data e.g. account owner and payment request information, 2 = drop tx meta data)\") + \"\\n\";\n@@ -763,7 +764,7 @@ bool AppInit2(boost::thread_group& threadGroup)\n     bSpendZeroConfChange = GetArg(\"-spendzeroconfchange\", true);\n     fSendFreeTransactions = GetArg(\"-sendfreetransactions\", false);\n \n-    std::string strWalletFile = GetArg(\"-wallet\", \"wallet.dat\");\n+    std::string strWalletFile = GetArg(\"-wallet\", DEFAULT_WALLET_FILENAME);\n #endif // ENABLE_WALLET\n \n     fIsBareMultisigStd = GetArg(\"-permitbaremultisig\", true) != 0;\n@@ -1095,7 +1096,7 @@ bool AppInit2(boost::thread_group& threadGroup)\n             pwalletMain = new CWallet(strWalletFile);\n             DBErrors nZapWalletRet = pwalletMain->ZapWalletTx(vWtx);\n             if (nZapWalletRet != DB_LOAD_OK) {\n-                uiInterface.InitMessage(_(\"Error loading wallet.dat: Wallet corrupted\"));\n+                uiInterface.InitMessage(strprintf(_(\"Error loading wallet file (%s): Wallet corrupted\"), strWalletFile));\n                 return false;\n             }\n \n@@ -1112,23 +1113,23 @@ bool AppInit2(boost::thread_group& threadGroup)\n         if (nLoadWalletRet != DB_LOAD_OK)\n         {\n             if (nLoadWalletRet == DB_CORRUPT)\n-                strErrors << _(\"Error loading wallet.dat: Wallet corrupted\") << \"\\n\";\n+                strErrors << strprintf(_(\"Error loading wallet file (%s): Wallet corrupted\"), strWalletFile) << \"\\n\";\n             else if (nLoadWalletRet == DB_NONCRITICAL_ERROR)\n             {\n-                string msg(_(\"Warning: error reading wallet.dat! All keys read correctly, but transaction data\"\n-                             \" or address book entries might be missing or incorrect.\"));\n+                string msg(strprintf(_(\"Warning: error reading wallet file (%s)! All keys read correctly, but transaction data\"\n+                             \" or address book entries might be missing or incorrect.\"), strWalletFile));\n                 InitWarning(msg);\n             }\n             else if (nLoadWalletRet == DB_TOO_NEW)\n-                strErrors << _(\"Error loading wallet.dat: Wallet requires newer version of Bitcoin Core\") << \"\\n\";\n+                strErrors << strprintf(_(\"Error loading wallet file (%s): Wallet requires newer version of Bitcoin Core\"), strWalletFile) << \"\\n\";\n             else if (nLoadWalletRet == DB_NEED_REWRITE)\n             {\n                 strErrors << _(\"Wallet needed to be rewritten: restart Bitcoin Core to complete\") << \"\\n\";\n                 LogPrintf(\"%s\", strErrors.str());\n                 return InitError(strErrors.str());\n             }\n             else\n-                strErrors << _(\"Error loading wallet.dat\") << \"\\n\";\n+                strErrors << strprintf(_(\"Error loading wallet file (%s)\"), strWalletFile) << \"\\n\";\n         }\n \n         if (GetBoolArg(\"-upgradewallet\", fFirstRun))"
      }
    ]
  },
  {
    "sha": "f0415364548833c4a15f3f503f987cccc4668320",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmMDQxNTM2NDU0ODgzM2M0YTE1ZjNmNTAzZjk4N2NjY2M0NjY4MzIw",
    "commit": {
      "author": {
        "name": "Jonas Schnelli",
        "email": "jonas.schnelli@include7.ch",
        "date": "2015-01-07T15:22:33Z"
      },
      "committer": {
        "name": "Jonas Schnelli",
        "email": "jonas.schnelli@include7.ch",
        "date": "2015-02-05T08:43:52Z"
      },
      "message": "[Wallet] better flush/close handling of logdb\n\n- make sure std::map elements gets erased first\n- don't allow oversized keys/values in CLogDB::Write()\n- remove ref count\n- remove mem leak",
      "tree": {
        "sha": "4fe1cba97db5348a84765f5a4e357d124489cbf4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4fe1cba97db5348a84765f5a4e357d124489cbf4"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f0415364548833c4a15f3f503f987cccc4668320",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f0415364548833c4a15f3f503f987cccc4668320",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f0415364548833c4a15f3f503f987cccc4668320",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f0415364548833c4a15f3f503f987cccc4668320/comments",
    "author": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "34119f6de954627f33a4b3cd201a97f9086cf2d3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/34119f6de954627f33a4b3cd201a97f9086cf2d3",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/34119f6de954627f33a4b3cd201a97f9086cf2d3"
      }
    ],
    "stats": {
      "total": 116,
      "additions": 61,
      "deletions": 55
    },
    "files": [
      {
        "sha": "ece620407d8fdc396e651b02365f29d493b8c95f",
        "filename": "src/logdb.cpp",
        "status": "modified",
        "additions": 26,
        "deletions": 4,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f0415364548833c4a15f3f503f987cccc4668320/src/logdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f0415364548833c4a15f3f503f987cccc4668320/src/logdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/logdb.cpp?ref=f0415364548833c4a15f3f503f987cccc4668320",
        "patch": "@@ -6,7 +6,9 @@\n #include <unistd.h>\n \n #include \"logdb.h\"\n-#include \"util.h\"\n+\n+#define LOGDB_MAX_KEY_SIZE 0x1000\n+#define LOGDB_MAX_VALUE_SIZE 0x100000\n \n using namespace std;\n \n@@ -73,7 +75,6 @@ void CLogDBFile::Init_()\n     mapData.clear();\n     nUsed = 0;\n     nWritten = 0;\n-    nRefCount = 0;\n     setDirty.clear();\n }\n \n@@ -93,6 +94,7 @@ bool CLogDBFile::Write_(const data_t &key, const data_t &value, bool fOverwrite,\n     nUsed += key.size() + value.size();\n \n     // update data\n+    mapData.erase(key);\n     mapData.insert(make_pair(key, value));\n     if (!fLoad)\n         setDirty.insert(key);\n@@ -135,6 +137,8 @@ bool CLogDBFile::Close_()\n     if (file)\n     {\n         Flush_();\n+        \n+        LogPrintf(\"CLogDBFile::Close(): closing file\\n\");\n         fclose(file);\n         Init_();\n     }\n@@ -183,7 +187,7 @@ bool CLogDBFile::Load_()\n             LogPrintf(\"CLogDBFile::Load(): loading record mode %i\\n\", entry.nMode);\n \n             uint32_t nKeySize = ReadInt(file);\n-            if (nKeySize >= 0x1000)\n+            if (nKeySize >= LOGDB_MAX_KEY_SIZE)\n             {\n                 LogPrintf(\"CLogDBFile::Load(): oversizes key (%lu bytes)\\n\", (unsigned long)nKeySize);\n                 return false;\n@@ -203,7 +207,7 @@ bool CLogDBFile::Load_()\n             if (entry.nMode == 1)\n             {\n                 int nValueSize = ReadInt(file);\n-                if (nValueSize >= 0x100000)\n+                if (nValueSize >= LOGDB_MAX_VALUE_SIZE)\n                 {\n                     LogPrintf(\"CLogDBFile::Load(): oversized value (%lu bytes)\\n\", (unsigned long)nValueSize);\n                     return false;\n@@ -410,6 +414,16 @@ bool CLogDB::TxnCommit() {\n }\n \n bool CLogDB::Write_(const data_t &key, const data_t &value, bool fOverwrite) {\n+    if (key.size() >= LOGDB_MAX_KEY_SIZE)\n+    {\n+        LogPrintf(\"CLogDB::Write(): max keysize exceeded\\n\");\n+        return false;\n+    }\n+    if (value.size() >= LOGDB_MAX_VALUE_SIZE)\n+    {\n+        LogPrintf(\"CLogDB::Write(): max keysize exceeded\\n\");\n+        return false;\n+    }\n     if (fReadOnly)\n         return false;\n \n@@ -487,3 +501,11 @@ bool CLogDB::Exists_(const data_t &key) {\n \n     return fRet;\n }\n+\n+bool CLogDB::Flush(bool shutdown)\n+{\n+    boost::lock_guard<boost::shared_mutex> lock(db->mutex);\n+    bool state = db->Flush_();\n+    \n+    return state;\n+}"
      },
      {
        "sha": "4b5609e0a53ba284a73d67fde9781fec0b8ad17a",
        "filename": "src/logdb.h",
        "status": "modified",
        "additions": 18,
        "deletions": 42,
        "changes": 60,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f0415364548833c4a15f3f503f987cccc4668320/src/logdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f0415364548833c4a15f3f503f987cccc4668320/src/logdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/logdb.h?ref=f0415364548833c4a15f3f503f987cccc4668320",
        "patch": "@@ -12,6 +12,7 @@\n #include \"serialize.h\"\n #include \"streams.h\"\n #include \"sync.h\"\n+#include \"util.h\"\n #include \"version.h\"\n \n #include <boost/filesystem.hpp>\n@@ -37,9 +38,6 @@ class CLogDBFile\n     std::map<data_t, data_t> mapData;\n     size_t nUsed; // continuously updated\n     size_t nWritten; // updated when writing a new block\n-\n-    mutable CCriticalSection cs_nRefCount;\n-    int nRefCount; // number of attached CLogDB's\n     \n     // cached changes\n     std::set<data_t> setDirty;\n@@ -75,7 +73,7 @@ class CLogDBFile\n         file = fopen(pszFile, fCreate ? \"a+b\" : \"r+b\");\n \n         if (file == NULL) {\n-            printf(\"Error opening %s: %s\\n\", pszFile, strerror(errno));\n+            LogPrintf(\"Error opening %s: %s\\n\", pszFile, strerror(errno));\n                 return false;\n         }\n \n@@ -86,16 +84,8 @@ class CLogDBFile\n //    bool Close()            { CRITICAL_BLOCK(cs) return Close_();          return false; }\n //    bool IsDirty() const    { CRITICAL_BLOCK(cs) return !setDirty.empty(); return false; }\n //    bool IsOpen() const     { return file != NULL; }\n-\n-    bool Close() {\n-        boost::lock_guard<boost::shared_mutex> lock(mutex);\n-        return Close_();\n-    }\n };\n \n-\n-static std::vector<std::pair<std::string, CLogDBFile *> > openDbs;\n-\n class CLogDB\n {\n public:\n@@ -116,51 +106,37 @@ class CLogDB\n     bool TxnAbort();\n     bool TxnBegin();\n     bool TxnCommit();\n-\n+    bool Flush(bool shutdown = false);\n+    \n     CLogDB(std::string pathAndFile, bool fReadOnlyIn = false) : fReadOnly(fReadOnlyIn), fTransaction(false)\n     {\n-        //check if this db is already open\n-        bool found = false;\n-        for(std::vector<std::pair<std::string, CLogDBFile *> >::iterator it = openDbs.begin(); it != openDbs.end(); ++it) {\n-            if(it->first == pathAndFile)\n-            {\n-                db = it->second;\n-                found = true;\n-                break;\n-            }\n-            /* std::cout << *it; ... */\n-        }\n-        if(!found)\n-        {\n-            db = new CLogDBFile();\n-            bool createFile = true;\n-            if(boost::filesystem::exists(pathAndFile))\n-                createFile = false;\n-            \n-            db->Open(pathAndFile.c_str(), createFile);\n-            openDbs.push_back(make_pair(pathAndFile, db));\n-        }\n-\n-        LOCK(db->cs_nRefCount);\n-            db->nRefCount++;\n+        db = new CLogDBFile();\n+        bool createFile = true;\n+        if(boost::filesystem::exists(pathAndFile))\n+            createFile = false;\n+        \n+        db->Open(pathAndFile.c_str(), createFile);\n     }\n \n     ~CLogDB() {\n         TxnAbort();\n-        LOCK(db->cs_nRefCount);\n-        db->nRefCount--;\n-        if (db->nRefCount == 0)\n         {\n             boost::lock_guard<boost::shared_mutex> lock(db->mutex);\n-            db->Flush_();\n+            db->Close_();\n         }\n+        delete db;\n     }\n \n     bool Write(const data_t &key, const data_t &value);\n     bool Erase(const data_t &key);\n     bool Read(const data_t &key, data_t &value);\n     bool Exists(const data_t &key);\n-\n+    \n+    bool Close() {\n+        boost::lock_guard<boost::shared_mutex> lock(db->mutex);\n+        return db->Close_();\n+    }\n+    \n protected:\n     bool Write_(const data_t &key, const data_t &value, bool fOverwrite = true);\n     bool Erase_(const data_t &key);"
      },
      {
        "sha": "b7d9be202794358e4f3ba56b4a65e23180d4919a",
        "filename": "src/wallet.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 8,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f0415364548833c4a15f3f503f987cccc4668320/src/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f0415364548833c4a15f3f503f987cccc4668320/src/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.cpp?ref=f0415364548833c4a15f3f503f987cccc4668320",
        "patch": "@@ -498,12 +498,9 @@ bool CWallet::EncryptWallet(const SecureString& strWalletPassphrase)\n         Unlock(strWalletPassphrase);\n         NewKeyPool();\n         Lock();\n-\n-        // Need to completely rewrite the wallet file; if we don't, bdb might keep\n-        // bits of the unencrypted private key in slack space in the database file.\n-        //CDB::Rewrite(strWalletFile);\n-        //^^TODO\n-\n+        \n+        // Rewrite wallet because we may use a append only backend\n+        CWalletDB(strWalletFile).Rewrite();\n     }\n     NotifyStatusChanged(this);\n \n@@ -789,8 +786,7 @@ bool CWallet::IsChange(const CTxOut& txout) const\n \n bool CWallet::Flush(bool shutdown)\n {\n-    //TODO: implement\n-    return true;\n+    return CWalletDB(strWalletFile).Flush(shutdown);\n }\n \n int64_t CWalletTx::GetTxTime() const"
      },
      {
        "sha": "f273d9ac28db0b5007aa688be7b9d693dfa64a89",
        "filename": "src/walletdb.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 0,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f0415364548833c4a15f3f503f987cccc4668320/src/walletdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f0415364548833c4a15f3f503f987cccc4668320/src/walletdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/walletdb.cpp?ref=f0415364548833c4a15f3f503f987cccc4668320",
        "patch": "@@ -752,6 +752,15 @@ DBErrors CWalletDB::ZapWalletTx(CWallet* pwallet, vector<CWalletTx>& vWtx)\n     return DB_LOAD_OK;\n }\n \n+DBErrors CWalletDB::Rewrite()\n+{\n+    //TODO: implement\n+    //Here we need a way of write down the whole mapData to a new file\n+    //Flush_() needs to be rewritten\n+    \n+    return DB_LOAD_OK;\n+}\n+\n void ThreadFlushWalletDB(const string& strFile)\n {\n //    // Make this thread recognisable as the wallet flushing thread"
      },
      {
        "sha": "44b08430519795be9d02df337b31a09fd1556c12",
        "filename": "src/walletdb.h",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f0415364548833c4a15f3f503f987cccc4668320/src/walletdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f0415364548833c4a15f3f503f987cccc4668320/src/walletdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/walletdb.h?ref=f0415364548833c4a15f3f503f987cccc4668320",
        "patch": "@@ -128,11 +128,14 @@ class CWalletDB : public CLogDB\n     DBErrors LoadWallet(CWallet* pwallet);\n     DBErrors FindWalletTx(CWallet* pwallet, std::vector<uint256>& vTxHash, std::vector<CWalletTx>& vWtx);\n     DBErrors ZapWalletTx(CWallet* pwallet, std::vector<CWalletTx>& vWtx);\n+    \n+    DBErrors Rewrite();\n+    \n     static bool Recover(std::string filename, bool fOnlyKeys);\n     static bool Recover(std::string filename);\n     \n     static bool Verify(std::string filename, bool salvage);\n-\n+    \n private:\n     CWalletDB(const CWalletDB&);\n     void operator=(const CWalletDB&);"
      }
    ]
  },
  {
    "sha": "c856ad7f470de14d9d390bbec70614d651578bf5",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjODU2YWQ3ZjQ3MGRlMTRkOWQzOTBiYmVjNzA2MTRkNjUxNTc4YmY1",
    "commit": {
      "author": {
        "name": "Jonas Schnelli",
        "email": "jonas.schnelli@include7.ch",
        "date": "2015-01-12T09:02:01Z"
      },
      "committer": {
        "name": "Jonas Schnelli",
        "email": "jonas.schnelli@include7.ch",
        "date": "2015-02-05T08:50:21Z"
      },
      "message": "[Wallet] improve wallet <-> walletdb interface\n\n- add logdb unit test\n- remove usage of CWalletDB outside of CWallet\n- logdb: add version and file-start headerbytes\n- fix rpc test-framework after removing bdb\n- fix rpc_wallet_tests.cpp\n- correct Makefile and --disable-wallet handling\n- remove bitdb from TestSetup()",
      "tree": {
        "sha": "2ec20826d73a23d876c572fef8807e86468079eb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2ec20826d73a23d876c572fef8807e86468079eb"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c856ad7f470de14d9d390bbec70614d651578bf5",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c856ad7f470de14d9d390bbec70614d651578bf5",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c856ad7f470de14d9d390bbec70614d651578bf5",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c856ad7f470de14d9d390bbec70614d651578bf5/comments",
    "author": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f0415364548833c4a15f3f503f987cccc4668320",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f0415364548833c4a15f3f503f987cccc4668320",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f0415364548833c4a15f3f503f987cccc4668320"
      }
    ],
    "stats": {
      "total": 874,
      "additions": 390,
      "deletions": 484
    },
    "files": [
      {
        "sha": "eda5c55a3d2f7e56450105ea0ef37e92dcb1b817",
        "filename": "qa/rpc-tests/util.py",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c856ad7f470de14d9d390bbec70614d651578bf5/qa/rpc-tests/util.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c856ad7f470de14d9d390bbec70614d651578bf5/qa/rpc-tests/util.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/util.py?ref=c856ad7f470de14d9d390bbec70614d651578bf5",
        "patch": "@@ -119,7 +119,6 @@ def initialize_chain(test_dir):\n         wait_bitcoinds()\n         for i in range(4):\n             os.remove(log_filename(\"cache\", i, \"debug.log\"))\n-            os.remove(log_filename(\"cache\", i, \"db.log\"))\n             os.remove(log_filename(\"cache\", i, \"peers.dat\"))\n             os.remove(log_filename(\"cache\", i, \"fee_estimates.dat\"))\n "
      },
      {
        "sha": "19312d9729824815a45ce5d07c1d4ba90f8d9f11",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c856ad7f470de14d9d390bbec70614d651578bf5/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c856ad7f470de14d9d390bbec70614d651578bf5/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=c856ad7f470de14d9d390bbec70614d651578bf5",
        "patch": "@@ -99,6 +99,7 @@ BITCOIN_CORE_H = \\\n   keystore.h \\\n   leveldbwrapper.h \\\n   limitedmap.h \\\n+  logdb.h \\\n   main.h \\\n   merkleblock.h \\\n   miner.h \\"
      },
      {
        "sha": "cd7c6092175a5f364d0319d6c71cb0f6b79ea81d",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c856ad7f470de14d9d390bbec70614d651578bf5/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c856ad7f470de14d9d390bbec70614d651578bf5/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=c856ad7f470de14d9d390bbec70614d651578bf5",
        "patch": "@@ -74,8 +74,9 @@ BITCOIN_TESTS =\\\n if ENABLE_WALLET\n BITCOIN_TESTS += \\\n   test/accounting_tests.cpp \\\n-  test/wallet_tests.cpp \\\n-  test/rpc_wallet_tests.cpp\n+  test/logdb_tests.cpp \\\n+  test/rpc_wallet_tests.cpp \\\n+  test/wallet_tests.cpp\n endif\n \n test_test_bitcoin_SOURCES = $(BITCOIN_TESTS) $(JSON_TEST_FILES) $(RAW_TEST_FILES)"
      },
      {
        "sha": "28d15737f216ab4d2b3483cef738dc3355b46a77",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 35,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c856ad7f470de14d9d390bbec70614d651578bf5/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c856ad7f470de14d9d390bbec70614d651578bf5/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=c856ad7f470de14d9d390bbec70614d651578bf5",
        "patch": "@@ -25,7 +25,6 @@\n #include \"utilmoneystr.h\"\n #ifdef ENABLE_WALLET\n #include \"wallet.h\"\n-#include \"walletdb.h\"\n #endif\n \n #include <stdint.h>\n@@ -46,6 +45,7 @@ using namespace std;\n \n #ifdef ENABLE_WALLET\n CWallet* pwalletMain = NULL;\n+static const char* DEFAULT_WALLET_FILENAME=\"wallet.wal\";\n #endif\n bool fFeeEstimatesInitialized = false;\n \n@@ -67,7 +67,6 @@ enum BindFlags {\n };\n \n static const char* FEE_ESTIMATES_FILENAME=\"fee_estimates.dat\";\n-static const char* DEFAULT_WALLET_FILENAME=\"wallet.wal\";\n CClientUIInterface uiInterface;\n \n //////////////////////////////////////////////////////////////////////////////\n@@ -1089,13 +1088,14 @@ bool AppInit2(boost::thread_group& threadGroup)\n \n         // needed to restore wallet transaction meta data after -zapwallettxes\n         std::vector<CWalletTx> vWtx;\n-\n+        bool fFirstRun = true;\n+        \n         if (GetBoolArg(\"-zapwallettxes\", false)) {\n             uiInterface.InitMessage(_(\"Zapping all transactions from wallet...\"));\n \n             pwalletMain = new CWallet(strWalletFile);\n-            DBErrors nZapWalletRet = pwalletMain->ZapWalletTx(vWtx);\n-            if (nZapWalletRet != DB_LOAD_OK) {\n+            pwalletMain->LoadWallet(fFirstRun);\n+            if (!pwalletMain->ZapWalletTx(vWtx)) {\n                 uiInterface.InitMessage(strprintf(_(\"Error loading wallet file (%s): Wallet corrupted\"), strWalletFile));\n                 return false;\n             }\n@@ -1107,7 +1107,6 @@ bool AppInit2(boost::thread_group& threadGroup)\n         uiInterface.InitMessage(_(\"Loading wallet...\"));\n \n         nStart = GetTimeMillis();\n-        bool fFirstRun = true;\n         pwalletMain = new CWallet(strWalletFile);\n         DBErrors nLoadWalletRet = pwalletMain->LoadWallet(fFirstRun);\n         if (nLoadWalletRet != DB_LOAD_OK)\n@@ -1120,32 +1119,12 @@ bool AppInit2(boost::thread_group& threadGroup)\n                              \" or address book entries might be missing or incorrect.\"), strWalletFile));\n                 InitWarning(msg);\n             }\n-            else if (nLoadWalletRet == DB_TOO_NEW)\n-                strErrors << strprintf(_(\"Error loading wallet file (%s): Wallet requires newer version of Bitcoin Core\"), strWalletFile) << \"\\n\";\n-            else if (nLoadWalletRet == DB_NEED_REWRITE)\n-            {\n-                strErrors << _(\"Wallet needed to be rewritten: restart Bitcoin Core to complete\") << \"\\n\";\n-                LogPrintf(\"%s\", strErrors.str());\n-                return InitError(strErrors.str());\n-            }\n-            else\n-                strErrors << strprintf(_(\"Error loading wallet file (%s)\"), strWalletFile) << \"\\n\";\n         }\n \n         if (GetBoolArg(\"-upgradewallet\", fFirstRun))\n         {\n-            int nMaxVersion = GetArg(\"-upgradewallet\", 0);\n-            if (nMaxVersion == 0) // the -upgradewallet without argument case\n-            {\n-                LogPrintf(\"Performing wallet upgrade to %i\\n\", FEATURE_LATEST);\n-                nMaxVersion = CLIENT_VERSION;\n-                pwalletMain->SetMinVersion(FEATURE_LATEST); // permanently upgrade the wallet immediately\n-            }\n-            else\n-                LogPrintf(\"Allowing wallet upgrade up to %i\\n\", nMaxVersion);\n-            if (nMaxVersion < pwalletMain->GetVersion())\n-                strErrors << _(\"Cannot downgrade wallet\") << \"\\n\";\n-            pwalletMain->SetMaxVersion(nMaxVersion);\n+            LogPrintf(\"There is no upgrade required (your version: %d)\\n\", pwalletMain->GetVersion());\n+\n         }\n \n         if (fFirstRun)\n@@ -1173,9 +1152,8 @@ bool AppInit2(boost::thread_group& threadGroup)\n             pindexRescan = chainActive.Genesis();\n         else\n         {\n-            CWalletDB walletdb(strWalletFile);\n             CBlockLocator locator;\n-            if (walletdb.ReadBestBlock(locator))\n+            if (pwalletMain->ReadBestBlock(locator))\n                 pindexRescan = FindForkInGlobalIndex(chainActive, locator);\n             else\n                 pindexRescan = chainActive.Genesis();\n@@ -1188,7 +1166,6 @@ bool AppInit2(boost::thread_group& threadGroup)\n             pwalletMain->ScanForWalletTransactions(pindexRescan, true);\n             LogPrintf(\" rescan      %15dms\\n\", GetTimeMillis() - nStart);\n             pwalletMain->SetBestChain(chainActive.GetLocator());\n-            nWalletDBUpdated++;\n \n             // Restore wallet transaction metadata after -zapwallettxes=1\n             if (GetBoolArg(\"-zapwallettxes\", false) && GetArg(\"-zapwallettxes\", \"1\") != \"2\")\n@@ -1210,7 +1187,7 @@ bool AppInit2(boost::thread_group& threadGroup)\n                         copyTo->fFromMe = copyFrom->fFromMe;\n                         copyTo->strFromAccount = copyFrom->strFromAccount;\n                         copyTo->nOrderPos = copyFrom->nOrderPos;\n-                        copyTo->WriteToDisk(&walletdb);\n+                        pwalletMain->WriteTxToDisk(*copyTo);\n                     }\n                 }\n             }\n@@ -1278,9 +1255,6 @@ bool AppInit2(boost::thread_group& threadGroup)\n     if (pwalletMain) {\n         // Add wallet transactions that aren't already in a block to mapTransactions\n         pwalletMain->ReacceptWalletTransactions();\n-\n-        // Run a thread to flush wallet periodically\n-        threadGroup.create_thread(boost::bind(&ThreadFlushWalletDB, boost::ref(pwalletMain->strWalletFile)));\n     }\n #endif\n "
      },
      {
        "sha": "f545e39fc361a370ef8d4de60d4107261fd34f2f",
        "filename": "src/logdb.cpp",
        "status": "modified",
        "additions": 57,
        "deletions": 7,
        "changes": 64,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c856ad7f470de14d9d390bbec70614d651578bf5/src/logdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c856ad7f470de14d9d390bbec70614d651578bf5/src/logdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/logdb.cpp?ref=c856ad7f470de14d9d390bbec70614d651578bf5",
        "patch": "@@ -76,6 +76,40 @@ void CLogDBFile::Init_()\n     nUsed = 0;\n     nWritten = 0;\n     setDirty.clear();\n+    version = logdb_version;\n+}\n+\n+bool CLogDBFile::Open_(const char *pszFile, bool fCreate)\n+{\n+    file = fopen(pszFile, fCreate ? \"a+b\" : \"r+b\");\n+    \n+    if (file == NULL) {\n+        LogPrintf(\"CLogDB::Open Error opening %s: %s\\n\", pszFile, strerror(errno));\n+        return false;\n+    }\n+    \n+    if (fCreate)\n+    {\n+        if (ftell(file) > 0)\n+        {\n+            LogPrintf(\"CLogDB::Open Error creating %s. Existing file detected\\n\", pszFile);\n+            return false;\n+        }\n+        else\n+        {\n+            if (fwrite(logdb_header_magic, 4, 1, file) != 1)\n+            {\n+                LogPrintf(\"CLogDBFile::Flush_(): error writing magic: %s\\n\", strerror(errno));\n+            }\n+            WriteInt(file, version);\n+            fflush(file);\n+            FileCommit(file);\n+            fclose(file);\n+            file = fopen(pszFile, \"r+b\");\n+        }\n+    }\n+    \n+    return true;\n }\n \n bool CLogDBFile::Write_(const data_t &key, const data_t &value, bool fOverwrite, bool fLoad)\n@@ -147,14 +181,26 @@ bool CLogDBFile::Close_()\n \n bool CLogDBFile::Load_()\n {\n+    if (feof(file))\n+        return true;\n+    \n+    //logdb header\n+    if (getc(file) != logdb_header_magic[0]) return feof(file);\n+    if (getc(file) != logdb_header_magic[1]) return false;\n+    if (getc(file) != logdb_header_magic[2]) return false;\n+    if (getc(file) != logdb_header_magic[3]) return false;\n+    \n+    version = ReadInt(file);\n+    if (version == 0) return false;\n+    \n     do\n     {\n         if (feof(file))\n             return true;\n-        if (getc(file) != 0xCC) return feof(file);\n-        if (getc(file) != 0xC4) return false;\n-        if (getc(file) != 0xE6) return false;\n-        if (getc(file) != 0xB0) return false;\n+        if (getc(file) != logdb_frameheader_magic[0]) return feof(file);\n+        if (getc(file) != logdb_frameheader_magic[1]) return false;\n+        if (getc(file) != logdb_frameheader_magic[2]) return false;\n+        if (getc(file) != logdb_frameheader_magic[3]) return false;\n \n         LogPrintf(\"CLogDB::Load(): frame header found\\n\");\n \n@@ -280,9 +326,7 @@ bool CLogDBFile::Flush_()\n \n     LogPrintf(\"CLogDBFile::Flush_(): dirty entries found\\n\");\n \n-    unsigned char magic[4]={0xCC,0xC4,0xE6,0xB0};\n-\n-    if (fwrite(magic, 4, 1, file) != 1)\n+    if (fwrite(logdb_frameheader_magic, 4, 1, file) != 1)\n     {\n         LogPrintf(\"CLogDBFile::Flush_(): error writing magic: %s\\n\", strerror(errno));\n     }\n@@ -410,9 +454,15 @@ bool CLogDB::TxnCommit() {\n     else\n         db->mutex.unlock();\n \n+    db->Flush_();\n+    \n     return true;\n }\n \n+bool CLogDB::Load() {\n+    return db->Load_();\n+}\n+\n bool CLogDB::Write_(const data_t &key, const data_t &value, bool fOverwrite) {\n     if (key.size() >= LOGDB_MAX_KEY_SIZE)\n     {"
      },
      {
        "sha": "bf5a02cbf69ccc82ef95ac5db20dea5899a4daff",
        "filename": "src/logdb.h",
        "status": "modified",
        "additions": 9,
        "deletions": 11,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c856ad7f470de14d9d390bbec70614d651578bf5/src/logdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c856ad7f470de14d9d390bbec70614d651578bf5/src/logdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/logdb.h?ref=c856ad7f470de14d9d390bbec70614d651578bf5",
        "patch": "@@ -20,7 +20,9 @@\n \n #include \"crypto/sha256.h\"\n \n-extern unsigned int nWalletDBUpdated;\n+static const unsigned char logdb_frameheader_magic[4] = {0xB1,0xA0,0xEE,0xC9};\n+static const unsigned char logdb_header_magic[4]      = {0xCC,0xC4,0xE6,0xB0};\n+static const int64_t logdb_version                    = 10000;\n \n typedef std::vector<unsigned char> data_t;\n \n@@ -33,7 +35,8 @@ class CLogDBFile\n \n     FILE *file;\n     CSHA256 ctxState;\n-\n+    uint64_t version;\n+    \n     // database\n     std::map<data_t, data_t> mapData;\n     size_t nUsed; // continuously updated\n@@ -52,8 +55,9 @@ class CLogDBFile\n     bool Exists_(const data_t &key) const;\n     bool Erase_(const data_t &key, bool fLoad = false);\n     bool Flush_();\n+    bool Open_(const char *pszFile, bool fCreate = true);\n     bool Close_();\n-\n+    \n public:\n     CLogDBFile()\n     {\n@@ -70,14 +74,7 @@ class CLogDBFile\n         boost::lock_guard<boost::shared_mutex> lock(mutex);\n         Close_();\n \n-        file = fopen(pszFile, fCreate ? \"a+b\" : \"r+b\");\n-\n-        if (file == NULL) {\n-            LogPrintf(\"Error opening %s: %s\\n\", pszFile, strerror(errno));\n-                return false;\n-        }\n-\n-        return Load_();\n+        return Open_(pszFile, fCreate);\n     }\n \n //    bool Flush()            { CRITICAL_BLOCK(cs) return Flush_();          return false; }\n@@ -131,6 +128,7 @@ class CLogDB\n     bool Erase(const data_t &key);\n     bool Read(const data_t &key, data_t &value);\n     bool Exists(const data_t &key);\n+    bool Load();\n     \n     bool Close() {\n         boost::lock_guard<boost::shared_mutex> lock(db->mutex);"
      },
      {
        "sha": "a65be6bbe0e7f76784f16d63f50531c520f381f6",
        "filename": "src/rpcwallet.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 43,
        "changes": 50,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c856ad7f470de14d9d390bbec70614d651578bf5/src/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c856ad7f470de14d9d390bbec70614d651578bf5/src/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcwallet.cpp?ref=c856ad7f470de14d9d390bbec70614d651578bf5",
        "patch": "@@ -14,7 +14,6 @@\n #include \"util.h\"\n #include \"utilmoneystr.h\"\n #include \"wallet.h\"\n-#include \"walletdb.h\"\n \n #include <stdint.h>\n \n@@ -114,10 +113,8 @@ Value getnewaddress(const Array& params, bool fHelp)\n \n CBitcoinAddress GetAccountAddress(string strAccount, bool bForceNew=false)\n {\n-    CWalletDB walletdb(pwalletMain->strWalletFile);\n-\n     CAccount account;\n-    walletdb.ReadAccount(strAccount, account);\n+    pwalletMain->ReadAccount(strAccount, account);\n \n     bool bKeyUsed = false;\n \n@@ -143,7 +140,7 @@ CBitcoinAddress GetAccountAddress(string strAccount, bool bForceNew=false)\n             throw JSONRPCError(RPC_WALLET_KEYPOOL_RAN_OUT, \"Error: Keypool ran out, please call keypoolrefill first\");\n \n         pwalletMain->SetAddressBook(account.vchPubKey.GetID(), strAccount, \"receive\");\n-        walletdb.WriteAccount(strAccount, account);\n+        pwalletMain->WriteAccount(strAccount, account);\n     }\n \n     return CBitcoinAddress(account.vchPubKey.GetID());\n@@ -607,7 +604,7 @@ Value getreceivedbyaccount(const Array& params, bool fHelp)\n }\n \n \n-CAmount GetAccountBalance(CWalletDB& walletdb, const string& strAccount, int nMinDepth, const isminefilter& filter)\n+CAmount GetAccountBalance(const string& strAccount, int nMinDepth, const isminefilter& filter)\n {\n     CAmount nBalance = 0;\n \n@@ -627,18 +624,11 @@ CAmount GetAccountBalance(CWalletDB& walletdb, const string& strAccount, int nMi\n     }\n \n     // Tally internal accounting entries\n-    nBalance += walletdb.GetAccountCreditDebit(strAccount);\n+    nBalance += pwalletMain->GetAccountCreditDebit(strAccount);\n \n     return nBalance;\n }\n \n-CAmount GetAccountBalance(const string& strAccount, int nMinDepth, const isminefilter& filter)\n-{\n-    CWalletDB walletdb(pwalletMain->strWalletFile);\n-    return GetAccountBalance(walletdb, strAccount, nMinDepth, filter);\n-}\n-\n-\n Value getbalance(const Array& params, bool fHelp)\n {\n     if (fHelp || params.size() > 3)\n@@ -758,35 +748,9 @@ Value movecmd(const Array& params, bool fHelp)\n     if (params.size() > 4)\n         strComment = params[4].get_str();\n \n-    CWalletDB walletdb(pwalletMain->strWalletFile);\n-    if (!walletdb.TxnBegin())\n-        throw JSONRPCError(RPC_DATABASE_ERROR, \"database error\");\n-\n-    int64_t nNow = GetAdjustedTime();\n-\n-    // Debit\n-    CAccountingEntry debit;\n-    debit.nOrderPos = pwalletMain->IncOrderPosNext(&walletdb);\n-    debit.strAccount = strFrom;\n-    debit.nCreditDebit = -nAmount;\n-    debit.nTime = nNow;\n-    debit.strOtherAccount = strTo;\n-    debit.strComment = strComment;\n-    walletdb.WriteAccountingEntry(debit);\n-\n-    // Credit\n-    CAccountingEntry credit;\n-    credit.nOrderPos = pwalletMain->IncOrderPosNext(&walletdb);\n-    credit.strAccount = strTo;\n-    credit.nCreditDebit = nAmount;\n-    credit.nTime = nNow;\n-    credit.strOtherAccount = strFrom;\n-    credit.strComment = strComment;\n-    walletdb.WriteAccountingEntry(credit);\n-\n-    if (!walletdb.TxnCommit())\n-        throw JSONRPCError(RPC_DATABASE_ERROR, \"database error\");\n \n+    pwalletMain->MoveAccount(strFrom, strTo, nAmount, strComment);\n+    \n     return true;\n }\n \n@@ -1452,7 +1416,7 @@ Value listaccounts(const Array& params, bool fHelp)\n     }\n \n     list<CAccountingEntry> acentries;\n-    CWalletDB(pwalletMain->strWalletFile).ListAccountCreditDebit(\"*\", acentries);\n+    pwalletMain->ListAccountCreditDebit(\"*\", acentries);\n     BOOST_FOREACH(const CAccountingEntry& entry, acentries)\n         mapAccountBalances[entry.strAccount] += entry.nCreditDebit;\n "
      },
      {
        "sha": "9e4d348659afa9e070fb1ef4e91200f24b8471ee",
        "filename": "src/test/logdb_tests.cpp",
        "status": "added",
        "additions": 140,
        "deletions": 0,
        "changes": 140,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c856ad7f470de14d9d390bbec70614d651578bf5/src/test/logdb_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c856ad7f470de14d9d390bbec70614d651578bf5/src/test/logdb_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/logdb_tests.cpp?ref=c856ad7f470de14d9d390bbec70614d651578bf5",
        "patch": "@@ -0,0 +1,140 @@\n+// Copyright (c) 2013 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"base58.h\"\n+#include \"key.h\"\n+#include \"logdb.h\"\n+#include \"random.h\"\n+#include \"util.h\"\n+\n+#include <boost/test/unit_test.hpp>\n+\n+using namespace std;\n+static const string strSecret1     (\"Kwr371tjA9u2rFSMZjTNun2PXXP3WPZu2afRHTcta6KxEUdm1vEw\");\n+static const string strSecret2    (\"L3Hq7a8FEQwJkW1M2GNKDW28546Vp5miewcCzSqUD9kCAXrJdS3g\");\n+\n+BOOST_AUTO_TEST_SUITE(logdb_tests)\n+\n+BOOST_AUTO_TEST_CASE(logdb_test_1)\n+{\n+    boost::filesystem::path tmpPath = GetTempPath() / strprintf(\"test_bitcoin_logdb_%lu_%i.logdb\", (unsigned long)GetTime(), (int)(GetRand(100000)));    \n+    std::string dbFile = tmpPath.string();\n+    \n+    int max_loops = 1;\n+    \n+    for(int i = 0;i<max_loops;i++)\n+    {\n+        \n+        // simple value test\n+        CLogDB *aDB = new CLogDB(dbFile, false);\n+        aDB->Load();\n+        aDB->Write(std::string(\"testvalue\"), std::string(\"aValue\"));\n+        aDB->Flush(true); //shutdown, close the file\n+        aDB->Close();\n+        delete aDB;\n+        \n+        aDB = new CLogDB(dbFile, false);\n+        aDB->Load();\n+        std::string returnString;\n+        aDB->Read(std::string(\"testvalue\"), returnString);\n+        BOOST_CHECK_EQUAL(returnString, std::string(\"aValue\"));\n+        aDB->Write(std::string(\"testvalue\"), std::string(\"aValue2\"));\n+        aDB->Read(std::string(\"testvalue\"), returnString);\n+        BOOST_CHECK_EQUAL(returnString, std::string(\"aValue2\"));\n+        aDB->Flush(true); //shutdown, close the file\n+        aDB->Close();\n+        delete aDB;\n+        \n+        aDB = new CLogDB(dbFile, false);\n+        aDB->Load();\n+        aDB->Erase(std::string(\"testvalue\"));\n+        \n+        std::string returnString2;\n+        aDB->Read(std::string(\"testvalue\"), returnString2);\n+        BOOST_CHECK(returnString2 == \"\");\n+        aDB->Flush(true); //shutdown, close the file\n+        aDB->Close();\n+        delete aDB;\n+\n+        // store a key\n+        CLogDB *aDB2 = new CLogDB(dbFile, false);\n+        aDB2->Load();\n+        aDB2->Read(std::string(\"testvalue\"), returnString);\n+        BOOST_CHECK_EQUAL(returnString, std::string(\"aValue2\"));\n+        \n+        CBitcoinSecret bsecret;\n+        BOOST_CHECK( bsecret.SetString (strSecret1));\n+        CKey key1  = bsecret.GetKey();\n+        CPubKey pKey = key1.GetPubKey();\n+        aDB2->Write(std::string(\"keyOverwriteTest\"), pKey);\n+        aDB2->Flush(true); //shutdown, close the file\n+        aDB2->Close();\n+        delete aDB2;\n+        \n+        // overwrite existing key with a new pubkey\n+        aDB2 = new CLogDB(dbFile, false);\n+        aDB2->Load();\n+        bsecret.SetString(strSecret2);\n+        CKey key2  = bsecret.GetKey();\n+        CPubKey pKey2 = key2.GetPubKey();\n+        aDB2->Write(std::string(\"keyOverwriteTest\"), pKey2);\n+        aDB2->Flush(true); //shutdown, close the file\n+        aDB2->Close();\n+        delete aDB2;\n+\n+        // persistance and erase test\n+        aDB2 = new CLogDB(dbFile, false);\n+        aDB2->Load();\n+        CPubKey pKeyTest;\n+        aDB2->Read(std::string(\"keyOverwriteTest\"), pKeyTest);\n+        \n+        BOOST_CHECK(pKey2 == pKeyTest);\n+        BOOST_CHECK(pKey != pKeyTest);\n+        BOOST_CHECK(pKeyTest.IsValid() == true);\n+\n+        aDB2->Erase(std::string(\"keyOverwriteTest\"));\n+        CPubKey pKeyTestEmpty;\n+        aDB2->Read(std::string(\"keyOverwriteTest\"), pKeyTestEmpty);\n+        BOOST_CHECK(pKeyTestEmpty.IsValid() == false);\n+        aDB2->Flush(true); //shutdown, close the file\n+        aDB2->Close();\n+        delete aDB2;\n+        \n+        // check persistance of Erase\n+        aDB2 = new CLogDB(dbFile, false);\n+        aDB2->Load();\n+        CPubKey pKeyTestEmpty2;\n+        aDB2->Read(std::string(\"keyOverwriteTest\"), pKeyTestEmpty2);\n+        BOOST_CHECK(pKeyTestEmpty2.IsValid() == false);\n+        \n+        //maxKeySize\n+        std::string longKey = std::string(999,'a');\n+        bool state = aDB2->Write(longKey, std::string(\"newValue\"));\n+        BOOST_CHECK(state);\n+        aDB2->Flush(true); //shutdown, close the file\n+        aDB2->Close();\n+        delete aDB2;\n+        \n+        aDB2 = new CLogDB(dbFile, false);\n+        aDB2->Load();\n+        std::string newString;\n+        aDB2->Read(longKey, newString);\n+        BOOST_CHECK(newString == \"newValue\");\n+        aDB2->Flush(true); //shutdown, close the file\n+        \n+        std::string longKey2 = std::string(0x1001,'b');\n+        state = aDB2->Write(longKey2, std::string(\"newValue2\"));\n+        BOOST_CHECK(state == false);\n+        \n+        std::string newString2;\n+        aDB2->Read(longKey2, newString2);\n+        BOOST_CHECK(newString2 == \"\");\n+        \n+        aDB2->Close();\n+        delete aDB2;\n+    }\n+    \n+}\n+\n+BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "12a360629a11ddb5ad8fb50ba48187fd3bb497c1",
        "filename": "src/test/rpc_wallet_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c856ad7f470de14d9d390bbec70614d651578bf5/src/test/rpc_wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c856ad7f470de14d9d390bbec70614d651578bf5/src/test/rpc_wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/rpc_wallet_tests.cpp?ref=c856ad7f470de14d9d390bbec70614d651578bf5",
        "patch": "@@ -73,11 +73,10 @@ BOOST_AUTO_TEST_CASE(rpc_wallet)\n     string strAccount = \"walletDemoAccount\";\n     string strPurpose = \"receive\";\n     BOOST_CHECK_NO_THROW({ /*Initialize Wallet with an account */\n-        CWalletDB walletdb(pwalletMain->strWalletFile);\n         CAccount account;\n         account.vchPubKey = demoPubkey;\n         pwalletMain->SetAddressBook(account.vchPubKey.GetID(), strAccount, strPurpose);\n-        walletdb.WriteAccount(strAccount, account);\n+        pwalletMain->WriteAccount(strAccount, account);\n     });\n \n     CPubKey setaccountDemoPubkey = pwalletMain->GenerateNewKey();"
      },
      {
        "sha": "4aa709d4f6c1abd2186a43f40f3476d186690449",
        "filename": "src/test/test_bitcoin.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 8,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c856ad7f470de14d9d390bbec70614d651578bf5/src/test/test_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c856ad7f470de14d9d390bbec70614d651578bf5/src/test/test_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.cpp?ref=c856ad7f470de14d9d390bbec70614d651578bf5",
        "patch": "@@ -10,7 +10,6 @@\n #include \"ui_interface.h\"\n #include \"util.h\"\n #ifdef ENABLE_WALLET\n-#include \"db.h\"\n #include \"wallet.h\"\n #endif\n \n@@ -33,9 +32,6 @@ struct TestingSetup {\n         fPrintToDebugLog = false; // don't want to write to debug.log file\n         SelectParams(CBaseChainParams::UNITTEST);\n         noui_connect();\n-#ifdef ENABLE_WALLET\n-        bitdb.MakeMock();\n-#endif\n         pathTemp = GetTempPath() / strprintf(\"test_bitcoin_%lu_%i\", (unsigned long)GetTime(), (int)(GetRand(100000)));\n         boost::filesystem::create_directories(pathTemp);\n         mapArgs[\"-datadir\"] = pathTemp.string();\n@@ -45,7 +41,7 @@ struct TestingSetup {\n         InitBlockIndex();\n #ifdef ENABLE_WALLET\n         bool fFirstRun;\n-        pwalletMain = new CWallet(\"wallet.dat\");\n+        pwalletMain = new CWallet(\"wallet.wal\");\n         pwalletMain->LoadWallet(fFirstRun);\n         RegisterValidationInterface(pwalletMain);\n #endif\n@@ -66,9 +62,6 @@ struct TestingSetup {\n         delete pcoinsTip;\n         delete pcoinsdbview;\n         delete pblocktree;\n-#ifdef ENABLE_WALLET\n-        bitdb.Flush(true);\n-#endif\n         boost::filesystem::remove_all(pathTemp);\n     }\n };"
      },
      {
        "sha": "66b0692dc8f09a95e55db15a0cd8469466083141",
        "filename": "src/wallet.cpp",
        "status": "modified",
        "additions": 108,
        "deletions": 118,
        "changes": 226,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c856ad7f470de14d9d390bbec70614d651578bf5/src/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c856ad7f470de14d9d390bbec70614d651578bf5/src/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.cpp?ref=c856ad7f470de14d9d390bbec70614d651578bf5",
        "patch": "@@ -25,6 +25,7 @@ using namespace std;\n /**\n  * Settings\n  */\n+\n CFeeRate payTxFee(DEFAULT_TRANSACTION_FEE);\n CAmount maxTxFee = DEFAULT_TRANSACTION_MAXFEE;\n unsigned int nTxConfirmTarget = 1;\n@@ -69,15 +70,10 @@ const CWalletTx* CWallet::GetWalletTx(const uint256& hash) const\n CPubKey CWallet::GenerateNewKey()\n {\n     AssertLockHeld(cs_wallet); // mapKeyMetadata\n-    bool fCompressed = CanSupportFeature(FEATURE_COMPRPUBKEY); // default to compressed public keys if we want 0.6.0 wallets\n \n     CKey secret;\n-    secret.MakeNewKey(fCompressed);\n-\n-    // Compressed public keys were introduced in version 0.6.0\n-    if (fCompressed)\n-        SetMinVersion(FEATURE_COMPRPUBKEY);\n-\n+    secret.MakeNewKey(true);\n+    \n     CPubKey pubkey = secret.GetPubKey();\n     assert(secret.VerifyPubKey(pubkey));\n \n@@ -107,7 +103,7 @@ bool CWallet::AddKeyPubKey(const CKey& secret, const CPubKey &pubkey)\n     if (!fFileBacked)\n         return true;\n     if (!IsCrypted()) {\n-        return CWalletDB(strWalletFile).WriteKey(pubkey,\n+        return walletDB->WriteKey(pubkey,\n                                                  secret.GetPrivKey(),\n                                                  mapKeyMetadata[pubkey.GetID()]);\n     }\n@@ -128,7 +124,7 @@ bool CWallet::AddCryptedKey(const CPubKey &vchPubKey,\n                                                         vchCryptedSecret,\n                                                         mapKeyMetadata[vchPubKey.GetID()]);\n         else\n-            return CWalletDB(strWalletFile).WriteCryptedKey(vchPubKey,\n+            return walletDB->WriteCryptedKey(vchPubKey,\n                                                             vchCryptedSecret,\n                                                             mapKeyMetadata[vchPubKey.GetID()]);\n     }\n@@ -156,7 +152,7 @@ bool CWallet::AddCScript(const CScript& redeemScript)\n         return false;\n     if (!fFileBacked)\n         return true;\n-    return CWalletDB(strWalletFile).WriteCScript(Hash160(redeemScript), redeemScript);\n+    return walletDB->WriteCScript(Hash160(redeemScript), redeemScript);\n }\n \n bool CWallet::LoadCScript(const CScript& redeemScript)\n@@ -183,7 +179,7 @@ bool CWallet::AddWatchOnly(const CScript &dest)\n     NotifyWatchonlyChanged(true);\n     if (!fFileBacked)\n         return true;\n-    return CWalletDB(strWalletFile).WriteWatchOnly(dest);\n+    return walletDB->WriteWatchOnly(dest);\n }\n \n bool CWallet::RemoveWatchOnly(const CScript &dest)\n@@ -194,7 +190,7 @@ bool CWallet::RemoveWatchOnly(const CScript &dest)\n     if (!HaveWatchOnly())\n         NotifyWatchonlyChanged(false);\n     if (fFileBacked)\n-        if (!CWalletDB(strWalletFile).EraseWatchOnly(dest))\n+        if (!walletDB->EraseWatchOnly(dest))\n             return false;\n \n     return true;\n@@ -260,7 +256,7 @@ bool CWallet::ChangeWalletPassphrase(const SecureString& strOldWalletPassphrase,\n                     return false;\n                 if (!crypter.Encrypt(vMasterKey, pMasterKey.second.vchCryptedKey))\n                     return false;\n-                CWalletDB(strWalletFile).WriteMasterKey(pMasterKey.first, pMasterKey.second);\n+                walletDB->WriteMasterKey(pMasterKey.first, pMasterKey.second);\n                 if (fWasLocked)\n                     Lock();\n                 return true;\n@@ -273,35 +269,12 @@ bool CWallet::ChangeWalletPassphrase(const SecureString& strOldWalletPassphrase,\n \n void CWallet::SetBestChain(const CBlockLocator& loc)\n {\n-    CWalletDB walletdb(strWalletFile);\n-    walletdb.WriteBestBlock(loc);\n+    walletDB->WriteBestBlock(loc);\n }\n \n-bool CWallet::SetMinVersion(enum WalletFeature nVersion, CWalletDB* pwalletdbIn, bool fExplicit)\n+bool CWallet::ReadBestBlock(CBlockLocator& locator)\n {\n-    LOCK(cs_wallet); // nWalletVersion\n-    if (nWalletVersion >= nVersion)\n-        return true;\n-\n-    // when doing an explicit upgrade, if we pass the max version permitted, upgrade all the way\n-    if (fExplicit && nVersion > nWalletMaxVersion)\n-            nVersion = FEATURE_LATEST;\n-\n-    nWalletVersion = nVersion;\n-\n-    if (nVersion > nWalletMaxVersion)\n-        nWalletMaxVersion = nVersion;\n-\n-    if (fFileBacked)\n-    {\n-        CWalletDB* pwalletdb = pwalletdbIn ? pwalletdbIn : new CWalletDB(strWalletFile);\n-        if (nWalletVersion > 40000)\n-            pwalletdb->WriteMinVersion(nWalletVersion);\n-        if (!pwalletdbIn)\n-            delete pwalletdb;\n-    }\n-\n-    return true;\n+    return walletDB->ReadBestBlock(locator);\n }\n \n bool CWallet::SetMaxVersion(int nVersion)\n@@ -478,9 +451,6 @@ bool CWallet::EncryptWallet(const SecureString& strWalletPassphrase)\n             assert(false);\n         }\n \n-        // Encryption was introduced in version 0.4.0\n-        SetMinVersion(FEATURE_WALLETCRYPT, pwalletdbEncryption, true);\n-\n         if (fFileBacked)\n         {\n             if (!pwalletdbEncryption->TxnCommit()) {\n@@ -500,7 +470,7 @@ bool CWallet::EncryptWallet(const SecureString& strWalletPassphrase)\n         Lock();\n         \n         // Rewrite wallet because we may use a append only backend\n-        CWalletDB(strWalletFile).Rewrite();\n+        walletDB->Rewrite();\n     }\n     NotifyStatusChanged(this);\n \n@@ -514,16 +484,15 @@ int64_t CWallet::IncOrderPosNext(CWalletDB *pwalletdb)\n     if (pwalletdb) {\n         pwalletdb->WriteOrderPosNext(nOrderPosNext);\n     } else {\n-        CWalletDB(strWalletFile).WriteOrderPosNext(nOrderPosNext);\n+        walletDB->WriteOrderPosNext(nOrderPosNext);\n     }\n     return nRet;\n }\n \n CWallet::TxItems CWallet::OrderedTxItems(std::list<CAccountingEntry>& acentries, std::string strAccount)\n {\n     AssertLockHeld(cs_wallet); // mapWallet\n-    CWalletDB walletdb(strWalletFile);\n-\n+    \n     // First: get all CWalletTx and CAccountingEntry into a sorted-by-order multimap.\n     TxItems txOrdered;\n \n@@ -535,7 +504,7 @@ CWallet::TxItems CWallet::OrderedTxItems(std::list<CAccountingEntry>& acentries,\n         txOrdered.insert(make_pair(wtx->nOrderPos, TxPair(wtx, (CAccountingEntry*)0)));\n     }\n     acentries.clear();\n-    walletdb.ListAccountCreditDebit(strAccount, acentries);\n+    ListAccountCreditDebit(strAccount, acentries);\n     BOOST_FOREACH(CAccountingEntry& entry, acentries)\n     {\n         txOrdered.insert(make_pair(entry.nOrderPos, TxPair((CWalletTx*)0, &entry)));\n@@ -651,7 +620,7 @@ bool CWallet::AddToWallet(const CWalletTx& wtxIn, bool fFromLoadWallet, CWalletD\n \n         // Write to disk\n         if (fInsertedNew || fUpdated)\n-            if (!wtx.WriteToDisk(pwalletdb))\n+            if (!WriteTxToDisk(wtx))\n                 return false;\n \n         // Break debit/credit balance caches:\n@@ -725,7 +694,7 @@ void CWallet::EraseFromWallet(const uint256 &hash)\n     {\n         LOCK(cs_wallet);\n         if (mapWallet.erase(hash))\n-            CWalletDB(strWalletFile).EraseTx(hash);\n+            walletDB->EraseTx(hash);\n     }\n     return;\n }\n@@ -786,7 +755,12 @@ bool CWallet::IsChange(const CTxOut& txout) const\n \n bool CWallet::Flush(bool shutdown)\n {\n-    return CWalletDB(strWalletFile).Flush(shutdown);\n+    return walletDB->Flush(shutdown);\n+}\n+\n+bool CWallet::WriteTxToDisk(const CWalletTx& wtx)\n+{\n+    return walletDB->WriteTx(wtx.GetHash(), wtx);\n }\n \n int64_t CWalletTx::GetTxTime() const\n@@ -924,7 +898,6 @@ void CWalletTx::GetAccountAmounts(const string& strAccount, CAmount& nReceived,\n     }\n }\n \n-\n bool CWalletTx::WriteToDisk(CWalletDB *pwalletdb)\n {\n     return pwalletdb->WriteTx(GetHash(), *this);\n@@ -1778,17 +1751,12 @@ bool CWallet::CommitTransaction(CWalletTx& wtxNew, CReserveKey& reservekey)\n         LOCK2(cs_main, cs_wallet);\n         LogPrintf(\"CommitTransaction:\\n%s\", wtxNew.ToString());\n         {\n-            // This is only to keep the database open to defeat the auto-flush for the\n-            // duration of this scope.  This is the only place where this optimization\n-            // maybe makes sense; please don't do it anywhere else.\n-            CWalletDB* pwalletdb = fFileBacked ? new CWalletDB(strWalletFile,\"r+\") : NULL;\n-\n             // Take key pair from key pool so it won't be used again\n             reservekey.KeepKey();\n \n             // Add tx to wallet, because if it has change it's also ours,\n             // otherwise just for transaction history.\n-            AddToWallet(wtxNew, false, pwalletdb);\n+            AddToWallet(wtxNew, false, walletDB);\n \n             // Notify that old coins are spent\n             set<CWalletTx*> setCoins;\n@@ -1798,9 +1766,6 @@ bool CWallet::CommitTransaction(CWalletTx& wtxNew, CReserveKey& reservekey)\n                 coin.BindWallet(this);\n                 NotifyTransactionChanged(this, coin.GetHash(), CT_UPDATED);\n             }\n-\n-            if (fFileBacked)\n-                delete pwalletdb;\n         }\n \n         // Track how many getdata requests our transaction gets\n@@ -1849,22 +1814,11 @@ DBErrors CWallet::LoadWallet(bool& fFirstRunRet)\n     if (!fFileBacked)\n         return DB_LOAD_OK;\n     fFirstRunRet = false;\n-    DBErrors nLoadWalletRet = CWalletDB(strWalletFile,\"cr+\").LoadWallet(this);\n-    if (nLoadWalletRet == DB_NEED_REWRITE)\n-    {\n-        // TODO\n-//        if (CDB::Rewrite(strWalletFile, \"\\x04pool\"))\n-//        {\n-//            LOCK(cs_wallet);\n-//            setKeyPool.clear();\n-//            // Note: can't top-up keypool here, because wallet is locked.\n-//            // User will be prompted to unlock wallet the next operation\n-//            // the requires a new key.\n-//        }\n-    }\n+    DBErrors nLoadWalletRet = walletDB->LoadWallet(this);\n \n     if (nLoadWalletRet != DB_LOAD_OK)\n         return nLoadWalletRet;\n+    \n     fFirstRunRet = !vchDefaultKey.IsValid();\n \n     uiInterface.LoadWallet(this);\n@@ -1873,28 +1827,12 @@ DBErrors CWallet::LoadWallet(bool& fFirstRunRet)\n }\n \n \n-DBErrors CWallet::ZapWalletTx(std::vector<CWalletTx>& vWtx)\n+bool CWallet::ZapWalletTx(std::vector<CWalletTx>& vWtx)\n {\n     if (!fFileBacked)\n-        return DB_LOAD_OK;\n-    DBErrors nZapWalletTxRet = CWalletDB(strWalletFile,\"cr+\").ZapWalletTx(this, vWtx);\n-    if (nZapWalletTxRet == DB_NEED_REWRITE)\n-    {\n-        // TODO\n-//        if (CDB::Rewrite(strWalletFile, \"\\x04pool\"))\n-//        {\n-//            LOCK(cs_wallet);\n-//            setKeyPool.clear();\n-//            // Note: can't top-up keypool here, because wallet is locked.\n-//            // User will be prompted to unlock wallet the next operation\n-//            // that requires a new key.\n-//        }\n-    }\n-\n-    if (nZapWalletTxRet != DB_LOAD_OK)\n-        return nZapWalletTxRet;\n-\n-    return DB_LOAD_OK;\n+        return true;\n+    \n+    return walletDB->ZapWalletTx(this, vWtx);\n }\n \n \n@@ -1913,9 +1851,9 @@ bool CWallet::SetAddressBook(const CTxDestination& address, const string& strNam\n                              strPurpose, (fUpdated ? CT_UPDATED : CT_NEW) );\n     if (!fFileBacked)\n         return false;\n-    if (!strPurpose.empty() && !CWalletDB(strWalletFile).WritePurpose(CBitcoinAddress(address).ToString(), strPurpose))\n+    if (!strPurpose.empty() && !walletDB->WritePurpose(CBitcoinAddress(address).ToString(), strPurpose))\n         return false;\n-    return CWalletDB(strWalletFile).WriteName(CBitcoinAddress(address).ToString(), strName);\n+    return walletDB->WriteName(CBitcoinAddress(address).ToString(), strName);\n }\n \n bool CWallet::DelAddressBook(const CTxDestination& address)\n@@ -1929,7 +1867,7 @@ bool CWallet::DelAddressBook(const CTxDestination& address)\n             std::string strAddress = CBitcoinAddress(address).ToString();\n             BOOST_FOREACH(const PAIRTYPE(string, string) &item, mapAddressBook[address].destdata)\n             {\n-                CWalletDB(strWalletFile).EraseDestData(strAddress, item.first);\n+                walletDB->EraseDestData(strAddress, item.first);\n             }\n         }\n         mapAddressBook.erase(address);\n@@ -1939,15 +1877,15 @@ bool CWallet::DelAddressBook(const CTxDestination& address)\n \n     if (!fFileBacked)\n         return false;\n-    CWalletDB(strWalletFile).ErasePurpose(CBitcoinAddress(address).ToString());\n-    return CWalletDB(strWalletFile).EraseName(CBitcoinAddress(address).ToString());\n+    walletDB->ErasePurpose(CBitcoinAddress(address).ToString());\n+    return walletDB->EraseName(CBitcoinAddress(address).ToString());\n }\n \n bool CWallet::SetDefaultKey(const CPubKey &vchPubKey)\n {\n     if (fFileBacked)\n     {\n-        if (!CWalletDB(strWalletFile).WriteDefaultKey(vchPubKey))\n+        if (!walletDB->WriteDefaultKey(vchPubKey))\n             return false;\n     }\n     vchDefaultKey = vchPubKey;\n@@ -1962,9 +1900,8 @@ bool CWallet::NewKeyPool()\n {\n     {\n         LOCK(cs_wallet);\n-        CWalletDB walletdb(strWalletFile);\n         BOOST_FOREACH(int64_t nIndex, setKeyPool)\n-            walletdb.ErasePool(nIndex);\n+            walletDB->ErasePool(nIndex);\n         setKeyPool.clear();\n \n         if (IsLocked())\n@@ -1974,7 +1911,7 @@ bool CWallet::NewKeyPool()\n         for (int i = 0; i < nKeys; i++)\n         {\n             int64_t nIndex = i+1;\n-            walletdb.WritePool(nIndex, CKeyPool(GenerateNewKey()));\n+            walletDB->WritePool(nIndex, CKeyPool(GenerateNewKey()));\n             setKeyPool.insert(nIndex);\n         }\n         LogPrintf(\"CWallet::NewKeyPool wrote %d new keys\\n\", nKeys);\n@@ -1990,8 +1927,6 @@ bool CWallet::TopUpKeyPool(unsigned int kpSize)\n         if (IsLocked())\n             return false;\n \n-        CWalletDB walletdb(strWalletFile);\n-\n         // Top up key pool\n         unsigned int nTargetSize;\n         if (kpSize > 0)\n@@ -2004,8 +1939,8 @@ bool CWallet::TopUpKeyPool(unsigned int kpSize)\n             int64_t nEnd = 1;\n             if (!setKeyPool.empty())\n                 nEnd = *(--setKeyPool.end()) + 1;\n-            if (!walletdb.WritePool(nEnd, CKeyPool(GenerateNewKey())))\n-                throw runtime_error(\"TopUpKeyPool(): writing generated key failed\");\n+            if (!walletDB->WritePool(nEnd, CKeyPool(GenerateNewKey())))\n+                throw runtime_error(\"TopUpKeyPool() : writing generated key failed\");\n             setKeyPool.insert(nEnd);\n             LogPrintf(\"keypool added key %d, size=%u\\n\", nEnd, setKeyPool.size());\n         }\n@@ -2027,12 +1962,10 @@ void CWallet::ReserveKeyFromKeyPool(int64_t& nIndex, CKeyPool& keypool)\n         if(setKeyPool.empty())\n             return;\n \n-        CWalletDB walletdb(strWalletFile);\n-\n         nIndex = *(setKeyPool.begin());\n         setKeyPool.erase(setKeyPool.begin());\n-        if (!walletdb.ReadPool(nIndex, keypool))\n-            throw runtime_error(\"ReserveKeyFromKeyPool(): read failed\");\n+        if (!walletDB->ReadPool(nIndex, keypool))\n+            throw runtime_error(\"ReserveKeyFromKeyPool() : read failed\");\n         if (!HaveKey(keypool.vchPubKey.GetID()))\n             throw runtime_error(\"ReserveKeyFromKeyPool(): unknown key in key pool\");\n         assert(keypool.vchPubKey.IsValid());\n@@ -2045,8 +1978,7 @@ void CWallet::KeepKey(int64_t nIndex)\n     // Remove from key pool\n     if (fFileBacked)\n     {\n-        CWalletDB walletdb(strWalletFile);\n-        walletdb.ErasePool(nIndex);\n+        walletDB->ErasePool(nIndex);\n     }\n     LogPrintf(\"keypool keep %d\\n\", nIndex);\n }\n@@ -2238,6 +2170,66 @@ set<CTxDestination> CWallet::GetAccountAddresses(string strAccount) const\n     return result;\n }\n \n+void CWallet::ListAccountCreditDebit(const string& strAccount, list<CAccountingEntry>& entries)\n+{\n+    walletDB->ListAccountCreditDebit(strAccount, entries);\n+}\n+\n+CAmount CWallet::GetAccountCreditDebit(const string& strAccount)\n+{\n+    list<CAccountingEntry> entries;\n+    ListAccountCreditDebit(strAccount, entries);\n+    \n+    CAmount nCreditDebit = 0;\n+    BOOST_FOREACH (const CAccountingEntry& entry, entries)\n+    nCreditDebit += entry.nCreditDebit;\n+    \n+    return nCreditDebit;\n+}\n+\n+bool CWallet::ReadAccount(const string& strAccount, CAccount& account)\n+{\n+    return walletDB->ReadAccount(strAccount, account);\n+}\n+\n+bool CWallet::WriteAccount(const string& strAccount, const CAccount& account)\n+{\n+    return walletDB->WriteAccount(strAccount, account);\n+}\n+\n+bool CWallet::MoveAccount(const string& strFrom, const string& strTo, CAmount nAmount, const string& strComment)\n+{\n+    if(!walletDB->TxnBegin())\n+        return false;\n+\n+    int64_t nNow = GetAdjustedTime();\n+    \n+    // Debit\n+    CAccountingEntry debit;\n+    debit.nOrderPos = IncOrderPosNext();\n+    debit.strAccount = strFrom;\n+    debit.nCreditDebit = -nAmount;\n+    debit.nTime = nNow;\n+    debit.strOtherAccount = strTo;\n+    debit.strComment = strComment;\n+    walletDB->WriteAccountingEntry(debit);\n+    \n+    // Credit\n+    CAccountingEntry credit;\n+    credit.nOrderPos = IncOrderPosNext();\n+    credit.strAccount = strTo;\n+    credit.nCreditDebit = nAmount;\n+    credit.nTime = nNow;\n+    credit.strOtherAccount = strFrom;\n+    credit.strComment = strComment;\n+    walletDB->WriteAccountingEntry(credit);\n+    \n+    if (!walletDB->TxnCommit())\n+        return false;\n+\n+    return true;\n+}\n+\n bool CReserveKey::GetReservedKey(CPubKey& pubkey)\n {\n     if (nIndex == -1)\n@@ -2275,14 +2267,12 @@ void CWallet::GetAllReserveKeys(set<CKeyID>& setAddress) const\n {\n     setAddress.clear();\n \n-    CWalletDB walletdb(strWalletFile);\n-\n     LOCK2(cs_main, cs_wallet);\n     BOOST_FOREACH(const int64_t& id, setKeyPool)\n     {\n         CKeyPool keypool;\n-        if (!walletdb.ReadPool(id, keypool))\n-            throw runtime_error(\"GetAllReserveKeyHashes(): read failed\");\n+        if (!walletDB->ReadPool(id, keypool))\n+            throw runtime_error(\"GetAllReserveKeyHashes() : read failed\");\n         assert(keypool.vchPubKey.IsValid());\n         CKeyID keyID = keypool.vchPubKey.GetID();\n         if (!HaveKey(keyID))\n@@ -2432,7 +2422,7 @@ bool CWallet::AddDestData(const CTxDestination &dest, const std::string &key, co\n     mapAddressBook[dest].destdata.insert(std::make_pair(key, value));\n     if (!fFileBacked)\n         return true;\n-    return CWalletDB(strWalletFile).WriteDestData(CBitcoinAddress(dest).ToString(), key, value);\n+    return walletDB->WriteDestData(CBitcoinAddress(dest).ToString(), key, value);\n }\n \n bool CWallet::EraseDestData(const CTxDestination &dest, const std::string &key)\n@@ -2441,7 +2431,7 @@ bool CWallet::EraseDestData(const CTxDestination &dest, const std::string &key)\n         return false;\n     if (!fFileBacked)\n         return true;\n-    return CWalletDB(strWalletFile).EraseDestData(CBitcoinAddress(dest).ToString(), key);\n+    return walletDB->EraseDestData(CBitcoinAddress(dest).ToString(), key);\n }\n \n bool CWallet::LoadDestData(const CTxDestination &dest, const std::string &key, const std::string &value)"
      },
      {
        "sha": "f13dd2b14c524464921c6e79443f685bc9ba1332",
        "filename": "src/wallet.h",
        "status": "modified",
        "additions": 36,
        "deletions": 12,
        "changes": 48,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c856ad7f470de14d9d390bbec70614d651578bf5/src/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c856ad7f470de14d9d390bbec70614d651578bf5/src/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.h?ref=c856ad7f470de14d9d390bbec70614d651578bf5",
        "patch": "@@ -57,12 +57,7 @@ class CWalletTx;\n /** (client) version numbers for particular wallet features */\n enum WalletFeature\n {\n-    FEATURE_BASE = 10500, // the earliest version new wallets supports (only useful for getinfo's clientversion output)\n-\n-    FEATURE_WALLETCRYPT = 40000, // wallet encryption\n-    FEATURE_COMPRPUBKEY = 60000, // compressed public keys\n-\n-    FEATURE_LATEST = 60000\n+    FEATURE_BASE = 10000, // the earliest version of logdb wallets\n };\n \n \n@@ -435,6 +430,9 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n private:\n     bool SelectCoins(const CAmount& nTargetValue, std::set<std::pair<const CWalletTx*,unsigned int> >& setCoinsRet, CAmount& nValueRet, const CCoinControl *coinControl = NULL) const;\n \n+    //! handle to the wallet backend\n+    CWalletDB *walletDB;\n+\n     CWalletDB *pwalletdbEncryption;\n \n     //! the current wallet version: clients below this version are not able to load the wallet\n@@ -488,13 +486,20 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n         SetNull();\n \n         strWalletFile = strWalletFileIn;\n+        \n+        //instantiate a wallet backend object and maps the stored values\n+        walletDB = new CWalletDB(strWalletFile);\n+        \n         fFileBacked = true;\n     }\n \n     ~CWallet()\n     {\n         delete pwalletdbEncryption;\n         pwalletdbEncryption = NULL;\n+        \n+        // make sure to discard the handle (it might close the db/file)\n+        delete walletDB;\n     }\n \n     void SetNull()\n@@ -633,7 +638,11 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n     std::map<CTxDestination, CAmount> GetAddressBalances();\n \n     std::set<CTxDestination> GetAccountAddresses(std::string strAccount) const;\n-\n+    void ListAccountCreditDebit(const std::string& strAccount, std::list<CAccountingEntry>& entries);\n+    CAmount GetAccountCreditDebit(const std::string& strAccount);\n+    bool ReadAccount(const std::string& strAccount, CAccount& account);\n+    bool WriteAccount(const std::string& strAccount, const CAccount& account);\n+    bool MoveAccount(const std::string& strFrom, const std::string& strTo, CAmount nAmount, const std::string& strComment);\n     isminetype IsMine(const CTxIn& txin) const;\n     CAmount GetDebit(const CTxIn& txin, const isminefilter& filter) const;\n     isminetype IsMine(const CTxOut& txout) const\n@@ -699,9 +708,10 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n         return nChange;\n     }\n     void SetBestChain(const CBlockLocator& loc);\n-\n+    bool ReadBestBlock(CBlockLocator& locator);\n+    \n     DBErrors LoadWallet(bool& fFirstRunRet);\n-    DBErrors ZapWalletTx(std::vector<CWalletTx>& vWtx);\n+    bool ZapWalletTx(std::vector<CWalletTx>& vWtx);\n \n     bool SetAddressBook(const CTxDestination& address, const std::string& strName, const std::string& purpose);\n \n@@ -727,9 +737,6 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n \n     bool SetDefaultKey(const CPubKey &vchPubKey);\n \n-    //! signify that a particular wallet feature is now used. this may change nWalletVersion and nWalletMaxVersion if those are lower\n-    bool SetMinVersion(enum WalletFeature, CWalletDB* pwalletdbIn = NULL, bool fExplicit = false);\n-\n     //! change which version we're allowed to upgrade to (note that this does not immediately imply upgrading to that format)\n     bool SetMaxVersion(int nVersion);\n \n@@ -742,6 +749,9 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n     //! Flush wallet\n     bool Flush(bool shutdown);\n     \n+    //! Write down a specific wallet transaction\n+    bool WriteTxToDisk(const CWalletTx& wtx);\n+    \n     /** \n      * Address book entry changed.\n      * @note called with lock cs_wallet held.\n@@ -1095,6 +1105,17 @@ class CWalletTx : public CMerkleTx\n \n     bool SetDefaultKey(const CPubKey &vchPubKey);\n \n+    void GetAmounts(std::list<COutputEntry>& listReceived,\n+                    std::list<COutputEntry>& listSent, CAmount& nFee, std::string& strSentAccount, const isminefilter& filter) const;\n+\n+    void GetAccountAmounts(const std::string& strAccount, CAmount& nReceived,\n+                           CAmount& nSent, CAmount& nFee, const isminefilter& filter) const;\n+    \n+    bool IsFromMe(const isminefilter& filter) const\n+    {\n+        return (GetDebit(filter) > 0);\n+    }\n+\n     //! signify that a particular wallet feature is now used. this may change nWalletVersion and nWalletMaxVersion if those are lower\n     bool SetMinVersion(enum WalletFeature, CWalletDB* pwalletdbIn = NULL, bool fExplicit = false);\n \n@@ -1103,6 +1124,9 @@ class CWalletTx : public CMerkleTx\n \n     //! get the current wallet format (the oldest client version guaranteed to understand this wallet)\n     int GetVersion() { LOCK(cs_wallet); return nWalletVersion; }\n+        \n+    int64_t GetTxTime() const;\n+    int GetRequestCount() const;\n \n     //! Get wallet transactions that conflict with given transaction (spend same outputs)\n     std::set<uint256> GetConflicts(const uint256& txid) const;"
      },
      {
        "sha": "73da35e0d55b34df89860aec2bfe399972ffefb1",
        "filename": "src/walletdb.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 242,
        "changes": 259,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c856ad7f470de14d9d390bbec70614d651578bf5/src/walletdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c856ad7f470de14d9d390bbec70614d651578bf5/src/walletdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/walletdb.cpp?ref=c856ad7f470de14d9d390bbec70614d651578bf5",
        "patch": "@@ -28,46 +28,38 @@ static uint64_t nAccountingEntryNumber = 0;\n \n bool CWalletDB::WriteName(const string& strAddress, const string& strName)\n {\n-    nWalletDBUpdated++;\n     return Write(make_pair(string(\"name\"), strAddress), strName);\n }\n \n bool CWalletDB::EraseName(const string& strAddress)\n {\n     // This should only be used for sending addresses, never for receiving addresses,\n     // receiving addresses must always have an address book entry if they're not change return.\n-    nWalletDBUpdated++;\n     return Erase(make_pair(string(\"name\"), strAddress));\n }\n \n bool CWalletDB::WritePurpose(const string& strAddress, const string& strPurpose)\n {\n-    nWalletDBUpdated++;\n     return Write(make_pair(string(\"purpose\"), strAddress), strPurpose);\n }\n \n bool CWalletDB::ErasePurpose(const string& strPurpose)\n {\n-    nWalletDBUpdated++;\n     return Erase(make_pair(string(\"purpose\"), strPurpose));\n }\n \n bool CWalletDB::WriteTx(uint256 hash, const CWalletTx& wtx)\n {\n-    nWalletDBUpdated++;\n     return Write(std::make_pair(std::string(\"tx\"), hash), wtx);\n }\n \n bool CWalletDB::EraseTx(uint256 hash)\n {\n-    nWalletDBUpdated++;\n     return Erase(std::make_pair(std::string(\"tx\"), hash));\n }\n \n bool CWalletDB::WriteKey(const CPubKey& vchPubKey, const CPrivKey& vchPrivKey, const CKeyMetadata& keyMeta)\n {\n-    nWalletDBUpdated++;\n-\n     if (!Write(std::make_pair(std::string(\"keymeta\"), vchPubKey),\n                keyMeta, false))\n         return false;\n@@ -86,7 +78,6 @@ bool CWalletDB::WriteCryptedKey(const CPubKey& vchPubKey,\n                                 const CKeyMetadata &keyMeta)\n {\n     const bool fEraseUnencryptedKey = true;\n-    nWalletDBUpdated++;\n \n     if (!Write(std::make_pair(std::string(\"keymeta\"), vchPubKey),\n             keyMeta))\n@@ -104,31 +95,26 @@ bool CWalletDB::WriteCryptedKey(const CPubKey& vchPubKey,\n \n bool CWalletDB::WriteMasterKey(unsigned int nID, const CMasterKey& kMasterKey)\n {\n-    nWalletDBUpdated++;\n     return Write(std::make_pair(std::string(\"mkey\"), nID), kMasterKey, true);\n }\n \n bool CWalletDB::WriteCScript(const uint160& hash, const CScript& redeemScript)\n {\n-    nWalletDBUpdated++;\n     return Write(std::make_pair(std::string(\"cscript\"), hash), redeemScript, false);\n }\n \n bool CWalletDB::WriteWatchOnly(const CScript &dest)\n {\n-    nWalletDBUpdated++;\n     return Write(std::make_pair(std::string(\"watchs\"), dest), '1');\n }\n \n bool CWalletDB::EraseWatchOnly(const CScript &dest)\n {\n-    nWalletDBUpdated++;\n     return Erase(std::make_pair(std::string(\"watchs\"), dest));\n }\n \n bool CWalletDB::WriteBestBlock(const CBlockLocator& locator)\n {\n-    nWalletDBUpdated++;\n     return Write(std::string(\"bestblock\"), locator);\n }\n \n@@ -139,13 +125,11 @@ bool CWalletDB::ReadBestBlock(CBlockLocator& locator)\n \n bool CWalletDB::WriteOrderPosNext(int64_t nOrderPosNext)\n {\n-    nWalletDBUpdated++;\n     return Write(std::string(\"orderposnext\"), nOrderPosNext);\n }\n \n bool CWalletDB::WriteDefaultKey(const CPubKey& vchPubKey)\n {\n-    nWalletDBUpdated++;\n     return Write(std::string(\"defaultkey\"), vchPubKey);\n }\n \n@@ -156,13 +140,11 @@ bool CWalletDB::ReadPool(int64_t nPool, CKeyPool& keypool)\n \n bool CWalletDB::WritePool(int64_t nPool, const CKeyPool& keypool)\n {\n-    nWalletDBUpdated++;\n     return Write(std::make_pair(std::string(\"pool\"), nPool), keypool);\n }\n \n bool CWalletDB::ErasePool(int64_t nPool)\n {\n-    nWalletDBUpdated++;\n     return Erase(std::make_pair(std::string(\"pool\"), nPool));\n }\n \n@@ -192,61 +174,31 @@ bool CWalletDB::WriteAccountingEntry(const CAccountingEntry& acentry)\n     return WriteAccountingEntry(++nAccountingEntryNumber, acentry);\n }\n \n-CAmount CWalletDB::GetAccountCreditDebit(const string& strAccount)\n-{\n-    list<CAccountingEntry> entries;\n-    ListAccountCreditDebit(strAccount, entries);\n-\n-    CAmount nCreditDebit = 0;\n-    BOOST_FOREACH (const CAccountingEntry& entry, entries)\n-        nCreditDebit += entry.nCreditDebit;\n-\n-    return nCreditDebit;\n-}\n-\n void CWalletDB::ListAccountCreditDebit(const string& strAccount, list<CAccountingEntry>& entries)\n {\n-    /*\n     bool fAllAccounts = (strAccount == \"*\");\n \n-    Dbc* pcursor = GetCursor();\n-    if (!pcursor)\n-        throw runtime_error(\"CWalletDB::ListAccountCreditDebit(): cannot create DB cursor\");\n-    unsigned int fFlags = DB_SET_RANGE;\n-    while (true)\n+    for (CWalletDB::const_iterator it = begin(); it != end(); it++)\n     {\n         // Read next record\n-        CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n-        if (fFlags == DB_SET_RANGE)\n-            ssKey << std::make_pair(std::string(\"acentry\"), std::make_pair((fAllAccounts ? string(\"\") : strAccount), uint64_t(0)));\n-        CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n-        int ret = ReadAtCursor(pcursor, ssKey, ssValue, fFlags);\n-        fFlags = DB_NEXT;\n-        if (ret == DB_NOTFOUND)\n-            break;\n-        else if (ret != 0)\n-        {\n-            pcursor->close();\n-            throw runtime_error(\"CWalletDB::ListAccountCreditDebit(): error scanning DB\");\n-        }\n+        CDataStream ssKey((*it).first, SER_DISK, CLIENT_VERSION);\n+        CDataStream ssValue((*it).second, SER_DISK, CLIENT_VERSION);\n \n         // Unserialize\n         string strType;\n         ssKey >> strType;\n         if (strType != \"acentry\")\n-            break;\n+            continue;\n+        \n         CAccountingEntry acentry;\n         ssKey >> acentry.strAccount;\n         if (!fAllAccounts && acentry.strAccount != strAccount)\n-            break;\n+            continue;\n \n         ssValue >> acentry;\n         ssKey >> acentry.nEntryNo;\n         entries.push_back(acentry);\n     }\n-\n-    pcursor->close();\n-     */\n }\n \n DBErrors CWalletDB::ReorderTransactions(CWallet* pwallet)\n@@ -606,6 +558,9 @@ static bool IsKeyType(string strType)\n \n DBErrors CWalletDB::LoadWallet(CWallet* pwallet)\n {\n+    if(!Load())\n+        return DB_CORRUPT;\n+    \n     pwallet->vchDefaultKey = CPubKey();\n     CWalletScanState wss;\n     bool fNoncriticalErrors = false;\n@@ -735,21 +690,21 @@ DBErrors CWalletDB::FindWalletTx(CWallet* pwallet, vector<uint256>& vTxHash, vec\n     return result;\n }\n \n-DBErrors CWalletDB::ZapWalletTx(CWallet* pwallet, vector<CWalletTx>& vWtx)\n+bool CWalletDB::ZapWalletTx(CWallet* pwallet, vector<CWalletTx>& vWtx)\n {\n     // build list of wallet TXs\n     vector<uint256> vTxHash;\n     DBErrors err = FindWalletTx(pwallet, vTxHash, vWtx);\n     if (err != DB_LOAD_OK)\n-        return err;\n+        return false;\n \n     // erase each wallet TX\n     BOOST_FOREACH (uint256& hash, vTxHash) {\n         if (!EraseTx(hash))\n-            return DB_CORRUPT;\n+            return false;\n     }\n \n-    return DB_LOAD_OK;\n+    return true;\n }\n \n DBErrors CWalletDB::Rewrite()\n@@ -761,68 +716,6 @@ DBErrors CWalletDB::Rewrite()\n     return DB_LOAD_OK;\n }\n \n-void ThreadFlushWalletDB(const string& strFile)\n-{\n-//    // Make this thread recognisable as the wallet flushing thread\n-//    RenameThread(\"bitcoin-wallet\");\n-//\n-//    static bool fOneThread;\n-//    if (fOneThread)\n-//        return;\n-//    fOneThread = true;\n-//    if (!GetBoolArg(\"-flushwallet\", true))\n-//        return;\n-//\n-//    unsigned int nLastSeen = nWalletDBUpdated;\n-//    unsigned int nLastFlushed = nWalletDBUpdated;\n-//    int64_t nLastWalletUpdate = GetTime();\n-//    while (true)\n-//    {\n-//        MilliSleep(500);\n-//\n-//        if (nLastSeen != nWalletDBUpdated)\n-//        {\n-//            nLastSeen = nWalletDBUpdated;\n-//            nLastWalletUpdate = GetTime();\n-//        }\n-//\n-//        if (nLastFlushed != nWalletDBUpdated && GetTime() - nLastWalletUpdate >= 2)\n-//        {\n-//            TRY_LOCK(bitdb.cs_db,lockDb);\n-//            if (lockDb)\n-//            {\n-//                // Don't do this if any databases are in use\n-//                int nRefCount = 0;\n-//                map<string, int>::iterator mi = bitdb.mapFileUseCount.begin();\n-//                while (mi != bitdb.mapFileUseCount.end())\n-//                {\n-//                    nRefCount += (*mi).second;\n-//                    mi++;\n-//                }\n-//\n-//                if (nRefCount == 0)\n-//                {\n-//                    boost::this_thread::interruption_point();\n-//                    map<string, int>::iterator mi = bitdb.mapFileUseCount.find(strFile);\n-//                    if (mi != bitdb.mapFileUseCount.end())\n-//                    {\n-//                        LogPrint(\"db\", \"Flushing wallet.dat\\n\");\n-//                        nLastFlushed = nWalletDBUpdated;\n-//                        int64_t nStart = GetTimeMillis();\n-//\n-//                        // Flush wallet.dat so it's self contained\n-//                        bitdb.CloseDb(strFile);\n-//                        bitdb.CheckpointLSN(strFile);\n-//\n-//                        bitdb.mapFileUseCount.erase(mi++);\n-//                        LogPrint(\"db\", \"Flushed wallet.dat %dms\\n\", GetTimeMillis() - nStart);\n-//                    }\n-//                }\n-//            }\n-//        }\n-//    }\n-}\n-\n bool BackupWallet(const CWallet& wallet, const string& strDest)\n {\n     /*\n@@ -870,146 +763,28 @@ bool BackupWallet(const CWallet& wallet, const string& strDest)\n //\n bool CWalletDB::Recover(std::string filename, bool fOnlyKeys)\n {\n-    /*\n-    // Recovery procedure:\n-    // move wallet.dat to wallet.timestamp.bak\n-    // Call Salvage with fAggressive=true to\n-    // get as much data as possible.\n-    // Rewrite salvaged data to wallet.dat\n-    // Set -rescan so any missing transactions will be\n-    // found.\n-    int64_t now = GetTime();\n-    std::string newFilename = strprintf(\"wallet.%d.bak\", now);\n-\n-    int result = dbenv.dbenv.dbrename(NULL, filename.c_str(), NULL,\n-                                      newFilename.c_str(), DB_AUTO_COMMIT);\n-    if (result == 0)\n-        LogPrintf(\"Renamed %s to %s\\n\", filename, newFilename);\n-    else\n-    {\n-        LogPrintf(\"Failed to rename %s to %s\\n\", filename, newFilename);\n-        return false;\n-    }\n-\n-    std::vector<CDBEnv::KeyValPair> salvagedData;\n-    bool allOK = dbenv.Salvage(newFilename, true, salvagedData);\n-    if (salvagedData.empty())\n-    {\n-        LogPrintf(\"Salvage(aggressive) found no records in %s.\\n\", newFilename);\n-        return false;\n-    }\n-    LogPrintf(\"Salvage(aggressive) found %u records\\n\", salvagedData.size());\n-\n-    bool fSuccess = allOK;\n-    boost::scoped_ptr<Db> pdbCopy(new Db(&dbenv.dbenv, 0));\n-    int ret = pdbCopy->open(NULL,               // Txn pointer\n-                            filename.c_str(),   // Filename\n-                            \"main\",             // Logical db name\n-                            DB_BTREE,           // Database type\n-                            DB_CREATE,          // Flags\n-                            0);\n-    if (ret > 0)\n-    {\n-        LogPrintf(\"Cannot create database file %s\\n\", filename);\n-        return false;\n-    }\n-    CWallet dummyWallet;\n-    CWalletScanState wss;\n-\n-    DbTxn* ptxn = dbenv.TxnBegin();\n-    BOOST_FOREACH(CDBEnv::KeyValPair& row, salvagedData)\n-    {\n-        if (fOnlyKeys)\n-        {\n-            CDataStream ssKey(row.first, SER_DISK, CLIENT_VERSION);\n-            CDataStream ssValue(row.second, SER_DISK, CLIENT_VERSION);\n-            string strType, strErr;\n-            bool fReadOK = ReadKeyValue(&dummyWallet, ssKey, ssValue,\n-                                        wss, strType, strErr);\n-            if (!IsKeyType(strType))\n-                continue;\n-            if (!fReadOK)\n-            {\n-                LogPrintf(\"WARNING: CWalletDB::Recover skipping %s: %s\\n\", strType, strErr);\n-                continue;\n-            }\n-        }\n-        Dbt datKey(&row.first[0], row.first.size());\n-        Dbt datValue(&row.second[0], row.second.size());\n-        int ret2 = pdbCopy->put(ptxn, &datKey, &datValue, DB_NOOVERWRITE);\n-        if (ret2 > 0)\n-            fSuccess = false;\n-    }\n-    ptxn->commit(0);\n-    pdbCopy->close(0);\n-\n-    return fSuccess;\n-     */\n+    //TODO\n     return false;\n }\n \n bool CWalletDB::Recover(std::string filename)\n {\n+    //TODO\n     return CWalletDB::Recover(filename, false);\n }\n \n bool CWalletDB::Verify(std::string filename, bool salvage)\n {\n-    //TODO: implement\n-    \n-    //        if (!bitdb.Open(GetDataDir()))\n-    //        {\n-    //            // try moving the database env out of the way\n-    //            boost::filesystem::path pathDatabase = GetDataDir() / \"database\";\n-    //            boost::filesystem::path pathDatabaseBak = GetDataDir() / strprintf(\"database.%d.bak\", GetTime());\n-    //            try {\n-    //                boost::filesystem::rename(pathDatabase, pathDatabaseBak);\n-    //                LogPrintf(\"Moved old %s to %s. Retrying.\\n\", pathDatabase.string(), pathDatabaseBak.string());\n-    //            } catch (const boost::filesystem::filesystem_error&) {\n-    //                 // failure is ok (well, not really, but it's not worse than what we started with)\n-    //            }\n-    //\n-    //            // try again\n-    //            if (!bitdb.Open(GetDataDir())) {\n-    //                // if it still fails, it probably means we can't even create the database env\n-    //                string msg = strprintf(_(\"Error initializing wallet database environment %s!\"), strDataDir);\n-    //                return InitError(msg);\n-    //            }\n-    //        }\n-    //\n-    //        if (GetBoolArg(\"-salvagewallet\", false))\n-    //        {\n-    //            // Recover readable keypairs:\n-    //            if (!CWalletDB::Recover(strWalletFile, true))\n-    //                return false;\n-    //        }\n-    //\n-    //        if (filesystem::exists(GetDataDir() / strWalletFile))\n-    //        {\n-    //            CDBEnv::VerifyResult r = bitdb.Verify(strWalletFile, CWalletDB::Recover);\n-    //            if (r == CDBEnv::RECOVER_OK)\n-    //            {\n-    //                string msg = strprintf(_(\"Warning: wallet.dat corrupt, data salvaged!\"\n-    //                                         \" Original wallet.dat saved as wallet.{timestamp}.bak in %s; if\"\n-    //                                         \" your balance or transactions are incorrect you should\"\n-    //                                         \" restore from a backup.\"), strDataDir);\n-    //                InitWarning(msg);\n-    //            }\n-    //            if (r == CDBEnv::RECOVER_FAIL)\n-    //                return InitError(_(\"wallet.dat corrupt, salvage failed\"));\n-    //        }\n-    \n-    return true;\n+    //TODO\n+    return false;\n }\n \n bool CWalletDB::WriteDestData(const std::string &address, const std::string &key, const std::string &value)\n {\n-    nWalletDBUpdated++;\n     return Write(std::make_pair(std::string(\"destdata\"), std::make_pair(address, key)), value);\n }\n \n bool CWalletDB::EraseDestData(const std::string &address, const std::string &key)\n {\n-    nWalletDBUpdated++;\n     return Erase(std::make_pair(std::string(\"destdata\"), std::make_pair(address, key)));\n }"
      },
      {
        "sha": "081e8d2596113f698ba99f1110b1f47d4dce42ed",
        "filename": "src/walletdb.h",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c856ad7f470de14d9d390bbec70614d651578bf5/src/walletdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c856ad7f470de14d9d390bbec70614d651578bf5/src/walletdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/walletdb.h?ref=c856ad7f470de14d9d390bbec70614d651578bf5",
        "patch": "@@ -121,13 +121,12 @@ class CWalletDB : public CLogDB\n     bool EraseDestData(const std::string &address, const std::string &key);\n \n     bool WriteAccountingEntry(const CAccountingEntry& acentry);\n-    CAmount GetAccountCreditDebit(const std::string& strAccount);\n     void ListAccountCreditDebit(const std::string& strAccount, std::list<CAccountingEntry>& acentries);\n \n     DBErrors ReorderTransactions(CWallet* pwallet);\n     DBErrors LoadWallet(CWallet* pwallet);\n     DBErrors FindWalletTx(CWallet* pwallet, std::vector<uint256>& vTxHash, std::vector<CWalletTx>& vWtx);\n-    DBErrors ZapWalletTx(CWallet* pwallet, std::vector<CWalletTx>& vWtx);\n+    bool ZapWalletTx(CWallet* pwallet, std::vector<CWalletTx>& vWtx);\n     \n     DBErrors Rewrite();\n     \n@@ -144,6 +143,5 @@ class CWalletDB : public CLogDB\n };\n \n bool BackupWallet(const CWallet& wallet, const std::string& strDest);\n-void ThreadFlushWalletDB(const std::string& strWalletFile);\n \n #endif // BITCOIN_WALLETDB_H"
      }
    ]
  },
  {
    "sha": "75851f3bdf20b68e8894878c0f04703318ad2acb",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3NTg1MWYzYmRmMjBiNjhlODg5NDg3OGMwZjA0NzAzMzE4YWQyYWNi",
    "commit": {
      "author": {
        "name": "Jonas Schnelli",
        "email": "jonas.schnelli@include7.ch",
        "date": "2015-01-21T14:56:36Z"
      },
      "committer": {
        "name": "Jonas Schnelli",
        "email": "jonas.schnelli@include7.ch",
        "date": "2015-02-05T08:50:21Z"
      },
      "message": "[Wallet] support for db rewriting\n\n- adds encryption and compact write for logdb wallets",
      "tree": {
        "sha": "23e095624ab395c0f51ce4c55ca91f86a77d5b6a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/23e095624ab395c0f51ce4c55ca91f86a77d5b6a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/75851f3bdf20b68e8894878c0f04703318ad2acb",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/75851f3bdf20b68e8894878c0f04703318ad2acb",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/75851f3bdf20b68e8894878c0f04703318ad2acb",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/75851f3bdf20b68e8894878c0f04703318ad2acb/comments",
    "author": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c856ad7f470de14d9d390bbec70614d651578bf5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c856ad7f470de14d9d390bbec70614d651578bf5",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c856ad7f470de14d9d390bbec70614d651578bf5"
      }
    ],
    "stats": {
      "total": 240,
      "additions": 206,
      "deletions": 34
    },
    "files": [
      {
        "sha": "6d4ef9aa78905a118d27de0a5441bc051fa5ce88",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 1,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/75851f3bdf20b68e8894878c0f04703318ad2acb/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/75851f3bdf20b68e8894878c0f04703318ad2acb/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=75851f3bdf20b68e8894878c0f04703318ad2acb",
        "patch": "@@ -834,7 +834,11 @@ bool AppInit2(boost::thread_group& threadGroup)\n         LogPrintf(\"Using wallet %s\\n\", strWalletFile);\n         uiInterface.InitMessage(_(\"Verifying wallet...\"));\n \n-        CWalletDB::Verify(strWalletFile, GetBoolArg(\"-salvagewallet\", false));\n+        if (!CWalletDB::Verify(strWalletFile, GetBoolArg(\"-salvagewallet\", false)))\n+        {\n+            string msg = strprintf(_(\"Corrupt wallet detected (filename: %s)!\"), strWalletFile);\n+            return InitError(msg);\n+        }\n     } // (!fDisableWallet)\n #endif // ENABLE_WALLET\n     // ********************************************************* Step 6: network initialization"
      },
      {
        "sha": "9c54dc344360840dbfd3336d449ea01e6c0c7b33",
        "filename": "src/logdb.cpp",
        "status": "modified",
        "additions": 87,
        "deletions": 8,
        "changes": 95,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/75851f3bdf20b68e8894878c0f04703318ad2acb/src/logdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/75851f3bdf20b68e8894878c0f04703318ad2acb/src/logdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/logdb.cpp?ref=75851f3bdf20b68e8894878c0f04703318ad2acb",
        "patch": "@@ -4,6 +4,7 @@\n \n #include <stdio.h>\n #include <unistd.h>\n+#include <sys/stat.h>\n \n #include \"logdb.h\"\n \n@@ -81,7 +82,19 @@ void CLogDBFile::Init_()\n \n bool CLogDBFile::Open_(const char *pszFile, bool fCreate)\n {\n-    file = fopen(pszFile, fCreate ? \"a+b\" : \"r+b\");\n+    fileName = string(pszFile);\n+    \n+    size_t size;\n+    struct stat sbuf;\n+    if (stat(pszFile, &sbuf) != 0) {\n+        size = 0;\n+    } else {\n+        size = sbuf.st_size;\n+    }\n+    \n+    LogPrintf(\"CLogDB::Open Filesize %ld\\n\", size);\n+    \n+    file = fopen(pszFile, \"a+b\");\n     \n     if (file == NULL) {\n         LogPrintf(\"CLogDB::Open Error opening %s: %s\\n\", pszFile, strerror(errno));\n@@ -99,16 +112,17 @@ bool CLogDBFile::Open_(const char *pszFile, bool fCreate)\n         {\n             if (fwrite(logdb_header_magic, 4, 1, file) != 1)\n             {\n-                LogPrintf(\"CLogDBFile::Flush_(): error writing magic: %s\\n\", strerror(errno));\n+                LogPrintf(\"CLogDBFile::Open_(): error writing magic: %s\\n\", strerror(errno));\n             }\n             WriteInt(file, version);\n             fflush(file);\n             FileCommit(file);\n-            fclose(file);\n-            file = fopen(pszFile, \"r+b\");\n+            \n+            LogPrintf(\"CLogDBFile::Open_(): pos1: %ld\\n\", ftell(file));\n         }\n     }\n-    \n+\n+    LogPrintf(\"CLogDBFile::Open_(): pos3: %ld\\n\", ftell(file));\n     return true;\n }\n \n@@ -181,23 +195,41 @@ bool CLogDBFile::Close_()\n \n bool CLogDBFile::Load_()\n {\n+    LogPrintf(\"CLogDB::Load(): start loading\\n\");\n     if (feof(file))\n+    {\n+        LogPrintf(\"CLogDB::Load(): eof, return\\n\");\n         return true;\n+    }\n     \n     //logdb header\n     if (getc(file) != logdb_header_magic[0]) return feof(file);\n     if (getc(file) != logdb_header_magic[1]) return false;\n     if (getc(file) != logdb_header_magic[2]) return false;\n     if (getc(file) != logdb_header_magic[3]) return false;\n     \n+    LogPrintf(\"CLogDB::Load(): header okay %ld\\n\", ftell(file));\n+    \n     version = ReadInt(file);\n     if (version == 0) return false;\n     \n+    LogPrintf(\"CLogDB::Load(): version okay %d, %ld\\n\", version, ftell(file));\n+    \n     do\n     {\n+        LogPrintf(\"CLogDB::Load(): check for frame\\n\");\n         if (feof(file))\n+        {\n+            LogPrintf(\"CLogDB::Load(): end of file, returning\\n\");\n             return true;\n-        if (getc(file) != logdb_frameheader_magic[0]) return feof(file);\n+        }\n+        int aChar = getc(file);\n+        if (aChar != logdb_frameheader_magic[0])\n+        {\n+            LogPrintf(\"CLogDB::Load(): first frame headerbyte is wront found %2x pos: %ld\\n\", aChar, ftell(file));\n+            return feof(file);\n+        }\n+        LogPrintf(\"CLogDB::Load(): first frame headerbyte is okay (%2x) pos: %ld\\n\", aChar, ftell(file));\n         if (getc(file) != logdb_frameheader_magic[1]) return false;\n         if (getc(file) != logdb_frameheader_magic[2]) return false;\n         if (getc(file) != logdb_frameheader_magic[3]) return false;\n@@ -317,6 +349,17 @@ bool CLogDBFile::Load_()\n     LogPrintf(\"CLogDBFile::Load(): done\\n\");\n }\n \n+bool CLogDBFile::Reopen_(bool readOnly)\n+{\n+    fclose(file);\n+    file = fopen(fileName.c_str(), (readOnly) ? \"rb+\" : \"ab+\");\n+    \n+    if(file)\n+        return true;\n+    else\n+        return false;\n+}\n+\n bool CLogDBFile::Flush_()\n {\n     LogPrintf(\"CLogDBFile::Flush_()\\n\");\n@@ -326,11 +369,15 @@ bool CLogDBFile::Flush_()\n \n     LogPrintf(\"CLogDBFile::Flush_(): dirty entries found\\n\");\n \n+    LogPrintf(\"CLogDBFile::Flush(): current fpos: %ld\\n\", ftell(file));\n+    \n     if (fwrite(logdb_frameheader_magic, 4, 1, file) != 1)\n     {\n         LogPrintf(\"CLogDBFile::Flush_(): error writing magic: %s\\n\", strerror(errno));\n     }\n \n+    LogPrintf(\"CLogDBFile::Flush(): current fpos (afther header): %ld\\n\", ftell(file));\n+    \n     CSHA256 ctx = ctxState;\n \n     for (set<data_t>::iterator it = setDirty.begin(); it != setDirty.end(); it++)\n@@ -390,7 +437,7 @@ bool CLogDBFile::Flush_()\n     FileCommit(file);\n     ctxState = ctx;\n \n-    LogPrintf(\"CLogDBFile::Flush(): wrote frame\\n\");\n+    LogPrintf(\"CLogDBFile::Flush(): wrote frame pos: %ld\\n\", ftell(file));\n \n     setDirty.clear();\n \n@@ -459,8 +506,23 @@ bool CLogDB::TxnCommit() {\n     return true;\n }\n \n+bool CLogDB::ReloadDB(const string& walletFile)\n+{\n+    delete db;\n+    db = new CLogDBFile();\n+    db->Open(walletFile.c_str(), false);\n+    if(!Load())\n+        return false;\n+\n+    return true;\n+}\n+\n bool CLogDB::Load() {\n-    return db->Load_();\n+    db->Reopen_(true);\n+    bool loadRet = db->Load_();\n+    db->Reopen_(false);\n+    \n+    return loadRet;\n }\n \n bool CLogDB::Write_(const data_t &key, const data_t &value, bool fOverwrite) {\n@@ -559,3 +621,20 @@ bool CLogDB::Flush(bool shutdown)\n     \n     return state;\n }\n+\n+bool CLogDB::Rewrite(const string &file)\n+{\n+    Flush();\n+\n+    CLogDBFile *newDB = new CLogDBFile();\n+    newDB->Open(file.c_str(), true); // create new file\n+    \n+    for (std::map<data_t, data_t>::iterator it = db->mapData.begin(); it != db->mapData.end(); it++)\n+    {\n+        newDB->Write_((*it).first, (*it).second);\n+    }\n+    \n+    newDB->Flush_();\n+    \n+    return true;\n+}"
      },
      {
        "sha": "719165d7b75586e6a038623f50d7ae0344c34bc3",
        "filename": "src/logdb.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/75851f3bdf20b68e8894878c0f04703318ad2acb/src/logdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/75851f3bdf20b68e8894878c0f04703318ad2acb/src/logdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/logdb.h?ref=75851f3bdf20b68e8894878c0f04703318ad2acb",
        "patch": "@@ -34,6 +34,8 @@ class CLogDBFile\n     mutable boost::shared_mutex mutex;\n \n     FILE *file;\n+    std::string fileName;\n+    \n     CSHA256 ctxState;\n     uint64_t version;\n     \n@@ -57,6 +59,7 @@ class CLogDBFile\n     bool Flush_();\n     bool Open_(const char *pszFile, bool fCreate = true);\n     bool Close_();\n+    bool Reopen_(bool readOnly);\n     \n public:\n     CLogDBFile()\n@@ -129,6 +132,8 @@ class CLogDB\n     bool Read(const data_t &key, data_t &value);\n     bool Exists(const data_t &key);\n     bool Load();\n+    bool Rewrite(const std::string &file); //rewrite and compact to a new file\n+    bool ReloadDB(const std::string& walletFile); //!reload the db file\n     \n     bool Close() {\n         boost::lock_guard<boost::shared_mutex> lock(db->mutex);"
      },
      {
        "sha": "aca4527735e88e5cff541645321c2b9ff0a0458a",
        "filename": "src/test/logdb_tests.cpp",
        "status": "modified",
        "additions": 64,
        "deletions": 1,
        "changes": 65,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/75851f3bdf20b68e8894878c0f04703318ad2acb/src/test/logdb_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/75851f3bdf20b68e8894878c0f04703318ad2acb/src/test/logdb_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/logdb_tests.cpp?ref=75851f3bdf20b68e8894878c0f04703318ad2acb",
        "patch": "@@ -18,9 +18,14 @@ BOOST_AUTO_TEST_SUITE(logdb_tests)\n \n BOOST_AUTO_TEST_CASE(logdb_test_1)\n {\n+    fPrintToConsole = true;\n+    \n     boost::filesystem::path tmpPath = GetTempPath() / strprintf(\"test_bitcoin_logdb_%lu_%i.logdb\", (unsigned long)GetTime(), (int)(GetRand(100000)));    \n     std::string dbFile = tmpPath.string();\n     \n+    \n+    LogPrintf(\"%s\", dbFile);\n+    \n     int max_loops = 1;\n     \n     for(int i = 0;i<max_loops;i++)\n@@ -30,13 +35,17 @@ BOOST_AUTO_TEST_CASE(logdb_test_1)\n         CLogDB *aDB = new CLogDB(dbFile, false);\n         aDB->Load();\n         aDB->Write(std::string(\"testvalue\"), std::string(\"aValue\"));\n+\n+        std::string returnString;\n+        aDB->Read(std::string(\"testvalue\"), returnString);\n+        BOOST_CHECK_EQUAL(returnString, std::string(\"aValue\"));\n+        \n         aDB->Flush(true); //shutdown, close the file\n         aDB->Close();\n         delete aDB;\n         \n         aDB = new CLogDB(dbFile, false);\n         aDB->Load();\n-        std::string returnString;\n         aDB->Read(std::string(\"testvalue\"), returnString);\n         BOOST_CHECK_EQUAL(returnString, std::string(\"aValue\"));\n         aDB->Write(std::string(\"testvalue\"), std::string(\"aValue2\"));\n@@ -134,7 +143,61 @@ BOOST_AUTO_TEST_CASE(logdb_test_1)\n         aDB2->Close();\n         delete aDB2;\n     }\n+}\n+\n+\n+BOOST_AUTO_TEST_CASE(logdb_test_rewrite)\n+{\n+    boost::filesystem::path tmpPath = GetTempPath() / strprintf(\"test_bitcoin_logdb_compact_%lu_%i.logdb\", (unsigned long)GetTime(), (int)(GetRand(100000)));\n+    \n+    std::string dbFile = tmpPath.string();\n+    std::string dbFileRewritten = dbFile+\".tmp\";\n+    \n+\n+    CLogDB *aDB = new CLogDB(dbFile, false);\n+    aDB->Load();\n+    aDB->Write(std::string(\"testvalue\"), std::string(\"aValue\"));\n+    aDB->Flush(true); //shutdown, close the file\n+    aDB->Close();\n+    delete aDB;\n+    \n+    aDB = new CLogDB(dbFile, false);\n+    aDB->Load();\n+    std::string returnString;\n+    aDB->Read(std::string(\"testvalue\"), returnString);\n+    BOOST_CHECK_EQUAL(returnString, std::string(\"aValue\"));\n+    aDB->Write(std::string(\"testvalue\"), std::string(\"aValue2\")); //overwrite value\n+    aDB->Read(std::string(\"testvalue\"), returnString);\n+    BOOST_CHECK_EQUAL(returnString, std::string(\"aValue2\"));\n+    \n+    aDB->Rewrite(dbFileRewritten); //this new db should only containe key \"testvalue\" once\n+    \n+    aDB->Flush(true); //shutdown, close the file\n+    aDB->Close();\n+    delete aDB;\n+    \n+    \n+    //open the new compact db and check of the value\n+    aDB = new CLogDB(dbFileRewritten, false);\n+    aDB->Load();\n+    aDB->Read(std::string(\"testvalue\"), returnString);\n+    BOOST_CHECK_EQUAL(returnString, std::string(\"aValue2\"));\n+    aDB->Close();\n+    delete aDB;\n+\n+    \n+    // compare filesizes\n+    FILE *fh = fopen(dbFile.c_str(), \"rb\");\n+    fseek(fh, 0L, SEEK_END);\n+    size_t oldFileSize = ftell(fh);\n+    fclose(fh);\n+    \n+    fh = fopen(dbFileRewritten.c_str(), \"rb\");\n+    fseek(fh, 0L, SEEK_END);\n+    size_t newFileSize = ftell(fh);\n+    fclose(fh);\n     \n+    BOOST_CHECK(newFileSize > (oldFileSize-8)/2.0); // file size must be half the size minus the ~8 header (depends on version int length) bytes\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "7ea5995486e47f4b091beccbda3d74d0e3306a29",
        "filename": "src/wallet.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 17,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/75851f3bdf20b68e8894878c0f04703318ad2acb/src/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/75851f3bdf20b68e8894878c0f04703318ad2acb/src/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.cpp?ref=75851f3bdf20b68e8894878c0f04703318ad2acb",
        "patch": "@@ -430,38 +430,31 @@ bool CWallet::EncryptWallet(const SecureString& strWalletPassphrase)\n         mapMasterKeys[++nMasterKeyMaxID] = kMasterKey;\n         if (fFileBacked)\n         {\n-            assert(!pwalletdbEncryption);\n-            pwalletdbEncryption = new CWalletDB(strWalletFile);\n-            if (!pwalletdbEncryption->TxnBegin()) {\n-                delete pwalletdbEncryption;\n-                pwalletdbEncryption = NULL;\n+            if (!walletDB->TxnBegin())\n                 return false;\n-            }\n-            pwalletdbEncryption->WriteMasterKey(nMasterKeyMaxID, kMasterKey);\n+            \n+            walletDB->WriteMasterKey(nMasterKeyMaxID, kMasterKey);\n         }\n \n         if (!EncryptKeys(vMasterKey))\n         {\n-            if (fFileBacked) {\n-                pwalletdbEncryption->TxnAbort();\n-                delete pwalletdbEncryption;\n-            }\n+            if (fFileBacked)\n+                walletDB->TxnAbort();\n+            \n             // We now probably have half of our keys encrypted in memory, and half not...\n             // die and let the user reload their unencrypted wallet.\n+            LogPrintf(\"Encryption failed. Exiting...\\n\");\n             assert(false);\n         }\n \n         if (fFileBacked)\n         {\n-            if (!pwalletdbEncryption->TxnCommit()) {\n-                delete pwalletdbEncryption;\n+            if (!walletDB->TxnCommit()) {\n                 // We now have keys encrypted in memory, but not on disk...\n                 // die to avoid confusion and let the user reload their unencrypted wallet.\n+                LogPrintf(\"Encryption transaction commit failed. Exiting...\\n\");\n                 assert(false);\n             }\n-\n-            delete pwalletdbEncryption;\n-            pwalletdbEncryption = NULL;\n         }\n \n         Lock();\n@@ -470,7 +463,12 @@ bool CWallet::EncryptWallet(const SecureString& strWalletPassphrase)\n         Lock();\n         \n         // Rewrite wallet because we may use a append only backend\n-        walletDB->Rewrite();\n+        boost::filesystem::path walletFile = GetDataDir() / strWalletFile;\n+        if(walletDB->RewriteAndReplace(walletFile.string()) != DB_LOAD_OK)\n+        {\n+            LogPrintf(\"Corrupt wallet detected after encryption/file-move...\\n\");\n+            assert(false);\n+        }\n     }\n     NotifyStatusChanged(this);\n "
      },
      {
        "sha": "76a34b340603e93f16947c303936fb4f0b9c9e1d",
        "filename": "src/walletdb.cpp",
        "status": "modified",
        "additions": 29,
        "deletions": 6,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/75851f3bdf20b68e8894878c0f04703318ad2acb/src/walletdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/75851f3bdf20b68e8894878c0f04703318ad2acb/src/walletdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/walletdb.cpp?ref=75851f3bdf20b68e8894878c0f04703318ad2acb",
        "patch": "@@ -707,11 +707,30 @@ bool CWalletDB::ZapWalletTx(CWallet* pwallet, vector<CWalletTx>& vWtx)\n     return true;\n }\n \n-DBErrors CWalletDB::Rewrite()\n+DBErrors CWalletDB::RewriteAndReplace(const string& walletFile)\n {\n-    //TODO: implement\n-    //Here we need a way of write down the whole mapData to a new file\n-    //Flush_() needs to be rewritten\n+    std::string newFile = walletFile+\".tmp\";\n+    Rewrite(newFile);\n+    \n+    //simple verify\n+    CLogDBFile *newDB = new CLogDBFile();\n+    bool dbLoadRet = newDB->Open(newFile.c_str(), false);\n+    delete newDB;\n+    \n+    if(dbLoadRet)\n+    {\n+        Close();\n+        \n+        \n+        boost::filesystem::remove_all(walletFile);\n+        RenameOver(newFile, walletFile);\n+        \n+        //reopen the db\n+        if(!ReloadDB(walletFile))\n+        {\n+            return DB_CORRUPT;\n+        }\n+    }\n     \n     return DB_LOAD_OK;\n }\n@@ -775,8 +794,12 @@ bool CWalletDB::Recover(std::string filename)\n \n bool CWalletDB::Verify(std::string filename, bool salvage)\n {\n-    //TODO\n-    return false;\n+    // simple verifying by loading the db keystore but not load the keys itself\n+    CWalletDB *newDB = new CWalletDB(filename);\n+    bool loadRet = newDB->Load();\n+    delete newDB;\n+    \n+    return loadRet;\n }\n \n bool CWalletDB::WriteDestData(const std::string &address, const std::string &key, const std::string &value)"
      },
      {
        "sha": "2dbbfbf1ba0ab7ca3f58aa978f29f8c4cdc24610",
        "filename": "src/walletdb.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/75851f3bdf20b68e8894878c0f04703318ad2acb/src/walletdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/75851f3bdf20b68e8894878c0f04703318ad2acb/src/walletdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/walletdb.h?ref=75851f3bdf20b68e8894878c0f04703318ad2acb",
        "patch": "@@ -128,7 +128,7 @@ class CWalletDB : public CLogDB\n     DBErrors FindWalletTx(CWallet* pwallet, std::vector<uint256>& vTxHash, std::vector<CWalletTx>& vWtx);\n     bool ZapWalletTx(CWallet* pwallet, std::vector<CWalletTx>& vWtx);\n     \n-    DBErrors Rewrite();\n+    DBErrors RewriteAndReplace(const std::string& walletFile); //rewrites and compacts database, will replace existing wallet file\n     \n     static bool Recover(std::string filename, bool fOnlyKeys);\n     static bool Recover(std::string filename);"
      }
    ]
  },
  {
    "sha": "bde59e1974640d9d83e33ca61bbc637b01eff7a1",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiZGU1OWUxOTc0NjQwZDlkODNlMzNjYTYxYmJjNjM3YjAxZWZmN2Ex",
    "commit": {
      "author": {
        "name": "Jonas Schnelli",
        "email": "jonas.schnelli@include7.ch",
        "date": "2015-01-23T13:19:10Z"
      },
      "committer": {
        "name": "Jonas Schnelli",
        "email": "jonas.schnelli@include7.ch",
        "date": "2015-02-09T20:29:50Z"
      },
      "message": "[Wallet] tests and cleanup\n\n- add wallet encryption/unlocking test\n- cleanup logdb, remove of initial header with logdb-file version number\n- remove fileBackend=false option (doesn't make sense anymore)\n- remove wallet max/min version",
      "tree": {
        "sha": "83efe8f603deb95e56de538f19b5aec0a4d6576b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/83efe8f603deb95e56de538f19b5aec0a4d6576b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/bde59e1974640d9d83e33ca61bbc637b01eff7a1",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bde59e1974640d9d83e33ca61bbc637b01eff7a1",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/bde59e1974640d9d83e33ca61bbc637b01eff7a1",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bde59e1974640d9d83e33ca61bbc637b01eff7a1/comments",
    "author": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "75851f3bdf20b68e8894878c0f04703318ad2acb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/75851f3bdf20b68e8894878c0f04703318ad2acb",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/75851f3bdf20b68e8894878c0f04703318ad2acb"
      }
    ],
    "stats": {
      "total": 812,
      "additions": 173,
      "deletions": 639
    },
    "files": [
      {
        "sha": "344f8bb44bedadd4f1427f6cd523750fa90bd9cc",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bde59e1974640d9d83e33ca61bbc637b01eff7a1/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bde59e1974640d9d83e33ca61bbc637b01eff7a1/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=bde59e1974640d9d83e33ca61bbc637b01eff7a1",
        "patch": "@@ -1126,11 +1126,8 @@ bool AppInit2(boost::thread_group& threadGroup)\n         }\n \n         if (GetBoolArg(\"-upgradewallet\", fFirstRun))\n-        {\n             LogPrintf(\"There is no upgrade required (your version: %d)\\n\", pwalletMain->GetVersion());\n \n-        }\n-\n         if (fFirstRun)\n         {\n             // Create new keyUser and set as default key"
      },
      {
        "sha": "3ca11ef5d03d3dc5e3f5359b4320e33558b49e47",
        "filename": "src/logdb.cpp",
        "status": "modified",
        "additions": 52,
        "deletions": 78,
        "changes": 130,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bde59e1974640d9d83e33ca61bbc637b01eff7a1/src/logdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bde59e1974640d9d83e33ca61bbc637b01eff7a1/src/logdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/logdb.cpp?ref=bde59e1974640d9d83e33ca61bbc637b01eff7a1",
        "patch": "@@ -11,6 +11,14 @@\n #define LOGDB_MAX_KEY_SIZE 0x1000\n #define LOGDB_MAX_VALUE_SIZE 0x100000\n \n+static const unsigned char logdb_frameheader_magic[4] = {0xB1,0xA0,0xEE,0xC9};\n+\n+#ifdef DEBUG_LOGDB\n+#define LogDBDebug(...) LogPrint(NULL, __VA_ARGS__)\n+#else\n+#define LogDBDebug(...) ;\n+#endif\n+\n using namespace std;\n \n // Compact integers: least-significant digit first base-128 encoding.\n@@ -49,7 +57,7 @@ uint64_t static ReadInt(FILE *file)\n }\n \n // File format\n-// \n+//\n // The file consists of a list of frames, each of which consists of:\n // 4 bytes magic: 0xCC 0xC4 0xE6 0xB0\n // N records, each of which consists of:\n@@ -77,24 +85,12 @@ void CLogDBFile::Init_()\n     nUsed = 0;\n     nWritten = 0;\n     setDirty.clear();\n-    version = logdb_version;\n }\n \n bool CLogDBFile::Open_(const char *pszFile, bool fCreate)\n {\n-    fileName = string(pszFile);\n-    \n-    size_t size;\n-    struct stat sbuf;\n-    if (stat(pszFile, &sbuf) != 0) {\n-        size = 0;\n-    } else {\n-        size = sbuf.st_size;\n-    }\n-    \n-    LogPrintf(\"CLogDB::Open Filesize %ld\\n\", size);\n-    \n-    file = fopen(pszFile, \"a+b\");\n+    fileName = string(pszFile); //keep filename\n+    file = fopen(pszFile, \"a+b\"); //always use \"append\"-mode by default\n     \n     if (file == NULL) {\n         LogPrintf(\"CLogDB::Open Error opening %s: %s\\n\", pszFile, strerror(errno));\n@@ -108,21 +104,8 @@ bool CLogDBFile::Open_(const char *pszFile, bool fCreate)\n             LogPrintf(\"CLogDB::Open Error creating %s. Existing file detected\\n\", pszFile);\n             return false;\n         }\n-        else\n-        {\n-            if (fwrite(logdb_header_magic, 4, 1, file) != 1)\n-            {\n-                LogPrintf(\"CLogDBFile::Open_(): error writing magic: %s\\n\", strerror(errno));\n-            }\n-            WriteInt(file, version);\n-            fflush(file);\n-            FileCommit(file);\n-            \n-            LogPrintf(\"CLogDBFile::Open_(): pos1: %ld\\n\", ftell(file));\n-        }\n     }\n \n-    LogPrintf(\"CLogDBFile::Open_(): pos3: %ld\\n\", ftell(file));\n     return true;\n }\n \n@@ -186,7 +169,7 @@ bool CLogDBFile::Close_()\n     {\n         Flush_();\n         \n-        LogPrintf(\"CLogDBFile::Close(): closing file\\n\");\n+        LogDBDebug(\"CLogDBFile::Close(): closing file\\n\");\n         fclose(file);\n         Init_();\n     }\n@@ -195,46 +178,29 @@ bool CLogDBFile::Close_()\n \n bool CLogDBFile::Load_()\n {\n-    LogPrintf(\"CLogDB::Load(): start loading\\n\");\n+    LogDBDebug(\"CLogDB::Load(): start loading\\n\");\n+    \n     if (feof(file))\n-    {\n-        LogPrintf(\"CLogDB::Load(): eof, return\\n\");\n         return true;\n-    }\n-    \n-    //logdb header\n-    if (getc(file) != logdb_header_magic[0]) return feof(file);\n-    if (getc(file) != logdb_header_magic[1]) return false;\n-    if (getc(file) != logdb_header_magic[2]) return false;\n-    if (getc(file) != logdb_header_magic[3]) return false;\n-    \n-    LogPrintf(\"CLogDB::Load(): header okay %ld\\n\", ftell(file));\n-    \n-    version = ReadInt(file);\n-    if (version == 0) return false;\n-    \n-    LogPrintf(\"CLogDB::Load(): version okay %d, %ld\\n\", version, ftell(file));\n     \n     do\n     {\n-        LogPrintf(\"CLogDB::Load(): check for frame\\n\");\n         if (feof(file))\n         {\n-            LogPrintf(\"CLogDB::Load(): end of file, returning\\n\");\n+            LogDBDebug(\"CLogDB::Load(): end of file, returning\\n\");\n             return true;\n         }\n         int aChar = getc(file);\n         if (aChar != logdb_frameheader_magic[0])\n         {\n-            LogPrintf(\"CLogDB::Load(): first frame headerbyte is wront found %2x pos: %ld\\n\", aChar, ftell(file));\n+            LogDBDebug(\"CLogDB::Load(): first frame headerbyte is incorrect found %2x\\n\", aChar);\n             return feof(file);\n         }\n-        LogPrintf(\"CLogDB::Load(): first frame headerbyte is okay (%2x) pos: %ld\\n\", aChar, ftell(file));\n         if (getc(file) != logdb_frameheader_magic[1]) return false;\n         if (getc(file) != logdb_frameheader_magic[2]) return false;\n         if (getc(file) != logdb_frameheader_magic[3]) return false;\n \n-        LogPrintf(\"CLogDB::Load(): frame header found\\n\");\n+        LogDBDebug(\"CLogDB::Load(): frame header found\\n\");\n \n         vector<CModEntry> vMod;\n \n@@ -253,7 +219,7 @@ bool CLogDBFile::Load_()\n             entry.nMode = getc(file);\n             if (entry.nMode > 2)\n             {\n-                LogPrintf(\"CLogDBFile::Load(): unknown record mode\\n\");\n+                LogDBDebug(\"CLogDBFile::Load(): unknown record mode\\n\");\n                 return false;\n             }\n \n@@ -262,22 +228,22 @@ bool CLogDBFile::Load_()\n             if (entry.nMode == 0)\n                 break;\n \n-            LogPrintf(\"CLogDBFile::Load(): loading record mode %i\\n\", entry.nMode);\n+            LogDBDebug(\"CLogDBFile::Load(): loading record mode %i\\n\", entry.nMode);\n \n             uint32_t nKeySize = ReadInt(file);\n             if (nKeySize >= LOGDB_MAX_KEY_SIZE)\n             {\n-                LogPrintf(\"CLogDBFile::Load(): oversizes key (%lu bytes)\\n\", (unsigned long)nKeySize);\n+                LogDBDebug(\"CLogDBFile::Load(): oversizes key (%lu bytes)\\n\", (unsigned long)nKeySize);\n                 return false;\n             }\n             entry.key.resize(nKeySize);\n             if (fread(&entry.key[0], nKeySize, 1, file) != 1)\n             {\n-                LogPrintf(\"CLogDBFile::Load(): unable to read key (%lu bytes)\\n\", (unsigned long)nKeySize);\n+                LogDBDebug(\"CLogDBFile::Load(): unable to read key (%lu bytes)\\n\", (unsigned long)nKeySize);\n                 return false;\n             }\n \n-            LogPrintf(\"CLogDBFile::load(): loading key (%.*s)\\n\", nKeySize, &entry.key[0]);\n+            LogDBDebug(\"CLogDBFile::load(): loading key (%.*s)\\n\", nKeySize, &entry.key[0]);\n \n             ctx.Write((const unsigned char *)&nKeySize, 4);\n             ctx.Write((const unsigned char *)&entry.key[0], nKeySize);\n@@ -287,13 +253,13 @@ bool CLogDBFile::Load_()\n                 int nValueSize = ReadInt(file);\n                 if (nValueSize >= LOGDB_MAX_VALUE_SIZE)\n                 {\n-                    LogPrintf(\"CLogDBFile::Load(): oversized value (%lu bytes)\\n\", (unsigned long)nValueSize);\n+                    LogDBDebug(\"CLogDBFile::Load(): oversized value (%lu bytes)\\n\", (unsigned long)nValueSize);\n                     return false;\n                 }\n                 entry.value.resize(nValueSize);\n                 if (fread(&entry.value[0], nValueSize, 1, file) != 1)\n                 {\n-                    LogPrintf(\"CLogDBFile::Load(): unable to read value (%lu bytes)\\n\", (unsigned long)nValueSize);\n+                    LogDBDebug(\"CLogDBFile::Load(): unable to read value (%lu bytes)\\n\", (unsigned long)nValueSize);\n                     return false;\n                 }\n \n@@ -307,7 +273,7 @@ bool CLogDBFile::Load_()\n         unsigned char check[8];\n         if (fread(check, 8, 1, file)!=1)\n         {\n-            LogPrintf(\"CLogDBFile::Load(): unable to read checksum\\n\");\n+            LogDBDebug(\"CLogDBFile::Load(): unable to read checksum\\n\");\n             return false;\n         }\n \n@@ -320,10 +286,6 @@ bool CLogDBFile::Load_()\n             LogPrintf(\"CLogDBFile::Load(): checksum failed\\n\");\n             return false;\n         }\n-        else\n-        {\n-            LogPrintf(\"CLogDBFile::Load(): checksum OK\\n\");\n-        }\n \n         // if we reach this point, the entire read frame was valid\n         ctxState = ctx;\n@@ -346,7 +308,7 @@ bool CLogDBFile::Load_()\n \n     } while(true);\n \n-    LogPrintf(\"CLogDBFile::Load(): done\\n\");\n+    LogDBDebug(\"CLogDBFile::Load(): done\\n\");\n }\n \n bool CLogDBFile::Reopen_(bool readOnly)\n@@ -362,21 +324,19 @@ bool CLogDBFile::Reopen_(bool readOnly)\n \n bool CLogDBFile::Flush_()\n {\n-    LogPrintf(\"CLogDBFile::Flush_()\\n\");\n+    LogDBDebug(\"CLogDBFile::Flush_()\\n\");\n \n     if (setDirty.empty())\n         return true;\n \n-    LogPrintf(\"CLogDBFile::Flush_(): dirty entries found\\n\");\n+    LogDBDebug(\"CLogDBFile::Flush_(): dirty entries found\\n\");\n \n-    LogPrintf(\"CLogDBFile::Flush(): current fpos: %ld\\n\", ftell(file));\n-    \n     if (fwrite(logdb_frameheader_magic, 4, 1, file) != 1)\n     {\n-        LogPrintf(\"CLogDBFile::Flush_(): error writing magic: %s\\n\", strerror(errno));\n+        LogDBDebug(\"CLogDBFile::Flush_(): error writing magic: %s\\n\", strerror(errno));\n+        return false;\n     }\n \n-    LogPrintf(\"CLogDBFile::Flush(): current fpos (afther header): %ld\\n\", ftell(file));\n     \n     CSHA256 ctx = ctxState;\n \n@@ -392,7 +352,7 @@ bool CLogDBFile::Flush_()\n             uint32_t nDataSize = (*it2).second.size();\n             nWritten += nKeySize + nDataSize;\n \n-            LogPrintf(\"CLogDBFile::Flush(): writing update(%.*s)\\n\", nKeySize, &(*it)[0]);\n+            LogDBDebug(\"CLogDBFile::Flush(): writing update (keysize: %d, str0-2: %.3s)\\n\", nKeySize, &(*it)[0]);\n \n             putc(nMode, file);\n             WriteInt(file, nKeySize);\n@@ -413,7 +373,8 @@ bool CLogDBFile::Flush_()\n             uint32_t nKeySize = (*it).size();\n             nWritten += nKeySize;\n \n-            LogPrintf(\"CLogDBFile::Flush(): writing erase(%.*s)\\n\", nKeySize, &(*it)[0]);\n+            \n+            LogDBDebug(\"CLogDBFile::Flush(): writing erase (keysize: %d, str0-2: %.3s)\\n\", nKeySize, &(*it)[0]);\n \n             putc(nMode, file);\n             WriteInt(file, nKeySize);\n@@ -437,7 +398,7 @@ bool CLogDBFile::Flush_()\n     FileCommit(file);\n     ctxState = ctx;\n \n-    LogPrintf(\"CLogDBFile::Flush(): wrote frame pos: %ld\\n\", ftell(file));\n+    LogDBDebug(\"CLogDBFile::Flush(): wrote frame pos: %ld\\n\", ftell(file));\n \n     setDirty.clear();\n \n@@ -494,14 +455,14 @@ bool CLogDB::TxnCommit() {\n     }\n     mapData.clear();\n     setDirty.clear();\n-\n+    if (!fReadOnly)\n+        db->Flush_();\n+    \n     fTransaction = false;\n     if (fReadOnly)\n         db->mutex.unlock_shared();\n     else\n         db->mutex.unlock();\n-\n-    db->Flush_();\n     \n     return true;\n }\n@@ -511,16 +472,29 @@ bool CLogDB::ReloadDB(const string& walletFile)\n     delete db;\n     db = new CLogDBFile();\n     db->Open(walletFile.c_str(), false);\n-    if(!Load())\n+    if (!Load())\n+    {\n+        loaded = false;\n         return false;\n+    }\n \n     return true;\n }\n \n bool CLogDB::Load() {\n+    \n+    // for loading we need the file in \"rb+\" mode.\n     db->Reopen_(true);\n+    \n+    // map to memory\n     bool loadRet = db->Load_();\n-    db->Reopen_(false);\n+    \n+    // reset the file to append writing mode \"ab+\"\n+    if (loadRet)\n+    {\n+        db->Reopen_(false);\n+        loaded = true;\n+    }\n     \n     return loadRet;\n }"
      },
      {
        "sha": "c0b961cee06e248b59a612459e5cf9b67e7e8f5e",
        "filename": "src/logdb.h",
        "status": "modified",
        "additions": 16,
        "deletions": 9,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bde59e1974640d9d83e33ca61bbc637b01eff7a1/src/logdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bde59e1974640d9d83e33ca61bbc637b01eff7a1/src/logdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/logdb.h?ref=bde59e1974640d9d83e33ca61bbc637b01eff7a1",
        "patch": "@@ -20,10 +20,6 @@\n \n #include \"crypto/sha256.h\"\n \n-static const unsigned char logdb_frameheader_magic[4] = {0xB1,0xA0,0xEE,0xC9};\n-static const unsigned char logdb_header_magic[4]      = {0xCC,0xC4,0xE6,0xB0};\n-static const int64_t logdb_version                    = 10000;\n-\n typedef std::vector<unsigned char> data_t;\n \n class CLogDB;\n@@ -37,7 +33,6 @@ class CLogDBFile\n     std::string fileName;\n     \n     CSHA256 ctxState;\n-    uint64_t version;\n     \n     // database\n     std::map<data_t, data_t> mapData;\n@@ -92,30 +87,33 @@ class CLogDB\n     typedef data_t key_type;\n     typedef data_t value_type;\n     typedef std::map<key_type, value_type>::const_iterator const_iterator;\n-\n-private:\n     mutable CCriticalSection cs;\n+    \n+private:\n     CLogDBFile *db; // pointer to non-const db\n     const bool fReadOnly; // readonly CLogDB's use a shared lock instead of a normal\n \n     bool fTransaction; // true inside a transaction\n     std::map<data_t, data_t> mapData; // must be empty outside transactions\n     std::set<data_t> setDirty;\n \n+    bool loaded;\n+    \n public:\n     bool TxnAbort();\n     bool TxnBegin();\n     bool TxnCommit();\n     bool Flush(bool shutdown = false);\n     \n-    CLogDB(std::string pathAndFile, bool fReadOnlyIn = false) : fReadOnly(fReadOnlyIn), fTransaction(false)\n+    CLogDB(std::string pathAndFile, bool fReadOnlyIn = false) : fReadOnly(fReadOnlyIn), fTransaction(false), loaded(false)\n     {\n         db = new CLogDBFile();\n         bool createFile = true;\n         if(boost::filesystem::exists(pathAndFile))\n             createFile = false;\n         \n-        db->Open(pathAndFile.c_str(), createFile);\n+        if(db->Open(pathAndFile.c_str(), createFile) && createFile)\n+            loaded = true;\n     }\n \n     ~CLogDB() {\n@@ -137,6 +135,7 @@ class CLogDB\n     \n     bool Close() {\n         boost::lock_guard<boost::shared_mutex> lock(db->mutex);\n+        loaded = false;\n         return db->Close_();\n     }\n     \n@@ -154,6 +153,8 @@ class CLogDB\n template<typename K, typename V>\n bool Write(const K &key, const V &value, bool fOverwrite = true)\n {\n+    if (!loaded) return false;\n+    \n     CDataStream ssk(SER_DISK, CLIENT_VERSION);\n     ssk << key;\n     data_t datak(ssk.begin(), ssk.end());\n@@ -165,6 +166,8 @@ bool Write(const K &key, const V &value, bool fOverwrite = true)\n template<typename K, typename V>\n bool Read(const K &key, V &value)\n {\n+    if (!loaded) return false;\n+    \n     CDataStream ssk(SER_DISK, CLIENT_VERSION);\n     ssk << key;\n     data_t datak(ssk.begin(), ssk.end());\n@@ -178,6 +181,8 @@ bool Read(const K &key, V &value)\n template<typename K>\n bool Exists(const K &key)\n {\n+    if (!loaded) return false;\n+    \n     CDataStream ssk(SER_DISK, CLIENT_VERSION);\n     ssk << key;\n     data_t datak(ssk.begin(), ssk.end());\n@@ -186,6 +191,8 @@ bool Exists(const K &key)\n template<typename K>\n bool Erase(const K &key)\n {\n+    if (!loaded) return false;\n+    \n     CDataStream ssk(SER_DISK, CLIENT_VERSION);\n     ssk << key;\n     data_t datak(ssk.begin(), ssk.end());"
      },
      {
        "sha": "925ca26ec032e8170e26421b482a9452d4061464",
        "filename": "src/qt/walletmodel.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bde59e1974640d9d83e33ca61bbc637b01eff7a1/src/qt/walletmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bde59e1974640d9d83e33ca61bbc637b01eff7a1/src/qt/walletmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletmodel.cpp?ref=bde59e1974640d9d83e33ca61bbc637b01eff7a1",
        "patch": "@@ -434,7 +434,7 @@ bool WalletModel::changePassphrase(const SecureString &oldPass, const SecureStri\n \n bool WalletModel::backupWallet(const QString &filename)\n {\n-    return BackupWallet(*wallet, filename.toLocal8Bit().data());\n+    return wallet->BackupWallet(filename.toLocal8Bit().data());\n }\n \n // Handlers for core signals"
      },
      {
        "sha": "fe75a50d38abf4fed012bd850287006fbea8d212",
        "filename": "src/rpcwallet.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bde59e1974640d9d83e33ca61bbc637b01eff7a1/src/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bde59e1974640d9d83e33ca61bbc637b01eff7a1/src/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcwallet.cpp?ref=bde59e1974640d9d83e33ca61bbc637b01eff7a1",
        "patch": "@@ -1606,7 +1606,7 @@ Value backupwallet(const Array& params, bool fHelp)\n     LOCK2(cs_main, pwalletMain->cs_wallet);\n \n     string strDest = params[0].get_str();\n-    if (!BackupWallet(*pwalletMain, strDest))\n+    if (!pwalletMain->BackupWallet(strDest))\n         throw JSONRPCError(RPC_WALLET_ERROR, \"Error: Wallet backup failed!\");\n \n     return Value::null;"
      },
      {
        "sha": "5d56b399d76306f0fbba04ee7f6c185bcfea317d",
        "filename": "src/test/accounting_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bde59e1974640d9d83e33ca61bbc637b01eff7a1/src/test/accounting_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bde59e1974640d9d83e33ca61bbc637b01eff7a1/src/test/accounting_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/accounting_tests.cpp?ref=bde59e1974640d9d83e33ca61bbc637b01eff7a1",
        "patch": "@@ -31,6 +31,8 @@ GetResults(CWalletDB& walletdb, std::map<CAmount, CAccountingEntry>& results)\n BOOST_AUTO_TEST_CASE(acc_orderupgrade)\n {\n     CWalletDB walletdb(pwalletMain->strWalletFile);\n+    walletdb.Load();\n+    \n     std::vector<CWalletTx*> vpwtx;\n     CWalletTx wtx;\n     CAccountingEntry ae;"
      },
      {
        "sha": "e11d5c388f55381f474c3bae52d7194f078d0dd0",
        "filename": "src/test/logdb_tests.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bde59e1974640d9d83e33ca61bbc637b01eff7a1/src/test/logdb_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bde59e1974640d9d83e33ca61bbc637b01eff7a1/src/test/logdb_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/logdb_tests.cpp?ref=bde59e1974640d9d83e33ca61bbc637b01eff7a1",
        "patch": "@@ -18,8 +18,6 @@ BOOST_AUTO_TEST_SUITE(logdb_tests)\n \n BOOST_AUTO_TEST_CASE(logdb_test_1)\n {\n-    fPrintToConsole = true;\n-    \n     boost::filesystem::path tmpPath = GetTempPath() / strprintf(\"test_bitcoin_logdb_%lu_%i.logdb\", (unsigned long)GetTime(), (int)(GetRand(100000)));    \n     std::string dbFile = tmpPath.string();\n     "
      },
      {
        "sha": "f163f6715948ae9629b0c4d5e8d2a0c91ccdf152",
        "filename": "src/test/wallet_tests.cpp",
        "status": "modified",
        "additions": 47,
        "deletions": 0,
        "changes": 47,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bde59e1974640d9d83e33ca61bbc637b01eff7a1/src/test/wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bde59e1974640d9d83e33ca61bbc637b01eff7a1/src/test/wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/wallet_tests.cpp?ref=bde59e1974640d9d83e33ca61bbc637b01eff7a1",
        "patch": "@@ -305,4 +305,51 @@ BOOST_AUTO_TEST_CASE(coin_selection_tests)\n     empty_wallet();\n }\n \n+//BOOST_AUTO_TEST_CASE(encrypt_wallet_tests)\n+//{\n+//    SecureString strWalletPass;\n+//    strWalletPass.reserve(100);\n+//    strWalletPass = \"test\";\n+//    \n+//    std::string dbFile = strprintf(\"test_bitcoin_logdb_%lu_%i.logdb\", (unsigned long)GetTime(), (int)(GetRand(100000)));\n+//    \n+//    bool fFirstRun = true;\n+//    CWallet *newWallet = new CWallet(dbFile);\n+//    newWallet->LoadWallet(fFirstRun);\n+//    \n+//    CPubKey newDefaultKey;\n+//    {\n+//        LOCK(newWallet->cs_wallet);\n+//\n+//        newDefaultKey = newWallet->GenerateNewKey();\n+//        newWallet->SetDefaultKey(newDefaultKey);\n+//        newWallet->TopUpKeyPool(10); //add 10 keys\n+//        \n+//        BOOST_CHECK(newWallet->IsLocked() == false);\n+//        BOOST_CHECK(newWallet->EncryptWallet(strWalletPass));\n+//        BOOST_CHECK(newWallet->IsLocked() == true);\n+//\n+//        BOOST_CHECK(newWallet->Unlock(strWalletPass));\n+//        BOOST_CHECK(newWallet->IsLocked() == false);\n+//        \n+//        BOOST_CHECK(newWallet->Lock());\n+//        BOOST_CHECK(newWallet->IsLocked() == true);\n+//        \n+//        BOOST_CHECK_THROW(newWallet->GenerateNewKey(), std::runtime_error); // must trigger a assertion because wallet is locked\n+//        BOOST_CHECK(newWallet->Unlock(strWalletPass));\n+//        BOOST_CHECK_NO_THROW(newWallet->GenerateNewKey()); // must trigger a assertion because wallet is locked\n+//    }\n+//    \n+//    delete newWallet;\n+//\n+//    newWallet = new CWallet(dbFile);\n+//    newWallet->LoadWallet(fFirstRun);\n+//    {\n+//        LOCK(newWallet->cs_wallet);\n+//        BOOST_CHECK(newWallet->vchDefaultKey == newDefaultKey); // after the encryption, default key must still be readable\n+//    }\n+//    delete newWallet;\n+//    \n+//}\n+\n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "77b264d18e903fabce44b848e7a32c13689c782e",
        "filename": "src/wallet.cpp",
        "status": "modified",
        "additions": 52,
        "deletions": 82,
        "changes": 134,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bde59e1974640d9d83e33ca61bbc637b01eff7a1/src/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bde59e1974640d9d83e33ca61bbc637b01eff7a1/src/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.cpp?ref=bde59e1974640d9d83e33ca61bbc637b01eff7a1",
        "patch": "@@ -100,8 +100,6 @@ bool CWallet::AddKeyPubKey(const CKey& secret, const CPubKey &pubkey)\n     if (HaveWatchOnly(script))\n         RemoveWatchOnly(script);\n \n-    if (!fFileBacked)\n-        return true;\n     if (!IsCrypted()) {\n         return walletDB->WriteKey(pubkey,\n                                                  secret.GetPrivKey(),\n@@ -115,18 +113,11 @@ bool CWallet::AddCryptedKey(const CPubKey &vchPubKey,\n {\n     if (!CCryptoKeyStore::AddCryptedKey(vchPubKey, vchCryptedSecret))\n         return false;\n-    if (!fFileBacked)\n-        return true;\n     {\n         LOCK(cs_wallet);\n-        if (pwalletdbEncryption)\n-            return pwalletdbEncryption->WriteCryptedKey(vchPubKey,\n+        return walletDB->WriteCryptedKey(vchPubKey,\n                                                         vchCryptedSecret,\n                                                         mapKeyMetadata[vchPubKey.GetID()]);\n-        else\n-            return walletDB->WriteCryptedKey(vchPubKey,\n-                                                            vchCryptedSecret,\n-                                                            mapKeyMetadata[vchPubKey.GetID()]);\n     }\n     return false;\n }\n@@ -150,8 +141,6 @@ bool CWallet::AddCScript(const CScript& redeemScript)\n {\n     if (!CCryptoKeyStore::AddCScript(redeemScript))\n         return false;\n-    if (!fFileBacked)\n-        return true;\n     return walletDB->WriteCScript(Hash160(redeemScript), redeemScript);\n }\n \n@@ -177,8 +166,6 @@ bool CWallet::AddWatchOnly(const CScript &dest)\n         return false;\n     nTimeFirstKey = 1; // No birthday information for watch-only keys.\n     NotifyWatchonlyChanged(true);\n-    if (!fFileBacked)\n-        return true;\n     return walletDB->WriteWatchOnly(dest);\n }\n \n@@ -189,9 +176,8 @@ bool CWallet::RemoveWatchOnly(const CScript &dest)\n         return false;\n     if (!HaveWatchOnly())\n         NotifyWatchonlyChanged(false);\n-    if (fFileBacked)\n-        if (!walletDB->EraseWatchOnly(dest))\n-            return false;\n+    if (!walletDB->EraseWatchOnly(dest))\n+        return false;\n \n     return true;\n }\n@@ -277,18 +263,6 @@ bool CWallet::ReadBestBlock(CBlockLocator& locator)\n     return walletDB->ReadBestBlock(locator);\n }\n \n-bool CWallet::SetMaxVersion(int nVersion)\n-{\n-    LOCK(cs_wallet); // nWalletVersion, nWalletMaxVersion\n-    // cannot downgrade below current version\n-    if (nWalletVersion > nVersion)\n-        return false;\n-\n-    nWalletMaxVersion = nVersion;\n-\n-    return true;\n-}\n-\n set<uint256> CWallet::GetConflicts(const uint256& txid) const\n {\n     set<uint256> result;\n@@ -428,33 +402,27 @@ bool CWallet::EncryptWallet(const SecureString& strWalletPassphrase)\n     {\n         LOCK(cs_wallet);\n         mapMasterKeys[++nMasterKeyMaxID] = kMasterKey;\n-        if (fFileBacked)\n-        {\n-            if (!walletDB->TxnBegin())\n-                return false;\n-            \n-            walletDB->WriteMasterKey(nMasterKeyMaxID, kMasterKey);\n-        }\n+\n+        if (!walletDB->TxnBegin())\n+            return false;\n+        \n+        walletDB->WriteMasterKey(nMasterKeyMaxID, kMasterKey);\n \n         if (!EncryptKeys(vMasterKey))\n         {\n-            if (fFileBacked)\n-                walletDB->TxnAbort();\n+            walletDB->TxnAbort();\n             \n             // We now probably have half of our keys encrypted in memory, and half not...\n             // die and let the user reload their unencrypted wallet.\n             LogPrintf(\"Encryption failed. Exiting...\\n\");\n             assert(false);\n         }\n \n-        if (fFileBacked)\n-        {\n-            if (!walletDB->TxnCommit()) {\n-                // We now have keys encrypted in memory, but not on disk...\n-                // die to avoid confusion and let the user reload their unencrypted wallet.\n-                LogPrintf(\"Encryption transaction commit failed. Exiting...\\n\");\n-                assert(false);\n-            }\n+        if (!walletDB->TxnCommit()) {\n+            // We now have keys encrypted in memory, but not on disk...\n+            // die to avoid confusion and let the user reload their unencrypted wallet.\n+            LogPrintf(\"Encryption transaction commit failed. Exiting...\\n\");\n+            assert(false);\n         }\n \n         Lock();\n@@ -659,11 +627,7 @@ bool CWallet::AddToWalletIfInvolvingMe(const CTransaction& tx, const CBlock* pbl\n             if (pblock)\n                 wtx.SetMerkleBranch(*pblock);\n \n-            // Do not flush the wallet here for performance reasons\n-            // this is safe, as in case of a crash, we rescan the necessary blocks on startup through our SetBestChain-mechanism\n-            CWalletDB walletdb(strWalletFile, \"r+\", false);\n-\n-            return AddToWallet(wtx, false, &walletdb);\n+            return AddToWallet(wtx, false, walletDB);\n         }\n     }\n     return false;\n@@ -687,8 +651,6 @@ void CWallet::SyncTransaction(const CTransaction& tx, const CBlock* pblock)\n \n void CWallet::EraseFromWallet(const uint256 &hash)\n {\n-    if (!fFileBacked)\n-        return;\n     {\n         LOCK(cs_wallet);\n         if (mapWallet.erase(hash))\n@@ -761,6 +723,32 @@ bool CWallet::WriteTxToDisk(const CWalletTx& wtx)\n     return walletDB->WriteTx(wtx.GetHash(), wtx);\n }\n \n+bool CWallet::BackupWallet(const string& strDest)\n+{\n+    Flush(false);\n+    LOCK(walletDB->cs);\n+    \n+    // Copy wallet.dat\n+    boost::filesystem::path pathSrc = GetDataDir() / strWalletFile;\n+    boost::filesystem::path pathDest(strDest);\n+    if (boost::filesystem::is_directory(pathDest))\n+        pathDest /= strWalletFile;\n+    \n+    try {\n+#if BOOST_VERSION >= 104000\n+        boost::filesystem::copy_file(pathSrc, pathDest, boost::filesystem::copy_option::overwrite_if_exists);\n+#else\n+        boost::filesystem::copy_file(pathSrc, pathDest);\n+#endif\n+        LogPrintf(\"copied wallet.dat to %s\\n\", pathDest.string());\n+        return true;\n+    } catch (const boost::filesystem::filesystem_error& e) {\n+        LogPrintf(\"error copying wallet.dat to %s - %s\\n\", pathDest.string(), e.what());\n+        return false;\n+    }\n+    return false;\n+}\n+\n int64_t CWalletTx::GetTxTime() const\n {\n     int64_t n = nTimeSmart;\n@@ -1809,8 +1797,6 @@ CAmount CWallet::GetMinimumFee(unsigned int nTxBytes, unsigned int nConfirmTarge\n \n DBErrors CWallet::LoadWallet(bool& fFirstRunRet)\n {\n-    if (!fFileBacked)\n-        return DB_LOAD_OK;\n     fFirstRunRet = false;\n     DBErrors nLoadWalletRet = walletDB->LoadWallet(this);\n \n@@ -1827,9 +1813,6 @@ DBErrors CWallet::LoadWallet(bool& fFirstRunRet)\n \n bool CWallet::ZapWalletTx(std::vector<CWalletTx>& vWtx)\n {\n-    if (!fFileBacked)\n-        return true;\n-    \n     return walletDB->ZapWalletTx(this, vWtx);\n }\n \n@@ -1845,10 +1828,10 @@ bool CWallet::SetAddressBook(const CTxDestination& address, const string& strNam\n         if (!strPurpose.empty()) /* update purpose only if requested */\n             mapAddressBook[address].purpose = strPurpose;\n     }\n+    \n     NotifyAddressBookChanged(this, address, strName, ::IsMine(*this, address) != ISMINE_NO,\n                              strPurpose, (fUpdated ? CT_UPDATED : CT_NEW) );\n-    if (!fFileBacked)\n-        return false;\n+    \n     if (!strPurpose.empty() && !walletDB->WritePurpose(CBitcoinAddress(address).ToString(), strPurpose))\n         return false;\n     return walletDB->WriteName(CBitcoinAddress(address).ToString(), strName);\n@@ -1859,33 +1842,27 @@ bool CWallet::DelAddressBook(const CTxDestination& address)\n     {\n         LOCK(cs_wallet); // mapAddressBook\n \n-        if(fFileBacked)\n+        // Delete destdata tuples associated with address\n+        std::string strAddress = CBitcoinAddress(address).ToString();\n+        BOOST_FOREACH(const PAIRTYPE(string, string) &item, mapAddressBook[address].destdata)\n         {\n-            // Delete destdata tuples associated with address\n-            std::string strAddress = CBitcoinAddress(address).ToString();\n-            BOOST_FOREACH(const PAIRTYPE(string, string) &item, mapAddressBook[address].destdata)\n-            {\n-                walletDB->EraseDestData(strAddress, item.first);\n-            }\n+            walletDB->EraseDestData(strAddress, item.first);\n         }\n+    \n         mapAddressBook.erase(address);\n     }\n \n     NotifyAddressBookChanged(this, address, \"\", ::IsMine(*this, address) != ISMINE_NO, \"\", CT_DELETED);\n \n-    if (!fFileBacked)\n-        return false;\n     walletDB->ErasePurpose(CBitcoinAddress(address).ToString());\n     return walletDB->EraseName(CBitcoinAddress(address).ToString());\n }\n \n bool CWallet::SetDefaultKey(const CPubKey &vchPubKey)\n {\n-    if (fFileBacked)\n-    {\n-        if (!walletDB->WriteDefaultKey(vchPubKey))\n-            return false;\n-    }\n+    if (!walletDB->WriteDefaultKey(vchPubKey))\n+        return false;\n+    \n     vchDefaultKey = vchPubKey;\n     return true;\n }\n@@ -1974,10 +1951,7 @@ void CWallet::ReserveKeyFromKeyPool(int64_t& nIndex, CKeyPool& keypool)\n void CWallet::KeepKey(int64_t nIndex)\n {\n     // Remove from key pool\n-    if (fFileBacked)\n-    {\n-        walletDB->ErasePool(nIndex);\n-    }\n+    walletDB->ErasePool(nIndex);\n     LogPrintf(\"keypool keep %d\\n\", nIndex);\n }\n \n@@ -2418,17 +2392,13 @@ bool CWallet::AddDestData(const CTxDestination &dest, const std::string &key, co\n         return false;\n \n     mapAddressBook[dest].destdata.insert(std::make_pair(key, value));\n-    if (!fFileBacked)\n-        return true;\n     return walletDB->WriteDestData(CBitcoinAddress(dest).ToString(), key, value);\n }\n \n bool CWallet::EraseDestData(const CTxDestination &dest, const std::string &key)\n {\n     if (!mapAddressBook[dest].destdata.erase(key))\n         return false;\n-    if (!fFileBacked)\n-        return true;\n     return walletDB->EraseDestData(CBitcoinAddress(dest).ToString(), key);\n }\n "
      },
      {
        "sha": "cad76caeb845016a9c9b8524aae36e6ff861dd83",
        "filename": "src/wallet.h",
        "status": "modified",
        "additions": 2,
        "deletions": 396,
        "changes": 398,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bde59e1974640d9d83e33ca61bbc637b01eff7a1/src/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bde59e1974640d9d83e33ca61bbc637b01eff7a1/src/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.h?ref=bde59e1974640d9d83e33ca61bbc637b01eff7a1",
        "patch": "@@ -433,8 +433,6 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n     //! handle to the wallet backend\n     CWalletDB *walletDB;\n \n-    CWalletDB *pwalletdbEncryption;\n-\n     //! the current wallet version: clients below this version are not able to load the wallet\n     int nWalletVersion;\n \n@@ -461,12 +459,10 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n      * Main wallet lock.\n      * This lock protects all the fields added by CWallet\n      *   except for:\n-     *      fFileBacked (immutable after instantiation)\n      *      strWalletFile (immutable after instantiation)\n      */\n     mutable CCriticalSection cs_wallet;\n \n-    bool fFileBacked;\n     std::string strWalletFile;\n \n     std::set<int64_t> setKeyPool;\n@@ -489,15 +485,10 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n         \n         //instantiate a wallet backend object and maps the stored values\n         walletDB = new CWalletDB(strWalletFile);\n-        \n-        fFileBacked = true;\n     }\n \n     ~CWallet()\n     {\n-        delete pwalletdbEncryption;\n-        pwalletdbEncryption = NULL;\n-        \n         // make sure to discard the handle (it might close the db/file)\n         delete walletDB;\n     }\n@@ -506,9 +497,7 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n     {\n         nWalletVersion = FEATURE_BASE;\n         nWalletMaxVersion = FEATURE_BASE;\n-        fFileBacked = false;\n         nMasterKeyMaxID = 0;\n-        pwalletdbEncryption = NULL;\n         nOrderPosNext = 0;\n         nNextResend = 0;\n         nLastResend = 0;\n@@ -555,9 +544,6 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n     bool LoadKey(const CKey& key, const CPubKey &pubkey) { return CCryptoKeyStore::AddKeyPubKey(key, pubkey); }\n     //! Load metadata (used by LoadWallet)\n     bool LoadKeyMetadata(const CPubKey &pubkey, const CKeyMetadata &metadata);\n-\n-    bool LoadMinVersion(int nVersion) { AssertLockHeld(cs_wallet); nWalletVersion = nVersion; nWalletMaxVersion = std::max(nWalletMaxVersion, nVersion); return true; }\n-\n     //! Adds an encrypted key to the store, and saves it to disk.\n     bool AddCryptedKey(const CPubKey &vchPubKey, const std::vector<unsigned char> &vchCryptedSecret);\n     //! Adds an encrypted key to the store, without saving it to disk (used by LoadWallet)\n@@ -737,9 +723,6 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n \n     bool SetDefaultKey(const CPubKey &vchPubKey);\n \n-    //! change which version we're allowed to upgrade to (note that this does not immediately imply upgrading to that format)\n-    bool SetMaxVersion(int nVersion);\n-\n     //! get the current wallet format (the oldest client version guaranteed to understand this wallet)\n     int GetVersion() { LOCK(cs_wallet); return nWalletVersion; }\n \n@@ -752,385 +735,9 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n     //! Write down a specific wallet transaction\n     bool WriteTxToDisk(const CWalletTx& wtx);\n     \n-    /** \n-     * Address book entry changed.\n-     * @note called with lock cs_wallet held.\n-     */\n-    boost::signals2::signal<void (CWallet *wallet, const CTxDestination\n-            &address, const std::string &label, bool isMine,\n-            const std::string &purpose,\n-            ChangeType status)> NotifyAddressBookChanged;\n-\n-    /** \n-     * Wallet transaction added, removed or updated.\n-     * @note called with lock cs_wallet held.\n-     */\n-    boost::signals2::signal<void (CWallet *wallet, const uint256 &hashTx,\n-            ChangeType status)> NotifyTransactionChanged;\n-\n-    /** Show progress e.g. for rescan */\n-    boost::signals2::signal<void (const std::string &title, int nProgress)> ShowProgress;\n-\n-    /** Watch-only address added */\n-    boost::signals2::signal<void (bool fHaveWatchOnly)> NotifyWatchonlyChanged;\n-};\n-\n-/** A key allocated from the key pool. */\n-class CReserveKey\n-{\n-protected:\n-    CWallet* pwallet;\n-    int64_t nIndex;\n-    CPubKey vchPubKey;\n-public:\n-    CReserveKey(CWallet* pwalletIn)\n-    {\n-        nIndex = -1;\n-        pwallet = pwalletIn;\n-    }\n-\n-    ~CReserveKey()\n-    {\n-        ReturnKey();\n-    }\n-\n-    void ReturnKey();\n-    bool GetReservedKey(CPubKey &pubkey);\n-    void KeepKey();\n-};\n-\n-\n-typedef std::map<std::string, std::string> mapValue_t;\n-\n-\n-static void ReadOrderPos(int64_t& nOrderPos, mapValue_t& mapValue)\n-{\n-    if (!mapValue.count(\"n\"))\n-    {\n-        nOrderPos = -1; // TODO: calculate elsewhere\n-        return;\n-    }\n-    nOrderPos = atoi64(mapValue[\"n\"].c_str());\n-}\n-\n-\n-static void WriteOrderPos(const int64_t& nOrderPos, mapValue_t& mapValue)\n-{\n-    if (nOrderPos == -1)\n-        return;\n-    mapValue[\"n\"] = i64tostr(nOrderPos);\n-}\n-\n-struct COutputEntry\n-{\n-    CTxDestination destination;\n-    CAmount amount;\n-    int vout;\n-};\n-\n-/** A transaction with a merkle branch linking it to the block chain. */\n-class CMerkleTx : public CTransaction\n-{\n-private:\n-    int GetDepthInMainChainINTERNAL(const CBlockIndex* &pindexRet) const;\n-\n-public:\n-    uint256 hashBlock;\n-    std::vector<uint256> vMerkleBranch;\n-    int nIndex;\n-\n-    // memory only\n-    mutable bool fMerkleVerified;\n-\n-\n-    CMerkleTx()\n-    {\n-        Init();\n-    }\n-\n-    CMerkleTx(const CTransaction& txIn) : CTransaction(txIn)\n-    {\n-        Init();\n-    }\n-\n-    void Init()\n-    {\n-        hashBlock = uint256();\n-        nIndex = -1;\n-        fMerkleVerified = false;\n-    }\n-\n-    ADD_SERIALIZE_METHODS;\n-\n-    template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n-        READWRITE(*(CTransaction*)this);\n-        nVersion = this->nVersion;\n-        READWRITE(hashBlock);\n-        READWRITE(vMerkleBranch);\n-        READWRITE(nIndex);\n-    }\n-\n-    int SetMerkleBranch(const CBlock& block);\n-\n-\n-    /**\n-     * Return depth of transaction in blockchain:\n-     * -1  : not in blockchain, and not in memory pool (conflicted transaction)\n-     *  0  : in memory pool, waiting to be included in a block\n-     * >=1 : this many blocks deep in the main chain\n-     */\n-    int GetDepthInMainChain(const CBlockIndex* &pindexRet) const;\n-    int GetDepthInMainChain() const { const CBlockIndex *pindexRet; return GetDepthInMainChain(pindexRet); }\n-    bool IsInMainChain() const { const CBlockIndex *pindexRet; return GetDepthInMainChainINTERNAL(pindexRet) > 0; }\n-    int GetBlocksToMaturity() const;\n-    bool AcceptToMemoryPool(bool fLimitFree=true, bool fRejectInsaneFee=true);\n-};\n-\n-/** \n- * A transaction with a bunch of additional info that only the owner cares about.\n- * It includes any unrecorded transactions needed to link it back to the block chain.\n- */\n-class CWalletTx : public CMerkleTx\n-{\n-private:\n-    const CWallet* pwallet;\n-\n-public:\n-    mapValue_t mapValue;\n-    std::vector<std::pair<std::string, std::string> > vOrderForm;\n-    unsigned int fTimeReceivedIsTxTime;\n-    unsigned int nTimeReceived; //! time received by this node\n-    unsigned int nTimeSmart;\n-    char fFromMe;\n-    std::string strFromAccount;\n-    int64_t nOrderPos; //! position in ordered transaction list\n-\n-    // memory only\n-    mutable bool fDebitCached;\n-    mutable bool fCreditCached;\n-    mutable bool fImmatureCreditCached;\n-    mutable bool fAvailableCreditCached;\n-    mutable bool fWatchDebitCached;\n-    mutable bool fWatchCreditCached;\n-    mutable bool fImmatureWatchCreditCached;\n-    mutable bool fAvailableWatchCreditCached;\n-    mutable bool fChangeCached;\n-    mutable CAmount nDebitCached;\n-    mutable CAmount nCreditCached;\n-    mutable CAmount nImmatureCreditCached;\n-    mutable CAmount nAvailableCreditCached;\n-    mutable CAmount nWatchDebitCached;\n-    mutable CAmount nWatchCreditCached;\n-    mutable CAmount nImmatureWatchCreditCached;\n-    mutable CAmount nAvailableWatchCreditCached;\n-    mutable CAmount nChangeCached;\n-\n-    CWalletTx()\n-    {\n-        Init(NULL);\n-    }\n-\n-    CWalletTx(const CWallet* pwalletIn)\n-    {\n-        Init(pwalletIn);\n-    }\n-\n-    CWalletTx(const CWallet* pwalletIn, const CMerkleTx& txIn) : CMerkleTx(txIn)\n-    {\n-        Init(pwalletIn);\n-    }\n-\n-    CWalletTx(const CWallet* pwalletIn, const CTransaction& txIn) : CMerkleTx(txIn)\n-    {\n-        Init(pwalletIn);\n-    }\n-\n-    void Init(const CWallet* pwalletIn)\n-    {\n-        pwallet = pwalletIn;\n-        mapValue.clear();\n-        vOrderForm.clear();\n-        fTimeReceivedIsTxTime = false;\n-        nTimeReceived = 0;\n-        nTimeSmart = 0;\n-        fFromMe = false;\n-        strFromAccount.clear();\n-        fDebitCached = false;\n-        fCreditCached = false;\n-        fImmatureCreditCached = false;\n-        fAvailableCreditCached = false;\n-        fWatchDebitCached = false;\n-        fWatchCreditCached = false;\n-        fImmatureWatchCreditCached = false;\n-        fAvailableWatchCreditCached = false;\n-        fChangeCached = false;\n-        nDebitCached = 0;\n-        nCreditCached = 0;\n-        nImmatureCreditCached = 0;\n-        nAvailableCreditCached = 0;\n-        nWatchDebitCached = 0;\n-        nWatchCreditCached = 0;\n-        nAvailableWatchCreditCached = 0;\n-        nImmatureWatchCreditCached = 0;\n-        nChangeCached = 0;\n-        nOrderPos = -1;\n-    }\n-\n-    ADD_SERIALIZE_METHODS;\n-\n-    template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n-        if (ser_action.ForRead())\n-            Init(NULL);\n-        char fSpent = false;\n-\n-        if (!ser_action.ForRead())\n-        {\n-            mapValue[\"fromaccount\"] = strFromAccount;\n-\n-            WriteOrderPos(nOrderPos, mapValue);\n-\n-            if (nTimeSmart)\n-                mapValue[\"timesmart\"] = strprintf(\"%u\", nTimeSmart);\n-        }\n-\n-    static CFeeRate minTxFee;\n-    static CAmount GetMinimumFee(unsigned int nTxBytes, unsigned int nConfirmTarget, const CTxMemPool& pool);\n-\n-    bool NewKeyPool();\n-    bool TopUpKeyPool(unsigned int kpSize = 0);\n-    void ReserveKeyFromKeyPool(int64_t& nIndex, CKeyPool& keypool);\n-    void KeepKey(int64_t nIndex);\n-    void ReturnKey(int64_t nIndex);\n-    bool GetKeyFromPool(CPubKey &key);\n-    int64_t GetOldestKeyPoolTime();\n-    void GetAllReserveKeys(std::set<CKeyID>& setAddress) const;\n-\n-    std::set< std::set<CTxDestination> > GetAddressGroupings();\n-    std::map<CTxDestination, CAmount> GetAddressBalances();\n-\n-    std::set<CTxDestination> GetAccountAddresses(std::string strAccount) const;\n-\n-    isminetype IsMine(const CTxIn& txin) const;\n-    CAmount GetDebit(const CTxIn& txin, const isminefilter& filter) const;\n-    isminetype IsMine(const CTxOut& txout) const\n-    {\n-        return ::IsMine(*this, txout.scriptPubKey);\n-    }\n-    CAmount GetCredit(const CTxOut& txout, const isminefilter& filter) const\n-    {\n-        if (!MoneyRange(txout.nValue))\n-            throw std::runtime_error(\"CWallet::GetCredit(): value out of range\");\n-        return ((IsMine(txout) & filter) ? txout.nValue : 0);\n-    }\n-    bool IsChange(const CTxOut& txout) const;\n-    CAmount GetChange(const CTxOut& txout) const\n-    {\n-        if (!MoneyRange(txout.nValue))\n-            throw std::runtime_error(\"CWallet::GetChange(): value out of range\");\n-        return (IsChange(txout) ? txout.nValue : 0);\n-    }\n-    bool IsMine(const CTransaction& tx) const\n-    {\n-        BOOST_FOREACH(const CTxOut& txout, tx.vout)\n-            if (IsMine(txout))\n-                return true;\n-        return false;\n-    }\n-    /** should probably be renamed to IsRelevantToMe */\n-    bool IsFromMe(const CTransaction& tx) const\n-    {\n-        return (GetDebit(tx, ISMINE_ALL) > 0);\n-    }\n-    CAmount GetDebit(const CTransaction& tx, const isminefilter& filter) const\n-    {\n-        CAmount nDebit = 0;\n-        BOOST_FOREACH(const CTxIn& txin, tx.vin)\n-        {\n-            nDebit += GetDebit(txin, filter);\n-            if (!MoneyRange(nDebit))\n-                throw std::runtime_error(\"CWallet::GetDebit(): value out of range\");\n-        }\n-        return nDebit;\n-    }\n-    CAmount GetCredit(const CTransaction& tx, const isminefilter& filter) const\n-    {\n-        CAmount nCredit = 0;\n-        BOOST_FOREACH(const CTxOut& txout, tx.vout)\n-        {\n-            nCredit += GetCredit(txout, filter);\n-            if (!MoneyRange(nCredit))\n-                throw std::runtime_error(\"CWallet::GetCredit(): value out of range\");\n-        }\n-        return nCredit;\n-    }\n-    CAmount GetChange(const CTransaction& tx) const\n-    {\n-        CAmount nChange = 0;\n-        BOOST_FOREACH(const CTxOut& txout, tx.vout)\n-        {\n-            nChange += GetChange(txout);\n-            if (!MoneyRange(nChange))\n-                throw std::runtime_error(\"CWallet::GetChange(): value out of range\");\n-        }\n-        return nChange;\n-    }\n-    void SetBestChain(const CBlockLocator& loc);\n-\n-    DBErrors LoadWallet(bool& fFirstRunRet);\n-    DBErrors ZapWalletTx(std::vector<CWalletTx>& vWtx);\n-\n-    bool SetAddressBook(const CTxDestination& address, const std::string& strName, const std::string& purpose);\n-\n-    bool DelAddressBook(const CTxDestination& address);\n-\n-    void UpdatedTransaction(const uint256 &hashTx);\n-\n-    void Inventory(const uint256 &hash)\n-    {\n-        {\n-            LOCK(cs_wallet);\n-            std::map<uint256, int>::iterator mi = mapRequestCount.find(hash);\n-            if (mi != mapRequestCount.end())\n-                (*mi).second++;\n-        }\n-    }\n-\n-    unsigned int GetKeyPoolSize()\n-    {\n-        AssertLockHeld(cs_wallet); // setKeyPool\n-        return setKeyPool.size();\n-    }\n-\n-    bool SetDefaultKey(const CPubKey &vchPubKey);\n-\n-    void GetAmounts(std::list<COutputEntry>& listReceived,\n-                    std::list<COutputEntry>& listSent, CAmount& nFee, std::string& strSentAccount, const isminefilter& filter) const;\n-\n-    void GetAccountAmounts(const std::string& strAccount, CAmount& nReceived,\n-                           CAmount& nSent, CAmount& nFee, const isminefilter& filter) const;\n+    //! Create a backup of the wallet file\n+    bool BackupWallet(const std::string& strDest);\n     \n-    bool IsFromMe(const isminefilter& filter) const\n-    {\n-        return (GetDebit(filter) > 0);\n-    }\n-\n-    //! signify that a particular wallet feature is now used. this may change nWalletVersion and nWalletMaxVersion if those are lower\n-    bool SetMinVersion(enum WalletFeature, CWalletDB* pwalletdbIn = NULL, bool fExplicit = false);\n-\n-    //! change which version we're allowed to upgrade to (note that this does not immediately imply upgrading to that format)\n-    bool SetMaxVersion(int nVersion);\n-\n-    //! get the current wallet format (the oldest client version guaranteed to understand this wallet)\n-    int GetVersion() { LOCK(cs_wallet); return nWalletVersion; }\n-        \n-    int64_t GetTxTime() const;\n-    int GetRequestCount() const;\n-\n-    //! Get wallet transactions that conflict with given transaction (spend same outputs)\n-    std::set<uint256> GetConflicts(const uint256& txid) const;\n-\n     /** \n      * Address book entry changed.\n      * @note called with lock cs_wallet held.\n@@ -1178,7 +785,6 @@ class CReserveKey\n     void KeepKey();\n };\n \n-\n /** \n  * Account information.\n  * Stored in wallet with key \"acc\"+string account name."
      },
      {
        "sha": "fd2a6bbbd05caddf29b938ccf6d457537c73920e",
        "filename": "src/walletdb.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 63,
        "changes": 63,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bde59e1974640d9d83e33ca61bbc637b01eff7a1/src/walletdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bde59e1974640d9d83e33ca61bbc637b01eff7a1/src/walletdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/walletdb.cpp?ref=bde59e1974640d9d83e33ca61bbc637b01eff7a1",
        "patch": "@@ -148,11 +148,6 @@ bool CWalletDB::ErasePool(int64_t nPool)\n     return Erase(std::make_pair(std::string(\"pool\"), nPool));\n }\n \n-bool CWalletDB::WriteMinVersion(int nVersion)\n-{\n-    return Write(std::string(\"minversion\"), nVersion);\n-}\n-\n bool CWalletDB::ReadAccount(const string& strAccount, CAccount& account)\n {\n     account.SetNull();\n@@ -570,14 +565,6 @@ DBErrors CWalletDB::LoadWallet(CWallet* pwallet)\n     \n     try {\n         LOCK(pwallet->cs_wallet);\n-        int nMinVersion = 0;\n-        if (Read((string)\"minversion\", nMinVersion))\n-        {\n-            if (nMinVersion > CLIENT_VERSION)\n-                return DB_TOO_NEW;\n-            pwallet->LoadMinVersion(nMinVersion);\n-        }\n-\n         for (CWalletDB::const_iterator it = begin(); it != end(); it++)\n         {\n             // Read next record\n@@ -649,14 +636,6 @@ DBErrors CWalletDB::FindWalletTx(CWallet* pwallet, vector<uint256>& vTxHash, vec\n \n     try {\n         LOCK(pwallet->cs_wallet);\n-        int nMinVersion = 0;\n-        if (Read((string)\"minversion\", nMinVersion))\n-        {\n-            if (nMinVersion > CLIENT_VERSION)\n-                return DB_TOO_NEW;\n-            pwallet->LoadMinVersion(nMinVersion);\n-        }\n-\n         for (CWalletDB::const_iterator it = begin(); it != end(); it++)\n         {\n             // Read next record\n@@ -735,48 +714,6 @@ DBErrors CWalletDB::RewriteAndReplace(const string& walletFile)\n     return DB_LOAD_OK;\n }\n \n-bool BackupWallet(const CWallet& wallet, const string& strDest)\n-{\n-    /*\n-    if (!wallet.fFileBacked)\n-        return false;\n-    while (true)\n-    {\n-        {\n-            LOCK(bitdb.cs_db);\n-            if (!bitdb.mapFileUseCount.count(wallet.strWalletFile) || bitdb.mapFileUseCount[wallet.strWalletFile] == 0)\n-            {\n-                // Flush log data to the dat file\n-                bitdb.CloseDb(wallet.strWalletFile);\n-                bitdb.CheckpointLSN(wallet.strWalletFile);\n-                bitdb.mapFileUseCount.erase(wallet.strWalletFile);\n-\n-                // Copy wallet.dat\n-                boost::filesystem::path pathSrc = GetDataDir() / wallet.strWalletFile;\n-                boost::filesystem::path pathDest(strDest);\n-                if (boost::filesystem::is_directory(pathDest))\n-                    pathDest /= wallet.strWalletFile;\n-\n-                try {\n-#if BOOST_VERSION >= 104000\n-                    boost::filesystem::copy_file(pathSrc, pathDest, boost::filesystem::copy_option::overwrite_if_exists);\n-#else\n-                    boost::filesystem::copy_file(pathSrc, pathDest);\n-#endif\n-                    LogPrintf(\"copied wallet.dat to %s\\n\", pathDest.string());\n-                    return true;\n-                } catch (const boost::filesystem::filesystem_error& e) {\n-                    LogPrintf(\"error copying wallet.dat to %s - %s\\n\", pathDest.string(), e.what());\n-                    return false;\n-                }\n-            }\n-        }\n-        MilliSleep(100);\n-    }\n-     */\n-    return false;\n-}\n-\n //\n // Try to (very carefully!) recover wallet.dat if there is a problem.\n //"
      },
      {
        "sha": "1a1eedd46e2eafe5cf25eb611d8e2ad989476589",
        "filename": "src/walletdb.h",
        "status": "modified",
        "additions": 0,
        "deletions": 4,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bde59e1974640d9d83e33ca61bbc637b01eff7a1/src/walletdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bde59e1974640d9d83e33ca61bbc637b01eff7a1/src/walletdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/walletdb.h?ref=bde59e1974640d9d83e33ca61bbc637b01eff7a1",
        "patch": "@@ -110,8 +110,6 @@ class CWalletDB : public CLogDB\n     bool WritePool(int64_t nPool, const CKeyPool& keypool);\n     bool ErasePool(int64_t nPool);\n \n-    bool WriteMinVersion(int nVersion);\n-\n     bool ReadAccount(const std::string& strAccount, CAccount& account);\n     bool WriteAccount(const std::string& strAccount, const CAccount& account);\n \n@@ -142,6 +140,4 @@ class CWalletDB : public CLogDB\n     bool WriteAccountingEntry(const uint64_t nAccEntryNum, const CAccountingEntry& acentry);\n };\n \n-bool BackupWallet(const CWallet& wallet, const std::string& strDest);\n-\n #endif // BITCOIN_WALLETDB_H"
      }
    ]
  }
]