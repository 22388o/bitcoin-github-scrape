[
  {
    "sha": "5350cd85fb39cc46e696de969218b9048150a1ba",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1MzUwY2Q4NWZiMzljYzQ2ZTY5NmRlOTY5MjE4YjkwNDgxNTBhMWJh",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2019-07-30T21:53:05Z"
      },
      "committer": {
        "name": "practicalswift",
        "email": "practicalswift@users.noreply.github.com",
        "date": "2019-10-23T11:53:23Z"
      },
      "message": "Abstract out some of the descriptor Span-parsing helpers",
      "tree": {
        "sha": "06aa8bacc3912a394400c6ff3f432315e74b9cca",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/06aa8bacc3912a394400c6ff3f432315e74b9cca"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5350cd85fb39cc46e696de969218b9048150a1ba",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5350cd85fb39cc46e696de969218b9048150a1ba",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5350cd85fb39cc46e696de969218b9048150a1ba",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5350cd85fb39cc46e696de969218b9048150a1ba/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a884b32854965a6990ef8d8ecccccd91736e0dca",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a884b32854965a6990ef8d8ecccccd91736e0dca",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a884b32854965a6990ef8d8ecccccd91736e0dca"
      }
    ],
    "stats": {
      "total": 17,
      "additions": 17,
      "deletions": 0
    },
    "files": [
      {
        "sha": "42567a20534c6c367df8f4b2d48b2b6a768ab667",
        "filename": "src/script/descriptor.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 0,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5350cd85fb39cc46e696de969218b9048150a1ba/src/script/descriptor.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5350cd85fb39cc46e696de969218b9048150a1ba/src/script/descriptor.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/descriptor.cpp?ref=5350cd85fb39cc46e696de969218b9048150a1ba",
        "patch": "@@ -633,6 +633,23 @@ enum class ParseScriptContext {\n     P2WSH,\n };\n \n+/** Split a string on every instance of sep, returning a vector. */\n+std::vector<Span<const char>> Split(const Span<const char>& sp, char sep)\n+{\n+    std::vector<Span<const char>> ret;\n+    auto it = sp.begin();\n+    auto start = it;\n+    while (it != sp.end()) {\n+        if (*it == sep) {\n+            ret.emplace_back(start, it);\n+            start = it + 1;\n+        }\n+        ++it;\n+    }\n+    ret.emplace_back(start, it);\n+    return ret;\n+}\n+\n /** Parse a key path, being passed a split list of elements (the first element is ignored). */\n NODISCARD bool ParseKeyPath(const std::vector<Span<const char>>& split, KeyPath& out, std::string& error)\n {"
      }
    ]
  },
  {
    "sha": "af31da39e7eca329dbf4e1a4c210374b08fb59e6",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphZjMxZGEzOWU3ZWNhMzI5ZGJmNGUxYTRjMjEwMzc0YjA4ZmI1OWU2",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2019-08-28T22:12:51Z"
      },
      "committer": {
        "name": "practicalswift",
        "email": "practicalswift@users.noreply.github.com",
        "date": "2019-10-23T11:54:49Z"
      },
      "message": "Add some general std::vector utility functions\n\nAdded are:\n\n* Vector(arg1,arg2,arg3,...) constructs a vector with the specified\n  arguments as elements. The vector's type is derived from the\n  arguments. If some of the arguments are rvalue references, they\n  will be moved into place rather than copied (which can't be achieved\n  using list initialization).\n\n* Cat(vector1,vector2) returns a concatenation of the two vectors,\n  efficiently moving elements when relevant.\n\nVector generalizes (and replaces) the Singleton function in\nsrc/descriptor.cpp, and Cat replaces the Cat function in bech32.cpp",
      "tree": {
        "sha": "7c3d8f601eabb808641d4083df5d9bbbc8acdadd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7c3d8f601eabb808641d4083df5d9bbbc8acdadd"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/af31da39e7eca329dbf4e1a4c210374b08fb59e6",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/af31da39e7eca329dbf4e1a4c210374b08fb59e6",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/af31da39e7eca329dbf4e1a4c210374b08fb59e6",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/af31da39e7eca329dbf4e1a4c210374b08fb59e6/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5350cd85fb39cc46e696de969218b9048150a1ba",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5350cd85fb39cc46e696de969218b9048150a1ba",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5350cd85fb39cc46e696de969218b9048150a1ba"
      }
    ],
    "stats": {
      "total": 13,
      "additions": 11,
      "deletions": 2
    },
    "files": [
      {
        "sha": "f0d24ee18ac9dd3efe7e21c79b47be61395f21b6",
        "filename": "src/util/vector.h",
        "status": "modified",
        "additions": 11,
        "deletions": 2,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/af31da39e7eca329dbf4e1a4c210374b08fb59e6/src/util/vector.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/af31da39e7eca329dbf4e1a4c210374b08fb59e6/src/util/vector.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/vector.h?ref=af31da39e7eca329dbf4e1a4c210374b08fb59e6",
        "patch": "@@ -9,6 +9,16 @@\n #include <type_traits>\n #include <vector>\n \n+/** Emplace back multiple elements to a container. */\n+template<typename V>\n+inline void EmplaceBackMany(V& vec) {}\n+template<typename V, typename Arg, typename... Args>\n+inline void EmplaceBackMany(V& vec, Arg&& arg, Args&&... args)\n+{\n+    vec.emplace_back(std::forward<Arg>(arg));\n+    EmplaceBackMany(vec, std::forward<Args>(args)...);\n+}\n+\n /** Construct a vector with the specified elements.\n  *\n  * This is preferable over the list initializing constructor of std::vector:\n@@ -21,8 +31,7 @@ inline std::vector<typename std::common_type<Args...>::type> Vector(Args&&... ar\n {\n     std::vector<typename std::common_type<Args...>::type> ret;\n     ret.reserve(sizeof...(args));\n-    // The line below uses the trick from https://www.experts-exchange.com/articles/32502/None-recursive-variadic-templates-with-std-initializer-list.html\n-    (void)std::initializer_list<int>{(ret.emplace_back(std::forward<Args>(args)), 0)...};\n+    EmplaceBackMany(ret, std::forward<Args>(args)...);\n     return ret;\n }\n "
      }
    ]
  },
  {
    "sha": "57a6c0e853b84b72a7d39cbd37834fcf6416ac40",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1N2E2YzBlODUzYjg0YjcyYTdkMzljYmQzNzgzNGZjZjY0MTZhYzQw",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2019-08-28T23:23:03Z"
      },
      "committer": {
        "name": "practicalswift",
        "email": "practicalswift@users.noreply.github.com",
        "date": "2019-10-23T11:54:49Z"
      },
      "message": "Miniscript: type system, script creation, text notation, tests",
      "tree": {
        "sha": "5b01dc54fcaabb58a6416fb9e9cacb59d3122cd6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5b01dc54fcaabb58a6416fb9e9cacb59d3122cd6"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/57a6c0e853b84b72a7d39cbd37834fcf6416ac40",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/57a6c0e853b84b72a7d39cbd37834fcf6416ac40",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/57a6c0e853b84b72a7d39cbd37834fcf6416ac40",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/57a6c0e853b84b72a7d39cbd37834fcf6416ac40/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "af31da39e7eca329dbf4e1a4c210374b08fb59e6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/af31da39e7eca329dbf4e1a4c210374b08fb59e6",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/af31da39e7eca329dbf4e1a4c210374b08fb59e6"
      }
    ],
    "stats": {
      "total": 1167,
      "additions": 1167,
      "deletions": 0
    },
    "files": [
      {
        "sha": "3726e6b8c218b4a6d46592ef9d90a27210b88756",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/57a6c0e853b84b72a7d39cbd37834fcf6416ac40/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/57a6c0e853b84b72a7d39cbd37834fcf6416ac40/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=57a6c0e853b84b72a7d39cbd37834fcf6416ac40",
        "patch": "@@ -184,6 +184,7 @@ BITCOIN_CORE_H = \\\n   scheduler.h \\\n   script/descriptor.h \\\n   script/keyorigin.h \\\n+  script/miniscript.h \\\n   script/sigcache.h \\\n   script/sign.h \\\n   script/signingprovider.h \\\n@@ -471,6 +472,7 @@ libbitcoin_common_a_SOURCES = \\\n   rpc/util.cpp \\\n   scheduler.cpp \\\n   script/descriptor.cpp \\\n+  script/miniscript.cpp \\\n   script/sign.cpp \\\n   script/signingprovider.cpp \\\n   script/standard.cpp \\"
      },
      {
        "sha": "7dc0c2b0a72964a9bda64401b0e48bdf6ddb63c9",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/57a6c0e853b84b72a7d39cbd37834fcf6416ac40/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/57a6c0e853b84b72a7d39cbd37834fcf6416ac40/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=57a6c0e853b84b72a7d39cbd37834fcf6416ac40",
        "patch": "@@ -116,6 +116,7 @@ BITCOIN_TESTS =\\\n   test/dbwrapper_tests.cpp \\\n   test/validation_tests.cpp \\\n   test/mempool_tests.cpp \\\n+  test/miniscript_tests.cpp \\\n   test/merkle_tests.cpp \\\n   test/merkleblock_tests.cpp \\\n   test/miner_tests.cpp \\"
      },
      {
        "sha": "4011fc6fdea51a96dd8d1bff24333f3924dfebbf",
        "filename": "src/script/miniscript.cpp",
        "status": "added",
        "additions": 234,
        "deletions": 0,
        "changes": 234,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/57a6c0e853b84b72a7d39cbd37834fcf6416ac40/src/script/miniscript.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/57a6c0e853b84b72a7d39cbd37834fcf6416ac40/src/script/miniscript.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/miniscript.cpp?ref=57a6c0e853b84b72a7d39cbd37834fcf6416ac40",
        "patch": "@@ -0,0 +1,234 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <string>\n+#include <vector>\n+#include <script/script.h>\n+#include <script/miniscript.h>\n+\n+#include <assert.h>\n+\n+namespace miniscript {\n+namespace internal {\n+\n+Type SanitizeType(Type e) {\n+    int num_types = (e << \"K\"_mst) + (e << \"V\"_mst) + (e << \"B\"_mst) + (e << \"W\"_mst);\n+    if (num_types == 0) return \"\"_mst; // No valid type, don't care about the rest\n+    assert(num_types == 1); // K, V, B, W all conflict with each other\n+    bool ok = // Work around a GCC 4.8 bug that breaks user-defined literals in macro calls.\n+        (!(e << \"z\"_mst) || !(e << \"o\"_mst)) && // z conflicts with o\n+        (!(e << \"n\"_mst) || !(e << \"z\"_mst)) && // n conflicts with z\n+        (!(e << \"V\"_mst) || !(e << \"d\"_mst)) && // V conflicts with d\n+        (!(e << \"K\"_mst) ||  (e << \"u\"_mst)) && // K implies u\n+        (!(e << \"V\"_mst) || !(e << \"u\"_mst)) && // V conflicts with u\n+        (!(e << \"e\"_mst) || !(e << \"f\"_mst)) && // e conflicts with f\n+        (!(e << \"e\"_mst) ||  (e << \"d\"_mst)) && // e implies d\n+        (!(e << \"V\"_mst) || !(e << \"e\"_mst)) && // V conflicts with e\n+        (!(e << \"d\"_mst) || !(e << \"f\"_mst)) && // d conflicts with f\n+        (!(e << \"V\"_mst) ||  (e << \"f\"_mst)) && // V implies f\n+        (!(e << \"K\"_mst) ||  (e << \"s\"_mst)) && // K implies s\n+        (!(e << \"z\"_mst) ||  (e << \"m\"_mst)); // z implies m\n+    assert(ok);\n+    return e;\n+}\n+\n+Type ComputeType(NodeType nodetype, Type x, Type y, Type z, const std::vector<Type>& sub_types, uint32_t k, size_t data_size, size_t n_subs, size_t n_keys) {\n+    // Sanity check on data\n+    if (nodetype == NodeType::SHA256 || nodetype == NodeType::HASH256) {\n+        assert(data_size == 32);\n+    } else if (nodetype == NodeType::RIPEMD160 || nodetype == NodeType::HASH160) {\n+        assert(data_size == 20);\n+    } else {\n+        assert(data_size == 0);\n+    }\n+    // Sanity check on k\n+    if (nodetype == NodeType::OLDER || nodetype == NodeType::AFTER) {\n+        assert(k >= 1 && k < 0x80000000UL);\n+    } else if (nodetype == NodeType::THRESH_M) {\n+        assert(k >= 1 && k <= n_keys);\n+    } else if (nodetype == NodeType::THRESH) {\n+        assert(k > 1 && k < n_subs);\n+    } else {\n+        assert(k == 0);\n+    }\n+    // Sanity check on subs\n+    if (nodetype == NodeType::AND_V || nodetype == NodeType::AND_B || nodetype == NodeType::OR_B ||\n+        nodetype == NodeType::OR_C || nodetype == NodeType::OR_I || nodetype == NodeType::OR_D) {\n+        assert(n_subs == 2);\n+    } else if (nodetype == NodeType::ANDOR) {\n+        assert(n_subs == 3);\n+    } else if (nodetype == NodeType::WRAP_A || nodetype == NodeType::WRAP_S || nodetype == NodeType::WRAP_C ||\n+               nodetype == NodeType::WRAP_D || nodetype == NodeType::WRAP_V || nodetype == NodeType::WRAP_J ||\n+               nodetype == NodeType::WRAP_N) {\n+        assert(n_subs == 1);\n+    } else if (nodetype != NodeType::THRESH) {\n+        assert(n_subs == 0);\n+    }\n+    // Sanity check on keys\n+    if (nodetype == NodeType::PK || nodetype == NodeType::PK_H) {\n+        assert(n_keys == 1);\n+    } else if (nodetype == NodeType::THRESH_M) {\n+        assert(n_keys >= 1 && n_keys <= 20);\n+    } else {\n+        assert(n_keys == 0);\n+    }\n+\n+    // Below is the per-nodetype logic for computing the expression types.\n+    // It heavily relies on Type's << operator (where \"X << a_mst\" means\n+    // \"X has all properties listed in a\").\n+    switch (nodetype) {\n+        case NodeType::PK: return \"Konudemsx\"_mst;\n+        case NodeType::PK_H: return \"Knudemsx\"_mst;\n+        case NodeType::OLDER: return \"Bzfmx\"_mst;\n+        case NodeType::AFTER: return \"Bzfmx\"_mst;\n+        case NodeType::SHA256: return \"Bonudm\"_mst;\n+        case NodeType::RIPEMD160: return \"Bonudm\"_mst;\n+        case NodeType::HASH256: return \"Bonudm\"_mst;\n+        case NodeType::HASH160: return \"Bonudm\"_mst;\n+        case NodeType::JUST_1: return \"Bzufmx\"_mst;\n+        case NodeType::JUST_0: return \"Bzudemsx\"_mst;\n+        case NodeType::WRAP_A: return\n+            \"W\"_mst.If(x << \"B\"_mst) | // W=B_x\n+            (x & \"udfems\"_mst) | // u=u_x, d=d_x, f=f_x, e=e_x, m=m_x, s=s_x\n+            \"x\"_mst; // x\n+        case NodeType::WRAP_S: return\n+            \"W\"_mst.If(x << \"Bo\"_mst) | // W=B_x*o_x\n+            (x & \"udfemsx\"_mst); // u=u_x, d=d_x, f=f_x, e=e_x, m=m_x, s=s_x, x=x_x\n+        case NodeType::WRAP_C: return\n+            \"B\"_mst.If(x << \"K\"_mst) | // B=K_x\n+             (x & \"ondfem\"_mst) | // o=o_x, n=n_x, d=d_x, f=f_x, e=e_x, m=m_x\n+             \"us\"_mst; // u, s\n+        case NodeType::WRAP_D: return\n+            \"B\"_mst.If(x << \"Vz\"_mst) | // B=V_x*z_x\n+            \"o\"_mst.If(x << \"z\"_mst) | // o=z_x\n+            \"e\"_mst.If(x << \"f\"_mst) | // e=f_x\n+            (x & \"ms\"_mst) | // m=m_x, s=s_x\n+            \"nudx\"_mst; // n, u, d, x\n+        case NodeType::WRAP_V: return\n+            \"V\"_mst.If(x << \"B\"_mst) | // V=B_x\n+            (x & \"zonms\"_mst) | // z=z_x, o=o_x, n=n_x, m=m_x, s=s_x\n+            \"fx\"_mst; // f, x\n+        case NodeType::WRAP_J: return\n+            \"B\"_mst.If(x << \"Bn\"_mst) | // B=B_x*n_x\n+            \"e\"_mst.If(x << \"f\"_mst) | // e=f_x\n+            (x & \"oums\"_mst) | // o=o_x, u=u_x, m=m_x, s=s_x\n+            \"ndx\"_mst; // n, d, x\n+        case NodeType::WRAP_N: return\n+            (x & \"Bzondfems\"_mst) | // B=B_x, z=z_x, o=o_x, n=n_x, d=d_x, f=f_x, e=e_x, m=m_x, s=s_x\n+            \"ux\"_mst; // u, x\n+        case NodeType::AND_V: return\n+            (y & \"KVB\"_mst).If(x << \"V\"_mst) | // B=V_x*B_y, V=V_x*V_y, K=V_x*K_y\n+            (x & \"n\"_mst) | (y & \"n\"_mst).If(x << \"z\"_mst) | // n=n_x+z_x*n_y\n+            ((x | y) & \"o\"_mst).If((x | y) << \"z\"_mst) | // o=o_x*z_y+z_x*o_y\n+            (x & y & \"dmz\"_mst) | // d=d_x*d_y, m=m_x*m_y, z=z_x*z_y\n+            ((x | y) & \"s\"_mst) | // s=s_x+s_y\n+            \"f\"_mst.If((y << \"f\"_mst) || (x << \"s\"_mst)) | // f=f_y+s_x\n+            (y & \"ux\"_mst); // u=u_y, x=x_y\n+        case NodeType::AND_B: return\n+            (x & \"B\"_mst).If(y << \"W\"_mst) | // B=B_x*W_y\n+            ((x | y) & \"o\"_mst).If((x | y) << \"z\"_mst) | // o=o_x*z_y+z_x*o_y\n+            (x & \"n\"_mst) | (y & \"n\"_mst).If(x << \"z\"_mst) | // n=n_x+z_x*n_y\n+            (x & y & \"e\"_mst).If((x & y) << \"s\"_mst) | // e=e_x*e_y*s_x*s_y\n+            (x & y & \"dzm\"_mst) | // d=d_x*d_y, z=z_x*z_y, m=m_x*m_y\n+            \"f\"_mst.If(((x & y) << \"f\"_mst) || (x << \"sf\"_mst) || (y << \"sf\"_mst)) | // f=f_x*f_y + f_x*s_x + f_y*s_y\n+            ((x | y) & \"s\"_mst) | // s=s_x+s_y\n+            \"ux\"_mst; // u, x\n+        case NodeType::OR_B: return\n+            \"B\"_mst.If(x << \"Bd\"_mst && y << \"Wd\"_mst) | // B=B_x*d_x*W_x*d_y\n+            ((x | y) & \"o\"_mst).If((x | y) << \"z\"_mst) | // o=o_x*z_y+z_x*o_y\n+            (x & y & \"m\"_mst).If((x | y) << \"s\"_mst && (x & y) << \"e\"_mst) | // m=m_x*m_y*e_x*e_y*(s_x+s_y)\n+            (x & y & \"zse\"_mst) | // z=z_x*z_y, s=s_x*s_y, e=e_x*e_y\n+            \"dux\"_mst; // d, u, x\n+        case NodeType::OR_D: return\n+            (y & \"B\"_mst).If(x << \"Bdu\"_mst) | // B=B_y*B_x*d_x*u_x\n+            (x & \"o\"_mst).If(y << \"z\"_mst) | // o=o_x*z_y\n+            (x & y & \"m\"_mst).If(x << \"e\"_mst && (x | y) << \"s\"_mst) | // m=m_x*m_y*e_x*(s_x+s_y)\n+            (x & y & \"zes\"_mst) | // z=z_x*z_y, e=e_x*e_y, s=s_x*s_y\n+            (y & \"ufd\"_mst) | // u=u_y, f=f_y, d=d_y\n+            \"x\"_mst; // x\n+        case NodeType::OR_C: return\n+            (y & \"V\"_mst).If(x << \"Bdu\"_mst) | // V=V_y*B_x*u_x*d_x\n+            (x & \"o\"_mst).If(y << \"z\"_mst) | // o=o_x*z_y\n+            (x & y & \"m\"_mst).If(x << \"e\"_mst && (x | y) << \"s\"_mst) | // m=m_x*m_y*e_x*(s_x*s_y)\n+            (x & y & \"zs\"_mst) | // z=z_x*z_y, s=s_x*s_y\n+            \"fx\"_mst; // f, x\n+        case NodeType::OR_I: return\n+            (x & y & \"VBKufs\"_mst) | // V=V_x*V_y, B=B_x*B_y, K=K_x*K_y, u=u_x*u_y, f=f_x*f_y, s=s_x*s_y\n+            \"o\"_mst.If((x & y) << \"z\"_mst) | // o=z_x*z_y\n+            ((x | y) & \"e\"_mst).If((x | y) << \"f\"_mst) | // e=e_x*f_y+f_x*e_y\n+            (x & y & \"m\"_mst).If((x | y) << \"s\"_mst) | // m=m_x*m_y*(s_x+s_y)\n+            ((x | y) & \"d\"_mst) | // d=d_x+d_y\n+            \"x\"_mst; // x\n+        case NodeType::ANDOR: return\n+            (y & z & \"BKV\"_mst).If(x << \"Bdu\"_mst) | // B=B_x*d_x*u_x*B_y*B_z, K=B_x*d_x*u_x*K_y*K_z, V=B_x*d_x*u_x*V_y*V_z\n+            (x & y & z & \"z\"_mst) | // z=z_x*z_y*z_z\n+            ((x | (y & z)) & \"o\"_mst).If((x | (y & z)) << \"z\"_mst) | // o=o_x*z_y*z_z+z_x+o_y*o_z\n+            (y & z & \"u\"_mst) | // f=f_y*f_z, u=u_y*u_z\n+            (z & \"f\"_mst).If((x << \"s\"_mst) || (y << \"f\"_mst)) |\n+            (z & \"d\"_mst) | // d=d_x\n+            (x & z & \"e\"_mst).If(x << \"s\"_mst || y << \"f\"_mst) | // e=e_x*e_z*(s_x+s_y)\n+            (x & y & z & \"m\"_mst).If(x << \"e\"_mst && (x | y | z) << \"s\"_mst) | // m=m_x*m_y*m_z*e_x*(s_x+s_y+s_z)\n+            (z & (x | y) & \"s\"_mst) | // s=s_z*(s_x+s_y)\n+            \"x\"_mst; // x\n+        case NodeType::THRESH_M: return \"Bnudems\"_mst;\n+        case NodeType::THRESH: {\n+            bool all_e = true;\n+            bool all_m = true;\n+            uint32_t args = 0;\n+            uint32_t num_s = 0;\n+            for (size_t i = 0; i < sub_types.size(); ++i) {\n+                Type t = sub_types[i];\n+                if (!(t << (i ? \"Wdu\"_mst : \"Bdu\"_mst))) return \"\"_mst; // Require Bdu, Wdu, Wdu, ...\n+                if (!(t << \"e\"_mst)) all_e = false;\n+                if (!(t << \"m\"_mst)) all_m = false;\n+                if (t << \"s\"_mst) num_s += 1;\n+                args += (t << \"z\"_mst) ? 0 : (t << \"o\"_mst) ? 1 : 2;\n+            }\n+            return \"Bdu\"_mst |\n+                   \"z\"_mst.If(args == 0) | // z=all z\n+                   \"o\"_mst.If(args == 1) | // o=all z except one o\n+                   \"e\"_mst.If(all_e && num_s == n_subs) | // e=all e and all s\n+                   \"m\"_mst.If(all_e && all_m && num_s >= n_subs - k) | // m=all e, >=(n-k) s\n+                   \"s\"_mst.If(num_s >= n_subs - k + 1); // s= >=(n-k+1) s\n+            }\n+    }\n+    assert(false);\n+    return \"\"_mst;\n+}\n+\n+size_t ComputeScriptLen(NodeType nodetype, Type sub0typ, size_t subsize, uint32_t k, size_t n_subs, size_t n_keys) {\n+    switch (nodetype) {\n+        case NodeType::PK: return subsize + 34;\n+        case NodeType::PK_H: return subsize + 3 + 21;\n+        case NodeType::OLDER: return subsize + 1 + (CScript() << k).size();\n+        case NodeType::AFTER: return subsize + 1 + (CScript() << k).size();\n+        case NodeType::HASH256: return subsize + 4 + 2 + 33;\n+        case NodeType::HASH160: return subsize + 4 + 2 + 21;\n+        case NodeType::SHA256: return subsize + 4 + 2 + 33;\n+        case NodeType::RIPEMD160: return subsize + 4 + 2 + 21;\n+        case NodeType::WRAP_A: return subsize + 2;\n+        case NodeType::WRAP_S: return subsize + 1;\n+        case NodeType::WRAP_C: return subsize + 1;\n+        case NodeType::WRAP_D: return subsize + 3;\n+        case NodeType::WRAP_V: return subsize + (sub0typ << \"x\"_mst);\n+        case NodeType::WRAP_J: return subsize + 4;\n+        case NodeType::WRAP_N: return subsize + 1;\n+        case NodeType::JUST_1: return 1;\n+        case NodeType::JUST_0: return 1;\n+        case NodeType::AND_V: return subsize;\n+        case NodeType::AND_B: return subsize + 1;\n+        case NodeType::OR_B: return subsize + 1;\n+        case NodeType::OR_D: return subsize + 3;\n+        case NodeType::OR_C: return subsize + 2;\n+        case NodeType::OR_I: return subsize + 3;\n+        case NodeType::ANDOR: return subsize + 3;\n+        case NodeType::THRESH: return subsize + n_subs + 1;\n+        case NodeType::THRESH_M: return subsize + 3 + (n_keys > 16) + (k > 16) + 34 * n_keys;\n+    }\n+    assert(false);\n+    return 0;\n+}\n+\n+} // namespace internal\n+} // namespace miniscript"
      },
      {
        "sha": "4089fd5f17f9fffc7bed9dfaf1a154e2cd60c370",
        "filename": "src/script/miniscript.h",
        "status": "added",
        "additions": 604,
        "deletions": 0,
        "changes": 604,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/57a6c0e853b84b72a7d39cbd37834fcf6416ac40/src/script/miniscript.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/57a6c0e853b84b72a7d39cbd37834fcf6416ac40/src/script/miniscript.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/miniscript.h?ref=57a6c0e853b84b72a7d39cbd37834fcf6416ac40",
        "patch": "@@ -0,0 +1,604 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SCRIPT_MINISCRIPT_H\n+#define BITCOIN_SCRIPT_MINISCRIPT_H\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+#include <stdlib.h>\n+#include <assert.h>\n+\n+#include <script/script.h>\n+#include <span.h>\n+#include <util/spanparsing.h>\n+#include <util/strencodings.h>\n+#include <util/vector.h>\n+\n+namespace miniscript {\n+\n+/** This type encapsulates the miniscript type system properties.\n+ *\n+ * Every miniscript expression is one of 4 basic types, and additionally has\n+ * a number of boolean type properties.\n+ *\n+ * The basic types are:\n+ * - \"B\" Base:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - When satisfied, pushes a nonzero value of up to 4 bytes onto the stack.\n+ *   - When dissatisfied, pushes a 0 onto the stack.\n+ *   - This is used for most expressions, and required for the top level one.\n+ *   - For example: older(n) = <n> OP_CHECKSEQUENCEVERIFY.\n+ * - \"V\" Verify:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - When satisfactied, pushes nothing.\n+ *   - Cannot be dissatisfied.\n+ *   - This is obtained by adding an OP_VERIFY to a B, modifying the last opcode\n+ *     of a B to its -VERIFY version (only for OP_CHECKSIG, OP_CHECKSIGVERIFY\n+ *     and OP_EQUAL), or using IFs where both branches are also Vs.\n+ *   - For example vc:pk(key) = <key> OP_CHECKSIGVERIFY\n+ * - \"K\" Key:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - Becomes a B when followed by OP_CHECKSIG.\n+ *   - Always pushes a public key onto the stack, for which a signature is to be\n+ *     provided to satisfy the expression.\n+ *   - For example pk_h(key) = OP_DUP OP_HASH160 <Hash160(key)> OP_EQUALVERIFY\n+ * - \"W\" Wrapped:\n+ *   - Takes its input from one below the top of the stack.\n+ *   - When satisfied, pushes a nonzero value (like B) on top of the stack, or one below.\n+ *   - When dissatisfied, pushes 0 op top of the stack or one below.\n+ *   - Is always \"OP_SWAP [B]\" or \"OP_TOALTSTACK [B] OP_FROMALTSTACK\".\n+ *   - For example sc:pk(key) = OP_SWAP <key> OP_CHECKSIG\n+ *\n+ * There a type properties that help reasoning about correctness:\n+ * - \"z\" Zero-arg:\n+ *   - Is known to always consume exactly 0 stack elements.\n+ *   - For example after(n) = <n> OP_CHECKLOCKTIMEVERIFY\n+ * - \"o\" One-arg:\n+ *   - Is known to always consume exactly 1 stack element.\n+ *   - Conflicts with property 'z'\n+ *   - For example sha256(hash) = OP_SIZE 32 OP_EQUALVERIFY OP_SHA256 <hash> OP_EQUAL\n+ * - \"n\" Nonzero:\n+ *   - For every way this expression can be satisfied, a satisfaction exists that never needs\n+ *     a zero top stack element.\n+ *   - Conflicts with property 'z' and with type 'W'.\n+ * - \"d\" Dissatisfiable:\n+ *   - There is an easy way to construct a dissatisfaction for this expression.\n+ *   - Conflicts with type 'V'.\n+ * - \"u\" Unit:\n+ *   - In case of satisfaction, an exact 1 is put on the stack (rather than just nonzero).\n+ *   - Conflicts with type 'V'.\n+ *\n+ * Additional type properties help reasoning about nonmalleability:\n+ * - \"e\" Expression:\n+ *   - This implies property 'd', but the dissatisfaction is nonmalleable.\n+ *   - This generally requires 'e' for all subexpressions which are invoked for that\n+ *     dissatifsaction, and property 'f' for the unexecuted subexpressions in that case.\n+ *   - Conflicts with type 'V'.\n+ * - \"f\" Forced:\n+ *   - Dissatisfactions (if any) for this expression always involve at least one signature.\n+ *   - Is always true for type 'V'.\n+ * - \"s\" Safe:\n+ *   - Satisfactions for this expression always involve at least one signature.\n+ * - \"m\" Nonmalleable:\n+ *   - For every way this expression can be satisfied (which may be none),\n+ *     a nonmalleable satisfaction exists.\n+ *   - This generally requires 'm' for all subexpressions, and 'e' for all subexpressions\n+ *     which are dissatisfied when satisfying the parent.\n+ *\n+ * One final type property is an implementation detail:\n+ * - \"x\" Expensive verify:\n+ *   - Expressions with this property have a script whose last opcode is not EQUAL, CHECKSIG, or CHECKMULTISIG.\n+ *   - Not having this property means that it can be converted to a V at no cost (by switching to the\n+ *     -VERIFY version of the last opcode).\n+ *\n+ * For each of these properties the subset rule holds: an expression with properties X, Y, and Z, is also\n+ * valid in places where an X, a Y, a Z, an XY, ... is expected.\n+*/\n+class Type {\n+    //! Internal bitmap of properties (see \"\"_mst operator for details).\n+    uint16_t m_flags;\n+\n+    //! Internal constructed used by the \"\"_mst operator.\n+    explicit constexpr Type(uint16_t flags) : m_flags(flags) {}\n+\n+public:\n+    //! The only way to publicly construct a Type is using this literal operator.\n+    friend constexpr Type operator\"\" _mst(const char* c, size_t l);\n+\n+    //! Compute the type with the union of properties.\n+    constexpr Type operator|(Type x) const { return Type(m_flags | x.m_flags); }\n+\n+    //! Compute the type with the intersection of properties.\n+    constexpr Type operator&(Type x) const { return Type(m_flags & x.m_flags); }\n+\n+    //! Check whether the left hand's properties are superset of the right's (= left is a subtype of right).\n+    constexpr bool operator<<(Type x) const { return (x.m_flags & ~m_flags) == 0; }\n+\n+    //! Comparison operator to enable use in sets/maps (total ordering incompatible with <<).\n+    constexpr bool operator<(Type x) const { return m_flags < x.m_flags; }\n+\n+    //! Equality operator.\n+    constexpr bool operator==(Type x) const { return m_flags == x.m_flags; }\n+\n+    //! The empty type if x is false, itself otherwise.\n+    constexpr Type If(bool x) const { return Type(x ? m_flags : 0); }\n+};\n+\n+//! Literal operator to construct Type objects.\n+inline constexpr Type operator\"\" _mst(const char* c, size_t l) {\n+    return l == 0 ? Type(0) : operator\"\" _mst(c + 1, l - 1) | Type(\n+        *c == 'B' ? 1 << 0 : // Base type\n+        *c == 'V' ? 1 << 1 : // Verify type\n+        *c == 'K' ? 1 << 2 : // Key type\n+        *c == 'W' ? 1 << 3 : // Wrapped type\n+        *c == 'z' ? 1 << 4 : // Zero-arg property\n+        *c == 'o' ? 1 << 5 : // One-arg property\n+        *c == 'n' ? 1 << 6 : // Nonzero arg property\n+        *c == 'd' ? 1 << 7 : // Dissatisfiable property\n+        *c == 'u' ? 1 << 8 : // Unit property\n+        *c == 'e' ? 1 << 9 : // Expression property\n+        *c == 'f' ? 1 << 10 : // Forced property\n+        *c == 's' ? 1 << 11 : // Safe property\n+        *c == 'm' ? 1 << 12 : // Nonmalleable property\n+        *c == 'x' ? 1 << 13 : // Expensive verify\n+        (throw std::logic_error(\"Unknown character in _mst literal\"), 0)\n+    );\n+}\n+\n+template<typename Key> struct Node;\n+template<typename Key> using NodeRef = std::shared_ptr<const Node<Key>>;\n+\n+//! Construct a miniscript node as a shared_ptr.\n+template<typename Key, typename... Args>\n+NodeRef<Key> MakeNodeRef(Args&&... args) { return std::make_shared<const Node<Key>>(std::forward<Args>(args)...); }\n+\n+//! The different node types in miniscript.\n+enum class NodeType {\n+    JUST_0,     //!< OP_0\n+    JUST_1,    //!< OP_1\n+    PK,        //!< [key]\n+    PK_H,      //!< OP_DUP OP_HASH160 [keyhash] OP_EQUALVERFIFY\n+    OLDER,     //!< [n] OP_CHECKSEQUENCEVERIFY\n+    AFTER,     //!< [n] OP_CHECKLOCKTIMEVERIFY\n+    SHA256,    //!< OP_SIZE 32 OP_EQUALVERIFY OP_SHA256 [hash] OP_EQUAL\n+    HASH256,   //!< OP_SIZE 32 OP_EQUALVERIFY OP_HASH256 [hash] OP_EQUAL\n+    RIPEMD160, //!< OP_SIZE 32 OP_EQUALVERIFY OP_RIPEMD160 [hash] OP_EQUAL\n+    HASH160,   //!< OP_SIZE 32 OP_EQUALVERIFY OP_HASH160 [hash] OP_EQUAL\n+    WRAP_A,    //!< OP_TOALTSTACK [X] OP_FROMALTSTACK\n+    WRAP_S,    //!< OP_SWAP [X]\n+    WRAP_C,    //!< [X] OP_CHECKSIG\n+    WRAP_D,    //!< OP_DUP OP_IF [X] OP_ENDIF\n+    WRAP_V,    //!< [X] OP_VERIFY (or -VERIFY version of last opcode in X)\n+    WRAP_J,    //!< OP_SIZE OP_0NOTEQUAL OP_IF [X] OP_ENDIF\n+    WRAP_N,    //!< [X] OP_0NOTEQUAL\n+    AND_V,     //!< [X] [Y]\n+    AND_B,     //!< [X] [Y] OP_BOOLAND\n+    OR_B,      //!< [X] [Y] OP_BOOLOR\n+    OR_C,      //!< [X] OP_NOTIF [Y] OP_ENDIF\n+    OR_D,      //!< [X] OP_IFDUP OP_NOTIF [Y] OP_ENDIF\n+    OR_I,      //!< IF [X] OP_ELSE [Y] OP_ENDIF\n+    ANDOR,     //!< [X] OP_NOTIF [Z] OP_ELSE [Y] OP_ENDIF\n+    THRESH,    //!< [X1] ([Xn] OP_ADD)* [k] OP_EQUAL\n+    THRESH_M,  //!< [k] [key_n]* [n] OP_CHECKMULTISIG\n+    // AND_N(X,Y) is represented as ANDOR(X,Y,0)\n+    // WRAP_T(X) is represented as AND_V(X,1)\n+    // WRAP_L(X) is represented as OR_I(0,X)\n+    // WRAP_U(X) is represented as OR_I(X,0)\n+};\n+\n+namespace internal {\n+\n+//! Helper function for Node::CalcType.\n+Type ComputeType(NodeType nodetype, Type x, Type y, Type z, const std::vector<Type>& sub_types, uint32_t k, size_t data_size, size_t n_subs, size_t n_keys);\n+\n+//! Helper function for Node::CalcScriptLen.\n+size_t ComputeScriptLen(NodeType nodetype, Type sub0typ, size_t subsize, uint32_t k, size_t n_subs, size_t n_keys);\n+\n+//! A helper sanitizer/checker for the output of CalcType.\n+Type SanitizeType(Type x);\n+\n+} // namespace internal\n+\n+//! A node in a miniscript expression.\n+template<typename Key>\n+struct Node {\n+    //! What node type this node is.\n+    const NodeType nodetype;\n+    //! The k parameter (time for OLDER/AFTER, threshold for THRESH(_M))\n+    const uint32_t k = 0;\n+    //! The keys used by this expression (only for PK/PK_H/THRESH_M)\n+    const std::vector<Key> keys;\n+    //! The data bytes in this expression (only for HASH160/HASH256/SHA256/RIPEMD10).\n+    const std::vector<unsigned char> data;\n+    //! Subexpressions (for WRAP_*/AND_*/OR_*/ANDOR/THRESH)\n+    const std::vector<NodeRef<Key>> subs;\n+\n+private:\n+    //! Cached expression type (computed by CalcType and fed through SanitizeType).\n+    const Type typ;\n+    //! Cached script length (computed by CalcScriptLen).\n+    const size_t scriptlen;\n+\n+    //! Compute the length of the script for this miniscript (including children).\n+    size_t CalcScriptLen() const {\n+        size_t subsize = 0;\n+        for (const auto& sub : subs) {\n+            subsize += sub->ScriptSize();\n+        }\n+        Type sub0type = subs.size() > 0 ? subs[0]->GetType() : \"\"_mst;\n+        return internal::ComputeScriptLen(nodetype, sub0type, subsize, k, subs.size(), keys.size());\n+    }\n+\n+    //! Compute the type for this miniscript.\n+    Type CalcType() const {\n+        using namespace internal;\n+\n+        // THRESH has a variable number of subexpression\n+        std::vector<Type> sub_types;\n+        if (nodetype == NodeType::THRESH) {\n+            for (const auto& sub : subs) sub_types.push_back(sub->GetType());\n+        }\n+        // All other nodes than THRESH can be computed just from the types of the 0-3 subexpexpressions.\n+        Type x = subs.size() > 0 ? subs[0]->GetType() : \"\"_mst;\n+        Type y = subs.size() > 1 ? subs[1]->GetType() : \"\"_mst;\n+        Type z = subs.size() > 2 ? subs[2]->GetType() : \"\"_mst;\n+\n+        return SanitizeType(ComputeType(nodetype, x, y, z, sub_types, k, data.size(), subs.size(), keys.size()));\n+    }\n+\n+    //! Internal code for ToScript.\n+    template<typename Ctx>\n+    CScript MakeScript(const Ctx& ctx, bool verify = false) const {\n+        std::vector<unsigned char> bytes;\n+        switch (nodetype) {\n+            case NodeType::PK: return CScript() << ctx.ToPKBytes(keys[0]);\n+            case NodeType::PK_H: return CScript() << OP_DUP << OP_HASH160 << ctx.ToPKHBytes(keys[0]) << OP_EQUALVERIFY;\n+            case NodeType::OLDER: return CScript() << k << OP_CHECKSEQUENCEVERIFY;\n+            case NodeType::AFTER: return CScript() << k << OP_CHECKLOCKTIMEVERIFY;\n+            case NodeType::SHA256: return CScript() << OP_SIZE << 32 << OP_EQUALVERIFY << OP_SHA256 << data << (verify ? OP_EQUALVERIFY : OP_EQUAL);\n+            case NodeType::RIPEMD160: return CScript() << OP_SIZE << 32 << OP_EQUALVERIFY << OP_RIPEMD160 << data << (verify ? OP_EQUALVERIFY : OP_EQUAL);\n+            case NodeType::HASH256: return CScript() << OP_SIZE << 32 << OP_EQUALVERIFY << OP_HASH256 << data << (verify ? OP_EQUALVERIFY : OP_EQUAL);\n+            case NodeType::HASH160: return CScript() << OP_SIZE << 32 << OP_EQUALVERIFY << OP_HASH160 << data << (verify ? OP_EQUALVERIFY : OP_EQUAL);\n+            case NodeType::WRAP_A: return (CScript() << OP_TOALTSTACK) + subs[0]->MakeScript(ctx) + (CScript() << OP_FROMALTSTACK);\n+            case NodeType::WRAP_S: return (CScript() << OP_SWAP) + subs[0]->MakeScript(ctx, verify);\n+            case NodeType::WRAP_C: return subs[0]->MakeScript(ctx) + CScript() << (verify ? OP_CHECKSIGVERIFY : OP_CHECKSIG);\n+            case NodeType::WRAP_D: return (CScript() << OP_DUP << OP_IF) + subs[0]->MakeScript(ctx) + (CScript() << OP_ENDIF);\n+            case NodeType::WRAP_V: return subs[0]->MakeScript(ctx, true) + (subs[0]->GetType() << \"x\"_mst ? (CScript() << OP_VERIFY) : CScript());\n+            case NodeType::WRAP_J: return (CScript() << OP_SIZE << OP_0NOTEQUAL << OP_IF) + subs[0]->MakeScript(ctx) + (CScript() << OP_ENDIF);\n+            case NodeType::WRAP_N: return subs[0]->MakeScript(ctx) + CScript() << OP_0NOTEQUAL;\n+            case NodeType::JUST_1: return CScript() << OP_1;\n+            case NodeType::JUST_0: return CScript() << OP_0;\n+            case NodeType::AND_V: return subs[0]->MakeScript(ctx) + subs[1]->MakeScript(ctx, verify);\n+            case NodeType::AND_B: return subs[0]->MakeScript(ctx) + subs[1]->MakeScript(ctx) + (CScript() << OP_BOOLAND);\n+            case NodeType::OR_B: return subs[0]->MakeScript(ctx) + subs[1]->MakeScript(ctx) + (CScript() << OP_BOOLOR);\n+            case NodeType::OR_D: return subs[0]->MakeScript(ctx) + (CScript() << OP_IFDUP << OP_NOTIF) + subs[1]->MakeScript(ctx) + (CScript() << OP_ENDIF);\n+            case NodeType::OR_C: return subs[0]->MakeScript(ctx) + (CScript() << OP_NOTIF) + subs[1]->MakeScript(ctx) + (CScript() << OP_ENDIF);\n+            case NodeType::OR_I: return (CScript() << OP_IF) + subs[0]->MakeScript(ctx) + (CScript() << OP_ELSE) + subs[1]->MakeScript(ctx) + (CScript() << OP_ENDIF);\n+            case NodeType::ANDOR: return subs[0]->MakeScript(ctx) + (CScript() << OP_NOTIF) + subs[2]->MakeScript(ctx) + (CScript() << OP_ELSE) + subs[1]->MakeScript(ctx) + (CScript() << OP_ENDIF);\n+            case NodeType::THRESH_M: {\n+                CScript script = CScript() << k;\n+                for (const auto& key : keys) {\n+                    script << ctx.ToPKBytes(key);\n+                }\n+                return script << keys.size() << (verify ? OP_CHECKMULTISIGVERIFY : OP_CHECKMULTISIG);\n+            }\n+            case NodeType::THRESH: {\n+                CScript script = subs[0]->MakeScript(ctx);\n+                for (size_t i = 1; i < subs.size(); ++i) {\n+                    script = (script + subs[i]->MakeScript(ctx)) << OP_ADD;\n+                }\n+                return script << k << (verify ? OP_EQUALVERIFY : OP_EQUAL);\n+            }\n+        }\n+        assert(false);\n+        return {};\n+    }\n+\n+    //! Internal code for ToString.\n+    template<typename Ctx>\n+    std::string MakeString(const Ctx& ctx, bool& success, bool wrapped = false) const {\n+        switch (nodetype) {\n+            case NodeType::WRAP_A: return \"a\" + subs[0]->MakeString(ctx, success, true);\n+            case NodeType::WRAP_S: return \"s\" + subs[0]->MakeString(ctx, success, true);\n+            case NodeType::WRAP_C: return \"c\" + subs[0]->MakeString(ctx, success, true);\n+            case NodeType::WRAP_D: return \"d\" + subs[0]->MakeString(ctx, success, true);\n+            case NodeType::WRAP_V: return \"v\" + subs[0]->MakeString(ctx, success, true);\n+            case NodeType::WRAP_J: return \"j\" + subs[0]->MakeString(ctx, success, true);\n+            case NodeType::WRAP_N: return \"n\" + subs[0]->MakeString(ctx, success, true);\n+            case NodeType::AND_V:\n+                // t:X is syntactic sugar for and_v(X,1).\n+                if (subs[1]->nodetype == NodeType::JUST_1) return \"t\" + subs[0]->MakeString(ctx, success, true);\n+                break;\n+            case NodeType::OR_I:\n+                if (subs[0]->nodetype == NodeType::JUST_0) return \"l\" + subs[1]->MakeString(ctx, success, true);\n+                if (subs[1]->nodetype == NodeType::JUST_0) return \"u\" + subs[0]->MakeString(ctx, success, true);\n+                break;\n+            default:\n+                break;\n+        }\n+\n+        std::string ret = wrapped ? \":\" : \"\";\n+\n+        switch (nodetype) {\n+            case NodeType::PK: {\n+                std::string key_str;\n+                success = ctx.ToString(keys[0], key_str);\n+                return std::move(ret) + \"pk(\" + std::move(key_str) + \")\";\n+            }\n+            case NodeType::PK_H: {\n+                std::string key_str;\n+                success = ctx.ToString(keys[0], key_str);\n+                return std::move(ret) + \"pk_h(\" + std::move(key_str) + \")\";\n+            }\n+            case NodeType::AFTER: return std::move(ret) + \"after(\" + std::to_string(k) + \")\";\n+            case NodeType::OLDER: return std::move(ret) + \"older(\" + std::to_string(k) + \")\";\n+            case NodeType::HASH256: return std::move(ret) + \"hash256(\" + HexStr(data.begin(), data.end()) + \")\";\n+            case NodeType::HASH160: return std::move(ret) + \"hash160(\" + HexStr(data.begin(), data.end()) + \")\";\n+            case NodeType::SHA256: return std::move(ret) + \"sha256(\" + HexStr(data.begin(), data.end()) + \")\";\n+            case NodeType::RIPEMD160: return std::move(ret) + \"ripemd160(\" + HexStr(data.begin(), data.end()) + \")\";\n+            case NodeType::JUST_1: return std::move(ret) + \"1\";\n+            case NodeType::JUST_0: return std::move(ret) + \"0\";\n+            case NodeType::AND_V: return std::move(ret) + \"and_v(\" + subs[0]->MakeString(ctx, success) + \",\" + subs[1]->MakeString(ctx, success) + \")\";\n+            case NodeType::AND_B: return std::move(ret) + \"and_b(\" + subs[0]->MakeString(ctx, success) + \",\" + subs[1]->MakeString(ctx, success) + \")\";\n+            case NodeType::OR_B: return std::move(ret) + \"or_b(\" + subs[0]->MakeString(ctx, success) + \",\" + subs[1]->MakeString(ctx, success) + \")\";\n+            case NodeType::OR_D: return std::move(ret) + \"or_d(\" + subs[0]->MakeString(ctx, success) + \",\" + subs[1]->MakeString(ctx, success) + \")\";\n+            case NodeType::OR_C: return std::move(ret) + \"or_c(\" + subs[0]->MakeString(ctx, success) + \",\" + subs[1]->MakeString(ctx, success) + \")\";\n+            case NodeType::OR_I: return std::move(ret) + \"or_i(\" + subs[0]->MakeString(ctx, success) + \",\" + subs[1]->MakeString(ctx, success) + \")\";\n+            case NodeType::ANDOR:\n+                // and_n(X,Y) is syntactic sugar for andor(X,Y,0).\n+                if (subs[2]->nodetype == NodeType::JUST_0) return std::move(ret) + \"and_n(\" + subs[0]->MakeString(ctx, success) + \",\" + subs[1]->MakeString(ctx, success) + \")\";\n+                return std::move(ret) + \"andor(\" + subs[0]->MakeString(ctx, success) + \",\" + subs[1]->MakeString(ctx, success) + \",\" + subs[2]->MakeString(ctx, success) + \")\";\n+            case NodeType::THRESH_M: {\n+                auto str = std::move(ret) + \"thresh_m(\" + std::to_string(k);\n+                for (const auto& key : keys) {\n+                    std::string key_str;\n+                    success &= ctx.ToString(key, key_str);\n+                    str += \",\" + std::move(key_str);\n+                }\n+                return std::move(str) + \")\";\n+            }\n+            case NodeType::THRESH: {\n+                auto str = std::move(ret) + \"thresh(\" + std::to_string(k);\n+                for (const auto& sub : subs) {\n+                    str += \",\" + sub->MakeString(ctx, success);\n+                }\n+                return std::move(str) + \")\";\n+            }\n+            default: assert(false); // Wrappers should have been handled above\n+        }\n+        return \"\";\n+    }\n+\n+public:\n+    //! Return the size of the script for this expression (faster than ToString().size()).\n+    size_t ScriptSize() const { return scriptlen; }\n+\n+    //! Return the expression type.\n+    Type GetType() const { return typ; }\n+\n+    //! Check whether this node is valid at all.\n+    bool IsValid() const { return !(GetType() == \"\"_mst); }\n+\n+    //! Check whether this node is valid as a script on its own.\n+    bool IsValidTopLevel() const { return GetType() << \"B\"_mst; }\n+\n+    //! Check whether this script can always be satisfied in a non-malleable way.\n+    bool IsNonMalleable() const { return GetType() << \"m\"_mst; }\n+\n+    //! Check whether this script always needs a signature.\n+    bool NeedsSignature() const { return GetType() << \"s\"_mst; }\n+\n+    //! Do all sanity checks.\n+    bool IsSafeTopLevel() const { return GetType() << \"Bms\"_mst; }\n+\n+    //! Construct the script for this miniscript (including subexpressions).\n+    template<typename Ctx>\n+    CScript ToScript(const Ctx& ctx) const { return MakeScript(ctx); }\n+\n+    //! Convert this miniscript to its textual descriptor notation.\n+    template<typename Ctx>\n+    bool ToString(const Ctx& ctx, std::string& out) const {\n+        bool ret = true;\n+        out = MakeString(ctx, ret);\n+        if (!ret) out = \"\";\n+        return ret;\n+    }\n+\n+    //! Equality testing.\n+    bool operator==(const Node<Key>& arg) const\n+    {\n+        if (nodetype != arg.nodetype) return false;\n+        if (k != arg.k) return false;\n+        if (data != arg.data) return false;\n+        if (keys != arg.keys) return false;\n+        if (subs.size() != arg.subs.size()) return false;\n+        for (size_t i = 0; i < subs.size(); ++i) {\n+            if (!(*subs[i] == *arg.subs[i])) return false;\n+        }\n+        assert(scriptlen == arg.scriptlen);\n+        assert(typ == arg.typ);\n+        return true;\n+    }\n+\n+    // Constructors with various argument combinations.\n+    Node(NodeType nt, std::vector<NodeRef<Key>> sub, std::vector<unsigned char> arg, uint32_t val = 0) : nodetype(nt), k(val), data(std::move(arg)), subs(std::move(sub)), typ(CalcType()), scriptlen(CalcScriptLen()) {}\n+    Node(NodeType nt, std::vector<unsigned char> arg, uint32_t val = 0) : nodetype(nt), k(val), data(std::move(arg)), typ(CalcType()), scriptlen(CalcScriptLen()) {}\n+    Node(NodeType nt, std::vector<NodeRef<Key>> sub, std::vector<Key> key, uint32_t val = 0) : nodetype(nt), k(val), keys(std::move(key)), subs(std::move(sub)), typ(CalcType()), scriptlen(CalcScriptLen()) {}\n+    Node(NodeType nt, std::vector<Key> key, uint32_t val = 0) : nodetype(nt), k(val), keys(std::move(key)), typ(CalcType()), scriptlen(CalcScriptLen()) {}\n+    Node(NodeType nt, std::vector<NodeRef<Key>> sub, uint32_t val = 0) : nodetype(nt), k(val), subs(std::move(sub)), typ(CalcType()), scriptlen(CalcScriptLen()) {}\n+    Node(NodeType nt, uint32_t val = 0) : nodetype(nt), k(val), typ(CalcType()), scriptlen(CalcScriptLen()) {}\n+};\n+\n+namespace internal {\n+\n+//! Parse a miniscript from its textual descriptor form.\n+template<typename Key, typename Ctx>\n+inline NodeRef<Key> Parse(Span<const char>& in, const Ctx& ctx) {\n+    auto expr = Expr(in);\n+    // Parse wrappers\n+    for (int i = 0; i < expr.size(); ++i) {\n+        if (expr[i] == ':') {\n+            auto in2 = expr.subspan(i + 1);\n+            auto sub = Parse<Key>(in2, ctx);\n+            if (!sub || in2.size()) return {};\n+            for (int j = i; j-- > 0; ) {\n+                if (expr[j] == 'a') {\n+                    sub = MakeNodeRef<Key>(NodeType::WRAP_A, Vector(std::move(sub)));\n+                } else if (expr[j] == 's') {\n+                    sub = MakeNodeRef<Key>(NodeType::WRAP_S, Vector(std::move(sub)));\n+                } else if (expr[j] == 'c') {\n+                    sub = MakeNodeRef<Key>(NodeType::WRAP_C, Vector(std::move(sub)));\n+                } else if (expr[j] == 'd') {\n+                    sub = MakeNodeRef<Key>(NodeType::WRAP_D, Vector(std::move(sub)));\n+                } else if (expr[j] == 'j') {\n+                    sub = MakeNodeRef<Key>(NodeType::WRAP_J, Vector(std::move(sub)));\n+                } else if (expr[j] == 'n') {\n+                    sub = MakeNodeRef<Key>(NodeType::WRAP_N, Vector(std::move(sub)));\n+                } else if (expr[j] == 'v') {\n+                    sub = MakeNodeRef<Key>(NodeType::WRAP_V, Vector(std::move(sub)));\n+                } else if (expr[j] == 't') {\n+                    sub = MakeNodeRef<Key>(NodeType::AND_V, Vector(std::move(sub), MakeNodeRef<Key>(NodeType::JUST_1)));\n+                } else if (expr[j] == 'u') {\n+                    sub = MakeNodeRef<Key>(NodeType::OR_I, Vector(std::move(sub), MakeNodeRef<Key>(NodeType::JUST_0)));\n+                } else if (expr[j] == 'l') {\n+                    sub = MakeNodeRef<Key>(NodeType::OR_I, Vector(MakeNodeRef<Key>(NodeType::JUST_0), std::move(sub)));\n+                } else {\n+                    return {};\n+                }\n+            }\n+            return sub;\n+        }\n+        if (expr[i] < 'a' || expr[i] > 'z') break;\n+    }\n+    // Parse the other node types\n+    NodeType nodetype;\n+    if (expr == Span<const char>(\"0\", 1)) {\n+        return MakeNodeRef<Key>(NodeType::JUST_0);\n+    } else if (expr == Span<const char>(\"1\", 1)) {\n+        return MakeNodeRef<Key>(NodeType::JUST_1);\n+    } else if (Func(\"pk\", expr)) {\n+        Key key;\n+        if (ctx.FromString(expr.begin(), expr.end(), key)) {\n+            return MakeNodeRef<Key>(NodeType::PK, Vector(std::move(key)));\n+        }\n+        return {};\n+    } else if (Func(\"pk_h\", expr)) {\n+        Key key;\n+        if (ctx.FromString(expr.begin(), expr.end(), key)) {\n+            return MakeNodeRef<Key>(NodeType::PK_H, Vector(std::move(key)));\n+        }\n+        return {};\n+    } else if (expr == MakeSpan(\"0\")) {\n+        return MakeNodeRef<Key>(NodeType::JUST_0);\n+    } else if (expr == MakeSpan(\"1\")) {\n+        return MakeNodeRef<Key>(NodeType::JUST_1);\n+    } else if (Func(\"sha256\", expr)) {\n+        auto hash = ParseHex(std::string(expr.begin(), expr.end()));\n+        if (hash.size() != 32) return {};\n+        return MakeNodeRef<Key>(NodeType::SHA256, std::move(hash));\n+    } else if (Func(\"ripemd160\", expr)) {\n+        auto hash = ParseHex(std::string(expr.begin(), expr.end()));\n+        if (hash.size() != 20) return {};\n+        return MakeNodeRef<Key>(NodeType::RIPEMD160, std::move(hash));\n+    } else if (Func(\"hash256\", expr)) {\n+        auto hash = ParseHex(std::string(expr.begin(), expr.end()));\n+        if (hash.size() != 32) return {};\n+        return MakeNodeRef<Key>(NodeType::HASH256, std::move(hash));\n+    } else if (Func(\"hash160\", expr)) {\n+        auto hash = ParseHex(std::string(expr.begin(), expr.end()));\n+        if (hash.size() != 20) return {};\n+        return MakeNodeRef<Key>(NodeType::HASH160, std::move(hash));\n+    } else if (Func(\"after\", expr)) {\n+        int64_t num;\n+        if (!ParseInt64(std::string(expr.begin(), expr.end()), &num)) return {};\n+        if (num < 1 || num >= 0x80000000L) return {};\n+        return MakeNodeRef<Key>(NodeType::AFTER, num);\n+    } else if (Func(\"older\", expr)) {\n+        int64_t num;\n+        if (!ParseInt64(std::string(expr.begin(), expr.end()), &num)) return {};\n+        if (num < 1 || num >= 0x80000000L) return {};\n+        return MakeNodeRef<Key>(NodeType::OLDER, num);\n+    } else if (Func(\"and_n\", expr)) {\n+        auto left = Parse<Key>(expr, ctx);\n+        if (!left || !Const(\",\", expr)) return {};\n+        auto right = Parse<Key>(expr, ctx);\n+        if (!right || expr.size()) return {};\n+        return MakeNodeRef<Key>(NodeType::ANDOR, Vector(std::move(left), std::move(right), MakeNodeRef<Key>(NodeType::JUST_0)));\n+    } else if (Func(\"andor\", expr)) {\n+        auto left = Parse<Key>(expr, ctx);\n+        if (!left || !Const(\",\", expr)) return {};\n+        auto mid = Parse<Key>(expr, ctx);\n+        if (!mid || !Const(\",\", expr)) return {};\n+        auto right = Parse<Key>(expr, ctx);\n+        if (!right || expr.size()) return {};\n+        return MakeNodeRef<Key>(NodeType::ANDOR, Vector(std::move(left), std::move(mid), std::move(right)));\n+    } else if (Func(\"thresh_m\", expr)) {\n+        auto arg = Expr(expr);\n+        int64_t count;\n+        if (!ParseInt64(std::string(arg.begin(), arg.end()), &count)) return {};\n+        std::vector<Key> keys;\n+        while (expr.size()) {\n+            if (!Const(\",\", expr)) return {};\n+            auto keyarg = Expr(expr);\n+            Key key;\n+            if (!ctx.FromString(keyarg.begin(), keyarg.end(), key)) return {};\n+            keys.push_back(std::move(key));\n+        }\n+        if (keys.size() < 1 || keys.size() > 20) return {};\n+        if (count < 1 || count > (int64_t)keys.size()) return {};\n+        return MakeNodeRef<Key>(NodeType::THRESH_M, std::move(keys), count);\n+    } else if (Func(\"thresh\", expr)) {\n+        auto arg = Expr(expr);\n+        int64_t count;\n+        if (!ParseInt64(std::string(arg.begin(), arg.end()), &count)) return {};\n+        std::vector<NodeRef<Key>> subs;\n+        while (expr.size()) {\n+            if (!Const(\",\", expr)) return {};\n+            auto sub = Parse<Key>(expr, ctx);\n+            if (!sub) return {};\n+            subs.push_back(std::move(sub));\n+        }\n+        if (count <= 1 || count >= (int64_t)subs.size()) return {};\n+        return MakeNodeRef<Key>(NodeType::THRESH, std::move(subs), count);\n+    } else if (Func(\"and_v\", expr)) {\n+        nodetype = NodeType::AND_V;\n+    } else if (Func(\"and_b\", expr)) {\n+        nodetype = NodeType::AND_B;\n+    } else if (Func(\"or_c\", expr)) {\n+        nodetype = NodeType::OR_C;\n+    } else if (Func(\"or_b\", expr)) {\n+        nodetype = NodeType::OR_B;\n+    } else if (Func(\"or_d\", expr)) {\n+        nodetype = NodeType::OR_D;\n+    } else if (Func(\"or_i\", expr)) {\n+        nodetype = NodeType::OR_I;\n+    } else {\n+        return {};\n+    }\n+    auto left = Parse<Key>(expr, ctx);\n+    if (!left || !Const(\",\", expr)) return {};\n+    auto right = Parse<Key>(expr, ctx);\n+    if (!right || expr.size()) return {};\n+    return MakeNodeRef<Key>(nodetype, Vector(std::move(left), std::move(right)));\n+}\n+\n+} // namespace internal\n+\n+template<typename Ctx>\n+inline NodeRef<typename Ctx::Key> FromString(const std::string& str, const Ctx& ctx) {\n+    using namespace internal;\n+    Span<const char> span = MakeSpan(str);\n+    auto ret = Parse<typename Ctx::Key>(span, ctx);\n+    if (!ret || span.size()) return {};\n+    return ret;\n+}\n+\n+} // namespace miniscript\n+\n+#endif // BITCOIN_SCRIPT_MINISCRIPT_H"
      },
      {
        "sha": "305a9cc85c41f66ef18c1c81a0da471b3b690d7a",
        "filename": "src/script/script.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/57a6c0e853b84b72a7d39cbd37834fcf6416ac40/src/script/script.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/57a6c0e853b84b72a7d39cbd37834fcf6416ac40/src/script/script.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script.h?ref=57a6c0e853b84b72a7d39cbd37834fcf6416ac40",
        "patch": "@@ -317,6 +317,8 @@ class CScriptNum\n         return m_value;\n     }\n \n+    int64_t GetInt64() const { return m_value; }\n+\n     std::vector<unsigned char> getvch() const\n     {\n         return serialize(m_value);"
      },
      {
        "sha": "25d2eed2346a4330633ced65f0c4634e639122fa",
        "filename": "src/test/miniscript_tests.cpp",
        "status": "added",
        "additions": 324,
        "deletions": 0,
        "changes": 324,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/57a6c0e853b84b72a7d39cbd37834fcf6416ac40/src/test/miniscript_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/57a6c0e853b84b72a7d39cbd37834fcf6416ac40/src/test/miniscript_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/miniscript_tests.cpp?ref=57a6c0e853b84b72a7d39cbd37834fcf6416ac40",
        "patch": "@@ -0,0 +1,324 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\n+#include <string>\n+\n+#include <test/setup_common.h>\n+#include <boost/test/unit_test.hpp>\n+\n+#include <hash.h>\n+#include <pubkey.h>\n+#include <uint256.h>\n+#include <crypto/ripemd160.h>\n+#include <crypto/sha256.h>\n+#include <script/miniscript.h>\n+\n+namespace {\n+\n+/** TestData groups various kinds of precomputed data necessary in this test. */\n+struct TestData {\n+    //! The only public keys used in this test.\n+    std::vector<CPubKey> pubkeys;\n+    //! A map from the public keys to their CKeyIDs (faster than hashing every time).\n+    std::map<CPubKey, CKeyID> pkhashes;\n+\n+    // Various precomputed hashes\n+    std::vector<std::vector<unsigned char>> sha256;\n+    std::vector<std::vector<unsigned char>> ripemd160;\n+    std::vector<std::vector<unsigned char>> hash256;\n+    std::vector<std::vector<unsigned char>> hash160;\n+\n+    TestData()\n+    {\n+        // We generate 255 public keys and 255 hashes of each type.\n+        for (int i = 1; i <= 255; ++i) {\n+            // This 32-byte array functions as both private key data and hash preimage (31 zero bytes plus any nonzero byte).\n+            unsigned char keydata[32] = {0};\n+            keydata[31] = i;\n+\n+            // Compute CPubkey and CKeyID\n+            CKey key;\n+            key.Set(keydata, keydata + 32, true);\n+            CPubKey pubkey = key.GetPubKey();\n+            CKeyID keyid = pubkey.GetID();\n+            pubkeys.push_back(pubkey);\n+            pkhashes.emplace(pubkey, keyid);\n+\n+            // Compute various hashes\n+            std::vector<unsigned char> hash;\n+            hash.resize(32);\n+            CSHA256().Write(keydata, 32).Finalize(hash.data());\n+            sha256.push_back(hash);\n+            CHash256().Write(keydata, 32).Finalize(hash.data());\n+            hash256.push_back(hash);\n+            hash.resize(20);\n+            CRIPEMD160().Write(keydata, 32).Finalize(hash.data());\n+            ripemd160.push_back(hash);\n+            CHash160().Write(keydata, 32).Finalize(hash.data());\n+            hash160.push_back(hash);\n+        }\n+    }\n+};\n+\n+//! Global TestData object\n+std::unique_ptr<const TestData> g_testdata;\n+\n+/** A class encapulating conversion routing for CPubKey. */\n+struct KeyConverter {\n+    typedef CPubKey Key;\n+\n+    //! Public keys in text form are their usual hex notation (no xpubs, ...).\n+    bool ToString(const CPubKey& key, std::string& ret) const { ret = HexStr(key.begin(), key.end()); return true; }\n+\n+    //! Convert a public key to bytes.\n+    std::vector<unsigned char> ToPKBytes(const CPubKey& key) const { return {key.begin(), key.end()}; }\n+\n+    //! Convert a public key to its Hash160 bytes (precomputed).\n+    std::vector<unsigned char> ToPKHBytes(const CPubKey& key) const\n+    {\n+        auto it = g_testdata->pkhashes.find(key);\n+        assert(it != g_testdata->pkhashes.end());\n+        return {it->second.begin(), it->second.end()};\n+    }\n+\n+    //! Parse a public key from a range of hex characters.\n+    template<typename I>\n+    bool FromString(I first, I last, CPubKey& key) const {\n+        auto bytes = ParseHex(std::string(first, last));\n+        key.Set(bytes.begin(), bytes.end());\n+        return key.IsValid();\n+    }\n+};\n+\n+//! Singleton instance of KeyConverter.\n+const KeyConverter CONVERTER{};\n+\n+// Helper types and functions that use miniscript instantiated for CPubKey.\n+using NodeType = miniscript::NodeType;\n+using NodeRef = miniscript::NodeRef<CPubKey>;\n+template<typename... Args> NodeRef MakeNodeRef(Args&&... args) { return miniscript::MakeNodeRef<CPubKey>(std::forward<Args>(args)...); }\n+using miniscript::operator\"\" _mst;\n+\n+NodeRef GenNode(miniscript::Type typ, int complexity);\n+\n+//! Generate a random valid miniscript node of the given type and complexity.\n+NodeRef RandomNode(miniscript::Type typ, int complexity) {\n+    assert(complexity > 0);\n+    NodeRef ret;\n+    do {\n+        ret = GenNode(typ, complexity);\n+    } while (!ret || !ret->IsValid() || !(ret->GetType() << typ));\n+    return ret;\n+}\n+\n+//! Generate a vector of valid miniscript nodes of the given types, and a specified complexity of their sum.\n+std::vector<NodeRef> MultiNode(int complexity, const std::vector<miniscript::Type>& types)\n+{\n+    int nodes = types.size();\n+    assert(complexity >= nodes);\n+    std::vector<int> subcomplex(nodes, 1);\n+    if (nodes == 1) {\n+        subcomplex[0] = complexity;\n+    } else {\n+        // This is a silly inefficient way to construct a multinomial distribution.\n+        for (int i = 0; i < complexity - nodes; ++i) {\n+            subcomplex[InsecureRandRange(nodes)]++;\n+        }\n+    }\n+    std::vector<NodeRef> subs;\n+    for (int i = 0; i < nodes; ++i) {\n+        subs.push_back(RandomNode(types[i], subcomplex[i]));\n+    }\n+    return subs;\n+}\n+\n+//! Generate a random (but occasionally invalid) miniscript node of the given type and complexity.\n+NodeRef GenNode(miniscript::Type typ, int complexity) {\n+    if (typ << \"B\"_mst) {\n+        // Generate a \"B\" node.\n+        if (complexity == 1) {\n+            switch (InsecureRandBits(2)) {\n+                case 0: return MakeNodeRef(InsecureRandBool() ? NodeType::JUST_0 : NodeType::JUST_1);\n+                case 1: return MakeNodeRef(InsecureRandBool() ? NodeType::OLDER : NodeType::AFTER, 1 + InsecureRandRange((1ULL << (1 + InsecureRandRange(31))) - 1));\n+                case 2: {\n+                    int hashtype = InsecureRandBits(2);\n+                    int index = InsecureRandRange(255);\n+                    switch (hashtype) {\n+                        case 0: return MakeNodeRef(NodeType::SHA256, g_testdata->sha256[index]);\n+                        case 1: return MakeNodeRef(NodeType::RIPEMD160, g_testdata->ripemd160[index]);\n+                        case 2: return MakeNodeRef(NodeType::HASH256, g_testdata->hash256[index]);\n+                        case 3: return MakeNodeRef(NodeType::HASH160, g_testdata->hash160[index]);\n+                    }\n+                    break;\n+                }\n+                case 3: return MakeNodeRef(NodeType::WRAP_C, MultiNode(complexity, Vector(\"K\"_mst)));\n+            }\n+            assert(false);\n+        }\n+        switch (InsecureRandRange(7 + (complexity >= 3) * 7 + (complexity >= 4) * 2)) {\n+            // Complexity >= 2\n+            case 0: return MakeNodeRef(NodeType::WRAP_C, MultiNode(complexity, Vector(\"K\"_mst)));\n+            case 1: return MakeNodeRef(NodeType::WRAP_D, MultiNode(complexity - 1, Vector(\"V\"_mst)));\n+            case 2: return MakeNodeRef(NodeType::WRAP_J, MultiNode(complexity - 1, Vector(\"B\"_mst)));\n+            case 3: return MakeNodeRef(NodeType::WRAP_N, MultiNode(complexity - 1, Vector(\"B\"_mst)));\n+            case 4: return MakeNodeRef(NodeType::OR_I, Cat(MultiNode(complexity - 1, Vector(\"B\"_mst)), Vector(MakeNodeRef(NodeType::JUST_0))));\n+            case 5: return MakeNodeRef(NodeType::OR_I, Cat(Vector(MakeNodeRef(NodeType::JUST_0)), MultiNode(complexity - 1, Vector(\"B\"_mst))));\n+            case 6: return MakeNodeRef(NodeType::AND_V, Cat(MultiNode(complexity - 1, Vector(\"V\"_mst)), Vector(MakeNodeRef(NodeType::JUST_1))));\n+            // Complexity >= 3\n+            case 7: return MakeNodeRef(NodeType::AND_V, MultiNode(complexity - 1, Vector(\"V\"_mst, \"B\"_mst)));\n+            case 8: return MakeNodeRef(NodeType::ANDOR, Cat(MultiNode(complexity - 1, Vector(\"B\"_mst, \"B\"_mst)), Vector(MakeNodeRef(NodeType::JUST_0))));\n+            case 9: return MakeNodeRef(NodeType::AND_B, MultiNode(complexity - 1, Vector(\"B\"_mst, \"W\"_mst)));\n+            case 10: return MakeNodeRef(NodeType::OR_B, MultiNode(complexity - 1, Vector(\"B\"_mst, \"W\"_mst)));\n+            case 11: return MakeNodeRef(NodeType::OR_D, MultiNode(complexity - 1, Vector(\"B\"_mst, \"B\"_mst)));\n+            case 12: return MakeNodeRef(NodeType::OR_I, MultiNode(complexity - 1, Vector(\"B\"_mst, \"B\"_mst)));\n+            case 13: {\n+                if (complexity != 3) return {};\n+                int nkeys = 1 + (InsecureRandRange(15) * InsecureRandRange(25)) / 17;\n+                int sigs = 1 + InsecureRandRange(nkeys);\n+                std::vector<CPubKey> keys;\n+                for (int i = 0; i < nkeys; ++i) keys.push_back(g_testdata->pubkeys[InsecureRandRange(255)]);\n+                return MakeNodeRef(NodeType::THRESH_M, std::move(keys), sigs);\n+            }\n+            // Complexity >= 4\n+            case 14: return MakeNodeRef(NodeType::ANDOR, MultiNode(complexity - 1, Vector(\"B\"_mst, \"B\"_mst, \"B\"_mst)));\n+            case 15: {\n+                int args = 3 + InsecureRandRange(std::min(3, complexity - 3));\n+                int sats = 2 + InsecureRandRange(args - 2);\n+                return MakeNodeRef(NodeType::THRESH, MultiNode(complexity - 1, Cat(Vector(\"B\"_mst), std::vector<miniscript::Type>(args - 1, \"W\"_mst))), sats);\n+            }\n+        }\n+    } else if (typ << \"V\"_mst) {\n+        // Generate a \"V\" node.\n+        switch (InsecureRandRange(1 + (complexity >= 3) * 3 + (complexity >= 4))) {\n+            // Complexity >= 1\n+            case 0: return MakeNodeRef(NodeType::WRAP_V, MultiNode(complexity, Vector(\"B\"_mst)));\n+            // Complexity >= 3\n+            case 1: return MakeNodeRef(NodeType::AND_V, MultiNode(complexity - 1, Vector(\"V\"_mst, \"V\"_mst)));\n+            case 2: return MakeNodeRef(NodeType::OR_C, MultiNode(complexity - 1, Vector(\"B\"_mst, \"V\"_mst)));\n+            case 3: return MakeNodeRef(NodeType::OR_I, MultiNode(complexity - 1, Vector(\"V\"_mst, \"V\"_mst)));\n+            // Complexity >= 4\n+            case 4: return MakeNodeRef(NodeType::ANDOR, MultiNode(complexity - 1, Vector(\"B\"_mst, \"V\"_mst, \"V\"_mst)));\n+        }\n+    } else if (typ << \"W\"_mst) {\n+        // Generate a \"W\" node by wrapping a \"B\" node.\n+        auto sub = RandomNode(\"B\"_mst, complexity);\n+        if (sub->GetType() << \"o\"_mst) {\n+            if (InsecureRandBool()) return MakeNodeRef(NodeType::WRAP_S, Vector(std::move(sub)));\n+        }\n+        return MakeNodeRef(NodeType::WRAP_A, Vector(std::move(sub)));\n+    } else if (typ << \"K\"_mst) {\n+        // Generate a \"K\" node.\n+        if (complexity == 1 || complexity == 2) {\n+            if (InsecureRandBool()) {\n+                return MakeNodeRef(NodeType::PK, Vector(g_testdata->pubkeys[InsecureRandRange(255)]));\n+            } else {\n+                return MakeNodeRef(NodeType::PK_H, Vector(g_testdata->pubkeys[InsecureRandRange(255)]));\n+            }\n+        }\n+        switch (InsecureRandRange(2 + (complexity >= 4))) {\n+            // Complexity >= 3\n+            case 0: return MakeNodeRef(NodeType::AND_V, MultiNode(complexity - 1, Vector(\"V\"_mst, \"K\"_mst)));\n+            case 1: return MakeNodeRef(NodeType::OR_I, MultiNode(complexity - 1, Vector(\"K\"_mst, \"K\"_mst)));\n+            // Complexity >= 4\n+            case 2: return MakeNodeRef(NodeType::ANDOR, MultiNode(complexity - 1, Vector(\"B\"_mst, \"K\"_mst, \"K\"_mst)));\n+        }\n+    }\n+    assert(false);\n+    return {};\n+}\n+\n+enum TestMode : int {\n+    TESTMODE_INVALID = 0,\n+    TESTMODE_VALID = 1,\n+    TESTMODE_NONMAL = 2,\n+    TESTMODE_NEEDSIG = 4\n+};\n+\n+void Test(const std::string& ms, const std::string& hexscript, int mode)\n+{\n+    auto node = miniscript::FromString(ms, CONVERTER);\n+    if (mode == TESTMODE_INVALID) {\n+        BOOST_CHECK_MESSAGE(!node || !node->IsValid(), \"Unexpectedly valid: \" + ms);\n+    } else {\n+        BOOST_CHECK_MESSAGE(node, \"Unparseable: \" + ms);\n+        BOOST_CHECK_MESSAGE(node->IsValid(), \"Invalid: \" + ms);\n+        BOOST_CHECK_MESSAGE(node->IsValidTopLevel(), \"Invalid top level: \" + ms);\n+        auto computed_script = node->ToScript(CONVERTER);\n+        BOOST_CHECK_MESSAGE(node->ScriptSize() == computed_script.size(), \"Script size mismatch: \" + ms);\n+        if (hexscript != \"?\") BOOST_CHECK_MESSAGE(HexStr(computed_script) == hexscript, \"Script mismatch: \" + ms + \" (\" + HexStr(computed_script) + \" vs \" + hexscript + \")\");\n+        BOOST_CHECK_MESSAGE(node->IsNonMalleable() == !!(mode & TESTMODE_NONMAL), \"Malleability mismatch: \" + ms);\n+        BOOST_CHECK_MESSAGE(node->NeedsSignature() == !!(mode & TESTMODE_NEEDSIG), \"Signature necessity mismatch: \" + ms);\n+    }\n+\n+}\n+\n+} // namespace\n+\n+BOOST_FIXTURE_TEST_SUITE(miniscript_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(fixed_tests)\n+{\n+    g_testdata.reset(new TestData());\n+\n+    // Randomly generated test set that covers the majority of type and node type combinations\n+    Test(\"lltvln:after(1231488000)\", \"6300676300676300670400046749b1926869516868\", TESTMODE_VALID | TESTMODE_NONMAL);\n+    Test(\"uuj:and_v(v:thresh_m(2,03d01115d548e7561b15c38f004d734633687cf4419620095bc5b0f47070afe85a,025601570cb47f238d2b0286db4a990fa0f3ba28d1a319f5e7cf55c2a2444da7cc),after(1231488000))\", \"6363829263522103d01115d548e7561b15c38f004d734633687cf4419620095bc5b0f47070afe85a21025601570cb47f238d2b0286db4a990fa0f3ba28d1a319f5e7cf55c2a2444da7cc52af0400046749b168670068670068\", TESTMODE_VALID | TESTMODE_NONMAL | TESTMODE_NEEDSIG);\n+    Test(\"or_b(un:thresh_m(2,03daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729,024ce119c96e2fa357200b559b2f7dd5a5f02d5290aff74b03f3e471b273211c97),al:older(16))\", \"63522103daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee872921024ce119c96e2fa357200b559b2f7dd5a5f02d5290aff74b03f3e471b273211c9752ae926700686b63006760b2686c9b\", TESTMODE_VALID);\n+    Test(\"j:and_v(vdv:after(1567547623),older(2016))\", \"829263766304e7e06e5db169686902e007b268\", TESTMODE_VALID | TESTMODE_NONMAL);\n+    Test(\"t:and_v(vu:hash256(131772552c01444cd81360818376a040b7c3b2b7b0a53550ee3edde216cec61b),v:sha256(ec4916dd28fc4c10d78e287ca5d9cc51ee1ae73cbfde08c6b37324cbfaac8bc5))\", \"6382012088aa20131772552c01444cd81360818376a040b7c3b2b7b0a53550ee3edde216cec61b876700686982012088a820ec4916dd28fc4c10d78e287ca5d9cc51ee1ae73cbfde08c6b37324cbfaac8bc58851\", TESTMODE_VALID | TESTMODE_NONMAL);\n+    Test(\"t:andor(thresh_m(3,02d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e,03fff97bd5755eeea420453a14355235d382f6472f8568a18b2f057a1460297556,02e493dbf1c10d80f3581e4904930b1404cc6c13900ee0758474fa94abe8c4cd13),v:older(4194305),v:sha256(9267d3dbed802941483f1afa2a6bc68de5f653128aca9bf1461c5d0a3ad36ed2))\", \"532102d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e2103fff97bd5755eeea420453a14355235d382f6472f8568a18b2f057a14602975562102e493dbf1c10d80f3581e4904930b1404cc6c13900ee0758474fa94abe8c4cd1353ae6482012088a8209267d3dbed802941483f1afa2a6bc68de5f653128aca9bf1461c5d0a3ad36ed2886703010040b2696851\", TESTMODE_VALID | TESTMODE_NONMAL);\n+    Test(\"or_d(thresh_m(1,02f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9),or_b(thresh_m(3,022f01e5e15cca351daff3843fb70f3c2f0a1bdd05e5af888a67784ef3e10a2a01,032fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f,03d01115d548e7561b15c38f004d734633687cf4419620095bc5b0f47070afe85a),su:after(500000)))\", \"512102f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f951ae73645321022f01e5e15cca351daff3843fb70f3c2f0a1bdd05e5af888a67784ef3e10a2a0121032fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f2103d01115d548e7561b15c38f004d734633687cf4419620095bc5b0f47070afe85a53ae7c630320a107b16700689b68\", TESTMODE_VALID | TESTMODE_NONMAL);\n+    Test(\"or_d(sha256(38df1c1f64a24a77b23393bca50dff872e31edc4f3b5aa3b90ad0b82f4f089b6),and_n(un:after(499999999),older(4194305)))\", \"82012088a82038df1c1f64a24a77b23393bca50dff872e31edc4f3b5aa3b90ad0b82f4f089b68773646304ff64cd1db19267006864006703010040b26868\", TESTMODE_VALID);\n+    Test(\"and_v(or_i(v:thresh_m(2,02c6047f9441ed7d6d3045406e95c07cd85c778e4b8cef3ca7abac09b95c709ee5,03774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb),v:thresh_m(2,03e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a,025cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc)),sha256(d1ec675902ef1633427ca360b290b0b3045a0d9058ddb5e648b4c3c3224c5c68))\", \"63522102c6047f9441ed7d6d3045406e95c07cd85c778e4b8cef3ca7abac09b95c709ee52103774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb52af67522103e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a21025cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc52af6882012088a820d1ec675902ef1633427ca360b290b0b3045a0d9058ddb5e648b4c3c3224c5c6887\", TESTMODE_VALID | TESTMODE_NONMAL | TESTMODE_NEEDSIG);\n+    Test(\"j:and_b(thresh_m(2,0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798,024ce119c96e2fa357200b559b2f7dd5a5f02d5290aff74b03f3e471b273211c97),s:or_i(older(1),older(4252898)))\", \"82926352210279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f8179821024ce119c96e2fa357200b559b2f7dd5a5f02d5290aff74b03f3e471b273211c9752ae7c6351b26703e2e440b2689a68\", TESTMODE_VALID | TESTMODE_NEEDSIG);\n+    Test(\"and_b(older(16),s:or_d(sha256(e38990d0c7fc009880a9c07c23842e886c6bbdc964ce6bdd5817ad357335ee6f),n:after(1567547623)))\", \"60b27c82012088a820e38990d0c7fc009880a9c07c23842e886c6bbdc964ce6bdd5817ad357335ee6f87736404e7e06e5db192689a\", TESTMODE_VALID);\n+    Test(\"j:and_v(v:hash160(20195b5a3d650c17f0f29f91c33f8f6335193d07),or_d(sha256(96de8fc8c256fa1e1556d41af431cace7dca68707c78dd88c3acab8b17164c47),older(16)))\", \"82926382012088a91420195b5a3d650c17f0f29f91c33f8f6335193d078882012088a82096de8fc8c256fa1e1556d41af431cace7dca68707c78dd88c3acab8b17164c4787736460b26868\", TESTMODE_VALID);\n+    Test(\"and_b(hash256(32ba476771d01e37807990ead8719f08af494723de1d228f2c2c07cc0aa40bac),a:and_b(hash256(131772552c01444cd81360818376a040b7c3b2b7b0a53550ee3edde216cec61b),a:older(1)))\", \"82012088aa2032ba476771d01e37807990ead8719f08af494723de1d228f2c2c07cc0aa40bac876b82012088aa20131772552c01444cd81360818376a040b7c3b2b7b0a53550ee3edde216cec61b876b51b26c9a6c9a\", TESTMODE_VALID | TESTMODE_NONMAL);\n+    Test(\"thresh(2,thresh_m(2,03a0434d9e47f3c86235477c7b1ae6ae5d3442d49b1943c2b752a68e2a47e247c7,036d2b085e9e382ed10b69fc311a03f8641ccfff21574de0927513a49d9a688a00),a:thresh_m(1,036d2b085e9e382ed10b69fc311a03f8641ccfff21574de0927513a49d9a688a00),ac:pk(022f01e5e15cca351daff3843fb70f3c2f0a1bdd05e5af888a67784ef3e10a2a01))\", \"522103a0434d9e47f3c86235477c7b1ae6ae5d3442d49b1943c2b752a68e2a47e247c721036d2b085e9e382ed10b69fc311a03f8641ccfff21574de0927513a49d9a688a0052ae6b5121036d2b085e9e382ed10b69fc311a03f8641ccfff21574de0927513a49d9a688a0051ae6c936b21022f01e5e15cca351daff3843fb70f3c2f0a1bdd05e5af888a67784ef3e10a2a01ac6c935287\", TESTMODE_VALID | TESTMODE_NONMAL | TESTMODE_NEEDSIG);\n+    Test(\"and_n(sha256(d1ec675902ef1633427ca360b290b0b3045a0d9058ddb5e648b4c3c3224c5c68),t:or_i(v:older(4252898),v:older(144)))\", \"82012088a820d1ec675902ef1633427ca360b290b0b3045a0d9058ddb5e648b4c3c3224c5c68876400676303e2e440b26967029000b269685168\", TESTMODE_VALID);\n+    Test(\"or_d(d:and_v(v:older(4252898),v:older(4252898)),sha256(38df1c1f64a24a77b23393bca50dff872e31edc4f3b5aa3b90ad0b82f4f089b6))\", \"766303e2e440b26903e2e440b26968736482012088a82038df1c1f64a24a77b23393bca50dff872e31edc4f3b5aa3b90ad0b82f4f089b68768\", TESTMODE_VALID);\n+    Test(\"c:and_v(or_c(sha256(9267d3dbed802941483f1afa2a6bc68de5f653128aca9bf1461c5d0a3ad36ed2),v:thresh_m(1,02c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db)),pk(03acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe))\", \"82012088a8209267d3dbed802941483f1afa2a6bc68de5f653128aca9bf1461c5d0a3ad36ed28764512102c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db51af682103acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbeac\", TESTMODE_VALID | TESTMODE_NEEDSIG);\n+    Test(\"c:and_v(or_c(thresh_m(2,036d2b085e9e382ed10b69fc311a03f8641ccfff21574de0927513a49d9a688a00,02352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5),v:ripemd160(1b0f3c404d12075c68c938f9f60ebea4f74941a0)),pk(03fff97bd5755eeea420453a14355235d382f6472f8568a18b2f057a1460297556))\", \"5221036d2b085e9e382ed10b69fc311a03f8641ccfff21574de0927513a49d9a688a002102352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d552ae6482012088a6141b0f3c404d12075c68c938f9f60ebea4f74941a088682103fff97bd5755eeea420453a14355235d382f6472f8568a18b2f057a1460297556ac\", TESTMODE_VALID | TESTMODE_NONMAL | TESTMODE_NEEDSIG);\n+    Test(\"and_v(andor(hash256(8a35d9ca92a48eaade6f53a64985e9e2afeb74dcf8acb4c3721e0dc7e4294b25),v:hash256(939894f70e6c3a25da75da0cc2071b4076d9b006563cf635986ada2e93c0d735),v:older(50000)),after(499999999))\", \"82012088aa208a35d9ca92a48eaade6f53a64985e9e2afeb74dcf8acb4c3721e0dc7e4294b2587640350c300b2696782012088aa20939894f70e6c3a25da75da0cc2071b4076d9b006563cf635986ada2e93c0d735886804ff64cd1db1\", TESTMODE_VALID);\n+    Test(\"andor(hash256(5f8d30e655a7ba0d7596bb3ddfb1d2d20390d23b1845000e1e118b3be1b3f040),j:and_v(v:hash160(3a2bff0da9d96868e66abc4427bea4691cf61ccd),older(4194305)),ripemd160(44d90e2d3714c8663b632fcf0f9d5f22192cc4c8))\", \"82012088aa205f8d30e655a7ba0d7596bb3ddfb1d2d20390d23b1845000e1e118b3be1b3f040876482012088a61444d90e2d3714c8663b632fcf0f9d5f22192cc4c8876782926382012088a9143a2bff0da9d96868e66abc4427bea4691cf61ccd8803010040b26868\", TESTMODE_VALID);\n+    Test(\"or_i(c:and_v(v:after(500000),pk(02c6047f9441ed7d6d3045406e95c07cd85c778e4b8cef3ca7abac09b95c709ee5)),sha256(d9147961436944f43cd99d28b2bbddbf452ef872b30c8279e255e7daafc7f946))\", \"630320a107b1692102c6047f9441ed7d6d3045406e95c07cd85c778e4b8cef3ca7abac09b95c709ee5ac6782012088a820d9147961436944f43cd99d28b2bbddbf452ef872b30c8279e255e7daafc7f9468768\", TESTMODE_VALID | TESTMODE_NONMAL);\n+    Test(\"thresh(2,c:pk_h(025cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc),s:sha256(e38990d0c7fc009880a9c07c23842e886c6bbdc964ce6bdd5817ad357335ee6f),a:hash160(dd69735817e0e3f6f826a9238dc2e291184f0131))\", \"76a9145dedfbf9ea599dd4e3ca6a80b333c472fd0b3f6988ac7c82012088a820e38990d0c7fc009880a9c07c23842e886c6bbdc964ce6bdd5817ad357335ee6f87936b82012088a914dd69735817e0e3f6f826a9238dc2e291184f0131876c935287\", TESTMODE_VALID);\n+    Test(\"and_n(sha256(9267d3dbed802941483f1afa2a6bc68de5f653128aca9bf1461c5d0a3ad36ed2),uc:and_v(v:older(144),pk(03fe72c435413d33d48ac09c9161ba8b09683215439d62b7940502bda8b202e6ce)))\", \"82012088a8209267d3dbed802941483f1afa2a6bc68de5f653128aca9bf1461c5d0a3ad36ed28764006763029000b2692103fe72c435413d33d48ac09c9161ba8b09683215439d62b7940502bda8b202e6ceac67006868\", TESTMODE_VALID | TESTMODE_NEEDSIG);\n+    Test(\"and_n(c:pk(03daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729),and_b(l:older(4252898),a:older(16)))\", \"2103daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729ac64006763006703e2e440b2686b60b26c9a68\", TESTMODE_VALID | TESTMODE_NONMAL | TESTMODE_NEEDSIG);\n+    Test(\"c:or_i(and_v(v:older(16),pk_h(02d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e)),pk_h(026a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4))\", \"6360b26976a9149fc5dbe5efdce10374a4dd4053c93af540211718886776a9142fbd32c8dd59ee7c17e66cb6ebea7e9846c3040f8868ac\", TESTMODE_VALID | TESTMODE_NONMAL | TESTMODE_NEEDSIG);\n+    Test(\"or_d(c:pk_h(02e493dbf1c10d80f3581e4904930b1404cc6c13900ee0758474fa94abe8c4cd13),andor(c:pk(024ce119c96e2fa357200b559b2f7dd5a5f02d5290aff74b03f3e471b273211c97),older(2016),after(1567547623)))\", \"76a914c42e7ef92fdb603af844d064faad95db9bcdfd3d88ac736421024ce119c96e2fa357200b559b2f7dd5a5f02d5290aff74b03f3e471b273211c97ac6404e7e06e5db16702e007b26868\", TESTMODE_VALID | TESTMODE_NONMAL);\n+    Test(\"c:andor(ripemd160(6ad07d21fd5dfc646f0b30577045ce201616b9ba),pk_h(02d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e),and_v(v:hash256(8a35d9ca92a48eaade6f53a64985e9e2afeb74dcf8acb4c3721e0dc7e4294b25),pk_h(03d01115d548e7561b15c38f004d734633687cf4419620095bc5b0f47070afe85a)))\", \"82012088a6146ad07d21fd5dfc646f0b30577045ce201616b9ba876482012088aa208a35d9ca92a48eaade6f53a64985e9e2afeb74dcf8acb4c3721e0dc7e4294b258876a914dd100be7d9aea5721158ebde6d6a1fd8fff93bb1886776a9149fc5dbe5efdce10374a4dd4053c93af5402117188868ac\", TESTMODE_VALID | TESTMODE_NEEDSIG);\n+    Test(\"c:andor(u:ripemd160(6ad07d21fd5dfc646f0b30577045ce201616b9ba),pk_h(03daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729),or_i(pk_h(022f01e5e15cca351daff3843fb70f3c2f0a1bdd05e5af888a67784ef3e10a2a01),pk_h(0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798)))\", \"6382012088a6146ad07d21fd5dfc646f0b30577045ce201616b9ba87670068646376a9149652d86bedf43ad264362e6e6eba6eb764508127886776a914751e76e8199196d454941c45d1b3a323f1433bd688686776a91420d637c1a6404d2227f3561fdbaff5a680dba6488868ac\", TESTMODE_VALID | TESTMODE_NEEDSIG);\n+    Test(\"c:or_i(andor(c:pk_h(03d30199d74fb5a22d47b6e054e2f378cedacffcb89904a61d75d0dbd407143e65),pk_h(022f01e5e15cca351daff3843fb70f3c2f0a1bdd05e5af888a67784ef3e10a2a01),pk_h(02c6047f9441ed7d6d3045406e95c07cd85c778e4b8cef3ca7abac09b95c709ee5)),pk(02d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e))\", \"6376a914fcd35ddacad9f2d5be5e464639441c6065e6955d88ac6476a91406afd46bcdfd22ef94ac122aa11f241244a37ecc886776a9149652d86bedf43ad264362e6e6eba6eb7645081278868672102d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e68ac\", TESTMODE_VALID | TESTMODE_NONMAL | TESTMODE_NEEDSIG);\n+\n+    g_testdata.reset();\n+}\n+\n+BOOST_AUTO_TEST_CASE(random_tests)\n+{\n+    // Initialize precomputed data.\n+    g_testdata.reset(new TestData());\n+\n+    for (int i = 0; i < 1000; ++i) {\n+        bool safe = InsecureRandRange(20) == 0; // In 5% of the cases, generate safe top-level expressions.\n+        // Generate a random B (or Bms) node of variable complexity, which should be valid as a top-level expression.\n+        auto node = RandomNode(safe ? \"Bms\"_mst : \"B\"_mst, 1 + InsecureRandRange(90));\n+        BOOST_CHECK(node && node->IsValid() && node->IsValidTopLevel());\n+        auto script = node->ToScript(CONVERTER);\n+        BOOST_CHECK(node->ScriptSize() == script.size()); // Check consistency between script size estimation and real size\n+        // Check consistency of \"x\" property with the script (relying on the fact that no top-level scripts end with a hash or key push, whose last byte could match these opcodes).\n+        bool ends_in_verify = !(node->GetType() << \"x\"_mst);\n+        BOOST_CHECK(ends_in_verify == (script.back() == OP_CHECKSIG || script.back() == OP_CHECKMULTISIG || script.back() == OP_EQUAL));\n+        std::string str;\n+        BOOST_CHECK(node->ToString(CONVERTER, str)); // Check that we can convert to text\n+        auto parsed = miniscript::FromString(str, CONVERTER);\n+        BOOST_CHECK(parsed); // Check that we can convert back\n+        BOOST_CHECK(*parsed == *node); // Check that it matches the original\n+    }\n+\n+    g_testdata.reset();\n+}\n+\n+BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  },
  {
    "sha": "aeccaad6cabf5ef7ba14c54c76d758b49ea66fdd",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphZWNjYWFkNmNhYmY1ZWY3YmExNGM1NGM3NmQ3NThiNDllYTY2ZmRk",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2019-09-02T02:31:22Z"
      },
      "committer": {
        "name": "practicalswift",
        "email": "practicalswift@users.noreply.github.com",
        "date": "2019-10-23T11:54:49Z"
      },
      "message": "Miniscript: conversion from script",
      "tree": {
        "sha": "aa4e3508ccdfa1643b02de81a984f10badbb8e90",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/aa4e3508ccdfa1643b02de81a984f10badbb8e90"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/aeccaad6cabf5ef7ba14c54c76d758b49ea66fdd",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/aeccaad6cabf5ef7ba14c54c76d758b49ea66fdd",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/aeccaad6cabf5ef7ba14c54c76d758b49ea66fdd",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/aeccaad6cabf5ef7ba14c54c76d758b49ea66fdd/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "57a6c0e853b84b72a7d39cbd37834fcf6416ac40",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/57a6c0e853b84b72a7d39cbd37834fcf6416ac40",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/57a6c0e853b84b72a7d39cbd37834fcf6416ac40"
      }
    ],
    "stats": {
      "total": 312,
      "additions": 312,
      "deletions": 0
    },
    "files": [
      {
        "sha": "10196c5e21ceee3863d42820b4d6a03d832fd005",
        "filename": "src/script/miniscript.cpp",
        "status": "modified",
        "additions": 46,
        "deletions": 0,
        "changes": 46,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/aeccaad6cabf5ef7ba14c54c76d758b49ea66fdd/src/script/miniscript.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/aeccaad6cabf5ef7ba14c54c76d758b49ea66fdd/src/script/miniscript.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/miniscript.cpp?ref=aeccaad6cabf5ef7ba14c54c76d758b49ea66fdd",
        "patch": "@@ -230,5 +230,51 @@ size_t ComputeScriptLen(NodeType nodetype, Type sub0typ, size_t subsize, uint32_\n     return 0;\n }\n \n+bool DecomposeScript(const CScript& script, std::vector<std::pair<opcodetype, std::vector<unsigned char>>>& out)\n+{\n+    out.clear();\n+    CScript::const_iterator it = script.begin(), itend = script.end();\n+    while (it != itend) {\n+        std::vector<unsigned char> push_data;\n+        opcodetype opcode;\n+        if (!script.GetOp(it, opcode, push_data)) {\n+            out.clear();\n+            return false;\n+        } else if (opcode >= OP_1 && opcode <= OP_16) {\n+            // Deal with OP_n (GetOp does not turn them into pushes).\n+            push_data.assign(1, CScript::DecodeOP_N(opcode));\n+        } else if (opcode == OP_CHECKSIGVERIFY) {\n+            // Decompose OP_CHECKSIGVERIFY into OP_CHECKSIG OP_VERIFY\n+            out.emplace_back(OP_CHECKSIG, std::vector<unsigned char>());\n+            opcode = OP_VERIFY;\n+        } else if (opcode == OP_CHECKMULTISIGVERIFY) {\n+            // Decompose OP_CHECKMULTISIGVERIFY into OP_CHECKMULTISIG OP_VERIFY\n+            out.emplace_back(OP_CHECKMULTISIG, std::vector<unsigned char>());\n+            opcode = OP_VERIFY;\n+        } else if (opcode == OP_EQUALVERIFY) {\n+            // Decompose OP_EQUALVERIFY into OP_EQUAL OP_VERIFY\n+            out.emplace_back(OP_EQUAL, std::vector<unsigned char>());\n+            opcode = OP_VERIFY;\n+        }\n+        out.emplace_back(opcode, std::move(push_data));\n+    }\n+    std::reverse(out.begin(), out.end());\n+    return true;\n+}\n+\n+bool ParseScriptNumber(const std::pair<opcodetype, std::vector<unsigned char>>& in, int64_t& k) {\n+    if (in.first == OP_0) {\n+        k = 0;\n+        return true;\n+    }\n+    if (!in.second.empty()) {\n+        try {\n+            k = CScriptNum(in.second, true).GetInt64();\n+            return true;\n+        } catch(const scriptnum_error&) {}\n+    }\n+    return false;\n+}\n+\n } // namespace internal\n } // namespace miniscript"
      },
      {
        "sha": "c53ac4ed44d49cace14c3831ee5f22a5747af45b",
        "filename": "src/script/miniscript.h",
        "status": "modified",
        "additions": 239,
        "deletions": 0,
        "changes": 239,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/aeccaad6cabf5ef7ba14c54c76d758b49ea66fdd/src/script/miniscript.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/aeccaad6cabf5ef7ba14c54c76d758b49ea66fdd/src/script/miniscript.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/miniscript.h?ref=aeccaad6cabf5ef7ba14c54c76d758b49ea66fdd",
        "patch": "@@ -588,6 +588,233 @@ inline NodeRef<Key> Parse(Span<const char>& in, const Ctx& ctx) {\n     return MakeNodeRef<Key>(nodetype, Vector(std::move(left), std::move(right)));\n }\n \n+/** Decode a script into opcode/push pairs.\n+ *\n+ * Construct a vector with one element per opcode in the script, in reverse order.\n+ * Each element is a pair consisting of the opcode, as well as the data pushed by\n+ * the opcode (including OP_n), if any. OP_CHECKSIGVERIFY, OP_CHECKMULTISIGVERIFY,\n+ * and OP_EQUALVERIFY are decomposed into OP_CHECKSIG, OP_CHECKMULTISIG, OP_EQUAL\n+ * respectively, plus OP_VERIFY.\n+ */\n+bool DecomposeScript(const CScript& script, std::vector<std::pair<opcodetype, std::vector<unsigned char>>>& out);\n+\n+/** Determine whether the passed pair (created by DecomposeScript) is pushing a number. */\n+bool ParseScriptNumber(const std::pair<opcodetype, std::vector<unsigned char>>& in, int64_t& k);\n+\n+template<typename Key, typename Ctx, typename I> inline NodeRef<Key> DecodeSingle(I& in, I last, const Ctx& ctx);\n+template<typename Key, typename Ctx, typename I> inline NodeRef<Key> DecodeMulti(I& in, I last, const Ctx& ctx);\n+template<typename Key, typename Ctx, typename I> inline NodeRef<Key> DecodeWrapped(I& in, I last, const Ctx& ctx);\n+\n+//! Decode a list of script elements into a miniscript (except and_v, s:, and a:).\n+template<typename Key, typename Ctx, typename I>\n+inline NodeRef<Key> DecodeSingle(I& in, I last, const Ctx& ctx) {\n+    std::vector<NodeRef<Key>> subs;\n+    std::vector<Key> keys;\n+    int64_t k;\n+\n+    if (last > in && in[0].first == OP_1) {\n+        ++in;\n+        return MakeNodeRef<Key>(NodeType::JUST_1);\n+    }\n+    if (last > in && in[0].first == OP_0) {\n+        ++in;\n+        return MakeNodeRef<Key>(NodeType::JUST_0);\n+    }\n+    if (last > in && in[0].second.size() == 33) {\n+        Key key;\n+        if (!ctx.FromPKBytes(in[0].second.begin(), in[0].second.end(), key)) return {};\n+        ++in;\n+        return MakeNodeRef<Key>(NodeType::PK, Vector(std::move(key)));\n+    }\n+    if (last - in >= 5 && in[0].first == OP_VERIFY && in[1].first == OP_EQUAL && in[3].first == OP_HASH160 && in[4].first == OP_DUP && in[2].second.size() == 20) {\n+        Key key;\n+        if (!ctx.FromPKHBytes(in[2].second.begin(), in[2].second.end(), key)) return {};\n+        in += 5;\n+        return MakeNodeRef<Key>(NodeType::PK_H, Vector(std::move(key)));\n+    }\n+    if (last - in >= 2 && in[0].first == OP_CHECKSEQUENCEVERIFY && ParseScriptNumber(in[1], k)) {\n+        in += 2;\n+        if (k < 1 || k > 0x7FFFFFFFL) return {};\n+        return MakeNodeRef<Key>(NodeType::OLDER, k);\n+    }\n+    if (last - in >= 2 && in[0].first == OP_CHECKLOCKTIMEVERIFY && ParseScriptNumber(in[1], k)) {\n+        in += 2;\n+        if (k < 1 || k > 0x7FFFFFFFL) return {};\n+        return MakeNodeRef<Key>(NodeType::AFTER, k);\n+    }\n+    if (last - in >= 7 && in[0].first == OP_EQUAL && in[1].second.size() == 32 && in[2].first == OP_SHA256 && in[3].first == OP_VERIFY && in[4].first == OP_EQUAL && ParseScriptNumber(in[5], k) && k == 32 && in[6].first == OP_SIZE) {\n+        in += 7;\n+        return MakeNodeRef<Key>(NodeType::SHA256, in[-6].second);\n+    }\n+    if (last - in >= 7 && in[0].first == OP_EQUAL && in[1].second.size() == 20 && in[2].first == OP_RIPEMD160 && in[3].first == OP_VERIFY && in[4].first == OP_EQUAL && ParseScriptNumber(in[5], k) && k == 32 && in[6].first == OP_SIZE) {\n+        in += 7;\n+        return MakeNodeRef<Key>(NodeType::RIPEMD160, in[-6].second);\n+    }\n+    if (last - in >= 7 && in[0].first == OP_EQUAL && in[1].second.size() == 32 && in[2].first == OP_HASH256 && in[3].first == OP_VERIFY && in[4].first == OP_EQUAL && ParseScriptNumber(in[5], k) && k == 32 && in[6].first == OP_SIZE) {\n+        in += 7;\n+        return MakeNodeRef<Key>(NodeType::HASH256, in[-6].second);\n+    }\n+    if (last - in >= 7 && in[0].first == OP_EQUAL && in[1].second.size() == 20 && in[2].first == OP_HASH160 && in[3].first == OP_VERIFY && in[4].first == OP_EQUAL && ParseScriptNumber(in[5], k) && k == 32 && in[6].first == OP_SIZE) {\n+        in += 7;\n+        return MakeNodeRef<Key>(NodeType::HASH160, in[-6].second);\n+    }\n+    if (last - in >= 2 && in[0].first == OP_CHECKSIG) {\n+        ++in;\n+        auto sub = DecodeSingle<Key>(in, last, ctx);\n+        if (!sub) return {};\n+        return MakeNodeRef<Key>(NodeType::WRAP_C, Vector(std::move(sub)));\n+    }\n+    if (last - in >= 3 && in[0].first == OP_BOOLAND) {\n+        ++in;\n+        auto sub1 = DecodeWrapped<Key>(in, last, ctx);\n+        if (!sub1) return {};\n+        auto sub2 = DecodeSingle<Key>(in, last, ctx);\n+        if (!sub2) return {};\n+        return MakeNodeRef<Key>(NodeType::AND_B, Vector(std::move(sub2), std::move(sub1)));\n+    }\n+    if (last - in >= 3 && in[0].first == OP_BOOLOR) {\n+        ++in;\n+        auto sub1 = DecodeWrapped<Key>(in, last, ctx);\n+        if (!sub1) return {};\n+        auto sub2 = DecodeSingle<Key>(in, last, ctx);\n+        if (!sub2) return {};\n+        return MakeNodeRef<Key>(NodeType::OR_B, Vector(std::move(sub2), std::move(sub1)));\n+    }\n+    if (last - in >= 2 && in[0].first == OP_VERIFY) {\n+        ++in;\n+        auto sub = DecodeSingle<Key>(in, last, ctx);\n+        if (!sub) return {};\n+        return MakeNodeRef<Key>(NodeType::WRAP_V, Vector(std::move(sub)));\n+    }\n+    if (last - in >= 2 && in[0].first == OP_0NOTEQUAL) {\n+        ++in;\n+        auto sub = DecodeSingle<Key>(in, last, ctx);\n+        if (!sub) return {};\n+        return MakeNodeRef<Key>(NodeType::WRAP_N, Vector(std::move(sub)));\n+    }\n+    if (last > in && in[0].first == OP_ENDIF) {\n+        ++in;\n+        if (last - in == 0) return {};\n+        NodeRef<Key> sub1;\n+        sub1 = DecodeMulti<Key>(in, last, ctx);\n+        if (!sub1) return {};\n+        bool have_else = false;\n+        NodeRef<Key> sub2;\n+        if (last - in == 0) return {};\n+        if (in[0].first == OP_ELSE) {\n+            ++in;\n+            have_else = true;\n+            sub2 = DecodeMulti<Key>(in, last, ctx);\n+            if (!sub2) return {};\n+        }\n+        if (last - in == 0 || (in[0].first != OP_IF && in[0].first != OP_NOTIF)) return {};\n+        bool negated = (in[0].first == OP_NOTIF);\n+        ++in;\n+\n+        if (!have_else && !negated) {\n+            if (last > in && in[0].first == OP_DUP) {\n+                ++in;\n+                return MakeNodeRef<Key>(NodeType::WRAP_D, Vector(std::move(sub1)));\n+            }\n+            if (last - in >= 2 && in[0].first == OP_0NOTEQUAL && in[1].first == OP_SIZE) {\n+                in += 2;\n+                return MakeNodeRef<Key>(NodeType::WRAP_J, Vector(std::move(sub1)));\n+            }\n+            return {};\n+        }\n+        if (have_else && negated) {\n+            auto sub3 = DecodeSingle<Key>(in, last, ctx);\n+            if (!sub3) return {};\n+            return MakeNodeRef<Key>(NodeType::ANDOR, Vector(std::move(sub3), std::move(sub1), std::move(sub2)));\n+        }\n+        if (!have_else && negated) {\n+            if (last - in >= 2 && in[0].first == OP_IFDUP) {\n+                ++in;\n+                auto sub3 = DecodeSingle<Key>(in, last, ctx);\n+                if (!sub3) return {};\n+                return MakeNodeRef<Key>(NodeType::OR_D, Vector(std::move(sub3), std::move(sub1)));\n+            }\n+            if (last > in) {\n+                auto sub3 = DecodeSingle<Key>(in, last, ctx);\n+                if (!sub3) return {};\n+                return MakeNodeRef<Key>(NodeType::OR_C, Vector(std::move(sub3), std::move(sub1)));\n+            }\n+            return {};\n+        }\n+        if (have_else && !negated) {\n+            return MakeNodeRef<Key>(NodeType::OR_I, Vector(std::move(sub2), std::move(sub1)));\n+        }\n+        return {};\n+    }\n+    keys.clear();\n+    if (last - in >= 3 && in[0].first == OP_CHECKMULTISIG) {\n+        int64_t n;\n+        if (!ParseScriptNumber(in[1], n)) return {};\n+        if (last - in < 3 + n) return {};\n+        if (n < 1 || n > 20) return {};\n+        for (int i = 0; i < n; ++i) {\n+            Key key;\n+            if (in[2 + i].second.size() != 33) return {};\n+            if (!ctx.FromPKBytes(in[2 + i].second.begin(), in[2 + i].second.end(), key)) return {};\n+            keys.push_back(std::move(key));\n+        }\n+        if (!ParseScriptNumber(in[2 + n], k)) return {};\n+        if (k < 1 || k > n) return {};\n+        in += 3 + n;\n+        std::reverse(keys.begin(), keys.end());\n+        return MakeNodeRef<Key>(NodeType::THRESH_M, std::move(keys), k);\n+    }\n+    subs.clear();\n+    if (last - in >= 3 && in[0].first == OP_EQUAL && ParseScriptNumber(in[1], k)) {\n+        in += 2;\n+        while (last - in >= 2 && in[0].first == OP_ADD) {\n+            ++in;\n+            auto sub = DecodeWrapped<Key>(in, last, ctx);\n+            if (!sub) return {};\n+            subs.push_back(std::move(sub));\n+        }\n+        auto sub = DecodeSingle<Key>(in, last, ctx);\n+        if (!sub) return {};\n+        subs.push_back(std::move(sub));\n+        std::reverse(subs.begin(), subs.end());\n+        return MakeNodeRef<Key>(NodeType::THRESH, std::move(subs), k);\n+    }\n+\n+    return {};\n+}\n+\n+//! Decode a list of script elements into a miniscript (except a: and s:)\n+template<typename Key, typename Ctx, typename I>\n+inline NodeRef<Key> DecodeMulti(I& in, I last, const Ctx& ctx) {\n+    if (in == last) return {};\n+    auto sub = DecodeSingle<Key>(in, last, ctx);\n+    if (!sub) return {};\n+    while (in != last && in[0].first != OP_ELSE && in[0].first != OP_IF && in[0].first != OP_NOTIF && in[0].first != OP_TOALTSTACK && in[0].first != OP_SWAP) {\n+        auto sub2 = DecodeSingle<Key>(in, last, ctx);\n+        if (!sub2) return {};\n+        sub = MakeNodeRef<Key>(NodeType::AND_V, Vector(std::move(sub2), std::move(sub)));\n+    }\n+    return sub;\n+}\n+\n+//! Decode a list of script elements into a miniscript (only a: and s:)\n+template<typename Key, typename Ctx, typename I>\n+inline NodeRef<Key> DecodeWrapped(I& in, I last, const Ctx& ctx) {\n+    if (last - in >= 3 && in[0].first == OP_FROMALTSTACK) {\n+        ++in;\n+        auto sub = DecodeMulti<Key>(in, last, ctx);\n+        if (!sub) return {};\n+        if (in == last || in[0].first != OP_TOALTSTACK) return {};\n+        ++in;\n+        return MakeNodeRef<Key>(NodeType::WRAP_A, Vector(std::move(sub)));\n+    }\n+    auto sub = DecodeMulti<Key>(in, last, ctx);\n+    if (!sub) return {};\n+    if (in == last || in[0].first != OP_SWAP) return {};\n+    ++in;\n+    return MakeNodeRef<Key>(NodeType::WRAP_S, Vector(std::move(sub)));\n+}\n+\n } // namespace internal\n \n template<typename Ctx>\n@@ -599,6 +826,18 @@ inline NodeRef<typename Ctx::Key> FromString(const std::string& str, const Ctx&\n     return ret;\n }\n \n+template<typename Ctx>\n+inline NodeRef<typename Ctx::Key> FromScript(const CScript& script, const Ctx& ctx) {\n+    using namespace internal;\n+    std::vector<std::pair<opcodetype, std::vector<unsigned char>>> decomposed;\n+    if (!DecomposeScript(script, decomposed)) return {};\n+    auto it = decomposed.begin();\n+    auto ret = DecodeMulti<typename Ctx::Key>(it, decomposed.end(), ctx);\n+    if (!ret) return {};\n+    if (it != decomposed.end()) return {};\n+    return ret;\n+}\n+\n } // namespace miniscript\n \n #endif // BITCOIN_SCRIPT_MINISCRIPT_H"
      },
      {
        "sha": "e94122c54e68880d4bfcbb395b39de531bdb6d6b",
        "filename": "src/test/miniscript_tests.cpp",
        "status": "modified",
        "additions": 27,
        "deletions": 0,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/aeccaad6cabf5ef7ba14c54c76d758b49ea66fdd/src/test/miniscript_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/aeccaad6cabf5ef7ba14c54c76d758b49ea66fdd/src/test/miniscript_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/miniscript_tests.cpp?ref=aeccaad6cabf5ef7ba14c54c76d758b49ea66fdd",
        "patch": "@@ -23,6 +23,7 @@ struct TestData {\n     std::vector<CPubKey> pubkeys;\n     //! A map from the public keys to their CKeyIDs (faster than hashing every time).\n     std::map<CPubKey, CKeyID> pkhashes;\n+    std::map<CKeyID, CPubKey> pkmap;\n \n     // Various precomputed hashes\n     std::vector<std::vector<unsigned char>> sha256;\n@@ -45,6 +46,7 @@ struct TestData {\n             CKeyID keyid = pubkey.GetID();\n             pubkeys.push_back(pubkey);\n             pkhashes.emplace(pubkey, keyid);\n+            pkmap.emplace(keyid, pubkey);\n \n             // Compute various hashes\n             std::vector<unsigned char> hash;\n@@ -90,6 +92,23 @@ struct KeyConverter {\n         key.Set(bytes.begin(), bytes.end());\n         return key.IsValid();\n     }\n+\n+    template<typename I>\n+    bool FromPKBytes(I first, I last, CPubKey& key) const {\n+        key.Set(first, last);\n+        return key.IsValid();\n+    }\n+\n+    template<typename I>\n+    bool FromPKHBytes(I first, I last, CPubKey& key) const {\n+        assert(last - first == 20);\n+        CKeyID keyid;\n+        std::copy(first, last, keyid.begin());\n+        auto it = g_testdata->pkmap.find(keyid);\n+        assert(it != g_testdata->pkmap.end());\n+        key = it->second;\n+        return true;\n+    }\n };\n \n //! Singleton instance of KeyConverter.\n@@ -250,6 +269,9 @@ void Test(const std::string& ms, const std::string& hexscript, int mode)\n         if (hexscript != \"?\") BOOST_CHECK_MESSAGE(HexStr(computed_script) == hexscript, \"Script mismatch: \" + ms + \" (\" + HexStr(computed_script) + \" vs \" + hexscript + \")\");\n         BOOST_CHECK_MESSAGE(node->IsNonMalleable() == !!(mode & TESTMODE_NONMAL), \"Malleability mismatch: \" + ms);\n         BOOST_CHECK_MESSAGE(node->NeedsSignature() == !!(mode & TESTMODE_NEEDSIG), \"Signature necessity mismatch: \" + ms);\n+        auto inferred_miniscript = miniscript::FromScript(computed_script, CONVERTER);\n+        BOOST_CHECK_MESSAGE(inferred_miniscript, \"Cannot infer miniscript from script: \" + ms);\n+        BOOST_CHECK_MESSAGE(inferred_miniscript->ToScript(CONVERTER) == computed_script, \"Roundtrip failure: miniscript->script != miniscript->script->miniscript->script: \" + ms);\n     }\n \n }\n@@ -316,6 +338,11 @@ BOOST_AUTO_TEST_CASE(random_tests)\n         auto parsed = miniscript::FromString(str, CONVERTER);\n         BOOST_CHECK(parsed); // Check that we can convert back\n         BOOST_CHECK(*parsed == *node); // Check that it matches the original\n+        auto decoded = miniscript::FromScript(script, CONVERTER);\n+        BOOST_CHECK(decoded); // Check that we can decode the miniscript back from the script.\n+        // Check that it matches the original (we can't use *decoded == *node because the miniscript representation may differ)\n+        BOOST_CHECK(decoded->ToScript(CONVERTER) == script); // The script corresponding to that decoded form must match exactly.\n+        BOOST_CHECK(decoded->GetType() == node->GetType()); // The type also has to match exactly.\n     }\n \n     g_testdata.reset();"
      }
    ]
  },
  {
    "sha": "a4471ad5b553a65cbc1e468b5ef02ced713ddd4d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphNDQ3MWFkNWI1NTNhNjVjYmMxZTQ2OGI1ZWYwMmNlZDcxM2RkZDRk",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2019-08-29T21:16:27Z"
      },
      "committer": {
        "name": "practicalswift",
        "email": "practicalswift@users.noreply.github.com",
        "date": "2019-10-23T11:54:49Z"
      },
      "message": "Miniscript: ops limit and stack size computation",
      "tree": {
        "sha": "8822818944a44af6f677bab6f908a7c65e877fd5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8822818944a44af6f677bab6f908a7c65e877fd5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a4471ad5b553a65cbc1e468b5ef02ced713ddd4d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a4471ad5b553a65cbc1e468b5ef02ced713ddd4d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a4471ad5b553a65cbc1e468b5ef02ced713ddd4d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a4471ad5b553a65cbc1e468b5ef02ced713ddd4d/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "aeccaad6cabf5ef7ba14c54c76d758b49ea66fdd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/aeccaad6cabf5ef7ba14c54c76d758b49ea66fdd",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/aeccaad6cabf5ef7ba14c54c76d758b49ea66fdd"
      }
    ],
    "stats": {
      "total": 221,
      "additions": 183,
      "deletions": 38
    },
    "files": [
      {
        "sha": "7994c616ab353e6c977b21ca1c565427b824b678",
        "filename": "src/script/miniscript.h",
        "status": "modified",
        "additions": 151,
        "deletions": 7,
        "changes": 158,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a4471ad5b553a65cbc1e468b5ef02ced713ddd4d/src/script/miniscript.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a4471ad5b553a65cbc1e468b5ef02ced713ddd4d/src/script/miniscript.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/miniscript.h?ref=a4471ad5b553a65cbc1e468b5ef02ced713ddd4d",
        "patch": "@@ -14,6 +14,7 @@\n #include <stdlib.h>\n #include <assert.h>\n \n+#include <policy/policy.h>\n #include <script/script.h>\n #include <span.h>\n #include <util/spanparsing.h>\n@@ -203,6 +204,47 @@ size_t ComputeScriptLen(NodeType nodetype, Type sub0typ, size_t subsize, uint32_\n //! A helper sanitizer/checker for the output of CalcType.\n Type SanitizeType(Type x);\n \n+//! Class whose objects represent the maximum of a list of integers.\n+template<typename I>\n+struct MaxInt {\n+    const bool valid;\n+    const I value;\n+\n+    MaxInt() : valid(false), value(0) {}\n+    MaxInt(I val) : valid(true), value(val) {}\n+\n+    friend MaxInt<I> operator+(const MaxInt<I>& a, const MaxInt<I>& b) {\n+        if (!a.valid || !b.valid) return {};\n+        return a.value + b.value;\n+    }\n+\n+    friend MaxInt<I> Choose(const MaxInt<I>& a, const MaxInt<I>& b) {\n+        if (!a.valid) return b;\n+        if (!b.valid) return a;\n+        return std::max(a.value, b.value);\n+    }\n+};\n+\n+struct Ops {\n+    //! Non-push opcodes.\n+    uint32_t stat;\n+    //! Number of keys in possibly executed OP_CHECKMULTISIG(VERIFY)s to satisfy.\n+    MaxInt<uint32_t> sat;\n+    //! Number of keys in possibly executed OP_CHECKMULTISIG(VERIFY)s to dissatisfy.\n+    MaxInt<uint32_t> dsat;\n+\n+    Ops(uint32_t in_stat, MaxInt<uint32_t> in_sat, MaxInt<uint32_t> in_dsat) : stat(in_stat), sat(in_sat), dsat(in_dsat) {};\n+};\n+\n+struct StackSize {\n+    //! Maximum stack size to satisfy;\n+    MaxInt<uint32_t> sat;\n+    //! Maximum stack size to dissatisfy;\n+    MaxInt<uint32_t> dsat;\n+\n+    StackSize(MaxInt<uint32_t> in_sat, MaxInt<uint32_t> in_dsat) : sat(in_sat), dsat(in_dsat) {};\n+};\n+\n } // namespace internal\n \n //! A node in a miniscript expression.\n@@ -220,6 +262,10 @@ struct Node {\n     const std::vector<NodeRef<Key>> subs;\n \n private:\n+    //! Cached ops counts.\n+    const internal::Ops ops;\n+    //! Cached stack size bounds.\n+    const internal::StackSize ss;\n     //! Cached expression type (computed by CalcType and fed through SanitizeType).\n     const Type typ;\n     //! Cached script length (computed by CalcScriptLen).\n@@ -375,10 +421,108 @@ struct Node {\n         return \"\";\n     }\n \n+    internal::Ops CalcOps() const {\n+        switch (nodetype) {\n+            case NodeType::PK: return {0, 0, 0};\n+            case NodeType::PK_H: return {3, 0, 0};\n+            case NodeType::OLDER: return {1, 0, {}};\n+            case NodeType::AFTER: return {1, 0, {}};\n+            case NodeType::SHA256: return {4, 0, {}};\n+            case NodeType::RIPEMD160: return {4, 0, {}};\n+            case NodeType::HASH256: return {4, 0, {}};\n+            case NodeType::HASH160: return {4, 0, {}};\n+            case NodeType::AND_V: return {subs[0]->ops.stat + subs[1]->ops.stat, subs[0]->ops.sat + subs[1]->ops.sat, {}};\n+            case NodeType::AND_B: return {1 + subs[0]->ops.stat + subs[1]->ops.stat, subs[0]->ops.sat + subs[1]->ops.sat, subs[0]->ops.dsat + subs[1]->ops.dsat};\n+            case NodeType::OR_B: return {1 + subs[0]->ops.stat + subs[1]->ops.stat, Choose(subs[0]->ops.sat + subs[1]->ops.dsat, subs[1]->ops.sat + subs[0]->ops.dsat), subs[0]->ops.dsat + subs[1]->ops.dsat};\n+            case NodeType::OR_D: return {3 + subs[0]->ops.stat + subs[1]->ops.stat, Choose(subs[0]->ops.sat, subs[1]->ops.sat + subs[0]->ops.dsat), subs[0]->ops.dsat + subs[1]->ops.dsat};\n+            case NodeType::OR_C: return {2 + subs[0]->ops.stat + subs[1]->ops.stat, Choose(subs[0]->ops.sat, subs[1]->ops.sat + subs[0]->ops.dsat), {}};\n+            case NodeType::OR_I: return {3 + subs[0]->ops.stat + subs[1]->ops.stat, Choose(subs[0]->ops.sat, subs[1]->ops.sat), Choose(subs[0]->ops.dsat, subs[1]->ops.dsat)};\n+            case NodeType::ANDOR: return {3 + subs[0]->ops.stat + subs[1]->ops.stat + subs[2]->ops.stat, Choose(subs[1]->ops.sat + subs[0]->ops.sat, subs[0]->ops.dsat + subs[2]->ops.sat), subs[0]->ops.dsat + subs[2]->ops.dsat};\n+            case NodeType::THRESH_M: return {1, (uint32_t)keys.size(), (uint32_t)keys.size()};\n+            case NodeType::WRAP_A: return {2 + subs[0]->ops.stat, subs[0]->ops.sat, subs[0]->ops.dsat};\n+            case NodeType::WRAP_S: return {1 + subs[0]->ops.stat, subs[0]->ops.sat, subs[0]->ops.dsat};\n+            case NodeType::WRAP_C: return {1 + subs[0]->ops.stat, subs[0]->ops.sat, subs[0]->ops.dsat};\n+            case NodeType::WRAP_D: return {3 + subs[0]->ops.stat, subs[0]->ops.sat, 0};\n+            case NodeType::WRAP_V: return {subs[0]->ops.stat + (subs[0]->GetType() << \"x\"_mst), subs[0]->ops.sat, {}};\n+            case NodeType::WRAP_J: return {4 + subs[0]->ops.stat, subs[0]->ops.sat, 0};\n+            case NodeType::WRAP_N: return {1 + subs[0]->ops.stat, subs[0]->ops.sat, subs[0]->ops.dsat};\n+            case NodeType::JUST_1: return {0, 0, {}};\n+            case NodeType::JUST_0: return {0, {}, 0};\n+            case NodeType::THRESH: {\n+                uint32_t stat = 0;\n+                auto sats = Vector(internal::MaxInt<uint32_t>(0));\n+                for (const auto& sub : subs) {\n+                    stat += sub->ops.stat + 1;\n+                    auto next_sats = Vector(sats[0] + sub->ops.dsat);\n+                    for (size_t j = 1; j < sats.size(); ++j) next_sats.push_back(Choose(sats[j] + sub->ops.dsat, sats[j - 1] + sub->ops.sat));\n+                    next_sats.push_back(sats[sats.size() - 1] + sub->ops.sat);\n+                    sats = std::move(next_sats);\n+                }\n+                return {stat, sats[k], sats[0]};\n+            }\n+        }\n+        assert(false);\n+        return {0, {}, {}};\n+    }\n+\n+    internal::StackSize CalcStackSize() const {\n+        switch (nodetype) {\n+            case NodeType::PK: return {1, 1};\n+            case NodeType::PK_H: return {2, 2};\n+            case NodeType::OLDER: return {0, {}};\n+            case NodeType::AFTER: return {0, {}};\n+            case NodeType::SHA256: return {1, {}};\n+            case NodeType::RIPEMD160: return {1, {}};\n+            case NodeType::HASH256: return {1, {}};\n+            case NodeType::HASH160: return {1, {}};\n+            case NodeType::ANDOR: return {Choose(subs[0]->ss.sat + subs[1]->ss.sat, subs[0]->ss.dsat + subs[2]->ss.sat), subs[0]->ss.dsat + subs[2]->ss.dsat};\n+            case NodeType::AND_V: return {subs[0]->ss.sat + subs[1]->ss.sat, {}};\n+            case NodeType::AND_B: return {subs[0]->ss.sat + subs[1]->ss.sat, subs[0]->ss.dsat + subs[1]->ss.dsat};\n+            case NodeType::OR_B: return {Choose(subs[0]->ss.dsat + subs[1]->ss.sat, subs[0]->ss.sat + subs[1]->ss.dsat), subs[0]->ss.dsat + subs[1]->ss.dsat};\n+            case NodeType::OR_C: return {Choose(subs[0]->ss.sat, subs[0]->ss.dsat + subs[1]->ss.sat), {}};\n+            case NodeType::OR_D: return {Choose(subs[0]->ss.sat, subs[0]->ss.dsat + subs[1]->ss.sat), subs[0]->ss.dsat + subs[1]->ss.dsat};\n+            case NodeType::OR_I: return {Choose(subs[0]->ss.sat + 1, subs[1]->ss.sat + 1), Choose(subs[0]->ss.dsat + 1, subs[1]->ss.dsat + 1)};\n+            case NodeType::THRESH_M: return {(uint32_t)keys.size() + 1, (uint32_t)keys.size() + 1};\n+            case NodeType::WRAP_A: return subs[0]->ss;\n+            case NodeType::WRAP_S: return subs[0]->ss;\n+            case NodeType::WRAP_C: return subs[0]->ss;\n+            case NodeType::WRAP_D: return {1 + subs[0]->ss.sat, 1};\n+            case NodeType::WRAP_V: return {subs[0]->ss.sat, {}};\n+            case NodeType::WRAP_J: return {subs[0]->ss.sat, 1};\n+            case NodeType::WRAP_N: return subs[0]->ss;\n+            case NodeType::JUST_1: return {0, {}};\n+            case NodeType::JUST_0: return {{}, 0};\n+            case NodeType::THRESH: {\n+                auto sats = Vector(internal::MaxInt<uint32_t>(0));\n+                for (const auto& sub : subs) {\n+                    auto next_sats = Vector(sats[0] + sub->ss.dsat);\n+                    for (size_t j = 1; j < sats.size(); ++j) next_sats.push_back(Choose(sats[j] + sub->ss.dsat, sats[j - 1] + sub->ss.sat));\n+                    next_sats.push_back(sats[sats.size() - 1] + sub->ss.sat);\n+                    sats = std::move(next_sats);\n+                }\n+                return {sats[k], sats[0]};\n+            }\n+        }\n+        assert(false);\n+        return {{}, {}};\n+    }\n+\n public:\n     //! Return the size of the script for this expression (faster than ToString().size()).\n     size_t ScriptSize() const { return scriptlen; }\n \n+    //! Return the maximum number of ops needed to satisfy this script non-malleably.\n+    uint32_t GetOps() const { return ops.stat + ops.sat.value; }\n+\n+    //! Check the ops limit of this script against the consensus limit.\n+    bool CheckOpsLimit() const { return GetOps() <= MAX_OPS_PER_SCRIPT; }\n+\n+    //! Return the maximum number of stack elements needed to satisfy this script non-malleably.\n+    uint32_t GetStackSize() const { return ss.sat.value; }\n+\n+    //! Check the maximum stack size for this script against the policy limit.\n+    bool CheckStackSize() const { return GetStackSize() <= MAX_STANDARD_P2WSH_STACK_ITEMS; }\n+\n     //! Return the expression type.\n     Type GetType() const { return typ; }\n \n@@ -395,7 +539,7 @@ struct Node {\n     bool NeedsSignature() const { return GetType() << \"s\"_mst; }\n \n     //! Do all sanity checks.\n-    bool IsSafeTopLevel() const { return GetType() << \"Bms\"_mst; }\n+    bool IsSafeTopLevel() const { return GetType() << \"Bms\"_mst && CheckOpsLimit() && CheckStackSize(); }\n \n     //! Construct the script for this miniscript (including subexpressions).\n     template<typename Ctx>\n@@ -427,12 +571,12 @@ struct Node {\n     }\n \n     // Constructors with various argument combinations.\n-    Node(NodeType nt, std::vector<NodeRef<Key>> sub, std::vector<unsigned char> arg, uint32_t val = 0) : nodetype(nt), k(val), data(std::move(arg)), subs(std::move(sub)), typ(CalcType()), scriptlen(CalcScriptLen()) {}\n-    Node(NodeType nt, std::vector<unsigned char> arg, uint32_t val = 0) : nodetype(nt), k(val), data(std::move(arg)), typ(CalcType()), scriptlen(CalcScriptLen()) {}\n-    Node(NodeType nt, std::vector<NodeRef<Key>> sub, std::vector<Key> key, uint32_t val = 0) : nodetype(nt), k(val), keys(std::move(key)), subs(std::move(sub)), typ(CalcType()), scriptlen(CalcScriptLen()) {}\n-    Node(NodeType nt, std::vector<Key> key, uint32_t val = 0) : nodetype(nt), k(val), keys(std::move(key)), typ(CalcType()), scriptlen(CalcScriptLen()) {}\n-    Node(NodeType nt, std::vector<NodeRef<Key>> sub, uint32_t val = 0) : nodetype(nt), k(val), subs(std::move(sub)), typ(CalcType()), scriptlen(CalcScriptLen()) {}\n-    Node(NodeType nt, uint32_t val = 0) : nodetype(nt), k(val), typ(CalcType()), scriptlen(CalcScriptLen()) {}\n+    Node(NodeType nt, std::vector<NodeRef<Key>> sub, std::vector<unsigned char> arg, uint32_t val = 0) : nodetype(nt), k(val), data(std::move(arg)), subs(std::move(sub)), ops(CalcOps()), ss(CalcStackSize()), typ(CalcType()), scriptlen(CalcScriptLen()) {}\n+    Node(NodeType nt, std::vector<unsigned char> arg, uint32_t val = 0) : nodetype(nt), k(val), data(std::move(arg)), ops(CalcOps()), ss(CalcStackSize()), typ(CalcType()), scriptlen(CalcScriptLen()) {}\n+    Node(NodeType nt, std::vector<NodeRef<Key>> sub, std::vector<Key> key, uint32_t val = 0) : nodetype(nt), k(val), keys(std::move(key)), subs(std::move(sub)), ops(CalcOps()), ss(CalcStackSize()), typ(CalcType()), scriptlen(CalcScriptLen()) {}\n+    Node(NodeType nt, std::vector<Key> key, uint32_t val = 0) : nodetype(nt), k(val), keys(std::move(key)), ops(CalcOps()), ss(CalcStackSize()), typ(CalcType()), scriptlen(CalcScriptLen()) {}\n+    Node(NodeType nt, std::vector<NodeRef<Key>> sub, uint32_t val = 0) : nodetype(nt), k(val), subs(std::move(sub)), ops(CalcOps()), ss(CalcStackSize()), typ(CalcType()), scriptlen(CalcScriptLen()) {}\n+    Node(NodeType nt, uint32_t val = 0) : nodetype(nt), k(val), ops(CalcOps()), ss(CalcStackSize()), typ(CalcType()), scriptlen(CalcScriptLen()) {}\n };\n \n namespace internal {"
      },
      {
        "sha": "a4993489f9ebb80f24f36c3dd2aa2bf0cb1b0bdb",
        "filename": "src/test/miniscript_tests.cpp",
        "status": "modified",
        "additions": 32,
        "deletions": 31,
        "changes": 63,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a4471ad5b553a65cbc1e468b5ef02ced713ddd4d/src/test/miniscript_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a4471ad5b553a65cbc1e468b5ef02ced713ddd4d/src/test/miniscript_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/miniscript_tests.cpp?ref=a4471ad5b553a65cbc1e468b5ef02ced713ddd4d",
        "patch": "@@ -255,7 +255,7 @@ enum TestMode : int {\n     TESTMODE_NEEDSIG = 4\n };\n \n-void Test(const std::string& ms, const std::string& hexscript, int mode)\n+void Test(const std::string& ms, const std::string& hexscript, int mode, int opslimit = -1, int stacklimit = -1)\n {\n     auto node = miniscript::FromString(ms, CONVERTER);\n     if (mode == TESTMODE_INVALID) {\n@@ -272,8 +272,9 @@ void Test(const std::string& ms, const std::string& hexscript, int mode)\n         auto inferred_miniscript = miniscript::FromScript(computed_script, CONVERTER);\n         BOOST_CHECK_MESSAGE(inferred_miniscript, \"Cannot infer miniscript from script: \" + ms);\n         BOOST_CHECK_MESSAGE(inferred_miniscript->ToScript(CONVERTER) == computed_script, \"Roundtrip failure: miniscript->script != miniscript->script->miniscript->script: \" + ms);\n+        if (opslimit != -1) BOOST_CHECK_MESSAGE((int)node->GetOps() == opslimit, \"Ops limit mismatch: \" + ms + \" (\" + std::to_string(node->GetOps()) + \" vs \" + std::to_string(opslimit) + \")\");\n+        if (stacklimit != -1) BOOST_CHECK_MESSAGE((int)node->GetStackSize() == stacklimit, \"Stack limit mismatch: \" + ms + \" (\" + std::to_string(node->GetStackSize()) + \" vs \" + std::to_string(stacklimit) + \")\");\n     }\n-\n }\n \n } // namespace\n@@ -285,35 +286,35 @@ BOOST_AUTO_TEST_CASE(fixed_tests)\n     g_testdata.reset(new TestData());\n \n     // Randomly generated test set that covers the majority of type and node type combinations\n-    Test(\"lltvln:after(1231488000)\", \"6300676300676300670400046749b1926869516868\", TESTMODE_VALID | TESTMODE_NONMAL);\n-    Test(\"uuj:and_v(v:thresh_m(2,03d01115d548e7561b15c38f004d734633687cf4419620095bc5b0f47070afe85a,025601570cb47f238d2b0286db4a990fa0f3ba28d1a319f5e7cf55c2a2444da7cc),after(1231488000))\", \"6363829263522103d01115d548e7561b15c38f004d734633687cf4419620095bc5b0f47070afe85a21025601570cb47f238d2b0286db4a990fa0f3ba28d1a319f5e7cf55c2a2444da7cc52af0400046749b168670068670068\", TESTMODE_VALID | TESTMODE_NONMAL | TESTMODE_NEEDSIG);\n-    Test(\"or_b(un:thresh_m(2,03daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729,024ce119c96e2fa357200b559b2f7dd5a5f02d5290aff74b03f3e471b273211c97),al:older(16))\", \"63522103daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee872921024ce119c96e2fa357200b559b2f7dd5a5f02d5290aff74b03f3e471b273211c9752ae926700686b63006760b2686c9b\", TESTMODE_VALID);\n-    Test(\"j:and_v(vdv:after(1567547623),older(2016))\", \"829263766304e7e06e5db169686902e007b268\", TESTMODE_VALID | TESTMODE_NONMAL);\n-    Test(\"t:and_v(vu:hash256(131772552c01444cd81360818376a040b7c3b2b7b0a53550ee3edde216cec61b),v:sha256(ec4916dd28fc4c10d78e287ca5d9cc51ee1ae73cbfde08c6b37324cbfaac8bc5))\", \"6382012088aa20131772552c01444cd81360818376a040b7c3b2b7b0a53550ee3edde216cec61b876700686982012088a820ec4916dd28fc4c10d78e287ca5d9cc51ee1ae73cbfde08c6b37324cbfaac8bc58851\", TESTMODE_VALID | TESTMODE_NONMAL);\n-    Test(\"t:andor(thresh_m(3,02d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e,03fff97bd5755eeea420453a14355235d382f6472f8568a18b2f057a1460297556,02e493dbf1c10d80f3581e4904930b1404cc6c13900ee0758474fa94abe8c4cd13),v:older(4194305),v:sha256(9267d3dbed802941483f1afa2a6bc68de5f653128aca9bf1461c5d0a3ad36ed2))\", \"532102d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e2103fff97bd5755eeea420453a14355235d382f6472f8568a18b2f057a14602975562102e493dbf1c10d80f3581e4904930b1404cc6c13900ee0758474fa94abe8c4cd1353ae6482012088a8209267d3dbed802941483f1afa2a6bc68de5f653128aca9bf1461c5d0a3ad36ed2886703010040b2696851\", TESTMODE_VALID | TESTMODE_NONMAL);\n-    Test(\"or_d(thresh_m(1,02f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9),or_b(thresh_m(3,022f01e5e15cca351daff3843fb70f3c2f0a1bdd05e5af888a67784ef3e10a2a01,032fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f,03d01115d548e7561b15c38f004d734633687cf4419620095bc5b0f47070afe85a),su:after(500000)))\", \"512102f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f951ae73645321022f01e5e15cca351daff3843fb70f3c2f0a1bdd05e5af888a67784ef3e10a2a0121032fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f2103d01115d548e7561b15c38f004d734633687cf4419620095bc5b0f47070afe85a53ae7c630320a107b16700689b68\", TESTMODE_VALID | TESTMODE_NONMAL);\n-    Test(\"or_d(sha256(38df1c1f64a24a77b23393bca50dff872e31edc4f3b5aa3b90ad0b82f4f089b6),and_n(un:after(499999999),older(4194305)))\", \"82012088a82038df1c1f64a24a77b23393bca50dff872e31edc4f3b5aa3b90ad0b82f4f089b68773646304ff64cd1db19267006864006703010040b26868\", TESTMODE_VALID);\n-    Test(\"and_v(or_i(v:thresh_m(2,02c6047f9441ed7d6d3045406e95c07cd85c778e4b8cef3ca7abac09b95c709ee5,03774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb),v:thresh_m(2,03e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a,025cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc)),sha256(d1ec675902ef1633427ca360b290b0b3045a0d9058ddb5e648b4c3c3224c5c68))\", \"63522102c6047f9441ed7d6d3045406e95c07cd85c778e4b8cef3ca7abac09b95c709ee52103774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb52af67522103e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a21025cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc52af6882012088a820d1ec675902ef1633427ca360b290b0b3045a0d9058ddb5e648b4c3c3224c5c6887\", TESTMODE_VALID | TESTMODE_NONMAL | TESTMODE_NEEDSIG);\n-    Test(\"j:and_b(thresh_m(2,0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798,024ce119c96e2fa357200b559b2f7dd5a5f02d5290aff74b03f3e471b273211c97),s:or_i(older(1),older(4252898)))\", \"82926352210279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f8179821024ce119c96e2fa357200b559b2f7dd5a5f02d5290aff74b03f3e471b273211c9752ae7c6351b26703e2e440b2689a68\", TESTMODE_VALID | TESTMODE_NEEDSIG);\n-    Test(\"and_b(older(16),s:or_d(sha256(e38990d0c7fc009880a9c07c23842e886c6bbdc964ce6bdd5817ad357335ee6f),n:after(1567547623)))\", \"60b27c82012088a820e38990d0c7fc009880a9c07c23842e886c6bbdc964ce6bdd5817ad357335ee6f87736404e7e06e5db192689a\", TESTMODE_VALID);\n-    Test(\"j:and_v(v:hash160(20195b5a3d650c17f0f29f91c33f8f6335193d07),or_d(sha256(96de8fc8c256fa1e1556d41af431cace7dca68707c78dd88c3acab8b17164c47),older(16)))\", \"82926382012088a91420195b5a3d650c17f0f29f91c33f8f6335193d078882012088a82096de8fc8c256fa1e1556d41af431cace7dca68707c78dd88c3acab8b17164c4787736460b26868\", TESTMODE_VALID);\n-    Test(\"and_b(hash256(32ba476771d01e37807990ead8719f08af494723de1d228f2c2c07cc0aa40bac),a:and_b(hash256(131772552c01444cd81360818376a040b7c3b2b7b0a53550ee3edde216cec61b),a:older(1)))\", \"82012088aa2032ba476771d01e37807990ead8719f08af494723de1d228f2c2c07cc0aa40bac876b82012088aa20131772552c01444cd81360818376a040b7c3b2b7b0a53550ee3edde216cec61b876b51b26c9a6c9a\", TESTMODE_VALID | TESTMODE_NONMAL);\n-    Test(\"thresh(2,thresh_m(2,03a0434d9e47f3c86235477c7b1ae6ae5d3442d49b1943c2b752a68e2a47e247c7,036d2b085e9e382ed10b69fc311a03f8641ccfff21574de0927513a49d9a688a00),a:thresh_m(1,036d2b085e9e382ed10b69fc311a03f8641ccfff21574de0927513a49d9a688a00),ac:pk(022f01e5e15cca351daff3843fb70f3c2f0a1bdd05e5af888a67784ef3e10a2a01))\", \"522103a0434d9e47f3c86235477c7b1ae6ae5d3442d49b1943c2b752a68e2a47e247c721036d2b085e9e382ed10b69fc311a03f8641ccfff21574de0927513a49d9a688a0052ae6b5121036d2b085e9e382ed10b69fc311a03f8641ccfff21574de0927513a49d9a688a0051ae6c936b21022f01e5e15cca351daff3843fb70f3c2f0a1bdd05e5af888a67784ef3e10a2a01ac6c935287\", TESTMODE_VALID | TESTMODE_NONMAL | TESTMODE_NEEDSIG);\n-    Test(\"and_n(sha256(d1ec675902ef1633427ca360b290b0b3045a0d9058ddb5e648b4c3c3224c5c68),t:or_i(v:older(4252898),v:older(144)))\", \"82012088a820d1ec675902ef1633427ca360b290b0b3045a0d9058ddb5e648b4c3c3224c5c68876400676303e2e440b26967029000b269685168\", TESTMODE_VALID);\n-    Test(\"or_d(d:and_v(v:older(4252898),v:older(4252898)),sha256(38df1c1f64a24a77b23393bca50dff872e31edc4f3b5aa3b90ad0b82f4f089b6))\", \"766303e2e440b26903e2e440b26968736482012088a82038df1c1f64a24a77b23393bca50dff872e31edc4f3b5aa3b90ad0b82f4f089b68768\", TESTMODE_VALID);\n-    Test(\"c:and_v(or_c(sha256(9267d3dbed802941483f1afa2a6bc68de5f653128aca9bf1461c5d0a3ad36ed2),v:thresh_m(1,02c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db)),pk(03acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe))\", \"82012088a8209267d3dbed802941483f1afa2a6bc68de5f653128aca9bf1461c5d0a3ad36ed28764512102c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db51af682103acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbeac\", TESTMODE_VALID | TESTMODE_NEEDSIG);\n-    Test(\"c:and_v(or_c(thresh_m(2,036d2b085e9e382ed10b69fc311a03f8641ccfff21574de0927513a49d9a688a00,02352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5),v:ripemd160(1b0f3c404d12075c68c938f9f60ebea4f74941a0)),pk(03fff97bd5755eeea420453a14355235d382f6472f8568a18b2f057a1460297556))\", \"5221036d2b085e9e382ed10b69fc311a03f8641ccfff21574de0927513a49d9a688a002102352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d552ae6482012088a6141b0f3c404d12075c68c938f9f60ebea4f74941a088682103fff97bd5755eeea420453a14355235d382f6472f8568a18b2f057a1460297556ac\", TESTMODE_VALID | TESTMODE_NONMAL | TESTMODE_NEEDSIG);\n-    Test(\"and_v(andor(hash256(8a35d9ca92a48eaade6f53a64985e9e2afeb74dcf8acb4c3721e0dc7e4294b25),v:hash256(939894f70e6c3a25da75da0cc2071b4076d9b006563cf635986ada2e93c0d735),v:older(50000)),after(499999999))\", \"82012088aa208a35d9ca92a48eaade6f53a64985e9e2afeb74dcf8acb4c3721e0dc7e4294b2587640350c300b2696782012088aa20939894f70e6c3a25da75da0cc2071b4076d9b006563cf635986ada2e93c0d735886804ff64cd1db1\", TESTMODE_VALID);\n-    Test(\"andor(hash256(5f8d30e655a7ba0d7596bb3ddfb1d2d20390d23b1845000e1e118b3be1b3f040),j:and_v(v:hash160(3a2bff0da9d96868e66abc4427bea4691cf61ccd),older(4194305)),ripemd160(44d90e2d3714c8663b632fcf0f9d5f22192cc4c8))\", \"82012088aa205f8d30e655a7ba0d7596bb3ddfb1d2d20390d23b1845000e1e118b3be1b3f040876482012088a61444d90e2d3714c8663b632fcf0f9d5f22192cc4c8876782926382012088a9143a2bff0da9d96868e66abc4427bea4691cf61ccd8803010040b26868\", TESTMODE_VALID);\n-    Test(\"or_i(c:and_v(v:after(500000),pk(02c6047f9441ed7d6d3045406e95c07cd85c778e4b8cef3ca7abac09b95c709ee5)),sha256(d9147961436944f43cd99d28b2bbddbf452ef872b30c8279e255e7daafc7f946))\", \"630320a107b1692102c6047f9441ed7d6d3045406e95c07cd85c778e4b8cef3ca7abac09b95c709ee5ac6782012088a820d9147961436944f43cd99d28b2bbddbf452ef872b30c8279e255e7daafc7f9468768\", TESTMODE_VALID | TESTMODE_NONMAL);\n-    Test(\"thresh(2,c:pk_h(025cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc),s:sha256(e38990d0c7fc009880a9c07c23842e886c6bbdc964ce6bdd5817ad357335ee6f),a:hash160(dd69735817e0e3f6f826a9238dc2e291184f0131))\", \"76a9145dedfbf9ea599dd4e3ca6a80b333c472fd0b3f6988ac7c82012088a820e38990d0c7fc009880a9c07c23842e886c6bbdc964ce6bdd5817ad357335ee6f87936b82012088a914dd69735817e0e3f6f826a9238dc2e291184f0131876c935287\", TESTMODE_VALID);\n-    Test(\"and_n(sha256(9267d3dbed802941483f1afa2a6bc68de5f653128aca9bf1461c5d0a3ad36ed2),uc:and_v(v:older(144),pk(03fe72c435413d33d48ac09c9161ba8b09683215439d62b7940502bda8b202e6ce)))\", \"82012088a8209267d3dbed802941483f1afa2a6bc68de5f653128aca9bf1461c5d0a3ad36ed28764006763029000b2692103fe72c435413d33d48ac09c9161ba8b09683215439d62b7940502bda8b202e6ceac67006868\", TESTMODE_VALID | TESTMODE_NEEDSIG);\n-    Test(\"and_n(c:pk(03daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729),and_b(l:older(4252898),a:older(16)))\", \"2103daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729ac64006763006703e2e440b2686b60b26c9a68\", TESTMODE_VALID | TESTMODE_NONMAL | TESTMODE_NEEDSIG);\n-    Test(\"c:or_i(and_v(v:older(16),pk_h(02d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e)),pk_h(026a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4))\", \"6360b26976a9149fc5dbe5efdce10374a4dd4053c93af540211718886776a9142fbd32c8dd59ee7c17e66cb6ebea7e9846c3040f8868ac\", TESTMODE_VALID | TESTMODE_NONMAL | TESTMODE_NEEDSIG);\n-    Test(\"or_d(c:pk_h(02e493dbf1c10d80f3581e4904930b1404cc6c13900ee0758474fa94abe8c4cd13),andor(c:pk(024ce119c96e2fa357200b559b2f7dd5a5f02d5290aff74b03f3e471b273211c97),older(2016),after(1567547623)))\", \"76a914c42e7ef92fdb603af844d064faad95db9bcdfd3d88ac736421024ce119c96e2fa357200b559b2f7dd5a5f02d5290aff74b03f3e471b273211c97ac6404e7e06e5db16702e007b26868\", TESTMODE_VALID | TESTMODE_NONMAL);\n-    Test(\"c:andor(ripemd160(6ad07d21fd5dfc646f0b30577045ce201616b9ba),pk_h(02d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e),and_v(v:hash256(8a35d9ca92a48eaade6f53a64985e9e2afeb74dcf8acb4c3721e0dc7e4294b25),pk_h(03d01115d548e7561b15c38f004d734633687cf4419620095bc5b0f47070afe85a)))\", \"82012088a6146ad07d21fd5dfc646f0b30577045ce201616b9ba876482012088aa208a35d9ca92a48eaade6f53a64985e9e2afeb74dcf8acb4c3721e0dc7e4294b258876a914dd100be7d9aea5721158ebde6d6a1fd8fff93bb1886776a9149fc5dbe5efdce10374a4dd4053c93af5402117188868ac\", TESTMODE_VALID | TESTMODE_NEEDSIG);\n-    Test(\"c:andor(u:ripemd160(6ad07d21fd5dfc646f0b30577045ce201616b9ba),pk_h(03daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729),or_i(pk_h(022f01e5e15cca351daff3843fb70f3c2f0a1bdd05e5af888a67784ef3e10a2a01),pk_h(0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798)))\", \"6382012088a6146ad07d21fd5dfc646f0b30577045ce201616b9ba87670068646376a9149652d86bedf43ad264362e6e6eba6eb764508127886776a914751e76e8199196d454941c45d1b3a323f1433bd688686776a91420d637c1a6404d2227f3561fdbaff5a680dba6488868ac\", TESTMODE_VALID | TESTMODE_NEEDSIG);\n-    Test(\"c:or_i(andor(c:pk_h(03d30199d74fb5a22d47b6e054e2f378cedacffcb89904a61d75d0dbd407143e65),pk_h(022f01e5e15cca351daff3843fb70f3c2f0a1bdd05e5af888a67784ef3e10a2a01),pk_h(02c6047f9441ed7d6d3045406e95c07cd85c778e4b8cef3ca7abac09b95c709ee5)),pk(02d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e))\", \"6376a914fcd35ddacad9f2d5be5e464639441c6065e6955d88ac6476a91406afd46bcdfd22ef94ac122aa11f241244a37ecc886776a9149652d86bedf43ad264362e6e6eba6eb7645081278868672102d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e68ac\", TESTMODE_VALID | TESTMODE_NONMAL | TESTMODE_NEEDSIG);\n+    Test(\"lltvln:after(1231488000)\", \"6300676300676300670400046749b1926869516868\", TESTMODE_VALID | TESTMODE_NONMAL, 12, 3);\n+    Test(\"uuj:and_v(v:thresh_m(2,03d01115d548e7561b15c38f004d734633687cf4419620095bc5b0f47070afe85a,025601570cb47f238d2b0286db4a990fa0f3ba28d1a319f5e7cf55c2a2444da7cc),after(1231488000))\", \"6363829263522103d01115d548e7561b15c38f004d734633687cf4419620095bc5b0f47070afe85a21025601570cb47f238d2b0286db4a990fa0f3ba28d1a319f5e7cf55c2a2444da7cc52af0400046749b168670068670068\", TESTMODE_VALID | TESTMODE_NONMAL | TESTMODE_NEEDSIG, 14, 5);\n+    Test(\"or_b(un:thresh_m(2,03daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729,024ce119c96e2fa357200b559b2f7dd5a5f02d5290aff74b03f3e471b273211c97),al:older(16))\", \"63522103daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee872921024ce119c96e2fa357200b559b2f7dd5a5f02d5290aff74b03f3e471b273211c9752ae926700686b63006760b2686c9b\", TESTMODE_VALID, 14, 5);\n+    Test(\"j:and_v(vdv:after(1567547623),older(2016))\", \"829263766304e7e06e5db169686902e007b268\", TESTMODE_VALID | TESTMODE_NONMAL, 11, 1);\n+    Test(\"t:and_v(vu:hash256(131772552c01444cd81360818376a040b7c3b2b7b0a53550ee3edde216cec61b),v:sha256(ec4916dd28fc4c10d78e287ca5d9cc51ee1ae73cbfde08c6b37324cbfaac8bc5))\", \"6382012088aa20131772552c01444cd81360818376a040b7c3b2b7b0a53550ee3edde216cec61b876700686982012088a820ec4916dd28fc4c10d78e287ca5d9cc51ee1ae73cbfde08c6b37324cbfaac8bc58851\", TESTMODE_VALID | TESTMODE_NONMAL, 12, 3);\n+    Test(\"t:andor(thresh_m(3,02d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e,03fff97bd5755eeea420453a14355235d382f6472f8568a18b2f057a1460297556,02e493dbf1c10d80f3581e4904930b1404cc6c13900ee0758474fa94abe8c4cd13),v:older(4194305),v:sha256(9267d3dbed802941483f1afa2a6bc68de5f653128aca9bf1461c5d0a3ad36ed2))\", \"532102d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e2103fff97bd5755eeea420453a14355235d382f6472f8568a18b2f057a14602975562102e493dbf1c10d80f3581e4904930b1404cc6c13900ee0758474fa94abe8c4cd1353ae6482012088a8209267d3dbed802941483f1afa2a6bc68de5f653128aca9bf1461c5d0a3ad36ed2886703010040b2696851\", TESTMODE_VALID | TESTMODE_NONMAL, 13, 5);\n+    Test(\"or_d(thresh_m(1,02f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9),or_b(thresh_m(3,022f01e5e15cca351daff3843fb70f3c2f0a1bdd05e5af888a67784ef3e10a2a01,032fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f,03d01115d548e7561b15c38f004d734633687cf4419620095bc5b0f47070afe85a),su:after(500000)))\", \"512102f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f951ae73645321022f01e5e15cca351daff3843fb70f3c2f0a1bdd05e5af888a67784ef3e10a2a0121032fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f2103d01115d548e7561b15c38f004d734633687cf4419620095bc5b0f47070afe85a53ae7c630320a107b16700689b68\", TESTMODE_VALID | TESTMODE_NONMAL, 15, 7);\n+    Test(\"or_d(sha256(38df1c1f64a24a77b23393bca50dff872e31edc4f3b5aa3b90ad0b82f4f089b6),and_n(un:after(499999999),older(4194305)))\", \"82012088a82038df1c1f64a24a77b23393bca50dff872e31edc4f3b5aa3b90ad0b82f4f089b68773646304ff64cd1db19267006864006703010040b26868\", TESTMODE_VALID, 16, 1);\n+    Test(\"and_v(or_i(v:thresh_m(2,02c6047f9441ed7d6d3045406e95c07cd85c778e4b8cef3ca7abac09b95c709ee5,03774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb),v:thresh_m(2,03e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a,025cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc)),sha256(d1ec675902ef1633427ca360b290b0b3045a0d9058ddb5e648b4c3c3224c5c68))\", \"63522102c6047f9441ed7d6d3045406e95c07cd85c778e4b8cef3ca7abac09b95c709ee52103774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb52af67522103e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a21025cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc52af6882012088a820d1ec675902ef1633427ca360b290b0b3045a0d9058ddb5e648b4c3c3224c5c6887\", TESTMODE_VALID | TESTMODE_NONMAL | TESTMODE_NEEDSIG, 11, 5);\n+    Test(\"j:and_b(thresh_m(2,0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798,024ce119c96e2fa357200b559b2f7dd5a5f02d5290aff74b03f3e471b273211c97),s:or_i(older(1),older(4252898)))\", \"82926352210279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f8179821024ce119c96e2fa357200b559b2f7dd5a5f02d5290aff74b03f3e471b273211c9752ae7c6351b26703e2e440b2689a68\", TESTMODE_VALID | TESTMODE_NEEDSIG, 14, 4);\n+    Test(\"and_b(older(16),s:or_d(sha256(e38990d0c7fc009880a9c07c23842e886c6bbdc964ce6bdd5817ad357335ee6f),n:after(1567547623)))\", \"60b27c82012088a820e38990d0c7fc009880a9c07c23842e886c6bbdc964ce6bdd5817ad357335ee6f87736404e7e06e5db192689a\", TESTMODE_VALID, 12, 1);\n+    Test(\"j:and_v(v:hash160(20195b5a3d650c17f0f29f91c33f8f6335193d07),or_d(sha256(96de8fc8c256fa1e1556d41af431cace7dca68707c78dd88c3acab8b17164c47),older(16)))\", \"82926382012088a91420195b5a3d650c17f0f29f91c33f8f6335193d078882012088a82096de8fc8c256fa1e1556d41af431cace7dca68707c78dd88c3acab8b17164c4787736460b26868\", TESTMODE_VALID, 16, 2);\n+    Test(\"and_b(hash256(32ba476771d01e37807990ead8719f08af494723de1d228f2c2c07cc0aa40bac),a:and_b(hash256(131772552c01444cd81360818376a040b7c3b2b7b0a53550ee3edde216cec61b),a:older(1)))\", \"82012088aa2032ba476771d01e37807990ead8719f08af494723de1d228f2c2c07cc0aa40bac876b82012088aa20131772552c01444cd81360818376a040b7c3b2b7b0a53550ee3edde216cec61b876b51b26c9a6c9a\", TESTMODE_VALID | TESTMODE_NONMAL, 15, 2);\n+    Test(\"thresh(2,thresh_m(2,03a0434d9e47f3c86235477c7b1ae6ae5d3442d49b1943c2b752a68e2a47e247c7,036d2b085e9e382ed10b69fc311a03f8641ccfff21574de0927513a49d9a688a00),a:thresh_m(1,036d2b085e9e382ed10b69fc311a03f8641ccfff21574de0927513a49d9a688a00),ac:pk(022f01e5e15cca351daff3843fb70f3c2f0a1bdd05e5af888a67784ef3e10a2a01))\", \"522103a0434d9e47f3c86235477c7b1ae6ae5d3442d49b1943c2b752a68e2a47e247c721036d2b085e9e382ed10b69fc311a03f8641ccfff21574de0927513a49d9a688a0052ae6b5121036d2b085e9e382ed10b69fc311a03f8641ccfff21574de0927513a49d9a688a0051ae6c936b21022f01e5e15cca351daff3843fb70f3c2f0a1bdd05e5af888a67784ef3e10a2a01ac6c935287\", TESTMODE_VALID | TESTMODE_NONMAL | TESTMODE_NEEDSIG, 13, 6);\n+    Test(\"and_n(sha256(d1ec675902ef1633427ca360b290b0b3045a0d9058ddb5e648b4c3c3224c5c68),t:or_i(v:older(4252898),v:older(144)))\", \"82012088a820d1ec675902ef1633427ca360b290b0b3045a0d9058ddb5e648b4c3c3224c5c68876400676303e2e440b26967029000b269685168\", TESTMODE_VALID, 14, 2);\n+    Test(\"or_d(d:and_v(v:older(4252898),v:older(4252898)),sha256(38df1c1f64a24a77b23393bca50dff872e31edc4f3b5aa3b90ad0b82f4f089b6))\", \"766303e2e440b26903e2e440b26968736482012088a82038df1c1f64a24a77b23393bca50dff872e31edc4f3b5aa3b90ad0b82f4f089b68768\", TESTMODE_VALID, 14, 2);\n+    Test(\"c:and_v(or_c(sha256(9267d3dbed802941483f1afa2a6bc68de5f653128aca9bf1461c5d0a3ad36ed2),v:thresh_m(1,02c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db)),pk(03acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe))\", \"82012088a8209267d3dbed802941483f1afa2a6bc68de5f653128aca9bf1461c5d0a3ad36ed28764512102c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db51af682103acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbeac\", TESTMODE_VALID | TESTMODE_NEEDSIG, 8, 2);\n+    Test(\"c:and_v(or_c(thresh_m(2,036d2b085e9e382ed10b69fc311a03f8641ccfff21574de0927513a49d9a688a00,02352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5),v:ripemd160(1b0f3c404d12075c68c938f9f60ebea4f74941a0)),pk(03fff97bd5755eeea420453a14355235d382f6472f8568a18b2f057a1460297556))\", \"5221036d2b085e9e382ed10b69fc311a03f8641ccfff21574de0927513a49d9a688a002102352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d552ae6482012088a6141b0f3c404d12075c68c938f9f60ebea4f74941a088682103fff97bd5755eeea420453a14355235d382f6472f8568a18b2f057a1460297556ac\", TESTMODE_VALID | TESTMODE_NONMAL | TESTMODE_NEEDSIG, 10, 5);\n+    Test(\"and_v(andor(hash256(8a35d9ca92a48eaade6f53a64985e9e2afeb74dcf8acb4c3721e0dc7e4294b25),v:hash256(939894f70e6c3a25da75da0cc2071b4076d9b006563cf635986ada2e93c0d735),v:older(50000)),after(499999999))\", \"82012088aa208a35d9ca92a48eaade6f53a64985e9e2afeb74dcf8acb4c3721e0dc7e4294b2587640350c300b2696782012088aa20939894f70e6c3a25da75da0cc2071b4076d9b006563cf635986ada2e93c0d735886804ff64cd1db1\", TESTMODE_VALID, 14, 2);\n+    Test(\"andor(hash256(5f8d30e655a7ba0d7596bb3ddfb1d2d20390d23b1845000e1e118b3be1b3f040),j:and_v(v:hash160(3a2bff0da9d96868e66abc4427bea4691cf61ccd),older(4194305)),ripemd160(44d90e2d3714c8663b632fcf0f9d5f22192cc4c8))\", \"82012088aa205f8d30e655a7ba0d7596bb3ddfb1d2d20390d23b1845000e1e118b3be1b3f040876482012088a61444d90e2d3714c8663b632fcf0f9d5f22192cc4c8876782926382012088a9143a2bff0da9d96868e66abc4427bea4691cf61ccd8803010040b26868\", TESTMODE_VALID, 20, 2);\n+    Test(\"or_i(c:and_v(v:after(500000),pk(02c6047f9441ed7d6d3045406e95c07cd85c778e4b8cef3ca7abac09b95c709ee5)),sha256(d9147961436944f43cd99d28b2bbddbf452ef872b30c8279e255e7daafc7f946))\", \"630320a107b1692102c6047f9441ed7d6d3045406e95c07cd85c778e4b8cef3ca7abac09b95c709ee5ac6782012088a820d9147961436944f43cd99d28b2bbddbf452ef872b30c8279e255e7daafc7f9468768\", TESTMODE_VALID | TESTMODE_NONMAL, 10, 2);\n+    Test(\"thresh(2,c:pk_h(025cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc),s:sha256(e38990d0c7fc009880a9c07c23842e886c6bbdc964ce6bdd5817ad357335ee6f),a:hash160(dd69735817e0e3f6f826a9238dc2e291184f0131))\", \"76a9145dedfbf9ea599dd4e3ca6a80b333c472fd0b3f6988ac7c82012088a820e38990d0c7fc009880a9c07c23842e886c6bbdc964ce6bdd5817ad357335ee6f87936b82012088a914dd69735817e0e3f6f826a9238dc2e291184f0131876c935287\", TESTMODE_VALID, 18, 4);\n+    Test(\"and_n(sha256(9267d3dbed802941483f1afa2a6bc68de5f653128aca9bf1461c5d0a3ad36ed2),uc:and_v(v:older(144),pk(03fe72c435413d33d48ac09c9161ba8b09683215439d62b7940502bda8b202e6ce)))\", \"82012088a8209267d3dbed802941483f1afa2a6bc68de5f653128aca9bf1461c5d0a3ad36ed28764006763029000b2692103fe72c435413d33d48ac09c9161ba8b09683215439d62b7940502bda8b202e6ceac67006868\", TESTMODE_VALID | TESTMODE_NEEDSIG, 13, 3);\n+    Test(\"and_n(c:pk(03daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729),and_b(l:older(4252898),a:older(16)))\", \"2103daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729ac64006763006703e2e440b2686b60b26c9a68\", TESTMODE_VALID | TESTMODE_NONMAL | TESTMODE_NEEDSIG, 12, 2);\n+    Test(\"c:or_i(and_v(v:older(16),pk_h(02d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e)),pk_h(026a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4))\", \"6360b26976a9149fc5dbe5efdce10374a4dd4053c93af540211718886776a9142fbd32c8dd59ee7c17e66cb6ebea7e9846c3040f8868ac\", TESTMODE_VALID | TESTMODE_NONMAL | TESTMODE_NEEDSIG, 12, 3);\n+    Test(\"or_d(c:pk_h(02e493dbf1c10d80f3581e4904930b1404cc6c13900ee0758474fa94abe8c4cd13),andor(c:pk(024ce119c96e2fa357200b559b2f7dd5a5f02d5290aff74b03f3e471b273211c97),older(2016),after(1567547623)))\", \"76a914c42e7ef92fdb603af844d064faad95db9bcdfd3d88ac736421024ce119c96e2fa357200b559b2f7dd5a5f02d5290aff74b03f3e471b273211c97ac6404e7e06e5db16702e007b26868\", TESTMODE_VALID | TESTMODE_NONMAL, 13, 3);\n+    Test(\"c:andor(ripemd160(6ad07d21fd5dfc646f0b30577045ce201616b9ba),pk_h(02d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e),and_v(v:hash256(8a35d9ca92a48eaade6f53a64985e9e2afeb74dcf8acb4c3721e0dc7e4294b25),pk_h(03d01115d548e7561b15c38f004d734633687cf4419620095bc5b0f47070afe85a)))\", \"82012088a6146ad07d21fd5dfc646f0b30577045ce201616b9ba876482012088aa208a35d9ca92a48eaade6f53a64985e9e2afeb74dcf8acb4c3721e0dc7e4294b258876a914dd100be7d9aea5721158ebde6d6a1fd8fff93bb1886776a9149fc5dbe5efdce10374a4dd4053c93af5402117188868ac\", TESTMODE_VALID | TESTMODE_NEEDSIG, 18, 3);\n+    Test(\"c:andor(u:ripemd160(6ad07d21fd5dfc646f0b30577045ce201616b9ba),pk_h(03daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729),or_i(pk_h(022f01e5e15cca351daff3843fb70f3c2f0a1bdd05e5af888a67784ef3e10a2a01),pk_h(0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798)))\", \"6382012088a6146ad07d21fd5dfc646f0b30577045ce201616b9ba87670068646376a9149652d86bedf43ad264362e6e6eba6eb764508127886776a914751e76e8199196d454941c45d1b3a323f1433bd688686776a91420d637c1a6404d2227f3561fdbaff5a680dba6488868ac\", TESTMODE_VALID | TESTMODE_NEEDSIG, 23, 4);\n+    Test(\"c:or_i(andor(c:pk_h(03d30199d74fb5a22d47b6e054e2f378cedacffcb89904a61d75d0dbd407143e65),pk_h(022f01e5e15cca351daff3843fb70f3c2f0a1bdd05e5af888a67784ef3e10a2a01),pk_h(02c6047f9441ed7d6d3045406e95c07cd85c778e4b8cef3ca7abac09b95c709ee5)),pk(02d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e))\", \"6376a914fcd35ddacad9f2d5be5e464639441c6065e6955d88ac6476a91406afd46bcdfd22ef94ac122aa11f241244a37ecc886776a9149652d86bedf43ad264362e6e6eba6eb7645081278868672102d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e68ac\", TESTMODE_VALID | TESTMODE_NONMAL | TESTMODE_NEEDSIG, 17, 5);\n \n     g_testdata.reset();\n }"
      }
    ]
  },
  {
    "sha": "20dce1b64818c4b3fdca9633b990c36b52c1e469",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyMGRjZTFiNjQ4MThjNGIzZmRjYTk2MzNiOTkwYzM2YjUyYzFlNDY5",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2019-08-31T01:30:35Z"
      },
      "committer": {
        "name": "practicalswift",
        "email": "practicalswift@users.noreply.github.com",
        "date": "2019-10-23T11:54:49Z"
      },
      "message": "Abstract out DescriptorImpl::KeyToString",
      "tree": {
        "sha": "77aed76596beff16474b11801533e7b1e9bb6be6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/77aed76596beff16474b11801533e7b1e9bb6be6"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/20dce1b64818c4b3fdca9633b990c36b52c1e469",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/20dce1b64818c4b3fdca9633b990c36b52c1e469",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/20dce1b64818c4b3fdca9633b990c36b52c1e469",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/20dce1b64818c4b3fdca9633b990c36b52c1e469/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a4471ad5b553a65cbc1e468b5ef02ced713ddd4d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a4471ad5b553a65cbc1e468b5ef02ced713ddd4d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a4471ad5b553a65cbc1e468b5ef02ced713ddd4d"
      }
    ],
    "stats": {
      "total": 60,
      "additions": 34,
      "deletions": 26
    },
    "files": [
      {
        "sha": "29ab88344c6755544cd2492cbc70e7790f255e0f",
        "filename": "src/script/descriptor.cpp",
        "status": "modified",
        "additions": 34,
        "deletions": 26,
        "changes": 60,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/20dce1b64818c4b3fdca9633b990c36b52c1e469/src/script/descriptor.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/20dce1b64818c4b3fdca9633b990c36b52c1e469/src/script/descriptor.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/descriptor.cpp?ref=20dce1b64818c4b3fdca9633b990c36b52c1e469",
        "patch": "@@ -334,9 +334,22 @@ class BIP32PubkeyProvider final : public PubkeyProvider\n     }\n };\n \n+/** Helper to convert keys in descriptors to strings, optionally with access to private keys. */\n+bool KeyToString(const SigningProvider* arg, std::string& out, bool priv, const PubkeyProvider& key)\n+{\n+    if (priv) {\n+        if (!key.ToPrivateString(*arg, out)) return false;\n+    } else {\n+        out = key.ToString();\n+    }\n+    return true;\n+}\n+\n+\n /** Base class for all Descriptor implementations. */\n class DescriptorImpl : public Descriptor\n {\n+protected:\n     //! Public key arguments for this descriptor (size 1 for PK, PKH, WPKH; any size for Multisig).\n     const std::vector<std::unique_ptr<PubkeyProvider>> m_pubkey_args;\n     //! The sub-descriptor argument (nullptr for everything but SH and WSH).\n@@ -346,7 +359,6 @@ class DescriptorImpl : public Descriptor\n     //! The string name of the descriptor function.\n     const std::string m_name;\n \n-protected:\n     //! Return a serialization of anything except pubkey and script arguments, to be prepended to those.\n     virtual std::string ToStringExtra() const { return \"\"; }\n \n@@ -363,6 +375,27 @@ class DescriptorImpl : public Descriptor\n      */\n     virtual std::vector<CScript> MakeScripts(const std::vector<CPubKey>& pubkeys, const CScript* script, FlatSigningProvider& out) const = 0;\n \n+    virtual bool ToStringHelper(const SigningProvider* arg, std::string& out, bool priv) const\n+    {\n+        std::string extra = ToStringExtra();\n+        size_t pos = extra.size() > 0 ? 1 : 0;\n+        std::string ret = m_name + \"(\" + extra;\n+        for (const auto& pubkey : m_pubkey_args) {\n+            if (pos++) ret += \",\";\n+            std::string tmp;\n+            if (!KeyToString(arg, tmp, priv, *pubkey)) return false;\n+            ret += std::move(tmp);\n+        }\n+        if (m_subdescriptor_arg) {\n+            if (pos++) ret += \",\";\n+            std::string tmp;\n+            if (!m_subdescriptor_arg->ToStringHelper(arg, tmp, priv)) return false;\n+            ret += std::move(tmp);\n+        }\n+        out = std::move(ret) + \")\";\n+        return true;\n+    }\n+\n public:\n     DescriptorImpl(std::vector<std::unique_ptr<PubkeyProvider>> pubkeys, std::unique_ptr<DescriptorImpl> script, const std::string& name) : m_pubkey_args(std::move(pubkeys)), m_subdescriptor_arg(std::move(script)), m_name(name) {}\n \n@@ -385,31 +418,6 @@ class DescriptorImpl : public Descriptor\n         return false;\n     }\n \n-    bool ToStringHelper(const SigningProvider* arg, std::string& out, bool priv) const\n-    {\n-        std::string extra = ToStringExtra();\n-        size_t pos = extra.size() > 0 ? 1 : 0;\n-        std::string ret = m_name + \"(\" + extra;\n-        for (const auto& pubkey : m_pubkey_args) {\n-            if (pos++) ret += \",\";\n-            std::string tmp;\n-            if (priv) {\n-                if (!pubkey->ToPrivateString(*arg, tmp)) return false;\n-            } else {\n-                tmp = pubkey->ToString();\n-            }\n-            ret += std::move(tmp);\n-        }\n-        if (m_subdescriptor_arg) {\n-            if (pos++) ret += \",\";\n-            std::string tmp;\n-            if (!m_subdescriptor_arg->ToStringHelper(arg, tmp, priv)) return false;\n-            ret += std::move(tmp);\n-        }\n-        out = std::move(ret) + \")\";\n-        return true;\n-    }\n-\n     std::string ToString() const final\n     {\n         std::string ret;"
      }
    ]
  },
  {
    "sha": "82200387858905286eeeb28663393f39ebcd7fa2",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4MjIwMDM4Nzg1ODkwNTI4NmVlZWIyODY2MzM5M2YzOWViY2Q3ZmEy",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2019-08-31T01:32:15Z"
      },
      "committer": {
        "name": "practicalswift",
        "email": "practicalswift@users.noreply.github.com",
        "date": "2019-10-23T11:54:49Z"
      },
      "message": "Basic Miniscript support in output descriptors",
      "tree": {
        "sha": "4ed8053b796987cf25695c947caa174a63331e0b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4ed8053b796987cf25695c947caa174a63331e0b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/82200387858905286eeeb28663393f39ebcd7fa2",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/82200387858905286eeeb28663393f39ebcd7fa2",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/82200387858905286eeeb28663393f39ebcd7fa2",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/82200387858905286eeeb28663393f39ebcd7fa2/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "20dce1b64818c4b3fdca9633b990c36b52c1e469",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/20dce1b64818c4b3fdca9633b990c36b52c1e469",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/20dce1b64818c4b3fdca9633b990c36b52c1e469"
      }
    ],
    "stats": {
      "total": 153,
      "additions": 143,
      "deletions": 10
    },
    "files": [
      {
        "sha": "2975bb9d53e9d43501d520a3eb6a9293addb9b56",
        "filename": "src/script/descriptor.cpp",
        "status": "modified",
        "additions": 143,
        "deletions": 10,
        "changes": 153,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/82200387858905286eeeb28663393f39ebcd7fa2/src/script/descriptor.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/82200387858905286eeeb28663393f39ebcd7fa2/src/script/descriptor.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/descriptor.cpp?ref=82200387858905286eeeb28663393f39ebcd7fa2",
        "patch": "@@ -6,6 +6,7 @@\n \n #include <key_io.h>\n #include <pubkey.h>\n+#include <script/miniscript.h>\n #include <script/script.h>\n #include <script/standard.h>\n \n@@ -345,7 +346,6 @@ bool KeyToString(const SigningProvider* arg, std::string& out, bool priv, const\n     return true;\n }\n \n-\n /** Base class for all Descriptor implementations. */\n class DescriptorImpl : public Descriptor\n {\n@@ -631,6 +631,40 @@ class WSHDescriptor final : public DescriptorImpl\n     WSHDescriptor(std::unique_ptr<DescriptorImpl> desc) : DescriptorImpl({}, std::move(desc), \"wsh\") {}\n };\n \n+/* We instantiate Miniscript here with a simple integer as key type.\n+ * The value of these key integers are an index in the\n+ * DescriptorImpl::m_pubkey_args vector.\n+ */\n+\n+class ScriptMaker {\n+    const std::vector<CPubKey>& m_keys;\n+public:\n+    ScriptMaker(const std::vector<CPubKey>& keys) : m_keys(keys) {}\n+    std::vector<unsigned char> ToPKBytes(uint32_t key) const { return {m_keys[key].begin(), m_keys[key].end()}; }\n+    std::vector<unsigned char> ToPKHBytes(uint32_t key) const { auto id = m_keys[key].GetID(); return {id.begin(), id.end()}; }\n+};\n+\n+class StringMaker {\n+    const SigningProvider* m_arg;\n+    const std::vector<std::unique_ptr<PubkeyProvider>>& m_pubkeys;\n+    bool m_private;\n+public:\n+    StringMaker(const SigningProvider* arg, const std::vector<std::unique_ptr<PubkeyProvider>>& pubkeys, bool priv) : m_arg(arg), m_pubkeys(pubkeys), m_private(priv) {}\n+    bool ToString(uint32_t key, std::string& ret) const { return KeyToString(m_arg, ret, m_private, *m_pubkeys[key]); }\n+};\n+\n+class MiniscriptDescriptor final : public DescriptorImpl\n+{\n+private:\n+    miniscript::NodeRef<uint32_t> m_node;\n+protected:\n+    std::vector<CScript> MakeScripts(const std::vector<CPubKey>& keys, const CScript* script, FlatSigningProvider&) const override { return Vector(m_node->ToScript(ScriptMaker(keys))); }\n+public:\n+    bool ToStringHelper(const SigningProvider* arg, std::string& out, bool priv) const override { return m_node->ToString(StringMaker(arg, m_pubkey_args, priv), out); }\n+    bool IsSolvable() const override { return false; } // For now, mark these descriptors as non-solvable (as we don't have signing logic for them).\n+    MiniscriptDescriptor(std::vector<std::unique_ptr<PubkeyProvider>> providers, miniscript::NodeRef<uint32_t> node) : DescriptorImpl(std::move(providers), {}, \"?\"), m_node(std::move(node)) {}\n+};\n+\n ////////////////////////////////////////////////////////////////////////////\n // Parser                                                                 //\n ////////////////////////////////////////////////////////////////////////////\n@@ -778,6 +812,58 @@ std::unique_ptr<PubkeyProvider> ParsePubkey(const Span<const char>& sp, bool per\n     return MakeUnique<OriginPubkeyProvider>(std::move(info), std::move(provider));\n }\n \n+std::unique_ptr<PubkeyProvider> InferPubkey(const CPubKey& pubkey, ParseScriptContext, const SigningProvider& provider)\n+{\n+    std::unique_ptr<PubkeyProvider> key_provider = MakeUnique<ConstPubkeyProvider>(pubkey);\n+    KeyOriginInfo info;\n+    if (provider.GetKeyOrigin(pubkey.GetID(), info)) {\n+        return MakeUnique<OriginPubkeyProvider>(std::move(info), std::move(key_provider));\n+    }\n+    return key_provider;\n+}\n+\n+struct KeyParser {\n+    using Key = uint32_t;\n+    FlatSigningProvider* m_out;\n+    const SigningProvider* m_in;\n+    mutable std::vector<std::unique_ptr<PubkeyProvider>> m_keys;\n+    mutable std::string m_error;\n+    KeyParser(FlatSigningProvider* out, const SigningProvider* in) : m_out(out), m_in(in) {}\n+    template<typename I> bool FromString(I begin, I end, uint32_t& key) const\n+    {\n+        assert(m_out);\n+        auto pk = ParsePubkey(Span<const char>(&*begin, &*end), false, *m_out, m_error);\n+        key = m_keys.size();\n+        m_keys.push_back(std::move(pk));\n+        return true; // Return success even when key parsing fails; m_error will be checked instead.\n+    }\n+    template<typename I> bool FromPKBytes(I begin, I end, uint32_t& key) const\n+    {\n+        assert(m_in);\n+        CPubKey pubkey(begin, end);\n+        if (pubkey.IsValid()) {\n+            key = m_keys.size();\n+            m_keys.push_back(InferPubkey(pubkey, ParseScriptContext::P2WSH, *m_in));\n+            return true;\n+        }\n+        return false;\n+    }\n+    template<typename I> bool FromPKHBytes(I begin, I end, uint32_t& key) const\n+    {\n+        assert(end - begin == 20);\n+        assert(m_in);\n+        uint160 hash(std::vector<unsigned char>(begin, end));\n+        CKeyID keyid(hash);\n+        CPubKey pubkey;\n+        if (m_in->GetPubKey(keyid, pubkey)) {\n+            key = m_keys.size();\n+            m_keys.push_back(InferPubkey(pubkey, ParseScriptContext::P2WSH, *m_in));\n+            return true;\n+        }\n+        return false;\n+    }\n+};\n+\n /** Parse a script in a particular context. */\n std::unique_ptr<DescriptorImpl> ParseScript(Span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out, std::string& error)\n {\n@@ -888,6 +974,54 @@ std::unique_ptr<DescriptorImpl> ParseScript(Span<const char>& sp, ParseScriptCon\n         auto bytes = ParseHex(str);\n         return MakeUnique<RawDescriptor>(CScript(bytes.begin(), bytes.end()));\n     }\n+    // Process miniscript expressions.\n+    {\n+        KeyParser parser(&out, nullptr);\n+        auto node = miniscript::FromString(std::string(expr.begin(), expr.end()), parser);\n+        if (node) {\n+            if (ctx != ParseScriptContext::P2WSH) {\n+                error = \"Miniscript expressions can only be used in wsh\";\n+                return nullptr;\n+            }\n+            if (parser.m_error != \"\") {\n+                error = std::move(parser.m_error);\n+                return nullptr;\n+            }\n+            // If invalid/malleable, recurse down to find a minimal subexpression with that property (better error reporting).\n+            while (!node->IsValid() || !node->IsNonMalleable()) {\n+                bool found_invalid_sub = false;\n+                for (const auto& sub : node->subs) {\n+                    if (!sub->IsValid() || !node->IsNonMalleable()) {\n+                        node = sub;\n+                        found_invalid_sub = true;\n+                        break;\n+                    }\n+                }\n+                if (!found_invalid_sub) {\n+                    std::string err;\n+                    node->ToString(StringMaker(nullptr, parser.m_keys, false), err);\n+                    if (!node->IsValid()) {\n+                        error = \"Miniscript expression '\" + std::move(err) + \"' is invalid\";\n+                    } else {\n+                        error = \"miniscript expression '\" + std::move(err) + \"' needs malleable witnesses\";\n+                    }\n+                    return nullptr;\n+                }\n+            }\n+            // Additional requirements only checked at the top level.\n+            if (!node->IsValidTopLevel()) {\n+                error = \"Miniscript expression is only valid as subexpression\";\n+                return nullptr;\n+            } else if (!node->NeedsSignature()) {\n+                error = \"Miniscript expression is insecure: witnesses without signature exist\";\n+                return nullptr;\n+            } else if (!node->IsSafeTopLevel()) {\n+                error = \"Miniscript expression needs witnesses that may exceed resource limits\";\n+                return nullptr;\n+            }\n+            return MakeUnique<MiniscriptDescriptor>(std::move(parser.m_keys), std::move(node));\n+        }\n+    }\n     if (ctx == ParseScriptContext::P2SH) {\n         error = \"A function is needed within P2SH\";\n         return nullptr;\n@@ -899,15 +1033,6 @@ std::unique_ptr<DescriptorImpl> ParseScript(Span<const char>& sp, ParseScriptCon\n     return nullptr;\n }\n \n-std::unique_ptr<PubkeyProvider> InferPubkey(const CPubKey& pubkey, ParseScriptContext, const SigningProvider& provider)\n-{\n-    std::unique_ptr<PubkeyProvider> key_provider = MakeUnique<ConstPubkeyProvider>(pubkey);\n-    KeyOriginInfo info;\n-    if (provider.GetKeyOrigin(pubkey.GetID(), info)) {\n-        return MakeUnique<OriginPubkeyProvider>(std::move(info), std::move(key_provider));\n-    }\n-    return key_provider;\n-}\n \n std::unique_ptr<DescriptorImpl> InferScript(const CScript& script, ParseScriptContext ctx, const SigningProvider& provider)\n {\n@@ -963,6 +1088,14 @@ std::unique_ptr<DescriptorImpl> InferScript(const CScript& script, ParseScriptCo\n         }\n     }\n \n+    if (ctx == ParseScriptContext::P2WSH) {\n+        KeyParser parser(nullptr, &provider);\n+        auto node = miniscript::FromScript(script, parser);\n+        if (node && node->IsSafeTopLevel()) {\n+            return MakeUnique<MiniscriptDescriptor>(std::move(parser.m_keys), std::move(node));\n+        }\n+    }\n+\n     CTxDestination dest;\n     if (ExtractDestination(script, dest)) {\n         if (GetScriptForDestination(dest) == script) {"
      }
    ]
  },
  {
    "sha": "a22c0e9bad5bb9caaf1c2e7f0bafc8ad03b50dcc",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphMjJjMGU5YmFkNWJiOWNhYWYxYzJlN2YwYmFmYzhhZDAzYjUwZGNj",
    "commit": {
      "author": {
        "name": "practicalswift",
        "email": "practicalswift@users.noreply.github.com",
        "date": "2019-10-13T20:38:22Z"
      },
      "committer": {
        "name": "practicalswift",
        "email": "practicalswift@users.noreply.github.com",
        "date": "2019-10-23T11:54:49Z"
      },
      "message": "[wip] Fix compilation errors after merge",
      "tree": {
        "sha": "ad99a3d1b83c3838eb8c4fadacc1fd06a8dba90b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ad99a3d1b83c3838eb8c4fadacc1fd06a8dba90b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a22c0e9bad5bb9caaf1c2e7f0bafc8ad03b50dcc",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a22c0e9bad5bb9caaf1c2e7f0bafc8ad03b50dcc",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a22c0e9bad5bb9caaf1c2e7f0bafc8ad03b50dcc",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a22c0e9bad5bb9caaf1c2e7f0bafc8ad03b50dcc/comments",
    "author": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "82200387858905286eeeb28663393f39ebcd7fa2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/82200387858905286eeeb28663393f39ebcd7fa2",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/82200387858905286eeeb28663393f39ebcd7fa2"
      }
    ],
    "stats": {
      "total": 19,
      "additions": 2,
      "deletions": 17
    },
    "files": [
      {
        "sha": "ba01b77976449bb684b3e90fb3da317c95f01229",
        "filename": "src/script/descriptor.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 17,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a22c0e9bad5bb9caaf1c2e7f0bafc8ad03b50dcc/src/script/descriptor.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a22c0e9bad5bb9caaf1c2e7f0bafc8ad03b50dcc/src/script/descriptor.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/descriptor.cpp?ref=a22c0e9bad5bb9caaf1c2e7f0bafc8ad03b50dcc",
        "patch": "@@ -675,23 +675,6 @@ enum class ParseScriptContext {\n     P2WSH,\n };\n \n-/** Split a string on every instance of sep, returning a vector. */\n-std::vector<Span<const char>> Split(const Span<const char>& sp, char sep)\n-{\n-    std::vector<Span<const char>> ret;\n-    auto it = sp.begin();\n-    auto start = it;\n-    while (it != sp.end()) {\n-        if (*it == sep) {\n-            ret.emplace_back(start, it);\n-            start = it + 1;\n-        }\n-        ++it;\n-    }\n-    ret.emplace_back(start, it);\n-    return ret;\n-}\n-\n /** Parse a key path, being passed a split list of elements (the first element is ignored). */\n NODISCARD bool ParseKeyPath(const std::vector<Span<const char>>& split, KeyPath& out, std::string& error)\n {"
      },
      {
        "sha": "d5bc80f989ac17c67b0b45df15955ae6413a2819",
        "filename": "src/script/miniscript.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a22c0e9bad5bb9caaf1c2e7f0bafc8ad03b50dcc/src/script/miniscript.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a22c0e9bad5bb9caaf1c2e7f0bafc8ad03b50dcc/src/script/miniscript.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/miniscript.h?ref=a22c0e9bad5bb9caaf1c2e7f0bafc8ad03b50dcc",
        "patch": "@@ -21,6 +21,8 @@\n #include <util/strencodings.h>\n #include <util/vector.h>\n \n+using namespace spanparsing;\n+\n namespace miniscript {\n \n /** This type encapsulates the miniscript type system properties."
      }
    ]
  },
  {
    "sha": "f9548e2b3d24f12ad273367565764c0da5b1b164",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmOTU0OGUyYjNkMjRmMTJhZDI3MzM2NzU2NTc2NGMwZGE1YjFiMTY0",
    "commit": {
      "author": {
        "name": "practicalswift",
        "email": "practicalswift@users.noreply.github.com",
        "date": "2019-10-02T08:01:27Z"
      },
      "committer": {
        "name": "practicalswift",
        "email": "practicalswift@users.noreply.github.com",
        "date": "2019-10-23T11:54:49Z"
      },
      "message": "tests: Add corpora suppression (FUZZERS_MISSING_CORPORA) for fuzzers missing in https://github.com/bitcoin-core/qa-assets/tree/master/fuzz_seed_corpus",
      "tree": {
        "sha": "366a1e3cf4a82ac8dabff0d627cf12261fe2bf49",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/366a1e3cf4a82ac8dabff0d627cf12261fe2bf49"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f9548e2b3d24f12ad273367565764c0da5b1b164",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f9548e2b3d24f12ad273367565764c0da5b1b164",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f9548e2b3d24f12ad273367565764c0da5b1b164",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f9548e2b3d24f12ad273367565764c0da5b1b164/comments",
    "author": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a22c0e9bad5bb9caaf1c2e7f0bafc8ad03b50dcc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a22c0e9bad5bb9caaf1c2e7f0bafc8ad03b50dcc",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a22c0e9bad5bb9caaf1c2e7f0bafc8ad03b50dcc"
      }
    ],
    "stats": {
      "total": 10,
      "additions": 9,
      "deletions": 1
    },
    "files": [
      {
        "sha": "494ddf65b2d3aafd19283c97ecadfe765035d6a4",
        "filename": "test/fuzz/test_runner.py",
        "status": "modified",
        "additions": 9,
        "deletions": 1,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f9548e2b3d24f12ad273367565764c0da5b1b164/test/fuzz/test_runner.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f9548e2b3d24f12ad273367565764c0da5b1b164/test/fuzz/test_runner.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/fuzz/test_runner.py?ref=f9548e2b3d24f12ad273367565764c0da5b1b164",
        "patch": "@@ -12,6 +12,10 @@\n import subprocess\n import logging\n \n+# Fuzzers known to lack a seed corpus in https://github.com/bitcoin-core/qa-assets/tree/master/fuzz_seed_corpus\n+FUZZERS_MISSING_CORPORA = [\n+    \"from_script\",\n+]\n \n def main():\n     parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)\n@@ -100,10 +104,14 @@ def main():\n \n def run_once(*, corpus, test_list, build_dir, export_coverage):\n     for t in test_list:\n+        corpus_path = os.path.join(corpus, t)\n+        if t in FUZZERS_MISSING_CORPORA:\n+            os.makedirs(corpus_path, exist_ok=True)\n         args = [\n             os.path.join(build_dir, 'src', 'test', 'fuzz', t),\n             '-runs=1',\n-            os.path.join(corpus, t),\n+            '-detect_leaks=0',\n+            corpus_path,\n         ]\n         logging.debug('Run {} with args {}'.format(t, args))\n         result = subprocess.run(args, stderr=subprocess.PIPE, universal_newlines=True)"
      }
    ]
  },
  {
    "sha": "cada7353c22dff5e5af6dc41b1f1991f19003fff",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjYWRhNzM1M2MyMmRmZjVlNWFmNmRjNDFiMWYxOTkxZjE5MDAzZmZm",
    "commit": {
      "author": {
        "name": "practicalswift",
        "email": "practicalswift@users.noreply.github.com",
        "date": "2019-10-13T20:55:28Z"
      },
      "committer": {
        "name": "practicalswift",
        "email": "practicalswift@users.noreply.github.com",
        "date": "2019-10-23T11:54:49Z"
      },
      "message": "tests: Add fuzzing harness for miniscript::FromScript(...)",
      "tree": {
        "sha": "f99dac86d4555192e03f36eee331d936ae093fdf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f99dac86d4555192e03f36eee331d936ae093fdf"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/cada7353c22dff5e5af6dc41b1f1991f19003fff",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cada7353c22dff5e5af6dc41b1f1991f19003fff",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/cada7353c22dff5e5af6dc41b1f1991f19003fff",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cada7353c22dff5e5af6dc41b1f1991f19003fff/comments",
    "author": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f9548e2b3d24f12ad273367565764c0da5b1b164",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f9548e2b3d24f12ad273367565764c0da5b1b164",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f9548e2b3d24f12ad273367565764c0da5b1b164"
      }
    ],
    "stats": {
      "total": 48,
      "additions": 48,
      "deletions": 0
    },
    "files": [
      {
        "sha": "689f2c0225a55beeb12b562ffb7ca3c07ebe81e6",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cada7353c22dff5e5af6dc41b1f1991f19003fff/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cada7353c22dff5e5af6dc41b1f1991f19003fff/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=cada7353c22dff5e5af6dc41b1f1991f19003fff",
        "patch": "@@ -18,6 +18,7 @@ FUZZ_TARGETS = \\\n   test/fuzz/coins_deserialize \\\n   test/fuzz/diskblockindex_deserialize \\\n   test/fuzz/eval_script \\\n+  test/fuzz/from_script \\\n   test/fuzz/inv_deserialize \\\n   test/fuzz/messageheader_deserialize \\\n   test/fuzz/netaddr_deserialize \\\n@@ -314,6 +315,12 @@ test_fuzz_eval_script_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n test_fuzz_eval_script_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n test_fuzz_eval_script_LDADD = $(FUZZ_SUITE_LD_COMMON)\n \n+test_fuzz_from_script_SOURCES = $(FUZZ_SUITE) test/fuzz/from_script.cpp\n+test_fuzz_from_script_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n+test_fuzz_from_script_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n+test_fuzz_from_script_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n+test_fuzz_from_script_LDADD = $(FUZZ_SUITE_LD_COMMON)\n+\n test_fuzz_txoutcompressor_deserialize_SOURCES = $(FUZZ_SUITE) test/fuzz/deserialize.cpp\n test_fuzz_txoutcompressor_deserialize_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) -DTXOUTCOMPRESSOR_DESERIALIZE=1\n test_fuzz_txoutcompressor_deserialize_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)"
      },
      {
        "sha": "628ce3a37ba37ca91ff920c7ff0ac43249907fdf",
        "filename": "src/test/fuzz/from_script.cpp",
        "status": "added",
        "additions": 41,
        "deletions": 0,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cada7353c22dff5e5af6dc41b1f1991f19003fff/src/test/fuzz/from_script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cada7353c22dff5e5af6dc41b1f1991f19003fff/src/test/fuzz/from_script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/from_script.cpp?ref=cada7353c22dff5e5af6dc41b1f1991f19003fff",
        "patch": "@@ -0,0 +1,41 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <pubkey.h>\n+#include <script/miniscript.h>\n+#include <script/script.h>\n+#include <test/fuzz/fuzz.h>\n+\n+#include <initializer_list>\n+#include <string>\n+\n+struct DummyKeyConverter {\n+    typedef CPubKey Key;\n+    bool return_value{false};\n+\n+    explicit DummyKeyConverter(bool return_value_) : return_value(return_value_)\n+    {\n+    }\n+\n+    template <typename I>\n+    bool FromPKBytes(I first, I last, Key& key) const\n+    {\n+        return return_value;\n+    }\n+\n+    template <typename I>\n+    bool FromPKHBytes(I first, I last, Key& key) const\n+    {\n+        return return_value;\n+    }\n+};\n+\n+void test_one_input(const std::vector<uint8_t>& buffer)\n+{\n+    const CScript script(buffer.begin(), buffer.end());\n+    for (const bool return_value : {true, false}) {\n+        const DummyKeyConverter ctx{return_value};\n+        (void)miniscript::FromScript(script, ctx);\n+    }\n+}"
      }
    ]
  }
]