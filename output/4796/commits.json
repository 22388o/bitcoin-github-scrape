[
  {
    "sha": "6db83db3eb96809da3e680464b152f82785e38e6",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2ZGI4M2RiM2ViOTY4MDlkYTNlNjgwNDY0YjE1MmY4Mjc4NWUzOGU2",
    "commit": {
      "author": {
        "name": "jtimon",
        "email": "jtimon@blockstream.io",
        "date": "2014-09-03T00:52:01Z"
      },
      "committer": {
        "name": "jtimon",
        "email": "jtimon@blockstream.io",
        "date": "2014-09-08T20:14:24Z"
      },
      "message": "Decouple CChain from mapBlockIndex",
      "tree": {
        "sha": "e74fd80fe789c3550d862d088e2d6b86be547e14",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e74fd80fe789c3550d862d088e2d6b86be547e14"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6db83db3eb96809da3e680464b152f82785e38e6",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6db83db3eb96809da3e680464b152f82785e38e6",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6db83db3eb96809da3e680464b152f82785e38e6",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6db83db3eb96809da3e680464b152f82785e38e6/comments",
    "author": {
      "login": "jtimon",
      "id": 1008458,
      "node_id": "MDQ6VXNlcjEwMDg0NTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1008458?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jtimon",
      "html_url": "https://github.com/jtimon",
      "followers_url": "https://api.github.com/users/jtimon/followers",
      "following_url": "https://api.github.com/users/jtimon/following{/other_user}",
      "gists_url": "https://api.github.com/users/jtimon/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jtimon/subscriptions",
      "organizations_url": "https://api.github.com/users/jtimon/orgs",
      "repos_url": "https://api.github.com/users/jtimon/repos",
      "events_url": "https://api.github.com/users/jtimon/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jtimon/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jtimon",
      "id": 1008458,
      "node_id": "MDQ6VXNlcjEwMDg0NTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1008458?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jtimon",
      "html_url": "https://github.com/jtimon",
      "followers_url": "https://api.github.com/users/jtimon/followers",
      "following_url": "https://api.github.com/users/jtimon/following{/other_user}",
      "gists_url": "https://api.github.com/users/jtimon/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jtimon/subscriptions",
      "organizations_url": "https://api.github.com/users/jtimon/orgs",
      "repos_url": "https://api.github.com/users/jtimon/repos",
      "events_url": "https://api.github.com/users/jtimon/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jtimon/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "eecd3c0fb0625b036f68a7830dda8edde21fcb90",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/eecd3c0fb0625b036f68a7830dda8edde21fcb90",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/eecd3c0fb0625b036f68a7830dda8edde21fcb90"
      }
    ],
    "stats": {
      "total": 19,
      "additions": 10,
      "deletions": 9
    },
    "files": [
      {
        "sha": "f83dfe2f9943bbc16c5effd538003a7c0564093c",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6db83db3eb96809da3e680464b152f82785e38e6/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6db83db3eb96809da3e680464b152f82785e38e6/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=6db83db3eb96809da3e680464b152f82785e38e6",
        "patch": "@@ -1151,7 +1151,7 @@ bool AppInit2(boost::thread_group& threadGroup)\n             CWalletDB walletdb(strWalletFile);\n             CBlockLocator locator;\n             if (walletdb.ReadBestBlock(locator))\n-                pindexRescan = chainActive.FindFork(locator);\n+                pindexRescan = FindForkInGlobalIndex(chainActive, locator);\n             else\n                 pindexRescan = chainActive.Genesis();\n         }"
      },
      {
        "sha": "108f8e0823aaf89f855177db088e8352f3a06144",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 5,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6db83db3eb96809da3e680464b152f82785e38e6/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6db83db3eb96809da3e680464b152f82785e38e6/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=6db83db3eb96809da3e680464b152f82785e38e6",
        "patch": "@@ -431,18 +431,19 @@ CBlockLocator CChain::GetLocator(const CBlockIndex *pindex) const {\n     return CBlockLocator(vHave);\n }\n \n-CBlockIndex *CChain::FindFork(const CBlockLocator &locator) const {\n+CBlockIndex* FindForkInGlobalIndex(const CChain& chain, const CBlockLocator& locator)\n+{\n     // Find the first block the caller has in the main chain\n     BOOST_FOREACH(const uint256& hash, locator.vHave) {\n         BlockMap::iterator mi = mapBlockIndex.find(hash);\n         if (mi != mapBlockIndex.end())\n         {\n             CBlockIndex* pindex = (*mi).second;\n-            if (Contains(pindex))\n+            if (chain.Contains(pindex))\n                 return pindex;\n         }\n     }\n-    return Genesis();\n+    return chain.Genesis();\n }\n \n const CBlockIndex *CChain::FindFork(const CBlockIndex *pindex) const {\n@@ -3672,7 +3673,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         LOCK(cs_main);\n \n         // Find the last block the caller has in the main chain\n-        CBlockIndex* pindex = chainActive.FindFork(locator);\n+        CBlockIndex* pindex = FindForkInGlobalIndex(chainActive, locator);\n \n         // Send the rest of the chain\n         if (pindex)\n@@ -3719,7 +3720,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         else\n         {\n             // Find the last block the caller has in the main chain\n-            pindex = chainActive.FindFork(locator);\n+            pindex = FindForkInGlobalIndex(chainActive, locator);\n             if (pindex)\n                 pindex = chainActive.Next(pindex);\n         }"
      },
      {
        "sha": "dbc20783bbbd86c9f412ea96c12202112f73a18c",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6db83db3eb96809da3e680464b152f82785e38e6/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6db83db3eb96809da3e680464b152f82785e38e6/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=6db83db3eb96809da3e680464b152f82785e38e6",
        "patch": "@@ -953,13 +953,13 @@ class CChain {\n     /** Return a CBlockLocator that refers to a block in this chain (by default the tip). */\n     CBlockLocator GetLocator(const CBlockIndex *pindex = NULL) const;\n \n-    /** Find the last common block between this chain and a locator. */\n-    CBlockIndex *FindFork(const CBlockLocator &locator) const;\n-\n     /** Find the last common block between this chain and a block index entry. */\n     const CBlockIndex *FindFork(const CBlockIndex *pindex) const;\n };\n \n+/** Find the last common block between the parameter chain and a locator. */\n+CBlockIndex* FindForkInGlobalIndex(const CChain& chain, const CBlockLocator& locator);\n+\n /** The currently-connected chain of blocks. */\n extern CChain chainActive;\n "
      }
    ]
  },
  {
    "sha": "e8b5f0d549b1b76611c7374bed9ceec7d09fa847",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplOGI1ZjBkNTQ5YjFiNzY2MTFjNzM3NGJlZDljZWVjN2QwOWZhODQ3",
    "commit": {
      "author": {
        "name": "jtimon",
        "email": "jtimon@blockstream.io",
        "date": "2014-09-03T00:20:09Z"
      },
      "committer": {
        "name": "jtimon",
        "email": "jtimon@blockstream.io",
        "date": "2014-09-08T20:17:19Z"
      },
      "message": "Move CBlockIndex, CChain and related code out of main",
      "tree": {
        "sha": "a35ca887cbbe54978bf94943a5a250d6ec30540e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a35ca887cbbe54978bf94943a5a250d6ec30540e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e8b5f0d549b1b76611c7374bed9ceec7d09fa847",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e8b5f0d549b1b76611c7374bed9ceec7d09fa847",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e8b5f0d549b1b76611c7374bed9ceec7d09fa847",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e8b5f0d549b1b76611c7374bed9ceec7d09fa847/comments",
    "author": {
      "login": "jtimon",
      "id": 1008458,
      "node_id": "MDQ6VXNlcjEwMDg0NTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1008458?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jtimon",
      "html_url": "https://github.com/jtimon",
      "followers_url": "https://api.github.com/users/jtimon/followers",
      "following_url": "https://api.github.com/users/jtimon/following{/other_user}",
      "gists_url": "https://api.github.com/users/jtimon/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jtimon/subscriptions",
      "organizations_url": "https://api.github.com/users/jtimon/orgs",
      "repos_url": "https://api.github.com/users/jtimon/repos",
      "events_url": "https://api.github.com/users/jtimon/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jtimon/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jtimon",
      "id": 1008458,
      "node_id": "MDQ6VXNlcjEwMDg0NTg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1008458?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jtimon",
      "html_url": "https://github.com/jtimon",
      "followers_url": "https://api.github.com/users/jtimon/followers",
      "following_url": "https://api.github.com/users/jtimon/following{/other_user}",
      "gists_url": "https://api.github.com/users/jtimon/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jtimon/subscriptions",
      "organizations_url": "https://api.github.com/users/jtimon/orgs",
      "repos_url": "https://api.github.com/users/jtimon/repos",
      "events_url": "https://api.github.com/users/jtimon/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jtimon/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6db83db3eb96809da3e680464b152f82785e38e6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6db83db3eb96809da3e680464b152f82785e38e6",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6db83db3eb96809da3e680464b152f82785e38e6"
      }
    ],
    "stats": {
      "total": 886,
      "additions": 452,
      "deletions": 434
    },
    "files": [
      {
        "sha": "56e141532ad96c5d34dc5e7ec35c62e9b622e838",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e8b5f0d549b1b76611c7374bed9ceec7d09fa847/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e8b5f0d549b1b76611c7374bed9ceec7d09fa847/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=e8b5f0d549b1b76611c7374bed9ceec7d09fa847",
        "patch": "@@ -67,6 +67,7 @@ BITCOIN_CORE_H = \\\n   allocators.h \\\n   base58.h \\\n   bloom.h \\\n+  chain.h \\\n   chainparams.h \\\n   chainparamsbase.h \\\n   chainparamsseeds.h \\\n@@ -145,6 +146,7 @@ libbitcoin_server_a_SOURCES = \\\n   addrman.cpp \\\n   alert.cpp \\\n   bloom.cpp \\\n+  chain.cpp \\\n   checkpoints.cpp \\\n   init.cpp \\\n   leveldbwrapper.cpp \\"
      },
      {
        "sha": "bcb497b2d491bac851493f325fa09a5659fa4d66",
        "filename": "src/chain.cpp",
        "status": "added",
        "additions": 59,
        "deletions": 0,
        "changes": 59,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e8b5f0d549b1b76611c7374bed9ceec7d09fa847/src/chain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e8b5f0d549b1b76611c7374bed9ceec7d09fa847/src/chain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chain.cpp?ref=e8b5f0d549b1b76611c7374bed9ceec7d09fa847",
        "patch": "@@ -0,0 +1,59 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2014 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"chain.h\"\n+\n+using namespace std;\n+\n+// CChain implementation\n+\n+CBlockIndex *CChain::SetTip(CBlockIndex *pindex) {\n+    if (pindex == NULL) {\n+        vChain.clear();\n+        return NULL;\n+    }\n+    vChain.resize(pindex->nHeight + 1);\n+    while (pindex && vChain[pindex->nHeight] != pindex) {\n+        vChain[pindex->nHeight] = pindex;\n+        pindex = pindex->pprev;\n+    }\n+    return pindex;\n+}\n+\n+CBlockLocator CChain::GetLocator(const CBlockIndex *pindex) const {\n+    int nStep = 1;\n+    std::vector<uint256> vHave;\n+    vHave.reserve(32);\n+\n+    if (!pindex)\n+        pindex = Tip();\n+    while (pindex) {\n+        vHave.push_back(pindex->GetBlockHash());\n+        // Stop when we have added the genesis block.\n+        if (pindex->nHeight == 0)\n+            break;\n+        // Exponentially larger steps back, plus the genesis block.\n+        int nHeight = std::max(pindex->nHeight - nStep, 0);\n+        if (Contains(pindex)) {\n+            // Use O(1) CChain index if possible.\n+            pindex = (*this)[nHeight];\n+        } else {\n+            // Otherwise, use O(log n) skiplist.\n+            pindex = pindex->GetAncestor(nHeight);\n+        }\n+        if (vHave.size() > 10)\n+            nStep *= 2;\n+    }\n+\n+    return CBlockLocator(vHave);\n+}\n+\n+const CBlockIndex *CChain::FindFork(const CBlockIndex *pindex) const {\n+    if (pindex->nHeight > Height())\n+        pindex = pindex->GetAncestor(Height());\n+    while (pindex && !Contains(pindex))\n+        pindex = pindex->pprev;\n+    return pindex;\n+}"
      },
      {
        "sha": "91bdf383475f1e69284ae1dd0216efbf41971386",
        "filename": "src/chain.h",
        "status": "added",
        "additions": 390,
        "deletions": 0,
        "changes": 390,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e8b5f0d549b1b76611c7374bed9ceec7d09fa847/src/chain.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e8b5f0d549b1b76611c7374bed9ceec7d09fa847/src/chain.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chain.h?ref=e8b5f0d549b1b76611c7374bed9ceec7d09fa847",
        "patch": "@@ -0,0 +1,390 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2014 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef H_BITCOIN_CHAIN\n+#define H_BITCOIN_CHAIN\n+\n+#include \"core.h\"\n+#include \"pow.h\"\n+#include \"uint256.h\"\n+\n+#include <vector>\n+\n+#include <boost/foreach.hpp>\n+\n+struct CDiskBlockPos\n+{\n+    int nFile;\n+    unsigned int nPos;\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        READWRITE(VARINT(nFile));\n+        READWRITE(VARINT(nPos));\n+    }\n+\n+    CDiskBlockPos() {\n+        SetNull();\n+    }\n+\n+    CDiskBlockPos(int nFileIn, unsigned int nPosIn) {\n+        nFile = nFileIn;\n+        nPos = nPosIn;\n+    }\n+\n+    friend bool operator==(const CDiskBlockPos &a, const CDiskBlockPos &b) {\n+        return (a.nFile == b.nFile && a.nPos == b.nPos);\n+    }\n+\n+    friend bool operator!=(const CDiskBlockPos &a, const CDiskBlockPos &b) {\n+        return !(a == b);\n+    }\n+\n+    void SetNull() { nFile = -1; nPos = 0; }\n+    bool IsNull() const { return (nFile == -1); }\n+};\n+\n+enum BlockStatus {\n+    BLOCK_VALID_UNKNOWN      =    0,\n+    BLOCK_VALID_HEADER       =    1, // parsed, version ok, hash satisfies claimed PoW, 1 <= vtx count <= max, timestamp not in future\n+    BLOCK_VALID_TREE         =    2, // parent found, difficulty matches, timestamp >= median previous, checkpoint\n+    BLOCK_VALID_TRANSACTIONS =    3, // only first tx is coinbase, 2 <= coinbase input script length <= 100, transactions valid, no duplicate txids, sigops, size, merkle root\n+    BLOCK_VALID_CHAIN        =    4, // outputs do not overspend inputs, no double spends, coinbase output ok, immature coinbase spends, BIP30\n+    BLOCK_VALID_SCRIPTS      =    5, // scripts/signatures ok\n+    BLOCK_VALID_MASK         =   BLOCK_VALID_HEADER | BLOCK_VALID_TREE | BLOCK_VALID_TRANSACTIONS |\n+                                 BLOCK_VALID_CHAIN | BLOCK_VALID_SCRIPTS,\n+\n+    BLOCK_HAVE_DATA          =    8, // full block available in blk*.dat\n+    BLOCK_HAVE_UNDO          =   16, // undo data available in rev*.dat\n+    BLOCK_HAVE_MASK          =   BLOCK_HAVE_DATA | BLOCK_HAVE_UNDO,\n+\n+    BLOCK_FAILED_VALID       =   32, // stage after last reached validness failed\n+    BLOCK_FAILED_CHILD       =   64, // descends from failed block\n+    BLOCK_FAILED_MASK        =   BLOCK_FAILED_VALID | BLOCK_FAILED_CHILD,\n+};\n+\n+/** The block chain is a tree shaped structure starting with the\n+ * genesis block at the root, with each block potentially having multiple\n+ * candidates to be the next block. A blockindex may have multiple pprev pointing\n+ * to it, but at most one of them can be part of the currently active branch.\n+ */\n+class CBlockIndex\n+{\n+public:\n+    // pointer to the hash of the block, if any. memory is owned by this CBlockIndex\n+    const uint256* phashBlock;\n+\n+    // pointer to the index of the predecessor of this block\n+    CBlockIndex* pprev;\n+\n+    // pointer to the index of some further predecessor of this block\n+    CBlockIndex* pskip;\n+\n+    // height of the entry in the chain. The genesis block has height 0\n+    int nHeight;\n+\n+    // Which # file this block is stored in (blk?????.dat)\n+    int nFile;\n+\n+    // Byte offset within blk?????.dat where this block's data is stored\n+    unsigned int nDataPos;\n+\n+    // Byte offset within rev?????.dat where this block's undo data is stored\n+    unsigned int nUndoPos;\n+\n+    // (memory only) Total amount of work (expected number of hashes) in the chain up to and including this block\n+    uint256 nChainWork;\n+\n+    // Number of transactions in this block.\n+    // Note: in a potential headers-first mode, this number cannot be relied upon\n+    unsigned int nTx;\n+\n+    // (memory only) Number of transactions in the chain up to and including this block\n+    unsigned int nChainTx; // change to 64-bit type when necessary; won't happen before 2030\n+\n+    // Verification status of this block. See enum BlockStatus\n+    unsigned int nStatus;\n+\n+    // block header\n+    int nVersion;\n+    uint256 hashMerkleRoot;\n+    unsigned int nTime;\n+    unsigned int nBits;\n+    unsigned int nNonce;\n+\n+    // (memory only) Sequencial id assigned to distinguish order in which blocks are received.\n+    uint32_t nSequenceId;\n+\n+    void SetNull()\n+    {\n+        phashBlock = NULL;\n+        pprev = NULL;\n+        pskip = NULL;\n+        nHeight = 0;\n+        nFile = 0;\n+        nDataPos = 0;\n+        nUndoPos = 0;\n+        nChainWork = 0;\n+        nTx = 0;\n+        nChainTx = 0;\n+        nStatus = 0;\n+        nSequenceId = 0;\n+\n+        nVersion       = 0;\n+        hashMerkleRoot = 0;\n+        nTime          = 0;\n+        nBits          = 0;\n+        nNonce         = 0;\n+    }\n+\n+    CBlockIndex()\n+    {\n+        SetNull();\n+    }\n+\n+    CBlockIndex(CBlockHeader& block)\n+    {\n+        SetNull();\n+\n+        nVersion       = block.nVersion;\n+        hashMerkleRoot = block.hashMerkleRoot;\n+        nTime          = block.nTime;\n+        nBits          = block.nBits;\n+        nNonce         = block.nNonce;\n+    }\n+\n+    CDiskBlockPos GetBlockPos() const {\n+        CDiskBlockPos ret;\n+        if (nStatus & BLOCK_HAVE_DATA) {\n+            ret.nFile = nFile;\n+            ret.nPos  = nDataPos;\n+        }\n+        return ret;\n+    }\n+\n+    CDiskBlockPos GetUndoPos() const {\n+        CDiskBlockPos ret;\n+        if (nStatus & BLOCK_HAVE_UNDO) {\n+            ret.nFile = nFile;\n+            ret.nPos  = nUndoPos;\n+        }\n+        return ret;\n+    }\n+\n+    CBlockHeader GetBlockHeader() const\n+    {\n+        CBlockHeader block;\n+        block.nVersion       = nVersion;\n+        if (pprev)\n+            block.hashPrevBlock = pprev->GetBlockHash();\n+        block.hashMerkleRoot = hashMerkleRoot;\n+        block.nTime          = nTime;\n+        block.nBits          = nBits;\n+        block.nNonce         = nNonce;\n+        return block;\n+    }\n+\n+    uint256 GetBlockHash() const\n+    {\n+        return *phashBlock;\n+    }\n+\n+    int64_t GetBlockTime() const\n+    {\n+        return (int64_t)nTime;\n+    }\n+\n+    uint256 GetBlockWork() const\n+    {\n+        return GetProofIncrement(nBits);\n+    }\n+\n+    enum { nMedianTimeSpan=11 };\n+\n+    int64_t GetMedianTimePast() const\n+    {\n+        int64_t pmedian[nMedianTimeSpan];\n+        int64_t* pbegin = &pmedian[nMedianTimeSpan];\n+        int64_t* pend = &pmedian[nMedianTimeSpan];\n+\n+        const CBlockIndex* pindex = this;\n+        for (int i = 0; i < nMedianTimeSpan && pindex; i++, pindex = pindex->pprev)\n+            *(--pbegin) = pindex->GetBlockTime();\n+\n+        std::sort(pbegin, pend);\n+        return pbegin[(pend - pbegin)/2];\n+    }\n+\n+    /**\n+     * Returns true if there are nRequired or more blocks of minVersion or above\n+     * in the last Params().ToCheckBlockUpgradeMajority() blocks, starting at pstart \n+     * and going backwards.\n+     */\n+    static bool IsSuperMajority(int minVersion, const CBlockIndex* pstart,\n+                                unsigned int nRequired);\n+\n+    std::string ToString() const\n+    {\n+        return strprintf(\"CBlockIndex(pprev=%p, nHeight=%d, merkle=%s, hashBlock=%s)\",\n+            pprev, nHeight,\n+            hashMerkleRoot.ToString(),\n+            GetBlockHash().ToString());\n+    }\n+\n+    // Check whether this block index entry is valid up to the passed validity level.\n+    bool IsValid(enum BlockStatus nUpTo = BLOCK_VALID_TRANSACTIONS) const\n+    {\n+        assert(!(nUpTo & ~BLOCK_VALID_MASK)); // Only validity flags allowed.\n+        if (nStatus & BLOCK_FAILED_MASK)\n+            return false;\n+        return ((nStatus & BLOCK_VALID_MASK) >= nUpTo);\n+    }\n+\n+    // Raise the validity level of this block index entry.\n+    // Returns true if the validity was changed.\n+    bool RaiseValidity(enum BlockStatus nUpTo)\n+    {\n+        assert(!(nUpTo & ~BLOCK_VALID_MASK)); // Only validity flags allowed.\n+        if (nStatus & BLOCK_FAILED_MASK)\n+            return false;\n+        if ((nStatus & BLOCK_VALID_MASK) < nUpTo) {\n+            nStatus = (nStatus & ~BLOCK_VALID_MASK) | nUpTo;\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    // Build the skiplist pointer for this entry.\n+    void BuildSkip();\n+\n+    // Efficiently find an ancestor of this block.\n+    CBlockIndex* GetAncestor(int height);\n+    const CBlockIndex* GetAncestor(int height) const;\n+};\n+\n+/** Used to marshal pointers into hashes for db storage. */\n+class CDiskBlockIndex : public CBlockIndex\n+{\n+public:\n+    uint256 hashPrev;\n+\n+    CDiskBlockIndex() {\n+        hashPrev = 0;\n+    }\n+\n+    explicit CDiskBlockIndex(CBlockIndex* pindex) : CBlockIndex(*pindex) {\n+        hashPrev = (pprev ? pprev->GetBlockHash() : 0);\n+    }\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        if (!(nType & SER_GETHASH))\n+            READWRITE(VARINT(nVersion));\n+\n+        READWRITE(VARINT(nHeight));\n+        READWRITE(VARINT(nStatus));\n+        READWRITE(VARINT(nTx));\n+        if (nStatus & (BLOCK_HAVE_DATA | BLOCK_HAVE_UNDO))\n+            READWRITE(VARINT(nFile));\n+        if (nStatus & BLOCK_HAVE_DATA)\n+            READWRITE(VARINT(nDataPos));\n+        if (nStatus & BLOCK_HAVE_UNDO)\n+            READWRITE(VARINT(nUndoPos));\n+\n+        // block header\n+        READWRITE(this->nVersion);\n+        READWRITE(hashPrev);\n+        READWRITE(hashMerkleRoot);\n+        READWRITE(nTime);\n+        READWRITE(nBits);\n+        READWRITE(nNonce);\n+    }\n+\n+    uint256 GetBlockHash() const\n+    {\n+        CBlockHeader block;\n+        block.nVersion        = nVersion;\n+        block.hashPrevBlock   = hashPrev;\n+        block.hashMerkleRoot  = hashMerkleRoot;\n+        block.nTime           = nTime;\n+        block.nBits           = nBits;\n+        block.nNonce          = nNonce;\n+        return block.GetHash();\n+    }\n+\n+\n+    std::string ToString() const\n+    {\n+        std::string str = \"CDiskBlockIndex(\";\n+        str += CBlockIndex::ToString();\n+        str += strprintf(\"\\n                hashBlock=%s, hashPrev=%s)\",\n+            GetBlockHash().ToString(),\n+            hashPrev.ToString());\n+        return str;\n+    }\n+};\n+\n+/** An in-memory indexed chain of blocks. */\n+class CChain {\n+private:\n+    std::vector<CBlockIndex*> vChain;\n+\n+public:\n+    /** Returns the index entry for the genesis block of this chain, or NULL if none. */\n+    CBlockIndex *Genesis() const {\n+        return vChain.size() > 0 ? vChain[0] : NULL;\n+    }\n+\n+    /** Returns the index entry for the tip of this chain, or NULL if none. */\n+    CBlockIndex *Tip() const {\n+        return vChain.size() > 0 ? vChain[vChain.size() - 1] : NULL;\n+    }\n+\n+    /** Returns the index entry at a particular height in this chain, or NULL if no such height exists. */\n+    CBlockIndex *operator[](int nHeight) const {\n+        if (nHeight < 0 || nHeight >= (int)vChain.size())\n+            return NULL;\n+        return vChain[nHeight];\n+    }\n+\n+    /** Compare two chains efficiently. */\n+    friend bool operator==(const CChain &a, const CChain &b) {\n+        return a.vChain.size() == b.vChain.size() &&\n+               a.vChain[a.vChain.size() - 1] == b.vChain[b.vChain.size() - 1];\n+    }\n+\n+    /** Efficiently check whether a block is present in this chain. */\n+    bool Contains(const CBlockIndex *pindex) const {\n+        return (*this)[pindex->nHeight] == pindex;\n+    }\n+\n+    /** Find the successor of a block in this chain, or NULL if the given index is not found or is the tip. */\n+    CBlockIndex *Next(const CBlockIndex *pindex) const {\n+        if (Contains(pindex))\n+            return (*this)[pindex->nHeight + 1];\n+        else\n+            return NULL;\n+    }\n+\n+    /** Return the maximal height in the chain. Is equal to chain.Tip() ? chain.Tip()->nHeight : -1. */\n+    int Height() const {\n+        return vChain.size() - 1;\n+    }\n+\n+    /** Set/initialize a chain with a given tip. Returns the forking point. */\n+    CBlockIndex *SetTip(CBlockIndex *pindex);\n+\n+    /** Return a CBlockLocator that refers to a block in this chain (by default the tip). */\n+    CBlockLocator GetLocator(const CBlockIndex *pindex = NULL) const;\n+\n+    /** Find the last common block between this chain and a block index entry. */\n+    const CBlockIndex *FindFork(const CBlockIndex *pindex) const;\n+};\n+\n+#endif "
      },
      {
        "sha": "5210f8ef55c1e304e9fa037de3d2db887e82e94d",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 54,
        "changes": 54,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e8b5f0d549b1b76611c7374bed9ceec7d09fa847/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e8b5f0d549b1b76611c7374bed9ceec7d09fa847/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=e8b5f0d549b1b76611c7374bed9ceec7d09fa847",
        "patch": "@@ -385,52 +385,6 @@ void UnregisterNodeSignals(CNodeSignals& nodeSignals)\n     nodeSignals.FinalizeNode.disconnect(&FinalizeNode);\n }\n \n-//////////////////////////////////////////////////////////////////////////////\n-//\n-// CChain implementation\n-//\n-\n-CBlockIndex *CChain::SetTip(CBlockIndex *pindex) {\n-    if (pindex == NULL) {\n-        vChain.clear();\n-        return NULL;\n-    }\n-    vChain.resize(pindex->nHeight + 1);\n-    while (pindex && vChain[pindex->nHeight] != pindex) {\n-        vChain[pindex->nHeight] = pindex;\n-        pindex = pindex->pprev;\n-    }\n-    return pindex;\n-}\n-\n-CBlockLocator CChain::GetLocator(const CBlockIndex *pindex) const {\n-    int nStep = 1;\n-    std::vector<uint256> vHave;\n-    vHave.reserve(32);\n-\n-    if (!pindex)\n-        pindex = Tip();\n-    while (pindex) {\n-        vHave.push_back(pindex->GetBlockHash());\n-        // Stop when we have added the genesis block.\n-        if (pindex->nHeight == 0)\n-            break;\n-        // Exponentially larger steps back, plus the genesis block.\n-        int nHeight = std::max(pindex->nHeight - nStep, 0);\n-        if (Contains(pindex)) {\n-            // Use O(1) CChain index if possible.\n-            pindex = (*this)[nHeight];\n-        } else {\n-            // Otherwise, use O(log n) skiplist.\n-            pindex = pindex->GetAncestor(nHeight);\n-        }\n-        if (vHave.size() > 10)\n-            nStep *= 2;\n-    }\n-\n-    return CBlockLocator(vHave);\n-}\n-\n CBlockIndex* FindForkInGlobalIndex(const CChain& chain, const CBlockLocator& locator)\n {\n     // Find the first block the caller has in the main chain\n@@ -446,14 +400,6 @@ CBlockIndex* FindForkInGlobalIndex(const CChain& chain, const CBlockLocator& loc\n     return chain.Genesis();\n }\n \n-const CBlockIndex *CChain::FindFork(const CBlockIndex *pindex) const {\n-    if (pindex->nHeight > Height())\n-        pindex = pindex->GetAncestor(Height());\n-    while (pindex && !Contains(pindex))\n-        pindex = pindex->pprev;\n-    return pindex;\n-}\n-\n CCoinsViewCache *pcoinsTip = NULL;\n CBlockTreeDB *pblocktree = NULL;\n "
      },
      {
        "sha": "ff55a26cac3defe2a6da63c6e01419ee029d7e08",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 1,
        "deletions": 380,
        "changes": 381,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e8b5f0d549b1b76611c7374bed9ceec7d09fa847/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e8b5f0d549b1b76611c7374bed9ceec7d09fa847/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=e8b5f0d549b1b76611c7374bed9ceec7d09fa847",
        "patch": "@@ -10,6 +10,7 @@\n #include \"config/bitcoin-config.h\"\n #endif\n \n+#include \"chain.h\"\n #include \"chainparams.h\"\n #include \"coins.h\"\n #include \"core.h\"\n@@ -113,7 +114,6 @@ static const uint64_t nMinDiskSpace = 52428800;\n \n \n class CBlockTreeDB;\n-struct CDiskBlockPos;\n class CTxUndo;\n class CScriptCheck;\n class CValidationState;\n@@ -189,51 +189,11 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n                         bool* pfMissingInputs, bool fRejectInsaneFee=false);\n \n \n-\n-\n-\n-\n-\n-\n struct CNodeStateStats {\n     int nMisbehavior;\n     int nSyncHeight;\n };\n \n-struct CDiskBlockPos\n-{\n-    int nFile;\n-    unsigned int nPos;\n-\n-    ADD_SERIALIZE_METHODS;\n-\n-    template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n-        READWRITE(VARINT(nFile));\n-        READWRITE(VARINT(nPos));\n-    }\n-\n-    CDiskBlockPos() {\n-        SetNull();\n-    }\n-\n-    CDiskBlockPos(int nFileIn, unsigned int nPosIn) {\n-        nFile = nFileIn;\n-        nPos = nPosIn;\n-    }\n-\n-    friend bool operator==(const CDiskBlockPos &a, const CDiskBlockPos &b) {\n-        return (a.nFile == b.nFile && a.nPos == b.nPos);\n-    }\n-\n-    friend bool operator!=(const CDiskBlockPos &a, const CDiskBlockPos &b) {\n-        return !(a == b);\n-    }\n-\n-    void SetNull() { nFile = -1; nPos = 0; }\n-    bool IsNull() const { return (nFile == -1); }\n-};\n-\n struct CDiskTxPos : public CDiskBlockPos\n {\n     unsigned int nTxOffset; // after header\n@@ -547,288 +507,6 @@ class CBlockFileInfo\n      }\n };\n \n-enum BlockStatus {\n-    BLOCK_VALID_UNKNOWN      =    0,\n-    BLOCK_VALID_HEADER       =    1, // parsed, version ok, hash satisfies claimed PoW, 1 <= vtx count <= max, timestamp not in future\n-    BLOCK_VALID_TREE         =    2, // parent found, difficulty matches, timestamp >= median previous, checkpoint\n-    BLOCK_VALID_TRANSACTIONS =    3, // only first tx is coinbase, 2 <= coinbase input script length <= 100, transactions valid, no duplicate txids, sigops, size, merkle root\n-    BLOCK_VALID_CHAIN        =    4, // outputs do not overspend inputs, no double spends, coinbase output ok, immature coinbase spends, BIP30\n-    BLOCK_VALID_SCRIPTS      =    5, // scripts/signatures ok\n-    BLOCK_VALID_MASK         =   BLOCK_VALID_HEADER | BLOCK_VALID_TREE | BLOCK_VALID_TRANSACTIONS |\n-                                 BLOCK_VALID_CHAIN | BLOCK_VALID_SCRIPTS,\n-\n-    BLOCK_HAVE_DATA          =    8, // full block available in blk*.dat\n-    BLOCK_HAVE_UNDO          =   16, // undo data available in rev*.dat\n-    BLOCK_HAVE_MASK          =   BLOCK_HAVE_DATA | BLOCK_HAVE_UNDO,\n-\n-    BLOCK_FAILED_VALID       =   32, // stage after last reached validness failed\n-    BLOCK_FAILED_CHILD       =   64, // descends from failed block\n-    BLOCK_FAILED_MASK        =   BLOCK_FAILED_VALID | BLOCK_FAILED_CHILD,\n-};\n-\n-/** The block chain is a tree shaped structure starting with the\n- * genesis block at the root, with each block potentially having multiple\n- * candidates to be the next block. A blockindex may have multiple pprev pointing\n- * to it, but at most one of them can be part of the currently active branch.\n- */\n-class CBlockIndex\n-{\n-public:\n-    // pointer to the hash of the block, if any. memory is owned by this CBlockIndex\n-    const uint256* phashBlock;\n-\n-    // pointer to the index of the predecessor of this block\n-    CBlockIndex* pprev;\n-\n-    // pointer to the index of some further predecessor of this block\n-    CBlockIndex* pskip;\n-\n-    // height of the entry in the chain. The genesis block has height 0\n-    int nHeight;\n-\n-    // Which # file this block is stored in (blk?????.dat)\n-    int nFile;\n-\n-    // Byte offset within blk?????.dat where this block's data is stored\n-    unsigned int nDataPos;\n-\n-    // Byte offset within rev?????.dat where this block's undo data is stored\n-    unsigned int nUndoPos;\n-\n-    // (memory only) Total amount of work (expected number of hashes) in the chain up to and including this block\n-    uint256 nChainWork;\n-\n-    // Number of transactions in this block.\n-    // Note: in a potential headers-first mode, this number cannot be relied upon\n-    unsigned int nTx;\n-\n-    // (memory only) Number of transactions in the chain up to and including this block\n-    unsigned int nChainTx; // change to 64-bit type when necessary; won't happen before 2030\n-\n-    // Verification status of this block. See enum BlockStatus\n-    unsigned int nStatus;\n-\n-    // block header\n-    int nVersion;\n-    uint256 hashMerkleRoot;\n-    unsigned int nTime;\n-    unsigned int nBits;\n-    unsigned int nNonce;\n-\n-    // (memory only) Sequencial id assigned to distinguish order in which blocks are received.\n-    uint32_t nSequenceId;\n-\n-    void SetNull()\n-    {\n-        phashBlock = NULL;\n-        pprev = NULL;\n-        pskip = NULL;\n-        nHeight = 0;\n-        nFile = 0;\n-        nDataPos = 0;\n-        nUndoPos = 0;\n-        nChainWork = 0;\n-        nTx = 0;\n-        nChainTx = 0;\n-        nStatus = 0;\n-        nSequenceId = 0;\n-\n-        nVersion       = 0;\n-        hashMerkleRoot = 0;\n-        nTime          = 0;\n-        nBits          = 0;\n-        nNonce         = 0;\n-    }\n-\n-    CBlockIndex()\n-    {\n-        SetNull();\n-    }\n-\n-    CBlockIndex(CBlockHeader& block)\n-    {\n-        SetNull();\n-\n-        nVersion       = block.nVersion;\n-        hashMerkleRoot = block.hashMerkleRoot;\n-        nTime          = block.nTime;\n-        nBits          = block.nBits;\n-        nNonce         = block.nNonce;\n-    }\n-\n-    CDiskBlockPos GetBlockPos() const {\n-        CDiskBlockPos ret;\n-        if (nStatus & BLOCK_HAVE_DATA) {\n-            ret.nFile = nFile;\n-            ret.nPos  = nDataPos;\n-        }\n-        return ret;\n-    }\n-\n-    CDiskBlockPos GetUndoPos() const {\n-        CDiskBlockPos ret;\n-        if (nStatus & BLOCK_HAVE_UNDO) {\n-            ret.nFile = nFile;\n-            ret.nPos  = nUndoPos;\n-        }\n-        return ret;\n-    }\n-\n-    CBlockHeader GetBlockHeader() const\n-    {\n-        CBlockHeader block;\n-        block.nVersion       = nVersion;\n-        if (pprev)\n-            block.hashPrevBlock = pprev->GetBlockHash();\n-        block.hashMerkleRoot = hashMerkleRoot;\n-        block.nTime          = nTime;\n-        block.nBits          = nBits;\n-        block.nNonce         = nNonce;\n-        return block;\n-    }\n-\n-    uint256 GetBlockHash() const\n-    {\n-        return *phashBlock;\n-    }\n-\n-    int64_t GetBlockTime() const\n-    {\n-        return (int64_t)nTime;\n-    }\n-\n-    uint256 GetBlockWork() const\n-    {\n-        return GetProofIncrement(nBits);\n-    }\n-\n-    enum { nMedianTimeSpan=11 };\n-\n-    int64_t GetMedianTimePast() const\n-    {\n-        int64_t pmedian[nMedianTimeSpan];\n-        int64_t* pbegin = &pmedian[nMedianTimeSpan];\n-        int64_t* pend = &pmedian[nMedianTimeSpan];\n-\n-        const CBlockIndex* pindex = this;\n-        for (int i = 0; i < nMedianTimeSpan && pindex; i++, pindex = pindex->pprev)\n-            *(--pbegin) = pindex->GetBlockTime();\n-\n-        std::sort(pbegin, pend);\n-        return pbegin[(pend - pbegin)/2];\n-    }\n-\n-    /**\n-     * Returns true if there are nRequired or more blocks of minVersion or above\n-     * in the last Params().ToCheckBlockUpgradeMajority() blocks, starting at pstart \n-     * and going backwards.\n-     */\n-    static bool IsSuperMajority(int minVersion, const CBlockIndex* pstart,\n-                                unsigned int nRequired);\n-\n-    std::string ToString() const\n-    {\n-        return strprintf(\"CBlockIndex(pprev=%p, nHeight=%d, merkle=%s, hashBlock=%s)\",\n-            pprev, nHeight,\n-            hashMerkleRoot.ToString(),\n-            GetBlockHash().ToString());\n-    }\n-\n-    // Check whether this block index entry is valid up to the passed validity level.\n-    bool IsValid(enum BlockStatus nUpTo = BLOCK_VALID_TRANSACTIONS) const\n-    {\n-        assert(!(nUpTo & ~BLOCK_VALID_MASK)); // Only validity flags allowed.\n-        if (nStatus & BLOCK_FAILED_MASK)\n-            return false;\n-        return ((nStatus & BLOCK_VALID_MASK) >= nUpTo);\n-    }\n-\n-    // Raise the validity level of this block index entry.\n-    // Returns true if the validity was changed.\n-    bool RaiseValidity(enum BlockStatus nUpTo)\n-    {\n-        assert(!(nUpTo & ~BLOCK_VALID_MASK)); // Only validity flags allowed.\n-        if (nStatus & BLOCK_FAILED_MASK)\n-            return false;\n-        if ((nStatus & BLOCK_VALID_MASK) < nUpTo) {\n-            nStatus = (nStatus & ~BLOCK_VALID_MASK) | nUpTo;\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    // Build the skiplist pointer for this entry.\n-    void BuildSkip();\n-\n-    // Efficiently find an ancestor of this block.\n-    CBlockIndex* GetAncestor(int height);\n-    const CBlockIndex* GetAncestor(int height) const;\n-};\n-\n-/** Used to marshal pointers into hashes for db storage. */\n-class CDiskBlockIndex : public CBlockIndex\n-{\n-public:\n-    uint256 hashPrev;\n-\n-    CDiskBlockIndex() {\n-        hashPrev = 0;\n-    }\n-\n-    explicit CDiskBlockIndex(CBlockIndex* pindex) : CBlockIndex(*pindex) {\n-        hashPrev = (pprev ? pprev->GetBlockHash() : 0);\n-    }\n-\n-    ADD_SERIALIZE_METHODS;\n-\n-    template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n-        if (!(nType & SER_GETHASH))\n-            READWRITE(VARINT(nVersion));\n-\n-        READWRITE(VARINT(nHeight));\n-        READWRITE(VARINT(nStatus));\n-        READWRITE(VARINT(nTx));\n-        if (nStatus & (BLOCK_HAVE_DATA | BLOCK_HAVE_UNDO))\n-            READWRITE(VARINT(nFile));\n-        if (nStatus & BLOCK_HAVE_DATA)\n-            READWRITE(VARINT(nDataPos));\n-        if (nStatus & BLOCK_HAVE_UNDO)\n-            READWRITE(VARINT(nUndoPos));\n-\n-        // block header\n-        READWRITE(this->nVersion);\n-        READWRITE(hashPrev);\n-        READWRITE(hashMerkleRoot);\n-        READWRITE(nTime);\n-        READWRITE(nBits);\n-        READWRITE(nNonce);\n-    }\n-\n-    uint256 GetBlockHash() const\n-    {\n-        CBlockHeader block;\n-        block.nVersion        = nVersion;\n-        block.hashPrevBlock   = hashPrev;\n-        block.hashMerkleRoot  = hashMerkleRoot;\n-        block.nTime           = nTime;\n-        block.nBits           = nBits;\n-        block.nNonce          = nNonce;\n-        return block.GetHash();\n-    }\n-\n-\n-    std::string ToString() const\n-    {\n-        std::string str = \"CDiskBlockIndex(\";\n-        str += CBlockIndex::ToString();\n-        str += strprintf(\"\\n                hashBlock=%s, hashPrev=%s)\",\n-            GetBlockHash().ToString(),\n-            hashPrev.ToString());\n-        return str;\n-    }\n-};\n-\n /** Capture information about block/transaction validation */\n class CValidationState {\n private:\n@@ -900,63 +578,6 @@ class CVerifyDB {\n     bool VerifyDB(CCoinsView *coinsview, int nCheckLevel, int nCheckDepth);\n };\n \n-/** An in-memory indexed chain of blocks. */\n-class CChain {\n-private:\n-    std::vector<CBlockIndex*> vChain;\n-\n-public:\n-    /** Returns the index entry for the genesis block of this chain, or NULL if none. */\n-    CBlockIndex *Genesis() const {\n-        return vChain.size() > 0 ? vChain[0] : NULL;\n-    }\n-\n-    /** Returns the index entry for the tip of this chain, or NULL if none. */\n-    CBlockIndex *Tip() const {\n-        return vChain.size() > 0 ? vChain[vChain.size() - 1] : NULL;\n-    }\n-\n-    /** Returns the index entry at a particular height in this chain, or NULL if no such height exists. */\n-    CBlockIndex *operator[](int nHeight) const {\n-        if (nHeight < 0 || nHeight >= (int)vChain.size())\n-            return NULL;\n-        return vChain[nHeight];\n-    }\n-\n-    /** Compare two chains efficiently. */\n-    friend bool operator==(const CChain &a, const CChain &b) {\n-        return a.vChain.size() == b.vChain.size() &&\n-               a.vChain[a.vChain.size() - 1] == b.vChain[b.vChain.size() - 1];\n-    }\n-\n-    /** Efficiently check whether a block is present in this chain. */\n-    bool Contains(const CBlockIndex *pindex) const {\n-        return (*this)[pindex->nHeight] == pindex;\n-    }\n-\n-    /** Find the successor of a block in this chain, or NULL if the given index is not found or is the tip. */\n-    CBlockIndex *Next(const CBlockIndex *pindex) const {\n-        if (Contains(pindex))\n-            return (*this)[pindex->nHeight + 1];\n-        else\n-            return NULL;\n-    }\n-\n-    /** Return the maximal height in the chain. Is equal to chain.Tip() ? chain.Tip()->nHeight : -1. */\n-    int Height() const {\n-        return vChain.size() - 1;\n-    }\n-\n-    /** Set/initialize a chain with a given tip. Returns the forking point. */\n-    CBlockIndex *SetTip(CBlockIndex *pindex);\n-\n-    /** Return a CBlockLocator that refers to a block in this chain (by default the tip). */\n-    CBlockLocator GetLocator(const CBlockIndex *pindex = NULL) const;\n-\n-    /** Find the last common block between this chain and a block index entry. */\n-    const CBlockIndex *FindFork(const CBlockIndex *pindex) const;\n-};\n-\n /** Find the last common block between the parameter chain and a locator. */\n CBlockIndex* FindForkInGlobalIndex(const CChain& chain, const CBlockLocator& locator);\n "
      }
    ]
  }
]