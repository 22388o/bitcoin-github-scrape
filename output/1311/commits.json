[
  {
    "sha": "6dbd0199d26cb4dcb6393dea6e9c78d461d7fe40",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2ZGJkMDE5OWQyNmNiNGRjYjYzOTNkZWE2ZTljNzhkNDYxZDdmZTQw",
    "commit": {
      "author": {
        "name": "R E Broadley",
        "email": "rebroad+github@gmail.com",
        "date": "2012-05-17T14:35:44Z"
      },
      "committer": {
        "name": "R E Broadley",
        "email": "rebroad+github@gmail.com",
        "date": "2012-05-17T17:37:32Z"
      },
      "message": "Improve debug.log output.\n\nAlso, rename AlreadyAskedFor to AlreadyWaitingFor (makes more sense, as can cease waiting, but cannot stop having done a past thing.)\n\nOnly display peer if fLogPeers is set, for privacy purposes.\n\nConflicts:\n\n\tsrc/main.cpp",
      "tree": {
        "sha": "4e725b20c82cf81deb95b810b2ce4c55f301cac2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4e725b20c82cf81deb95b810b2ce4c55f301cac2"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6dbd0199d26cb4dcb6393dea6e9c78d461d7fe40",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6dbd0199d26cb4dcb6393dea6e9c78d461d7fe40",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6dbd0199d26cb4dcb6393dea6e9c78d461d7fe40",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6dbd0199d26cb4dcb6393dea6e9c78d461d7fe40/comments",
    "author": {
      "login": "rebroad",
      "id": 1530283,
      "node_id": "MDQ6VXNlcjE1MzAyODM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1530283?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rebroad",
      "html_url": "https://github.com/rebroad",
      "followers_url": "https://api.github.com/users/rebroad/followers",
      "following_url": "https://api.github.com/users/rebroad/following{/other_user}",
      "gists_url": "https://api.github.com/users/rebroad/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rebroad/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rebroad/subscriptions",
      "organizations_url": "https://api.github.com/users/rebroad/orgs",
      "repos_url": "https://api.github.com/users/rebroad/repos",
      "events_url": "https://api.github.com/users/rebroad/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rebroad/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "rebroad",
      "id": 1530283,
      "node_id": "MDQ6VXNlcjE1MzAyODM=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1530283?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rebroad",
      "html_url": "https://github.com/rebroad",
      "followers_url": "https://api.github.com/users/rebroad/followers",
      "following_url": "https://api.github.com/users/rebroad/following{/other_user}",
      "gists_url": "https://api.github.com/users/rebroad/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rebroad/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rebroad/subscriptions",
      "organizations_url": "https://api.github.com/users/rebroad/orgs",
      "repos_url": "https://api.github.com/users/rebroad/repos",
      "events_url": "https://api.github.com/users/rebroad/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rebroad/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "0c7fd9458576ae4b182f561bfd25ce16ca8bb5da",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0c7fd9458576ae4b182f561bfd25ce16ca8bb5da",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0c7fd9458576ae4b182f561bfd25ce16ca8bb5da"
      }
    ],
    "stats": {
      "total": 509,
      "additions": 372,
      "deletions": 137
    },
    "files": [
      {
        "sha": "17b1b23cc43045fbdecbebc6b1ecccddb934576b",
        "filename": ".gitignore",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6dbd0199d26cb4dcb6393dea6e9c78d461d7fe40/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6dbd0199d26cb4dcb6393dea6e9c78d461d7fe40/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.gitignore?ref=6dbd0199d26cb4dcb6393dea6e9c78d461d7fe40",
        "patch": "@@ -20,3 +20,4 @@ qrc_*.cpp\n *.pro.user\n #mac specific\n .DS_Store\n+build/"
      },
      {
        "sha": "b673e76db2e5dd8d4e4265bc428893a3d798810e",
        "filename": "src/addrman.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6dbd0199d26cb4dcb6393dea6e9c78d461d7fe40/src/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6dbd0199d26cb4dcb6393dea6e9c78d461d7fe40/src/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.cpp?ref=6dbd0199d26cb4dcb6393dea6e9c78d461d7fe40",
        "patch": "@@ -303,7 +303,8 @@ void CAddrMan::Good_(const CService &addr, int64 nTime)\n     // TODO: maybe re-add the node, but for now, just bail out\n     if (nUBucket == -1) return;\n \n-    printf(\"Moving %s to tried\\n\", addr.ToString().c_str());\n+    if (fDebug)\n+        printf(\"Moving %s to tried\\n\", addr.ToString().c_str());\n \n     // move nId to the tried tables\n     MakeTried(info, nId, nUBucket);"
      },
      {
        "sha": "69a5bbcbe5b54c828ce728ced9e4a54e6786f80d",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6dbd0199d26cb4dcb6393dea6e9c78d461d7fe40/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6dbd0199d26cb4dcb6393dea6e9c78d461d7fe40/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=6dbd0199d26cb4dcb6393dea6e9c78d461d7fe40",
        "patch": "@@ -418,7 +418,7 @@ class CAddrMan\n             fRet |= Add_(addr, source, nTimePenalty);\n             Check();\n         }\n-        if (fRet)\n+        if (fRet && CaughtUp())\n             printf(\"Added %s from %s: %i tried, %i new\\n\", addr.ToStringIPPort().c_str(), source.ToString().c_str(), nTried, nNew);\n         return fRet;\n     }\n@@ -434,7 +434,7 @@ class CAddrMan\n                 nAdd += Add_(*it, source, nTimePenalty) ? 1 : 0;\n             Check();\n         }\n-        if (nAdd)\n+        if (nAdd && CaughtUp())\n             printf(\"Added %i addresses from %s: %i tried, %i new\\n\", nAdd, source.ToString().c_str(), nTried, nNew);\n         return nAdd > 0;\n     }"
      },
      {
        "sha": "633d597eb757d1889233bf4bf2211902c76f4aa1",
        "filename": "src/db.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 1,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6dbd0199d26cb4dcb6393dea6e9c78d461d7fe40/src/db.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6dbd0199d26cb4dcb6393dea6e9c78d461d7fe40/src/db.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/db.cpp?ref=6dbd0199d26cb4dcb6393dea6e9c78d461d7fe40",
        "patch": "@@ -289,6 +289,7 @@ bool CDB::Rewrite(const string& strFile, const char* pszSkip)\n \n void DBFlush(bool fShutdown)\n {\n+    int64 nStart = GetTimeMillis();\n     // Flush log data to the actual data file\n     //  on all files that are not in use\n     printf(\"DBFlush(%s)%s\\n\", fShutdown ? \"true\" : \"false\", fDbEnvInit ? \"\" : \" db not started\");\n@@ -318,6 +319,7 @@ void DBFlush(bool fShutdown)\n             else\n                 mi++;\n         }\n+        printf(\"DBFlush: After while loop (%s)%s %15\"PRI64d\"ms\\n\", fShutdown ? \"true\" : \"false\", fDbEnvInit ? \"\" : \" db not started\", GetTimeMillis() - nStart);\n         if (fShutdown)\n         {\n             char** listp;\n@@ -589,7 +591,9 @@ bool CTxDB::LoadBlockIndex()\n     pindexBest = mapBlockIndex[hashBestChain];\n     nBestHeight = pindexBest->nHeight;\n     bnBestChainWork = pindexBest->bnChainWork;\n-    printf(\"LoadBlockIndex(): hashBestChain=%s  height=%d\\n\", hashBestChain.ToString().substr(0,20).c_str(), nBestHeight);\n+    printf(\"LoadBlockIndex(): hashBestChain=%s  height=%d  date=%s\\n\",\n+      hashBestChain.ToString().substr(0,20).c_str(), nBestHeight,\n+      DateTimeStrFormat(\"%x %H:%M:%S\", pindexBest->GetBlockTime()).c_str());\n \n     // Load bnBestInvalidWork, OK if it doesn't exist\n     ReadBestInvalidWork(bnBestInvalidWork);"
      },
      {
        "sha": "d5fbd571961f172ecf43e89e7ad095e86bba4484",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 2,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6dbd0199d26cb4dcb6393dea6e9c78d461d7fe40/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6dbd0199d26cb4dcb6393dea6e9c78d461d7fe40/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=6dbd0199d26cb4dcb6393dea6e9c78d461d7fe40",
        "patch": "@@ -38,6 +38,7 @@ void ExitTimeout(void* parg)\n \n void Shutdown(void* parg)\n {\n+    printf(\"Shutdown() entered\\n\"); // REB\n     static CCriticalSection cs_Shutdown;\n     static bool fTaken;\n     bool fFirstThread = false;\n@@ -75,9 +76,10 @@ void Shutdown(void* parg)\n     }\n }\n \n-void HandleSIGTERM(int)\n+void HandleSIGTERM(int signal)\n {\n     fRequestShutdown = true;\n+    printf(\"HandleSIGTERM(%d)\\n\", signal);\n }\n \n \n@@ -154,6 +156,7 @@ bool AppInit(int argc, char* argv[])\n     }\n     if (!fRet)\n         Shutdown(NULL);\n+    printf(\"AppInit() exited\\n\");\n     return fRet;\n }\n #endif\n@@ -232,6 +235,7 @@ std::string HelpMessage()\n         \"  -testnet               \" + _(\"Use the test network\") + \"\\n\" +\n         \"  -debug                 \" + _(\"Output extra debugging information\") + \"\\n\" +\n         \"  -logtimestamps         \" + _(\"Prepend debug output with timestamp\") + \"\\n\" +\n+        \"  -quietinitial          \" + _(\"Reduce debug output on initial block download\") + \"\\n\" +\n         \"  -printtoconsole        \" + _(\"Send trace/debug info to console instead of debug.log file\") + \"\\n\" +\n #ifdef WIN32\n         \"  -printtodebugger       \" + _(\"Send trace/debug info to debugger\") + \"\\n\" +\n@@ -315,6 +319,8 @@ bool AppInit2()\n     fPrintToConsole = GetBoolArg(\"-printtoconsole\");\n     fPrintToDebugger = GetBoolArg(\"-printtodebugger\");\n     fLogTimestamps = GetBoolArg(\"-logtimestamps\");\n+    fQuietInitial = GetBoolArg(\"-quietinitial\");\n+    fLogPeers = GetBoolArg(\"-logpeers\");\n \n #if !defined(WIN32) && !defined(QT_GUI)\n     if (fDaemon)\n@@ -343,6 +349,7 @@ bool AppInit2()\n     printf(\"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\");\n     printf(\"Bitcoin version %s (%s)\\n\", FormatFullVersion().c_str(), CLIENT_DATE.c_str());\n     printf(\"Default data directory %s\\n\", GetDefaultDataDir().string().c_str());\n+    printf(\"Config file %s\\n\", GetConfigFile().c_str());\n \n     if (GetBoolArg(\"-loadblockindextest\"))\n     {\n@@ -487,7 +494,6 @@ bool AppInit2()\n \n     //// debug print\n     printf(\"mapBlockIndex.size() = %d\\n\",   mapBlockIndex.size());\n-    printf(\"nBestHeight = %d\\n\",            nBestHeight);\n     printf(\"setKeyPool.size() = %d\\n\",      pwalletMain->setKeyPool.size());\n     printf(\"mapWallet.size() = %d\\n\",       pwalletMain->mapWallet.size());\n     printf(\"mapAddressBook.size() = %d\\n\",  pwalletMain->mapAddressBook.size());\n@@ -662,6 +668,7 @@ bool AppInit2()\n \n     RandAddSeedPerfmon();\n \n+    printf(\"CreateThread(StartNode)\\n\");\n     if (!CreateThread(StartNode, NULL))\n         InitError(_(\"Error: could not start node\"));\n \n@@ -675,6 +682,7 @@ bool AppInit2()\n         Sleep(5000);\n #endif\n \n+    printf(\"AppInit2() exited\\n\");\n     return true;\n }\n "
      },
      {
        "sha": "82f7a8eee7f93036d40dd8c7a16d026ea654e6dc",
        "filename": "src/irc.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6dbd0199d26cb4dcb6393dea6e9c78d461d7fe40/src/irc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6dbd0199d26cb4dcb6393dea6e9c78d461d7fe40/src/irc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/irc.cpp?ref=6dbd0199d26cb4dcb6393dea6e9c78d461d7fe40",
        "patch": "@@ -200,7 +200,7 @@ void ThreadIRCSeed(void* parg)\n     } catch (...) {\n         PrintExceptionContinue(NULL, \"ThreadIRCSeed()\");\n     }\n-    printf(\"ThreadIRCSeed exiting\\n\");\n+    printf(\"ThreadIRCSeed exited\\n\");\n }\n \n void ThreadIRCSeed2(void* parg)\n@@ -321,7 +321,7 @@ void ThreadIRCSeed2(void* parg)\n                 // index 7 is limited to 16 characters\n                 // could get full length name at index 10, but would be different from join messages\n                 strlcpy(pszName, vWords[7].c_str(), sizeof(pszName));\n-                printf(\"IRC got who\\n\");\n+                if (fDebug) printf(\"IRC got who\\n\");\n             }\n \n             if (vWords[1] == \"JOIN\" && vWords[0].size() > 1)"
      },
      {
        "sha": "006939eb7d11508f3e7ace6f808245fff6a7ec71",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 297,
        "deletions": 97,
        "changes": 394,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6dbd0199d26cb4dcb6393dea6e9c78d461d7fe40/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6dbd0199d26cb4dcb6393dea6e9c78d461d7fe40/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=6dbd0199d26cb4dcb6393dea6e9c78d461d7fe40",
        "patch": "@@ -31,6 +31,7 @@ uint256 hashGenesisBlock(\"0x000000000019d6689c085ae165831e934ff763ae46a2a6c172b3\n static CBigNum bnProofOfWorkLimit(~uint256(0) >> 32);\n CBlockIndex* pindexGenesisBlock = NULL;\n int nBestHeight = -1;\n+CNode* txnode = NULL;           // node calling AcceptToMemoryPool()\n CBigNum bnBestChainWork = 0;\n CBigNum bnBestInvalidWork = 0;\n uint256 hashBestChain = 0;\n@@ -410,47 +411,68 @@ int CMerkleTx::SetMerkleBranch(const CBlock* pblock)\n \n bool CTransaction::CheckTransaction() const\n {\n+    uint256 hash = this->GetHash();\n+\n     // Basic checks that don't depend on any context\n-    if (vin.empty())\n-        return DoS(10, error(\"CTransaction::CheckTransaction() : vin empty\"));\n-    if (vout.empty())\n-        return DoS(10, error(\"CTransaction::CheckTransaction() : vout empty\"));\n+    if (vin.empty()) {\n+        if (txnode && fLogPeers) printf(\"%s \", txnode->addr.ToString().c_str());\n+        return DoS(10, error(\"checktx: %s vin empty\", hash.ToString().substr(0,10).c_str()));\n+    }\n+    if (vout.empty()) {\n+        if (txnode && fLogPeers) printf(\"%s \", txnode->addr.ToString().c_str());\n+        return DoS(10, error(\"checktx: %s vout empty\", hash.ToString().substr(0,10).c_str()));\n+    }\n     // Size limits\n-    if (::GetSerializeSize(*this, SER_NETWORK, PROTOCOL_VERSION) > MAX_BLOCK_SIZE)\n-        return DoS(100, error(\"CTransaction::CheckTransaction() : size limits failed\"));\n+    if (::GetSerializeSize(*this, SER_NETWORK, PROTOCOL_VERSION) > MAX_BLOCK_SIZE) {\n+        if (txnode) printf(\"%s \", txnode->addr.ToString().c_str());\n+        return DoS(100, error(\"checktx: %s size limits failed\", hash.ToString().substr(0,10).c_str()));\n+    }\n \n     // Check for negative or overflow output values\n     int64 nValueOut = 0;\n     BOOST_FOREACH(const CTxOut& txout, vout)\n     {\n-        if (txout.nValue < 0)\n-            return DoS(100, error(\"CTransaction::CheckTransaction() : txout.nValue negative\"));\n-        if (txout.nValue > MAX_MONEY)\n-            return DoS(100, error(\"CTransaction::CheckTransaction() : txout.nValue too high\"));\n+        if (txout.nValue < 0) {\n+            if (txnode) printf(\"%s \", txnode->addr.ToString().c_str());\n+            return DoS(100, error(\"checktx: %s txout.nValue negative\", hash.ToString().substr(0,10).c_str()));\n+        }\n+        if (txout.nValue > MAX_MONEY) {\n+            if (txnode) printf(\"%s \", txnode->addr.ToString().c_str());\n+            return DoS(100, error(\"checktx: %s txout.nValue too high\", hash.ToString().substr(0,10).c_str()));\n+        }\n         nValueOut += txout.nValue;\n-        if (!MoneyRange(nValueOut))\n-            return DoS(100, error(\"CTransaction::CheckTransaction() : txout total out of range\"));\n+        if (!MoneyRange(nValueOut)) {\n+            if (txnode) printf(\"%s \", txnode->addr.ToString().c_str());\n+            return DoS(100, error(\"checktx: %s txout total out of range\", hash.ToString().substr(0,10).c_str()));\n+        }\n     }\n \n     // Check for duplicate inputs\n     set<COutPoint> vInOutPoints;\n     BOOST_FOREACH(const CTxIn& txin, vin)\n     {\n-        if (vInOutPoints.count(txin.prevout))\n+        if (vInOutPoints.count(txin.prevout)) {\n+            if (txnode && fLogPeers) printf(\"%s \", txnode->addr.ToString().c_str());\n+            printf(\"checktx : %s duplicate input\\n\", hash.ToString().substr(0,10).c_str());\n             return false;\n+        }\n         vInOutPoints.insert(txin.prevout);\n     }\n \n     if (IsCoinBase())\n     {\n-        if (vin[0].scriptSig.size() < 2 || vin[0].scriptSig.size() > 100)\n-            return DoS(100, error(\"CTransaction::CheckTransaction() : coinbase script size\"));\n+        if (vin[0].scriptSig.size() < 2 || vin[0].scriptSig.size() > 100) {\n+            if (txnode) printf(\"%s \", txnode->addr.ToString().c_str());\n+            return DoS(100, error(\"checktx: %s coinbase script size %d\", hash.ToString().substr(0,10).c_str(), vin[0].scriptSig.size()));\n+        }\n     }\n     else\n     {\n         BOOST_FOREACH(const CTxIn& txin, vin)\n-            if (txin.prevout.IsNull())\n-                return DoS(10, error(\"CTransaction::CheckTransaction() : prevout is null\"));\n+            if (txin.prevout.IsNull()) {\n+                if (txnode && fLogPeers) printf(\"%s \", txnode->addr.ToString().c_str());\n+                return DoS(10, error(\"checktx: %s prevout is null\", hash.ToString().substr(0,10).c_str()));\n+            }\n     }\n \n     return true;\n@@ -459,26 +481,33 @@ bool CTransaction::CheckTransaction() const\n bool CTxMemPool::accept(CTxDB& txdb, CTransaction &tx, bool fCheckInputs,\n                         bool* pfMissingInputs)\n {\n+    uint256 hash = tx.GetHash();\n+\n     if (pfMissingInputs)\n         *pfMissingInputs = false;\n \n     if (!tx.CheckTransaction())\n-        return error(\"CTxMemPool::accept() : CheckTransaction failed\");\n+        return false;\n \n     // Coinbase is only valid in a block, not as a loose transaction\n-    if (tx.IsCoinBase())\n-        return tx.DoS(100, error(\"CTxMemPool::accept() : coinbase as individual tx\"));\n+    if (tx.IsCoinBase()) {\n+        if (txnode) printf(\"%s \", txnode->addr.ToString().c_str());\n+        return tx.DoS(100, error(\"txaccept: %s coinbase as individual tx\", hash.ToString().substr(0,10).c_str()));\n+    }\n \n     // To help v0.1.5 clients who would see it as a negative number\n-    if ((int64)tx.nLockTime > std::numeric_limits<int>::max())\n-        return error(\"CTxMemPool::accept() : not accepting nLockTime beyond 2038 yet\");\n+    if ((int64)tx.nLockTime > std::numeric_limits<int>::max()) {\n+        if (txnode && fLogPeers) printf(\"%s \", txnode->addr.ToString().c_str());\n+        return error(\"txaccept: %s not accepting nLockTime beyond 2038 yet\", hash.ToString().substr(0,10).c_str());\n+    }\n \n     // Rather not work on nonstandard transactions (unless -testnet)\n-    if (!fTestNet && !tx.IsStandard())\n-        return error(\"CTxMemPool::accept() : nonstandard transaction type\");\n+    if (!fTestNet && !tx.IsStandard()) {\n+        if (txnode && fLogPeers) printf(\"%s \", txnode->addr.ToString().c_str());\n+        return error(\"txaccept: %s nonstandard tx type\", hash.ToString().substr(0,10).c_str());\n+    }\n \n     // Do we already have it?\n-    uint256 hash = tx.GetHash();\n     {\n         LOCK(cs);\n         if (mapTx.count(hash))\n@@ -499,40 +528,66 @@ bool CTxMemPool::accept(CTxDB& txdb, CTransaction &tx, bool fCheckInputs,\n             return false;\n \n             // Allow replacing with a newer version of the same transaction\n-            if (i != 0)\n+            if (i != 0) {\n+                if (txnode && fLogPeers) printf(\"%s \", txnode->addr.ToString().c_str());\n+                printf(\"txaccept: replacement failed as i != 0\\n\", hash.ToString().substr(0,10).c_str());\n                 return false;\n+            }\n             ptxOld = mapNextTx[outpoint].ptx;\n-            if (ptxOld->IsFinal())\n+            if (ptxOld->IsFinal()) {\n+                if (txnode && fLogPeers) printf(\"%s \", txnode->addr.ToString().c_str());\n+                printf(\"txaccept: replacement failed as old outpoint IsFinal\\n\", hash.ToString().substr(0,10).c_str()); \n                 return false;\n-            if (!tx.IsNewerThan(*ptxOld))\n+            }\n+            if (!tx.IsNewerThan(*ptxOld)) {\n+                if (txnode && fLogPeers) printf(\"%s \", txnode->addr.ToString().c_str());\n+                printf(\"txaccept: %s replacement failed as IsNewerThan\\n\", hash.ToString().substr(0,10).c_str());\n                 return false;\n+            }\n             for (unsigned int i = 0; i < tx.vin.size(); i++)\n             {\n                 COutPoint outpoint = tx.vin[i].prevout;\n-                if (!mapNextTx.count(outpoint) || mapNextTx[outpoint].ptx != ptxOld)\n+                if (!mapNextTx.count(outpoint)) {\n+                    if (txnode && fLogPeers) printf(\"%s \", txnode->addr.ToString().c_str());\n+                    printf(\"txaccept: %s replacement failed as no outpoint found\\n\", hash.ToString().substr(0,10).c_str()); // REB\n+                    return false;\n+                }\n+                if (mapNextTx[outpoint].ptx != ptxOld) {\n+                    if (txnode && fLogPeers) printf(\"%s \", txnode->addr.ToString().c_str());\n+                    printf(\"txaccept: %s replacement failed as outpoint is different\\n\", hash.ToString().substr(0,10).c_str());\n                     return false;\n+                }\n             }\n+            if (txnode && fLogPeers) printf(\"%s \", txnode->addr.ToString().c_str());\n+            printf(\"txaccept: %s is a replacement\\n\", hash.ToString().substr(0,10).c_str());\n+\n             break;\n         }\n     }\n \n+    bool fFreetx = false;\n+\n     if (fCheckInputs)\n     {\n         MapPrevTx mapInputs;\n         map<uint256, CTxIndex> mapUnused;\n         bool fInvalid = false;\n         if (!tx.FetchInputs(txdb, mapUnused, false, false, mapInputs, fInvalid))\n         {\n-            if (fInvalid)\n-                return error(\"CTxMemPool::accept() : FetchInputs found invalid tx %s\", hash.ToString().substr(0,10).c_str());\n+            if (fInvalid) {\n+                if (txnode && fLogPeers) printf(\"%s \", txnode->addr.ToString().c_str());\n+                return error(\"txaccept: %s FetchInputs found invalid\", hash.ToString().substr(0,10).c_str());\n+            }\n             if (pfMissingInputs)\n                 *pfMissingInputs = true;\n             return false;\n         }\n \n         // Check for non-standard pay-to-script-hash in inputs\n-        if (!tx.AreInputsStandard(mapInputs) && !fTestNet)\n-            return error(\"CTxMemPool::accept() : nonstandard transaction input\");\n+        if (!tx.AreInputsStandard(mapInputs) && !fTestNet) {\n+            if (txnode && fLogPeers) printf(\"%s \", txnode->addr.ToString().c_str());\n+            return error(\"txaccept: %s nonstandard inputs\", hash.ToString().substr(0,10).c_str());\n+        }\n \n         // Note: if you modify this code to accept non-standard transactions, then\n         // you should add code here to check that the transaction does a\n@@ -542,8 +597,12 @@ bool CTxMemPool::accept(CTxDB& txdb, CTransaction &tx, bool fCheckInputs,\n         unsigned int nSize = ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);\n \n         // Don't accept it if it can't get into a block\n-        if (nFees < tx.GetMinFee(1000, true, GMF_RELAY))\n-            return error(\"CTxMemPool::accept() : not enough fees\");\n+        if (nFees < tx.GetMinFee(1000, true, GMF_RELAY)) {\n+            printf(\"txaccept: tx %s \", hash.ToString().substr(0,10).c_str());\n+            if (txnode && fLogPeers) printf(\"from %s \", txnode->addr.ToString().c_str());\n+            printf(\"not enough fees\\n\");\n+            return false;\n+        }\n \n         // Continuously rate-limit free transactions\n         // This mitigates 'penny-flooding' -- sending thousands of free transactions just to\n@@ -562,28 +621,33 @@ bool CTxMemPool::accept(CTxDB& txdb, CTransaction &tx, bool fCheckInputs,\n                 nLastTime = nNow;\n                 // -limitfreerelay unit is thousand-bytes-per-minute\n                 // At default rate it would take over a month to fill 1GB\n-                if (dFreeCount > GetArg(\"-limitfreerelay\", 15)*10*1000 && !IsFromMe(tx))\n-                    return error(\"CTxMemPool::accept() : free transaction rejected by rate limiter\");\n+                if (dFreeCount > GetArg(\"-limitfreerelay\", 15)*10*1000 && !IsFromMe(tx)) {\n+                    printf(\"txaccept: free tx %s \", hash.ToString().substr(0,10).c_str());\n+                    if (txnode && fLogPeers) printf(\"from %s \", txnode->addr.ToString().c_str());\n+                    printf(\"rejected by rate limiter\\n\");\n+                    return false;\n+                } else\n+                    fFreetx = true;\n                 if (fDebug)\n                     printf(\"Rate limit dFreeCount: %g => %g\\n\", dFreeCount, dFreeCount+nSize);\n                 dFreeCount += nSize;\n             }\n-        }\n+        } // nFees < MIN_RELAY_TX_FEE\n \n         // Check against previous transactions\n         // This is done last to help prevent CPU exhaustion denial-of-service attacks.\n         if (!tx.ConnectInputs(mapInputs, mapUnused, CDiskTxPos(1,1,1), pindexBest, false, false))\n         {\n-            return error(\"CTxMemPool::accept() : ConnectInputs failed %s\", hash.ToString().substr(0,10).c_str());\n+            return error(\"mempool: ConnectInputs failed %s\", hash.ToString().substr(0,10).c_str());\n         }\n-    }\n+    } // if (fCheckInputs)\n \n     // Store transaction in memory\n     {\n         LOCK(cs);\n         if (ptxOld)\n         {\n-            printf(\"CTxMemPool::accept() : replacing tx %s with new version\\n\", ptxOld->GetHash().ToString().c_str());\n+            printf(\"CTxMemPool::accept(): replacing tx %s with new version (%s)\\n\", ptxOld->GetHash().ToString().c_str(), hash.ToString().substr(0,10).c_str());\n             remove(*ptxOld);\n         }\n         addUnchecked(tx);\n@@ -594,9 +658,10 @@ bool CTxMemPool::accept(CTxDB& txdb, CTransaction &tx, bool fCheckInputs,\n     if (ptxOld)\n         EraseFromWallets(ptxOld->GetHash());\n \n-    printf(\"CTxMemPool::accept() : accepted %s (poolsz %u)\\n\",\n-           hash.ToString().substr(0,10).c_str(),\n-           mapTx.size());\n+    printf(\"mempool %lu: \", mapTx.size());\n+    if (fFreetx) printf(\"free \");\n+    printf(\"tx %s accepted \", hash.ToString().substr(0,10).c_str());\n+\n     return true;\n }\n \n@@ -925,6 +990,13 @@ int GetNumBlocksOfPeers()\n     return std::max(cPeerBlockCounts.median(), Checkpoints::GetTotalBlocksEstimate());\n }\n \n+bool CaughtUp()\n+{\n+    int BlocksOfPeers = GetNumBlocksOfPeers();\n+    //printf(\"CaughtUp: nBestHeight=%d, GetNumBlocksOfPeers()=%d\\n\", nBestHeight, BlocksOfPeers);\n+    return (nBestHeight >= BlocksOfPeers);\n+}\n+\n bool IsInitialBlockDownload()\n {\n     if (pindexBest == NULL || nBestHeight < Checkpoints::GetTotalBlocksEstimate())\n@@ -948,8 +1020,13 @@ void static InvalidChainFound(CBlockIndex* pindexNew)\n         CTxDB().WriteBestInvalidWork(bnBestInvalidWork);\n         MainFrameRepaint();\n     }\n-    printf(\"InvalidChainFound: invalid block=%s  height=%d  work=%s\\n\", pindexNew->GetBlockHash().ToString().substr(0,20).c_str(), pindexNew->nHeight, pindexNew->bnChainWork.ToString().c_str());\n-    printf(\"InvalidChainFound:  current best=%s  height=%d  work=%s\\n\", hashBestChain.ToString().substr(0,20).c_str(), nBestHeight, bnBestChainWork.ToString().c_str());\n+    printf(\"InvalidChainFound: invalid block=%s  height=%d  work=%s  date=%s\\n\",\n+      pindexNew->GetBlockHash().ToString().substr(0,20).c_str(), pindexNew->nHeight,\n+      pindexNew->bnChainWork.ToString().c_str(), DateTimeStrFormat(\"%x %H:%M:%S\",\n+      pindexNew->GetBlockTime()).c_str());\n+    printf(\"InvalidChainFound:  current best=%s  height=%d  work=%s  date=%s\\n\",\n+      hashBestChain.ToString().substr(0,20).c_str(), nBestHeight, bnBestChainWork.ToString().c_str(),\n+      DateTimeStrFormat(\"%x %H:%M:%S\", pindexBest->GetBlockTime()).c_str());\n     if (pindexBest && bnBestInvalidWork > bnBestChainWork + pindexBest->GetBlockWork() * 6)\n         printf(\"InvalidChainFound: WARNING: Displayed transactions may not be correct!  You may need to upgrade, or other nodes may need to upgrade.\\n\");\n }\n@@ -1050,8 +1127,11 @@ bool CTransaction::FetchInputs(CTxDB& txdb, const map<uint256, CTxIndex>& mapTes\n             // Get prev tx from single transactions in memory\n             {\n                 LOCK(mempool.cs);\n-                if (!mempool.exists(prevout.hash))\n-                    return error(\"FetchInputs() : %s mempool Tx prev not found %s\", GetHash().ToString().substr(0,10).c_str(),  prevout.hash.ToString().substr(0,10).c_str());\n+                if (!mempool.exists(prevout.hash)) {\n+                    if (CaughtUp())\n+                        printf(\"mempool.exists() : %s prev (%s) not found\\n\", GetHash().ToString().substr(0,10).c_str(),  prevout.hash.ToString().substr(0,10).c_str());\n+                    return false;\n+                }\n                 txPrev = mempool.lookup(prevout.hash);\n             }\n             if (!fFound)\n@@ -1151,8 +1231,10 @@ bool CTransaction::ConnectInputs(MapPrevTx inputs,\n             // If prev is coinbase, check that it's matured\n             if (txPrev.IsCoinBase())\n                 for (const CBlockIndex* pindex = pindexBlock; pindex && pindexBlock->nHeight - pindex->nHeight < COINBASE_MATURITY; pindex = pindex->pprev)\n-                    if (pindex->nBlockPos == txindex.pos.nBlockPos && pindex->nFile == txindex.pos.nFile)\n-                        return error(\"ConnectInputs() : tried to spend coinbase at depth %d\", pindexBlock->nHeight - pindex->nHeight);\n+                    if (pindex->nBlockPos == txindex.pos.nBlockPos && pindex->nFile == txindex.pos.nFile) {\n+                        if (fBlock) printf(\"AcceptBLock(): \");\n+                        return error(\"ConnectInputs(): tried to spend coinbase at depth %d\", pindexBlock->nHeight - pindex->nHeight);\n+                    }\n \n             // Check for conflicts (double-spend)\n             // This doesn't trigger the DoS code on purpose; if it did, it would make it easier\n@@ -1301,8 +1383,10 @@ bool CBlock::ConnectBlock(CTxDB& txdb, CBlockIndex* pindex)\n             if (txdb.ReadTxIndex(tx.GetHash(), txindexOld))\n             {\n                 BOOST_FOREACH(CDiskTxPos &pos, txindexOld.vSpent)\n-                    if (pos.IsNull())\n+                    if (pos.IsNull()) {\n+                        printf(\"Failing ConnectBlock() due BIP30\\n\");  // REB\n                         return false;\n+                    }\n             }\n         }\n     }\n@@ -1359,8 +1443,10 @@ bool CBlock::ConnectBlock(CTxDB& txdb, CBlockIndex* pindex)\n             return error(\"ConnectBlock() : UpdateTxIndex failed\");\n     }\n \n-    if (vtx[0].GetValueOut() > GetBlockValue(pindex->nHeight, nFees))\n+    if (vtx[0].GetValueOut() > GetBlockValue(pindex->nHeight, nFees)) {\n+        printf(\"ConnectBlock() fail due to GetValueOut too high\\n\");\n         return false;\n+    }\n \n     // Update block index on disk without changing it in memory.\n     // The memory index structure will be changed after the db commits.\n@@ -1633,9 +1719,14 @@ bool CBlock::AddToBlockIndex(unsigned int nFile, unsigned int nBlockPos)\n         return false;\n \n     // New best\n-    if (pindexNew->bnChainWork > bnBestChainWork)\n-        if (!SetBestChain(txdb, pindexNew))\n+    if (pindexNew->bnChainWork > bnBestChainWork) {\n+        if (CaughtUp()) printf(\"New block is a potential best. Checking...\\n\");\n+        if (!SetBestChain(txdb, pindexNew)) {\n+            printf(\"SetBestChain() failed\\n\");\n             return false;\n+        }\n+    } else\n+        printf(\"New block has less work than current best.\\n\");\n \n     txdb.Close();\n \n@@ -1764,12 +1855,18 @@ bool CBlock::AcceptBlock()\n \n bool ProcessBlock(CNode* pfrom, CBlock* pblock)\n {\n+    int64 nStart;\n+    nStart = GetTimeMillis();\n     // Check for duplicate\n     uint256 hash = pblock->GetHash();\n-    if (mapBlockIndex.count(hash))\n-        return error(\"ProcessBlock() : already have block %d %s\", mapBlockIndex[hash]->nHeight, hash.ToString().substr(0,20).c_str());\n-    if (mapOrphanBlocks.count(hash))\n-        return error(\"ProcessBlock() : already have block (orphan) %s\", hash.ToString().substr(0,20).c_str());\n+    if (mapBlockIndex.count(hash)) {\n+        printf(\"ProcessBlock() : already have block %d %s\\n\", mapBlockIndex[hash]->nHeight, hash.ToString().substr(0,20).c_str());\n+        return false;\n+    }\n+    if (mapOrphanBlocks.count(hash)) {\n+        printf(\"ProcessBlock() : already have block (orphan) %s\\n\", hash.ToString().substr(0,20).c_str());\n+        return false;\n+    }\n \n     // Preliminary checks\n     if (!pblock->CheckBlock())\n@@ -1808,15 +1905,20 @@ bool ProcessBlock(CNode* pfrom, CBlock* pblock)\n         mapOrphanBlocksByPrev.insert(make_pair(pblock2->hashPrevBlock, pblock2));\n \n         // Ask this guy to fill in what we're missing\n-        if (pfrom)\n+        if (pfrom) {\n+            printf(\"getblocks to %s\\n\", pfrom->addr.ToString().c_str());\n             pfrom->PushGetBlocks(pindexBest, GetOrphanRoot(pblock2));\n+        }\n         return true;\n     }\n \n     // Store to disk\n     if (!pblock->AcceptBlock())\n         return error(\"ProcessBlock() : AcceptBlock FAILED\");\n \n+    printf(\"Block ACCEPTED %15\"PRI64d\"ms\\n\", GetTimeMillis() - nStart);\n+    nStart = GetTimeMillis();\n+\n     // Recursively process any orphan blocks that depended on this one\n     vector<uint256> vWorkQueue;\n     vWorkQueue.push_back(hash);\n@@ -1828,15 +1930,20 @@ bool ProcessBlock(CNode* pfrom, CBlock* pblock)\n              ++mi)\n         {\n             CBlock* pblockOrphan = (*mi).second;\n-            if (pblockOrphan->AcceptBlock())\n-                vWorkQueue.push_back(pblockOrphan->GetHash());\n-            mapOrphanBlocks.erase(pblockOrphan->GetHash());\n+            uint256 orphanhash = pblockOrphan->GetHash();\n+            if (pblockOrphan->AcceptBlock()) {\n+                vWorkQueue.push_back(orphanhash);\n+                printf(\"Orphan block ACCEPTED %15\"PRI64d\"ms\\n\", GetTimeMillis() - nStart);\n+            } else\n+                printf(\"Orphan block %s REJECTED %15\"PRI64d\"ms\\n\", orphanhash.ToString().substr(0,20).c_str(), GetTimeMillis() - nStart);\n+            nStart = GetTimeMillis();\n+\n+            mapOrphanBlocks.erase(orphanhash);\n             delete pblockOrphan;\n         }\n         mapOrphanBlocksByPrev.erase(hashPrev);\n     }\n \n-    printf(\"ProcessBlock: ACCEPTED\\n\");\n     return true;\n }\n \n@@ -2218,7 +2325,7 @@ bool CAlert::ProcessAlert()\n         mapAlerts.insert(make_pair(GetHash(), *this));\n     }\n \n-    printf(\"accepted alert %d, AppliesToMe()=%d\\n\", nID, AppliesToMe());\n+    if (fDebug) printf(\"accepted alert %d, AppliesToMe()=%d\\n\", nID, AppliesToMe());\n     MainFrameRepaint();\n     return true;\n }\n@@ -2282,9 +2389,6 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n     }\n \n \n-\n-\n-\n     if (strCommand == \"version\")\n     {\n         // Each connection can only send one version message\n@@ -2388,7 +2492,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n \n         pfrom->fSuccessfullyConnected = true;\n \n-        printf(\"version message: version %d, blocks=%d\\n\", pfrom->nVersion, pfrom->nStartingHeight);\n+        printf(\"version message: version %d, blocks=%d, peer=%s\\n\", pfrom->nVersion, pfrom->nStartingHeight, pfrom->addr.ToString().c_str());\n \n         cPeerBlockCounts.input(pfrom->nStartingHeight);\n     }\n@@ -2484,6 +2588,13 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n             pfrom->Misbehaving(20);\n             return error(\"message inv size() = %d\", vInv.size());\n         }\n+        int invtxs = 0;\n+        int invblocks = 0;\n+        int askblocks = 0;\n+        int orphanget = 0;\n+        int lastblockget = 0;\n+        int64 nRequestTime = 0;\n+        CInv inv;\n \n         // find last block in inv vector\n         unsigned int nLastBlock = (unsigned int)(-1);\n@@ -2496,34 +2607,71 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n         CTxDB txdb(\"r\");\n         for (unsigned int nInv = 0; nInv < vInv.size(); nInv++)\n         {\n-            const CInv &inv = vInv[nInv];\n+            inv = vInv[nInv]; // was \"const CInv &inv =\"\n \n             if (fShutdown)\n                 return true;\n+\n+            if (inv.type == MSG_BLOCK) invblocks++;\n+            if (inv.type == MSG_TX) invtxs++;\n+\n             pfrom->AddInventoryKnown(inv);\n \n             bool fAlreadyHave = AlreadyHave(txdb, inv);\n             if (fDebug)\n                 printf(\"  got inventory: %s  %s\\n\", inv.ToString().c_str(), fAlreadyHave ? \"have\" : \"new\");\n \n-            if (!fAlreadyHave)\n-                pfrom->AskFor(inv);\n-            else if (inv.type == MSG_BLOCK && mapOrphanBlocks.count(inv.hash)) {\n+            if (!fAlreadyHave) {\n+                nRequestTime = pfrom->AskFor(inv);\n+                if (CaughtUp() || !fQuietInitial) {\n+                    if (fLogPeers || inv.type == MSG_BLOCK)\n+                        printf(\"askfor %s at %s at %s\\n\", inv.ToString().c_str(),\n+                          DateTimeStrFormat(\"%H:%M:%S\", nRequestTime/1000000).c_str(),\n+                          pfrom->addr.ToString().c_str());\n+                    else\n+                        printf(\"askfor %s at %s\\n\", inv.ToString().c_str(),\n+                          DateTimeStrFormat(\"%H:%M:%S\", nRequestTime/1000000).c_str());\n+                }\n+                if (inv.type == MSG_BLOCK) askblocks++;\n+            } else if (inv.type == MSG_BLOCK && mapOrphanBlocks.count(inv.hash)) {\n                 pfrom->PushGetBlocks(pindexBest, GetOrphanRoot(mapOrphanBlocks[inv.hash]));\n+                orphanget++;\n+                if (CaughtUp() || !fQuietInitial)\n+                    printf(\"orphan getblocks %s to %s\\n\", inv.ToString().c_str(), pfrom->addr.ToString().c_str());\n             } else if (nInv == nLastBlock) {\n                 // In case we are on a very long side-chain, it is possible that we already have\n                 // the last block in an inv bundle sent in response to getblocks. Try to detect\n                 // this situation and push another getblocks to continue.\n                 std::vector<CInv> vGetData(1,inv);\n                 pfrom->PushGetBlocks(mapBlockIndex[inv.hash], uint256(0));\n+                lastblockget++;\n                 if (fDebug)\n                     printf(\"force request: %s\\n\", inv.ToString().c_str());\n             }\n \n             // Track requests for our stuff\n             Inventory(inv.hash);\n-        }\n-    }\n+        } // for each item in inv bundle\n+\n+        if (!CaughtUp() && fQuietInitial) {\n+            if (invblocks) {\n+                if (vInv.size() == 1) {\n+                    if (askblocks)\n+                        printf(\"askfor %s at %s\", inv.ToString().c_str(), DateTimeStrFormat(\"%H:%M:%S\", nRequestTime/10000000).c_str());\n+                    else\n+                        printf(\"inv %s\", inv.ToString().c_str());\n+                } else {\n+                    printf(\"inv containing %d (askfor %d) blocks\", invblocks, askblocks);\n+                    if (invtxs) printf(\" and %d txs\", invtxs);\n+                }\n+                printf(\" at %s\\n\", pfrom->addr.ToString().c_str());\n+            } // inv cointained blocks\n+        } // !CaughtUp()\n+        if (orphanget)\n+            printf(\"orphan getblocks (%d) to %s\\n\", orphanget, pfrom->addr.ToString().c_str());\n+        if (lastblockget)\n+            printf(\"lastblock getblocks to %s\\n\", pfrom->addr.ToString().c_str());\n+    } // strCommand == \"inv\"\n \n \n     else if (strCommand == \"getdata\")\n@@ -2535,16 +2683,25 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n             pfrom->Misbehaving(20);\n             return error(\"message getdata size() = %d\", vInv.size());\n         }\n+        int nBlocks = 0;\n+        int nTxs = 0;\n \n         BOOST_FOREACH(const CInv& inv, vInv)\n         {\n             if (fShutdown)\n                 return true;\n-            printf(\"received getdata for: %s\\n\", inv.ToString().c_str());\n+\n+            if (vInv.size() < 5) {\n+                if (inv.type == MSG_BLOCK || fLogPeers)\n+                    printf(\"got getdata %s from %s\\n\", inv.ToString().c_str(), pfrom->addr.ToString().c_str());\n+                else\n+                    printf(\"got getdata %s\\n\", inv.ToString().c_str());\n+            }\n \n             if (inv.type == MSG_BLOCK)\n             {\n                 // Send block from disk\n+                nBlocks++;\n                 map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(inv.hash);\n                 if (mi != mapBlockIndex.end())\n                 {\n@@ -2564,10 +2721,11 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n                         pfrom->hashContinue = 0;\n                     }\n                 }\n-            }\n+            } // if a block\n             else if (inv.IsKnownType())\n             {\n                 // Send stream from relay memory\n+                nTxs++;\n                 {\n                     LOCK(cs_mapRelay);\n                     map<CInv, CDataStream>::iterator mi = mapRelay.find(inv);\n@@ -2578,12 +2736,25 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n \n             // Track requests for our stuff\n             Inventory(inv.hash);\n+        } // for each getdata request\n+\n+        if (vInv.size() > 4) {\n+            printf(\"got getdata for \");\n+            if (nBlocks) {\n+                printf(\"%d blocks \", nBlocks);\n+                if (nTxs) printf(\"and \");\n+            }\n+            if (nTxs) printf(\"%d txs \", nTxs);\n+            printf(\"from %s. Sending.\\n\", pfrom->addr.ToString().c_str());\n         }\n-    }\n+\n+    } // strCommand = \"getdata\"\n \n \n     else if (strCommand == \"getblocks\")\n     {\n+        // This is a request from a node to tell them about the blocks I have.\n+\n         CBlockLocator locator;\n         uint256 hashStop;\n         vRecv >> locator >> hashStop;\n@@ -2596,12 +2767,12 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n             pindex = pindex->pnext;\n         int nLimit = 500 + locator.GetDistanceBack();\n         unsigned int nBytes = 0;\n-        printf(\"getblocks %d to %s limit %d\\n\", (pindex ? pindex->nHeight : -1), hashStop.ToString().substr(0,20).c_str(), nLimit);\n+        printf(\"getblocks %d to %s limit %d from %s\\n\", (pindex ? pindex->nHeight : -1), hashStop.ToString().substr(0,20).c_str(), nLimit, pfrom->addr.ToString().c_str());\n         for (; pindex; pindex = pindex->pnext)\n         {\n             if (pindex->GetBlockHash() == hashStop)\n             {\n-                printf(\"  getblocks stopping at %d %s (%u bytes)\\n\", pindex->nHeight, pindex->GetBlockHash().ToString().substr(0,20).c_str(), nBytes);\n+                if (fDebug) printf(\"  getblocks stopping at %d %s (%u bytes)\\n\", pindex->nHeight, pindex->GetBlockHash().ToString().substr(0,20).c_str(), nBytes);\n                 break;\n             }\n             pfrom->PushInventory(CInv(MSG_BLOCK, pindex->GetBlockHash()));\n@@ -2668,11 +2839,17 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n         pfrom->AddInventoryKnown(inv);\n \n         bool fMissingInputs = false;\n+        txnode = pfrom; \n         if (tx.AcceptToMemoryPool(txdb, true, &fMissingInputs))\n         {\n+            txnode = NULL;\n+            if (fLogPeers)\n+                printf(\"from %s\\n\", pfrom->addr.ToString().c_str());\n+            else\n+                printf(\"\\n\");\n             SyncWithWallets(tx, NULL, true);\n             RelayMessage(inv, vMsg);\n-            mapAlreadyAskedFor.erase(inv);\n+            mapWaitingFor.erase(inv);\n             vWorkQueue.push_back(inv.hash);\n \n             // Recursively process any orphan transactions that depended on this one\n@@ -2690,21 +2867,22 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n \n                     if (tx.AcceptToMemoryPool(txdb, true))\n                     {\n-                        printf(\"   accepted orphan tx %s\\n\", inv.hash.ToString().substr(0,10).c_str());\n+                        printf(\"(orphan)\\n\");\n                         SyncWithWallets(tx, NULL, true);\n                         RelayMessage(inv, vMsg);\n-                        mapAlreadyAskedFor.erase(inv);\n+                        mapWaitingFor.erase(inv);\n                         vWorkQueue.push_back(inv.hash);\n                     }\n                 }\n             }\n \n             BOOST_FOREACH(uint256 hash, vWorkQueue)\n                 EraseOrphanTx(hash);\n-        }\n+        } // if tx.AcceptToMemoryPool()\n         else if (fMissingInputs)\n         {\n-            printf(\"storing orphan tx %s\\n\", inv.hash.ToString().substr(0,10).c_str());\n+            if (CaughtUp() || !fQuietInitial)\n+                printf(\"storing orphan tx %s\\n\", inv.hash.ToString().substr(0,10).c_str());\n             AddOrphanTx(vMsg);\n \n             // DoS prevention: do not allow mapOrphanTransactions to grow unbounded\n@@ -2719,16 +2897,15 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n     else if (strCommand == \"block\")\n     {\n         CBlock block;\n+        int size = vRecv.size();\n         vRecv >> block;\n \n-        printf(\"received block %s\\n\", block.GetHash().ToString().substr(0,20).c_str());\n-        // block.print();\n-\n         CInv inv(MSG_BLOCK, block.GetHash());\n+        printf(\"received block %s (size %u) from %s\\n\", inv.hash.ToString().substr(0,20).c_str(), size, pfrom->addr.ToString().c_str());\n         pfrom->AddInventoryKnown(inv);\n \n         if (ProcessBlock(pfrom, &block))\n-            mapAlreadyAskedFor.erase(inv);\n+            mapWaitingFor.erase(inv);\n         if (block.nDoS) pfrom->Misbehaving(block.nDoS);\n     }\n \n@@ -2791,6 +2968,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n \n     else if (strCommand == \"ping\")\n     {\n+        printf(\"PING from %s\\n\", pfrom->addr.ToString().c_str());\n         if (pfrom->nVersion > BIP0031_VERSION)\n         {\n             uint64 nonce = 0;\n@@ -2831,6 +3009,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n \n     else\n     {\n+        printf(\"UNKNOWN command (\\\"%s\\\") from %s\\n\", strCommand.c_str(), pfrom->addr.ToString().c_str());\n         // Ignore unknown commands for extensibility\n     }\n \n@@ -2840,7 +3019,6 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n         if (strCommand == \"version\" || strCommand == \"addr\" || strCommand == \"inv\" || strCommand == \"getdata\" || strCommand == \"ping\")\n             AddressCurrentlyConnected(pfrom->addr);\n \n-\n     return true;\n }\n \n@@ -2894,11 +3072,12 @@ bool ProcessMessages(CNode* pfrom)\n         unsigned int nMessageSize = hdr.nMessageSize;\n         if (nMessageSize > MAX_SIZE)\n         {\n-            printf(\"ProcessMessage(%s, %u bytes) : nMessageSize > MAX_SIZE\\n\", strCommand.c_str(), nMessageSize);\n+            printf(\"ProcessMessages(%s, %u bytes) from %s: nMessageSize > MAX_SIZE\\n\", strCommand.c_str(), nMessageSize, pfrom->addr.ToString().c_str());\n             continue;\n         }\n-        if (nMessageSize > vRecv.size())\n+        if (vRecv.size() < nMessageSize)\n         {\n+            printf(\"receiving block (size %u) from %s\\n\", nMessageSize, pfrom->addr.ToString().c_str());\n             // Rewind and wait for rest of message\n             vRecv.insert(vRecv.begin(), vHeaderSave.begin(), vHeaderSave.end());\n             break;\n@@ -2910,7 +3089,7 @@ bool ProcessMessages(CNode* pfrom)\n         memcpy(&nChecksum, &hash, sizeof(nChecksum));\n         if (nChecksum != hdr.nChecksum)\n         {\n-            printf(\"ProcessMessage(%s, %u bytes) : CHECKSUM ERROR nChecksum=%08x hdr.nChecksum=%08x\\n\",\n+            printf(\"ProcessMessages(%s, %u bytes) : CHECKSUM ERROR nChecksum=%08x hdr.nChecksum=%08x\\n\",\n                strCommand.c_str(), nMessageSize, nChecksum, hdr.nChecksum);\n             continue;\n         }\n@@ -2935,12 +3114,12 @@ bool ProcessMessages(CNode* pfrom)\n             if (strstr(e.what(), \"end of data\"))\n             {\n                 // Allow exceptions from underlength message on vRecv\n-                printf(\"ProcessMessage(%s, %u bytes) : Exception '%s' caught, normally caused by a message being shorter than its stated length\\n\", strCommand.c_str(), nMessageSize, e.what());\n+                printf(\"ProcessMessages(%s, %u bytes) : Exception '%s' caught, normally caused by a message being shorter than its stated length\\n\", strCommand.c_str(), nMessageSize, e.what());\n             }\n             else if (strstr(e.what(), \"size too large\"))\n             {\n                 // Allow exceptions from overlong size\n-                printf(\"ProcessMessage(%s, %u bytes) : Exception '%s' caught\\n\", strCommand.c_str(), nMessageSize, e.what());\n+                printf(\"ProcessMessages(%s, %u bytes) : Exception '%s' caught\\n\", strCommand.c_str(), nMessageSize, e.what());\n             }\n             else\n             {\n@@ -3090,33 +3269,54 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n         if (!vInv.empty())\n             pto->PushMessage(\"inv\", vInv);\n \n+        if (pto->fDisconnect)\n+            return true;\n \n         //\n         // Message: getdata\n         //\n         vector<CInv> vGetData;\n         int64 nNow = GetTime() * 1000000;\n         CTxDB txdb(\"r\");\n+        int gettxs = 0;\n+        int getblocks = 0;\n+\n         while (!pto->mapAskFor.empty() && (*pto->mapAskFor.begin()).first <= nNow)\n         {\n             const CInv& inv = (*pto->mapAskFor.begin()).second;\n             if (!AlreadyHave(txdb, inv))\n             {\n-                printf(\"sending getdata: %s\\n\", inv.ToString().c_str());\n+                if (CaughtUp() || !fQuietInitial) {\n+                    if (inv.type == MSG_BLOCK || fLogPeers)\n+                        printf(\"getdata %s to %s\\n\", inv.ToString().c_str(), pto->addr.ToString().c_str());\n+                    else\n+                        printf(\"getdata %s\\n\", inv.ToString().c_str());\n+                }\n+\n+                if (inv.type == MSG_BLOCK) {\n+                    getblocks++; \n+                }\n+                if (inv.type == MSG_TX) gettxs++;\n                 vGetData.push_back(inv);\n                 if (vGetData.size() >= 1000)\n                 {\n                     pto->PushMessage(\"getdata\", vGetData);\n                     vGetData.clear();\n                 }\n+                mapWaitingFor[inv] = nNow;\n             }\n-            mapAlreadyAskedFor[inv] = nNow;\n             pto->mapAskFor.erase(pto->mapAskFor.begin());\n         }\n         if (!vGetData.empty())\n             pto->PushMessage(\"getdata\", vGetData);\n \n-    }\n+        if (getblocks && !CaughtUp() && fQuietInitial) {\n+            printf(\"getdata %d blocks\", getblocks);\n+            if (gettxs) printf(\" and %d txs\", gettxs);\n+            printf(\" to %s\\n\", pto->addr.ToString().c_str());\n+        }\n+\n+    } // if LockMain\n     return true;\n }\n "
      },
      {
        "sha": "514f45e0ae9fa88adb1452369bd23c182f218733",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 33,
        "deletions": 24,
        "changes": 57,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6dbd0199d26cb4dcb6393dea6e9c78d461d7fe40/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6dbd0199d26cb4dcb6393dea6e9c78d461d7fe40/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=6dbd0199d26cb4dcb6393dea6e9c78d461d7fe40",
        "patch": "@@ -64,7 +64,7 @@ CCriticalSection cs_vNodes;\n map<CInv, CDataStream> mapRelay;\n deque<pair<int64, CInv> > vRelayExpiration;\n CCriticalSection cs_mapRelay;\n-map<CInv, int64> mapAlreadyAskedFor;\n+map<CInv, int64> mapWaitingFor;\n \n static deque<string> vOneShots;\n CCriticalSection cs_vOneShots;\n@@ -172,7 +172,7 @@ bool RecvLine(SOCKET hSocket, string& strLine)\n             if (nBytes == 0)\n             {\n                 // socket closed\n-                printf(\"socket closed\\n\");\n+                if (fDebug) printf(\"socket closed\\n\");\n                 return false;\n             }\n             else\n@@ -475,11 +475,10 @@ CNode* ConnectNode(CAddress addrConnect, const char *pszDest, int64 nTimeout)\n         }\n     }\n \n-\n     /// debug print\n     printf(\"trying connection %s lastseen=%.1fhrs\\n\",\n         pszDest ? pszDest : addrConnect.ToString().c_str(),\n-        pszDest ? 0 : (double)(addrConnect.nTime - GetAdjustedTime())/3600.0);\n+        pszDest ? 0 : (double)(GetAdjustedTime() - addrConnect.nTime)/3600.0);\n \n     // Connect\n     SOCKET hSocket;\n@@ -488,7 +487,7 @@ CNode* ConnectNode(CAddress addrConnect, const char *pszDest, int64 nTimeout)\n         addrman.Attempt(addrConnect);\n \n         /// debug print\n-        printf(\"connected %s\\n\", pszDest ? pszDest : addrConnect.ToString().c_str());\n+        if (fDebug) printf(\"connected %s\\n\", pszDest ? pszDest : addrConnect.ToString().c_str());\n \n         // Set to nonblocking\n #ifdef WIN32\n@@ -579,13 +578,16 @@ bool CNode::IsBanned(CNetAddr ip)\n \n bool CNode::Misbehaving(int howmuch)\n {\n+    nMisbehavior += howmuch;\n     if (addr.IsLocal())\n     {\n-        printf(\"Warning: local node %s misbehaving\\n\", addrName.c_str());\n+        printf(\"Warning: local node %s misbehaving (tot: %d)\\n\", addrName.c_str(), nMisbehavior);\n         return false;\n     }\n-\n-    nMisbehavior += howmuch;\n+    if (nMisbehavior < 0)\n+        nMisbehavior = 0;\n+    else\n+        printf(\"Misbehaving: %s (%d -> %d)\\n\", addr.ToString().c_str(), nMisbehavior-howmuch, nMisbehavior);\n     if (nMisbehavior >= GetArg(\"-banscore\", 100))\n     {\n         int64 banTime = GetTime()+GetArg(\"-bantime\", 60*60*24);  // Default 24-hour ban\n@@ -595,7 +597,7 @@ bool CNode::Misbehaving(int howmuch)\n                 setBanned[addr] = banTime;\n         }\n         CloseSocketDisconnect();\n-        printf(\"Disconnected %s for misbehavior (score=%d)\\n\", addrName.c_str(), nMisbehavior);\n+        //printf(\"Disconnected %s for misbehavior (score=%d)\\n\", addrName.c_str(), nMisbehavior);\n         return true;\n     }\n     return false;\n@@ -628,7 +630,7 @@ void ThreadSocketHandler(void* parg)\n         vnThreadsRunning[THREAD_SOCKETHANDLER]--;\n         throw; // support pthread_cancel()\n     }\n-    printf(\"ThreadSocketHandler exiting\\n\");\n+    printf(\"ThreadSocketHandler exited\\n\");\n }\n \n void ThreadSocketHandler2(void* parg)\n@@ -658,6 +660,8 @@ void ThreadSocketHandler2(void* parg)\n                     pnode->grantOutbound.Release();\n \n                     // close socket and cleanup\n+                    if (!pnode->fDisconnect) \n+                        printf(\"Closing unused node.\\n\");\n                     pnode->CloseSocketDisconnect();\n                     pnode->Cleanup();\n \n@@ -870,7 +874,9 @@ void ThreadSocketHandler2(void* parg)\n                         {\n                             // socket closed gracefully\n                             if (!pnode->fDisconnect)\n-                                printf(\"socket closed\\n\");\n+                                printf(\"socket closed gracefully\\n\");\n+                            else\n+                                printf(\"nBytes = 0, fDisconnect = true\\n\");\n                             pnode->CloseSocketDisconnect();\n                         }\n                         else if (nBytes < 0)\n@@ -880,7 +886,9 @@ void ThreadSocketHandler2(void* parg)\n                             if (nErr != WSAEWOULDBLOCK && nErr != WSAEMSGSIZE && nErr != WSAEINTR && nErr != WSAEINPROGRESS)\n                             {\n                                 if (!pnode->fDisconnect)\n-                                    printf(\"socket recv error %d\\n\", nErr);\n+                                    printf(\"socket recv error %d from %s\\n\", nErr, pnode->addr.ToString().c_str());\n+                                else\n+                                    printf(\"recv error %d and fDisconnect from %s\\n\", nErr, pnode->addr.ToString().c_str());\n                                 pnode->CloseSocketDisconnect();\n                             }\n                         }\n@@ -935,21 +943,21 @@ void ThreadSocketHandler2(void* parg)\n             {\n                 if (pnode->nLastRecv == 0 || pnode->nLastSend == 0)\n                 {\n-                    printf(\"socket no message in first 60 seconds, %d %d\\n\", pnode->nLastRecv != 0, pnode->nLastSend != 0);\n+                    printf(\"%s no message in first minute, %d %d\\n\", pnode->addr.ToString().c_str(), pnode->nLastRecv != 0, pnode->nLastSend != 0);\n                     pnode->fDisconnect = true;\n                 }\n                 else if (GetTime() - pnode->nLastSend > 90*60 && GetTime() - pnode->nLastSendEmpty > 90*60)\n                 {\n-                    printf(\"socket not sending\\n\");\n+                    printf(\"%s socket not sending since 90 minutes\\n\", pnode->addr.ToString().c_str());\n                     pnode->fDisconnect = true;\n                 }\n                 else if (GetTime() - pnode->nLastRecv > 90*60)\n                 {\n-                    printf(\"socket inactivity timeout\\n\");\n+                    printf(\"%s not receiving since 90 minutes\\n\", pnode->addr.ToString().c_str());\n                     pnode->fDisconnect = true;\n                 }\n-            }\n-        }\n+            } // connected > 1 minute\n+        } // end of for each node\n         {\n             LOCK(cs_vNodes);\n             BOOST_FOREACH(CNode* pnode, vNodesCopy)\n@@ -985,7 +993,7 @@ void ThreadMapPort(void* parg)\n         vnThreadsRunning[THREAD_UPNP]--;\n         PrintException(NULL, \"ThreadMapPort()\");\n     }\n-    printf(\"ThreadMapPort exiting\\n\");\n+    printf(\"ThreadMapPort exited\\n\");\n }\n \n void ThreadMapPort2(void* parg)\n@@ -1147,7 +1155,7 @@ void ThreadDNSAddressSeed(void* parg)\n         vnThreadsRunning[THREAD_DNSSEED]--;\n         throw; // support pthread_cancel()\n     }\n-    printf(\"ThreadDNSAddressSeed exiting\\n\");\n+    printf(\"ThreadDNSAddressSeed exited\\n\");\n }\n \n void ThreadDNSAddressSeed2(void* parg)\n@@ -1310,7 +1318,7 @@ void ThreadDumpAddress(void* parg)\n     catch (std::exception& e) {\n         PrintException(&e, \"ThreadDumpAddress()\");\n     }\n-    printf(\"ThreadDumpAddress exiting\\n\");\n+    printf(\"ThreadDumpAddress exited\\n\");\n }\n \n void ThreadOpenConnections(void* parg)\n@@ -1329,7 +1337,7 @@ void ThreadOpenConnections(void* parg)\n         vnThreadsRunning[THREAD_OPENCONNECTIONS]--;\n         PrintException(NULL, \"ThreadOpenConnections()\");\n     }\n-    printf(\"ThreadOpenConnections exiting\\n\");\n+    printf(\"ThreadOpenConnections exited\\n\");\n }\n \n void static ProcessOneShot()\n@@ -1482,7 +1490,7 @@ void ThreadOpenAddedConnections(void* parg)\n         vnThreadsRunning[THREAD_ADDEDCONNECTIONS]--;\n         PrintException(NULL, \"ThreadOpenAddedConnections()\");\n     }\n-    printf(\"ThreadOpenAddedConnections exiting\\n\");\n+    printf(\"ThreadOpenAddedConnections exited\\n\");\n }\n \n void ThreadOpenAddedConnections2(void* parg)\n@@ -1611,7 +1619,7 @@ void ThreadMessageHandler(void* parg)\n         vnThreadsRunning[THREAD_MESSAGEHANDLER]--;\n         PrintException(NULL, \"ThreadMessageHandler()\");\n     }\n-    printf(\"ThreadMessageHandler exiting\\n\");\n+    printf(\"ThreadMessageHandler exited\\n\");\n }\n \n void ThreadMessageHandler2(void* parg)\n@@ -1727,7 +1735,6 @@ bool BindListenPort(const CService &addrBind, string& strError)\n     setsockopt(hListenSocket, SOL_SOCKET, SO_REUSEADDR, (void*)&nOne, sizeof(int));\n #endif\n \n-\n #ifdef WIN32\n     // Set to nonblocking, incoming connections will also inherit this\n     if (ioctlsocket(hListenSocket, FIONBIO, (u_long*)&nOne) == SOCKET_ERROR)\n@@ -1902,6 +1909,8 @@ void StartNode(void* parg)\n \n     // Generate coins in the background\n     GenerateBitcoins(GetBoolArg(\"-gen\", false), pwalletMain);\n+\n+    printf(\"StartNode() exited\\n\");\n }\n \n bool StopNode()"
      },
      {
        "sha": "12d708e047f63ab78d4e9fb060a41a81e30f0b7e",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 7,
        "deletions": 4,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6dbd0199d26cb4dcb6393dea6e9c78d461d7fe40/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6dbd0199d26cb4dcb6393dea6e9c78d461d7fe40/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=6dbd0199d26cb4dcb6393dea6e9c78d461d7fe40",
        "patch": "@@ -120,7 +120,7 @@ extern CCriticalSection cs_vNodes;\n extern std::map<CInv, CDataStream> mapRelay;\n extern std::deque<std::pair<int64, CInv> > vRelayExpiration;\n extern CCriticalSection cs_mapRelay;\n-extern std::map<CInv, int64> mapAlreadyAskedFor;\n+extern std::map<CInv, int64> mapWaitingFor;\n \n \n \n@@ -289,12 +289,11 @@ class CNode\n         }\n     }\n \n-    void AskFor(const CInv& inv)\n+    int64 AskFor(const CInv& inv)\n     {\n         // We're using mapAskFor as a priority queue,\n         // the key is the earliest time the request can be sent\n-        int64& nRequestTime = mapAlreadyAskedFor[inv];\n-        printf(\"askfor %s   %\"PRI64d\"\\n\", inv.ToString().c_str(), nRequestTime);\n+        int64& nRequestTime = mapWaitingFor[inv];\n \n         // Make sure not to reuse time indexes to keep things in the same order\n         int64 nNow = (GetTime() - 1) * 1000000;\n@@ -306,6 +305,10 @@ class CNode\n         // Each retry is 2 minutes after the last\n         nRequestTime = std::max(nRequestTime + 2 * 60 * 1000000, nNow);\n         mapAskFor.insert(std::make_pair(nRequestTime, inv));\n+        if (CaughtUp() || !fQuietInitial)\n+            printf(\"askfor %s at %s \", inv.ToString().c_str(), DateTimeStrFormat(\"%H:%M:%S\", nRequestTime/1000000).c_str());\n+\n+        return nRequestTime;\n     }\n \n "
      },
      {
        "sha": "8622e3c14fa9009d5d51017a7a0f29e9b188ad7c",
        "filename": "src/netbase.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6dbd0199d26cb4dcb6393dea6e9c78d461d7fe40/src/netbase.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6dbd0199d26cb4dcb6393dea6e9c78d461d7fe40/src/netbase.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.cpp?ref=6dbd0199d26cb4dcb6393dea6e9c78d461d7fe40",
        "patch": "@@ -372,7 +372,7 @@ bool static ConnectSocketDirectly(const CService &addrConnect, SOCKET& hSocketRe\n             int nRet = select(hSocket + 1, NULL, &fdset, NULL, &timeout);\n             if (nRet == 0)\n             {\n-                printf(\"connection timeout\\n\");\n+                if (fDebug) printf(\"connection timeout\\n\");\n                 closesocket(hSocket);\n                 return false;\n             }\n@@ -395,7 +395,7 @@ bool static ConnectSocketDirectly(const CService &addrConnect, SOCKET& hSocketRe\n             }\n             if (nRet != 0)\n             {\n-                printf(\"connect() failed after select(): %s\\n\",strerror(nRet));\n+                if (fDebug) printf(\"connect() failed after select(): %s\\n\",strerror(nRet));\n                 closesocket(hSocket);\n                 return false;\n             }\n@@ -406,7 +406,7 @@ bool static ConnectSocketDirectly(const CService &addrConnect, SOCKET& hSocketRe\n         else\n #endif\n         {\n-            printf(\"connect() failed: %i\\n\",WSAGetLastError());\n+            if (fDebug) printf(\"connect() failed: %i\\n\", WSAGetLastError());\n             closesocket(hSocket);\n             return false;\n         }"
      },
      {
        "sha": "28d33d110ddc6892e8c34f3947c4bbf0319a0ae3",
        "filename": "src/util.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6dbd0199d26cb4dcb6393dea6e9c78d461d7fe40/src/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6dbd0199d26cb4dcb6393dea6e9c78d461d7fe40/src/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.cpp?ref=6dbd0199d26cb4dcb6393dea6e9c78d461d7fe40",
        "patch": "@@ -67,6 +67,8 @@ string strMiscWarning;\n bool fTestNet = false;\n bool fNoListen = false;\n bool fLogTimestamps = false;\n+bool fQuietInitial = false;\n+bool fLogPeers = false;\n CMedianFilter<int64> vTimeOffsets(200,0);\n \n // Init openssl library multithreading support"
      },
      {
        "sha": "bba92d06ab0bdeca544b301999088e4f8adcc42a",
        "filename": "src/util.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6dbd0199d26cb4dcb6393dea6e9c78d461d7fe40/src/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6dbd0199d26cb4dcb6393dea6e9c78d461d7fe40/src/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.h?ref=6dbd0199d26cb4dcb6393dea6e9c78d461d7fe40",
        "patch": "@@ -121,6 +121,8 @@ extern std::string strMiscWarning;\n extern bool fTestNet;\n extern bool fNoListen;\n extern bool fLogTimestamps;\n+extern bool fQuietInitial;\n+extern bool fLogPeers;\n \n void RandAddSeed();\n void RandAddSeedPerfmon();\n@@ -173,6 +175,7 @@ int64 GetAdjustedTime();\n std::string FormatFullVersion();\n std::string FormatSubVersion(const std::string& name, int nClientVersion, const std::vector<std::string>& comments);\n void AddTimeData(const CNetAddr& ip, int64 nTime);\n+bool CaughtUp();\n \n \n "
      },
      {
        "sha": "281818ff707d9e806828b52b62ba8ebc09b18abb",
        "filename": "src/walletdb.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 1,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6dbd0199d26cb4dcb6393dea6e9c78d461d7fe40/src/walletdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6dbd0199d26cb4dcb6393dea6e9c78d461d7fe40/src/walletdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/walletdb.cpp?ref=6dbd0199d26cb4dcb6393dea6e9c78d461d7fe40",
        "patch": "@@ -367,7 +367,11 @@ void ThreadFlushWalletDB(void* parg)\n                     map<string, int>::iterator mi = mapFileUseCount.find(strFile);\n                     if (mi != mapFileUseCount.end())\n                     {\n-                        printf(\"Flushing wallet.dat\\n\");\n+                        if (CaughtUp() || !fQuietInitial) {\n+                            if (!fLogTimestamps) // we don't want the date twice.\n+                                printf(\"%s \", DateTimeStrFormat(\"%x %H:%M:%S\", GetTime()).c_str());\n+                            printf(\"Flushing wallet.dat\\n\");\n+                        }\n                         nLastFlushed = nWalletDBUpdated;\n                         int64 nStart = GetTimeMillis();\n "
      }
    ]
  }
]