[
  {
    "sha": "da0fecffa788a0a74121d554d3d76936ab96b39e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkYTBmZWNmZmE3ODhhMGE3NDEyMWQ1NTRkM2Q3NjkzNmFiOTZiMzll",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-01-11T22:33:34Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2014-01-11T22:39:29Z"
      },
      "message": "Store orphan blocks in serialized form",
      "tree": {
        "sha": "02b894836761d9103632c18ef0de8e96a7a10633",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/02b894836761d9103632c18ef0de8e96a7a10633"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/da0fecffa788a0a74121d554d3d76936ab96b39e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/da0fecffa788a0a74121d554d3d76936ab96b39e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/da0fecffa788a0a74121d554d3d76936ab96b39e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/da0fecffa788a0a74121d554d3d76936ab96b39e/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "dc64c3c3747f0d592ebad516dc08e752687e62eb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dc64c3c3747f0d592ebad516dc08e752687e62eb",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/dc64c3c3747f0d592ebad516dc08e752687e62eb"
      }
    ],
    "stats": {
      "total": 58,
      "additions": 41,
      "deletions": 17
    },
    "files": [
      {
        "sha": "9c6c1ba0c385c6fb0f6dce5672873c1238b7754f",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 41,
        "deletions": 17,
        "changes": 58,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/da0fecffa788a0a74121d554d3d76936ab96b39e/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/da0fecffa788a0a74121d554d3d76936ab96b39e/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=da0fecffa788a0a74121d554d3d76936ab96b39e",
        "patch": "@@ -56,8 +56,13 @@ int64_t CTransaction::nMinRelayTxFee = 10000;\n \n static CMedianFilter<int> cPeerBlockCounts(8, 0); // Amount of blocks that other nodes claim to have\n \n-map<uint256, CBlock*> mapOrphanBlocks;\n-multimap<uint256, CBlock*> mapOrphanBlocksByPrev;\n+struct COrphanBlock {\n+    uint256 hashBlock;\n+    uint256 hashPrev;\n+    vector<unsigned char> vchBlock;\n+};\n+map<uint256, COrphanBlock*> mapOrphanBlocks;\n+multimap<uint256, COrphanBlock*> mapOrphanBlocksByPrev;\n \n map<uint256, CTransaction> mapOrphanTransactions;\n map<uint256, set<uint256> > mapOrphanTransactionsByPrev;\n@@ -985,12 +990,19 @@ bool ReadBlockFromDisk(CBlock& block, const CBlockIndex* pindex)\n     return true;\n }\n \n-uint256 static GetOrphanRoot(const CBlockHeader* pblock)\n+uint256 static GetOrphanRoot(const uint256& hash)\n {\n+    map<uint256, COrphanBlock*>::iterator it = mapOrphanBlocks.find(hash);\n+    if (it == mapOrphanBlocks.end())\n+        return hash;\n+\n     // Work back to the first block in the orphan chain\n-    while (mapOrphanBlocks.count(pblock->hashPrevBlock))\n-        pblock = mapOrphanBlocks[pblock->hashPrevBlock];\n-    return pblock->GetHash();\n+    do {\n+        map<uint256, COrphanBlock*>::iterator it2 = mapOrphanBlocks.find(it->second->hashPrev);\n+        if (it2 == mapOrphanBlocks.end())\n+            return it->first;\n+        it = it2;\n+    } while(true);\n }\n \n int64_t GetBlockValue(int nHeight, int64_t nFees)\n@@ -2277,12 +2289,19 @@ bool ProcessBlock(CValidationState &state, CNode* pfrom, CBlock* pblock, CDiskBl\n \n         // Accept orphans as long as there is a node to request its parents from\n         if (pfrom) {\n-            CBlock* pblock2 = new CBlock(*pblock);\n+            COrphanBlock* pblock2 = new COrphanBlock();\n+            {\n+                CDataStream ss(SER_DISK, CLIENT_VERSION);\n+                ss << *pblock;\n+                pblock2->vchBlock = std::vector<unsigned char>(ss.begin(), ss.end());\n+            }\n+            pblock2->hashBlock = hash;\n+            pblock2->hashPrev = pblock->hashPrevBlock;\n             mapOrphanBlocks.insert(make_pair(hash, pblock2));\n-            mapOrphanBlocksByPrev.insert(make_pair(pblock2->hashPrevBlock, pblock2));\n+            mapOrphanBlocksByPrev.insert(make_pair(pblock2->hashPrev, pblock2));\n \n             // Ask this guy to fill in what we're missing\n-            PushGetBlocks(pfrom, chainActive.Tip(), GetOrphanRoot(pblock2));\n+            PushGetBlocks(pfrom, chainActive.Tip(), GetOrphanRoot(hash));\n         }\n         return true;\n     }\n@@ -2297,17 +2316,22 @@ bool ProcessBlock(CValidationState &state, CNode* pfrom, CBlock* pblock, CDiskBl\n     for (unsigned int i = 0; i < vWorkQueue.size(); i++)\n     {\n         uint256 hashPrev = vWorkQueue[i];\n-        for (multimap<uint256, CBlock*>::iterator mi = mapOrphanBlocksByPrev.lower_bound(hashPrev);\n+        for (multimap<uint256, COrphanBlock*>::iterator mi = mapOrphanBlocksByPrev.lower_bound(hashPrev);\n              mi != mapOrphanBlocksByPrev.upper_bound(hashPrev);\n              ++mi)\n         {\n-            CBlock* pblockOrphan = (*mi).second;\n+            CBlock block;\n+            {\n+                CDataStream ss(mi->second->vchBlock, SER_DISK, CLIENT_VERSION);\n+                ss >> block;\n+            }\n+            block.BuildMerkleTree();\n             // Use a dummy CValidationState so someone can't setup nodes to counter-DoS based on orphan resolution (that is, feeding people an invalid block based on LegitBlockX in order to get anyone relaying LegitBlockX banned)\n             CValidationState stateDummy;\n-            if (AcceptBlock(*pblockOrphan, stateDummy))\n-                vWorkQueue.push_back(pblockOrphan->GetHash());\n-            mapOrphanBlocks.erase(pblockOrphan->GetHash());\n-            delete pblockOrphan;\n+            if (AcceptBlock(block, stateDummy))\n+                vWorkQueue.push_back(mi->second->hashBlock);\n+            mapOrphanBlocks.erase(mi->second->hashBlock);\n+            delete mi->second;\n         }\n         mapOrphanBlocksByPrev.erase(hashPrev);\n     }\n@@ -3331,7 +3355,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n                 if (!fImporting && !fReindex)\n                     pfrom->AskFor(inv);\n             } else if (inv.type == MSG_BLOCK && mapOrphanBlocks.count(inv.hash)) {\n-                PushGetBlocks(pfrom, chainActive.Tip(), GetOrphanRoot(mapOrphanBlocks[inv.hash]));\n+                PushGetBlocks(pfrom, chainActive.Tip(), GetOrphanRoot(inv.hash));\n             } else if (nInv == nLastBlock) {\n                 // In case we are on a very long side-chain, it is possible that we already have\n                 // the last block in an inv bundle sent in response to getblocks. Try to detect\n@@ -4119,7 +4143,7 @@ class CMainCleanup\n         mapBlockIndex.clear();\n \n         // orphan blocks\n-        std::map<uint256, CBlock*>::iterator it2 = mapOrphanBlocks.begin();\n+        std::map<uint256, COrphanBlock*>::iterator it2 = mapOrphanBlocks.begin();\n         for (; it2 != mapOrphanBlocks.end(); it2++)\n             delete (*it2).second;\n         mapOrphanBlocks.clear();"
      }
    ]
  }
]