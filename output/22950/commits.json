[
  {
    "sha": "5faa7dd6d871eac1a0ec5c4a93f2ad7577781a56",
    "node_id": "C_kwDOABII59oAKDVmYWE3ZGQ2ZDg3MWVhYzFhMGVjNWM0YTkzZjJhZDc1Nzc3ODFhNTY",
    "commit": {
      "author": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2021-09-24T20:14:39Z"
      },
      "committer": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2021-09-28T18:46:02Z"
      },
      "message": "[move-only] Move CAddrMan function definitions to cpp\n\nIn preparation for introducing the pimpl pattern to addrman, move all function\nbodies out of the header file.\n\nReview hint: use git diff --color-moved=dimmed-zebra\n--color-moved-ws=ignore-all-space",
      "tree": {
        "sha": "deeec23512fef5de5ba1b6d3bb37978c0fcc0f32",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/deeec23512fef5de5ba1b6d3bb37978c0fcc0f32"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5faa7dd6d871eac1a0ec5c4a93f2ad7577781a56",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5faa7dd6d871eac1a0ec5c4a93f2ad7577781a56",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5faa7dd6d871eac1a0ec5c4a93f2ad7577781a56",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5faa7dd6d871eac1a0ec5c4a93f2ad7577781a56/comments",
    "author": {
      "login": "amitiuttarwar",
      "id": 1500952,
      "node_id": "MDQ6VXNlcjE1MDA5NTI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/amitiuttarwar",
      "html_url": "https://github.com/amitiuttarwar",
      "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
      "following_url": "https://api.github.com/users/amitiuttarwar/following{/other_user}",
      "gists_url": "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
      "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
      "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
      "events_url": "https://api.github.com/users/amitiuttarwar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "amitiuttarwar",
      "id": 1500952,
      "node_id": "MDQ6VXNlcjE1MDA5NTI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/amitiuttarwar",
      "html_url": "https://github.com/amitiuttarwar",
      "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
      "following_url": "https://api.github.com/users/amitiuttarwar/following{/other_user}",
      "gists_url": "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
      "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
      "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
      "events_url": "https://api.github.com/users/amitiuttarwar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "efa227f5df5f5a9669dec5f1d574cf22d3c0903f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/efa227f5df5f5a9669dec5f1d574cf22d3c0903f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/efa227f5df5f5a9669dec5f1d574cf22d3c0903f"
      }
    ],
    "stats": {
      "total": 198,
      "additions": 111,
      "deletions": 87
    },
    "files": [
      {
        "sha": "0fa8edd3164d93be24ea253bce0cbb08946d6a54",
        "filename": "src/addrman.cpp",
        "status": "modified",
        "additions": 99,
        "deletions": 0,
        "changes": 99,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5faa7dd6d871eac1a0ec5c4a93f2ad7577781a56/src/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5faa7dd6d871eac1a0ec5c4a93f2ad7577781a56/src/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.cpp?ref=5faa7dd6d871eac1a0ec5c4a93f2ad7577781a56",
        "patch": "@@ -119,6 +119,11 @@ CAddrMan::CAddrMan(std::vector<bool> asmap, bool deterministic, int32_t consiste\n     }\n }\n \n+CAddrMan::~CAddrMan()\n+{\n+    nKey.SetNull();\n+}\n+\n template <typename Stream>\n void CAddrMan::Serialize(Stream& s_) const\n {\n@@ -1017,3 +1022,97 @@ CAddrInfo CAddrMan::SelectTriedCollision_()\n \n     return mapInfo[id_old];\n }\n+\n+size_t CAddrMan::size() const\n+{\n+    LOCK(cs); // TODO: Cache this in an atomic to avoid this overhead\n+    return vRandom.size();\n+}\n+\n+bool CAddrMan::Add(const std::vector<CAddress> &vAddr, const CNetAddr& source, int64_t nTimePenalty)\n+{\n+    LOCK(cs);\n+    int nAdd = 0;\n+    Check();\n+    for (std::vector<CAddress>::const_iterator it = vAddr.begin(); it != vAddr.end(); it++)\n+        nAdd += Add_(*it, source, nTimePenalty) ? 1 : 0;\n+    Check();\n+    if (nAdd) {\n+        LogPrint(BCLog::ADDRMAN, \"Added %i addresses from %s: %i tried, %i new\\n\", nAdd, source.ToString(), nTried, nNew);\n+    }\n+    return nAdd > 0;\n+}\n+\n+void CAddrMan::Good(const CService &addr, int64_t nTime)\n+{\n+    LOCK(cs);\n+    Check();\n+    Good_(addr, /* test_before_evict */ true, nTime);\n+    Check();\n+}\n+\n+void CAddrMan::Attempt(const CService &addr, bool fCountFailure, int64_t nTime)\n+{\n+    LOCK(cs);\n+    Check();\n+    Attempt_(addr, fCountFailure, nTime);\n+    Check();\n+}\n+\n+\n+void CAddrMan::ResolveCollisions()\n+{\n+    LOCK(cs);\n+    Check();\n+    ResolveCollisions_();\n+    Check();\n+}\n+\n+CAddrInfo CAddrMan::SelectTriedCollision()\n+{\n+    LOCK(cs);\n+    Check();\n+    const CAddrInfo ret = SelectTriedCollision_();\n+    Check();\n+    return ret;\n+}\n+\n+CAddrInfo CAddrMan::Select(bool newOnly) const\n+{\n+    LOCK(cs);\n+    Check();\n+    const CAddrInfo addrRet = Select_(newOnly);\n+    Check();\n+    return addrRet;\n+}\n+\n+std::vector<CAddress> CAddrMan::GetAddr(size_t max_addresses, size_t max_pct, std::optional<Network> network) const\n+{\n+    LOCK(cs);\n+    Check();\n+    std::vector<CAddress> vAddr;\n+    GetAddr_(vAddr, max_addresses, max_pct, network);\n+    Check();\n+    return vAddr;\n+}\n+\n+void CAddrMan::Connected(const CService &addr, int64_t nTime)\n+{\n+    LOCK(cs);\n+    Check();\n+    Connected_(addr, nTime);\n+    Check();\n+}\n+\n+void CAddrMan::SetServices(const CService &addr, ServiceFlags nServices)\n+{\n+    LOCK(cs);\n+    Check();\n+    SetServices_(addr, nServices);\n+    Check();\n+}\n+\n+const std::vector<bool>& CAddrMan::GetAsmap() const\n+{\n+    return m_asmap;\n+}"
      },
      {
        "sha": "bc2f934caa4a3d573f475c3761929ec91600539e",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 12,
        "deletions": 87,
        "changes": 99,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5faa7dd6d871eac1a0ec5c4a93f2ad7577781a56/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5faa7dd6d871eac1a0ec5c4a93f2ad7577781a56/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=5faa7dd6d871eac1a0ec5c4a93f2ad7577781a56",
        "patch": "@@ -150,88 +150,33 @@ class CAddrMan\n \n     explicit CAddrMan(std::vector<bool> asmap, bool deterministic, int32_t consistency_check_ratio);\n \n-    ~CAddrMan()\n-    {\n-        nKey.SetNull();\n-    }\n+    ~CAddrMan();\n \n     //! Return the number of (unique) addresses in all tables.\n-    size_t size() const\n-        EXCLUSIVE_LOCKS_REQUIRED(!cs)\n-    {\n-        LOCK(cs); // TODO: Cache this in an atomic to avoid this overhead\n-        return vRandom.size();\n-    }\n+    size_t size() const EXCLUSIVE_LOCKS_REQUIRED(!cs);\n \n     //! Add addresses to addrman's new table.\n     bool Add(const std::vector<CAddress> &vAddr, const CNetAddr& source, int64_t nTimePenalty = 0)\n-        EXCLUSIVE_LOCKS_REQUIRED(!cs)\n-    {\n-        LOCK(cs);\n-        int nAdd = 0;\n-        Check();\n-        for (std::vector<CAddress>::const_iterator it = vAddr.begin(); it != vAddr.end(); it++)\n-            nAdd += Add_(*it, source, nTimePenalty) ? 1 : 0;\n-        Check();\n-        if (nAdd) {\n-            LogPrint(BCLog::ADDRMAN, \"Added %i addresses from %s: %i tried, %i new\\n\", nAdd, source.ToString(), nTried, nNew);\n-        }\n-        return nAdd > 0;\n-    }\n+        EXCLUSIVE_LOCKS_REQUIRED(!cs);\n \n     //! Mark an entry as accessible.\n     void Good(const CService &addr, int64_t nTime = GetAdjustedTime())\n-        EXCLUSIVE_LOCKS_REQUIRED(!cs)\n-    {\n-        LOCK(cs);\n-        Check();\n-        Good_(addr, /* test_before_evict */ true, nTime);\n-        Check();\n-    }\n+        EXCLUSIVE_LOCKS_REQUIRED(!cs);\n \n     //! Mark an entry as connection attempted to.\n     void Attempt(const CService &addr, bool fCountFailure, int64_t nTime = GetAdjustedTime())\n-        EXCLUSIVE_LOCKS_REQUIRED(!cs)\n-    {\n-        LOCK(cs);\n-        Check();\n-        Attempt_(addr, fCountFailure, nTime);\n-        Check();\n-    }\n+        EXCLUSIVE_LOCKS_REQUIRED(!cs);\n \n     //! See if any to-be-evicted tried table entries have been tested and if so resolve the collisions.\n-    void ResolveCollisions()\n-        EXCLUSIVE_LOCKS_REQUIRED(!cs)\n-    {\n-        LOCK(cs);\n-        Check();\n-        ResolveCollisions_();\n-        Check();\n-    }\n+    void ResolveCollisions() EXCLUSIVE_LOCKS_REQUIRED(!cs);\n \n     //! Randomly select an address in tried that another address is attempting to evict.\n-    CAddrInfo SelectTriedCollision()\n-        EXCLUSIVE_LOCKS_REQUIRED(!cs)\n-    {\n-        LOCK(cs);\n-        Check();\n-        const CAddrInfo ret = SelectTriedCollision_();\n-        Check();\n-        return ret;\n-    }\n+    CAddrInfo SelectTriedCollision() EXCLUSIVE_LOCKS_REQUIRED(!cs);\n \n     /**\n      * Choose an address to connect to.\n      */\n-    CAddrInfo Select(bool newOnly = false) const\n-        EXCLUSIVE_LOCKS_REQUIRED(!cs)\n-    {\n-        LOCK(cs);\n-        Check();\n-        const CAddrInfo addrRet = Select_(newOnly);\n-        Check();\n-        return addrRet;\n-    }\n+    CAddrInfo Select(bool newOnly = false) const EXCLUSIVE_LOCKS_REQUIRED(!cs);\n \n     /**\n      * Return all or many randomly selected addresses, optionally by network.\n@@ -241,36 +186,16 @@ class CAddrMan\n      * @param[in] network        Select only addresses of this network (nullopt = all).\n      */\n     std::vector<CAddress> GetAddr(size_t max_addresses, size_t max_pct, std::optional<Network> network) const\n-        EXCLUSIVE_LOCKS_REQUIRED(!cs)\n-    {\n-        LOCK(cs);\n-        Check();\n-        std::vector<CAddress> vAddr;\n-        GetAddr_(vAddr, max_addresses, max_pct, network);\n-        Check();\n-        return vAddr;\n-    }\n+        EXCLUSIVE_LOCKS_REQUIRED(!cs);\n \n     //! Outer function for Connected_()\n     void Connected(const CService &addr, int64_t nTime = GetAdjustedTime())\n-        EXCLUSIVE_LOCKS_REQUIRED(!cs)\n-    {\n-        LOCK(cs);\n-        Check();\n-        Connected_(addr, nTime);\n-        Check();\n-    }\n+        EXCLUSIVE_LOCKS_REQUIRED(!cs);\n \n     void SetServices(const CService &addr, ServiceFlags nServices)\n-        EXCLUSIVE_LOCKS_REQUIRED(!cs)\n-    {\n-        LOCK(cs);\n-        Check();\n-        SetServices_(addr, nServices);\n-        Check();\n-    }\n+        EXCLUSIVE_LOCKS_REQUIRED(!cs);\n \n-    const std::vector<bool>& GetAsmap() const { return m_asmap; }\n+    const std::vector<bool>& GetAsmap() const;\n \n private:\n     //! A mutex to protect the inner data structures."
      }
    ]
  },
  {
    "sha": "f2e5f38f09ee40933f752680fe7d75ee8e529fae",
    "node_id": "C_kwDOABII59oAKGYyZTVmMzhmMDllZTQwOTMzZjc1MjY4MGZlN2Q3NWVlOGU1MjlmYWU",
    "commit": {
      "author": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2021-09-28T19:46:43Z"
      },
      "committer": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2021-09-28T22:56:36Z"
      },
      "message": "[move-only] Match ordering of CAddrMan declarations and definitions\n\nAlso move `Check` and `ForceCheckAddrman` to be after the `FunctionName_` functions.\n\nReview hint: use git diff --color-moved=dimmed-zebra\n--color-moved-ws=ignore-all-space",
      "tree": {
        "sha": "a0bccf780a7da32ca8b97c435e44af8f67e0b669",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a0bccf780a7da32ca8b97c435e44af8f67e0b669"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f2e5f38f09ee40933f752680fe7d75ee8e529fae",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f2e5f38f09ee40933f752680fe7d75ee8e529fae",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f2e5f38f09ee40933f752680fe7d75ee8e529fae",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f2e5f38f09ee40933f752680fe7d75ee8e529fae/comments",
    "author": {
      "login": "amitiuttarwar",
      "id": 1500952,
      "node_id": "MDQ6VXNlcjE1MDA5NTI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/amitiuttarwar",
      "html_url": "https://github.com/amitiuttarwar",
      "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
      "following_url": "https://api.github.com/users/amitiuttarwar/following{/other_user}",
      "gists_url": "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
      "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
      "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
      "events_url": "https://api.github.com/users/amitiuttarwar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "amitiuttarwar",
      "id": 1500952,
      "node_id": "MDQ6VXNlcjE1MDA5NTI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/amitiuttarwar",
      "html_url": "https://github.com/amitiuttarwar",
      "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
      "following_url": "https://api.github.com/users/amitiuttarwar/following{/other_user}",
      "gists_url": "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
      "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
      "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
      "events_url": "https://api.github.com/users/amitiuttarwar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5faa7dd6d871eac1a0ec5c4a93f2ad7577781a56",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5faa7dd6d871eac1a0ec5c4a93f2ad7577781a56",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5faa7dd6d871eac1a0ec5c4a93f2ad7577781a56"
      }
    ],
    "stats": {
      "total": 245,
      "additions": 123,
      "deletions": 122
    },
    "files": [
      {
        "sha": "99c4f00d6d2322d2483b55c2181b1eb2b981cc6e",
        "filename": "src/addrman.cpp",
        "status": "modified",
        "additions": 103,
        "deletions": 102,
        "changes": 205,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f2e5f38f09ee40933f752680fe7d75ee8e529fae/src/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f2e5f38f09ee40933f752680fe7d75ee8e529fae/src/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.cpp?ref=f2e5f38f09ee40933f752680fe7d75ee8e529fae",
        "patch": "@@ -753,108 +753,6 @@ CAddrInfo CAddrMan::Select_(bool newOnly) const\n     }\n }\n \n-void CAddrMan::Check() const\n-{\n-    AssertLockHeld(cs);\n-\n-    // Run consistency checks 1 in m_consistency_check_ratio times if enabled\n-    if (m_consistency_check_ratio == 0) return;\n-    if (insecure_rand.randrange(m_consistency_check_ratio) >= 1) return;\n-\n-    const int err{ForceCheckAddrman()};\n-    if (err) {\n-        LogPrintf(\"ADDRMAN CONSISTENCY CHECK FAILED!!! err=%i\\n\", err);\n-        assert(false);\n-    }\n-}\n-\n-int CAddrMan::ForceCheckAddrman() const\n-{\n-    AssertLockHeld(cs);\n-\n-    LogPrint(BCLog::ADDRMAN, \"Addrman checks started: new %i, tried %i, total %u\\n\", nNew, nTried, vRandom.size());\n-\n-    std::unordered_set<int> setTried;\n-    std::unordered_map<int, int> mapNew;\n-\n-    if (vRandom.size() != (size_t)(nTried + nNew))\n-        return -7;\n-\n-    for (const auto& entry : mapInfo) {\n-        int n = entry.first;\n-        const CAddrInfo& info = entry.second;\n-        if (info.fInTried) {\n-            if (!info.nLastSuccess)\n-                return -1;\n-            if (info.nRefCount)\n-                return -2;\n-            setTried.insert(n);\n-        } else {\n-            if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)\n-                return -3;\n-            if (!info.nRefCount)\n-                return -4;\n-            mapNew[n] = info.nRefCount;\n-        }\n-        const auto it{mapAddr.find(info)};\n-        if (it == mapAddr.end() || it->second != n) {\n-            return -5;\n-        }\n-        if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)\n-            return -14;\n-        if (info.nLastTry < 0)\n-            return -6;\n-        if (info.nLastSuccess < 0)\n-            return -8;\n-    }\n-\n-    if (setTried.size() != (size_t)nTried)\n-        return -9;\n-    if (mapNew.size() != (size_t)nNew)\n-        return -10;\n-\n-    for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {\n-        for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {\n-            if (vvTried[n][i] != -1) {\n-                if (!setTried.count(vvTried[n][i]))\n-                    return -11;\n-                const auto it{mapInfo.find(vvTried[n][i])};\n-                if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_asmap) != n) {\n-                    return -17;\n-                }\n-                if (it->second.GetBucketPosition(nKey, false, n) != i) {\n-                    return -18;\n-                }\n-                setTried.erase(vvTried[n][i]);\n-            }\n-        }\n-    }\n-\n-    for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {\n-        for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {\n-            if (vvNew[n][i] != -1) {\n-                if (!mapNew.count(vvNew[n][i]))\n-                    return -12;\n-                const auto it{mapInfo.find(vvNew[n][i])};\n-                if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {\n-                    return -19;\n-                }\n-                if (--mapNew[vvNew[n][i]] == 0)\n-                    mapNew.erase(vvNew[n][i]);\n-            }\n-        }\n-    }\n-\n-    if (setTried.size())\n-        return -13;\n-    if (mapNew.size())\n-        return -15;\n-    if (nKey.IsNull())\n-        return -16;\n-\n-    LogPrint(BCLog::ADDRMAN, \"Addrman checks completed successfully\\n\");\n-    return 0;\n-}\n \n void CAddrMan::GetAddr_(std::vector<CAddress>& vAddr, size_t max_addresses, size_t max_pct, std::optional<Network> network) const\n {\n@@ -1023,6 +921,109 @@ CAddrInfo CAddrMan::SelectTriedCollision_()\n     return mapInfo[id_old];\n }\n \n+void CAddrMan::Check() const\n+{\n+    AssertLockHeld(cs);\n+\n+    // Run consistency checks 1 in m_consistency_check_ratio times if enabled\n+    if (m_consistency_check_ratio == 0) return;\n+    if (insecure_rand.randrange(m_consistency_check_ratio) >= 1) return;\n+\n+    const int err{ForceCheckAddrman()};\n+    if (err) {\n+        LogPrintf(\"ADDRMAN CONSISTENCY CHECK FAILED!!! err=%i\\n\", err);\n+        assert(false);\n+    }\n+}\n+\n+int CAddrMan::ForceCheckAddrman() const\n+{\n+    AssertLockHeld(cs);\n+\n+    LogPrint(BCLog::ADDRMAN, \"Addrman checks started: new %i, tried %i, total %u\\n\", nNew, nTried, vRandom.size());\n+\n+    std::unordered_set<int> setTried;\n+    std::unordered_map<int, int> mapNew;\n+\n+    if (vRandom.size() != (size_t)(nTried + nNew))\n+        return -7;\n+\n+    for (const auto& entry : mapInfo) {\n+        int n = entry.first;\n+        const CAddrInfo& info = entry.second;\n+        if (info.fInTried) {\n+            if (!info.nLastSuccess)\n+                return -1;\n+            if (info.nRefCount)\n+                return -2;\n+            setTried.insert(n);\n+        } else {\n+            if (info.nRefCount < 0 || info.nRefCount > ADDRMAN_NEW_BUCKETS_PER_ADDRESS)\n+                return -3;\n+            if (!info.nRefCount)\n+                return -4;\n+            mapNew[n] = info.nRefCount;\n+        }\n+        const auto it{mapAddr.find(info)};\n+        if (it == mapAddr.end() || it->second != n) {\n+            return -5;\n+        }\n+        if (info.nRandomPos < 0 || (size_t)info.nRandomPos >= vRandom.size() || vRandom[info.nRandomPos] != n)\n+            return -14;\n+        if (info.nLastTry < 0)\n+            return -6;\n+        if (info.nLastSuccess < 0)\n+            return -8;\n+    }\n+\n+    if (setTried.size() != (size_t)nTried)\n+        return -9;\n+    if (mapNew.size() != (size_t)nNew)\n+        return -10;\n+\n+    for (int n = 0; n < ADDRMAN_TRIED_BUCKET_COUNT; n++) {\n+        for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {\n+            if (vvTried[n][i] != -1) {\n+                if (!setTried.count(vvTried[n][i]))\n+                    return -11;\n+                const auto it{mapInfo.find(vvTried[n][i])};\n+                if (it == mapInfo.end() || it->second.GetTriedBucket(nKey, m_asmap) != n) {\n+                    return -17;\n+                }\n+                if (it->second.GetBucketPosition(nKey, false, n) != i) {\n+                    return -18;\n+                }\n+                setTried.erase(vvTried[n][i]);\n+            }\n+        }\n+    }\n+\n+    for (int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {\n+        for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {\n+            if (vvNew[n][i] != -1) {\n+                if (!mapNew.count(vvNew[n][i]))\n+                    return -12;\n+                const auto it{mapInfo.find(vvNew[n][i])};\n+                if (it == mapInfo.end() || it->second.GetBucketPosition(nKey, true, n) != i) {\n+                    return -19;\n+                }\n+                if (--mapNew[vvNew[n][i]] == 0)\n+                    mapNew.erase(vvNew[n][i]);\n+            }\n+        }\n+    }\n+\n+    if (setTried.size())\n+        return -13;\n+    if (mapNew.size())\n+        return -15;\n+    if (nKey.IsNull())\n+        return -16;\n+\n+    LogPrint(BCLog::ADDRMAN, \"Addrman checks completed successfully\\n\");\n+    return 0;\n+}\n+\n size_t CAddrMan::size() const\n {\n     LOCK(cs); // TODO: Cache this in an atomic to avoid this overhead"
      },
      {
        "sha": "d3d764c9c64e77009ebe75ec19dd6abdd402ff68",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 20,
        "deletions": 20,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f2e5f38f09ee40933f752680fe7d75ee8e529fae/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f2e5f38f09ee40933f752680fe7d75ee8e529fae/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=f2e5f38f09ee40933f752680fe7d75ee8e529fae",
        "patch": "@@ -142,16 +142,16 @@ static constexpr int ADDRMAN_BUCKET_SIZE{1 << ADDRMAN_BUCKET_SIZE_LOG2};\n class CAddrMan\n {\n public:\n+    explicit CAddrMan(std::vector<bool> asmap, bool deterministic, int32_t consistency_check_ratio);\n+\n+    ~CAddrMan();\n+\n     template <typename Stream>\n     void Serialize(Stream& s_) const EXCLUSIVE_LOCKS_REQUIRED(!cs);\n \n     template <typename Stream>\n     void Unserialize(Stream& s_) EXCLUSIVE_LOCKS_REQUIRED(!cs);\n \n-    explicit CAddrMan(std::vector<bool> asmap, bool deterministic, int32_t consistency_check_ratio);\n-\n-    ~CAddrMan();\n-\n     //! Return the number of (unique) addresses in all tables.\n     size_t size() const EXCLUSIVE_LOCKS_REQUIRED(!cs);\n \n@@ -289,15 +289,15 @@ class CAddrMan\n     //! Swap two elements in vRandom.\n     void SwapRandom(unsigned int nRandomPos1, unsigned int nRandomPos2) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n-    //! Move an entry from the \"new\" table(s) to the \"tried\" table\n-    void MakeTried(CAddrInfo& info, int nId) EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n     //! Delete an entry. It must not be in tried, and have refcount 0.\n     void Delete(int nId) EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n     //! Clear a position in a \"new\" table. This is the only place where entries are actually deleted.\n     void ClearNew(int nUBucket, int nUBucketPos) EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n+    //! Move an entry from the \"new\" table(s) to the \"tried\" table\n+    void MakeTried(CAddrInfo& info, int nId) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n     //! Mark an entry \"good\", possibly moving it from \"new\" to \"tried\".\n     void Good_(const CService &addr, bool test_before_evict, int64_t time) EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n@@ -310,19 +310,6 @@ class CAddrMan\n     //! Select an address to connect to, if newOnly is set to true, only the new table is selected from.\n     CAddrInfo Select_(bool newOnly) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n-    //! See if any to-be-evicted tried table entries have been tested and if so resolve the collisions.\n-    void ResolveCollisions_() EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! Return a random to-be-evicted tried table address.\n-    CAddrInfo SelectTriedCollision_() EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! Consistency check, taking into account m_consistency_check_ratio. Will std::abort if an inconsistency is detected.\n-    void Check() const EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! Perform consistency check, regardless of m_consistency_check_ratio.\n-    //! @returns an error code or zero.\n-    int ForceCheckAddrman() const EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n     /**\n      * Return all or many randomly selected addresses, optionally by network.\n      *\n@@ -349,6 +336,19 @@ class CAddrMan\n     //! Update an entry's service bits.\n     void SetServices_(const CService &addr, ServiceFlags nServices) EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n+    //! See if any to-be-evicted tried table entries have been tested and if so resolve the collisions.\n+    void ResolveCollisions_() EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Return a random to-be-evicted tried table address.\n+    CAddrInfo SelectTriedCollision_() EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Consistency check, taking into account m_consistency_check_ratio. Will std::abort if an inconsistency is detected.\n+    void Check() const EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Perform consistency check, regardless of m_consistency_check_ratio.\n+    //! @returns an error code or zero.\n+    int ForceCheckAddrman() const EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n     friend class CAddrManTest;\n     friend class CAddrManDeterministic;\n };"
      }
    ]
  },
  {
    "sha": "8af5b54f973e11c847345418d8631bc301b96130",
    "node_id": "C_kwDOABII59oAKDhhZjViNTRmOTczZTExYzg0NzM0NTQxOGQ4NjMxYmMzMDFiOTYxMzA",
    "commit": {
      "author": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2021-09-01T18:21:29Z"
      },
      "committer": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2021-09-28T23:02:34Z"
      },
      "message": "[addrman] Introduce CAddrMan::Impl to encapsulate addrman implementation.\n\nIntroduce the pimpl pattern for CAddrMan to separate the implementation details\nfrom the externally used object representation. This reduces compile-time\ndependencies and conceptually clarifies AddrMan's interface from the\nimplementation specifics.\n\nSince the unit & fuzz tests currently rely on accessing CAddrMan internals, this\ncommit introduces addrman_impl.h, which is exclusively imported by addrman.cpp\nand test files.\n\nReview hint: git diff --color-moved=dimmed-zebra\n--color-moved-ws=ignore-all-space",
      "tree": {
        "sha": "29080d2442f453fc2483fb42b7302b3bfc7fd026",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/29080d2442f453fc2483fb42b7302b3bfc7fd026"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8af5b54f973e11c847345418d8631bc301b96130",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8af5b54f973e11c847345418d8631bc301b96130",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8af5b54f973e11c847345418d8631bc301b96130",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8af5b54f973e11c847345418d8631bc301b96130/comments",
    "author": {
      "login": "amitiuttarwar",
      "id": 1500952,
      "node_id": "MDQ6VXNlcjE1MDA5NTI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/amitiuttarwar",
      "html_url": "https://github.com/amitiuttarwar",
      "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
      "following_url": "https://api.github.com/users/amitiuttarwar/following{/other_user}",
      "gists_url": "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
      "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
      "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
      "events_url": "https://api.github.com/users/amitiuttarwar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "amitiuttarwar",
      "id": 1500952,
      "node_id": "MDQ6VXNlcjE1MDA5NTI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/amitiuttarwar",
      "html_url": "https://github.com/amitiuttarwar",
      "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
      "following_url": "https://api.github.com/users/amitiuttarwar/following{/other_user}",
      "gists_url": "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
      "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
      "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
      "events_url": "https://api.github.com/users/amitiuttarwar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f2e5f38f09ee40933f752680fe7d75ee8e529fae",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f2e5f38f09ee40933f752680fe7d75ee8e529fae",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f2e5f38f09ee40933f752680fe7d75ee8e529fae"
      }
    ],
    "stats": {
      "total": 616,
      "additions": 371,
      "deletions": 245
    },
    "files": [
      {
        "sha": "72aa3829f4cb21cc1fc325feb1de1ce9b1c35bf4",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8af5b54f973e11c847345418d8631bc301b96130/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8af5b54f973e11c847345418d8631bc301b96130/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=8af5b54f973e11c847345418d8631bc301b96130",
        "patch": "@@ -117,6 +117,7 @@ endif\n BITCOIN_CORE_H = \\\n   addrdb.h \\\n   addrman.h \\\n+  addrman_impl.h \\\n   attributes.h \\\n   banman.h \\\n   base58.h \\"
      },
      {
        "sha": "2fc6ca29a12e72ab649aff88114cd6c3637f99f4",
        "filename": "src/addrman.cpp",
        "status": "modified",
        "additions": 114,
        "deletions": 43,
        "changes": 157,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8af5b54f973e11c847345418d8631bc301b96130/src/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8af5b54f973e11c847345418d8631bc301b96130/src/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.cpp?ref=8af5b54f973e11c847345418d8631bc301b96130",
        "patch": "@@ -4,6 +4,7 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include <addrman.h>\n+#include <addrman_impl.h>\n \n #include <clientversion.h>\n #include <hash.h>\n@@ -101,7 +102,7 @@ double CAddrInfo::GetChance(int64_t nNow) const\n     return fChance;\n }\n \n-CAddrMan::CAddrMan(std::vector<bool> asmap, bool deterministic, int32_t consistency_check_ratio)\n+AddrManImpl::AddrManImpl(std::vector<bool>&& asmap, bool deterministic, int32_t consistency_check_ratio)\n     : insecure_rand{deterministic}\n     , nKey{deterministic ? uint256{1} : insecure_rand.rand256()}\n     , m_consistency_check_ratio{consistency_check_ratio}\n@@ -119,13 +120,13 @@ CAddrMan::CAddrMan(std::vector<bool> asmap, bool deterministic, int32_t consiste\n     }\n }\n \n-CAddrMan::~CAddrMan()\n+AddrManImpl::~AddrManImpl()\n {\n     nKey.SetNull();\n }\n \n template <typename Stream>\n-void CAddrMan::Serialize(Stream& s_) const\n+void AddrManImpl::Serialize(Stream& s_) const\n {\n     LOCK(cs);\n \n@@ -228,7 +229,7 @@ void CAddrMan::Serialize(Stream& s_) const\n }\n \n template <typename Stream>\n-void CAddrMan::Unserialize(Stream& s_)\n+void AddrManImpl::Unserialize(Stream& s_)\n {\n     LOCK(cs);\n \n@@ -399,16 +400,7 @@ void CAddrMan::Unserialize(Stream& s_)\n     }\n }\n \n-// explicit instantiation\n-template void CAddrMan::Serialize(CHashWriter& s) const;\n-template void CAddrMan::Serialize(CAutoFile& s) const;\n-template void CAddrMan::Serialize(CDataStream& s) const;\n-template void CAddrMan::Unserialize(CAutoFile& s);\n-template void CAddrMan::Unserialize(CHashVerifier<CAutoFile>& s);\n-template void CAddrMan::Unserialize(CDataStream& s);\n-template void CAddrMan::Unserialize(CHashVerifier<CDataStream>& s);\n-\n-CAddrInfo* CAddrMan::Find(const CNetAddr& addr, int* pnId)\n+CAddrInfo* AddrManImpl::Find(const CNetAddr& addr, int* pnId)\n {\n     AssertLockHeld(cs);\n \n@@ -423,7 +415,7 @@ CAddrInfo* CAddrMan::Find(const CNetAddr& addr, int* pnId)\n     return nullptr;\n }\n \n-CAddrInfo* CAddrMan::Create(const CAddress& addr, const CNetAddr& addrSource, int* pnId)\n+CAddrInfo* AddrManImpl::Create(const CAddress& addr, const CNetAddr& addrSource, int* pnId)\n {\n     AssertLockHeld(cs);\n \n@@ -437,7 +429,7 @@ CAddrInfo* CAddrMan::Create(const CAddress& addr, const CNetAddr& addrSource, in\n     return &mapInfo[nId];\n }\n \n-void CAddrMan::SwapRandom(unsigned int nRndPos1, unsigned int nRndPos2) const\n+void AddrManImpl::SwapRandom(unsigned int nRndPos1, unsigned int nRndPos2) const\n {\n     AssertLockHeld(cs);\n \n@@ -461,7 +453,7 @@ void CAddrMan::SwapRandom(unsigned int nRndPos1, unsigned int nRndPos2) const\n     vRandom[nRndPos2] = nId1;\n }\n \n-void CAddrMan::Delete(int nId)\n+void AddrManImpl::Delete(int nId)\n {\n     AssertLockHeld(cs);\n \n@@ -477,7 +469,7 @@ void CAddrMan::Delete(int nId)\n     nNew--;\n }\n \n-void CAddrMan::ClearNew(int nUBucket, int nUBucketPos)\n+void AddrManImpl::ClearNew(int nUBucket, int nUBucketPos)\n {\n     AssertLockHeld(cs);\n \n@@ -494,7 +486,7 @@ void CAddrMan::ClearNew(int nUBucket, int nUBucketPos)\n     }\n }\n \n-void CAddrMan::MakeTried(CAddrInfo& info, int nId)\n+void AddrManImpl::MakeTried(CAddrInfo& info, int nId)\n {\n     AssertLockHeld(cs);\n \n@@ -547,7 +539,7 @@ void CAddrMan::MakeTried(CAddrInfo& info, int nId)\n     info.fInTried = true;\n }\n \n-void CAddrMan::Good_(const CService& addr, bool test_before_evict, int64_t nTime)\n+void AddrManImpl::Good_(const CService& addr, bool test_before_evict, int64_t nTime)\n {\n     AssertLockHeld(cs);\n \n@@ -603,7 +595,7 @@ void CAddrMan::Good_(const CService& addr, bool test_before_evict, int64_t nTime\n     }\n }\n \n-bool CAddrMan::Add_(const CAddress& addr, const CNetAddr& source, int64_t nTimePenalty)\n+bool AddrManImpl::Add_(const CAddress& addr, const CNetAddr& source, int64_t nTimePenalty)\n {\n     AssertLockHeld(cs);\n \n@@ -678,7 +670,7 @@ bool CAddrMan::Add_(const CAddress& addr, const CNetAddr& source, int64_t nTimeP\n     return fNew;\n }\n \n-void CAddrMan::Attempt_(const CService& addr, bool fCountFailure, int64_t nTime)\n+void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, int64_t nTime)\n {\n     AssertLockHeld(cs);\n \n@@ -702,7 +694,7 @@ void CAddrMan::Attempt_(const CService& addr, bool fCountFailure, int64_t nTime)\n     }\n }\n \n-CAddrInfo CAddrMan::Select_(bool newOnly) const\n+CAddrInfo AddrManImpl::Select_(bool newOnly) const\n {\n     AssertLockHeld(cs);\n \n@@ -753,8 +745,7 @@ CAddrInfo CAddrMan::Select_(bool newOnly) const\n     }\n }\n \n-\n-void CAddrMan::GetAddr_(std::vector<CAddress>& vAddr, size_t max_addresses, size_t max_pct, std::optional<Network> network) const\n+void AddrManImpl::GetAddr_(std::vector<CAddress>& vAddr, size_t max_addresses, size_t max_pct, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n@@ -789,7 +780,7 @@ void CAddrMan::GetAddr_(std::vector<CAddress>& vAddr, size_t max_addresses, size\n     }\n }\n \n-void CAddrMan::Connected_(const CService& addr, int64_t nTime)\n+void AddrManImpl::Connected_(const CService& addr, int64_t nTime)\n {\n     AssertLockHeld(cs);\n \n@@ -811,7 +802,7 @@ void CAddrMan::Connected_(const CService& addr, int64_t nTime)\n         info.nTime = nTime;\n }\n \n-void CAddrMan::SetServices_(const CService& addr, ServiceFlags nServices)\n+void AddrManImpl::SetServices_(const CService& addr, ServiceFlags nServices)\n {\n     AssertLockHeld(cs);\n \n@@ -831,7 +822,7 @@ void CAddrMan::SetServices_(const CService& addr, ServiceFlags nServices)\n     info.nServices = nServices;\n }\n \n-void CAddrMan::ResolveCollisions_()\n+void AddrManImpl::ResolveCollisions_()\n {\n     AssertLockHeld(cs);\n \n@@ -892,7 +883,7 @@ void CAddrMan::ResolveCollisions_()\n     }\n }\n \n-CAddrInfo CAddrMan::SelectTriedCollision_()\n+CAddrInfo AddrManImpl::SelectTriedCollision_()\n {\n     AssertLockHeld(cs);\n \n@@ -921,7 +912,7 @@ CAddrInfo CAddrMan::SelectTriedCollision_()\n     return mapInfo[id_old];\n }\n \n-void CAddrMan::Check() const\n+void AddrManImpl::Check() const\n {\n     AssertLockHeld(cs);\n \n@@ -936,7 +927,7 @@ void CAddrMan::Check() const\n     }\n }\n \n-int CAddrMan::ForceCheckAddrman() const\n+int AddrManImpl::ForceCheckAddrman() const\n {\n     AssertLockHeld(cs);\n \n@@ -1024,13 +1015,13 @@ int CAddrMan::ForceCheckAddrman() const\n     return 0;\n }\n \n-size_t CAddrMan::size() const\n+size_t AddrManImpl::size() const\n {\n     LOCK(cs); // TODO: Cache this in an atomic to avoid this overhead\n     return vRandom.size();\n }\n \n-bool CAddrMan::Add(const std::vector<CAddress> &vAddr, const CNetAddr& source, int64_t nTimePenalty)\n+bool AddrManImpl::Add(const std::vector<CAddress> &vAddr, const CNetAddr& source, int64_t nTimePenalty)\n {\n     LOCK(cs);\n     int nAdd = 0;\n@@ -1044,32 +1035,31 @@ bool CAddrMan::Add(const std::vector<CAddress> &vAddr, const CNetAddr& source, i\n     return nAdd > 0;\n }\n \n-void CAddrMan::Good(const CService &addr, int64_t nTime)\n+void AddrManImpl::Good(const CService &addr, int64_t nTime)\n {\n     LOCK(cs);\n     Check();\n     Good_(addr, /* test_before_evict */ true, nTime);\n     Check();\n }\n \n-void CAddrMan::Attempt(const CService &addr, bool fCountFailure, int64_t nTime)\n+void AddrManImpl::Attempt(const CService &addr, bool fCountFailure, int64_t nTime)\n {\n     LOCK(cs);\n     Check();\n     Attempt_(addr, fCountFailure, nTime);\n     Check();\n }\n \n-\n-void CAddrMan::ResolveCollisions()\n+void AddrManImpl::ResolveCollisions()\n {\n     LOCK(cs);\n     Check();\n     ResolveCollisions_();\n     Check();\n }\n \n-CAddrInfo CAddrMan::SelectTriedCollision()\n+CAddrInfo AddrManImpl::SelectTriedCollision()\n {\n     LOCK(cs);\n     Check();\n@@ -1078,7 +1068,7 @@ CAddrInfo CAddrMan::SelectTriedCollision()\n     return ret;\n }\n \n-CAddrInfo CAddrMan::Select(bool newOnly) const\n+CAddrInfo AddrManImpl::Select(bool newOnly) const\n {\n     LOCK(cs);\n     Check();\n@@ -1087,7 +1077,7 @@ CAddrInfo CAddrMan::Select(bool newOnly) const\n     return addrRet;\n }\n \n-std::vector<CAddress> CAddrMan::GetAddr(size_t max_addresses, size_t max_pct, std::optional<Network> network) const\n+std::vector<CAddress> AddrManImpl::GetAddr(size_t max_addresses, size_t max_pct, std::optional<Network> network) const\n {\n     LOCK(cs);\n     Check();\n@@ -1097,23 +1087,104 @@ std::vector<CAddress> CAddrMan::GetAddr(size_t max_addresses, size_t max_pct, st\n     return vAddr;\n }\n \n-void CAddrMan::Connected(const CService &addr, int64_t nTime)\n+void AddrManImpl::Connected(const CService &addr, int64_t nTime)\n {\n     LOCK(cs);\n     Check();\n     Connected_(addr, nTime);\n     Check();\n }\n \n-void CAddrMan::SetServices(const CService &addr, ServiceFlags nServices)\n+void AddrManImpl::SetServices(const CService &addr, ServiceFlags nServices)\n {\n     LOCK(cs);\n     Check();\n     SetServices_(addr, nServices);\n     Check();\n }\n \n-const std::vector<bool>& CAddrMan::GetAsmap() const\n+const std::vector<bool>& AddrManImpl::GetAsmap() const\n {\n     return m_asmap;\n }\n+\n+CAddrMan::CAddrMan(std::vector<bool> asmap, bool deterministic, int32_t consistency_check_ratio)\n+    : m_impl(std::make_unique<AddrManImpl>(std::move(asmap), deterministic, consistency_check_ratio)) {}\n+\n+CAddrMan::~CAddrMan() = default;\n+\n+template <typename Stream>\n+void CAddrMan::Serialize(Stream& s_) const\n+{\n+    m_impl->Serialize<Stream>(s_);\n+}\n+\n+template <typename Stream>\n+void CAddrMan::Unserialize(Stream& s_)\n+{\n+    m_impl->Unserialize<Stream>(s_);\n+}\n+\n+// explicit instantiation\n+template void CAddrMan::Serialize(CHashWriter& s) const;\n+template void CAddrMan::Serialize(CAutoFile& s) const;\n+template void CAddrMan::Serialize(CDataStream& s) const;\n+template void CAddrMan::Unserialize(CAutoFile& s);\n+template void CAddrMan::Unserialize(CHashVerifier<CAutoFile>& s);\n+template void CAddrMan::Unserialize(CDataStream& s);\n+template void CAddrMan::Unserialize(CHashVerifier<CDataStream>& s);\n+\n+size_t CAddrMan::size() const\n+{\n+    return m_impl->size();\n+}\n+\n+bool CAddrMan::Add(const std::vector<CAddress> &vAddr, const CNetAddr& source, int64_t nTimePenalty)\n+{\n+    return m_impl->Add(vAddr, source, nTimePenalty);\n+}\n+\n+void CAddrMan::Good(const CService &addr, int64_t nTime)\n+{\n+    m_impl->Good(addr, nTime);\n+}\n+\n+void CAddrMan::Attempt(const CService &addr, bool fCountFailure, int64_t nTime)\n+{\n+    m_impl->Attempt(addr, fCountFailure, nTime);\n+}\n+\n+void CAddrMan::ResolveCollisions()\n+{\n+    m_impl->ResolveCollisions();\n+}\n+\n+CAddrInfo CAddrMan::SelectTriedCollision()\n+{\n+    return m_impl->SelectTriedCollision();\n+}\n+\n+CAddrInfo CAddrMan::Select(bool newOnly) const\n+{\n+    return m_impl->Select(newOnly);\n+}\n+\n+std::vector<CAddress> CAddrMan::GetAddr(size_t max_addresses, size_t max_pct, std::optional<Network> network) const\n+{\n+    return m_impl->GetAddr(max_addresses, max_pct, network);\n+}\n+\n+void CAddrMan::Connected(const CService &addr, int64_t nTime)\n+{\n+    m_impl->Connected(addr, nTime);\n+}\n+\n+void CAddrMan::SetServices(const CService &addr, ServiceFlags nServices)\n+{\n+    m_impl->SetServices(addr, nServices);\n+}\n+\n+const std::vector<bool>& CAddrMan::GetAsmap() const\n+{\n+    return m_impl->GetAsmap();\n+}"
      },
      {
        "sha": "2135295b89248600c5e30f2cbc8669567e83a43a",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 17,
        "deletions": 171,
        "changes": 188,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8af5b54f973e11c847345418d8631bc301b96130/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8af5b54f973e11c847345418d8631bc301b96130/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=8af5b54f973e11c847345418d8631bc301b96130",
        "patch": "@@ -19,6 +19,8 @@\n #include <unordered_map>\n #include <vector>\n \n+class AddrManImpl;\n+\n /** Default for -checkaddrman */\n static constexpr int32_t DEFAULT_ADDRMAN_CONSISTENCY_CHECKS{0};\n \n@@ -53,7 +55,7 @@ class CAddrInfo : public CAddress\n     //! position in vRandom\n     mutable int nRandomPos{-1};\n \n-    friend class CAddrMan;\n+    friend class AddrManImpl;\n     friend class CAddrManDeterministic;\n \n public:\n@@ -141,42 +143,41 @@ static constexpr int ADDRMAN_BUCKET_SIZE{1 << ADDRMAN_BUCKET_SIZE_LOG2};\n  */\n class CAddrMan\n {\n+    const std::unique_ptr<AddrManImpl> m_impl;\n+\n public:\n     explicit CAddrMan(std::vector<bool> asmap, bool deterministic, int32_t consistency_check_ratio);\n \n     ~CAddrMan();\n \n     template <typename Stream>\n-    void Serialize(Stream& s_) const EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+    void Serialize(Stream& s_) const;\n \n     template <typename Stream>\n-    void Unserialize(Stream& s_) EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+    void Unserialize(Stream& s_);\n \n     //! Return the number of (unique) addresses in all tables.\n-    size_t size() const EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+    size_t size() const;\n \n     //! Add addresses to addrman's new table.\n-    bool Add(const std::vector<CAddress> &vAddr, const CNetAddr& source, int64_t nTimePenalty = 0)\n-        EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+    bool Add(const std::vector<CAddress> &vAddr, const CNetAddr& source, int64_t nTimePenalty = 0);\n \n     //! Mark an entry as accessible.\n-    void Good(const CService &addr, int64_t nTime = GetAdjustedTime())\n-        EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+    void Good(const CService &addr, int64_t nTime = GetAdjustedTime());\n \n     //! Mark an entry as connection attempted to.\n-    void Attempt(const CService &addr, bool fCountFailure, int64_t nTime = GetAdjustedTime())\n-        EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+    void Attempt(const CService &addr, bool fCountFailure, int64_t nTime = GetAdjustedTime());\n \n     //! See if any to-be-evicted tried table entries have been tested and if so resolve the collisions.\n-    void ResolveCollisions() EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+    void ResolveCollisions();\n \n     //! Randomly select an address in tried that another address is attempting to evict.\n-    CAddrInfo SelectTriedCollision() EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+    CAddrInfo SelectTriedCollision();\n \n     /**\n      * Choose an address to connect to.\n      */\n-    CAddrInfo Select(bool newOnly = false) const EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+    CAddrInfo Select(bool newOnly = false) const;\n \n     /**\n      * Return all or many randomly selected addresses, optionally by network.\n@@ -185,170 +186,15 @@ class CAddrMan\n      * @param[in] max_pct        Maximum percentage of addresses to return (0 = all).\n      * @param[in] network        Select only addresses of this network (nullopt = all).\n      */\n-    std::vector<CAddress> GetAddr(size_t max_addresses, size_t max_pct, std::optional<Network> network) const\n-        EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+    std::vector<CAddress> GetAddr(size_t max_addresses, size_t max_pct, std::optional<Network> network) const;\n \n     //! Outer function for Connected_()\n-    void Connected(const CService &addr, int64_t nTime = GetAdjustedTime())\n-        EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+    void Connected(const CService &addr, int64_t nTime = GetAdjustedTime());\n \n-    void SetServices(const CService &addr, ServiceFlags nServices)\n-        EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+    void SetServices(const CService &addr, ServiceFlags nServices);\n \n     const std::vector<bool>& GetAsmap() const;\n \n-private:\n-    //! A mutex to protect the inner data structures.\n-    mutable Mutex cs;\n-\n-    //! Source of random numbers for randomization in inner loops\n-    mutable FastRandomContext insecure_rand GUARDED_BY(cs);\n-\n-    //! secret key to randomize bucket select with\n-    uint256 nKey;\n-\n-    //! Serialization versions.\n-    enum Format : uint8_t {\n-        V0_HISTORICAL = 0,    //!< historic format, before commit e6b343d88\n-        V1_DETERMINISTIC = 1, //!< for pre-asmap files\n-        V2_ASMAP = 2,         //!< for files including asmap version\n-        V3_BIP155 = 3,        //!< same as V2_ASMAP plus addresses are in BIP155 format\n-    };\n-\n-    //! The maximum format this software knows it can unserialize. Also, we always serialize\n-    //! in this format.\n-    //! The format (first byte in the serialized stream) can be higher than this and\n-    //! still this software may be able to unserialize the file - if the second byte\n-    //! (see `lowest_compatible` in `Unserialize()`) is less or equal to this.\n-    static constexpr Format FILE_FORMAT = Format::V3_BIP155;\n-\n-    //! The initial value of a field that is incremented every time an incompatible format\n-    //! change is made (such that old software versions would not be able to parse and\n-    //! understand the new file format). This is 32 because we overtook the \"key size\"\n-    //! field which was 32 historically.\n-    //! @note Don't increment this. Increment `lowest_compatible` in `Serialize()` instead.\n-    static constexpr uint8_t INCOMPATIBILITY_BASE = 32;\n-\n-    //! last used nId\n-    int nIdCount GUARDED_BY(cs){0};\n-\n-    //! table with information about all nIds\n-    std::unordered_map<int, CAddrInfo> mapInfo GUARDED_BY(cs);\n-\n-    //! find an nId based on its network address\n-    std::unordered_map<CNetAddr, int, CNetAddrHash> mapAddr GUARDED_BY(cs);\n-\n-    //! randomly-ordered vector of all nIds\n-    //! This is mutable because it is unobservable outside the class, so any\n-    //! changes to it (even in const methods) are also unobservable.\n-    mutable std::vector<int> vRandom GUARDED_BY(cs);\n-\n-    // number of \"tried\" entries\n-    int nTried GUARDED_BY(cs){0};\n-\n-    //! list of \"tried\" buckets\n-    int vvTried[ADDRMAN_TRIED_BUCKET_COUNT][ADDRMAN_BUCKET_SIZE] GUARDED_BY(cs);\n-\n-    //! number of (unique) \"new\" entries\n-    int nNew GUARDED_BY(cs){0};\n-\n-    //! list of \"new\" buckets\n-    int vvNew[ADDRMAN_NEW_BUCKET_COUNT][ADDRMAN_BUCKET_SIZE] GUARDED_BY(cs);\n-\n-    //! last time Good was called (memory only). Initially set to 1 so that \"never\" is strictly worse.\n-    int64_t nLastGood GUARDED_BY(cs){1};\n-\n-    //! Holds addrs inserted into tried table that collide with existing entries. Test-before-evict discipline used to resolve these collisions.\n-    std::set<int> m_tried_collisions;\n-\n-    /** Perform consistency checks every m_consistency_check_ratio operations (if non-zero). */\n-    const int32_t m_consistency_check_ratio;\n-\n-    // Compressed IP->ASN mapping, loaded from a file when a node starts.\n-    // Should be always empty if no file was provided.\n-    // This mapping is then used for bucketing nodes in Addrman.\n-    //\n-    // If asmap is provided, nodes will be bucketed by\n-    // AS they belong to, in order to make impossible for a node\n-    // to connect to several nodes hosted in a single AS.\n-    // This is done in response to Erebus attack, but also to generally\n-    // diversify the connections every node creates,\n-    // especially useful when a large fraction of nodes\n-    // operate under a couple of cloud providers.\n-    //\n-    // If a new asmap was provided, the existing records\n-    // would be re-bucketed accordingly.\n-    const std::vector<bool> m_asmap;\n-\n-    //! Find an entry.\n-    CAddrInfo* Find(const CNetAddr& addr, int *pnId = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! Create a new entry and add it to the internal data structures mapInfo, mapAddr and vRandom.\n-    CAddrInfo* Create(const CAddress &addr, const CNetAddr &addrSource, int *pnId = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! Swap two elements in vRandom.\n-    void SwapRandom(unsigned int nRandomPos1, unsigned int nRandomPos2) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! Delete an entry. It must not be in tried, and have refcount 0.\n-    void Delete(int nId) EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! Clear a position in a \"new\" table. This is the only place where entries are actually deleted.\n-    void ClearNew(int nUBucket, int nUBucketPos) EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! Move an entry from the \"new\" table(s) to the \"tried\" table\n-    void MakeTried(CAddrInfo& info, int nId) EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! Mark an entry \"good\", possibly moving it from \"new\" to \"tried\".\n-    void Good_(const CService &addr, bool test_before_evict, int64_t time) EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! Add an entry to the \"new\" table.\n-    bool Add_(const CAddress &addr, const CNetAddr& source, int64_t nTimePenalty) EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! Mark an entry as attempted to connect.\n-    void Attempt_(const CService &addr, bool fCountFailure, int64_t nTime) EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! Select an address to connect to, if newOnly is set to true, only the new table is selected from.\n-    CAddrInfo Select_(bool newOnly) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    /**\n-     * Return all or many randomly selected addresses, optionally by network.\n-     *\n-     * @param[out] vAddr         Vector of randomly selected addresses from vRandom.\n-     * @param[in] max_addresses  Maximum number of addresses to return (0 = all).\n-     * @param[in] max_pct        Maximum percentage of addresses to return (0 = all).\n-     * @param[in] network        Select only addresses of this network (nullopt = all).\n-     */\n-    void GetAddr_(std::vector<CAddress>& vAddr, size_t max_addresses, size_t max_pct, std::optional<Network> network) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    /** We have successfully connected to this peer. Calling this function\n-     *  updates the CAddress's nTime, which is used in our IsTerrible()\n-     *  decisions and gossiped to peers. Callers should be careful that updating\n-     *  this information doesn't leak topology information to network spies.\n-     *\n-     *  net_processing calls this function when it *disconnects* from a peer to\n-     *  not leak information about currently connected peers.\n-     *\n-     * @param[in]   addr     The address of the peer we were connected to\n-     * @param[in]   nTime    The time that we were last connected to this peer\n-     */\n-    void Connected_(const CService& addr, int64_t nTime) EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! Update an entry's service bits.\n-    void SetServices_(const CService &addr, ServiceFlags nServices) EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! See if any to-be-evicted tried table entries have been tested and if so resolve the collisions.\n-    void ResolveCollisions_() EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! Return a random to-be-evicted tried table address.\n-    CAddrInfo SelectTriedCollision_() EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! Consistency check, taking into account m_consistency_check_ratio. Will std::abort if an inconsistency is detected.\n-    void Check() const EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n-    //! Perform consistency check, regardless of m_consistency_check_ratio.\n-    //! @returns an error code or zero.\n-    int ForceCheckAddrman() const EXCLUSIVE_LOCKS_REQUIRED(cs);\n-\n     friend class CAddrManTest;\n     friend class CAddrManDeterministic;\n };"
      },
      {
        "sha": "ee4b55e5c4c75bdbdad25670ac622ea8b75a4815",
        "filename": "src/addrman_impl.h",
        "status": "added",
        "additions": 206,
        "deletions": 0,
        "changes": 206,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8af5b54f973e11c847345418d8631bc301b96130/src/addrman_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8af5b54f973e11c847345418d8631bc301b96130/src/addrman_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman_impl.h?ref=8af5b54f973e11c847345418d8631bc301b96130",
        "patch": "@@ -0,0 +1,206 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_ADDRMAN_IMPL_H\n+#define BITCOIN_ADDRMAN_IMPL_H\n+\n+class AddrManImpl\n+{\n+public:\n+    AddrManImpl(std::vector<bool>&& asmap, bool deterministic, int32_t consistency_check_ratio);\n+\n+    ~AddrManImpl();\n+\n+    template <typename Stream>\n+    void Serialize(Stream& s_) const EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+\n+    template <typename Stream>\n+    void Unserialize(Stream& s_) EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+\n+    size_t size() const EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+\n+    bool Add(const std::vector<CAddress> &vAddr, const CNetAddr& source, int64_t nTimePenalty)\n+        EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+\n+    void Good(const CService &addr, int64_t nTime)\n+        EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+\n+    void Attempt(const CService &addr, bool fCountFailure, int64_t nTime)\n+        EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+\n+    void ResolveCollisions() EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+\n+    CAddrInfo SelectTriedCollision() EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+\n+    CAddrInfo Select(bool newOnly) const\n+        EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+\n+    std::vector<CAddress> GetAddr(size_t max_addresses, size_t max_pct, std::optional<Network> network) const\n+        EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+\n+    void Connected(const CService &addr, int64_t nTime)\n+        EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+\n+    void SetServices(const CService &addr, ServiceFlags nServices)\n+        EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+\n+    const std::vector<bool>& GetAsmap() const;\n+\n+    friend class CAddrManTest;\n+    friend class CAddrManDeterministic;\n+\n+private:\n+    //! A mutex to protect the inner data structures.\n+    mutable Mutex cs;\n+\n+    //! Source of random numbers for randomization in inner loops\n+    mutable FastRandomContext insecure_rand GUARDED_BY(cs);\n+\n+    //! secret key to randomize bucket select with\n+    uint256 nKey;\n+\n+    //! Serialization versions.\n+    enum Format : uint8_t {\n+        V0_HISTORICAL = 0,    //!< historic format, before commit e6b343d88\n+        V1_DETERMINISTIC = 1, //!< for pre-asmap files\n+        V2_ASMAP = 2,         //!< for files including asmap version\n+        V3_BIP155 = 3,        //!< same as V2_ASMAP plus addresses are in BIP155 format\n+    };\n+\n+    //! The maximum format this software knows it can unserialize. Also, we always serialize\n+    //! in this format.\n+    //! The format (first byte in the serialized stream) can be higher than this and\n+    //! still this software may be able to unserialize the file - if the second byte\n+    //! (see `lowest_compatible` in `Unserialize()`) is less or equal to this.\n+    static constexpr Format FILE_FORMAT = Format::V3_BIP155;\n+\n+    //! The initial value of a field that is incremented every time an incompatible format\n+    //! change is made (such that old software versions would not be able to parse and\n+    //! understand the new file format). This is 32 because we overtook the \"key size\"\n+    //! field which was 32 historically.\n+    //! @note Don't increment this. Increment `lowest_compatible` in `Serialize()` instead.\n+    static constexpr uint8_t INCOMPATIBILITY_BASE = 32;\n+\n+    //! last used nId\n+    int nIdCount GUARDED_BY(cs){0};\n+\n+    //! table with information about all nIds\n+    std::unordered_map<int, CAddrInfo> mapInfo GUARDED_BY(cs);\n+\n+    //! find an nId based on its network address\n+    std::unordered_map<CNetAddr, int, CNetAddrHash> mapAddr GUARDED_BY(cs);\n+\n+    //! randomly-ordered vector of all nIds\n+    //! This is mutable because it is unobservable outside the class, so any\n+    //! changes to it (even in const methods) are also unobservable.\n+    mutable std::vector<int> vRandom GUARDED_BY(cs);\n+\n+    // number of \"tried\" entries\n+    int nTried GUARDED_BY(cs){0};\n+\n+    //! list of \"tried\" buckets\n+    int vvTried[ADDRMAN_TRIED_BUCKET_COUNT][ADDRMAN_BUCKET_SIZE] GUARDED_BY(cs);\n+\n+    //! number of (unique) \"new\" entries\n+    int nNew GUARDED_BY(cs){0};\n+\n+    //! list of \"new\" buckets\n+    int vvNew[ADDRMAN_NEW_BUCKET_COUNT][ADDRMAN_BUCKET_SIZE] GUARDED_BY(cs);\n+\n+    //! last time Good was called (memory only). Initially set to 1 so that \"never\" is strictly worse.\n+    int64_t nLastGood GUARDED_BY(cs){1};\n+\n+    //! Holds addrs inserted into tried table that collide with existing entries. Test-before-evict discipline used to resolve these collisions.\n+    std::set<int> m_tried_collisions;\n+\n+    /** Perform consistency checks every m_consistency_check_ratio operations (if non-zero). */\n+    const int32_t m_consistency_check_ratio;\n+\n+    // Compressed IP->ASN mapping, loaded from a file when a node starts.\n+    // Should be always empty if no file was provided.\n+    // This mapping is then used for bucketing nodes in Addrman.\n+    //\n+    // If asmap is provided, nodes will be bucketed by\n+    // AS they belong to, in order to make impossible for a node\n+    // to connect to several nodes hosted in a single AS.\n+    // This is done in response to Erebus attack, but also to generally\n+    // diversify the connections every node creates,\n+    // especially useful when a large fraction of nodes\n+    // operate under a couple of cloud providers.\n+    //\n+    // If a new asmap was provided, the existing records\n+    // would be re-bucketed accordingly.\n+    const std::vector<bool> m_asmap;\n+\n+    //! Find an entry.\n+    CAddrInfo* Find(const CNetAddr& addr, int *pnId = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Create a new entry and add it to the internal data structures mapInfo, mapAddr and vRandom.\n+    CAddrInfo* Create(const CAddress &addr, const CNetAddr &addrSource, int *pnId = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Swap two elements in vRandom.\n+    void SwapRandom(unsigned int nRandomPos1, unsigned int nRandomPos2) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Delete an entry. It must not be in tried, and have refcount 0.\n+    void Delete(int nId) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Clear a position in a \"new\" table. This is the only place where entries are actually deleted.\n+    void ClearNew(int nUBucket, int nUBucketPos) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Move an entry from the \"new\" table(s) to the \"tried\" table\n+    void MakeTried(CAddrInfo& info, int nId) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Mark an entry \"good\", possibly moving it from \"new\" to \"tried\".\n+    void Good_(const CService &addr, bool test_before_evict, int64_t time) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Add an entry to the \"new\" table.\n+    bool Add_(const CAddress &addr, const CNetAddr& source, int64_t nTimePenalty) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Mark an entry as attempted to connect.\n+    void Attempt_(const CService &addr, bool fCountFailure, int64_t nTime) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Select an address to connect to, if newOnly is set to true, only the new table is selected from.\n+    CAddrInfo Select_(bool newOnly) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    /**\n+     * Return all or many randomly selected addresses, optionally by network.\n+     *\n+     * @param[out] vAddr         Vector of randomly selected addresses from vRandom.\n+     * @param[in] max_addresses  Maximum number of addresses to return (0 = all).\n+     * @param[in] max_pct        Maximum percentage of addresses to return (0 = all).\n+     * @param[in] network        Select only addresses of this network (nullopt = all).\n+     */\n+    void GetAddr_(std::vector<CAddress>& vAddr, size_t max_addresses, size_t max_pct, std::optional<Network> network) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    /** We have successfully connected to this peer. Calling this function\n+     *  updates the CAddress's nTime, which is used in our IsTerrible()\n+     *  decisions and gossiped to peers. Callers should be careful that updating\n+     *  this information doesn't leak topology information to network spies.\n+     *\n+     *  net_processing calls this function when it *disconnects* from a peer to\n+     *  not leak information about currently connected peers.\n+     *\n+     * @param[in]   addr     The address of the peer we were connected to\n+     * @param[in]   nTime    The time that we were last connected to this peer\n+     */\n+    void Connected_(const CService& addr, int64_t nTime) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Update an entry's service bits.\n+    void SetServices_(const CService &addr, ServiceFlags nServices) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! See if any to-be-evicted tried table entries have been tested and if so resolve the collisions.\n+    void ResolveCollisions_() EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Return a random to-be-evicted tried table address.\n+    CAddrInfo SelectTriedCollision_() EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Consistency check, taking into account m_consistency_check_ratio. Will std::abort if an inconsistency is detected.\n+    void Check() const EXCLUSIVE_LOCKS_REQUIRED(cs);\n+\n+    //! Perform consistency check, regardless of m_consistency_check_ratio.\n+    //! @returns an error code or zero.\n+    int ForceCheckAddrman() const EXCLUSIVE_LOCKS_REQUIRED(cs);\n+};\n+\n+#endif // BITCOIN_ADDRMAN_IMPL_H"
      },
      {
        "sha": "41c298e036449896047441bf4df7d53860da6f00",
        "filename": "src/test/addrman_tests.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 9,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8af5b54f973e11c847345418d8631bc301b96130/src/test/addrman_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8af5b54f973e11c847345418d8631bc301b96130/src/test/addrman_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/addrman_tests.cpp?ref=8af5b54f973e11c847345418d8631bc301b96130",
        "patch": "@@ -4,6 +4,7 @@\n \n #include <addrdb.h>\n #include <addrman.h>\n+#include <addrman_impl.h>\n #include <chainparams.h>\n #include <clientversion.h>\n #include <hash.h>\n@@ -90,30 +91,30 @@ class CAddrManTest : public CAddrMan\n \n     CAddrInfo* Find(const CNetAddr& addr, int* pnId = nullptr)\n     {\n-        LOCK(cs);\n-        return CAddrMan::Find(addr, pnId);\n+        LOCK(m_impl->cs);\n+        return m_impl->Find(addr, pnId);\n     }\n \n     CAddrInfo* Create(const CAddress& addr, const CNetAddr& addrSource, int* pnId = nullptr)\n     {\n-        LOCK(cs);\n-        return CAddrMan::Create(addr, addrSource, pnId);\n+        LOCK(m_impl->cs);\n+        return m_impl->Create(addr, addrSource, pnId);\n     }\n \n     void Delete(int nId)\n     {\n-        LOCK(cs);\n-        CAddrMan::Delete(nId);\n+        LOCK(m_impl->cs);\n+        m_impl->Delete(nId);\n     }\n \n     // Used to test deserialization\n     std::pair<int, int> GetBucketAndEntry(const CAddress& addr)\n     {\n-        LOCK(cs);\n-        int nId = mapAddr[addr];\n+        LOCK(m_impl->cs);\n+        int nId = m_impl->mapAddr[addr];\n         for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; ++bucket) {\n             for (int entry = 0; entry < ADDRMAN_BUCKET_SIZE; ++entry) {\n-                if (nId == vvNew[bucket][entry]) {\n+                if (nId == m_impl->vvNew[bucket][entry]) {\n                     return std::pair<int, int>(bucket, entry);\n                 }\n             }"
      },
      {
        "sha": "6625b69b142125eb9b8e4e50d0766f8217ecea66",
        "filename": "src/test/fuzz/addrman.cpp",
        "status": "modified",
        "additions": 23,
        "deletions": 22,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8af5b54f973e11c847345418d8631bc301b96130/src/test/fuzz/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8af5b54f973e11c847345418d8631bc301b96130/src/test/fuzz/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/addrman.cpp?ref=8af5b54f973e11c847345418d8631bc301b96130",
        "patch": "@@ -4,6 +4,7 @@\n \n #include <addrdb.h>\n #include <addrman.h>\n+#include <addrman_impl.h>\n #include <chainparams.h>\n #include <merkleblock.h>\n #include <test/fuzz/FuzzedDataProvider.h>\n@@ -43,13 +44,13 @@ class CAddrManDeterministic : public CAddrMan\n         : CAddrMan(std::move(asmap), /* deterministic */ true, /* consistency_check_ratio */ 0)\n         , m_fuzzed_data_provider(fuzzed_data_provider)\n     {\n-        WITH_LOCK(cs, insecure_rand = FastRandomContext{ConsumeUInt256(fuzzed_data_provider)});\n+        WITH_LOCK(m_impl->cs, m_impl->insecure_rand = FastRandomContext{ConsumeUInt256(fuzzed_data_provider)});\n     }\n \n     /**\n      * Generate a random address. Always returns a valid address.\n      */\n-    CNetAddr RandAddr() EXCLUSIVE_LOCKS_REQUIRED(cs)\n+    CNetAddr RandAddr() EXCLUSIVE_LOCKS_REQUIRED(m_impl->cs)\n     {\n         CNetAddr addr;\n         if (m_fuzzed_data_provider.remaining_bytes() > 1 && m_fuzzed_data_provider.ConsumeBool()) {\n@@ -61,15 +62,15 @@ class CAddrManDeterministic : public CAddrMan\n                                                                    {4, ADDR_TORV3_SIZE},\n                                                                    {5, ADDR_I2P_SIZE},\n                                                                    {6, ADDR_CJDNS_SIZE}};\n-            uint8_t net = insecure_rand.randrange(5) + 1; // [1..5]\n+            uint8_t net = m_impl->insecure_rand.randrange(5) + 1; // [1..5]\n             if (net == 3) {\n                 net = 6;\n             }\n \n             CDataStream s(SER_NETWORK, PROTOCOL_VERSION | ADDRV2_FORMAT);\n \n             s << net;\n-            s << insecure_rand.randbytes(net_len_map.at(net));\n+            s << m_impl->insecure_rand.randbytes(net_len_map.at(net));\n \n             s >> addr;\n         }\n@@ -89,7 +90,7 @@ class CAddrManDeterministic : public CAddrMan\n      */\n     void Fill()\n     {\n-        LOCK(cs);\n+        LOCK(m_impl->cs);\n \n         // Add some of the addresses directly to the \"tried\" table.\n \n@@ -102,20 +103,20 @@ class CAddrManDeterministic : public CAddrMan\n         // the latter is exhausted it just returns 0.\n         for (size_t i = 0; i < num_sources; ++i) {\n             const auto source = RandAddr();\n-            const size_t num_addresses = insecure_rand.randrange(500) + 1; // [1..500]\n+            const size_t num_addresses = m_impl->insecure_rand.randrange(500) + 1; // [1..500]\n \n             for (size_t j = 0; j < num_addresses; ++j) {\n                 const auto addr = CAddress{CService{RandAddr(), 8333}, NODE_NETWORK};\n-                const auto time_penalty = insecure_rand.randrange(100000001);\n-                Add_(addr, source, time_penalty);\n+                const auto time_penalty = m_impl->insecure_rand.randrange(100000001);\n+                m_impl->Add_(addr, source, time_penalty);\n \n-                if (n > 0 && mapInfo.size() % n == 0) {\n-                    Good_(addr, false, GetTime());\n+                if (n > 0 && m_impl->mapInfo.size() % n == 0) {\n+                    m_impl->Good_(addr, false, GetTime());\n                 }\n \n                 // Add 10% of the addresses from more than one source.\n-                if (insecure_rand.randrange(10) == 0 && prev_source.IsValid()) {\n-                    Add_(addr, prev_source, time_penalty);\n+                if (m_impl->insecure_rand.randrange(10) == 0 && prev_source.IsValid()) {\n+                    m_impl->Add_({addr}, prev_source, time_penalty);\n                 }\n             }\n             prev_source = source;\n@@ -131,10 +132,10 @@ class CAddrManDeterministic : public CAddrMan\n      */\n     bool operator==(const CAddrManDeterministic& other)\n     {\n-        LOCK2(cs, other.cs);\n+        LOCK2(m_impl->cs, other.m_impl->cs);\n \n-        if (mapInfo.size() != other.mapInfo.size() || nNew != other.nNew ||\n-            nTried != other.nTried) {\n+        if (m_impl->mapInfo.size() != other.m_impl->mapInfo.size() || m_impl->nNew != other.m_impl->nNew ||\n+            m_impl->nTried != other.m_impl->nTried) {\n             return false;\n         }\n \n@@ -160,38 +161,38 @@ class CAddrManDeterministic : public CAddrMan\n \n         using Addresses = std::unordered_set<CAddrInfo, CAddrInfoHasher, CAddrInfoEq>;\n \n-        const size_t num_addresses{mapInfo.size()};\n+        const size_t num_addresses{m_impl->mapInfo.size()};\n \n         Addresses addresses{num_addresses, addrinfo_hasher, addrinfo_eq};\n-        for (const auto& [id, addr] : mapInfo) {\n+        for (const auto& [id, addr] : m_impl->mapInfo) {\n             addresses.insert(addr);\n         }\n \n         Addresses other_addresses{num_addresses, addrinfo_hasher, addrinfo_eq};\n-        for (const auto& [id, addr] : other.mapInfo) {\n+        for (const auto& [id, addr] : other.m_impl->mapInfo) {\n             other_addresses.insert(addr);\n         }\n \n         if (addresses != other_addresses) {\n             return false;\n         }\n \n-        auto IdsReferToSameAddress = [&](int id, int other_id) EXCLUSIVE_LOCKS_REQUIRED(cs, other.cs) {\n+        auto IdsReferToSameAddress = [&](int id, int other_id) EXCLUSIVE_LOCKS_REQUIRED(m_impl->cs, other.m_impl->cs) {\n             if (id == -1 && other_id == -1) {\n                 return true;\n             }\n             if ((id == -1 && other_id != -1) || (id != -1 && other_id == -1)) {\n                 return false;\n             }\n-            return mapInfo.at(id) == other.mapInfo.at(other_id);\n+            return m_impl->mapInfo.at(id) == other.m_impl->mapInfo.at(other_id);\n         };\n \n         // Check that `vvNew` contains the same addresses as `other.vvNew`. Notice - `vvNew[i][j]`\n         // contains just an id and the address is to be found in `mapInfo.at(id)`. The ids\n         // themselves may differ between `vvNew` and `other.vvNew`.\n         for (size_t i = 0; i < ADDRMAN_NEW_BUCKET_COUNT; ++i) {\n             for (size_t j = 0; j < ADDRMAN_BUCKET_SIZE; ++j) {\n-                if (!IdsReferToSameAddress(vvNew[i][j], other.vvNew[i][j])) {\n+                if (!IdsReferToSameAddress(m_impl->vvNew[i][j], other.m_impl->vvNew[i][j])) {\n                     return false;\n                 }\n             }\n@@ -200,7 +201,7 @@ class CAddrManDeterministic : public CAddrMan\n         // Same for `vvTried`.\n         for (size_t i = 0; i < ADDRMAN_TRIED_BUCKET_COUNT; ++i) {\n             for (size_t j = 0; j < ADDRMAN_BUCKET_SIZE; ++j) {\n-                if (!IdsReferToSameAddress(vvTried[i][j], other.vvTried[i][j])) {\n+                if (!IdsReferToSameAddress(m_impl->vvTried[i][j], other.m_impl->vvTried[i][j])) {\n                     return false;\n                 }\n             }"
      }
    ]
  },
  {
    "sha": "7cba9d56185b9325ce41d79364e448462fff0f6a",
    "node_id": "C_kwDOABII59oAKDdjYmE5ZDU2MTg1YjkzMjVjZTQxZDc5MzY0ZTQ0ODQ2MmZmZjBmNmE",
    "commit": {
      "author": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2021-08-25T22:40:59Z"
      },
      "committer": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2021-09-28T23:02:34Z"
      },
      "message": "[net, addrman] Remove external dependencies on CAddrInfo objects\n\nCAddrInfo objects are an implementation detail of how AddrMan manages and adds\nmetadata to different records. Encapsulate this logic by updating Select &\nSelectTriedCollision to return the additional info that the callers need.",
      "tree": {
        "sha": "810167c86f44ed8d730232ec77544668b3bd6c85",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/810167c86f44ed8d730232ec77544668b3bd6c85"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7cba9d56185b9325ce41d79364e448462fff0f6a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7cba9d56185b9325ce41d79364e448462fff0f6a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7cba9d56185b9325ce41d79364e448462fff0f6a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7cba9d56185b9325ce41d79364e448462fff0f6a/comments",
    "author": {
      "login": "amitiuttarwar",
      "id": 1500952,
      "node_id": "MDQ6VXNlcjE1MDA5NTI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/amitiuttarwar",
      "html_url": "https://github.com/amitiuttarwar",
      "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
      "following_url": "https://api.github.com/users/amitiuttarwar/following{/other_user}",
      "gists_url": "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
      "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
      "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
      "events_url": "https://api.github.com/users/amitiuttarwar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "amitiuttarwar",
      "id": 1500952,
      "node_id": "MDQ6VXNlcjE1MDA5NTI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/amitiuttarwar",
      "html_url": "https://github.com/amitiuttarwar",
      "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
      "following_url": "https://api.github.com/users/amitiuttarwar/following{/other_user}",
      "gists_url": "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
      "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
      "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
      "events_url": "https://api.github.com/users/amitiuttarwar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8af5b54f973e11c847345418d8631bc301b96130",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8af5b54f973e11c847345418d8631bc301b96130",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8af5b54f973e11c847345418d8631bc301b96130"
      }
    ],
    "stats": {
      "total": 130,
      "additions": 70,
      "deletions": 60
    },
    "files": [
      {
        "sha": "324bab7292cdba466c1ec79d42f95ac697a4f63c",
        "filename": "src/addrman.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 21,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7cba9d56185b9325ce41d79364e448462fff0f6a/src/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7cba9d56185b9325ce41d79364e448462fff0f6a/src/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.cpp?ref=7cba9d56185b9325ce41d79364e448462fff0f6a",
        "patch": "@@ -694,15 +694,13 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, int64_t nTi\n     }\n }\n \n-CAddrInfo AddrManImpl::Select_(bool newOnly) const\n+std::pair<CAddress, int64_t> AddrManImpl::Select_(bool newOnly) const\n {\n     AssertLockHeld(cs);\n \n-    if (vRandom.empty())\n-        return CAddrInfo();\n+    if (vRandom.empty()) return {};\n \n-    if (newOnly && nNew == 0)\n-        return CAddrInfo();\n+    if (newOnly && nNew == 0) return {};\n \n     // Use a 50% chance for choosing between tried and new table entries.\n     if (!newOnly &&\n@@ -720,8 +718,9 @@ CAddrInfo AddrManImpl::Select_(bool newOnly) const\n             const auto it_found{mapInfo.find(nId)};\n             assert(it_found != mapInfo.end());\n             const CAddrInfo& info{it_found->second};\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30))\n-                return info;\n+            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n+                return {info, info.nLastTry};\n+            }\n             fChanceFactor *= 1.2;\n         }\n     } else {\n@@ -738,8 +737,9 @@ CAddrInfo AddrManImpl::Select_(bool newOnly) const\n             const auto it_found{mapInfo.find(nId)};\n             assert(it_found != mapInfo.end());\n             const CAddrInfo& info{it_found->second};\n-            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30))\n-                return info;\n+            if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n+                return {info, info.nLastTry};\n+            }\n             fChanceFactor *= 1.2;\n         }\n     }\n@@ -883,11 +883,11 @@ void AddrManImpl::ResolveCollisions_()\n     }\n }\n \n-CAddrInfo AddrManImpl::SelectTriedCollision_()\n+std::pair<CAddress, int64_t> AddrManImpl::SelectTriedCollision_()\n {\n     AssertLockHeld(cs);\n \n-    if (m_tried_collisions.size() == 0) return CAddrInfo();\n+    if (m_tried_collisions.size() == 0) return {};\n \n     std::set<int>::iterator it = m_tried_collisions.begin();\n \n@@ -898,7 +898,7 @@ CAddrInfo AddrManImpl::SelectTriedCollision_()\n     // If id_new not found in mapInfo remove it from m_tried_collisions\n     if (mapInfo.count(id_new) != 1) {\n         m_tried_collisions.erase(it);\n-        return CAddrInfo();\n+        return {};\n     }\n \n     const CAddrInfo& newInfo = mapInfo[id_new];\n@@ -907,9 +907,8 @@ CAddrInfo AddrManImpl::SelectTriedCollision_()\n     int tried_bucket = newInfo.GetTriedBucket(nKey, m_asmap);\n     int tried_bucket_pos = newInfo.GetBucketPosition(nKey, false, tried_bucket);\n \n-    int id_old = vvTried[tried_bucket][tried_bucket_pos];\n-\n-    return mapInfo[id_old];\n+    const CAddrInfo& info_old = mapInfo[vvTried[tried_bucket][tried_bucket_pos]];\n+    return {info_old, info_old.nLastTry};\n }\n \n void AddrManImpl::Check() const\n@@ -1059,20 +1058,20 @@ void AddrManImpl::ResolveCollisions()\n     Check();\n }\n \n-CAddrInfo AddrManImpl::SelectTriedCollision()\n+std::pair<CAddress, int64_t> AddrManImpl::SelectTriedCollision()\n {\n     LOCK(cs);\n     Check();\n-    const CAddrInfo ret = SelectTriedCollision_();\n+    const auto ret = SelectTriedCollision_();\n     Check();\n     return ret;\n }\n \n-CAddrInfo AddrManImpl::Select(bool newOnly) const\n+std::pair<CAddress, int64_t> AddrManImpl::Select(bool newOnly) const\n {\n     LOCK(cs);\n     Check();\n-    const CAddrInfo addrRet = Select_(newOnly);\n+    const auto addrRet = Select_(newOnly);\n     Check();\n     return addrRet;\n }\n@@ -1159,12 +1158,12 @@ void CAddrMan::ResolveCollisions()\n     m_impl->ResolveCollisions();\n }\n \n-CAddrInfo CAddrMan::SelectTriedCollision()\n+std::pair<CAddress, int64_t> CAddrMan::SelectTriedCollision()\n {\n     return m_impl->SelectTriedCollision();\n }\n \n-CAddrInfo CAddrMan::Select(bool newOnly) const\n+std::pair<CAddress, int64_t> CAddrMan::Select(bool newOnly) const\n {\n     return m_impl->Select(newOnly);\n }"
      },
      {
        "sha": "d176d0a42c180df0fc656e68644573f90ae48286",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 13,
        "deletions": 3,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7cba9d56185b9325ce41d79364e448462fff0f6a/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7cba9d56185b9325ce41d79364e448462fff0f6a/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=7cba9d56185b9325ce41d79364e448462fff0f6a",
        "patch": "@@ -171,13 +171,23 @@ class CAddrMan\n     //! See if any to-be-evicted tried table entries have been tested and if so resolve the collisions.\n     void ResolveCollisions();\n \n-    //! Randomly select an address in tried that another address is attempting to evict.\n-    CAddrInfo SelectTriedCollision();\n+    /**\n+     * Randomly select an address in the tried table that another address is\n+     * attempting to evict.\n+     *\n+     * @return CAddress The record for the selected tried peer.\n+     *         int64_t  The last time we attempted to connect to that peer.\n+     */\n+    std::pair<CAddress, int64_t> SelectTriedCollision();\n \n     /**\n      * Choose an address to connect to.\n+     *\n+     * @param[in] newOnly  Whether to only select addresses from the new table.\n+     * @return    CAddress The record for the selected peer.\n+     *            int64_t  The last time we attempted to connect to that peer.\n      */\n-    CAddrInfo Select(bool newOnly = false) const;\n+    std::pair<CAddress, int64_t> Select(bool newOnly = false) const;\n \n     /**\n      * Return all or many randomly selected addresses, optionally by network."
      },
      {
        "sha": "6752d5b81d14a24b5613810f29a7c1d308961192",
        "filename": "src/addrman_impl.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7cba9d56185b9325ce41d79364e448462fff0f6a/src/addrman_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7cba9d56185b9325ce41d79364e448462fff0f6a/src/addrman_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman_impl.h?ref=7cba9d56185b9325ce41d79364e448462fff0f6a",
        "patch": "@@ -31,9 +31,9 @@ class AddrManImpl\n \n     void ResolveCollisions() EXCLUSIVE_LOCKS_REQUIRED(!cs);\n \n-    CAddrInfo SelectTriedCollision() EXCLUSIVE_LOCKS_REQUIRED(!cs);\n+    std::pair<CAddress, int64_t> SelectTriedCollision() EXCLUSIVE_LOCKS_REQUIRED(!cs);\n \n-    CAddrInfo Select(bool newOnly) const\n+    std::pair<CAddress, int64_t>  Select(bool newOnly) const\n         EXCLUSIVE_LOCKS_REQUIRED(!cs);\n \n     std::vector<CAddress> GetAddr(size_t max_addresses, size_t max_pct, std::optional<Network> network) const\n@@ -161,7 +161,7 @@ class AddrManImpl\n     void Attempt_(const CService &addr, bool fCountFailure, int64_t nTime) EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n     //! Select an address to connect to, if newOnly is set to true, only the new table is selected from.\n-    CAddrInfo Select_(bool newOnly) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n+    std::pair<CAddress, int64_t> Select_(bool newOnly) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n     /**\n      * Return all or many randomly selected addresses, optionally by network.\n@@ -193,7 +193,7 @@ class AddrManImpl\n     void ResolveCollisions_() EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n     //! Return a random to-be-evicted tried table address.\n-    CAddrInfo SelectTriedCollision_() EXCLUSIVE_LOCKS_REQUIRED(cs);\n+    std::pair<CAddress, int64_t> SelectTriedCollision_() EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n     //! Consistency check, taking into account m_consistency_check_ratio. Will std::abort if an inconsistency is detected.\n     void Check() const EXCLUSIVE_LOCKS_REQUIRED(cs);"
      },
      {
        "sha": "b4c2e35f42222bca0a5fd7b8c873a8d031f9d2b4",
        "filename": "src/bench/addrman.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7cba9d56185b9325ce41d79364e448462fff0f6a/src/bench/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7cba9d56185b9325ce41d79364e448462fff0f6a/src/bench/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/addrman.cpp?ref=7cba9d56185b9325ce41d79364e448462fff0f6a",
        "patch": "@@ -87,7 +87,7 @@ static void AddrManSelect(benchmark::Bench& bench)\n \n     bench.run([&] {\n         const auto& address = addrman.Select();\n-        assert(address.GetPort() > 0);\n+        assert(address.first.GetPort() > 0);\n     });\n }\n "
      },
      {
        "sha": "df3b88725e430c23e59eb978be1494f3ca33817a",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 6,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7cba9d56185b9325ce41d79364e448462fff0f6a/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7cba9d56185b9325ce41d79364e448462fff0f6a/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=7cba9d56185b9325ce41d79364e448462fff0f6a",
        "patch": "@@ -2006,17 +2006,18 @@ void CConnman::ThreadOpenConnections(const std::vector<std::string> connect)\n             if (nTries > 100)\n                 break;\n \n-            CAddrInfo addr;\n+            CAddress addr;\n+            int64_t addr_last_try{0};\n \n             if (fFeeler) {\n                 // First, try to get a tried table collision address. This returns\n                 // an empty (invalid) address if there are no collisions to try.\n-                addr = addrman.SelectTriedCollision();\n+                std::tie(addr, addr_last_try) = addrman.SelectTriedCollision();\n \n                 if (!addr.IsValid()) {\n                     // No tried table collisions. Select a new table address\n                     // for our feeler.\n-                    addr = addrman.Select(true);\n+                    std::tie(addr, addr_last_try) = addrman.Select(true);\n                 } else if (AlreadyConnectedToAddress(addr)) {\n                     // If test-before-evict logic would have us connect to a\n                     // peer that we're already connected to, just mark that\n@@ -2025,11 +2026,11 @@ void CConnman::ThreadOpenConnections(const std::vector<std::string> connect)\n                     // a currently-connected peer.\n                     addrman.Good(addr);\n                     // Select a new table address for our feeler instead.\n-                    addr = addrman.Select(true);\n+                    std::tie(addr, addr_last_try) = addrman.Select(true);\n                 }\n             } else {\n                 // Not a feeler\n-                addr = addrman.Select();\n+                std::tie(addr, addr_last_try) = addrman.Select();\n             }\n \n             // Require outbound connections, other than feelers, to be to distinct network groups\n@@ -2046,7 +2047,7 @@ void CConnman::ThreadOpenConnections(const std::vector<std::string> connect)\n                 continue;\n \n             // only consider very recently tried nodes after 30 failed attempts\n-            if (nANow - addr.nLastTry < 600 && nTries < 30)\n+            if (nANow - addr_last_try < 600 && nTries < 30)\n                 continue;\n \n             // for non-feelers, require all the services we'll want,"
      },
      {
        "sha": "022f60a8ede05b1543000815a16faaa505a7c4a0",
        "filename": "src/test/addrman_tests.cpp",
        "status": "modified",
        "additions": 25,
        "deletions": 25,
        "changes": 50,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7cba9d56185b9325ce41d79364e448462fff0f6a/src/test/addrman_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7cba9d56185b9325ce41d79364e448462fff0f6a/src/test/addrman_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/addrman_tests.cpp?ref=7cba9d56185b9325ce41d79364e448462fff0f6a",
        "patch": "@@ -172,14 +172,14 @@ BOOST_AUTO_TEST_CASE(addrman_simple)\n \n     // Test: Does Addrman respond correctly when empty.\n     BOOST_CHECK_EQUAL(addrman->size(), 0U);\n-    CAddrInfo addr_null = addrman->Select();\n+    auto addr_null = addrman->Select().first;\n     BOOST_CHECK_EQUAL(addr_null.ToString(), \"[::]:0\");\n \n     // Test: Does Addrman::Add work as expected.\n     CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n     BOOST_CHECK(addrman->Add({CAddress(addr1, NODE_NONE)}, source));\n     BOOST_CHECK_EQUAL(addrman->size(), 1U);\n-    CAddrInfo addr_ret1 = addrman->Select();\n+    auto addr_ret1 = addrman->Select().first;\n     BOOST_CHECK_EQUAL(addr_ret1.ToString(), \"250.1.1.1:8333\");\n \n     // Test: Does IP address deduplication work correctly.\n@@ -224,15 +224,15 @@ BOOST_AUTO_TEST_CASE(addrman_ports)\n     CService addr1_port = ResolveService(\"250.1.1.1\", 8334);\n     BOOST_CHECK(!addrman.Add({CAddress(addr1_port, NODE_NONE)}, source));\n     BOOST_CHECK_EQUAL(addrman.size(), 1U);\n-    CAddrInfo addr_ret2 = addrman.Select();\n+    auto addr_ret2 = addrman.Select().first;\n     BOOST_CHECK_EQUAL(addr_ret2.ToString(), \"250.1.1.1:8333\");\n \n     // Test: Add same IP but diff port to tried table, it doesn't get added.\n     //  Perhaps this is not ideal behavior but it is the current behavior.\n     addrman.Good(CAddress(addr1_port, NODE_NONE));\n     BOOST_CHECK_EQUAL(addrman.size(), 1U);\n     bool newOnly = true;\n-    CAddrInfo addr_ret3 = addrman.Select(newOnly);\n+    auto addr_ret3 = addrman.Select(newOnly).first;\n     BOOST_CHECK_EQUAL(addr_ret3.ToString(), \"250.1.1.1:8333\");\n }\n \n@@ -249,16 +249,16 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     BOOST_CHECK_EQUAL(addrman.size(), 1U);\n \n     bool newOnly = true;\n-    CAddrInfo addr_ret1 = addrman.Select(newOnly);\n+    auto addr_ret1 = addrman.Select(newOnly).first;\n     BOOST_CHECK_EQUAL(addr_ret1.ToString(), \"250.1.1.1:8333\");\n \n     // Test: move addr to tried, select from new expected nothing returned.\n     addrman.Good(CAddress(addr1, NODE_NONE));\n     BOOST_CHECK_EQUAL(addrman.size(), 1U);\n-    CAddrInfo addr_ret2 = addrman.Select(newOnly);\n+    auto addr_ret2 = addrman.Select(newOnly).first;\n     BOOST_CHECK_EQUAL(addr_ret2.ToString(), \"[::]:0\");\n \n-    CAddrInfo addr_ret3 = addrman.Select();\n+    auto addr_ret3 = addrman.Select().first;\n     BOOST_CHECK_EQUAL(addr_ret3.ToString(), \"250.1.1.1:8333\");\n \n     BOOST_CHECK_EQUAL(addrman.size(), 1U);\n@@ -291,7 +291,7 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     // Test: Select pulls from new and tried regardless of port number.\n     std::set<uint16_t> ports;\n     for (int i = 0; i < 20; ++i) {\n-        ports.insert(addrman.Select().GetPort());\n+        ports.insert(addrman.Select().first.GetPort());\n     }\n     BOOST_CHECK_EQUAL(ports.size(), 3U);\n }\n@@ -869,7 +869,7 @@ BOOST_AUTO_TEST_CASE(addrman_selecttriedcollision)\n     BOOST_CHECK(addrman.size() == 0);\n \n     // Empty addrman should return blank addrman info.\n-    BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+    BOOST_CHECK(addrman.SelectTriedCollision().first.ToString() == \"[::]:0\");\n \n     // Add twenty two addresses.\n     CNetAddr source = ResolveIP(\"252.2.2.2\");\n@@ -880,7 +880,7 @@ BOOST_AUTO_TEST_CASE(addrman_selecttriedcollision)\n \n         // No collisions yet.\n         BOOST_CHECK(addrman.size() == i);\n-        BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+        BOOST_CHECK(addrman.SelectTriedCollision().first.ToString() == \"[::]:0\");\n     }\n \n     // Ensure Good handles duplicates well.\n@@ -889,7 +889,7 @@ BOOST_AUTO_TEST_CASE(addrman_selecttriedcollision)\n         addrman.Good(addr);\n \n         BOOST_CHECK(addrman.size() == 22);\n-        BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+        BOOST_CHECK(addrman.SelectTriedCollision().first.ToString() == \"[::]:0\");\n     }\n \n }\n@@ -907,7 +907,7 @@ BOOST_AUTO_TEST_CASE(addrman_noevict)\n \n         // No collision yet.\n         BOOST_CHECK(addrman.size() == i);\n-        BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+        BOOST_CHECK(addrman.SelectTriedCollision().first.ToString() == \"[::]:0\");\n     }\n \n     // Collision between 36 and 19.\n@@ -916,11 +916,11 @@ BOOST_AUTO_TEST_CASE(addrman_noevict)\n     addrman.Good(addr36);\n \n     BOOST_CHECK(addrman.size() == 36);\n-    BOOST_CHECK_EQUAL(addrman.SelectTriedCollision().ToString(), \"250.1.1.19:0\");\n+    BOOST_CHECK_EQUAL(addrman.SelectTriedCollision().first.ToString(), \"250.1.1.19:0\");\n \n     // 36 should be discarded and 19 not evicted.\n     addrman.ResolveCollisions();\n-    BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+    BOOST_CHECK(addrman.SelectTriedCollision().first.ToString() == \"[::]:0\");\n \n     // Lets create two collisions.\n     for (unsigned int i = 37; i < 59; i++) {\n@@ -929,7 +929,7 @@ BOOST_AUTO_TEST_CASE(addrman_noevict)\n         addrman.Good(addr);\n \n         BOOST_CHECK(addrman.size() == i);\n-        BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+        BOOST_CHECK(addrman.SelectTriedCollision().first.ToString() == \"[::]:0\");\n     }\n \n     // Cause a collision.\n@@ -938,16 +938,16 @@ BOOST_AUTO_TEST_CASE(addrman_noevict)\n     addrman.Good(addr59);\n     BOOST_CHECK(addrman.size() == 59);\n \n-    BOOST_CHECK_EQUAL(addrman.SelectTriedCollision().ToString(), \"250.1.1.10:0\");\n+    BOOST_CHECK_EQUAL(addrman.SelectTriedCollision().first.ToString(), \"250.1.1.10:0\");\n \n     // Cause a second collision.\n     BOOST_CHECK(!addrman.Add({CAddress(addr36, NODE_NONE)}, source));\n     addrman.Good(addr36);\n     BOOST_CHECK(addrman.size() == 59);\n \n-    BOOST_CHECK(addrman.SelectTriedCollision().ToString() != \"[::]:0\");\n+    BOOST_CHECK(addrman.SelectTriedCollision().first.ToString() != \"[::]:0\");\n     addrman.ResolveCollisions();\n-    BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+    BOOST_CHECK(addrman.SelectTriedCollision().first.ToString() == \"[::]:0\");\n }\n \n BOOST_AUTO_TEST_CASE(addrman_evictionworks)\n@@ -957,7 +957,7 @@ BOOST_AUTO_TEST_CASE(addrman_evictionworks)\n     BOOST_CHECK(addrman.size() == 0);\n \n     // Empty addrman should return blank addrman info.\n-    BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+    BOOST_CHECK(addrman.SelectTriedCollision().first.ToString() == \"[::]:0\");\n \n     // Add 35 addresses\n     CNetAddr source = ResolveIP(\"252.2.2.2\");\n@@ -968,7 +968,7 @@ BOOST_AUTO_TEST_CASE(addrman_evictionworks)\n \n         // No collision yet.\n         BOOST_CHECK(addrman.size() == i);\n-        BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+        BOOST_CHECK(addrman.SelectTriedCollision().first.ToString() == \"[::]:0\");\n     }\n \n     // Collision between 36 and 19.\n@@ -977,31 +977,31 @@ BOOST_AUTO_TEST_CASE(addrman_evictionworks)\n     addrman.Good(addr);\n \n     BOOST_CHECK_EQUAL(addrman.size(), 36);\n-    CAddrInfo info = addrman.SelectTriedCollision();\n+    auto info = addrman.SelectTriedCollision().first;\n     BOOST_CHECK_EQUAL(info.ToString(), \"250.1.1.19:0\");\n \n     // Ensure test of address fails, so that it is evicted.\n     addrman.SimConnFail(info);\n \n     // Should swap 36 for 19.\n     addrman.ResolveCollisions();\n-    BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+    BOOST_CHECK(addrman.SelectTriedCollision().first.ToString() == \"[::]:0\");\n \n     // If 36 was swapped for 19, then this should cause no collisions.\n     BOOST_CHECK(!addrman.Add({CAddress(addr, NODE_NONE)}, source));\n     addrman.Good(addr);\n \n-    BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+    BOOST_CHECK(addrman.SelectTriedCollision().first.ToString() == \"[::]:0\");\n \n     // If we insert 19 it should collide with 36\n     CService addr19 = ResolveService(\"250.1.1.19\");\n     BOOST_CHECK(!addrman.Add({CAddress(addr19, NODE_NONE)}, source));\n     addrman.Good(addr19);\n \n-    BOOST_CHECK_EQUAL(addrman.SelectTriedCollision().ToString(), \"250.1.1.36:0\");\n+    BOOST_CHECK_EQUAL(addrman.SelectTriedCollision().first.ToString(), \"250.1.1.36:0\");\n \n     addrman.ResolveCollisions();\n-    BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n+    BOOST_CHECK(addrman.SelectTriedCollision().first.ToString() == \"[::]:0\");\n }\n \n BOOST_AUTO_TEST_CASE(load_addrman)"
      }
    ]
  },
  {
    "sha": "e3f1ea659c9eb1e8be4579923d6acaaab148c2ef",
    "node_id": "C_kwDOABII59oAKGUzZjFlYTY1OWM5ZWIxZThiZTQ1Nzk5MjNkNmFjYWFhYjE0OGMyZWY",
    "commit": {
      "author": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2021-09-04T00:26:56Z"
      },
      "committer": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2021-09-28T23:02:34Z"
      },
      "message": "[move-only] Move CAddrInfo to test-only header file\n\nNow that no bitcoind callers require knowledge of the CAddrInfo object, it can\nbe moved into the test-only header file.\n\nReview hint: use git diff --color-moved=dimmed-zebra\n--color-moved-ws=ignore-all-space",
      "tree": {
        "sha": "1dfbc09de7854541e6c2a38071ffa4551429b003",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1dfbc09de7854541e6c2a38071ffa4551429b003"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e3f1ea659c9eb1e8be4579923d6acaaab148c2ef",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e3f1ea659c9eb1e8be4579923d6acaaab148c2ef",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e3f1ea659c9eb1e8be4579923d6acaaab148c2ef",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e3f1ea659c9eb1e8be4579923d6acaaab148c2ef/comments",
    "author": {
      "login": "amitiuttarwar",
      "id": 1500952,
      "node_id": "MDQ6VXNlcjE1MDA5NTI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/amitiuttarwar",
      "html_url": "https://github.com/amitiuttarwar",
      "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
      "following_url": "https://api.github.com/users/amitiuttarwar/following{/other_user}",
      "gists_url": "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
      "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
      "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
      "events_url": "https://api.github.com/users/amitiuttarwar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "amitiuttarwar",
      "id": 1500952,
      "node_id": "MDQ6VXNlcjE1MDA5NTI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/amitiuttarwar",
      "html_url": "https://github.com/amitiuttarwar",
      "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
      "following_url": "https://api.github.com/users/amitiuttarwar/following{/other_user}",
      "gists_url": "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
      "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
      "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
      "events_url": "https://api.github.com/users/amitiuttarwar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7cba9d56185b9325ce41d79364e448462fff0f6a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7cba9d56185b9325ce41d79364e448462fff0f6a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7cba9d56185b9325ce41d79364e448462fff0f6a"
      }
    ],
    "stats": {
      "total": 145,
      "additions": 73,
      "deletions": 72
    },
    "files": [
      {
        "sha": "33298df5cc1a1d8c59ca2028e6534728268a7e58",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 0,
        "deletions": 72,
        "changes": 72,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e3f1ea659c9eb1e8be4579923d6acaaab148c2ef/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e3f1ea659c9eb1e8be4579923d6acaaab148c2ef/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=e3f1ea659c9eb1e8be4579923d6acaaab148c2ef",
        "patch": "@@ -24,78 +24,6 @@ class AddrManImpl;\n /** Default for -checkaddrman */\n static constexpr int32_t DEFAULT_ADDRMAN_CONSISTENCY_CHECKS{0};\n \n-/**\n- * Extended statistics about a CAddress\n- */\n-class CAddrInfo : public CAddress\n-{\n-public:\n-    //! last try whatsoever by us (memory only)\n-    int64_t nLastTry{0};\n-\n-    //! last counted attempt (memory only)\n-    int64_t nLastCountAttempt{0};\n-\n-private:\n-    //! where knowledge about this address first came from\n-    CNetAddr source;\n-\n-    //! last successful connection by us\n-    int64_t nLastSuccess{0};\n-\n-    //! connection attempts since last successful attempt\n-    int nAttempts{0};\n-\n-    //! reference count in new sets (memory only)\n-    int nRefCount{0};\n-\n-    //! in tried set? (memory only)\n-    bool fInTried{false};\n-\n-    //! position in vRandom\n-    mutable int nRandomPos{-1};\n-\n-    friend class AddrManImpl;\n-    friend class CAddrManDeterministic;\n-\n-public:\n-\n-    SERIALIZE_METHODS(CAddrInfo, obj)\n-    {\n-        READWRITEAS(CAddress, obj);\n-        READWRITE(obj.source, obj.nLastSuccess, obj.nAttempts);\n-    }\n-\n-    CAddrInfo(const CAddress &addrIn, const CNetAddr &addrSource) : CAddress(addrIn), source(addrSource)\n-    {\n-    }\n-\n-    CAddrInfo() : CAddress(), source()\n-    {\n-    }\n-\n-    //! Calculate in which \"tried\" bucket this entry belongs\n-    int GetTriedBucket(const uint256 &nKey, const std::vector<bool> &asmap) const;\n-\n-    //! Calculate in which \"new\" bucket this entry belongs, given a certain source\n-    int GetNewBucket(const uint256 &nKey, const CNetAddr& src, const std::vector<bool> &asmap) const;\n-\n-    //! Calculate in which \"new\" bucket this entry belongs, using its default source\n-    int GetNewBucket(const uint256 &nKey, const std::vector<bool> &asmap) const\n-    {\n-        return GetNewBucket(nKey, source, asmap);\n-    }\n-\n-    //! Calculate in which position of a bucket to store this entry.\n-    int GetBucketPosition(const uint256 &nKey, bool fNew, int nBucket) const;\n-\n-    //! Determine whether the statistics about this entry are bad enough so that it can just be deleted\n-    bool IsTerrible(int64_t nNow = GetAdjustedTime()) const;\n-\n-    //! Calculate the relative chance this entry should be given when selecting nodes to connect to\n-    double GetChance(int64_t nNow = GetAdjustedTime()) const;\n-};\n-\n /** Stochastic address manager\n  *\n  * Design goals:"
      },
      {
        "sha": "fec98c416a132f6a67ba87ed82b9f82bc3af7ee5",
        "filename": "src/addrman_impl.h",
        "status": "modified",
        "additions": 72,
        "deletions": 0,
        "changes": 72,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e3f1ea659c9eb1e8be4579923d6acaaab148c2ef/src/addrman_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e3f1ea659c9eb1e8be4579923d6acaaab148c2ef/src/addrman_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman_impl.h?ref=e3f1ea659c9eb1e8be4579923d6acaaab148c2ef",
        "patch": "@@ -5,6 +5,78 @@\n #ifndef BITCOIN_ADDRMAN_IMPL_H\n #define BITCOIN_ADDRMAN_IMPL_H\n \n+/**\n+ * Extended statistics about a CAddress\n+ */\n+class CAddrInfo : public CAddress\n+{\n+public:\n+    //! last try whatsoever by us (memory only)\n+    int64_t nLastTry{0};\n+\n+    //! last counted attempt (memory only)\n+    int64_t nLastCountAttempt{0};\n+\n+private:\n+    //! where knowledge about this address first came from\n+    CNetAddr source;\n+\n+    //! last successful connection by us\n+    int64_t nLastSuccess{0};\n+\n+    //! connection attempts since last successful attempt\n+    int nAttempts{0};\n+\n+    //! reference count in new sets (memory only)\n+    int nRefCount{0};\n+\n+    //! in tried set? (memory only)\n+    bool fInTried{false};\n+\n+    //! position in vRandom\n+    mutable int nRandomPos{-1};\n+\n+    friend class AddrManImpl;\n+    friend class CAddrManDeterministic;\n+\n+public:\n+\n+    SERIALIZE_METHODS(CAddrInfo, obj)\n+    {\n+        READWRITEAS(CAddress, obj);\n+        READWRITE(obj.source, obj.nLastSuccess, obj.nAttempts);\n+    }\n+\n+    CAddrInfo(const CAddress &addrIn, const CNetAddr &addrSource) : CAddress(addrIn), source(addrSource)\n+    {\n+    }\n+\n+    CAddrInfo() : CAddress(), source()\n+    {\n+    }\n+\n+    //! Calculate in which \"tried\" bucket this entry belongs\n+    int GetTriedBucket(const uint256 &nKey, const std::vector<bool> &asmap) const;\n+\n+    //! Calculate in which \"new\" bucket this entry belongs, given a certain source\n+    int GetNewBucket(const uint256 &nKey, const CNetAddr& src, const std::vector<bool> &asmap) const;\n+\n+    //! Calculate in which \"new\" bucket this entry belongs, using its default source\n+    int GetNewBucket(const uint256 &nKey, const std::vector<bool> &asmap) const\n+    {\n+        return GetNewBucket(nKey, source, asmap);\n+    }\n+\n+    //! Calculate in which position of a bucket to store this entry.\n+    int GetBucketPosition(const uint256 &nKey, bool fNew, int nBucket) const;\n+\n+    //! Determine whether the statistics about this entry are bad enough so that it can just be deleted\n+    bool IsTerrible(int64_t nNow = GetAdjustedTime()) const;\n+\n+    //! Calculate the relative chance this entry should be given when selecting nodes to connect to\n+    double GetChance(int64_t nNow = GetAdjustedTime()) const;\n+};\n+\n class AddrManImpl\n {\n public:"
      },
      {
        "sha": "8297cfa481d1b1242259fcd0833d0d9fd0e89fb0",
        "filename": "src/test/fuzz/deserialize.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e3f1ea659c9eb1e8be4579923d6acaaab148c2ef/src/test/fuzz/deserialize.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e3f1ea659c9eb1e8be4579923d6acaaab148c2ef/src/test/fuzz/deserialize.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/deserialize.cpp?ref=e3f1ea659c9eb1e8be4579923d6acaaab148c2ef",
        "patch": "@@ -4,6 +4,7 @@\n \n #include <addrdb.h>\n #include <addrman.h>\n+#include <addrman_impl.h>\n #include <blockencodings.h>\n #include <blockfilter.h>\n #include <chain.h>"
      }
    ]
  },
  {
    "sha": "7cf41bbb38db5008f9b69037b88138076d6a6cc5",
    "node_id": "C_kwDOABII59oAKDdjZjQxYmJiMzhkYjUwMDhmOWI2OTAzN2I4ODEzODA3NmQ2YTZjYzU",
    "commit": {
      "author": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2021-09-10T20:32:42Z"
      },
      "committer": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2021-09-28T23:02:34Z"
      },
      "message": "[addrman] Change CAddrInfo access\n\nSince knowledge of CAddrInfo is limited to callsites that import\naddrman_impl.h, only objects in addrman.cpp or the tests have access. Thus we\ncan remove calling them friends and make the members public.",
      "tree": {
        "sha": "870d32a601570f85fe4e010b8f68a41498772187",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/870d32a601570f85fe4e010b8f68a41498772187"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7cf41bbb38db5008f9b69037b88138076d6a6cc5",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7cf41bbb38db5008f9b69037b88138076d6a6cc5",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7cf41bbb38db5008f9b69037b88138076d6a6cc5",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7cf41bbb38db5008f9b69037b88138076d6a6cc5/comments",
    "author": {
      "login": "amitiuttarwar",
      "id": 1500952,
      "node_id": "MDQ6VXNlcjE1MDA5NTI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/amitiuttarwar",
      "html_url": "https://github.com/amitiuttarwar",
      "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
      "following_url": "https://api.github.com/users/amitiuttarwar/following{/other_user}",
      "gists_url": "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
      "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
      "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
      "events_url": "https://api.github.com/users/amitiuttarwar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "amitiuttarwar",
      "id": 1500952,
      "node_id": "MDQ6VXNlcjE1MDA5NTI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/amitiuttarwar",
      "html_url": "https://github.com/amitiuttarwar",
      "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
      "following_url": "https://api.github.com/users/amitiuttarwar/following{/other_user}",
      "gists_url": "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
      "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
      "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
      "events_url": "https://api.github.com/users/amitiuttarwar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e3f1ea659c9eb1e8be4579923d6acaaab148c2ef",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e3f1ea659c9eb1e8be4579923d6acaaab148c2ef",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e3f1ea659c9eb1e8be4579923d6acaaab148c2ef"
      }
    ],
    "stats": {
      "total": 6,
      "additions": 0,
      "deletions": 6
    },
    "files": [
      {
        "sha": "8da814b1472a0c023523f7ccb9304fe2493a4432",
        "filename": "src/addrman_impl.h",
        "status": "modified",
        "additions": 0,
        "deletions": 6,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7cf41bbb38db5008f9b69037b88138076d6a6cc5/src/addrman_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7cf41bbb38db5008f9b69037b88138076d6a6cc5/src/addrman_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman_impl.h?ref=7cf41bbb38db5008f9b69037b88138076d6a6cc5",
        "patch": "@@ -17,7 +17,6 @@ class CAddrInfo : public CAddress\n     //! last counted attempt (memory only)\n     int64_t nLastCountAttempt{0};\n \n-private:\n     //! where knowledge about this address first came from\n     CNetAddr source;\n \n@@ -36,11 +35,6 @@ class CAddrInfo : public CAddress\n     //! position in vRandom\n     mutable int nRandomPos{-1};\n \n-    friend class AddrManImpl;\n-    friend class CAddrManDeterministic;\n-\n-public:\n-\n     SERIALIZE_METHODS(CAddrInfo, obj)\n     {\n         READWRITEAS(CAddress, obj);"
      }
    ]
  },
  {
    "sha": "40acd6fc9a8098fed85abf4fb727a5f0dff8a2ff",
    "node_id": "C_kwDOABII59oAKDQwYWNkNmZjOWE4MDk4ZmVkODVhYmY0ZmI3MjdhNWYwZGZmOGEyZmY",
    "commit": {
      "author": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2021-09-04T00:26:10Z"
      },
      "committer": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2021-09-28T23:02:34Z"
      },
      "message": "[move-only] Move constants to test-only header\n\nReview hint: git diff --color-moved=dimmed-zebra\n--color-moved-ws=ignore-all-space",
      "tree": {
        "sha": "b296c45f8f3d530a9ff7ccbd4749670a5730342d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b296c45f8f3d530a9ff7ccbd4749670a5730342d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/40acd6fc9a8098fed85abf4fb727a5f0dff8a2ff",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/40acd6fc9a8098fed85abf4fb727a5f0dff8a2ff",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/40acd6fc9a8098fed85abf4fb727a5f0dff8a2ff",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/40acd6fc9a8098fed85abf4fb727a5f0dff8a2ff/comments",
    "author": {
      "login": "amitiuttarwar",
      "id": 1500952,
      "node_id": "MDQ6VXNlcjE1MDA5NTI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/amitiuttarwar",
      "html_url": "https://github.com/amitiuttarwar",
      "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
      "following_url": "https://api.github.com/users/amitiuttarwar/following{/other_user}",
      "gists_url": "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
      "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
      "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
      "events_url": "https://api.github.com/users/amitiuttarwar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "amitiuttarwar",
      "id": 1500952,
      "node_id": "MDQ6VXNlcjE1MDA5NTI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/amitiuttarwar",
      "html_url": "https://github.com/amitiuttarwar",
      "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
      "following_url": "https://api.github.com/users/amitiuttarwar/following{/other_user}",
      "gists_url": "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
      "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
      "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
      "events_url": "https://api.github.com/users/amitiuttarwar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7cf41bbb38db5008f9b69037b88138076d6a6cc5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7cf41bbb38db5008f9b69037b88138076d6a6cc5",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7cf41bbb38db5008f9b69037b88138076d6a6cc5"
      }
    ],
    "stats": {
      "total": 26,
      "additions": 10,
      "deletions": 16
    },
    "files": [
      {
        "sha": "688265d345f12080ea40b69ecfc6c75fae8aa0a1",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 0,
        "deletions": 16,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/40acd6fc9a8098fed85abf4fb727a5f0dff8a2ff/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/40acd6fc9a8098fed85abf4fb727a5f0dff8a2ff/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=40acd6fc9a8098fed85abf4fb727a5f0dff8a2ff",
        "patch": "@@ -53,22 +53,6 @@ static constexpr int32_t DEFAULT_ADDRMAN_CONSISTENCY_CHECKS{0};\n  *    * Several indexes are kept for high performance. Setting m_consistency_check_ratio with the -checkaddrman\n  *      configuration option will introduce (expensive) consistency checks for the entire data structure.\n  */\n-\n-/** Total number of buckets for tried addresses */\n-static constexpr int32_t ADDRMAN_TRIED_BUCKET_COUNT_LOG2{8};\n-static constexpr int ADDRMAN_TRIED_BUCKET_COUNT{1 << ADDRMAN_TRIED_BUCKET_COUNT_LOG2};\n-\n-/** Total number of buckets for new addresses */\n-static constexpr int32_t ADDRMAN_NEW_BUCKET_COUNT_LOG2{10};\n-static constexpr int ADDRMAN_NEW_BUCKET_COUNT{1 << ADDRMAN_NEW_BUCKET_COUNT_LOG2};\n-\n-/** Maximum allowed number of entries in buckets for new and tried addresses */\n-static constexpr int32_t ADDRMAN_BUCKET_SIZE_LOG2{6};\n-static constexpr int ADDRMAN_BUCKET_SIZE{1 << ADDRMAN_BUCKET_SIZE_LOG2};\n-\n-/**\n- * Stochastical (IP) address manager\n- */\n class CAddrMan\n {\n     const std::unique_ptr<AddrManImpl> m_impl;"
      },
      {
        "sha": "1d13df803d9de2008654d1dc62f2e3800118b304",
        "filename": "src/addrman_impl.h",
        "status": "modified",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/40acd6fc9a8098fed85abf4fb727a5f0dff8a2ff/src/addrman_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/40acd6fc9a8098fed85abf4fb727a5f0dff8a2ff/src/addrman_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman_impl.h?ref=40acd6fc9a8098fed85abf4fb727a5f0dff8a2ff",
        "patch": "@@ -5,6 +5,16 @@\n #ifndef BITCOIN_ADDRMAN_IMPL_H\n #define BITCOIN_ADDRMAN_IMPL_H\n \n+/** Total number of buckets for tried addresses */\n+static constexpr int32_t ADDRMAN_TRIED_BUCKET_COUNT_LOG2{8};\n+static constexpr int ADDRMAN_TRIED_BUCKET_COUNT{1 << ADDRMAN_TRIED_BUCKET_COUNT_LOG2};\n+/** Total number of buckets for new addresses */\n+static constexpr int32_t ADDRMAN_NEW_BUCKET_COUNT_LOG2{10};\n+static constexpr int ADDRMAN_NEW_BUCKET_COUNT{1 << ADDRMAN_NEW_BUCKET_COUNT_LOG2};\n+/** Maximum allowed number of entries in buckets for new and tried addresses */\n+static constexpr int32_t ADDRMAN_BUCKET_SIZE_LOG2{6};\n+static constexpr int ADDRMAN_BUCKET_SIZE{1 << ADDRMAN_BUCKET_SIZE_LOG2};\n+\n /**\n  * Extended statistics about a CAddress\n  */"
      }
    ]
  },
  {
    "sha": "14f9e000d05f82b364d5a142cafc70b10406b660",
    "node_id": "C_kwDOABII59oAKDE0ZjllMDAwZDA1ZjgyYjM2NGQ1YTE0MmNhZmM3MGIxMDQwNmI2NjA",
    "commit": {
      "author": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2021-09-22T21:47:49Z"
      },
      "committer": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2021-09-28T23:02:34Z"
      },
      "message": "[refactor] Update GetAddr_() function signature\n\nUpdate so the internal function signature matches the external one, as is the\ncase for the other addrman functions.",
      "tree": {
        "sha": "1dafd2518b738523c4e37f3650689475ccac85e2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1dafd2518b738523c4e37f3650689475ccac85e2"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/14f9e000d05f82b364d5a142cafc70b10406b660",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/14f9e000d05f82b364d5a142cafc70b10406b660",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/14f9e000d05f82b364d5a142cafc70b10406b660",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/14f9e000d05f82b364d5a142cafc70b10406b660/comments",
    "author": {
      "login": "amitiuttarwar",
      "id": 1500952,
      "node_id": "MDQ6VXNlcjE1MDA5NTI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/amitiuttarwar",
      "html_url": "https://github.com/amitiuttarwar",
      "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
      "following_url": "https://api.github.com/users/amitiuttarwar/following{/other_user}",
      "gists_url": "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
      "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
      "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
      "events_url": "https://api.github.com/users/amitiuttarwar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "amitiuttarwar",
      "id": 1500952,
      "node_id": "MDQ6VXNlcjE1MDA5NTI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/amitiuttarwar",
      "html_url": "https://github.com/amitiuttarwar",
      "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
      "following_url": "https://api.github.com/users/amitiuttarwar/following{/other_user}",
      "gists_url": "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
      "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
      "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
      "events_url": "https://api.github.com/users/amitiuttarwar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "40acd6fc9a8098fed85abf4fb727a5f0dff8a2ff",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/40acd6fc9a8098fed85abf4fb727a5f0dff8a2ff",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/40acd6fc9a8098fed85abf4fb727a5f0dff8a2ff"
      }
    ],
    "stats": {
      "total": 19,
      "additions": 11,
      "deletions": 8
    },
    "files": [
      {
        "sha": "40e087f5fb8bc653bf4002821dfcde19b7537736",
        "filename": "src/addrman.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 6,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/14f9e000d05f82b364d5a142cafc70b10406b660/src/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/14f9e000d05f82b364d5a142cafc70b10406b660/src/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.cpp?ref=14f9e000d05f82b364d5a142cafc70b10406b660",
        "patch": "@@ -745,7 +745,7 @@ std::pair<CAddress, int64_t> AddrManImpl::Select_(bool newOnly) const\n     }\n }\n \n-void AddrManImpl::GetAddr_(std::vector<CAddress>& vAddr, size_t max_addresses, size_t max_pct, std::optional<Network> network) const\n+std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network) const\n {\n     AssertLockHeld(cs);\n \n@@ -759,8 +759,9 @@ void AddrManImpl::GetAddr_(std::vector<CAddress>& vAddr, size_t max_addresses, s\n \n     // gather a list of random nodes, skipping those of low quality\n     const int64_t now{GetAdjustedTime()};\n+    std::vector<CAddress> addresses;\n     for (unsigned int n = 0; n < vRandom.size(); n++) {\n-        if (vAddr.size() >= nNodes)\n+        if (addresses.size() >= nNodes)\n             break;\n \n         int nRndPos = insecure_rand.randrange(vRandom.size() - n) + n;\n@@ -776,8 +777,10 @@ void AddrManImpl::GetAddr_(std::vector<CAddress>& vAddr, size_t max_addresses, s\n         // Filter for quality\n         if (ai.IsTerrible(now)) continue;\n \n-        vAddr.push_back(ai);\n+        addresses.push_back(ai);\n     }\n+\n+    return addresses;\n }\n \n void AddrManImpl::Connected_(const CService& addr, int64_t nTime)\n@@ -1080,10 +1083,9 @@ std::vector<CAddress> AddrManImpl::GetAddr(size_t max_addresses, size_t max_pct,\n {\n     LOCK(cs);\n     Check();\n-    std::vector<CAddress> vAddr;\n-    GetAddr_(vAddr, max_addresses, max_pct, network);\n+    const auto addresses = GetAddr_(max_addresses, max_pct, network);\n     Check();\n-    return vAddr;\n+    return addresses;\n }\n \n void AddrManImpl::Connected(const CService &addr, int64_t nTime)"
      },
      {
        "sha": "918034caf88356c98108ae60f235ae15563232fa",
        "filename": "src/addrman_impl.h",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/14f9e000d05f82b364d5a142cafc70b10406b660/src/addrman_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/14f9e000d05f82b364d5a142cafc70b10406b660/src/addrman_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman_impl.h?ref=14f9e000d05f82b364d5a142cafc70b10406b660",
        "patch": "@@ -242,12 +242,13 @@ class AddrManImpl\n     /**\n      * Return all or many randomly selected addresses, optionally by network.\n      *\n-     * @param[out] vAddr         Vector of randomly selected addresses from vRandom.\n      * @param[in] max_addresses  Maximum number of addresses to return (0 = all).\n      * @param[in] max_pct        Maximum percentage of addresses to return (0 = all).\n      * @param[in] network        Select only addresses of this network (nullopt = all).\n+     *\n+     * @returns                  A vector of randomly selected addresses from vRandom.\n      */\n-    void GetAddr_(std::vector<CAddress>& vAddr, size_t max_addresses, size_t max_pct, std::optional<Network> network) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n+    std::vector<CAddress> GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n     /** We have successfully connected to this peer. Calling this function\n      *  updates the CAddress's nTime, which is used in our IsTerrible()"
      }
    ]
  },
  {
    "sha": "29727c2aa1233f7c5b91a17884c405e0aef10c6e",
    "node_id": "C_kwDOABII59oAKDI5NzI3YzJhYTEyMzNmN2M1YjkxYTE3ODg0YzQwNWUwYWVmMTBjNmU",
    "commit": {
      "author": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2021-09-04T00:27:11Z"
      },
      "committer": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2021-09-28T23:02:34Z"
      },
      "message": "[doc] Update comments\n\nMaintain comments on the external interfaces rather than on the internal\nfunctions that implement them.",
      "tree": {
        "sha": "5e7318e377fa5faeb8067bdb7975936c5524866a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5e7318e377fa5faeb8067bdb7975936c5524866a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/29727c2aa1233f7c5b91a17884c405e0aef10c6e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/29727c2aa1233f7c5b91a17884c405e0aef10c6e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/29727c2aa1233f7c5b91a17884c405e0aef10c6e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/29727c2aa1233f7c5b91a17884c405e0aef10c6e/comments",
    "author": {
      "login": "amitiuttarwar",
      "id": 1500952,
      "node_id": "MDQ6VXNlcjE1MDA5NTI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/amitiuttarwar",
      "html_url": "https://github.com/amitiuttarwar",
      "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
      "following_url": "https://api.github.com/users/amitiuttarwar/following{/other_user}",
      "gists_url": "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
      "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
      "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
      "events_url": "https://api.github.com/users/amitiuttarwar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "amitiuttarwar",
      "id": 1500952,
      "node_id": "MDQ6VXNlcjE1MDA5NTI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/amitiuttarwar",
      "html_url": "https://github.com/amitiuttarwar",
      "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
      "following_url": "https://api.github.com/users/amitiuttarwar/following{/other_user}",
      "gists_url": "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
      "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
      "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
      "events_url": "https://api.github.com/users/amitiuttarwar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "14f9e000d05f82b364d5a142cafc70b10406b660",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/14f9e000d05f82b364d5a142cafc70b10406b660",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/14f9e000d05f82b364d5a142cafc70b10406b660"
      }
    ],
    "stats": {
      "total": 46,
      "additions": 16,
      "deletions": 30
    },
    "files": [
      {
        "sha": "3ccd3751bc6971867e1df32f9846faa9e91add25",
        "filename": "src/addrman.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/29727c2aa1233f7c5b91a17884c405e0aef10c6e/src/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/29727c2aa1233f7c5b91a17884c405e0aef10c6e/src/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.cpp?ref=29727c2aa1233f7c5b91a17884c405e0aef10c6e",
        "patch": "@@ -23,7 +23,7 @@\n static constexpr uint32_t ADDRMAN_TRIED_BUCKETS_PER_GROUP{8};\n /** Over how many buckets entries with new addresses originating from a single group are spread */\n static constexpr uint32_t ADDRMAN_NEW_BUCKETS_PER_SOURCE_GROUP{64};\n-/** Maximum number of times an address can be added to the new table */\n+/** Maximum number of times an address can occur in the new table */\n static constexpr int32_t ADDRMAN_NEW_BUCKETS_PER_ADDRESS{8};\n /** How old addresses can maximally be */\n static constexpr int64_t ADDRMAN_HORIZON_DAYS{30};"
      },
      {
        "sha": "84c2bf2201b7c536fc8cd9214231ee07128b164a",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 15,
        "deletions": 2,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/29727c2aa1233f7c5b91a17884c405e0aef10c6e/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/29727c2aa1233f7c5b91a17884c405e0aef10c6e/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=29727c2aa1233f7c5b91a17884c405e0aef10c6e",
        "patch": "@@ -74,7 +74,7 @@ class CAddrMan\n     //! Add addresses to addrman's new table.\n     bool Add(const std::vector<CAddress> &vAddr, const CNetAddr& source, int64_t nTimePenalty = 0);\n \n-    //! Mark an entry as accessible.\n+    //! Mark an entry as accessible, possibly moving it from \"new\" to \"tried\".\n     void Good(const CService &addr, int64_t nTime = GetAdjustedTime());\n \n     //! Mark an entry as connection attempted to.\n@@ -107,12 +107,25 @@ class CAddrMan\n      * @param[in] max_addresses  Maximum number of addresses to return (0 = all).\n      * @param[in] max_pct        Maximum percentage of addresses to return (0 = all).\n      * @param[in] network        Select only addresses of this network (nullopt = all).\n+     *\n+     * @return                   A vector of randomly selected addresses from vRandom.\n      */\n     std::vector<CAddress> GetAddr(size_t max_addresses, size_t max_pct, std::optional<Network> network) const;\n \n-    //! Outer function for Connected_()\n+    /** We have successfully connected to this peer. Calling this function\n+     *  updates the CAddress's nTime, which is used in our IsTerrible()\n+     *  decisions and gossiped to peers. Callers should be careful that updating\n+     *  this information doesn't leak topology information to network spies.\n+     *\n+     *  net_processing calls this function when it *disconnects* from a peer to\n+     *  not leak information about currently connected peers.\n+     *\n+     * @param[in]   addr     The address of the peer we were connected to\n+     * @param[in]   nTime    The time that we were last connected to this peer\n+     */\n     void Connected(const CService &addr, int64_t nTime = GetAdjustedTime());\n \n+    //! Update an entry's service bits.\n     void SetServices(const CService &addr, ServiceFlags nServices);\n \n     const std::vector<bool>& GetAsmap() const;"
      },
      {
        "sha": "160efb2c0ed042d3b2f0176c112860785eb572b2",
        "filename": "src/addrman_impl.h",
        "status": "modified",
        "additions": 0,
        "deletions": 27,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/29727c2aa1233f7c5b91a17884c405e0aef10c6e/src/addrman_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/29727c2aa1233f7c5b91a17884c405e0aef10c6e/src/addrman_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman_impl.h?ref=29727c2aa1233f7c5b91a17884c405e0aef10c6e",
        "patch": "@@ -227,49 +227,22 @@ class AddrManImpl\n     //! Move an entry from the \"new\" table(s) to the \"tried\" table\n     void MakeTried(CAddrInfo& info, int nId) EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n-    //! Mark an entry \"good\", possibly moving it from \"new\" to \"tried\".\n     void Good_(const CService &addr, bool test_before_evict, int64_t time) EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n-    //! Add an entry to the \"new\" table.\n     bool Add_(const CAddress &addr, const CNetAddr& source, int64_t nTimePenalty) EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n-    //! Mark an entry as attempted to connect.\n     void Attempt_(const CService &addr, bool fCountFailure, int64_t nTime) EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n-    //! Select an address to connect to, if newOnly is set to true, only the new table is selected from.\n     std::pair<CAddress, int64_t> Select_(bool newOnly) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n-    /**\n-     * Return all or many randomly selected addresses, optionally by network.\n-     *\n-     * @param[in] max_addresses  Maximum number of addresses to return (0 = all).\n-     * @param[in] max_pct        Maximum percentage of addresses to return (0 = all).\n-     * @param[in] network        Select only addresses of this network (nullopt = all).\n-     *\n-     * @returns                  A vector of randomly selected addresses from vRandom.\n-     */\n     std::vector<CAddress> GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n-    /** We have successfully connected to this peer. Calling this function\n-     *  updates the CAddress's nTime, which is used in our IsTerrible()\n-     *  decisions and gossiped to peers. Callers should be careful that updating\n-     *  this information doesn't leak topology information to network spies.\n-     *\n-     *  net_processing calls this function when it *disconnects* from a peer to\n-     *  not leak information about currently connected peers.\n-     *\n-     * @param[in]   addr     The address of the peer we were connected to\n-     * @param[in]   nTime    The time that we were last connected to this peer\n-     */\n     void Connected_(const CService& addr, int64_t nTime) EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n-    //! Update an entry's service bits.\n     void SetServices_(const CService &addr, ServiceFlags nServices) EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n-    //! See if any to-be-evicted tried table entries have been tested and if so resolve the collisions.\n     void ResolveCollisions_() EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n-    //! Return a random to-be-evicted tried table address.\n     std::pair<CAddress, int64_t> SelectTriedCollision_() EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n     //! Consistency check, taking into account m_consistency_check_ratio. Will std::abort if an inconsistency is detected."
      }
    ]
  },
  {
    "sha": "3c263d3f63c3598954ee2b65a0e721e3c22e52f8",
    "node_id": "C_kwDOABII59oAKDNjMjYzZDNmNjNjMzU5ODk1NGVlMmI2NWEwZTcyMWUzYzIyZTUyZjg",
    "commit": {
      "author": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2021-09-10T22:37:41Z"
      },
      "committer": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2021-09-29T02:21:06Z"
      },
      "message": "[includes] Fix up included files",
      "tree": {
        "sha": "202a786aa08ee9854e89b744c74c44368f0b17f8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/202a786aa08ee9854e89b744c74c44368f0b17f8"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3c263d3f63c3598954ee2b65a0e721e3c22e52f8",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3c263d3f63c3598954ee2b65a0e721e3c22e52f8",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/3c263d3f63c3598954ee2b65a0e721e3c22e52f8",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3c263d3f63c3598954ee2b65a0e721e3c22e52f8/comments",
    "author": {
      "login": "amitiuttarwar",
      "id": 1500952,
      "node_id": "MDQ6VXNlcjE1MDA5NTI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/amitiuttarwar",
      "html_url": "https://github.com/amitiuttarwar",
      "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
      "following_url": "https://api.github.com/users/amitiuttarwar/following{/other_user}",
      "gists_url": "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
      "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
      "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
      "events_url": "https://api.github.com/users/amitiuttarwar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "amitiuttarwar",
      "id": 1500952,
      "node_id": "MDQ6VXNlcjE1MDA5NTI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/amitiuttarwar",
      "html_url": "https://github.com/amitiuttarwar",
      "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
      "following_url": "https://api.github.com/users/amitiuttarwar/following{/other_user}",
      "gists_url": "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
      "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
      "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
      "events_url": "https://api.github.com/users/amitiuttarwar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "29727c2aa1233f7c5b91a17884c405e0aef10c6e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/29727c2aa1233f7c5b91a17884c405e0aef10c6e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/29727c2aa1233f7c5b91a17884c405e0aef10c6e"
      }
    ],
    "stats": {
      "total": 32,
      "additions": 23,
      "deletions": 9
    },
    "files": [
      {
        "sha": "ef1538b6e9f19dffd6a0486c60ed5b6664693672",
        "filename": "src/addrman.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 4,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3c263d3f63c3598954ee2b65a0e721e3c22e52f8/src/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3c263d3f63c3598954ee2b65a0e721e3c22e52f8/src/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.cpp?ref=3c263d3f63c3598954ee2b65a0e721e3c22e52f8",
        "patch": "@@ -6,18 +6,19 @@\n #include <addrman.h>\n #include <addrman_impl.h>\n \n-#include <clientversion.h>\n #include <hash.h>\n-#include <logging.h>\n #include <netaddress.h>\n+#include <protocol.h>\n+#include <random.h>\n #include <serialize.h>\n #include <streams.h>\n+#include <timedata.h>\n+#include <tinyformat.h>\n+#include <uint256.h>\n #include <util/check.h>\n \n #include <cmath>\n #include <optional>\n-#include <unordered_map>\n-#include <unordered_set>\n \n /** Over how many buckets entries with tried addresses from a single group (/16 for IPv4) are spread */\n static constexpr uint32_t ADDRMAN_TRIED_BUCKETS_PER_GROUP{8};"
      },
      {
        "sha": "b0944bcfd59f0fe6429aeaa8fbc549ad19eaa6e1",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 3,
        "deletions": 5,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3c263d3f63c3598954ee2b65a0e721e3c22e52f8/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3c263d3f63c3598954ee2b65a0e721e3c22e52f8/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=3c263d3f63c3598954ee2b65a0e721e3c22e52f8",
        "patch": "@@ -6,17 +6,15 @@\n #ifndef BITCOIN_ADDRMAN_H\n #define BITCOIN_ADDRMAN_H\n \n-#include <fs.h>\n-#include <logging.h>\n #include <netaddress.h>\n #include <protocol.h>\n-#include <sync.h>\n+#include <streams.h>\n #include <timedata.h>\n \n #include <cstdint>\n+#include <memory>\n #include <optional>\n-#include <set>\n-#include <unordered_map>\n+#include <utility>\n #include <vector>\n \n class AddrManImpl;"
      },
      {
        "sha": "c37c7b4779899c48dfeaccc1760c28c792c42a24",
        "filename": "src/addrman_impl.h",
        "status": "modified",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3c263d3f63c3598954ee2b65a0e721e3c22e52f8/src/addrman_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3c263d3f63c3598954ee2b65a0e721e3c22e52f8/src/addrman_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman_impl.h?ref=3c263d3f63c3598954ee2b65a0e721e3c22e52f8",
        "patch": "@@ -5,6 +5,21 @@\n #ifndef BITCOIN_ADDRMAN_IMPL_H\n #define BITCOIN_ADDRMAN_IMPL_H\n \n+#include <logging.h>\n+#include <netaddress.h>\n+#include <protocol.h>\n+#include <serialize.h>\n+#include <sync.h>\n+#include <uint256.h>\n+\n+#include <cstdint>\n+#include <optional>\n+#include <set>\n+#include <unordered_map>\n+#include <unordered_set>\n+#include <utility>\n+#include <vector>\n+\n /** Total number of buckets for tried addresses */\n static constexpr int32_t ADDRMAN_TRIED_BUCKET_COUNT_LOG2{8};\n static constexpr int ADDRMAN_TRIED_BUCKET_COUNT{1 << ADDRMAN_TRIED_BUCKET_COUNT_LOG2};"
      }
    ]
  },
  {
    "sha": "dd8f7f250095e58bbf4cd4effb481b52143bd1ed",
    "node_id": "C_kwDOABII59oAKGRkOGY3ZjI1MDA5NWU1OGJiZjRjZDRlZmZiNDgxYjUyMTQzYmQxZWQ",
    "commit": {
      "author": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2021-09-11T00:16:37Z"
      },
      "committer": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2021-09-29T02:21:10Z"
      },
      "message": "scripted-diff: Rename CAddrMan to AddrMan\n\n-BEGIN VERIFY SCRIPT-\ngit grep -l CAddrMan src/ test/ | xargs sed -i 's/CAddrMan/AddrMan/g'\n-END VERIFY SCRIPT-",
      "tree": {
        "sha": "04068c2a49362c5ab7958fcb8bc268c55f5fc59d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/04068c2a49362c5ab7958fcb8bc268c55f5fc59d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/dd8f7f250095e58bbf4cd4effb481b52143bd1ed",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dd8f7f250095e58bbf4cd4effb481b52143bd1ed",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/dd8f7f250095e58bbf4cd4effb481b52143bd1ed",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dd8f7f250095e58bbf4cd4effb481b52143bd1ed/comments",
    "author": {
      "login": "amitiuttarwar",
      "id": 1500952,
      "node_id": "MDQ6VXNlcjE1MDA5NTI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/amitiuttarwar",
      "html_url": "https://github.com/amitiuttarwar",
      "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
      "following_url": "https://api.github.com/users/amitiuttarwar/following{/other_user}",
      "gists_url": "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
      "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
      "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
      "events_url": "https://api.github.com/users/amitiuttarwar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "amitiuttarwar",
      "id": 1500952,
      "node_id": "MDQ6VXNlcjE1MDA5NTI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/amitiuttarwar",
      "html_url": "https://github.com/amitiuttarwar",
      "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
      "following_url": "https://api.github.com/users/amitiuttarwar/following{/other_user}",
      "gists_url": "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
      "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
      "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
      "events_url": "https://api.github.com/users/amitiuttarwar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "3c263d3f63c3598954ee2b65a0e721e3c22e52f8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3c263d3f63c3598954ee2b65a0e721e3c22e52f8",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3c263d3f63c3598954ee2b65a0e721e3c22e52f8"
      }
    ],
    "stats": {
      "total": 244,
      "additions": 122,
      "deletions": 122
    },
    "files": [
      {
        "sha": "50fd09101ee568cd305b05ed1f3b7682dd828056",
        "filename": "src/addrdb.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dd8f7f250095e58bbf4cd4effb481b52143bd1ed/src/addrdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dd8f7f250095e58bbf4cd4effb481b52143bd1ed/src/addrdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrdb.cpp?ref=dd8f7f250095e58bbf4cd4effb481b52143bd1ed",
        "patch": "@@ -170,21 +170,21 @@ bool CBanDB::Read(banmap_t& banSet)\n     return true;\n }\n \n-bool DumpPeerAddresses(const ArgsManager& args, const CAddrMan& addr)\n+bool DumpPeerAddresses(const ArgsManager& args, const AddrMan& addr)\n {\n     const auto pathAddr = args.GetDataDirNet() / \"peers.dat\";\n     return SerializeFileDB(\"peers\", pathAddr, addr, CLIENT_VERSION);\n }\n \n-void ReadFromStream(CAddrMan& addr, CDataStream& ssPeers)\n+void ReadFromStream(AddrMan& addr, CDataStream& ssPeers)\n {\n     DeserializeDB(ssPeers, addr, false);\n }\n \n-std::optional<bilingual_str> LoadAddrman(const std::vector<bool>& asmap, const ArgsManager& args, std::unique_ptr<CAddrMan>& addrman)\n+std::optional<bilingual_str> LoadAddrman(const std::vector<bool>& asmap, const ArgsManager& args, std::unique_ptr<AddrMan>& addrman)\n {\n     auto check_addrman = std::clamp<int32_t>(args.GetIntArg(\"-checkaddrman\", DEFAULT_ADDRMAN_CONSISTENCY_CHECKS), 0, 1000000);\n-    addrman = std::make_unique<CAddrMan>(asmap, /* deterministic */ false, /* consistency_check_ratio */ check_addrman);\n+    addrman = std::make_unique<AddrMan>(asmap, /* deterministic */ false, /* consistency_check_ratio */ check_addrman);\n \n     int64_t nStart = GetTimeMillis();\n     const auto path_addr{args.GetDataDirNet() / \"peers.dat\"};\n@@ -193,7 +193,7 @@ std::optional<bilingual_str> LoadAddrman(const std::vector<bool>& asmap, const A\n         LogPrintf(\"Loaded %i addresses from peers.dat  %dms\\n\", addrman->size(), GetTimeMillis() - nStart);\n     } catch (const DbNotFoundError&) {\n         // Addrman can be in an inconsistent state after failure, reset it\n-        addrman = std::make_unique<CAddrMan>(asmap, /* deterministic */ false, /* consistency_check_ratio */ check_addrman);\n+        addrman = std::make_unique<AddrMan>(asmap, /* deterministic */ false, /* consistency_check_ratio */ check_addrman);\n         LogPrintf(\"Creating peers.dat because the file was not found (%s)\\n\", path_addr);\n         DumpPeerAddresses(args, *addrman);\n     } catch (const std::exception& e) {"
      },
      {
        "sha": "19be4b5bb4ee284c92745c7115c9ec1042c02f83",
        "filename": "src/addrdb.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dd8f7f250095e58bbf4cd4effb481b52143bd1ed/src/addrdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dd8f7f250095e58bbf4cd4effb481b52143bd1ed/src/addrdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrdb.h?ref=dd8f7f250095e58bbf4cd4effb481b52143bd1ed",
        "patch": "@@ -14,14 +14,14 @@\n #include <vector>\n \n class ArgsManager;\n-class CAddrMan;\n+class AddrMan;\n class CAddress;\n class CDataStream;\n struct bilingual_str;\n \n-bool DumpPeerAddresses(const ArgsManager& args, const CAddrMan& addr);\n+bool DumpPeerAddresses(const ArgsManager& args, const AddrMan& addr);\n /** Only used by tests. */\n-void ReadFromStream(CAddrMan& addr, CDataStream& ssPeers);\n+void ReadFromStream(AddrMan& addr, CDataStream& ssPeers);\n \n /** Access to the banlist database (banlist.json) */\n class CBanDB\n@@ -48,7 +48,7 @@ class CBanDB\n };\n \n /** Returns an error string on failure */\n-std::optional<bilingual_str> LoadAddrman(const std::vector<bool>& asmap, const ArgsManager& args, std::unique_ptr<CAddrMan>& addrman);\n+std::optional<bilingual_str> LoadAddrman(const std::vector<bool>& asmap, const ArgsManager& args, std::unique_ptr<AddrMan>& addrman);\n \n /**\n  * Dump the anchor IP address database (anchors.dat)"
      },
      {
        "sha": "42d4b5a6e5322cfd700095b4a74932dd0b2c9ba3",
        "filename": "src/addrman.cpp",
        "status": "modified",
        "additions": 25,
        "deletions": 25,
        "changes": 50,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dd8f7f250095e58bbf4cd4effb481b52143bd1ed/src/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dd8f7f250095e58bbf4cd4effb481b52143bd1ed/src/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.cpp?ref=dd8f7f250095e58bbf4cd4effb481b52143bd1ed",
        "patch": "@@ -269,14 +269,14 @@ void AddrManImpl::Unserialize(Stream& s_)\n \n     if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {\n         throw std::ios_base::failure(\n-                strprintf(\"Corrupt CAddrMan serialization: nNew=%d, should be in [0, %d]\",\n+                strprintf(\"Corrupt AddrMan serialization: nNew=%d, should be in [0, %d]\",\n                     nNew,\n                     ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));\n     }\n \n     if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {\n         throw std::ios_base::failure(\n-                strprintf(\"Corrupt CAddrMan serialization: nTried=%d, should be in [0, %d]\",\n+                strprintf(\"Corrupt AddrMan serialization: nTried=%d, should be in [0, %d]\",\n                     nTried,\n                     ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));\n     }\n@@ -1110,83 +1110,83 @@ const std::vector<bool>& AddrManImpl::GetAsmap() const\n     return m_asmap;\n }\n \n-CAddrMan::CAddrMan(std::vector<bool> asmap, bool deterministic, int32_t consistency_check_ratio)\n+AddrMan::AddrMan(std::vector<bool> asmap, bool deterministic, int32_t consistency_check_ratio)\n     : m_impl(std::make_unique<AddrManImpl>(std::move(asmap), deterministic, consistency_check_ratio)) {}\n \n-CAddrMan::~CAddrMan() = default;\n+AddrMan::~AddrMan() = default;\n \n template <typename Stream>\n-void CAddrMan::Serialize(Stream& s_) const\n+void AddrMan::Serialize(Stream& s_) const\n {\n     m_impl->Serialize<Stream>(s_);\n }\n \n template <typename Stream>\n-void CAddrMan::Unserialize(Stream& s_)\n+void AddrMan::Unserialize(Stream& s_)\n {\n     m_impl->Unserialize<Stream>(s_);\n }\n \n // explicit instantiation\n-template void CAddrMan::Serialize(CHashWriter& s) const;\n-template void CAddrMan::Serialize(CAutoFile& s) const;\n-template void CAddrMan::Serialize(CDataStream& s) const;\n-template void CAddrMan::Unserialize(CAutoFile& s);\n-template void CAddrMan::Unserialize(CHashVerifier<CAutoFile>& s);\n-template void CAddrMan::Unserialize(CDataStream& s);\n-template void CAddrMan::Unserialize(CHashVerifier<CDataStream>& s);\n-\n-size_t CAddrMan::size() const\n+template void AddrMan::Serialize(CHashWriter& s) const;\n+template void AddrMan::Serialize(CAutoFile& s) const;\n+template void AddrMan::Serialize(CDataStream& s) const;\n+template void AddrMan::Unserialize(CAutoFile& s);\n+template void AddrMan::Unserialize(CHashVerifier<CAutoFile>& s);\n+template void AddrMan::Unserialize(CDataStream& s);\n+template void AddrMan::Unserialize(CHashVerifier<CDataStream>& s);\n+\n+size_t AddrMan::size() const\n {\n     return m_impl->size();\n }\n \n-bool CAddrMan::Add(const std::vector<CAddress> &vAddr, const CNetAddr& source, int64_t nTimePenalty)\n+bool AddrMan::Add(const std::vector<CAddress> &vAddr, const CNetAddr& source, int64_t nTimePenalty)\n {\n     return m_impl->Add(vAddr, source, nTimePenalty);\n }\n \n-void CAddrMan::Good(const CService &addr, int64_t nTime)\n+void AddrMan::Good(const CService &addr, int64_t nTime)\n {\n     m_impl->Good(addr, nTime);\n }\n \n-void CAddrMan::Attempt(const CService &addr, bool fCountFailure, int64_t nTime)\n+void AddrMan::Attempt(const CService &addr, bool fCountFailure, int64_t nTime)\n {\n     m_impl->Attempt(addr, fCountFailure, nTime);\n }\n \n-void CAddrMan::ResolveCollisions()\n+void AddrMan::ResolveCollisions()\n {\n     m_impl->ResolveCollisions();\n }\n \n-std::pair<CAddress, int64_t> CAddrMan::SelectTriedCollision()\n+std::pair<CAddress, int64_t> AddrMan::SelectTriedCollision()\n {\n     return m_impl->SelectTriedCollision();\n }\n \n-std::pair<CAddress, int64_t> CAddrMan::Select(bool newOnly) const\n+std::pair<CAddress, int64_t> AddrMan::Select(bool newOnly) const\n {\n     return m_impl->Select(newOnly);\n }\n \n-std::vector<CAddress> CAddrMan::GetAddr(size_t max_addresses, size_t max_pct, std::optional<Network> network) const\n+std::vector<CAddress> AddrMan::GetAddr(size_t max_addresses, size_t max_pct, std::optional<Network> network) const\n {\n     return m_impl->GetAddr(max_addresses, max_pct, network);\n }\n \n-void CAddrMan::Connected(const CService &addr, int64_t nTime)\n+void AddrMan::Connected(const CService &addr, int64_t nTime)\n {\n     m_impl->Connected(addr, nTime);\n }\n \n-void CAddrMan::SetServices(const CService &addr, ServiceFlags nServices)\n+void AddrMan::SetServices(const CService &addr, ServiceFlags nServices)\n {\n     m_impl->SetServices(addr, nServices);\n }\n \n-const std::vector<bool>& CAddrMan::GetAsmap() const\n+const std::vector<bool>& AddrMan::GetAsmap() const\n {\n     return m_impl->GetAsmap();\n }"
      },
      {
        "sha": "fcb21478326294ac17dbbf0afa6737c5f9d2b7c2",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dd8f7f250095e58bbf4cd4effb481b52143bd1ed/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dd8f7f250095e58bbf4cd4effb481b52143bd1ed/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=dd8f7f250095e58bbf4cd4effb481b52143bd1ed",
        "patch": "@@ -51,14 +51,14 @@ static constexpr int32_t DEFAULT_ADDRMAN_CONSISTENCY_CHECKS{0};\n  *    * Several indexes are kept for high performance. Setting m_consistency_check_ratio with the -checkaddrman\n  *      configuration option will introduce (expensive) consistency checks for the entire data structure.\n  */\n-class CAddrMan\n+class AddrMan\n {\n     const std::unique_ptr<AddrManImpl> m_impl;\n \n public:\n-    explicit CAddrMan(std::vector<bool> asmap, bool deterministic, int32_t consistency_check_ratio);\n+    explicit AddrMan(std::vector<bool> asmap, bool deterministic, int32_t consistency_check_ratio);\n \n-    ~CAddrMan();\n+    ~AddrMan();\n \n     template <typename Stream>\n     void Serialize(Stream& s_) const;\n@@ -128,8 +128,8 @@ class CAddrMan\n \n     const std::vector<bool>& GetAsmap() const;\n \n-    friend class CAddrManTest;\n-    friend class CAddrManDeterministic;\n+    friend class AddrManTest;\n+    friend class AddrManDeterministic;\n };\n \n #endif // BITCOIN_ADDRMAN_H"
      },
      {
        "sha": "f9deb171911853f7a83e005ea904bdbe75984731",
        "filename": "src/addrman_impl.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dd8f7f250095e58bbf4cd4effb481b52143bd1ed/src/addrman_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dd8f7f250095e58bbf4cd4effb481b52143bd1ed/src/addrman_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman_impl.h?ref=dd8f7f250095e58bbf4cd4effb481b52143bd1ed",
        "patch": "@@ -138,8 +138,8 @@ class AddrManImpl\n \n     const std::vector<bool>& GetAsmap() const;\n \n-    friend class CAddrManTest;\n-    friend class CAddrManDeterministic;\n+    friend class AddrManTest;\n+    friend class AddrManDeterministic;\n \n private:\n     //! A mutex to protect the inner data structures."
      },
      {
        "sha": "d6834a239bd911c4dfcc08fa09e4c7084cc987bd",
        "filename": "src/bench/addrman.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dd8f7f250095e58bbf4cd4effb481b52143bd1ed/src/bench/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dd8f7f250095e58bbf4cd4effb481b52143bd1ed/src/bench/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/addrman.cpp?ref=dd8f7f250095e58bbf4cd4effb481b52143bd1ed",
        "patch": "@@ -53,14 +53,14 @@ static void CreateAddresses()\n     }\n }\n \n-static void AddAddressesToAddrMan(CAddrMan& addrman)\n+static void AddAddressesToAddrMan(AddrMan& addrman)\n {\n     for (size_t source_i = 0; source_i < NUM_SOURCES; ++source_i) {\n         addrman.Add(g_addresses[source_i], g_sources[source_i]);\n     }\n }\n \n-static void FillAddrMan(CAddrMan& addrman)\n+static void FillAddrMan(AddrMan& addrman)\n {\n     CreateAddresses();\n \n@@ -74,14 +74,14 @@ static void AddrManAdd(benchmark::Bench& bench)\n     CreateAddresses();\n \n     bench.run([&] {\n-        CAddrMan addrman{/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0};\n+        AddrMan addrman{/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0};\n         AddAddressesToAddrMan(addrman);\n     });\n }\n \n static void AddrManSelect(benchmark::Bench& bench)\n {\n-    CAddrMan addrman(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n+    AddrMan addrman(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n \n     FillAddrMan(addrman);\n \n@@ -93,7 +93,7 @@ static void AddrManSelect(benchmark::Bench& bench)\n \n static void AddrManGetAddr(benchmark::Bench& bench)\n {\n-    CAddrMan addrman(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n+    AddrMan addrman(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n \n     FillAddrMan(addrman);\n \n@@ -105,7 +105,7 @@ static void AddrManGetAddr(benchmark::Bench& bench)\n \n static void AddrManAddThenGood(benchmark::Bench& bench)\n {\n-    auto markSomeAsGood = [](CAddrMan& addrman) {\n+    auto markSomeAsGood = [](AddrMan& addrman) {\n         for (size_t source_i = 0; source_i < NUM_SOURCES; ++source_i) {\n             for (size_t addr_i = 0; addr_i < NUM_ADDRESSES_PER_SOURCE; ++addr_i) {\n                 addrman.Good(g_addresses[source_i][addr_i]);\n@@ -117,12 +117,12 @@ static void AddrManAddThenGood(benchmark::Bench& bench)\n \n     bench.run([&] {\n         // To make the benchmark independent of the number of evaluations, we always prepare a new addrman.\n-        // This is necessary because CAddrMan::Good() method modifies the object, affecting the timing of subsequent calls\n+        // This is necessary because AddrMan::Good() method modifies the object, affecting the timing of subsequent calls\n         // to the same method and we want to do the same amount of work in every loop iteration.\n         //\n         // This has some overhead (exactly the result of AddrManAdd benchmark), but that overhead is constant so improvements in\n-        // CAddrMan::Good() will still be noticeable.\n-        CAddrMan addrman(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n+        // AddrMan::Good() will still be noticeable.\n+        AddrMan addrman(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n         AddAddressesToAddrMan(addrman);\n \n         markSomeAsGood(addrman);"
      },
      {
        "sha": "12a9dea98eebddb8b0360b582002d36295fa9597",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dd8f7f250095e58bbf4cd4effb481b52143bd1ed/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dd8f7f250095e58bbf4cd4effb481b52143bd1ed/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=dd8f7f250095e58bbf4cd4effb481b52143bd1ed",
        "patch": "@@ -2438,7 +2438,7 @@ void CConnman::SetNetworkActive(bool active)\n     }\n }\n \n-CConnman::CConnman(uint64_t nSeed0In, uint64_t nSeed1In, CAddrMan& addrman_in, bool network_active)\n+CConnman::CConnman(uint64_t nSeed0In, uint64_t nSeed1In, AddrMan& addrman_in, bool network_active)\n     : addrman(addrman_in), nSeed0(nSeed0In), nSeed1(nSeed1In)\n {\n     SetTryNewOutboundPeer(false);"
      },
      {
        "sha": "2742107a3572a3b9754668660ea13ccdff3311ca",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dd8f7f250095e58bbf4cd4effb481b52143bd1ed/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dd8f7f250095e58bbf4cd4effb481b52143bd1ed/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=dd8f7f250095e58bbf4cd4effb481b52143bd1ed",
        "patch": "@@ -797,7 +797,7 @@ class CConnman\n         m_onion_binds = connOptions.onion_binds;\n     }\n \n-    CConnman(uint64_t seed0, uint64_t seed1, CAddrMan& addrman, bool network_active = true);\n+    CConnman(uint64_t seed0, uint64_t seed1, AddrMan& addrman, bool network_active = true);\n     ~CConnman();\n     bool Start(CScheduler& scheduler, const Options& options);\n \n@@ -1049,7 +1049,7 @@ class CConnman\n     std::vector<ListenSocket> vhListenSocket;\n     std::atomic<bool> fNetworkActive{true};\n     bool fAddressesInitialized{false};\n-    CAddrMan& addrman;\n+    AddrMan& addrman;\n     std::deque<std::string> m_addr_fetches GUARDED_BY(m_addr_fetches_mutex);\n     RecursiveMutex m_addr_fetches_mutex;\n     std::vector<std::string> vAddedNodes GUARDED_BY(cs_vAddedNodes);"
      },
      {
        "sha": "c82c395da9d3dcdfe39a6d6d9eb093146e1aca4c",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dd8f7f250095e58bbf4cd4effb481b52143bd1ed/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dd8f7f250095e58bbf4cd4effb481b52143bd1ed/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=dd8f7f250095e58bbf4cd4effb481b52143bd1ed",
        "patch": "@@ -291,7 +291,7 @@ using PeerRef = std::shared_ptr<Peer>;\n class PeerManagerImpl final : public PeerManager\n {\n public:\n-    PeerManagerImpl(const CChainParams& chainparams, CConnman& connman, CAddrMan& addrman,\n+    PeerManagerImpl(const CChainParams& chainparams, CConnman& connman, AddrMan& addrman,\n                     BanMan* banman, ChainstateManager& chainman,\n                     CTxMemPool& pool, bool ignore_incoming_txs);\n \n@@ -409,7 +409,7 @@ class PeerManagerImpl final : public PeerManager\n \n     const CChainParams& m_chainparams;\n     CConnman& m_connman;\n-    CAddrMan& m_addrman;\n+    AddrMan& m_addrman;\n     /** Pointer to this node's banman. May be nullptr - check existence before dereferencing. */\n     BanMan* const m_banman;\n     ChainstateManager& m_chainman;\n@@ -1419,14 +1419,14 @@ bool PeerManagerImpl::BlockRequestAllowed(const CBlockIndex* pindex)\n            (GetBlockProofEquivalentTime(*pindexBestHeader, *pindex, *pindexBestHeader, m_chainparams.GetConsensus()) < STALE_RELAY_AGE_LIMIT);\n }\n \n-std::unique_ptr<PeerManager> PeerManager::make(const CChainParams& chainparams, CConnman& connman, CAddrMan& addrman,\n+std::unique_ptr<PeerManager> PeerManager::make(const CChainParams& chainparams, CConnman& connman, AddrMan& addrman,\n                                                BanMan* banman, ChainstateManager& chainman,\n                                                CTxMemPool& pool, bool ignore_incoming_txs)\n {\n     return std::make_unique<PeerManagerImpl>(chainparams, connman, addrman, banman, chainman, pool, ignore_incoming_txs);\n }\n \n-PeerManagerImpl::PeerManagerImpl(const CChainParams& chainparams, CConnman& connman, CAddrMan& addrman,\n+PeerManagerImpl::PeerManagerImpl(const CChainParams& chainparams, CConnman& connman, AddrMan& addrman,\n                                  BanMan* banman, ChainstateManager& chainman,\n                                  CTxMemPool& pool, bool ignore_incoming_txs)\n     : m_chainparams(chainparams),\n@@ -2653,7 +2653,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             // table is also potentially detrimental because new-table entries\n             // are subject to eviction in the event of addrman collisions.  We\n             // mitigate the information-leak by never calling\n-            // CAddrMan::Connected() on block-relay-only peers; see\n+            // AddrMan::Connected() on block-relay-only peers; see\n             // FinalizeNode().\n             //\n             // This moves an address from New to Tried table in Addrman,"
      },
      {
        "sha": "27bc40687a0597a0ff6b454af2524ea1a0a73079",
        "filename": "src/net_processing.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dd8f7f250095e58bbf4cd4effb481b52143bd1ed/src/net_processing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dd8f7f250095e58bbf4cd4effb481b52143bd1ed/src/net_processing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.h?ref=dd8f7f250095e58bbf4cd4effb481b52143bd1ed",
        "patch": "@@ -9,7 +9,7 @@\n #include <net.h>\n #include <validationinterface.h>\n \n-class CAddrMan;\n+class AddrMan;\n class CChainParams;\n class CTxMemPool;\n class ChainstateManager;\n@@ -37,7 +37,7 @@ struct CNodeStateStats {\n class PeerManager : public CValidationInterface, public NetEventsInterface\n {\n public:\n-    static std::unique_ptr<PeerManager> make(const CChainParams& chainparams, CConnman& connman, CAddrMan& addrman,\n+    static std::unique_ptr<PeerManager> make(const CChainParams& chainparams, CConnman& connman, AddrMan& addrman,\n                                              BanMan* banman, ChainstateManager& chainman,\n                                              CTxMemPool& pool, bool ignore_incoming_txs);\n     virtual ~PeerManager() { }"
      },
      {
        "sha": "f9fff5a6d5e6a68f1db6bf8663fbc199d2668305",
        "filename": "src/netaddress.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dd8f7f250095e58bbf4cd4effb481b52143bd1ed/src/netaddress.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dd8f7f250095e58bbf4cd4effb481b52143bd1ed/src/netaddress.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.cpp?ref=dd8f7f250095e58bbf4cd4effb481b52143bd1ed",
        "patch": "@@ -165,7 +165,7 @@ void CNetAddr::SetLegacyIPv6(Span<const uint8_t> ipv6)\n }\n \n /**\n- * Create an \"internal\" address that represents a name or FQDN. CAddrMan uses\n+ * Create an \"internal\" address that represents a name or FQDN. AddrMan uses\n  * these fake addresses to keep track of which DNS seeds were used.\n  * @returns Whether or not the operation was successful.\n  * @see NET_INTERNAL, INTERNAL_IN_IPV6_PREFIX, CNetAddr::IsInternal(), CNetAddr::IsRFC4193()"
      },
      {
        "sha": "66c8c48f08a07dcffcd45cc57b401695b7f97905",
        "filename": "src/netaddress.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dd8f7f250095e58bbf4cd4effb481b52143bd1ed/src/netaddress.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dd8f7f250095e58bbf4cd4effb481b52143bd1ed/src/netaddress.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.h?ref=dd8f7f250095e58bbf4cd4effb481b52143bd1ed",
        "patch": "@@ -62,7 +62,7 @@ enum Network {\n     NET_CJDNS,\n \n     /// A set of addresses that represent the hash of a string or FQDN. We use\n-    /// them in CAddrMan to keep track of which DNS seeds were used.\n+    /// them in AddrMan to keep track of which DNS seeds were used.\n     NET_INTERNAL,\n \n     /// Dummy value to indicate the number of NET_* constants."
      },
      {
        "sha": "26873345b46724752dff4f35c47522486c046805",
        "filename": "src/node/context.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dd8f7f250095e58bbf4cd4effb481b52143bd1ed/src/node/context.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dd8f7f250095e58bbf4cd4effb481b52143bd1ed/src/node/context.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/context.h?ref=dd8f7f250095e58bbf4cd4effb481b52143bd1ed",
        "patch": "@@ -12,7 +12,7 @@\n \n class ArgsManager;\n class BanMan;\n-class CAddrMan;\n+class AddrMan;\n class CBlockPolicyEstimator;\n class CConnman;\n class CScheduler;\n@@ -39,7 +39,7 @@ class WalletClient;\n struct NodeContext {\n     //! Init interface for initializing current process and connecting to other processes.\n     interfaces::Init* init{nullptr};\n-    std::unique_ptr<CAddrMan> addrman;\n+    std::unique_ptr<AddrMan> addrman;\n     std::unique_ptr<CConnman> connman;\n     std::unique_ptr<CTxMemPool> mempool;\n     std::unique_ptr<CBlockPolicyEstimator> fee_estimator;"
      },
      {
        "sha": "d532eed1da33b90794e977e75009d362477e2ede",
        "filename": "src/test/addrman_tests.cpp",
        "status": "modified",
        "additions": 42,
        "deletions": 42,
        "changes": 84,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dd8f7f250095e58bbf4cd4effb481b52143bd1ed/src/test/addrman_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dd8f7f250095e58bbf4cd4effb481b52143bd1ed/src/test/addrman_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/addrman_tests.cpp?ref=dd8f7f250095e58bbf4cd4effb481b52143bd1ed",
        "patch": "@@ -22,26 +22,26 @@\n \n using namespace std::literals;\n \n-class CAddrManSerializationMock : public CAddrMan\n+class AddrManSerializationMock : public AddrMan\n {\n public:\n     virtual void Serialize(CDataStream& s) const = 0;\n \n-    CAddrManSerializationMock()\n-        : CAddrMan(/* asmap */ std::vector<bool>(), /* deterministic */ true, /* consistency_check_ratio */ 100)\n+    AddrManSerializationMock()\n+        : AddrMan(/* asmap */ std::vector<bool>(), /* deterministic */ true, /* consistency_check_ratio */ 100)\n     {}\n };\n \n-class CAddrManUncorrupted : public CAddrManSerializationMock\n+class AddrManUncorrupted : public AddrManSerializationMock\n {\n public:\n     void Serialize(CDataStream& s) const override\n     {\n-        CAddrMan::Serialize(s);\n+        AddrMan::Serialize(s);\n     }\n };\n \n-class CAddrManCorrupted : public CAddrManSerializationMock\n+class AddrManCorrupted : public AddrManSerializationMock\n {\n public:\n     void Serialize(CDataStream& s) const override\n@@ -67,7 +67,7 @@ class CAddrManCorrupted : public CAddrManSerializationMock\n     }\n };\n \n-static CDataStream AddrmanToStream(const CAddrManSerializationMock& _addrman)\n+static CDataStream AddrmanToStream(const AddrManSerializationMock& _addrman)\n {\n     CDataStream ssPeersIn(SER_DISK, CLIENT_VERSION);\n     ssPeersIn << Params().MessageStart();\n@@ -77,14 +77,14 @@ static CDataStream AddrmanToStream(const CAddrManSerializationMock& _addrman)\n     return CDataStream(vchData, SER_DISK, CLIENT_VERSION);\n }\n \n-class CAddrManTest : public CAddrMan\n+class AddrManTest : public AddrMan\n {\n private:\n     bool deterministic;\n public:\n-    explicit CAddrManTest(bool makeDeterministic = true,\n+    explicit AddrManTest(bool makeDeterministic = true,\n                           std::vector<bool> asmap = std::vector<bool>())\n-        : CAddrMan(asmap, makeDeterministic, /* consistency_check_ratio */ 100)\n+        : AddrMan(asmap, makeDeterministic, /* consistency_check_ratio */ 100)\n     {\n         deterministic = makeDeterministic;\n     }\n@@ -166,7 +166,7 @@ BOOST_FIXTURE_TEST_SUITE(addrman_tests, BasicTestingSetup)\n \n BOOST_AUTO_TEST_CASE(addrman_simple)\n {\n-    auto addrman = std::make_unique<CAddrManTest>();\n+    auto addrman = std::make_unique<AddrManTest>();\n \n     CNetAddr source = ResolveIP(\"252.2.2.2\");\n \n@@ -200,7 +200,7 @@ BOOST_AUTO_TEST_CASE(addrman_simple)\n     BOOST_CHECK(addrman->size() >= 1);\n \n     // Test: reset addrman and test AddrMan::Add multiple addresses works as expected\n-    addrman = std::make_unique<CAddrManTest>();\n+    addrman = std::make_unique<AddrManTest>();\n     std::vector<CAddress> vAddr;\n     vAddr.push_back(CAddress(ResolveService(\"250.1.1.3\", 8333), NODE_NONE));\n     vAddr.push_back(CAddress(ResolveService(\"250.1.1.4\", 8333), NODE_NONE));\n@@ -210,7 +210,7 @@ BOOST_AUTO_TEST_CASE(addrman_simple)\n \n BOOST_AUTO_TEST_CASE(addrman_ports)\n {\n-    CAddrManTest addrman;\n+    AddrManTest addrman;\n \n     CNetAddr source = ResolveIP(\"252.2.2.2\");\n \n@@ -239,7 +239,7 @@ BOOST_AUTO_TEST_CASE(addrman_ports)\n \n BOOST_AUTO_TEST_CASE(addrman_select)\n {\n-    CAddrManTest addrman;\n+    AddrManTest addrman;\n \n     CNetAddr source = ResolveIP(\"252.2.2.2\");\n \n@@ -298,7 +298,7 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n \n BOOST_AUTO_TEST_CASE(addrman_new_collisions)\n {\n-    CAddrManTest addrman;\n+    AddrManTest addrman;\n \n     CNetAddr source = ResolveIP(\"252.2.2.2\");\n \n@@ -327,7 +327,7 @@ BOOST_AUTO_TEST_CASE(addrman_new_collisions)\n \n BOOST_AUTO_TEST_CASE(addrman_tried_collisions)\n {\n-    CAddrManTest addrman;\n+    AddrManTest addrman;\n \n     CNetAddr source = ResolveIP(\"252.2.2.2\");\n \n@@ -357,7 +357,7 @@ BOOST_AUTO_TEST_CASE(addrman_tried_collisions)\n \n BOOST_AUTO_TEST_CASE(addrman_find)\n {\n-    CAddrManTest addrman;\n+    AddrManTest addrman;\n \n     BOOST_CHECK_EQUAL(addrman.size(), 0U);\n \n@@ -390,7 +390,7 @@ BOOST_AUTO_TEST_CASE(addrman_find)\n \n BOOST_AUTO_TEST_CASE(addrman_create)\n {\n-    CAddrManTest addrman;\n+    AddrManTest addrman;\n \n     BOOST_CHECK_EQUAL(addrman.size(), 0U);\n \n@@ -410,7 +410,7 @@ BOOST_AUTO_TEST_CASE(addrman_create)\n \n BOOST_AUTO_TEST_CASE(addrman_delete)\n {\n-    CAddrManTest addrman;\n+    AddrManTest addrman;\n \n     BOOST_CHECK_EQUAL(addrman.size(), 0U);\n \n@@ -430,7 +430,7 @@ BOOST_AUTO_TEST_CASE(addrman_delete)\n \n BOOST_AUTO_TEST_CASE(addrman_getaddr)\n {\n-    CAddrManTest addrman;\n+    AddrManTest addrman;\n \n     // Test: Sanity check, GetAddr should never return anything if addrman\n     //  is empty.\n@@ -490,7 +490,7 @@ BOOST_AUTO_TEST_CASE(addrman_getaddr)\n \n BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket_legacy)\n {\n-    CAddrManTest addrman;\n+    AddrManTest addrman;\n \n     CAddress addr1 = CAddress(ResolveService(\"250.1.1.1\", 8333), NODE_NONE);\n     CAddress addr2 = CAddress(ResolveService(\"250.1.1.1\", 9999), NODE_NONE);\n@@ -545,7 +545,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket_legacy)\n \n BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket_legacy)\n {\n-    CAddrManTest addrman;\n+    AddrManTest addrman;\n \n     CAddress addr1 = CAddress(ResolveService(\"250.1.2.1\", 8333), NODE_NONE);\n     CAddress addr2 = CAddress(ResolveService(\"250.1.2.1\", 9999), NODE_NONE);\n@@ -623,7 +623,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket_legacy)\n // 101.8.0.0/16 AS8\n BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket)\n {\n-    CAddrManTest addrman;\n+    AddrManTest addrman;\n \n     CAddress addr1 = CAddress(ResolveService(\"250.1.1.1\", 8333), NODE_NONE);\n     CAddress addr2 = CAddress(ResolveService(\"250.1.1.1\", 9999), NODE_NONE);\n@@ -678,7 +678,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket)\n \n BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n {\n-    CAddrManTest addrman;\n+    AddrManTest addrman;\n \n     CAddress addr1 = CAddress(ResolveService(\"250.1.2.1\", 8333), NODE_NONE);\n     CAddress addr2 = CAddress(ResolveService(\"250.1.2.1\", 9999), NODE_NONE);\n@@ -760,9 +760,9 @@ BOOST_AUTO_TEST_CASE(addrman_serialization)\n {\n     std::vector<bool> asmap1 = FromBytes(asmap_raw, sizeof(asmap_raw) * 8);\n \n-    auto addrman_asmap1 = std::make_unique<CAddrManTest>(true, asmap1);\n-    auto addrman_asmap1_dup = std::make_unique<CAddrManTest>(true, asmap1);\n-    auto addrman_noasmap = std::make_unique<CAddrManTest>();\n+    auto addrman_asmap1 = std::make_unique<AddrManTest>(true, asmap1);\n+    auto addrman_asmap1_dup = std::make_unique<AddrManTest>(true, asmap1);\n+    auto addrman_noasmap = std::make_unique<AddrManTest>();\n     CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n \n     CAddress addr = CAddress(ResolveService(\"250.1.1.1\"), NODE_NONE);\n@@ -792,8 +792,8 @@ BOOST_AUTO_TEST_CASE(addrman_serialization)\n     BOOST_CHECK(bucketAndEntry_asmap1.second != bucketAndEntry_noasmap.second);\n \n     // deserializing non-asmaped peers.dat to asmaped addrman\n-    addrman_asmap1 = std::make_unique<CAddrManTest>(true, asmap1);\n-    addrman_noasmap = std::make_unique<CAddrManTest>();\n+    addrman_asmap1 = std::make_unique<AddrManTest>(true, asmap1);\n+    addrman_noasmap = std::make_unique<AddrManTest>();\n     addrman_noasmap->Add({addr}, default_source);\n     stream << *addrman_noasmap;\n     stream >> *addrman_asmap1;\n@@ -804,8 +804,8 @@ BOOST_AUTO_TEST_CASE(addrman_serialization)\n     BOOST_CHECK(bucketAndEntry_asmap1_deser.second == bucketAndEntry_asmap1_dup.second);\n \n     // used to map to different buckets, now maps to the same bucket.\n-    addrman_asmap1 = std::make_unique<CAddrManTest>(true, asmap1);\n-    addrman_noasmap = std::make_unique<CAddrManTest>();\n+    addrman_asmap1 = std::make_unique<AddrManTest>(true, asmap1);\n+    addrman_noasmap = std::make_unique<AddrManTest>();\n     CAddress addr1 = CAddress(ResolveService(\"250.1.1.1\"), NODE_NONE);\n     CAddress addr2 = CAddress(ResolveService(\"250.2.1.1\"), NODE_NONE);\n     addrman_noasmap->Add({addr, addr2}, default_source);\n@@ -825,7 +825,7 @@ BOOST_AUTO_TEST_CASE(remove_invalid)\n {\n     // Confirm that invalid addresses are ignored in unserialization.\n \n-    auto addrman = std::make_unique<CAddrManTest>();\n+    auto addrman = std::make_unique<AddrManTest>();\n     CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n \n     const CAddress new1{ResolveService(\"5.5.5.5\"), NODE_NONE};\n@@ -857,14 +857,14 @@ BOOST_AUTO_TEST_CASE(remove_invalid)\n     BOOST_REQUIRE(pos + sizeof(tried2_raw_replacement) <= stream.size());\n     memcpy(stream.data() + pos, tried2_raw_replacement, sizeof(tried2_raw_replacement));\n \n-    addrman = std::make_unique<CAddrManTest>();\n+    addrman = std::make_unique<AddrManTest>();\n     stream >> *addrman;\n     BOOST_CHECK_EQUAL(addrman->size(), 2);\n }\n \n BOOST_AUTO_TEST_CASE(addrman_selecttriedcollision)\n {\n-    CAddrManTest addrman;\n+    AddrManTest addrman;\n \n     BOOST_CHECK(addrman.size() == 0);\n \n@@ -896,7 +896,7 @@ BOOST_AUTO_TEST_CASE(addrman_selecttriedcollision)\n \n BOOST_AUTO_TEST_CASE(addrman_noevict)\n {\n-    CAddrManTest addrman;\n+    AddrManTest addrman;\n \n     // Add 35 addresses.\n     CNetAddr source = ResolveIP(\"252.2.2.2\");\n@@ -952,7 +952,7 @@ BOOST_AUTO_TEST_CASE(addrman_noevict)\n \n BOOST_AUTO_TEST_CASE(addrman_evictionworks)\n {\n-    CAddrManTest addrman;\n+    AddrManTest addrman;\n \n     BOOST_CHECK(addrman.size() == 0);\n \n@@ -1006,7 +1006,7 @@ BOOST_AUTO_TEST_CASE(addrman_evictionworks)\n \n BOOST_AUTO_TEST_CASE(load_addrman)\n {\n-    CAddrManUncorrupted addrmanUncorrupted;\n+    AddrManUncorrupted addrmanUncorrupted;\n \n     CService addr1, addr2, addr3;\n     BOOST_CHECK(Lookup(\"250.7.1.1\", addr1, 8333, false));\n@@ -1025,7 +1025,7 @@ BOOST_AUTO_TEST_CASE(load_addrman)\n     // Test that the de-serialization does not throw an exception.\n     CDataStream ssPeers1 = AddrmanToStream(addrmanUncorrupted);\n     bool exceptionThrown = false;\n-    CAddrMan addrman1(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 100);\n+    AddrMan addrman1(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 100);\n \n     BOOST_CHECK(addrman1.size() == 0);\n     try {\n@@ -1042,7 +1042,7 @@ BOOST_AUTO_TEST_CASE(load_addrman)\n     // Test that ReadFromStream creates an addrman with the correct number of addrs.\n     CDataStream ssPeers2 = AddrmanToStream(addrmanUncorrupted);\n \n-    CAddrMan addrman2(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 100);\n+    AddrMan addrman2(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 100);\n     BOOST_CHECK(addrman2.size() == 0);\n     ReadFromStream(addrman2, ssPeers2);\n     BOOST_CHECK(addrman2.size() == 3);\n@@ -1051,12 +1051,12 @@ BOOST_AUTO_TEST_CASE(load_addrman)\n \n BOOST_AUTO_TEST_CASE(load_addrman_corrupted)\n {\n-    CAddrManCorrupted addrmanCorrupted;\n+    AddrManCorrupted addrmanCorrupted;\n \n     // Test that the de-serialization of corrupted addrman throws an exception.\n     CDataStream ssPeers1 = AddrmanToStream(addrmanCorrupted);\n     bool exceptionThrown = false;\n-    CAddrMan addrman1(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 100);\n+    AddrMan addrman1(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 100);\n     BOOST_CHECK(addrman1.size() == 0);\n     try {\n         unsigned char pchMsgTmp[4];\n@@ -1072,7 +1072,7 @@ BOOST_AUTO_TEST_CASE(load_addrman_corrupted)\n     // Test that ReadFromStream fails if peers.dat is corrupt\n     CDataStream ssPeers2 = AddrmanToStream(addrmanCorrupted);\n \n-    CAddrMan addrman2(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 100);\n+    AddrMan addrman2(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 100);\n     BOOST_CHECK(addrman2.size() == 0);\n     BOOST_CHECK_THROW(ReadFromStream(addrman2, ssPeers2), std::ios_base::failure);\n }"
      },
      {
        "sha": "d68002667ac58fe0ec15a478f9b0fe8c424805ff",
        "filename": "src/test/fuzz/addrman.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 11,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dd8f7f250095e58bbf4cd4effb481b52143bd1ed/src/test/fuzz/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dd8f7f250095e58bbf4cd4effb481b52143bd1ed/src/test/fuzz/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/addrman.cpp?ref=dd8f7f250095e58bbf4cd4effb481b52143bd1ed",
        "patch": "@@ -28,20 +28,20 @@ FUZZ_TARGET_INIT(data_stream_addr_man, initialize_addrman)\n {\n     FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n     CDataStream data_stream = ConsumeDataStream(fuzzed_data_provider);\n-    CAddrMan addr_man(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n+    AddrMan addr_man(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n     try {\n         ReadFromStream(addr_man, data_stream);\n     } catch (const std::exception&) {\n     }\n }\n \n-class CAddrManDeterministic : public CAddrMan\n+class AddrManDeterministic : public AddrMan\n {\n public:\n     FuzzedDataProvider& m_fuzzed_data_provider;\n \n-    explicit CAddrManDeterministic(std::vector<bool> asmap, FuzzedDataProvider& fuzzed_data_provider)\n-        : CAddrMan(std::move(asmap), /* deterministic */ true, /* consistency_check_ratio */ 0)\n+    explicit AddrManDeterministic(std::vector<bool> asmap, FuzzedDataProvider& fuzzed_data_provider)\n+        : AddrMan(std::move(asmap), /* deterministic */ true, /* consistency_check_ratio */ 0)\n         , m_fuzzed_data_provider(fuzzed_data_provider)\n     {\n         WITH_LOCK(m_impl->cs, m_impl->insecure_rand = FastRandomContext{ConsumeUInt256(fuzzed_data_provider)});\n@@ -130,7 +130,7 @@ class CAddrManDeterministic : public CAddrMan\n      * - vvNew entries refer to the same addresses\n      * - vvTried entries refer to the same addresses\n      */\n-    bool operator==(const CAddrManDeterministic& other)\n+    bool operator==(const AddrManDeterministic& other)\n     {\n         LOCK2(m_impl->cs, other.m_impl->cs);\n \n@@ -223,7 +223,7 @@ FUZZ_TARGET_INIT(addrman, initialize_addrman)\n     FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n     SetMockTime(ConsumeTime(fuzzed_data_provider));\n     std::vector<bool> asmap = ConsumeAsmap(fuzzed_data_provider);\n-    auto addr_man_ptr = std::make_unique<CAddrManDeterministic>(asmap, fuzzed_data_provider);\n+    auto addr_man_ptr = std::make_unique<AddrManDeterministic>(asmap, fuzzed_data_provider);\n     if (fuzzed_data_provider.ConsumeBool()) {\n         const std::vector<uint8_t> serialized_data{ConsumeRandomLengthByteVector(fuzzed_data_provider)};\n         CDataStream ds(serialized_data, SER_DISK, INIT_PROTO_VERSION);\n@@ -232,10 +232,10 @@ FUZZ_TARGET_INIT(addrman, initialize_addrman)\n         try {\n             ds >> *addr_man_ptr;\n         } catch (const std::ios_base::failure&) {\n-            addr_man_ptr = std::make_unique<CAddrManDeterministic>(asmap, fuzzed_data_provider);\n+            addr_man_ptr = std::make_unique<AddrManDeterministic>(asmap, fuzzed_data_provider);\n         }\n     }\n-    CAddrManDeterministic& addr_man = *addr_man_ptr;\n+    AddrManDeterministic& addr_man = *addr_man_ptr;\n     while (fuzzed_data_provider.ConsumeBool()) {\n         CallOneOf(\n             fuzzed_data_provider,\n@@ -284,7 +284,7 @@ FUZZ_TARGET_INIT(addrman, initialize_addrman)\n                 }\n             });\n     }\n-    const CAddrMan& const_addr_man{addr_man};\n+    const AddrMan& const_addr_man{addr_man};\n     (void)const_addr_man.GetAddr(\n         /* max_addresses */ fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, 4096),\n         /* max_pct */ fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, 4096),\n@@ -302,8 +302,8 @@ FUZZ_TARGET_INIT(addrman_serdeser, initialize_addrman)\n     SetMockTime(ConsumeTime(fuzzed_data_provider));\n \n     std::vector<bool> asmap = ConsumeAsmap(fuzzed_data_provider);\n-    CAddrManDeterministic addr_man1{asmap, fuzzed_data_provider};\n-    CAddrManDeterministic addr_man2{asmap, fuzzed_data_provider};\n+    AddrManDeterministic addr_man1{asmap, fuzzed_data_provider};\n+    AddrManDeterministic addr_man2{asmap, fuzzed_data_provider};\n \n     CDataStream data_stream(SER_NETWORK, PROTOCOL_VERSION);\n "
      },
      {
        "sha": "d381345a0d4d3d4376c70d904f496d497e3d007c",
        "filename": "src/test/fuzz/connman.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dd8f7f250095e58bbf4cd4effb481b52143bd1ed/src/test/fuzz/connman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dd8f7f250095e58bbf4cd4effb481b52143bd1ed/src/test/fuzz/connman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/connman.cpp?ref=dd8f7f250095e58bbf4cd4effb481b52143bd1ed",
        "patch": "@@ -25,7 +25,7 @@ FUZZ_TARGET_INIT(connman, initialize_connman)\n {\n     FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n     SetMockTime(ConsumeTime(fuzzed_data_provider));\n-    CAddrMan addrman(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n+    AddrMan addrman(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n     CConnman connman{fuzzed_data_provider.ConsumeIntegral<uint64_t>(), fuzzed_data_provider.ConsumeIntegral<uint64_t>(), addrman, fuzzed_data_provider.ConsumeBool()};\n     CNetAddr random_netaddr;\n     CNode random_node = ConsumeNode(fuzzed_data_provider);"
      },
      {
        "sha": "b1a07b482e94e23e5622a036234ccdc6add96867",
        "filename": "src/test/fuzz/deserialize.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dd8f7f250095e58bbf4cd4effb481b52143bd1ed/src/test/fuzz/deserialize.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dd8f7f250095e58bbf4cd4effb481b52143bd1ed/src/test/fuzz/deserialize.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/deserialize.cpp?ref=dd8f7f250095e58bbf4cd4effb481b52143bd1ed",
        "patch": "@@ -189,7 +189,7 @@ FUZZ_TARGET_DESERIALIZE(blockmerkleroot, {\n     BlockMerkleRoot(block, &mutated);\n })\n FUZZ_TARGET_DESERIALIZE(addrman_deserialize, {\n-    CAddrMan am(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n+    AddrMan am(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n     DeserializeFromFuzzingInput(buffer, am);\n })\n FUZZ_TARGET_DESERIALIZE(blockheader_deserialize, {"
      },
      {
        "sha": "ebefa9974e773e41c476b02d68d6ba828272e9a4",
        "filename": "src/test/util/setup_common.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dd8f7f250095e58bbf4cd4effb481b52143bd1ed/src/test/util/setup_common.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dd8f7f250095e58bbf4cd4effb481b52143bd1ed/src/test/util/setup_common.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util/setup_common.cpp?ref=dd8f7f250095e58bbf4cd4effb481b52143bd1ed",
        "patch": "@@ -192,7 +192,7 @@ TestingSetup::TestingSetup(const std::string& chainName, const std::vector<const\n         throw std::runtime_error(strprintf(\"ActivateBestChain failed. (%s)\", state.ToString()));\n     }\n \n-    m_node.addrman = std::make_unique<CAddrMan>(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n+    m_node.addrman = std::make_unique<AddrMan>(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n     m_node.banman = std::make_unique<BanMan>(m_args.GetDataDirBase() / \"banlist\", nullptr, DEFAULT_MISBEHAVING_BANTIME);\n     m_node.connman = std::make_unique<CConnman>(0x1337, 0x1337, *m_node.addrman); // Deterministic randomness for tests.\n     m_node.peerman = PeerManager::make(chainparams, *m_node.connman, *m_node.addrman,"
      },
      {
        "sha": "93d50c13692176f72ecdc17d1ef1dc3dffc2a354",
        "filename": "test/functional/feature_addrman.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dd8f7f250095e58bbf4cd4effb481b52143bd1ed/test/functional/feature_addrman.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dd8f7f250095e58bbf4cd4effb481b52143bd1ed/test/functional/feature_addrman.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_addrman.py?ref=dd8f7f250095e58bbf4cd4effb481b52143bd1ed",
        "patch": "@@ -109,15 +109,15 @@ def run_test(self):\n         self.stop_node(0)\n         write_addrman(peers_dat, len_tried=-1)\n         self.nodes[0].assert_start_raises_init_error(\n-            expected_msg=init_error(\"Corrupt CAddrMan serialization: nTried=-1, should be in \\\\[0, 16384\\\\]:.*\"),\n+            expected_msg=init_error(\"Corrupt AddrMan serialization: nTried=-1, should be in \\\\[0, 16384\\\\]:.*\"),\n             match=ErrorMatch.FULL_REGEX,\n         )\n \n         self.log.info(\"Check that corrupt addrman cannot be read (len_new)\")\n         self.stop_node(0)\n         write_addrman(peers_dat, len_new=-1)\n         self.nodes[0].assert_start_raises_init_error(\n-            expected_msg=init_error(\"Corrupt CAddrMan serialization: nNew=-1, should be in \\\\[0, 65536\\\\]:.*\"),\n+            expected_msg=init_error(\"Corrupt AddrMan serialization: nNew=-1, should be in \\\\[0, 65536\\\\]:.*\"),\n             match=ErrorMatch.FULL_REGEX,\n         )\n "
      }
    ]
  },
  {
    "sha": "375750387e35ed751d1f5ab48860bdec93977f64",
    "node_id": "C_kwDOABII59oAKDM3NTc1MDM4N2UzNWVkNzUxZDFmNWFiNDg4NjBiZGVjOTM5NzdmNjQ",
    "commit": {
      "author": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2021-09-11T00:33:25Z"
      },
      "committer": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2021-09-29T02:21:10Z"
      },
      "message": "scripted-diff: Rename CAddrInfo to AddrInfo\n\n-BEGIN VERIFY SCRIPT-\ngit grep -l CAddrInfo src/ | xargs sed -i 's/CAddrInfo/AddrInfo/g'\n-END VERIFY SCRIPT-",
      "tree": {
        "sha": "e5dee4689311a2f47995e9a0a166dc5f454fd223",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e5dee4689311a2f47995e9a0a166dc5f454fd223"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/375750387e35ed751d1f5ab48860bdec93977f64",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/375750387e35ed751d1f5ab48860bdec93977f64",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/375750387e35ed751d1f5ab48860bdec93977f64",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/375750387e35ed751d1f5ab48860bdec93977f64/comments",
    "author": {
      "login": "amitiuttarwar",
      "id": 1500952,
      "node_id": "MDQ6VXNlcjE1MDA5NTI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/amitiuttarwar",
      "html_url": "https://github.com/amitiuttarwar",
      "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
      "following_url": "https://api.github.com/users/amitiuttarwar/following{/other_user}",
      "gists_url": "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
      "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
      "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
      "events_url": "https://api.github.com/users/amitiuttarwar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "amitiuttarwar",
      "id": 1500952,
      "node_id": "MDQ6VXNlcjE1MDA5NTI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/amitiuttarwar",
      "html_url": "https://github.com/amitiuttarwar",
      "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
      "following_url": "https://api.github.com/users/amitiuttarwar/following{/other_user}",
      "gists_url": "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
      "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
      "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
      "events_url": "https://api.github.com/users/amitiuttarwar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "dd8f7f250095e58bbf4cd4effb481b52143bd1ed",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dd8f7f250095e58bbf4cd4effb481b52143bd1ed",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/dd8f7f250095e58bbf4cd4effb481b52143bd1ed"
      }
    ],
    "stats": {
      "total": 154,
      "additions": 77,
      "deletions": 77
    },
    "files": [
      {
        "sha": "c015026cbc2129a3cb013e7e1b79fb293f1f292e",
        "filename": "src/addrman.cpp",
        "status": "modified",
        "additions": 35,
        "deletions": 35,
        "changes": 70,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/375750387e35ed751d1f5ab48860bdec93977f64/src/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/375750387e35ed751d1f5ab48860bdec93977f64/src/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.cpp?ref=375750387e35ed751d1f5ab48860bdec93977f64",
        "patch": "@@ -41,7 +41,7 @@ static constexpr size_t ADDRMAN_SET_TRIED_COLLISION_SIZE{10};\n /** The maximum time we'll spend trying to resolve a tried table collision, in seconds */\n static constexpr int64_t ADDRMAN_TEST_WINDOW{40*60}; // 40 minutes\n \n-int CAddrInfo::GetTriedBucket(const uint256& nKey, const std::vector<bool> &asmap) const\n+int AddrInfo::GetTriedBucket(const uint256& nKey, const std::vector<bool> &asmap) const\n {\n     uint64_t hash1 = (CHashWriter(SER_GETHASH, 0) << nKey << GetKey()).GetCheapHash();\n     uint64_t hash2 = (CHashWriter(SER_GETHASH, 0) << nKey << GetGroup(asmap) << (hash1 % ADDRMAN_TRIED_BUCKETS_PER_GROUP)).GetCheapHash();\n@@ -51,7 +51,7 @@ int CAddrInfo::GetTriedBucket(const uint256& nKey, const std::vector<bool> &asma\n     return tried_bucket;\n }\n \n-int CAddrInfo::GetNewBucket(const uint256& nKey, const CNetAddr& src, const std::vector<bool> &asmap) const\n+int AddrInfo::GetNewBucket(const uint256& nKey, const CNetAddr& src, const std::vector<bool> &asmap) const\n {\n     std::vector<unsigned char> vchSourceGroupKey = src.GetGroup(asmap);\n     uint64_t hash1 = (CHashWriter(SER_GETHASH, 0) << nKey << GetGroup(asmap) << vchSourceGroupKey).GetCheapHash();\n@@ -62,13 +62,13 @@ int CAddrInfo::GetNewBucket(const uint256& nKey, const CNetAddr& src, const std:\n     return new_bucket;\n }\n \n-int CAddrInfo::GetBucketPosition(const uint256 &nKey, bool fNew, int nBucket) const\n+int AddrInfo::GetBucketPosition(const uint256 &nKey, bool fNew, int nBucket) const\n {\n     uint64_t hash1 = (CHashWriter(SER_GETHASH, 0) << nKey << (fNew ? uint8_t{'N'} : uint8_t{'K'}) << nBucket << GetKey()).GetCheapHash();\n     return hash1 % ADDRMAN_BUCKET_SIZE;\n }\n \n-bool CAddrInfo::IsTerrible(int64_t nNow) const\n+bool AddrInfo::IsTerrible(int64_t nNow) const\n {\n     if (nLastTry && nLastTry >= nNow - 60) // never remove things tried in the last minute\n         return false;\n@@ -88,7 +88,7 @@ bool CAddrInfo::IsTerrible(int64_t nNow) const\n     return false;\n }\n \n-double CAddrInfo::GetChance(int64_t nNow) const\n+double AddrInfo::GetChance(int64_t nNow) const\n {\n     double fChance = 1.0;\n     int64_t nSinceLastTry = std::max<int64_t>(nNow - nLastTry, 0);\n@@ -190,7 +190,7 @@ void AddrManImpl::Serialize(Stream& s_) const\n     int nIds = 0;\n     for (const auto& entry : mapInfo) {\n         mapUnkIds[entry.first] = nIds;\n-        const CAddrInfo &info = entry.second;\n+        const AddrInfo &info = entry.second;\n         if (info.nRefCount) {\n             assert(nIds != nNew); // this means nNew was wrong, oh ow\n             s << info;\n@@ -199,7 +199,7 @@ void AddrManImpl::Serialize(Stream& s_) const\n     }\n     nIds = 0;\n     for (const auto& entry : mapInfo) {\n-        const CAddrInfo &info = entry.second;\n+        const AddrInfo &info = entry.second;\n         if (info.fInTried) {\n             assert(nIds != nTried); // this means nTried was wrong, oh ow\n             s << info;\n@@ -283,7 +283,7 @@ void AddrManImpl::Unserialize(Stream& s_)\n \n     // Deserialize entries from the new table.\n     for (int n = 0; n < nNew; n++) {\n-        CAddrInfo &info = mapInfo[n];\n+        AddrInfo &info = mapInfo[n];\n         s >> info;\n         mapAddr[info] = n;\n         info.nRandomPos = vRandom.size();\n@@ -294,7 +294,7 @@ void AddrManImpl::Unserialize(Stream& s_)\n     // Deserialize entries from the tried table.\n     int nLost = 0;\n     for (int n = 0; n < nTried; n++) {\n-        CAddrInfo info;\n+        AddrInfo info;\n         s >> info;\n         int nKBucket = info.GetTriedBucket(nKey, m_asmap);\n         int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);\n@@ -351,7 +351,7 @@ void AddrManImpl::Unserialize(Stream& s_)\n     for (auto bucket_entry : bucket_entries) {\n         int bucket{bucket_entry.first};\n         const int entry_index{bucket_entry.second};\n-        CAddrInfo& info = mapInfo[entry_index];\n+        AddrInfo& info = mapInfo[entry_index];\n \n         // Don't store the entry in the new bucket if it's not a valid address for our addrman\n         if (!info.IsValid()) continue;\n@@ -401,7 +401,7 @@ void AddrManImpl::Unserialize(Stream& s_)\n     }\n }\n \n-CAddrInfo* AddrManImpl::Find(const CNetAddr& addr, int* pnId)\n+AddrInfo* AddrManImpl::Find(const CNetAddr& addr, int* pnId)\n {\n     AssertLockHeld(cs);\n \n@@ -416,12 +416,12 @@ CAddrInfo* AddrManImpl::Find(const CNetAddr& addr, int* pnId)\n     return nullptr;\n }\n \n-CAddrInfo* AddrManImpl::Create(const CAddress& addr, const CNetAddr& addrSource, int* pnId)\n+AddrInfo* AddrManImpl::Create(const CAddress& addr, const CNetAddr& addrSource, int* pnId)\n {\n     AssertLockHeld(cs);\n \n     int nId = nIdCount++;\n-    mapInfo[nId] = CAddrInfo(addr, addrSource);\n+    mapInfo[nId] = AddrInfo(addr, addrSource);\n     mapAddr[addr] = nId;\n     mapInfo[nId].nRandomPos = vRandom.size();\n     vRandom.push_back(nId);\n@@ -459,7 +459,7 @@ void AddrManImpl::Delete(int nId)\n     AssertLockHeld(cs);\n \n     assert(mapInfo.count(nId) != 0);\n-    CAddrInfo& info = mapInfo[nId];\n+    AddrInfo& info = mapInfo[nId];\n     assert(!info.fInTried);\n     assert(info.nRefCount == 0);\n \n@@ -477,7 +477,7 @@ void AddrManImpl::ClearNew(int nUBucket, int nUBucketPos)\n     // if there is an entry in the specified bucket, delete it.\n     if (vvNew[nUBucket][nUBucketPos] != -1) {\n         int nIdDelete = vvNew[nUBucket][nUBucketPos];\n-        CAddrInfo& infoDelete = mapInfo[nIdDelete];\n+        AddrInfo& infoDelete = mapInfo[nIdDelete];\n         assert(infoDelete.nRefCount > 0);\n         infoDelete.nRefCount--;\n         vvNew[nUBucket][nUBucketPos] = -1;\n@@ -487,7 +487,7 @@ void AddrManImpl::ClearNew(int nUBucket, int nUBucketPos)\n     }\n }\n \n-void AddrManImpl::MakeTried(CAddrInfo& info, int nId)\n+void AddrManImpl::MakeTried(AddrInfo& info, int nId)\n {\n     AssertLockHeld(cs);\n \n@@ -515,7 +515,7 @@ void AddrManImpl::MakeTried(CAddrInfo& info, int nId)\n         // find an item to evict\n         int nIdEvict = vvTried[nKBucket][nKBucketPos];\n         assert(mapInfo.count(nIdEvict) == 1);\n-        CAddrInfo& infoOld = mapInfo[nIdEvict];\n+        AddrInfo& infoOld = mapInfo[nIdEvict];\n \n         // Remove the to-be-evicted item from the tried set.\n         infoOld.fInTried = false;\n@@ -548,13 +548,13 @@ void AddrManImpl::Good_(const CService& addr, bool test_before_evict, int64_t nT\n \n     nLastGood = nTime;\n \n-    CAddrInfo* pinfo = Find(addr, &nId);\n+    AddrInfo* pinfo = Find(addr, &nId);\n \n     // if not found, bail out\n     if (!pinfo)\n         return;\n \n-    CAddrInfo& info = *pinfo;\n+    AddrInfo& info = *pinfo;\n \n     // check whether we are talking about the exact same CService (including same port)\n     if (info != addr)\n@@ -605,7 +605,7 @@ bool AddrManImpl::Add_(const CAddress& addr, const CNetAddr& source, int64_t nTi\n \n     bool fNew = false;\n     int nId;\n-    CAddrInfo* pinfo = Find(addr, &nId);\n+    AddrInfo* pinfo = Find(addr, &nId);\n \n     // Do not set a penalty for a source's self-announcement\n     if (addr == source) {\n@@ -652,7 +652,7 @@ bool AddrManImpl::Add_(const CAddress& addr, const CNetAddr& source, int64_t nTi\n     if (vvNew[nUBucket][nUBucketPos] != nId) {\n         bool fInsert = vvNew[nUBucket][nUBucketPos] == -1;\n         if (!fInsert) {\n-            CAddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];\n+            AddrInfo& infoExisting = mapInfo[vvNew[nUBucket][nUBucketPos]];\n             if (infoExisting.IsTerrible() || (infoExisting.nRefCount > 1 && pinfo->nRefCount == 0)) {\n                 // Overwrite the existing new table entry.\n                 fInsert = true;\n@@ -675,13 +675,13 @@ void AddrManImpl::Attempt_(const CService& addr, bool fCountFailure, int64_t nTi\n {\n     AssertLockHeld(cs);\n \n-    CAddrInfo* pinfo = Find(addr);\n+    AddrInfo* pinfo = Find(addr);\n \n     // if not found, bail out\n     if (!pinfo)\n         return;\n \n-    CAddrInfo& info = *pinfo;\n+    AddrInfo& info = *pinfo;\n \n     // check whether we are talking about the exact same CService (including same port)\n     if (info != addr)\n@@ -718,7 +718,7 @@ std::pair<CAddress, int64_t> AddrManImpl::Select_(bool newOnly) const\n             int nId = vvTried[nKBucket][nKBucketPos];\n             const auto it_found{mapInfo.find(nId)};\n             assert(it_found != mapInfo.end());\n-            const CAddrInfo& info{it_found->second};\n+            const AddrInfo& info{it_found->second};\n             if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n                 return {info, info.nLastTry};\n             }\n@@ -737,7 +737,7 @@ std::pair<CAddress, int64_t> AddrManImpl::Select_(bool newOnly) const\n             int nId = vvNew[nUBucket][nUBucketPos];\n             const auto it_found{mapInfo.find(nId)};\n             assert(it_found != mapInfo.end());\n-            const CAddrInfo& info{it_found->second};\n+            const AddrInfo& info{it_found->second};\n             if (insecure_rand.randbits(30) < fChanceFactor * info.GetChance() * (1 << 30)) {\n                 return {info, info.nLastTry};\n             }\n@@ -770,7 +770,7 @@ std::vector<CAddress> AddrManImpl::GetAddr_(size_t max_addresses, size_t max_pct\n         const auto it{mapInfo.find(vRandom[n])};\n         assert(it != mapInfo.end());\n \n-        const CAddrInfo& ai{it->second};\n+        const AddrInfo& ai{it->second};\n \n         // Filter by network (optional)\n         if (network != std::nullopt && ai.GetNetClass() != network) continue;\n@@ -788,13 +788,13 @@ void AddrManImpl::Connected_(const CService& addr, int64_t nTime)\n {\n     AssertLockHeld(cs);\n \n-    CAddrInfo* pinfo = Find(addr);\n+    AddrInfo* pinfo = Find(addr);\n \n     // if not found, bail out\n     if (!pinfo)\n         return;\n \n-    CAddrInfo& info = *pinfo;\n+    AddrInfo& info = *pinfo;\n \n     // check whether we are talking about the exact same CService (including same port)\n     if (info != addr)\n@@ -810,13 +810,13 @@ void AddrManImpl::SetServices_(const CService& addr, ServiceFlags nServices)\n {\n     AssertLockHeld(cs);\n \n-    CAddrInfo* pinfo = Find(addr);\n+    AddrInfo* pinfo = Find(addr);\n \n     // if not found, bail out\n     if (!pinfo)\n         return;\n \n-    CAddrInfo& info = *pinfo;\n+    AddrInfo& info = *pinfo;\n \n     // check whether we are talking about the exact same CService (including same port)\n     if (info != addr)\n@@ -839,7 +839,7 @@ void AddrManImpl::ResolveCollisions_()\n         if (mapInfo.count(id_new) != 1) {\n             erase_collision = true;\n         } else {\n-            CAddrInfo& info_new = mapInfo[id_new];\n+            AddrInfo& info_new = mapInfo[id_new];\n \n             // Which tried bucket to move the entry to.\n             int tried_bucket = info_new.GetTriedBucket(nKey, m_asmap);\n@@ -850,7 +850,7 @@ void AddrManImpl::ResolveCollisions_()\n \n                 // Get the to-be-evicted address that is being tested\n                 int id_old = vvTried[tried_bucket][tried_bucket_pos];\n-                CAddrInfo& info_old = mapInfo[id_old];\n+                AddrInfo& info_old = mapInfo[id_old];\n \n                 // Has successfully connected in last X hours\n                 if (GetAdjustedTime() - info_old.nLastSuccess < ADDRMAN_REPLACEMENT_HOURS*(60*60)) {\n@@ -905,13 +905,13 @@ std::pair<CAddress, int64_t> AddrManImpl::SelectTriedCollision_()\n         return {};\n     }\n \n-    const CAddrInfo& newInfo = mapInfo[id_new];\n+    const AddrInfo& newInfo = mapInfo[id_new];\n \n     // which tried bucket to move the entry to\n     int tried_bucket = newInfo.GetTriedBucket(nKey, m_asmap);\n     int tried_bucket_pos = newInfo.GetBucketPosition(nKey, false, tried_bucket);\n \n-    const CAddrInfo& info_old = mapInfo[vvTried[tried_bucket][tried_bucket_pos]];\n+    const AddrInfo& info_old = mapInfo[vvTried[tried_bucket][tried_bucket_pos]];\n     return {info_old, info_old.nLastTry};\n }\n \n@@ -944,7 +944,7 @@ int AddrManImpl::ForceCheckAddrman() const\n \n     for (const auto& entry : mapInfo) {\n         int n = entry.first;\n-        const CAddrInfo& info = entry.second;\n+        const AddrInfo& info = entry.second;\n         if (info.fInTried) {\n             if (!info.nLastSuccess)\n                 return -1;"
      },
      {
        "sha": "157f7d5da658c7e67a337afaa08903879307e711",
        "filename": "src/addrman_impl.h",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/375750387e35ed751d1f5ab48860bdec93977f64/src/addrman_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/375750387e35ed751d1f5ab48860bdec93977f64/src/addrman_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman_impl.h?ref=375750387e35ed751d1f5ab48860bdec93977f64",
        "patch": "@@ -33,7 +33,7 @@ static constexpr int ADDRMAN_BUCKET_SIZE{1 << ADDRMAN_BUCKET_SIZE_LOG2};\n /**\n  * Extended statistics about a CAddress\n  */\n-class CAddrInfo : public CAddress\n+class AddrInfo : public CAddress\n {\n public:\n     //! last try whatsoever by us (memory only)\n@@ -60,17 +60,17 @@ class CAddrInfo : public CAddress\n     //! position in vRandom\n     mutable int nRandomPos{-1};\n \n-    SERIALIZE_METHODS(CAddrInfo, obj)\n+    SERIALIZE_METHODS(AddrInfo, obj)\n     {\n         READWRITEAS(CAddress, obj);\n         READWRITE(obj.source, obj.nLastSuccess, obj.nAttempts);\n     }\n \n-    CAddrInfo(const CAddress &addrIn, const CNetAddr &addrSource) : CAddress(addrIn), source(addrSource)\n+    AddrInfo(const CAddress &addrIn, const CNetAddr &addrSource) : CAddress(addrIn), source(addrSource)\n     {\n     }\n \n-    CAddrInfo() : CAddress(), source()\n+    AddrInfo() : CAddress(), source()\n     {\n     }\n \n@@ -177,7 +177,7 @@ class AddrManImpl\n     int nIdCount GUARDED_BY(cs){0};\n \n     //! table with information about all nIds\n-    std::unordered_map<int, CAddrInfo> mapInfo GUARDED_BY(cs);\n+    std::unordered_map<int, AddrInfo> mapInfo GUARDED_BY(cs);\n \n     //! find an nId based on its network address\n     std::unordered_map<CNetAddr, int, CNetAddrHash> mapAddr GUARDED_BY(cs);\n@@ -225,10 +225,10 @@ class AddrManImpl\n     const std::vector<bool> m_asmap;\n \n     //! Find an entry.\n-    CAddrInfo* Find(const CNetAddr& addr, int *pnId = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+    AddrInfo* Find(const CNetAddr& addr, int *pnId = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n     //! Create a new entry and add it to the internal data structures mapInfo, mapAddr and vRandom.\n-    CAddrInfo* Create(const CAddress &addr, const CNetAddr &addrSource, int *pnId = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+    AddrInfo* Create(const CAddress &addr, const CNetAddr &addrSource, int *pnId = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n     //! Swap two elements in vRandom.\n     void SwapRandom(unsigned int nRandomPos1, unsigned int nRandomPos2) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n@@ -240,7 +240,7 @@ class AddrManImpl\n     void ClearNew(int nUBucket, int nUBucketPos) EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n     //! Move an entry from the \"new\" table(s) to the \"tried\" table\n-    void MakeTried(CAddrInfo& info, int nId) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+    void MakeTried(AddrInfo& info, int nId) EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n     void Good_(const CService &addr, bool test_before_evict, int64_t time) EXCLUSIVE_LOCKS_REQUIRED(cs);\n "
      },
      {
        "sha": "69ad7c7e24f31673306ad54021c5c71680f2694d",
        "filename": "src/test/addrman_tests.cpp",
        "status": "modified",
        "additions": 28,
        "deletions": 28,
        "changes": 56,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/375750387e35ed751d1f5ab48860bdec93977f64/src/test/addrman_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/375750387e35ed751d1f5ab48860bdec93977f64/src/test/addrman_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/addrman_tests.cpp?ref=375750387e35ed751d1f5ab48860bdec93977f64",
        "patch": "@@ -62,7 +62,7 @@ class AddrManCorrupted : public AddrManSerializationMock\n         CAddress addr = CAddress(serv, NODE_NONE);\n         CNetAddr resolved;\n         BOOST_CHECK(LookupHost(\"252.2.2.2\", resolved, false));\n-        CAddrInfo info = CAddrInfo(addr, resolved);\n+        AddrInfo info = AddrInfo(addr, resolved);\n         s << info;\n     }\n };\n@@ -89,13 +89,13 @@ class AddrManTest : public AddrMan\n         deterministic = makeDeterministic;\n     }\n \n-    CAddrInfo* Find(const CNetAddr& addr, int* pnId = nullptr)\n+    AddrInfo* Find(const CNetAddr& addr, int* pnId = nullptr)\n     {\n         LOCK(m_impl->cs);\n         return m_impl->Find(addr, pnId);\n     }\n \n-    CAddrInfo* Create(const CAddress& addr, const CNetAddr& addrSource, int* pnId = nullptr)\n+    AddrInfo* Create(const CAddress& addr, const CNetAddr& addrSource, int* pnId = nullptr)\n     {\n         LOCK(m_impl->cs);\n         return m_impl->Create(addr, addrSource, pnId);\n@@ -373,17 +373,17 @@ BOOST_AUTO_TEST_CASE(addrman_find)\n     BOOST_CHECK(addrman.Add({addr3}, source1));\n \n     // Test: ensure Find returns an IP matching what we searched on.\n-    CAddrInfo* info1 = addrman.Find(addr1);\n+    AddrInfo* info1 = addrman.Find(addr1);\n     BOOST_REQUIRE(info1);\n     BOOST_CHECK_EQUAL(info1->ToString(), \"250.1.2.1:8333\");\n \n     // Test 18; Find does not discriminate by port number.\n-    CAddrInfo* info2 = addrman.Find(addr2);\n+    AddrInfo* info2 = addrman.Find(addr2);\n     BOOST_REQUIRE(info2);\n     BOOST_CHECK_EQUAL(info2->ToString(), info1->ToString());\n \n     // Test: Find returns another IP matching what we searched on.\n-    CAddrInfo* info3 = addrman.Find(addr3);\n+    AddrInfo* info3 = addrman.Find(addr3);\n     BOOST_REQUIRE(info3);\n     BOOST_CHECK_EQUAL(info3->ToString(), \"251.255.2.1:8333\");\n }\n@@ -398,12 +398,12 @@ BOOST_AUTO_TEST_CASE(addrman_create)\n     CNetAddr source1 = ResolveIP(\"250.1.2.1\");\n \n     int nId;\n-    CAddrInfo* pinfo = addrman.Create(addr1, source1, &nId);\n+    AddrInfo* pinfo = addrman.Create(addr1, source1, &nId);\n \n     // Test: The result should be the same as the input addr.\n     BOOST_CHECK_EQUAL(pinfo->ToString(), \"250.1.2.1:8333\");\n \n-    CAddrInfo* info2 = addrman.Find(addr1);\n+    AddrInfo* info2 = addrman.Find(addr1);\n     BOOST_CHECK_EQUAL(info2->ToString(), \"250.1.2.1:8333\");\n }\n \n@@ -424,7 +424,7 @@ BOOST_AUTO_TEST_CASE(addrman_delete)\n     BOOST_CHECK_EQUAL(addrman.size(), 1U);\n     addrman.Delete(nId);\n     BOOST_CHECK_EQUAL(addrman.size(), 0U);\n-    CAddrInfo* info2 = addrman.Find(addr1);\n+    AddrInfo* info2 = addrman.Find(addr1);\n     BOOST_CHECK(info2 == nullptr);\n }\n \n@@ -498,7 +498,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket_legacy)\n     CNetAddr source1 = ResolveIP(\"250.1.1.1\");\n \n \n-    CAddrInfo info1 = CAddrInfo(addr1, source1);\n+    AddrInfo info1 = AddrInfo(addr1, source1);\n \n     uint256 nKey1 = (uint256)(CHashWriter(SER_GETHASH, 0) << 1).GetHash();\n     uint256 nKey2 = (uint256)(CHashWriter(SER_GETHASH, 0) << 2).GetHash();\n@@ -513,14 +513,14 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket_legacy)\n \n     // Test: Two addresses with same IP but different ports can map to\n     //  different buckets because they have different keys.\n-    CAddrInfo info2 = CAddrInfo(addr2, source1);\n+    AddrInfo info2 = AddrInfo(addr2, source1);\n \n     BOOST_CHECK(info1.GetKey() != info2.GetKey());\n     BOOST_CHECK(info1.GetTriedBucket(nKey1, asmap) != info2.GetTriedBucket(nKey1, asmap));\n \n     std::set<int> buckets;\n     for (int i = 0; i < 255; i++) {\n-        CAddrInfo infoi = CAddrInfo(\n+        AddrInfo infoi = AddrInfo(\n             CAddress(ResolveService(\"250.1.1.\" + ToString(i)), NODE_NONE),\n             ResolveIP(\"250.1.1.\" + ToString(i)));\n         int bucket = infoi.GetTriedBucket(nKey1, asmap);\n@@ -532,7 +532,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket_legacy)\n \n     buckets.clear();\n     for (int j = 0; j < 255; j++) {\n-        CAddrInfo infoj = CAddrInfo(\n+        AddrInfo infoj = AddrInfo(\n             CAddress(ResolveService(\"250.\" + ToString(j) + \".1.1\"), NODE_NONE),\n             ResolveIP(\"250.\" + ToString(j) + \".1.1\"));\n         int bucket = infoj.GetTriedBucket(nKey1, asmap);\n@@ -552,7 +552,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket_legacy)\n \n     CNetAddr source1 = ResolveIP(\"250.1.2.1\");\n \n-    CAddrInfo info1 = CAddrInfo(addr1, source1);\n+    AddrInfo info1 = AddrInfo(addr1, source1);\n \n     uint256 nKey1 = (uint256)(CHashWriter(SER_GETHASH, 0) << 1).GetHash();\n     uint256 nKey2 = (uint256)(CHashWriter(SER_GETHASH, 0) << 2).GetHash();\n@@ -568,13 +568,13 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket_legacy)\n     BOOST_CHECK(info1.GetNewBucket(nKey1, asmap) != info1.GetNewBucket(nKey2, asmap));\n \n     // Test: Ports should not affect bucket placement in the addr\n-    CAddrInfo info2 = CAddrInfo(addr2, source1);\n+    AddrInfo info2 = AddrInfo(addr2, source1);\n     BOOST_CHECK(info1.GetKey() != info2.GetKey());\n     BOOST_CHECK_EQUAL(info1.GetNewBucket(nKey1, asmap), info2.GetNewBucket(nKey1, asmap));\n \n     std::set<int> buckets;\n     for (int i = 0; i < 255; i++) {\n-        CAddrInfo infoi = CAddrInfo(\n+        AddrInfo infoi = AddrInfo(\n             CAddress(ResolveService(\"250.1.1.\" + ToString(i)), NODE_NONE),\n             ResolveIP(\"250.1.1.\" + ToString(i)));\n         int bucket = infoi.GetNewBucket(nKey1, asmap);\n@@ -586,7 +586,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket_legacy)\n \n     buckets.clear();\n     for (int j = 0; j < 4 * 255; j++) {\n-        CAddrInfo infoj = CAddrInfo(CAddress(\n+        AddrInfo infoj = AddrInfo(CAddress(\n                                         ResolveService(\n                                             ToString(250 + (j / 255)) + \".\" + ToString(j % 256) + \".1.1\"), NODE_NONE),\n             ResolveIP(\"251.4.1.1\"));\n@@ -599,7 +599,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket_legacy)\n \n     buckets.clear();\n     for (int p = 0; p < 255; p++) {\n-        CAddrInfo infoj = CAddrInfo(\n+        AddrInfo infoj = AddrInfo(\n             CAddress(ResolveService(\"250.1.1.1\"), NODE_NONE),\n             ResolveIP(\"250.\" + ToString(p) + \".1.1\"));\n         int bucket = infoj.GetNewBucket(nKey1, asmap);\n@@ -631,7 +631,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket)\n     CNetAddr source1 = ResolveIP(\"250.1.1.1\");\n \n \n-    CAddrInfo info1 = CAddrInfo(addr1, source1);\n+    AddrInfo info1 = AddrInfo(addr1, source1);\n \n     uint256 nKey1 = (uint256)(CHashWriter(SER_GETHASH, 0) << 1).GetHash();\n     uint256 nKey2 = (uint256)(CHashWriter(SER_GETHASH, 0) << 2).GetHash();\n@@ -646,14 +646,14 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket)\n \n     // Test: Two addresses with same IP but different ports can map to\n     //  different buckets because they have different keys.\n-    CAddrInfo info2 = CAddrInfo(addr2, source1);\n+    AddrInfo info2 = AddrInfo(addr2, source1);\n \n     BOOST_CHECK(info1.GetKey() != info2.GetKey());\n     BOOST_CHECK(info1.GetTriedBucket(nKey1, asmap) != info2.GetTriedBucket(nKey1, asmap));\n \n     std::set<int> buckets;\n     for (int j = 0; j < 255; j++) {\n-        CAddrInfo infoj = CAddrInfo(\n+        AddrInfo infoj = AddrInfo(\n             CAddress(ResolveService(\"101.\" + ToString(j) + \".1.1\"), NODE_NONE),\n             ResolveIP(\"101.\" + ToString(j) + \".1.1\"));\n         int bucket = infoj.GetTriedBucket(nKey1, asmap);\n@@ -665,7 +665,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket)\n \n     buckets.clear();\n     for (int j = 0; j < 255; j++) {\n-        CAddrInfo infoj = CAddrInfo(\n+        AddrInfo infoj = AddrInfo(\n             CAddress(ResolveService(\"250.\" + ToString(j) + \".1.1\"), NODE_NONE),\n             ResolveIP(\"250.\" + ToString(j) + \".1.1\"));\n         int bucket = infoj.GetTriedBucket(nKey1, asmap);\n@@ -685,7 +685,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n \n     CNetAddr source1 = ResolveIP(\"250.1.2.1\");\n \n-    CAddrInfo info1 = CAddrInfo(addr1, source1);\n+    AddrInfo info1 = AddrInfo(addr1, source1);\n \n     uint256 nKey1 = (uint256)(CHashWriter(SER_GETHASH, 0) << 1).GetHash();\n     uint256 nKey2 = (uint256)(CHashWriter(SER_GETHASH, 0) << 2).GetHash();\n@@ -701,13 +701,13 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n     BOOST_CHECK(info1.GetNewBucket(nKey1, asmap) != info1.GetNewBucket(nKey2, asmap));\n \n     // Test: Ports should not affect bucket placement in the addr\n-    CAddrInfo info2 = CAddrInfo(addr2, source1);\n+    AddrInfo info2 = AddrInfo(addr2, source1);\n     BOOST_CHECK(info1.GetKey() != info2.GetKey());\n     BOOST_CHECK_EQUAL(info1.GetNewBucket(nKey1, asmap), info2.GetNewBucket(nKey1, asmap));\n \n     std::set<int> buckets;\n     for (int i = 0; i < 255; i++) {\n-        CAddrInfo infoi = CAddrInfo(\n+        AddrInfo infoi = AddrInfo(\n             CAddress(ResolveService(\"250.1.1.\" + ToString(i)), NODE_NONE),\n             ResolveIP(\"250.1.1.\" + ToString(i)));\n         int bucket = infoi.GetNewBucket(nKey1, asmap);\n@@ -719,7 +719,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n \n     buckets.clear();\n     for (int j = 0; j < 4 * 255; j++) {\n-        CAddrInfo infoj = CAddrInfo(CAddress(\n+        AddrInfo infoj = AddrInfo(CAddress(\n                                         ResolveService(\n                                             ToString(250 + (j / 255)) + \".\" + ToString(j % 256) + \".1.1\"), NODE_NONE),\n             ResolveIP(\"251.4.1.1\"));\n@@ -732,7 +732,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n \n     buckets.clear();\n     for (int p = 0; p < 255; p++) {\n-        CAddrInfo infoj = CAddrInfo(\n+        AddrInfo infoj = AddrInfo(\n             CAddress(ResolveService(\"250.1.1.1\"), NODE_NONE),\n             ResolveIP(\"101.\" + ToString(p) + \".1.1\"));\n         int bucket = infoj.GetNewBucket(nKey1, asmap);\n@@ -744,7 +744,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n \n     buckets.clear();\n     for (int p = 0; p < 255; p++) {\n-        CAddrInfo infoj = CAddrInfo(\n+        AddrInfo infoj = AddrInfo(\n             CAddress(ResolveService(\"250.1.1.1\"), NODE_NONE),\n             ResolveIP(\"250.\" + ToString(p) + \".1.1\"));\n         int bucket = infoj.GetNewBucket(nKey1, asmap);"
      },
      {
        "sha": "cfeab9dcdc2f0e460188c47865ce9a15ca6717d0",
        "filename": "src/test/fuzz/addrman.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/375750387e35ed751d1f5ab48860bdec93977f64/src/test/fuzz/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/375750387e35ed751d1f5ab48860bdec93977f64/src/test/fuzz/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/addrman.cpp?ref=375750387e35ed751d1f5ab48860bdec93977f64",
        "patch": "@@ -142,24 +142,24 @@ class AddrManDeterministic : public AddrMan\n         // Check that all values in `mapInfo` are equal to all values in `other.mapInfo`.\n         // Keys may be different.\n \n-        using CAddrInfoHasher = std::function<size_t(const CAddrInfo&)>;\n-        using CAddrInfoEq = std::function<bool(const CAddrInfo&, const CAddrInfo&)>;\n+        using AddrInfoHasher = std::function<size_t(const AddrInfo&)>;\n+        using AddrInfoEq = std::function<bool(const AddrInfo&, const AddrInfo&)>;\n \n         CNetAddrHash netaddr_hasher;\n \n-        CAddrInfoHasher addrinfo_hasher = [&netaddr_hasher](const CAddrInfo& a) {\n+        AddrInfoHasher addrinfo_hasher = [&netaddr_hasher](const AddrInfo& a) {\n             return netaddr_hasher(static_cast<CNetAddr>(a)) ^ netaddr_hasher(a.source) ^\n                    a.nLastSuccess ^ a.nAttempts ^ a.nRefCount ^ a.fInTried;\n         };\n \n-        CAddrInfoEq addrinfo_eq = [](const CAddrInfo& lhs, const CAddrInfo& rhs) {\n+        AddrInfoEq addrinfo_eq = [](const AddrInfo& lhs, const AddrInfo& rhs) {\n             return static_cast<CNetAddr>(lhs) == static_cast<CNetAddr>(rhs) &&\n                    lhs.source == rhs.source && lhs.nLastSuccess == rhs.nLastSuccess &&\n                    lhs.nAttempts == rhs.nAttempts && lhs.nRefCount == rhs.nRefCount &&\n                    lhs.fInTried == rhs.fInTried;\n         };\n \n-        using Addresses = std::unordered_set<CAddrInfo, CAddrInfoHasher, CAddrInfoEq>;\n+        using Addresses = std::unordered_set<AddrInfo, AddrInfoHasher, AddrInfoEq>;\n \n         const size_t num_addresses{m_impl->mapInfo.size()};\n "
      },
      {
        "sha": "a9325fa738b223f8734f77e396ef4d48027546a6",
        "filename": "src/test/fuzz/deserialize.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/375750387e35ed751d1f5ab48860bdec93977f64/src/test/fuzz/deserialize.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/375750387e35ed751d1f5ab48860bdec93977f64/src/test/fuzz/deserialize.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/deserialize.cpp?ref=375750387e35ed751d1f5ab48860bdec93977f64",
        "patch": "@@ -105,7 +105,7 @@ FUZZ_TARGET_DESERIALIZE(block_filter_deserialize, {\n     DeserializeFromFuzzingInput(buffer, block_filter);\n })\n FUZZ_TARGET_DESERIALIZE(addr_info_deserialize, {\n-    CAddrInfo addr_info;\n+    AddrInfo addr_info;\n     DeserializeFromFuzzingInput(buffer, addr_info);\n })\n FUZZ_TARGET_DESERIALIZE(block_file_info_deserialize, {"
      }
    ]
  },
  {
    "sha": "021f86953e8a1dff8ecc768186368d345c865cc2",
    "node_id": "C_kwDOABII59oAKDAyMWY4Njk1M2U4YTFkZmY4ZWNjNzY4MTg2MzY4ZDM0NWM4NjVjYzI",
    "commit": {
      "author": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2021-09-11T00:53:57Z"
      },
      "committer": {
        "name": "Amiti Uttarwar",
        "email": "amiti@uttarwar.org",
        "date": "2021-09-29T02:21:10Z"
      },
      "message": "[style] Run changed files through clang formatter.",
      "tree": {
        "sha": "577d340c9606340fe140b9e734c41ed1450d74f8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/577d340c9606340fe140b9e734c41ed1450d74f8"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/021f86953e8a1dff8ecc768186368d345c865cc2",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/021f86953e8a1dff8ecc768186368d345c865cc2",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/021f86953e8a1dff8ecc768186368d345c865cc2",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/021f86953e8a1dff8ecc768186368d345c865cc2/comments",
    "author": {
      "login": "amitiuttarwar",
      "id": 1500952,
      "node_id": "MDQ6VXNlcjE1MDA5NTI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/amitiuttarwar",
      "html_url": "https://github.com/amitiuttarwar",
      "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
      "following_url": "https://api.github.com/users/amitiuttarwar/following{/other_user}",
      "gists_url": "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
      "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
      "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
      "events_url": "https://api.github.com/users/amitiuttarwar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "amitiuttarwar",
      "id": 1500952,
      "node_id": "MDQ6VXNlcjE1MDA5NTI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1500952?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/amitiuttarwar",
      "html_url": "https://github.com/amitiuttarwar",
      "followers_url": "https://api.github.com/users/amitiuttarwar/followers",
      "following_url": "https://api.github.com/users/amitiuttarwar/following{/other_user}",
      "gists_url": "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/amitiuttarwar/subscriptions",
      "organizations_url": "https://api.github.com/users/amitiuttarwar/orgs",
      "repos_url": "https://api.github.com/users/amitiuttarwar/repos",
      "events_url": "https://api.github.com/users/amitiuttarwar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/amitiuttarwar/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "375750387e35ed751d1f5ab48860bdec93977f64",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/375750387e35ed751d1f5ab48860bdec93977f64",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/375750387e35ed751d1f5ab48860bdec93977f64"
      }
    ],
    "stats": {
      "total": 68,
      "additions": 34,
      "deletions": 34
    },
    "files": [
      {
        "sha": "c364a7710b458a0440b04a2fcb20a74eaec16b12",
        "filename": "src/addrman.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 16,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/021f86953e8a1dff8ecc768186368d345c865cc2/src/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/021f86953e8a1dff8ecc768186368d345c865cc2/src/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.cpp?ref=021f86953e8a1dff8ecc768186368d345c865cc2",
        "patch": "@@ -41,7 +41,7 @@ static constexpr size_t ADDRMAN_SET_TRIED_COLLISION_SIZE{10};\n /** The maximum time we'll spend trying to resolve a tried table collision, in seconds */\n static constexpr int64_t ADDRMAN_TEST_WINDOW{40*60}; // 40 minutes\n \n-int AddrInfo::GetTriedBucket(const uint256& nKey, const std::vector<bool> &asmap) const\n+int AddrInfo::GetTriedBucket(const uint256& nKey, const std::vector<bool>& asmap) const\n {\n     uint64_t hash1 = (CHashWriter(SER_GETHASH, 0) << nKey << GetKey()).GetCheapHash();\n     uint64_t hash2 = (CHashWriter(SER_GETHASH, 0) << nKey << GetGroup(asmap) << (hash1 % ADDRMAN_TRIED_BUCKETS_PER_GROUP)).GetCheapHash();\n@@ -51,7 +51,7 @@ int AddrInfo::GetTriedBucket(const uint256& nKey, const std::vector<bool> &asmap\n     return tried_bucket;\n }\n \n-int AddrInfo::GetNewBucket(const uint256& nKey, const CNetAddr& src, const std::vector<bool> &asmap) const\n+int AddrInfo::GetNewBucket(const uint256& nKey, const CNetAddr& src, const std::vector<bool>& asmap) const\n {\n     std::vector<unsigned char> vchSourceGroupKey = src.GetGroup(asmap);\n     uint64_t hash1 = (CHashWriter(SER_GETHASH, 0) << nKey << GetGroup(asmap) << vchSourceGroupKey).GetCheapHash();\n@@ -62,7 +62,7 @@ int AddrInfo::GetNewBucket(const uint256& nKey, const CNetAddr& src, const std::\n     return new_bucket;\n }\n \n-int AddrInfo::GetBucketPosition(const uint256 &nKey, bool fNew, int nBucket) const\n+int AddrInfo::GetBucketPosition(const uint256& nKey, bool fNew, int nBucket) const\n {\n     uint64_t hash1 = (CHashWriter(SER_GETHASH, 0) << nKey << (fNew ? uint8_t{'N'} : uint8_t{'K'}) << nBucket << GetKey()).GetCheapHash();\n     return hash1 % ADDRMAN_BUCKET_SIZE;\n@@ -190,7 +190,7 @@ void AddrManImpl::Serialize(Stream& s_) const\n     int nIds = 0;\n     for (const auto& entry : mapInfo) {\n         mapUnkIds[entry.first] = nIds;\n-        const AddrInfo &info = entry.second;\n+        const AddrInfo& info = entry.second;\n         if (info.nRefCount) {\n             assert(nIds != nNew); // this means nNew was wrong, oh ow\n             s << info;\n@@ -199,7 +199,7 @@ void AddrManImpl::Serialize(Stream& s_) const\n     }\n     nIds = 0;\n     for (const auto& entry : mapInfo) {\n-        const AddrInfo &info = entry.second;\n+        const AddrInfo& info = entry.second;\n         if (info.fInTried) {\n             assert(nIds != nTried); // this means nTried was wrong, oh ow\n             s << info;\n@@ -283,7 +283,7 @@ void AddrManImpl::Unserialize(Stream& s_)\n \n     // Deserialize entries from the new table.\n     for (int n = 0; n < nNew; n++) {\n-        AddrInfo &info = mapInfo[n];\n+        AddrInfo& info = mapInfo[n];\n         s >> info;\n         mapAddr[info] = n;\n         info.nRandomPos = vRandom.size();\n@@ -1024,7 +1024,7 @@ size_t AddrManImpl::size() const\n     return vRandom.size();\n }\n \n-bool AddrManImpl::Add(const std::vector<CAddress> &vAddr, const CNetAddr& source, int64_t nTimePenalty)\n+bool AddrManImpl::Add(const std::vector<CAddress>& vAddr, const CNetAddr& source, int64_t nTimePenalty)\n {\n     LOCK(cs);\n     int nAdd = 0;\n@@ -1038,15 +1038,15 @@ bool AddrManImpl::Add(const std::vector<CAddress> &vAddr, const CNetAddr& source\n     return nAdd > 0;\n }\n \n-void AddrManImpl::Good(const CService &addr, int64_t nTime)\n+void AddrManImpl::Good(const CService& addr, int64_t nTime)\n {\n     LOCK(cs);\n     Check();\n     Good_(addr, /* test_before_evict */ true, nTime);\n     Check();\n }\n \n-void AddrManImpl::Attempt(const CService &addr, bool fCountFailure, int64_t nTime)\n+void AddrManImpl::Attempt(const CService& addr, bool fCountFailure, int64_t nTime)\n {\n     LOCK(cs);\n     Check();\n@@ -1089,15 +1089,15 @@ std::vector<CAddress> AddrManImpl::GetAddr(size_t max_addresses, size_t max_pct,\n     return addresses;\n }\n \n-void AddrManImpl::Connected(const CService &addr, int64_t nTime)\n+void AddrManImpl::Connected(const CService& addr, int64_t nTime)\n {\n     LOCK(cs);\n     Check();\n     Connected_(addr, nTime);\n     Check();\n }\n \n-void AddrManImpl::SetServices(const CService &addr, ServiceFlags nServices)\n+void AddrManImpl::SetServices(const CService& addr, ServiceFlags nServices)\n {\n     LOCK(cs);\n     Check();\n@@ -1141,17 +1141,17 @@ size_t AddrMan::size() const\n     return m_impl->size();\n }\n \n-bool AddrMan::Add(const std::vector<CAddress> &vAddr, const CNetAddr& source, int64_t nTimePenalty)\n+bool AddrMan::Add(const std::vector<CAddress>& vAddr, const CNetAddr& source, int64_t nTimePenalty)\n {\n     return m_impl->Add(vAddr, source, nTimePenalty);\n }\n \n-void AddrMan::Good(const CService &addr, int64_t nTime)\n+void AddrMan::Good(const CService& addr, int64_t nTime)\n {\n     m_impl->Good(addr, nTime);\n }\n \n-void AddrMan::Attempt(const CService &addr, bool fCountFailure, int64_t nTime)\n+void AddrMan::Attempt(const CService& addr, bool fCountFailure, int64_t nTime)\n {\n     m_impl->Attempt(addr, fCountFailure, nTime);\n }\n@@ -1176,12 +1176,12 @@ std::vector<CAddress> AddrMan::GetAddr(size_t max_addresses, size_t max_pct, std\n     return m_impl->GetAddr(max_addresses, max_pct, network);\n }\n \n-void AddrMan::Connected(const CService &addr, int64_t nTime)\n+void AddrMan::Connected(const CService& addr, int64_t nTime)\n {\n     m_impl->Connected(addr, nTime);\n }\n \n-void AddrMan::SetServices(const CService &addr, ServiceFlags nServices)\n+void AddrMan::SetServices(const CService& addr, ServiceFlags nServices)\n {\n     m_impl->SetServices(addr, nServices);\n }"
      },
      {
        "sha": "174ab4f811b0590732f437ed637ecdc8fb020e7d",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/021f86953e8a1dff8ecc768186368d345c865cc2/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/021f86953e8a1dff8ecc768186368d345c865cc2/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=021f86953e8a1dff8ecc768186368d345c865cc2",
        "patch": "@@ -70,13 +70,13 @@ class AddrMan\n     size_t size() const;\n \n     //! Add addresses to addrman's new table.\n-    bool Add(const std::vector<CAddress> &vAddr, const CNetAddr& source, int64_t nTimePenalty = 0);\n+    bool Add(const std::vector<CAddress>& vAddr, const CNetAddr& source, int64_t nTimePenalty = 0);\n \n     //! Mark an entry as accessible, possibly moving it from \"new\" to \"tried\".\n-    void Good(const CService &addr, int64_t nTime = GetAdjustedTime());\n+    void Good(const CService& addr, int64_t nTime = GetAdjustedTime());\n \n     //! Mark an entry as connection attempted to.\n-    void Attempt(const CService &addr, bool fCountFailure, int64_t nTime = GetAdjustedTime());\n+    void Attempt(const CService& addr, bool fCountFailure, int64_t nTime = GetAdjustedTime());\n \n     //! See if any to-be-evicted tried table entries have been tested and if so resolve the collisions.\n     void ResolveCollisions();\n@@ -121,10 +121,10 @@ class AddrMan\n      * @param[in]   addr     The address of the peer we were connected to\n      * @param[in]   nTime    The time that we were last connected to this peer\n      */\n-    void Connected(const CService &addr, int64_t nTime = GetAdjustedTime());\n+    void Connected(const CService& addr, int64_t nTime = GetAdjustedTime());\n \n     //! Update an entry's service bits.\n-    void SetServices(const CService &addr, ServiceFlags nServices);\n+    void SetServices(const CService& addr, ServiceFlags nServices);\n \n     const std::vector<bool>& GetAsmap() const;\n "
      },
      {
        "sha": "1dc7f25f9c476dc62774c69fd485b88c060ef0ae",
        "filename": "src/addrman_impl.h",
        "status": "modified",
        "additions": 12,
        "deletions": 12,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/021f86953e8a1dff8ecc768186368d345c865cc2/src/addrman_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/021f86953e8a1dff8ecc768186368d345c865cc2/src/addrman_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman_impl.h?ref=021f86953e8a1dff8ecc768186368d345c865cc2",
        "patch": "@@ -111,29 +111,29 @@ class AddrManImpl\n \n     size_t size() const EXCLUSIVE_LOCKS_REQUIRED(!cs);\n \n-    bool Add(const std::vector<CAddress> &vAddr, const CNetAddr& source, int64_t nTimePenalty)\n+    bool Add(const std::vector<CAddress>& vAddr, const CNetAddr& source, int64_t nTimePenalty)\n         EXCLUSIVE_LOCKS_REQUIRED(!cs);\n \n-    void Good(const CService &addr, int64_t nTime)\n+    void Good(const CService& addr, int64_t nTime)\n         EXCLUSIVE_LOCKS_REQUIRED(!cs);\n \n-    void Attempt(const CService &addr, bool fCountFailure, int64_t nTime)\n+    void Attempt(const CService& addr, bool fCountFailure, int64_t nTime)\n         EXCLUSIVE_LOCKS_REQUIRED(!cs);\n \n     void ResolveCollisions() EXCLUSIVE_LOCKS_REQUIRED(!cs);\n \n     std::pair<CAddress, int64_t> SelectTriedCollision() EXCLUSIVE_LOCKS_REQUIRED(!cs);\n \n-    std::pair<CAddress, int64_t>  Select(bool newOnly) const\n+    std::pair<CAddress, int64_t> Select(bool newOnly) const\n         EXCLUSIVE_LOCKS_REQUIRED(!cs);\n \n     std::vector<CAddress> GetAddr(size_t max_addresses, size_t max_pct, std::optional<Network> network) const\n         EXCLUSIVE_LOCKS_REQUIRED(!cs);\n \n-    void Connected(const CService &addr, int64_t nTime)\n+    void Connected(const CService& addr, int64_t nTime)\n         EXCLUSIVE_LOCKS_REQUIRED(!cs);\n \n-    void SetServices(const CService &addr, ServiceFlags nServices)\n+    void SetServices(const CService& addr, ServiceFlags nServices)\n         EXCLUSIVE_LOCKS_REQUIRED(!cs);\n \n     const std::vector<bool>& GetAsmap() const;\n@@ -225,10 +225,10 @@ class AddrManImpl\n     const std::vector<bool> m_asmap;\n \n     //! Find an entry.\n-    AddrInfo* Find(const CNetAddr& addr, int *pnId = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+    AddrInfo* Find(const CNetAddr& addr, int* pnId = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n     //! Create a new entry and add it to the internal data structures mapInfo, mapAddr and vRandom.\n-    AddrInfo* Create(const CAddress &addr, const CNetAddr &addrSource, int *pnId = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+    AddrInfo* Create(const CAddress& addr, const CNetAddr& addrSource, int* pnId = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n     //! Swap two elements in vRandom.\n     void SwapRandom(unsigned int nRandomPos1, unsigned int nRandomPos2) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n@@ -242,19 +242,19 @@ class AddrManImpl\n     //! Move an entry from the \"new\" table(s) to the \"tried\" table\n     void MakeTried(AddrInfo& info, int nId) EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n-    void Good_(const CService &addr, bool test_before_evict, int64_t time) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+    void Good_(const CService& addr, bool test_before_evict, int64_t time) EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n-    bool Add_(const CAddress &addr, const CNetAddr& source, int64_t nTimePenalty) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+    bool Add_(const CAddress& addr, const CNetAddr& source, int64_t nTimePenalty) EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n-    void Attempt_(const CService &addr, bool fCountFailure, int64_t nTime) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+    void Attempt_(const CService& addr, bool fCountFailure, int64_t nTime) EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n     std::pair<CAddress, int64_t> Select_(bool newOnly) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n     std::vector<CAddress> GetAddr_(size_t max_addresses, size_t max_pct, std::optional<Network> network) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n     void Connected_(const CService& addr, int64_t nTime) EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n-    void SetServices_(const CService &addr, ServiceFlags nServices) EXCLUSIVE_LOCKS_REQUIRED(cs);\n+    void SetServices_(const CService& addr, ServiceFlags nServices) EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n     void ResolveCollisions_() EXCLUSIVE_LOCKS_REQUIRED(cs);\n "
      },
      {
        "sha": "bd6f47021956963ea1e88f3279c2fd1d29c9d833",
        "filename": "src/test/addrman_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/021f86953e8a1dff8ecc768186368d345c865cc2/src/test/addrman_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/021f86953e8a1dff8ecc768186368d345c865cc2/src/test/addrman_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/addrman_tests.cpp?ref=021f86953e8a1dff8ecc768186368d345c865cc2",
        "patch": "@@ -83,7 +83,7 @@ class AddrManTest : public AddrMan\n     bool deterministic;\n public:\n     explicit AddrManTest(bool makeDeterministic = true,\n-                          std::vector<bool> asmap = std::vector<bool>())\n+                         std::vector<bool> asmap = std::vector<bool>())\n         : AddrMan(asmap, makeDeterministic, /* consistency_check_ratio */ 100)\n     {\n         deterministic = makeDeterministic;"
      }
    ]
  }
]