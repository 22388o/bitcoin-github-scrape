[
  {
    "sha": "e7c1b4490f2c559b050b8255df2d347dd0e4945f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplN2MxYjQ0OTBmMmM1NTliMDUwYjgyNTVkZjJkMzQ3ZGQwZTQ5NDVm",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-05-05T18:12:58Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-05-05T18:12:58Z"
      },
      "message": "Squashed 'src/secp256k1/' changes from 8225239..84973d3\n\n84973d3 Merge #454: Remove residual parts from the schnorr expirement.\n5e95bf2 Remove residual parts from the schnorr expirement.\ncbc20b8 Merge #452: Minor optimizations to _scalar_inverse to save 4M\n4cc8f52 Merge #437: Unroll secp256k1_fe_(get|set)_b32 to make them much faster.\n465159c Further shorten the addition chain for scalar inversion.\na2b6b19 Fix benchmark print_number infinite loop.\n8b7680a Unroll secp256k1_fe_(get|set)_b32 for 10x26.\naa84990 Unroll secp256k1_fe_(get|set)_b32 for 5x52.\ncf12fa1 Minor optimizations to _scalar_inverse to save 4M\n1199492 Merge #408: Add `secp256k1_ec_pubkey_negate` and `secp256k1_ec_privkey_negate`\n6af0871 Merge #441: secp256k1_context_randomize: document.\nab31a52 Merge #444: test: Use checked_alloc\neda5c1a Merge #449: Remove executable bit from secp256k1.c\n51b77ae Remove executable bit from secp256k1.c\n5eb030c test: Use checked_alloc\n72d952c FIXUP: Missing \"is\"\n70ff29b secp256k1_context_randomize: document.\n9d560f9 Merge #428: Exhaustive recovery\n8e48aa6 Add `secp256k1_ec_pubkey_negate` and `secp256k1_ec_privkey_negate`\n2cee5fd exhaustive tests: add recovery module\n678b0e5 exhaustive tests: remove erroneous comment from ecdsa_sig_sign\n03ff8c2 group_impl.h: remove unused `secp256k1_ge_set_infinity` function\na724d72 configure: add --enable-coverage to set options for coverage analysis\nb595163 recovery: add tests to cover API misusage\n6f8ae2f ecdh: test NULL-checking of arguments\n25e3cfb ecdsa_impl: replace scalar if-checks with VERIFY_CHECKs in ecdsa_sig_sign\n\ngit-subtree-dir: src/secp256k1\ngit-subtree-split: 84973d393ac240a90b2e1a6538c5368202bc2224",
      "tree": {
        "sha": "0cedbba829a5b38b750b2952af49b45880c32117",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0cedbba829a5b38b750b2952af49b45880c32117"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e7c1b4490f2c559b050b8255df2d347dd0e4945f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e7c1b4490f2c559b050b8255df2d347dd0e4945f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e7c1b4490f2c559b050b8255df2d347dd0e4945f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e7c1b4490f2c559b050b8255df2d347dd0e4945f/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7b49f22bdbdecca600c4744d020b3553fe427e61",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7b49f22bdbdecca600c4744d020b3553fe427e61",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7b49f22bdbdecca600c4744d020b3553fe427e61"
      }
    ],
    "stats": {
      "total": 901,
      "additions": 623,
      "deletions": 278
    },
    "files": [
      {
        "sha": "c071fbe2753c9bda4c8d7b74143dc15878572c4b",
        "filename": "Makefile.am",
        "status": "modified",
        "additions": 8,
        "deletions": 2,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e7c1b4490f2c559b050b8255df2d347dd0e4945f/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e7c1b4490f2c559b050b8255df2d347dd0e4945f/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/Makefile.am?ref=e7c1b4490f2c559b050b8255df2d347dd0e4945f",
        "patch": "@@ -93,7 +93,10 @@ TESTS =\n if USE_TESTS\n noinst_PROGRAMS += tests\n tests_SOURCES = src/tests.c\n-tests_CPPFLAGS = -DSECP256K1_BUILD -DVERIFY -I$(top_srcdir)/src -I$(top_srcdir)/include $(SECP_INCLUDES) $(SECP_TEST_INCLUDES)\n+tests_CPPFLAGS = -DSECP256K1_BUILD -I$(top_srcdir)/src -I$(top_srcdir)/include $(SECP_INCLUDES) $(SECP_TEST_INCLUDES)\n+if !ENABLE_COVERAGE\n+tests_CPPFLAGS += -DVERIFY\n+endif\n tests_LDADD = $(SECP_LIBS) $(SECP_TEST_LIBS) $(COMMON_LIB)\n tests_LDFLAGS = -static\n TESTS += tests\n@@ -102,7 +105,10 @@ endif\n if USE_EXHAUSTIVE_TESTS\n noinst_PROGRAMS += exhaustive_tests\n exhaustive_tests_SOURCES = src/tests_exhaustive.c\n-exhaustive_tests_CPPFLAGS = -DSECP256K1_BUILD -DVERIFY -I$(top_srcdir)/src $(SECP_INCLUDES)\n+exhaustive_tests_CPPFLAGS = -DSECP256K1_BUILD -I$(top_srcdir)/src $(SECP_INCLUDES)\n+if !ENABLE_COVERAGE\n+exhaustive_tests_CPPFLAGS += -DVERIFY\n+endif\n exhaustive_tests_LDADD = $(SECP_LIBS)\n exhaustive_tests_LDFLAGS = -static\n TESTS += exhaustive_tests"
      },
      {
        "sha": "e5fcbcb4edf2ace1c2b8740fc118b1e784f12d5e",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 16,
        "deletions": 1,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e7c1b4490f2c559b050b8255df2d347dd0e4945f/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e7c1b4490f2c559b050b8255df2d347dd0e4945f/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=e7c1b4490f2c559b050b8255df2d347dd0e4945f",
        "patch": "@@ -20,7 +20,7 @@ AC_PATH_TOOL(STRIP, strip)\n AX_PROG_CC_FOR_BUILD\n \n if test \"x$CFLAGS\" = \"x\"; then\n-  CFLAGS=\"-O3 -g\"\n+  CFLAGS=\"-g\"\n fi\n \n AM_PROG_CC_C_O\n@@ -89,6 +89,11 @@ AC_ARG_ENABLE(benchmark,\n     [use_benchmark=$enableval],\n     [use_benchmark=no])\n \n+AC_ARG_ENABLE(coverage,\n+    AS_HELP_STRING([--enable-coverage],[enable compiler flags to support kcov coverage analysis]),\n+    [enable_coverage=$enableval],\n+    [enable_coverage=no])\n+\n AC_ARG_ENABLE(tests,\n     AS_HELP_STRING([--enable-tests],[compile tests (default is yes)]),\n     [use_tests=$enableval],\n@@ -154,6 +159,14 @@ AC_COMPILE_IFELSE([AC_LANG_SOURCE([[void myfunc() {__builtin_expect(0,0);}]])],\n     [ AC_MSG_RESULT([no])\n     ])\n \n+if test x\"$enable_coverage\" = x\"yes\"; then\n+    AC_DEFINE(COVERAGE, 1, [Define this symbol to compile out all VERIFY code])\n+    CFLAGS=\"$CFLAGS -O0 --coverage\"\n+    LDFLAGS=\"--coverage\"\n+else\n+    CFLAGS=\"$CFLAGS -O3\"\n+fi\n+\n if test x\"$use_ecmult_static_precomputation\" != x\"no\"; then\n   save_cross_compiling=$cross_compiling\n   cross_compiling=no\n@@ -434,6 +447,7 @@ AC_MSG_NOTICE([Using field implementation: $set_field])\n AC_MSG_NOTICE([Using bignum implementation: $set_bignum])\n AC_MSG_NOTICE([Using scalar implementation: $set_scalar])\n AC_MSG_NOTICE([Using endomorphism optimizations: $use_endomorphism])\n+AC_MSG_NOTICE([Building for coverage analysis: $enable_coverage])\n AC_MSG_NOTICE([Building ECDH module: $enable_module_ecdh])\n AC_MSG_NOTICE([Building ECDSA pubkey recovery module: $enable_module_recovery])\n AC_MSG_NOTICE([Using jni: $use_jni])\n@@ -460,6 +474,7 @@ AC_SUBST(SECP_INCLUDES)\n AC_SUBST(SECP_LIBS)\n AC_SUBST(SECP_TEST_LIBS)\n AC_SUBST(SECP_TEST_INCLUDES)\n+AM_CONDITIONAL([ENABLE_COVERAGE], [test x\"$enable_coverage\" = x\"yes\"])\n AM_CONDITIONAL([USE_TESTS], [test x\"$use_tests\" != x\"no\"])\n AM_CONDITIONAL([USE_EXHAUSTIVE_TESTS], [test x\"$use_exhaustive_tests\" != x\"no\"])\n AM_CONDITIONAL([USE_BENCHMARK], [test x\"$use_benchmark\" = x\"yes\"])"
      },
      {
        "sha": "fc4c5cefbb3b654855908761b9a68be88303b813",
        "filename": "include/secp256k1.h",
        "status": "modified",
        "additions": 38,
        "deletions": 1,
        "changes": 39,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e7c1b4490f2c559b050b8255df2d347dd0e4945f/include/secp256k1.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e7c1b4490f2c559b050b8255df2d347dd0e4945f/include/secp256k1.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/include/secp256k1.h?ref=e7c1b4490f2c559b050b8255df2d347dd0e4945f",
        "patch": "@@ -163,6 +163,8 @@ typedef int (*secp256k1_nonce_function)(\n  *\n  *  Returns: a newly created context object.\n  *  In:      flags: which parts of the context to initialize.\n+ *\n+ *  See also secp256k1_context_randomize.\n  */\n SECP256K1_API secp256k1_context* secp256k1_context_create(\n     unsigned int flags\n@@ -485,6 +487,28 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_create(\n     const unsigned char *seckey\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n+/** Negates a private key in place.\n+ *\n+ *  Returns: 1 always\n+ *  Args:   ctx:        pointer to a context object\n+ *  In/Out: pubkey:     pointer to the public key to be negated (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_privkey_negate(\n+    const secp256k1_context* ctx,\n+    unsigned char *seckey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2);\n+\n+/** Negates a public key in place.\n+ *\n+ *  Returns: 1 always\n+ *  Args:   ctx:        pointer to a context object\n+ *  In/Out: pubkey:     pointer to the public key to be negated (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_negate(\n+    const secp256k1_context* ctx,\n+    secp256k1_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2);\n+\n /** Tweak a private key by adding tweak to it.\n  * Returns: 0 if the tweak was out of range (chance of around 1 in 2^128 for\n  *          uniformly random 32-byte arrays, or if the resulting private key\n@@ -543,11 +567,24 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_tweak_mul(\n     const unsigned char *tweak\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n-/** Updates the context randomization.\n+/** Updates the context randomization to protect against side-channel leakage.\n  *  Returns: 1: randomization successfully updated\n  *           0: error\n  *  Args:    ctx:       pointer to a context object (cannot be NULL)\n  *  In:      seed32:    pointer to a 32-byte random seed (NULL resets to initial state)\n+ *\n+ * While secp256k1 code is written to be constant-time no matter what secret\n+ * values are, it's possible that a future compiler may output code which isn't,\n+ * and also that the CPU may not emit the same radio frequencies or draw the same\n+ * amount power for all values.\n+ *\n+ * This function provides a seed which is combined into the blinding value: that\n+ * blinding value is added before each multiplication (and removed afterwards) so\n+ * that it does not affect function results, but shields against attacks which\n+ * rely on any input-dependent behaviour.\n+ *\n+ * You should call this after secp256k1_context_create or\n+ * secp256k1_context_clone, and may call this repeatedly afterwards.\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_context_randomize(\n     secp256k1_context* ctx,"
      },
      {
        "sha": "d67f08a4267bcb2e03e8ffbedb8c01de2691863b",
        "filename": "src/bench.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e7c1b4490f2c559b050b8255df2d347dd0e4945f/src/bench.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e7c1b4490f2c559b050b8255df2d347dd0e4945f/src/bench.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench.h?ref=e7c1b4490f2c559b050b8255df2d347dd0e4945f",
        "patch": "@@ -23,7 +23,7 @@ void print_number(double x) {\n     if (y < 0.0) {\n         y = -y;\n     }\n-    while (y < 100.0) {\n+    while (y > 0 && y < 100.0) {\n         y *= 10.0;\n         c++;\n     }"
      },
      {
        "sha": "5f137dda23ef3a62326a6aee21cd152fa09860da",
        "filename": "src/bench_schnorr_verify.c",
        "status": "removed",
        "additions": 0,
        "deletions": 73,
        "changes": 73,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7b49f22bdbdecca600c4744d020b3553fe427e61/src/bench_schnorr_verify.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7b49f22bdbdecca600c4744d020b3553fe427e61/src/bench_schnorr_verify.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench_schnorr_verify.c?ref=7b49f22bdbdecca600c4744d020b3553fe427e61",
        "patch": "@@ -1,73 +0,0 @@\n-/**********************************************************************\n- * Copyright (c) 2014 Pieter Wuille                                   *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n-\n-#include <stdio.h>\n-#include <string.h>\n-\n-#include \"include/secp256k1.h\"\n-#include \"include/secp256k1_schnorr.h\"\n-#include \"util.h\"\n-#include \"bench.h\"\n-\n-typedef struct {\n-    unsigned char key[32];\n-    unsigned char sig[64];\n-    unsigned char pubkey[33];\n-    size_t pubkeylen;\n-} benchmark_schnorr_sig_t;\n-\n-typedef struct {\n-    secp256k1_context *ctx;\n-    unsigned char msg[32];\n-    benchmark_schnorr_sig_t sigs[64];\n-    int numsigs;\n-} benchmark_schnorr_verify_t;\n-\n-static void benchmark_schnorr_init(void* arg) {\n-    int i, k;\n-    benchmark_schnorr_verify_t* data = (benchmark_schnorr_verify_t*)arg;\n-\n-    for (i = 0; i < 32; i++) {\n-        data->msg[i] = 1 + i;\n-    }\n-    for (k = 0; k < data->numsigs; k++) {\n-        secp256k1_pubkey pubkey;\n-        for (i = 0; i < 32; i++) {\n-            data->sigs[k].key[i] = 33 + i + k;\n-        }\n-        secp256k1_schnorr_sign(data->ctx, data->sigs[k].sig, data->msg, data->sigs[k].key, NULL, NULL);\n-        data->sigs[k].pubkeylen = 33;\n-        CHECK(secp256k1_ec_pubkey_create(data->ctx, &pubkey, data->sigs[k].key));\n-        CHECK(secp256k1_ec_pubkey_serialize(data->ctx, data->sigs[k].pubkey, &data->sigs[k].pubkeylen, &pubkey, SECP256K1_EC_COMPRESSED));\n-    }\n-}\n-\n-static void benchmark_schnorr_verify(void* arg) {\n-    int i;\n-    benchmark_schnorr_verify_t* data = (benchmark_schnorr_verify_t*)arg;\n-\n-    for (i = 0; i < 20000 / data->numsigs; i++) {\n-        secp256k1_pubkey pubkey;\n-        data->sigs[0].sig[(i >> 8) % 64] ^= (i & 0xFF);\n-        CHECK(secp256k1_ec_pubkey_parse(data->ctx, &pubkey, data->sigs[0].pubkey, data->sigs[0].pubkeylen));\n-        CHECK(secp256k1_schnorr_verify(data->ctx, data->sigs[0].sig, data->msg, &pubkey) == ((i & 0xFF) == 0));\n-        data->sigs[0].sig[(i >> 8) % 64] ^= (i & 0xFF);\n-    }\n-}\n-\n-\n-\n-int main(void) {\n-    benchmark_schnorr_verify_t data;\n-\n-    data.ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n-\n-    data.numsigs = 1;\n-    run_benchmark(\"schnorr_verify\", benchmark_schnorr_verify, benchmark_schnorr_init, NULL, &data, 10, 20000);\n-\n-    secp256k1_context_destroy(data.ctx);\n-    return 0;\n-}"
      },
      {
        "sha": "453bb1188066f90f7b4648ac19c8e78212973e11",
        "filename": "src/ecdsa_impl.h",
        "status": "modified",
        "additions": 5,
        "deletions": 11,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e7c1b4490f2c559b050b8255df2d347dd0e4945f/src/ecdsa_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e7c1b4490f2c559b050b8255df2d347dd0e4945f/src/ecdsa_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ecdsa_impl.h?ref=e7c1b4490f2c559b050b8255df2d347dd0e4945f",
        "patch": "@@ -225,14 +225,12 @@ static int secp256k1_ecdsa_sig_verify(const secp256k1_ecmult_context *ctx, const\n #if defined(EXHAUSTIVE_TEST_ORDER)\n {\n     secp256k1_scalar computed_r;\n-    int overflow = 0;\n     secp256k1_ge pr_ge;\n     secp256k1_ge_set_gej(&pr_ge, &pr);\n     secp256k1_fe_normalize(&pr_ge.x);\n \n     secp256k1_fe_get_b32(c, &pr_ge.x);\n-    secp256k1_scalar_set_b32(&computed_r, c, &overflow);\n-    /* we fully expect overflow */\n+    secp256k1_scalar_set_b32(&computed_r, c, NULL);\n     return secp256k1_scalar_eq(sigr, &computed_r);\n }\n #else\n@@ -285,14 +283,10 @@ static int secp256k1_ecdsa_sig_sign(const secp256k1_ecmult_gen_context *ctx, sec\n     secp256k1_fe_normalize(&r.y);\n     secp256k1_fe_get_b32(b, &r.x);\n     secp256k1_scalar_set_b32(sigr, b, &overflow);\n-    if (secp256k1_scalar_is_zero(sigr)) {\n-        /* P.x = order is on the curve, so technically sig->r could end up zero, which would be an invalid signature.\n-         * This branch is cryptographically unreachable as hitting it requires finding the discrete log of P.x = N.\n-         */\n-        secp256k1_gej_clear(&rp);\n-        secp256k1_ge_clear(&r);\n-        return 0;\n-    }\n+    /* These two conditions should be checked before calling */\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(sigr));\n+    VERIFY_CHECK(overflow == 0);\n+\n     if (recid) {\n         /* The overflow condition is cryptographically unreachable as hitting it requires finding the discrete log\n          * of some P where P.x >= order, and only 1 in about 2^127 points meet this criteria."
      },
      {
        "sha": "234c13a644233b15d84aa45183c5674ad37457ce",
        "filename": "src/field_10x26_impl.h",
        "status": "modified",
        "additions": 43,
        "deletions": 26,
        "changes": 69,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e7c1b4490f2c559b050b8255df2d347dd0e4945f/src/field_10x26_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e7c1b4490f2c559b050b8255df2d347dd0e4945f/src/field_10x26_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/field_10x26_impl.h?ref=e7c1b4490f2c559b050b8255df2d347dd0e4945f",
        "patch": "@@ -38,10 +38,6 @@ static void secp256k1_fe_verify(const secp256k1_fe *a) {\n     }\n     VERIFY_CHECK(r == 1);\n }\n-#else\n-static void secp256k1_fe_verify(const secp256k1_fe *a) {\n-    (void)a;\n-}\n #endif\n \n static void secp256k1_fe_normalize(secp256k1_fe *r) {\n@@ -325,17 +321,17 @@ static int secp256k1_fe_cmp_var(const secp256k1_fe *a, const secp256k1_fe *b) {\n }\n \n static int secp256k1_fe_set_b32(secp256k1_fe *r, const unsigned char *a) {\n-    int i;\n-    r->n[0] = r->n[1] = r->n[2] = r->n[3] = r->n[4] = 0;\n-    r->n[5] = r->n[6] = r->n[7] = r->n[8] = r->n[9] = 0;\n-    for (i=0; i<32; i++) {\n-        int j;\n-        for (j=0; j<4; j++) {\n-            int limb = (8*i+2*j)/26;\n-            int shift = (8*i+2*j)%26;\n-            r->n[limb] |= (uint32_t)((a[31-i] >> (2*j)) & 0x3) << shift;\n-        }\n-    }\n+    r->n[0] = (uint32_t)a[31] | ((uint32_t)a[30] << 8) | ((uint32_t)a[29] << 16) | ((uint32_t)(a[28] & 0x3) << 24);\n+    r->n[1] = (uint32_t)((a[28] >> 2) & 0x3f) | ((uint32_t)a[27] << 6) | ((uint32_t)a[26] << 14) | ((uint32_t)(a[25] & 0xf) << 22);\n+    r->n[2] = (uint32_t)((a[25] >> 4) & 0xf) | ((uint32_t)a[24] << 4) | ((uint32_t)a[23] << 12) | ((uint32_t)(a[22] & 0x3f) << 20);\n+    r->n[3] = (uint32_t)((a[22] >> 6) & 0x3) | ((uint32_t)a[21] << 2) | ((uint32_t)a[20] << 10) | ((uint32_t)a[19] << 18);\n+    r->n[4] = (uint32_t)a[18] | ((uint32_t)a[17] << 8) | ((uint32_t)a[16] << 16) | ((uint32_t)(a[15] & 0x3) << 24);\n+    r->n[5] = (uint32_t)((a[15] >> 2) & 0x3f) | ((uint32_t)a[14] << 6) | ((uint32_t)a[13] << 14) | ((uint32_t)(a[12] & 0xf) << 22);\n+    r->n[6] = (uint32_t)((a[12] >> 4) & 0xf) | ((uint32_t)a[11] << 4) | ((uint32_t)a[10] << 12) | ((uint32_t)(a[9] & 0x3f) << 20);\n+    r->n[7] = (uint32_t)((a[9] >> 6) & 0x3) | ((uint32_t)a[8] << 2) | ((uint32_t)a[7] << 10) | ((uint32_t)a[6] << 18);\n+    r->n[8] = (uint32_t)a[5] | ((uint32_t)a[4] << 8) | ((uint32_t)a[3] << 16) | ((uint32_t)(a[2] & 0x3) << 24);\n+    r->n[9] = (uint32_t)((a[2] >> 2) & 0x3f) | ((uint32_t)a[1] << 6) | ((uint32_t)a[0] << 14);\n+\n     if (r->n[9] == 0x3FFFFFUL && (r->n[8] & r->n[7] & r->n[6] & r->n[5] & r->n[4] & r->n[3] & r->n[2]) == 0x3FFFFFFUL && (r->n[1] + 0x40UL + ((r->n[0] + 0x3D1UL) >> 26)) > 0x3FFFFFFUL) {\n         return 0;\n     }\n@@ -349,21 +345,42 @@ static int secp256k1_fe_set_b32(secp256k1_fe *r, const unsigned char *a) {\n \n /** Convert a field element to a 32-byte big endian value. Requires the input to be normalized */\n static void secp256k1_fe_get_b32(unsigned char *r, const secp256k1_fe *a) {\n-    int i;\n #ifdef VERIFY\n     VERIFY_CHECK(a->normalized);\n     secp256k1_fe_verify(a);\n #endif\n-    for (i=0; i<32; i++) {\n-        int j;\n-        int c = 0;\n-        for (j=0; j<4; j++) {\n-            int limb = (8*i+2*j)/26;\n-            int shift = (8*i+2*j)%26;\n-            c |= ((a->n[limb] >> shift) & 0x3) << (2 * j);\n-        }\n-        r[31-i] = c;\n-    }\n+    r[0] = (a->n[9] >> 14) & 0xff;\n+    r[1] = (a->n[9] >> 6) & 0xff;\n+    r[2] = ((a->n[9] & 0x3F) << 2) | ((a->n[8] >> 24) & 0x3);\n+    r[3] = (a->n[8] >> 16) & 0xff;\n+    r[4] = (a->n[8] >> 8) & 0xff;\n+    r[5] = a->n[8] & 0xff;\n+    r[6] = (a->n[7] >> 18) & 0xff;\n+    r[7] = (a->n[7] >> 10) & 0xff;\n+    r[8] = (a->n[7] >> 2) & 0xff;\n+    r[9] = ((a->n[7] & 0x3) << 6) | ((a->n[6] >> 20) & 0x3f);\n+    r[10] = (a->n[6] >> 12) & 0xff;\n+    r[11] = (a->n[6] >> 4) & 0xff;\n+    r[12] = ((a->n[6] & 0xf) << 4) | ((a->n[5] >> 22) & 0xf);\n+    r[13] = (a->n[5] >> 14) & 0xff;\n+    r[14] = (a->n[5] >> 6) & 0xff;\n+    r[15] = ((a->n[5] & 0x3f) << 2) | ((a->n[4] >> 24) & 0x3);\n+    r[16] = (a->n[4] >> 16) & 0xff;\n+    r[17] = (a->n[4] >> 8) & 0xff;\n+    r[18] = a->n[4] & 0xff;\n+    r[19] = (a->n[3] >> 18) & 0xff;\n+    r[20] = (a->n[3] >> 10) & 0xff;\n+    r[21] = (a->n[3] >> 2) & 0xff;\n+    r[22] = ((a->n[3] & 0x3) << 6) | ((a->n[2] >> 20) & 0x3f);\n+    r[23] = (a->n[2] >> 12) & 0xff;\n+    r[24] = (a->n[2] >> 4) & 0xff;\n+    r[25] = ((a->n[2] & 0xf) << 4) | ((a->n[1] >> 22) & 0xf);\n+    r[26] = (a->n[1] >> 14) & 0xff;\n+    r[27] = (a->n[1] >> 6) & 0xff;\n+    r[28] = ((a->n[1] & 0x3f) << 2) | ((a->n[0] >> 24) & 0x3);\n+    r[29] = (a->n[0] >> 16) & 0xff;\n+    r[30] = (a->n[0] >> 8) & 0xff;\n+    r[31] = a->n[0] & 0xff;\n }\n \n SECP256K1_INLINE static void secp256k1_fe_negate(secp256k1_fe *r, const secp256k1_fe *a, int m) {"
      },
      {
        "sha": "8e8b286baff86a7e7796380e977194c2255483c2",
        "filename": "src/field_5x52_impl.h",
        "status": "modified",
        "additions": 66,
        "deletions": 25,
        "changes": 91,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e7c1b4490f2c559b050b8255df2d347dd0e4945f/src/field_5x52_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e7c1b4490f2c559b050b8255df2d347dd0e4945f/src/field_5x52_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/field_5x52_impl.h?ref=e7c1b4490f2c559b050b8255df2d347dd0e4945f",
        "patch": "@@ -49,10 +49,6 @@ static void secp256k1_fe_verify(const secp256k1_fe *a) {\n     }\n     VERIFY_CHECK(r == 1);\n }\n-#else\n-static void secp256k1_fe_verify(const secp256k1_fe *a) {\n-    (void)a;\n-}\n #endif\n \n static void secp256k1_fe_normalize(secp256k1_fe *r) {\n@@ -288,16 +284,40 @@ static int secp256k1_fe_cmp_var(const secp256k1_fe *a, const secp256k1_fe *b) {\n }\n \n static int secp256k1_fe_set_b32(secp256k1_fe *r, const unsigned char *a) {\n-    int i;\n-    r->n[0] = r->n[1] = r->n[2] = r->n[3] = r->n[4] = 0;\n-    for (i=0; i<32; i++) {\n-        int j;\n-        for (j=0; j<2; j++) {\n-            int limb = (8*i+4*j)/52;\n-            int shift = (8*i+4*j)%52;\n-            r->n[limb] |= (uint64_t)((a[31-i] >> (4*j)) & 0xF) << shift;\n-        }\n-    }\n+    r->n[0] = (uint64_t)a[31]\n+            | ((uint64_t)a[30] << 8)\n+            | ((uint64_t)a[29] << 16)\n+            | ((uint64_t)a[28] << 24)\n+            | ((uint64_t)a[27] << 32)\n+            | ((uint64_t)a[26] << 40)\n+            | ((uint64_t)(a[25] & 0xF)  << 48);\n+    r->n[1] = (uint64_t)((a[25] >> 4) & 0xF)\n+            | ((uint64_t)a[24] << 4)\n+            | ((uint64_t)a[23] << 12)\n+            | ((uint64_t)a[22] << 20)\n+            | ((uint64_t)a[21] << 28)\n+            | ((uint64_t)a[20] << 36)\n+            | ((uint64_t)a[19] << 44);\n+    r->n[2] = (uint64_t)a[18]\n+            | ((uint64_t)a[17] << 8)\n+            | ((uint64_t)a[16] << 16)\n+            | ((uint64_t)a[15] << 24)\n+            | ((uint64_t)a[14] << 32)\n+            | ((uint64_t)a[13] << 40)\n+            | ((uint64_t)(a[12] & 0xF) << 48);\n+    r->n[3] = (uint64_t)((a[12] >> 4) & 0xF)\n+            | ((uint64_t)a[11] << 4)\n+            | ((uint64_t)a[10] << 12)\n+            | ((uint64_t)a[9]  << 20)\n+            | ((uint64_t)a[8]  << 28)\n+            | ((uint64_t)a[7]  << 36)\n+            | ((uint64_t)a[6]  << 44);\n+    r->n[4] = (uint64_t)a[5]\n+            | ((uint64_t)a[4] << 8)\n+            | ((uint64_t)a[3] << 16)\n+            | ((uint64_t)a[2] << 24)\n+            | ((uint64_t)a[1] << 32)\n+            | ((uint64_t)a[0] << 40);\n     if (r->n[4] == 0x0FFFFFFFFFFFFULL && (r->n[3] & r->n[2] & r->n[1]) == 0xFFFFFFFFFFFFFULL && r->n[0] >= 0xFFFFEFFFFFC2FULL) {\n         return 0;\n     }\n@@ -311,21 +331,42 @@ static int secp256k1_fe_set_b32(secp256k1_fe *r, const unsigned char *a) {\n \n /** Convert a field element to a 32-byte big endian value. Requires the input to be normalized */\n static void secp256k1_fe_get_b32(unsigned char *r, const secp256k1_fe *a) {\n-    int i;\n #ifdef VERIFY\n     VERIFY_CHECK(a->normalized);\n     secp256k1_fe_verify(a);\n #endif\n-    for (i=0; i<32; i++) {\n-        int j;\n-        int c = 0;\n-        for (j=0; j<2; j++) {\n-            int limb = (8*i+4*j)/52;\n-            int shift = (8*i+4*j)%52;\n-            c |= ((a->n[limb] >> shift) & 0xF) << (4 * j);\n-        }\n-        r[31-i] = c;\n-    }\n+    r[0] = (a->n[4] >> 40) & 0xFF;\n+    r[1] = (a->n[4] >> 32) & 0xFF;\n+    r[2] = (a->n[4] >> 24) & 0xFF;\n+    r[3] = (a->n[4] >> 16) & 0xFF;\n+    r[4] = (a->n[4] >> 8) & 0xFF;\n+    r[5] = a->n[4] & 0xFF;\n+    r[6] = (a->n[3] >> 44) & 0xFF;\n+    r[7] = (a->n[3] >> 36) & 0xFF;\n+    r[8] = (a->n[3] >> 28) & 0xFF;\n+    r[9] = (a->n[3] >> 20) & 0xFF;\n+    r[10] = (a->n[3] >> 12) & 0xFF;\n+    r[11] = (a->n[3] >> 4) & 0xFF;\n+    r[12] = ((a->n[2] >> 48) & 0xF) | ((a->n[3] & 0xF) << 4);\n+    r[13] = (a->n[2] >> 40) & 0xFF;\n+    r[14] = (a->n[2] >> 32) & 0xFF;\n+    r[15] = (a->n[2] >> 24) & 0xFF;\n+    r[16] = (a->n[2] >> 16) & 0xFF;\n+    r[17] = (a->n[2] >> 8) & 0xFF;\n+    r[18] = a->n[2] & 0xFF;\n+    r[19] = (a->n[1] >> 44) & 0xFF;\n+    r[20] = (a->n[1] >> 36) & 0xFF;\n+    r[21] = (a->n[1] >> 28) & 0xFF;\n+    r[22] = (a->n[1] >> 20) & 0xFF;\n+    r[23] = (a->n[1] >> 12) & 0xFF;\n+    r[24] = (a->n[1] >> 4) & 0xFF;\n+    r[25] = ((a->n[0] >> 48) & 0xF) | ((a->n[1] & 0xF) << 4);\n+    r[26] = (a->n[0] >> 40) & 0xFF;\n+    r[27] = (a->n[0] >> 32) & 0xFF;\n+    r[28] = (a->n[0] >> 24) & 0xFF;\n+    r[29] = (a->n[0] >> 16) & 0xFF;\n+    r[30] = (a->n[0] >> 8) & 0xFF;\n+    r[31] = a->n[0] & 0xFF;\n }\n \n SECP256K1_INLINE static void secp256k1_fe_negate(secp256k1_fe *r, const secp256k1_fe *a, int m) {"
      },
      {
        "sha": "7d723532ff3e12c1767540d019e35ede17a7c6c4",
        "filename": "src/group_impl.h",
        "status": "modified",
        "additions": 0,
        "deletions": 6,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e7c1b4490f2c559b050b8255df2d347dd0e4945f/src/group_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e7c1b4490f2c559b050b8255df2d347dd0e4945f/src/group_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/group_impl.h?ref=e7c1b4490f2c559b050b8255df2d347dd0e4945f",
        "patch": "@@ -200,12 +200,6 @@ static void secp256k1_gej_set_infinity(secp256k1_gej *r) {\n     secp256k1_fe_clear(&r->z);\n }\n \n-static void secp256k1_ge_set_infinity(secp256k1_ge *r) {\n-    r->infinity = 1;\n-    secp256k1_fe_clear(&r->x);\n-    secp256k1_fe_clear(&r->y);\n-}\n-\n static void secp256k1_gej_clear(secp256k1_gej *r) {\n     r->infinity = 0;\n     secp256k1_fe_clear(&r->x);"
      },
      {
        "sha": "9e30fb73dd7fb98b6e860cfb9054f1d66fb4089a",
        "filename": "src/modules/ecdh/main_impl.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e7c1b4490f2c559b050b8255df2d347dd0e4945f/src/modules/ecdh/main_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e7c1b4490f2c559b050b8255df2d347dd0e4945f/src/modules/ecdh/main_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/ecdh/main_impl.h?ref=e7c1b4490f2c559b050b8255df2d347dd0e4945f",
        "patch": "@@ -16,10 +16,10 @@ int secp256k1_ecdh(const secp256k1_context* ctx, unsigned char *result, const se\n     secp256k1_gej res;\n     secp256k1_ge pt;\n     secp256k1_scalar s;\n+    VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(result != NULL);\n     ARG_CHECK(point != NULL);\n     ARG_CHECK(scalar != NULL);\n-    (void)ctx;\n \n     secp256k1_pubkey_load(ctx, &pt, point);\n     secp256k1_scalar_set_b32(&s, scalar, &overflow);"
      },
      {
        "sha": "85a5d0a9a69e10d585c2bc2ad4df03f14cf0def6",
        "filename": "src/modules/ecdh/tests_impl.h",
        "status": "modified",
        "additions": 30,
        "deletions": 0,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e7c1b4490f2c559b050b8255df2d347dd0e4945f/src/modules/ecdh/tests_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e7c1b4490f2c559b050b8255df2d347dd0e4945f/src/modules/ecdh/tests_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/ecdh/tests_impl.h?ref=e7c1b4490f2c559b050b8255df2d347dd0e4945f",
        "patch": "@@ -7,6 +7,35 @@\n #ifndef _SECP256K1_MODULE_ECDH_TESTS_\n #define _SECP256K1_MODULE_ECDH_TESTS_\n \n+void test_ecdh_api(void) {\n+    /* Setup context that just counts errors */\n+    secp256k1_context *tctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN);\n+    secp256k1_pubkey point;\n+    unsigned char res[32];\n+    unsigned char s_one[32] = { 0 };\n+    int32_t ecount = 0;\n+    s_one[31] = 1;\n+\n+    secp256k1_context_set_error_callback(tctx, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_illegal_callback(tctx, counting_illegal_callback_fn, &ecount);\n+    CHECK(secp256k1_ec_pubkey_create(tctx, &point, s_one) == 1);\n+\n+    /* Check all NULLs are detected */\n+    CHECK(secp256k1_ecdh(tctx, res, &point, s_one) == 1);\n+    CHECK(ecount == 0);\n+    CHECK(secp256k1_ecdh(tctx, NULL, &point, s_one) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_ecdh(tctx, res, NULL, s_one) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_ecdh(tctx, res, &point, NULL) == 0);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_ecdh(tctx, res, &point, s_one) == 1);\n+    CHECK(ecount == 3);\n+\n+    /* Cleanup */\n+    secp256k1_context_destroy(tctx);\n+}\n+\n void test_ecdh_generator_basepoint(void) {\n     unsigned char s_one[32] = { 0 };\n     secp256k1_pubkey point[2];\n@@ -68,6 +97,7 @@ void test_bad_scalar(void) {\n }\n \n void run_ecdh_tests(void) {\n+    test_ecdh_api();\n     test_ecdh_generator_basepoint();\n     test_bad_scalar();\n }"
      },
      {
        "sha": "c6fbe239813a3e45559bd36098d3d2ca2dac145a",
        "filename": "src/modules/recovery/main_impl.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e7c1b4490f2c559b050b8255df2d347dd0e4945f/src/modules/recovery/main_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e7c1b4490f2c559b050b8255df2d347dd0e4945f/src/modules/recovery/main_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/recovery/main_impl.h?ref=e7c1b4490f2c559b050b8255df2d347dd0e4945f",
        "patch": "@@ -179,7 +179,7 @@ int secp256k1_ecdsa_recover(const secp256k1_context* ctx, secp256k1_pubkey *pubk\n     ARG_CHECK(pubkey != NULL);\n \n     secp256k1_ecdsa_recoverable_signature_load(ctx, &r, &s, &recid, signature);\n-    ARG_CHECK(recid >= 0 && recid < 4);\n+    VERIFY_CHECK(recid >= 0 && recid < 4);  /* should have been caught in parse_compact */\n     secp256k1_scalar_set_b32(&m, msg32, NULL);\n     if (secp256k1_ecdsa_sig_recover(&ctx->ecmult_ctx, &r, &s, &q, &m, recid)) {\n         secp256k1_pubkey_save(pubkey, &q);"
      },
      {
        "sha": "765c7dd81e958c9ca37ee50117b286e90b6c7f7f",
        "filename": "src/modules/recovery/tests_impl.h",
        "status": "modified",
        "additions": 143,
        "deletions": 0,
        "changes": 143,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e7c1b4490f2c559b050b8255df2d347dd0e4945f/src/modules/recovery/tests_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e7c1b4490f2c559b050b8255df2d347dd0e4945f/src/modules/recovery/tests_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/modules/recovery/tests_impl.h?ref=e7c1b4490f2c559b050b8255df2d347dd0e4945f",
        "patch": "@@ -7,6 +7,146 @@\n #ifndef _SECP256K1_MODULE_RECOVERY_TESTS_\n #define _SECP256K1_MODULE_RECOVERY_TESTS_\n \n+static int recovery_test_nonce_function(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *algo16, void *data, unsigned int counter) {\n+    (void) msg32;\n+    (void) key32;\n+    (void) algo16;\n+    (void) data;\n+\n+    /* On the first run, return 0 to force a second run */\n+    if (counter == 0) {\n+        memset(nonce32, 0, 32);\n+        return 1;\n+    }\n+    /* On the second run, return an overflow to force a third run */\n+    if (counter == 1) {\n+        memset(nonce32, 0xff, 32);\n+        return 1;\n+    }\n+    /* On the next run, return a valid nonce, but flip a coin as to whether or not to fail signing. */\n+    memset(nonce32, 1, 32);\n+    return secp256k1_rand_bits(1);\n+}\n+\n+void test_ecdsa_recovery_api(void) {\n+    /* Setup contexts that just count errors */\n+    secp256k1_context *none = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    secp256k1_context *sign = secp256k1_context_create(SECP256K1_CONTEXT_SIGN);\n+    secp256k1_context *vrfy = secp256k1_context_create(SECP256K1_CONTEXT_VERIFY);\n+    secp256k1_context *both = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n+    secp256k1_pubkey pubkey;\n+    secp256k1_pubkey recpubkey;\n+    secp256k1_ecdsa_signature normal_sig;\n+    secp256k1_ecdsa_recoverable_signature recsig;\n+    unsigned char privkey[32] = { 1 };\n+    unsigned char message[32] = { 2 };\n+    int32_t ecount = 0;\n+    int recid = 0;\n+    unsigned char sig[74];\n+    unsigned char zero_privkey[32] = { 0 };\n+    unsigned char over_privkey[32] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+                                       0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+                                       0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+                                       0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };\n+\n+    secp256k1_context_set_error_callback(none, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_error_callback(sign, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_error_callback(vrfy, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_error_callback(both, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_illegal_callback(none, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_illegal_callback(sign, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_illegal_callback(vrfy, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_illegal_callback(both, counting_illegal_callback_fn, &ecount);\n+\n+    /* Construct and verify corresponding public key. */\n+    CHECK(secp256k1_ec_seckey_verify(ctx, privkey) == 1);\n+    CHECK(secp256k1_ec_pubkey_create(ctx, &pubkey, privkey) == 1);\n+\n+    /* Check bad contexts and NULLs for signing */\n+    ecount = 0;\n+    CHECK(secp256k1_ecdsa_sign_recoverable(none, &recsig, message, privkey, NULL, NULL) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_ecdsa_sign_recoverable(sign, &recsig, message, privkey, NULL, NULL) == 1);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_ecdsa_sign_recoverable(vrfy, &recsig, message, privkey, NULL, NULL) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_ecdsa_sign_recoverable(both, &recsig, message, privkey, NULL, NULL) == 1);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_ecdsa_sign_recoverable(both, NULL, message, privkey, NULL, NULL) == 0);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_ecdsa_sign_recoverable(both, &recsig, NULL, privkey, NULL, NULL) == 0);\n+    CHECK(ecount == 4);\n+    CHECK(secp256k1_ecdsa_sign_recoverable(both, &recsig, message, NULL, NULL, NULL) == 0);\n+    CHECK(ecount == 5);\n+    /* This will fail or succeed randomly, and in either case will not ARG_CHECK failure */\n+    secp256k1_ecdsa_sign_recoverable(both, &recsig, message, privkey, recovery_test_nonce_function, NULL);\n+    CHECK(ecount == 5);\n+    /* These will all fail, but not in ARG_CHECK way */\n+    CHECK(secp256k1_ecdsa_sign_recoverable(both, &recsig, message, zero_privkey, NULL, NULL) == 0);\n+    CHECK(secp256k1_ecdsa_sign_recoverable(both, &recsig, message, over_privkey, NULL, NULL) == 0);\n+    /* This one will succeed. */\n+    CHECK(secp256k1_ecdsa_sign_recoverable(both, &recsig, message, privkey, NULL, NULL) == 1);\n+    CHECK(ecount == 5);\n+\n+    /* Check signing with a goofy nonce function */\n+\n+    /* Check bad contexts and NULLs for recovery */\n+    ecount = 0;\n+    CHECK(secp256k1_ecdsa_recover(none, &recpubkey, &recsig, message) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_ecdsa_recover(sign, &recpubkey, &recsig, message) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_ecdsa_recover(vrfy, &recpubkey, &recsig, message) == 1);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_ecdsa_recover(both, &recpubkey, &recsig, message) == 1);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_ecdsa_recover(both, NULL, &recsig, message) == 0);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_ecdsa_recover(both, &recpubkey, NULL, message) == 0);\n+    CHECK(ecount == 4);\n+    CHECK(secp256k1_ecdsa_recover(both, &recpubkey, &recsig, NULL) == 0);\n+    CHECK(ecount == 5);\n+\n+    /* Check NULLs for conversion */\n+    CHECK(secp256k1_ecdsa_sign(both, &normal_sig, message, privkey, NULL, NULL) == 1);\n+    ecount = 0;\n+    CHECK(secp256k1_ecdsa_recoverable_signature_convert(both, NULL, &recsig) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_ecdsa_recoverable_signature_convert(both, &normal_sig, NULL) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_ecdsa_recoverable_signature_convert(both, &normal_sig, &recsig) == 1);\n+\n+    /* Check NULLs for de/serialization */\n+    CHECK(secp256k1_ecdsa_sign_recoverable(both, &recsig, message, privkey, NULL, NULL) == 1);\n+    ecount = 0;\n+    CHECK(secp256k1_ecdsa_recoverable_signature_serialize_compact(both, NULL, &recid, &recsig) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_ecdsa_recoverable_signature_serialize_compact(both, sig, NULL, &recsig) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_ecdsa_recoverable_signature_serialize_compact(both, sig, &recid, NULL) == 0);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_ecdsa_recoverable_signature_serialize_compact(both, sig, &recid, &recsig) == 1);\n+\n+    CHECK(secp256k1_ecdsa_recoverable_signature_parse_compact(both, NULL, sig, recid) == 0);\n+    CHECK(ecount == 4);\n+    CHECK(secp256k1_ecdsa_recoverable_signature_parse_compact(both, &recsig, NULL, recid) == 0);\n+    CHECK(ecount == 5);\n+    CHECK(secp256k1_ecdsa_recoverable_signature_parse_compact(both, &recsig, sig, -1) == 0);\n+    CHECK(ecount == 6);\n+    CHECK(secp256k1_ecdsa_recoverable_signature_parse_compact(both, &recsig, sig, 5) == 0);\n+    CHECK(ecount == 7);\n+    /* overflow in signature will fail but not affect ecount */\n+    memcpy(sig, over_privkey, 32);\n+    CHECK(secp256k1_ecdsa_recoverable_signature_parse_compact(both, &recsig, sig, recid) == 0);\n+    CHECK(ecount == 7);\n+\n+    /* cleanup */\n+    secp256k1_context_destroy(none);\n+    secp256k1_context_destroy(sign);\n+    secp256k1_context_destroy(vrfy);\n+    secp256k1_context_destroy(both);\n+}\n+\n void test_ecdsa_recovery_end_to_end(void) {\n     unsigned char extra[32] = {0x00};\n     unsigned char privkey[32];\n@@ -241,6 +381,9 @@ void test_ecdsa_recovery_edge_cases(void) {\n \n void run_recovery_tests(void) {\n     int i;\n+    for (i = 0; i < count; i++) {\n+        test_ecdsa_recovery_api();\n+    }\n     for (i = 0; i < 64*count; i++) {\n         test_ecdsa_recovery_end_to_end();\n     }"
      },
      {
        "sha": "2690d86558a9a1973ee5f4cc9c339c527718c54c",
        "filename": "src/scalar_impl.h",
        "status": "modified",
        "additions": 67,
        "deletions": 104,
        "changes": 171,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e7c1b4490f2c559b050b8255df2d347dd0e4945f/src/scalar_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e7c1b4490f2c559b050b8255df2d347dd0e4945f/src/scalar_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scalar_impl.h?ref=e7c1b4490f2c559b050b8255df2d347dd0e4945f",
        "patch": "@@ -66,88 +66,79 @@ static void secp256k1_scalar_inverse(secp256k1_scalar *r, const secp256k1_scalar\n #else\n     secp256k1_scalar *t;\n     int i;\n-    /* First compute x ^ (2^N - 1) for some values of N. */\n-    secp256k1_scalar x2, x3, x4, x6, x7, x8, x15, x30, x60, x120, x127;\n+    /* First compute xN as x ^ (2^N - 1) for some values of N,\n+     * and uM as x ^ M for some values of M. */\n+    secp256k1_scalar x2, x3, x6, x8, x14, x28, x56, x112, x126;\n+    secp256k1_scalar u2, u5, u9, u11, u13;\n \n-    secp256k1_scalar_sqr(&x2,  x);\n-    secp256k1_scalar_mul(&x2, &x2,  x);\n+    secp256k1_scalar_sqr(&u2, x);\n+    secp256k1_scalar_mul(&x2, &u2,  x);\n+    secp256k1_scalar_mul(&u5, &u2, &x2);\n+    secp256k1_scalar_mul(&x3, &u5,  &u2);\n+    secp256k1_scalar_mul(&u9, &x3, &u2);\n+    secp256k1_scalar_mul(&u11, &u9, &u2);\n+    secp256k1_scalar_mul(&u13, &u11, &u2);\n \n-    secp256k1_scalar_sqr(&x3, &x2);\n-    secp256k1_scalar_mul(&x3, &x3,  x);\n-\n-    secp256k1_scalar_sqr(&x4, &x3);\n-    secp256k1_scalar_mul(&x4, &x4,  x);\n-\n-    secp256k1_scalar_sqr(&x6, &x4);\n+    secp256k1_scalar_sqr(&x6, &u13);\n     secp256k1_scalar_sqr(&x6, &x6);\n-    secp256k1_scalar_mul(&x6, &x6, &x2);\n-\n-    secp256k1_scalar_sqr(&x7, &x6);\n-    secp256k1_scalar_mul(&x7, &x7,  x);\n+    secp256k1_scalar_mul(&x6, &x6, &u11);\n \n-    secp256k1_scalar_sqr(&x8, &x7);\n-    secp256k1_scalar_mul(&x8, &x8,  x);\n+    secp256k1_scalar_sqr(&x8, &x6);\n+    secp256k1_scalar_sqr(&x8, &x8);\n+    secp256k1_scalar_mul(&x8, &x8,  &x2);\n \n-    secp256k1_scalar_sqr(&x15, &x8);\n-    for (i = 0; i < 6; i++) {\n-        secp256k1_scalar_sqr(&x15, &x15);\n+    secp256k1_scalar_sqr(&x14, &x8);\n+    for (i = 0; i < 5; i++) {\n+        secp256k1_scalar_sqr(&x14, &x14);\n     }\n-    secp256k1_scalar_mul(&x15, &x15, &x7);\n+    secp256k1_scalar_mul(&x14, &x14, &x6);\n \n-    secp256k1_scalar_sqr(&x30, &x15);\n-    for (i = 0; i < 14; i++) {\n-        secp256k1_scalar_sqr(&x30, &x30);\n+    secp256k1_scalar_sqr(&x28, &x14);\n+    for (i = 0; i < 13; i++) {\n+        secp256k1_scalar_sqr(&x28, &x28);\n     }\n-    secp256k1_scalar_mul(&x30, &x30, &x15);\n+    secp256k1_scalar_mul(&x28, &x28, &x14);\n \n-    secp256k1_scalar_sqr(&x60, &x30);\n-    for (i = 0; i < 29; i++) {\n-        secp256k1_scalar_sqr(&x60, &x60);\n+    secp256k1_scalar_sqr(&x56, &x28);\n+    for (i = 0; i < 27; i++) {\n+        secp256k1_scalar_sqr(&x56, &x56);\n     }\n-    secp256k1_scalar_mul(&x60, &x60, &x30);\n+    secp256k1_scalar_mul(&x56, &x56, &x28);\n \n-    secp256k1_scalar_sqr(&x120, &x60);\n-    for (i = 0; i < 59; i++) {\n-        secp256k1_scalar_sqr(&x120, &x120);\n+    secp256k1_scalar_sqr(&x112, &x56);\n+    for (i = 0; i < 55; i++) {\n+        secp256k1_scalar_sqr(&x112, &x112);\n     }\n-    secp256k1_scalar_mul(&x120, &x120, &x60);\n+    secp256k1_scalar_mul(&x112, &x112, &x56);\n \n-    secp256k1_scalar_sqr(&x127, &x120);\n-    for (i = 0; i < 6; i++) {\n-        secp256k1_scalar_sqr(&x127, &x127);\n+    secp256k1_scalar_sqr(&x126, &x112);\n+    for (i = 0; i < 13; i++) {\n+        secp256k1_scalar_sqr(&x126, &x126);\n     }\n-    secp256k1_scalar_mul(&x127, &x127, &x7);\n+    secp256k1_scalar_mul(&x126, &x126, &x14);\n \n-    /* Then accumulate the final result (t starts at x127). */\n-    t = &x127;\n-    for (i = 0; i < 2; i++) { /* 0 */\n+    /* Then accumulate the final result (t starts at x126). */\n+    t = &x126;\n+    for (i = 0; i < 3; i++) {\n         secp256k1_scalar_sqr(t, t);\n     }\n-    secp256k1_scalar_mul(t, t, x); /* 1 */\n+    secp256k1_scalar_mul(t, t, &u5); /* 101 */\n     for (i = 0; i < 4; i++) { /* 0 */\n         secp256k1_scalar_sqr(t, t);\n     }\n     secp256k1_scalar_mul(t, t, &x3); /* 111 */\n-    for (i = 0; i < 2; i++) { /* 0 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 2; i++) { /* 0 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 2; i++) { /* 0 */\n+    for (i = 0; i < 4; i++) { /* 0 */\n         secp256k1_scalar_sqr(t, t);\n     }\n-    secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 4; i++) { /* 0 */\n+    secp256k1_scalar_mul(t, t, &u5); /* 101 */\n+    for (i = 0; i < 5; i++) { /* 0 */\n         secp256k1_scalar_sqr(t, t);\n     }\n-    secp256k1_scalar_mul(t, t, &x3); /* 111 */\n-    for (i = 0; i < 3; i++) { /* 0 */\n+    secp256k1_scalar_mul(t, t, &u11); /* 1011 */\n+    for (i = 0; i < 4; i++) {\n         secp256k1_scalar_sqr(t, t);\n     }\n-    secp256k1_scalar_mul(t, t, &x2); /* 11 */\n+    secp256k1_scalar_mul(t, t, &u11); /* 1011 */\n     for (i = 0; i < 4; i++) { /* 0 */\n         secp256k1_scalar_sqr(t, t);\n     }\n@@ -156,38 +147,26 @@ static void secp256k1_scalar_inverse(secp256k1_scalar *r, const secp256k1_scalar\n         secp256k1_scalar_sqr(t, t);\n     }\n     secp256k1_scalar_mul(t, t, &x3); /* 111 */\n-    for (i = 0; i < 4; i++) { /* 00 */\n+    for (i = 0; i < 6; i++) { /* 00 */\n         secp256k1_scalar_sqr(t, t);\n     }\n-    secp256k1_scalar_mul(t, t, &x2); /* 11 */\n-    for (i = 0; i < 2; i++) { /* 0 */\n+    secp256k1_scalar_mul(t, t, &u13); /* 1101 */\n+    for (i = 0; i < 4; i++) { /* 0 */\n         secp256k1_scalar_sqr(t, t);\n     }\n-    secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 2; i++) { /* 0 */\n+    secp256k1_scalar_mul(t, t, &u5); /* 101 */\n+    for (i = 0; i < 3; i++) {\n         secp256k1_scalar_sqr(t, t);\n     }\n-    secp256k1_scalar_mul(t, t, x); /* 1 */\n+    secp256k1_scalar_mul(t, t, &x3); /* 111 */\n     for (i = 0; i < 5; i++) { /* 0 */\n         secp256k1_scalar_sqr(t, t);\n     }\n-    secp256k1_scalar_mul(t, t, &x4); /* 1111 */\n-    for (i = 0; i < 2; i++) { /* 0 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 3; i++) { /* 00 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 4; i++) { /* 000 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 2; i++) { /* 0 */\n+    secp256k1_scalar_mul(t, t, &u9); /* 1001 */\n+    for (i = 0; i < 6; i++) { /* 000 */\n         secp256k1_scalar_sqr(t, t);\n     }\n-    secp256k1_scalar_mul(t, t, x); /* 1 */\n+    secp256k1_scalar_mul(t, t, &u5); /* 101 */\n     for (i = 0; i < 10; i++) { /* 0000000 */\n         secp256k1_scalar_sqr(t, t);\n     }\n@@ -200,50 +179,34 @@ static void secp256k1_scalar_inverse(secp256k1_scalar *r, const secp256k1_scalar\n         secp256k1_scalar_sqr(t, t);\n     }\n     secp256k1_scalar_mul(t, t, &x8); /* 11111111 */\n-    for (i = 0; i < 2; i++) { /* 0 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 3; i++) { /* 00 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 3; i++) { /* 00 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, x); /* 1 */\n     for (i = 0; i < 5; i++) { /* 0 */\n         secp256k1_scalar_sqr(t, t);\n     }\n-    secp256k1_scalar_mul(t, t, &x4); /* 1111 */\n-    for (i = 0; i < 2; i++) { /* 0 */\n+    secp256k1_scalar_mul(t, t, &u9); /* 1001 */\n+    for (i = 0; i < 6; i++) { /* 00 */\n         secp256k1_scalar_sqr(t, t);\n     }\n-    secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 5; i++) { /* 000 */\n+    secp256k1_scalar_mul(t, t, &u11); /* 1011 */\n+    for (i = 0; i < 4; i++) {\n         secp256k1_scalar_sqr(t, t);\n     }\n-    secp256k1_scalar_mul(t, t, &x2); /* 11 */\n-    for (i = 0; i < 4; i++) { /* 00 */\n+    secp256k1_scalar_mul(t, t, &u13); /* 1101 */\n+    for (i = 0; i < 5; i++) {\n         secp256k1_scalar_sqr(t, t);\n     }\n     secp256k1_scalar_mul(t, t, &x2); /* 11 */\n-    for (i = 0; i < 2; i++) { /* 0 */\n+    for (i = 0; i < 6; i++) { /* 00 */\n         secp256k1_scalar_sqr(t, t);\n     }\n-    secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 8; i++) { /* 000000 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, &x2); /* 11 */\n-    for (i = 0; i < 3; i++) { /* 0 */\n+    secp256k1_scalar_mul(t, t, &u13); /* 1101 */\n+    for (i = 0; i < 10; i++) { /* 000000 */\n         secp256k1_scalar_sqr(t, t);\n     }\n-    secp256k1_scalar_mul(t, t, &x2); /* 11 */\n-    for (i = 0; i < 3; i++) { /* 00 */\n+    secp256k1_scalar_mul(t, t, &u13); /* 1101 */\n+    for (i = 0; i < 4; i++) {\n         secp256k1_scalar_sqr(t, t);\n     }\n-    secp256k1_scalar_mul(t, t, x); /* 1 */\n+    secp256k1_scalar_mul(t, t, &u9); /* 1001 */\n     for (i = 0; i < 6; i++) { /* 00000 */\n         secp256k1_scalar_sqr(t, t);\n     }"
      },
      {
        "sha": "4f8c01655bd00eed0565b698f7029421b5fd1562",
        "filename": "src/secp256k1.c",
        "status": "modified",
        "additions": 27,
        "deletions": 4,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e7c1b4490f2c559b050b8255df2d347dd0e4945f/src/secp256k1.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e7c1b4490f2c559b050b8255df2d347dd0e4945f/src/secp256k1.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1.c?ref=e7c1b4490f2c559b050b8255df2d347dd0e4945f",
        "patch": "@@ -424,6 +424,33 @@ int secp256k1_ec_pubkey_create(const secp256k1_context* ctx, secp256k1_pubkey *p\n     return ret;\n }\n \n+int secp256k1_ec_privkey_negate(const secp256k1_context* ctx, unsigned char *seckey) {\n+    secp256k1_scalar sec;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    secp256k1_scalar_set_b32(&sec, seckey, NULL);\n+    secp256k1_scalar_negate(&sec, &sec);\n+    secp256k1_scalar_get_b32(seckey, &sec);\n+\n+    return 1;\n+}\n+\n+int secp256k1_ec_pubkey_negate(const secp256k1_context* ctx, secp256k1_pubkey *pubkey) {\n+    int ret = 0;\n+    secp256k1_ge p;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    ret = secp256k1_pubkey_load(ctx, &p, pubkey);\n+    memset(pubkey, 0, sizeof(*pubkey));\n+    if (ret) {\n+        secp256k1_ge_neg(&p, &p);\n+        secp256k1_pubkey_save(pubkey, &p);\n+    }\n+    return ret;\n+}\n+\n int secp256k1_ec_privkey_tweak_add(const secp256k1_context* ctx, unsigned char *seckey, const unsigned char *tweak) {\n     secp256k1_scalar term;\n     secp256k1_scalar sec;\n@@ -552,10 +579,6 @@ int secp256k1_ec_pubkey_combine(const secp256k1_context* ctx, secp256k1_pubkey *\n # include \"modules/ecdh/main_impl.h\"\n #endif\n \n-#ifdef ENABLE_MODULE_SCHNORR\n-# include \"modules/schnorr/main_impl.h\"\n-#endif\n-\n #ifdef ENABLE_MODULE_RECOVERY\n # include \"modules/recovery/main_impl.h\"\n #endif"
      },
      {
        "sha": "3d9bd5ebb48d46dff2d677976f850ad8809592e7",
        "filename": "src/tests.c",
        "status": "modified",
        "additions": 31,
        "deletions": 20,
        "changes": 51,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e7c1b4490f2c559b050b8255df2d347dd0e4945f/src/tests.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e7c1b4490f2c559b050b8255df2d347dd0e4945f/src/tests.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/tests.c?ref=e7c1b4490f2c559b050b8255df2d347dd0e4945f",
        "patch": "@@ -10,6 +10,7 @@\n \n #include <stdio.h>\n #include <stdlib.h>\n+#include <string.h>\n \n #include <time.h>\n \n@@ -135,6 +136,7 @@ void random_scalar_order(secp256k1_scalar *num) {\n \n void run_context_tests(void) {\n     secp256k1_pubkey pubkey;\n+    secp256k1_pubkey zero_pubkey;\n     secp256k1_ecdsa_signature sig;\n     unsigned char ctmp[32];\n     int32_t ecount;\n@@ -149,6 +151,8 @@ void run_context_tests(void) {\n     secp256k1_scalar msg, key, nonce;\n     secp256k1_scalar sigr, sigs;\n \n+    memset(&zero_pubkey, 0, sizeof(zero_pubkey));\n+\n     ecount = 0;\n     ecount2 = 10;\n     secp256k1_context_set_illegal_callback(vrfy, counting_illegal_callback_fn, &ecount);\n@@ -201,12 +205,20 @@ void run_context_tests(void) {\n     CHECK(ecount == 2);\n     CHECK(secp256k1_ec_pubkey_tweak_mul(sign, &pubkey, ctmp) == 0);\n     CHECK(ecount2 == 13);\n-    CHECK(secp256k1_ec_pubkey_tweak_mul(vrfy, &pubkey, ctmp) == 1);\n+    CHECK(secp256k1_ec_pubkey_negate(vrfy, &pubkey) == 1);\n     CHECK(ecount == 2);\n-    CHECK(secp256k1_context_randomize(vrfy, ctmp) == 0);\n+    CHECK(secp256k1_ec_pubkey_negate(sign, &pubkey) == 1);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_ec_pubkey_negate(sign, NULL) == 0);\n+    CHECK(ecount2 == 14);\n+    CHECK(secp256k1_ec_pubkey_negate(vrfy, &zero_pubkey) == 0);\n     CHECK(ecount == 3);\n+    CHECK(secp256k1_ec_pubkey_tweak_mul(vrfy, &pubkey, ctmp) == 1);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_context_randomize(vrfy, ctmp) == 0);\n+    CHECK(ecount == 4);\n     CHECK(secp256k1_context_randomize(sign, NULL) == 1);\n-    CHECK(ecount2 == 13);\n+    CHECK(ecount2 == 14);\n     secp256k1_context_set_illegal_callback(vrfy, NULL, NULL);\n     secp256k1_context_set_illegal_callback(sign, NULL, NULL);\n \n@@ -1879,9 +1891,9 @@ void test_ge(void) {\n      *\n      * When the endomorphism code is compiled in, p5 = lambda*p1 and p6 = lambda^2*p1 are added as well.\n      */\n-    secp256k1_ge *ge = (secp256k1_ge *)malloc(sizeof(secp256k1_ge) * (1 + 4 * runs));\n-    secp256k1_gej *gej = (secp256k1_gej *)malloc(sizeof(secp256k1_gej) * (1 + 4 * runs));\n-    secp256k1_fe *zinv = (secp256k1_fe *)malloc(sizeof(secp256k1_fe) * (1 + 4 * runs));\n+    secp256k1_ge *ge = (secp256k1_ge *)checked_malloc(&ctx->error_callback, sizeof(secp256k1_ge) * (1 + 4 * runs));\n+    secp256k1_gej *gej = (secp256k1_gej *)checked_malloc(&ctx->error_callback, sizeof(secp256k1_gej) * (1 + 4 * runs));\n+    secp256k1_fe *zinv = (secp256k1_fe *)checked_malloc(&ctx->error_callback, sizeof(secp256k1_fe) * (1 + 4 * runs));\n     secp256k1_fe zf;\n     secp256k1_fe zfi2, zfi3;\n \n@@ -1919,7 +1931,7 @@ void test_ge(void) {\n \n     /* Compute z inverses. */\n     {\n-        secp256k1_fe *zs = malloc(sizeof(secp256k1_fe) * (1 + 4 * runs));\n+        secp256k1_fe *zs = checked_malloc(&ctx->error_callback, sizeof(secp256k1_fe) * (1 + 4 * runs));\n         for (i = 0; i < 4 * runs + 1; i++) {\n             if (i == 0) {\n                 /* The point at infinity does not have a meaningful z inverse. Any should do. */\n@@ -2020,7 +2032,7 @@ void test_ge(void) {\n     /* Test adding all points together in random order equals infinity. */\n     {\n         secp256k1_gej sum = SECP256K1_GEJ_CONST_INFINITY;\n-        secp256k1_gej *gej_shuffled = (secp256k1_gej *)malloc((4 * runs + 1) * sizeof(secp256k1_gej));\n+        secp256k1_gej *gej_shuffled = (secp256k1_gej *)checked_malloc(&ctx->error_callback, (4 * runs + 1) * sizeof(secp256k1_gej));\n         for (i = 0; i < 4 * runs + 1; i++) {\n             gej_shuffled[i] = gej[i];\n         }\n@@ -2041,9 +2053,9 @@ void test_ge(void) {\n \n     /* Test batch gej -> ge conversion with and without known z ratios. */\n     {\n-        secp256k1_fe *zr = (secp256k1_fe *)malloc((4 * runs + 1) * sizeof(secp256k1_fe));\n-        secp256k1_ge *ge_set_table = (secp256k1_ge *)malloc((4 * runs + 1) * sizeof(secp256k1_ge));\n-        secp256k1_ge *ge_set_all = (secp256k1_ge *)malloc((4 * runs + 1) * sizeof(secp256k1_ge));\n+        secp256k1_fe *zr = (secp256k1_fe *)checked_malloc(&ctx->error_callback, (4 * runs + 1) * sizeof(secp256k1_fe));\n+        secp256k1_ge *ge_set_table = (secp256k1_ge *)checked_malloc(&ctx->error_callback, (4 * runs + 1) * sizeof(secp256k1_ge));\n+        secp256k1_ge *ge_set_all = (secp256k1_ge *)checked_malloc(&ctx->error_callback, (4 * runs + 1) * sizeof(secp256k1_ge));\n         for (i = 0; i < 4 * runs + 1; i++) {\n             /* Compute gej[i + 1].z / gez[i].z (with gej[n].z taken to be 1). */\n             if (i < 4 * runs) {\n@@ -3436,6 +3448,7 @@ void test_ecdsa_end_to_end(void) {\n     unsigned char pubkeyc[65];\n     size_t pubkeyclen = 65;\n     secp256k1_pubkey pubkey;\n+    secp256k1_pubkey pubkey_tmp;\n     unsigned char seckey[300];\n     size_t seckeylen = 300;\n \n@@ -3457,6 +3470,13 @@ void test_ecdsa_end_to_end(void) {\n     memset(&pubkey, 0, sizeof(pubkey));\n     CHECK(secp256k1_ec_pubkey_parse(ctx, &pubkey, pubkeyc, pubkeyclen) == 1);\n \n+    /* Verify negation changes the key and changes it back */\n+    memcpy(&pubkey_tmp, &pubkey, sizeof(pubkey));\n+    CHECK(secp256k1_ec_pubkey_negate(ctx, &pubkey_tmp) == 1);\n+    CHECK(memcmp(&pubkey_tmp, &pubkey, sizeof(pubkey)) != 0);\n+    CHECK(secp256k1_ec_pubkey_negate(ctx, &pubkey_tmp) == 1);\n+    CHECK(memcmp(&pubkey_tmp, &pubkey, sizeof(pubkey)) == 0);\n+\n     /* Verify private key import and export. */\n     CHECK(ec_privkey_export_der(ctx, seckey, &seckeylen, privkey, secp256k1_rand_bits(1) == 1));\n     CHECK(ec_privkey_import_der(ctx, privkey2, seckey, seckeylen) == 1);\n@@ -4383,10 +4403,6 @@ void run_ecdsa_openssl(void) {\n # include \"modules/ecdh/tests_impl.h\"\n #endif\n \n-#ifdef ENABLE_MODULE_SCHNORR\n-# include \"modules/schnorr/tests_impl.h\"\n-#endif\n-\n #ifdef ENABLE_MODULE_RECOVERY\n # include \"modules/recovery/tests_impl.h\"\n #endif\n@@ -4504,11 +4520,6 @@ int main(int argc, char **argv) {\n     run_ecdsa_openssl();\n #endif\n \n-#ifdef ENABLE_MODULE_SCHNORR\n-    /* Schnorr tests */\n-    run_schnorr_tests();\n-#endif\n-\n #ifdef ENABLE_MODULE_RECOVERY\n     /* ECDSA pubkey recovery tests */\n     run_recovery_tests();"
      },
      {
        "sha": "b040bb0733ddf1abef0b715b807d3133db37d2f8",
        "filename": "src/tests_exhaustive.c",
        "status": "modified",
        "additions": 142,
        "deletions": 1,
        "changes": 143,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e7c1b4490f2c559b050b8255df2d347dd0e4945f/src/tests_exhaustive.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e7c1b4490f2c559b050b8255df2d347dd0e4945f/src/tests_exhaustive.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/tests_exhaustive.c?ref=e7c1b4490f2c559b050b8255df2d347dd0e4945f",
        "patch": "@@ -26,6 +26,11 @@\n #include \"secp256k1.c\"\n #include \"testrand_impl.h\"\n \n+#ifdef ENABLE_MODULE_RECOVERY\n+#include \"src/modules/recovery/main_impl.h\"\n+#include \"include/secp256k1_recovery.h\"\n+#endif\n+\n /** stolen from tests.c */\n void ge_equals_ge(const secp256k1_ge *a, const secp256k1_ge *b) {\n     CHECK(a->infinity == b->infinity);\n@@ -77,7 +82,7 @@ int secp256k1_nonce_function_smallint(unsigned char *nonce32, const unsigned cha\n      * function with an increased `attempt`. So if attempt > 0 this means we\n      * need to change the nonce to avoid an infinite loop. */\n     if (attempt > 0) {\n-        (*idata)++;\n+        *idata = (*idata + 1) % EXHAUSTIVE_TEST_ORDER;\n     }\n     secp256k1_scalar_set_int(&s, *idata);\n     secp256k1_scalar_get_b32(nonce32, &s);\n@@ -244,6 +249,7 @@ void test_exhaustive_sign(const secp256k1_context *ctx, const secp256k1_ge *grou\n     for (i = 1; i < order; i++) {  /* message */\n         for (j = 1; j < order; j++) {  /* key */\n             for (k = 1; k < order; k++) {  /* nonce */\n+                const int starting_k = k;\n                 secp256k1_ecdsa_signature sig;\n                 secp256k1_scalar sk, msg, r, s, expected_r;\n                 unsigned char sk32[32], msg32[32];\n@@ -262,6 +268,11 @@ void test_exhaustive_sign(const secp256k1_context *ctx, const secp256k1_ge *grou\n                 CHECK(r == expected_r);\n                 CHECK((k * s) % order == (i + r * j) % order ||\n                       (k * (EXHAUSTIVE_TEST_ORDER - s)) % order == (i + r * j) % order);\n+\n+                /* Overflow means we've tried every possible nonce */\n+                if (k < starting_k) {\n+                    break;\n+                }\n             }\n         }\n     }\n@@ -276,6 +287,130 @@ void test_exhaustive_sign(const secp256k1_context *ctx, const secp256k1_ge *grou\n      */\n }\n \n+#ifdef ENABLE_MODULE_RECOVERY\n+void test_exhaustive_recovery_sign(const secp256k1_context *ctx, const secp256k1_ge *group, int order) {\n+    int i, j, k;\n+\n+    /* Loop */\n+    for (i = 1; i < order; i++) {  /* message */\n+        for (j = 1; j < order; j++) {  /* key */\n+            for (k = 1; k < order; k++) {  /* nonce */\n+                const int starting_k = k;\n+                secp256k1_fe r_dot_y_normalized;\n+                secp256k1_ecdsa_recoverable_signature rsig;\n+                secp256k1_ecdsa_signature sig;\n+                secp256k1_scalar sk, msg, r, s, expected_r;\n+                unsigned char sk32[32], msg32[32];\n+                int expected_recid;\n+                int recid;\n+                secp256k1_scalar_set_int(&msg, i);\n+                secp256k1_scalar_set_int(&sk, j);\n+                secp256k1_scalar_get_b32(sk32, &sk);\n+                secp256k1_scalar_get_b32(msg32, &msg);\n+\n+                secp256k1_ecdsa_sign_recoverable(ctx, &rsig, msg32, sk32, secp256k1_nonce_function_smallint, &k);\n+\n+                /* Check directly */\n+                secp256k1_ecdsa_recoverable_signature_load(ctx, &r, &s, &recid, &rsig);\n+                r_from_k(&expected_r, group, k);\n+                CHECK(r == expected_r);\n+                CHECK((k * s) % order == (i + r * j) % order ||\n+                      (k * (EXHAUSTIVE_TEST_ORDER - s)) % order == (i + r * j) % order);\n+                /* In computing the recid, there is an overflow condition that is disabled in\n+                 * scalar_low_impl.h `secp256k1_scalar_set_b32` because almost every r.y value\n+                 * will exceed the group order, and our signing code always holds out for r\n+                 * values that don't overflow, so with a proper overflow check the tests would\n+                 * loop indefinitely. */\n+                r_dot_y_normalized = group[k].y;\n+                secp256k1_fe_normalize(&r_dot_y_normalized);\n+                /* Also the recovery id is flipped depending if we hit the low-s branch */\n+                if ((k * s) % order == (i + r * j) % order) {\n+                    expected_recid = secp256k1_fe_is_odd(&r_dot_y_normalized) ? 1 : 0;\n+                } else {\n+                    expected_recid = secp256k1_fe_is_odd(&r_dot_y_normalized) ? 0 : 1;\n+                }\n+                CHECK(recid == expected_recid);\n+\n+                /* Convert to a standard sig then check */\n+                secp256k1_ecdsa_recoverable_signature_convert(ctx, &sig, &rsig);\n+                secp256k1_ecdsa_signature_load(ctx, &r, &s, &sig);\n+                /* Note that we compute expected_r *after* signing -- this is important\n+                 * because our nonce-computing function function might change k during\n+                 * signing. */\n+                r_from_k(&expected_r, group, k);\n+                CHECK(r == expected_r);\n+                CHECK((k * s) % order == (i + r * j) % order ||\n+                      (k * (EXHAUSTIVE_TEST_ORDER - s)) % order == (i + r * j) % order);\n+\n+                /* Overflow means we've tried every possible nonce */\n+                if (k < starting_k) {\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+void test_exhaustive_recovery_verify(const secp256k1_context *ctx, const secp256k1_ge *group, int order) {\n+    /* This is essentially a copy of test_exhaustive_verify, with recovery added */\n+    int s, r, msg, key;\n+    for (s = 1; s < order; s++) {\n+        for (r = 1; r < order; r++) {\n+            for (msg = 1; msg < order; msg++) {\n+                for (key = 1; key < order; key++) {\n+                    secp256k1_ge nonconst_ge;\n+                    secp256k1_ecdsa_recoverable_signature rsig;\n+                    secp256k1_ecdsa_signature sig;\n+                    secp256k1_pubkey pk;\n+                    secp256k1_scalar sk_s, msg_s, r_s, s_s;\n+                    secp256k1_scalar s_times_k_s, msg_plus_r_times_sk_s;\n+                    int recid = 0;\n+                    int k, should_verify;\n+                    unsigned char msg32[32];\n+\n+                    secp256k1_scalar_set_int(&s_s, s);\n+                    secp256k1_scalar_set_int(&r_s, r);\n+                    secp256k1_scalar_set_int(&msg_s, msg);\n+                    secp256k1_scalar_set_int(&sk_s, key);\n+                    secp256k1_scalar_get_b32(msg32, &msg_s);\n+\n+                    /* Verify by hand */\n+                    /* Run through every k value that gives us this r and check that *one* works.\n+                     * Note there could be none, there could be multiple, ECDSA is weird. */\n+                    should_verify = 0;\n+                    for (k = 0; k < order; k++) {\n+                        secp256k1_scalar check_x_s;\n+                        r_from_k(&check_x_s, group, k);\n+                        if (r_s == check_x_s) {\n+                            secp256k1_scalar_set_int(&s_times_k_s, k);\n+                            secp256k1_scalar_mul(&s_times_k_s, &s_times_k_s, &s_s);\n+                            secp256k1_scalar_mul(&msg_plus_r_times_sk_s, &r_s, &sk_s);\n+                            secp256k1_scalar_add(&msg_plus_r_times_sk_s, &msg_plus_r_times_sk_s, &msg_s);\n+                            should_verify |= secp256k1_scalar_eq(&s_times_k_s, &msg_plus_r_times_sk_s);\n+                        }\n+                    }\n+                    /* nb we have a \"high s\" rule */\n+                    should_verify &= !secp256k1_scalar_is_high(&s_s);\n+\n+                    /* We would like to try recovering the pubkey and checking that it matches,\n+                     * but pubkey recovery is impossible in the exhaustive tests (the reason\n+                     * being that there are 12 nonzero r values, 12 nonzero points, and no\n+                     * overlap between the sets, so there are no valid signatures). */\n+\n+                    /* Verify by converting to a standard signature and calling verify */\n+                    secp256k1_ecdsa_recoverable_signature_save(&rsig, &r_s, &s_s, recid);\n+                    secp256k1_ecdsa_recoverable_signature_convert(ctx, &sig, &rsig);\n+                    memcpy(&nonconst_ge, &group[sk_s], sizeof(nonconst_ge));\n+                    secp256k1_pubkey_save(&pk, &nonconst_ge);\n+                    CHECK(should_verify ==\n+                          secp256k1_ecdsa_verify(ctx, &sig, msg32, &pk));\n+                }\n+            }\n+        }\n+    }\n+}\n+#endif\n+\n int main(void) {\n     int i;\n     secp256k1_gej groupj[EXHAUSTIVE_TEST_ORDER];\n@@ -324,6 +459,12 @@ int main(void) {\n     test_exhaustive_sign(ctx, group, EXHAUSTIVE_TEST_ORDER);\n     test_exhaustive_verify(ctx, group, EXHAUSTIVE_TEST_ORDER);\n \n+#ifdef ENABLE_MODULE_RECOVERY\n+    test_exhaustive_recovery_sign(ctx, group, EXHAUSTIVE_TEST_ORDER);\n+    test_exhaustive_recovery_verify(ctx, group, EXHAUSTIVE_TEST_ORDER);\n+#endif\n+\n+    secp256k1_context_destroy(ctx);\n     return 0;\n }\n "
      },
      {
        "sha": "4092a86c9175cb7815cd4ebe5cf791940f72fb47",
        "filename": "src/util.h",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e7c1b4490f2c559b050b8255df2d347dd0e4945f/src/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e7c1b4490f2c559b050b8255df2d347dd0e4945f/src/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.h?ref=e7c1b4490f2c559b050b8255df2d347dd0e4945f",
        "patch": "@@ -57,7 +57,10 @@ static SECP256K1_INLINE void secp256k1_callback_call(const secp256k1_callback *\n #endif\n \n /* Like assert(), but when VERIFY is defined, and side-effect safe. */\n-#ifdef VERIFY\n+#if defined(COVERAGE)\n+#define VERIFY_CHECK(check)\n+#define VERIFY_SETUP(stmt)\n+#elif defined(VERIFY)\n #define VERIFY_CHECK CHECK\n #define VERIFY_SETUP(stmt) do { stmt; } while(0)\n #else"
      }
    ]
  },
  {
    "sha": "525282769e8e3e3491b71174a13afaa696f51652",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1MjUyODI3NjllOGUzZTM0OTFiNzExNzRhMTNhZmFhNjk2ZjUxNjUy",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-05-05T18:12:58Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-05-05T18:12:58Z"
      },
      "message": "Update to latest libsecp256k1",
      "tree": {
        "sha": "cdaf0d484667302e7a4d96ba9335b1bc4f681c39",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/cdaf0d484667302e7a4d96ba9335b1bc4f681c39"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/525282769e8e3e3491b71174a13afaa696f51652",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/525282769e8e3e3491b71174a13afaa696f51652",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/525282769e8e3e3491b71174a13afaa696f51652",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/525282769e8e3e3491b71174a13afaa696f51652/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "75171f099e82e3527d7c3469b15891bd92227ec2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/75171f099e82e3527d7c3469b15891bd92227ec2",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/75171f099e82e3527d7c3469b15891bd92227ec2"
      },
      {
        "sha": "e7c1b4490f2c559b050b8255df2d347dd0e4945f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e7c1b4490f2c559b050b8255df2d347dd0e4945f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e7c1b4490f2c559b050b8255df2d347dd0e4945f"
      }
    ],
    "stats": {
      "total": 901,
      "additions": 623,
      "deletions": 278
    },
    "files": [
      {
        "sha": "c071fbe2753c9bda4c8d7b74143dc15878572c4b",
        "filename": "src/secp256k1/Makefile.am",
        "status": "modified",
        "additions": 8,
        "deletions": 2,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/525282769e8e3e3491b71174a13afaa696f51652/src/secp256k1/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/525282769e8e3e3491b71174a13afaa696f51652/src/secp256k1/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/Makefile.am?ref=525282769e8e3e3491b71174a13afaa696f51652",
        "patch": "@@ -93,7 +93,10 @@ TESTS =\n if USE_TESTS\n noinst_PROGRAMS += tests\n tests_SOURCES = src/tests.c\n-tests_CPPFLAGS = -DSECP256K1_BUILD -DVERIFY -I$(top_srcdir)/src -I$(top_srcdir)/include $(SECP_INCLUDES) $(SECP_TEST_INCLUDES)\n+tests_CPPFLAGS = -DSECP256K1_BUILD -I$(top_srcdir)/src -I$(top_srcdir)/include $(SECP_INCLUDES) $(SECP_TEST_INCLUDES)\n+if !ENABLE_COVERAGE\n+tests_CPPFLAGS += -DVERIFY\n+endif\n tests_LDADD = $(SECP_LIBS) $(SECP_TEST_LIBS) $(COMMON_LIB)\n tests_LDFLAGS = -static\n TESTS += tests\n@@ -102,7 +105,10 @@ endif\n if USE_EXHAUSTIVE_TESTS\n noinst_PROGRAMS += exhaustive_tests\n exhaustive_tests_SOURCES = src/tests_exhaustive.c\n-exhaustive_tests_CPPFLAGS = -DSECP256K1_BUILD -DVERIFY -I$(top_srcdir)/src $(SECP_INCLUDES)\n+exhaustive_tests_CPPFLAGS = -DSECP256K1_BUILD -I$(top_srcdir)/src $(SECP_INCLUDES)\n+if !ENABLE_COVERAGE\n+exhaustive_tests_CPPFLAGS += -DVERIFY\n+endif\n exhaustive_tests_LDADD = $(SECP_LIBS)\n exhaustive_tests_LDFLAGS = -static\n TESTS += exhaustive_tests"
      },
      {
        "sha": "e5fcbcb4edf2ace1c2b8740fc118b1e784f12d5e",
        "filename": "src/secp256k1/configure.ac",
        "status": "modified",
        "additions": 16,
        "deletions": 1,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/525282769e8e3e3491b71174a13afaa696f51652/src/secp256k1/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/525282769e8e3e3491b71174a13afaa696f51652/src/secp256k1/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/configure.ac?ref=525282769e8e3e3491b71174a13afaa696f51652",
        "patch": "@@ -20,7 +20,7 @@ AC_PATH_TOOL(STRIP, strip)\n AX_PROG_CC_FOR_BUILD\n \n if test \"x$CFLAGS\" = \"x\"; then\n-  CFLAGS=\"-O3 -g\"\n+  CFLAGS=\"-g\"\n fi\n \n AM_PROG_CC_C_O\n@@ -89,6 +89,11 @@ AC_ARG_ENABLE(benchmark,\n     [use_benchmark=$enableval],\n     [use_benchmark=no])\n \n+AC_ARG_ENABLE(coverage,\n+    AS_HELP_STRING([--enable-coverage],[enable compiler flags to support kcov coverage analysis]),\n+    [enable_coverage=$enableval],\n+    [enable_coverage=no])\n+\n AC_ARG_ENABLE(tests,\n     AS_HELP_STRING([--enable-tests],[compile tests (default is yes)]),\n     [use_tests=$enableval],\n@@ -154,6 +159,14 @@ AC_COMPILE_IFELSE([AC_LANG_SOURCE([[void myfunc() {__builtin_expect(0,0);}]])],\n     [ AC_MSG_RESULT([no])\n     ])\n \n+if test x\"$enable_coverage\" = x\"yes\"; then\n+    AC_DEFINE(COVERAGE, 1, [Define this symbol to compile out all VERIFY code])\n+    CFLAGS=\"$CFLAGS -O0 --coverage\"\n+    LDFLAGS=\"--coverage\"\n+else\n+    CFLAGS=\"$CFLAGS -O3\"\n+fi\n+\n if test x\"$use_ecmult_static_precomputation\" != x\"no\"; then\n   save_cross_compiling=$cross_compiling\n   cross_compiling=no\n@@ -434,6 +447,7 @@ AC_MSG_NOTICE([Using field implementation: $set_field])\n AC_MSG_NOTICE([Using bignum implementation: $set_bignum])\n AC_MSG_NOTICE([Using scalar implementation: $set_scalar])\n AC_MSG_NOTICE([Using endomorphism optimizations: $use_endomorphism])\n+AC_MSG_NOTICE([Building for coverage analysis: $enable_coverage])\n AC_MSG_NOTICE([Building ECDH module: $enable_module_ecdh])\n AC_MSG_NOTICE([Building ECDSA pubkey recovery module: $enable_module_recovery])\n AC_MSG_NOTICE([Using jni: $use_jni])\n@@ -460,6 +474,7 @@ AC_SUBST(SECP_INCLUDES)\n AC_SUBST(SECP_LIBS)\n AC_SUBST(SECP_TEST_LIBS)\n AC_SUBST(SECP_TEST_INCLUDES)\n+AM_CONDITIONAL([ENABLE_COVERAGE], [test x\"$enable_coverage\" = x\"yes\"])\n AM_CONDITIONAL([USE_TESTS], [test x\"$use_tests\" != x\"no\"])\n AM_CONDITIONAL([USE_EXHAUSTIVE_TESTS], [test x\"$use_exhaustive_tests\" != x\"no\"])\n AM_CONDITIONAL([USE_BENCHMARK], [test x\"$use_benchmark\" = x\"yes\"])"
      },
      {
        "sha": "fc4c5cefbb3b654855908761b9a68be88303b813",
        "filename": "src/secp256k1/include/secp256k1.h",
        "status": "modified",
        "additions": 38,
        "deletions": 1,
        "changes": 39,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/525282769e8e3e3491b71174a13afaa696f51652/src/secp256k1/include/secp256k1.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/525282769e8e3e3491b71174a13afaa696f51652/src/secp256k1/include/secp256k1.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/include/secp256k1.h?ref=525282769e8e3e3491b71174a13afaa696f51652",
        "patch": "@@ -163,6 +163,8 @@ typedef int (*secp256k1_nonce_function)(\n  *\n  *  Returns: a newly created context object.\n  *  In:      flags: which parts of the context to initialize.\n+ *\n+ *  See also secp256k1_context_randomize.\n  */\n SECP256K1_API secp256k1_context* secp256k1_context_create(\n     unsigned int flags\n@@ -485,6 +487,28 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_create(\n     const unsigned char *seckey\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n+/** Negates a private key in place.\n+ *\n+ *  Returns: 1 always\n+ *  Args:   ctx:        pointer to a context object\n+ *  In/Out: pubkey:     pointer to the public key to be negated (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_privkey_negate(\n+    const secp256k1_context* ctx,\n+    unsigned char *seckey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2);\n+\n+/** Negates a public key in place.\n+ *\n+ *  Returns: 1 always\n+ *  Args:   ctx:        pointer to a context object\n+ *  In/Out: pubkey:     pointer to the public key to be negated (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_negate(\n+    const secp256k1_context* ctx,\n+    secp256k1_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2);\n+\n /** Tweak a private key by adding tweak to it.\n  * Returns: 0 if the tweak was out of range (chance of around 1 in 2^128 for\n  *          uniformly random 32-byte arrays, or if the resulting private key\n@@ -543,11 +567,24 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_tweak_mul(\n     const unsigned char *tweak\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n-/** Updates the context randomization.\n+/** Updates the context randomization to protect against side-channel leakage.\n  *  Returns: 1: randomization successfully updated\n  *           0: error\n  *  Args:    ctx:       pointer to a context object (cannot be NULL)\n  *  In:      seed32:    pointer to a 32-byte random seed (NULL resets to initial state)\n+ *\n+ * While secp256k1 code is written to be constant-time no matter what secret\n+ * values are, it's possible that a future compiler may output code which isn't,\n+ * and also that the CPU may not emit the same radio frequencies or draw the same\n+ * amount power for all values.\n+ *\n+ * This function provides a seed which is combined into the blinding value: that\n+ * blinding value is added before each multiplication (and removed afterwards) so\n+ * that it does not affect function results, but shields against attacks which\n+ * rely on any input-dependent behaviour.\n+ *\n+ * You should call this after secp256k1_context_create or\n+ * secp256k1_context_clone, and may call this repeatedly afterwards.\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_context_randomize(\n     secp256k1_context* ctx,"
      },
      {
        "sha": "d67f08a4267bcb2e03e8ffbedb8c01de2691863b",
        "filename": "src/secp256k1/src/bench.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/525282769e8e3e3491b71174a13afaa696f51652/src/secp256k1/src/bench.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/525282769e8e3e3491b71174a13afaa696f51652/src/secp256k1/src/bench.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench.h?ref=525282769e8e3e3491b71174a13afaa696f51652",
        "patch": "@@ -23,7 +23,7 @@ void print_number(double x) {\n     if (y < 0.0) {\n         y = -y;\n     }\n-    while (y < 100.0) {\n+    while (y > 0 && y < 100.0) {\n         y *= 10.0;\n         c++;\n     }"
      },
      {
        "sha": "5f137dda23ef3a62326a6aee21cd152fa09860da",
        "filename": "src/secp256k1/src/bench_schnorr_verify.c",
        "status": "removed",
        "additions": 0,
        "deletions": 73,
        "changes": 73,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/75171f099e82e3527d7c3469b15891bd92227ec2/src/secp256k1/src/bench_schnorr_verify.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/75171f099e82e3527d7c3469b15891bd92227ec2/src/secp256k1/src/bench_schnorr_verify.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_schnorr_verify.c?ref=75171f099e82e3527d7c3469b15891bd92227ec2",
        "patch": "@@ -1,73 +0,0 @@\n-/**********************************************************************\n- * Copyright (c) 2014 Pieter Wuille                                   *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n-\n-#include <stdio.h>\n-#include <string.h>\n-\n-#include \"include/secp256k1.h\"\n-#include \"include/secp256k1_schnorr.h\"\n-#include \"util.h\"\n-#include \"bench.h\"\n-\n-typedef struct {\n-    unsigned char key[32];\n-    unsigned char sig[64];\n-    unsigned char pubkey[33];\n-    size_t pubkeylen;\n-} benchmark_schnorr_sig_t;\n-\n-typedef struct {\n-    secp256k1_context *ctx;\n-    unsigned char msg[32];\n-    benchmark_schnorr_sig_t sigs[64];\n-    int numsigs;\n-} benchmark_schnorr_verify_t;\n-\n-static void benchmark_schnorr_init(void* arg) {\n-    int i, k;\n-    benchmark_schnorr_verify_t* data = (benchmark_schnorr_verify_t*)arg;\n-\n-    for (i = 0; i < 32; i++) {\n-        data->msg[i] = 1 + i;\n-    }\n-    for (k = 0; k < data->numsigs; k++) {\n-        secp256k1_pubkey pubkey;\n-        for (i = 0; i < 32; i++) {\n-            data->sigs[k].key[i] = 33 + i + k;\n-        }\n-        secp256k1_schnorr_sign(data->ctx, data->sigs[k].sig, data->msg, data->sigs[k].key, NULL, NULL);\n-        data->sigs[k].pubkeylen = 33;\n-        CHECK(secp256k1_ec_pubkey_create(data->ctx, &pubkey, data->sigs[k].key));\n-        CHECK(secp256k1_ec_pubkey_serialize(data->ctx, data->sigs[k].pubkey, &data->sigs[k].pubkeylen, &pubkey, SECP256K1_EC_COMPRESSED));\n-    }\n-}\n-\n-static void benchmark_schnorr_verify(void* arg) {\n-    int i;\n-    benchmark_schnorr_verify_t* data = (benchmark_schnorr_verify_t*)arg;\n-\n-    for (i = 0; i < 20000 / data->numsigs; i++) {\n-        secp256k1_pubkey pubkey;\n-        data->sigs[0].sig[(i >> 8) % 64] ^= (i & 0xFF);\n-        CHECK(secp256k1_ec_pubkey_parse(data->ctx, &pubkey, data->sigs[0].pubkey, data->sigs[0].pubkeylen));\n-        CHECK(secp256k1_schnorr_verify(data->ctx, data->sigs[0].sig, data->msg, &pubkey) == ((i & 0xFF) == 0));\n-        data->sigs[0].sig[(i >> 8) % 64] ^= (i & 0xFF);\n-    }\n-}\n-\n-\n-\n-int main(void) {\n-    benchmark_schnorr_verify_t data;\n-\n-    data.ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n-\n-    data.numsigs = 1;\n-    run_benchmark(\"schnorr_verify\", benchmark_schnorr_verify, benchmark_schnorr_init, NULL, &data, 10, 20000);\n-\n-    secp256k1_context_destroy(data.ctx);\n-    return 0;\n-}"
      },
      {
        "sha": "453bb1188066f90f7b4648ac19c8e78212973e11",
        "filename": "src/secp256k1/src/ecdsa_impl.h",
        "status": "modified",
        "additions": 5,
        "deletions": 11,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/525282769e8e3e3491b71174a13afaa696f51652/src/secp256k1/src/ecdsa_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/525282769e8e3e3491b71174a13afaa696f51652/src/secp256k1/src/ecdsa_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecdsa_impl.h?ref=525282769e8e3e3491b71174a13afaa696f51652",
        "patch": "@@ -225,14 +225,12 @@ static int secp256k1_ecdsa_sig_verify(const secp256k1_ecmult_context *ctx, const\n #if defined(EXHAUSTIVE_TEST_ORDER)\n {\n     secp256k1_scalar computed_r;\n-    int overflow = 0;\n     secp256k1_ge pr_ge;\n     secp256k1_ge_set_gej(&pr_ge, &pr);\n     secp256k1_fe_normalize(&pr_ge.x);\n \n     secp256k1_fe_get_b32(c, &pr_ge.x);\n-    secp256k1_scalar_set_b32(&computed_r, c, &overflow);\n-    /* we fully expect overflow */\n+    secp256k1_scalar_set_b32(&computed_r, c, NULL);\n     return secp256k1_scalar_eq(sigr, &computed_r);\n }\n #else\n@@ -285,14 +283,10 @@ static int secp256k1_ecdsa_sig_sign(const secp256k1_ecmult_gen_context *ctx, sec\n     secp256k1_fe_normalize(&r.y);\n     secp256k1_fe_get_b32(b, &r.x);\n     secp256k1_scalar_set_b32(sigr, b, &overflow);\n-    if (secp256k1_scalar_is_zero(sigr)) {\n-        /* P.x = order is on the curve, so technically sig->r could end up zero, which would be an invalid signature.\n-         * This branch is cryptographically unreachable as hitting it requires finding the discrete log of P.x = N.\n-         */\n-        secp256k1_gej_clear(&rp);\n-        secp256k1_ge_clear(&r);\n-        return 0;\n-    }\n+    /* These two conditions should be checked before calling */\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(sigr));\n+    VERIFY_CHECK(overflow == 0);\n+\n     if (recid) {\n         /* The overflow condition is cryptographically unreachable as hitting it requires finding the discrete log\n          * of some P where P.x >= order, and only 1 in about 2^127 points meet this criteria."
      },
      {
        "sha": "234c13a644233b15d84aa45183c5674ad37457ce",
        "filename": "src/secp256k1/src/field_10x26_impl.h",
        "status": "modified",
        "additions": 43,
        "deletions": 26,
        "changes": 69,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/525282769e8e3e3491b71174a13afaa696f51652/src/secp256k1/src/field_10x26_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/525282769e8e3e3491b71174a13afaa696f51652/src/secp256k1/src/field_10x26_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field_10x26_impl.h?ref=525282769e8e3e3491b71174a13afaa696f51652",
        "patch": "@@ -38,10 +38,6 @@ static void secp256k1_fe_verify(const secp256k1_fe *a) {\n     }\n     VERIFY_CHECK(r == 1);\n }\n-#else\n-static void secp256k1_fe_verify(const secp256k1_fe *a) {\n-    (void)a;\n-}\n #endif\n \n static void secp256k1_fe_normalize(secp256k1_fe *r) {\n@@ -325,17 +321,17 @@ static int secp256k1_fe_cmp_var(const secp256k1_fe *a, const secp256k1_fe *b) {\n }\n \n static int secp256k1_fe_set_b32(secp256k1_fe *r, const unsigned char *a) {\n-    int i;\n-    r->n[0] = r->n[1] = r->n[2] = r->n[3] = r->n[4] = 0;\n-    r->n[5] = r->n[6] = r->n[7] = r->n[8] = r->n[9] = 0;\n-    for (i=0; i<32; i++) {\n-        int j;\n-        for (j=0; j<4; j++) {\n-            int limb = (8*i+2*j)/26;\n-            int shift = (8*i+2*j)%26;\n-            r->n[limb] |= (uint32_t)((a[31-i] >> (2*j)) & 0x3) << shift;\n-        }\n-    }\n+    r->n[0] = (uint32_t)a[31] | ((uint32_t)a[30] << 8) | ((uint32_t)a[29] << 16) | ((uint32_t)(a[28] & 0x3) << 24);\n+    r->n[1] = (uint32_t)((a[28] >> 2) & 0x3f) | ((uint32_t)a[27] << 6) | ((uint32_t)a[26] << 14) | ((uint32_t)(a[25] & 0xf) << 22);\n+    r->n[2] = (uint32_t)((a[25] >> 4) & 0xf) | ((uint32_t)a[24] << 4) | ((uint32_t)a[23] << 12) | ((uint32_t)(a[22] & 0x3f) << 20);\n+    r->n[3] = (uint32_t)((a[22] >> 6) & 0x3) | ((uint32_t)a[21] << 2) | ((uint32_t)a[20] << 10) | ((uint32_t)a[19] << 18);\n+    r->n[4] = (uint32_t)a[18] | ((uint32_t)a[17] << 8) | ((uint32_t)a[16] << 16) | ((uint32_t)(a[15] & 0x3) << 24);\n+    r->n[5] = (uint32_t)((a[15] >> 2) & 0x3f) | ((uint32_t)a[14] << 6) | ((uint32_t)a[13] << 14) | ((uint32_t)(a[12] & 0xf) << 22);\n+    r->n[6] = (uint32_t)((a[12] >> 4) & 0xf) | ((uint32_t)a[11] << 4) | ((uint32_t)a[10] << 12) | ((uint32_t)(a[9] & 0x3f) << 20);\n+    r->n[7] = (uint32_t)((a[9] >> 6) & 0x3) | ((uint32_t)a[8] << 2) | ((uint32_t)a[7] << 10) | ((uint32_t)a[6] << 18);\n+    r->n[8] = (uint32_t)a[5] | ((uint32_t)a[4] << 8) | ((uint32_t)a[3] << 16) | ((uint32_t)(a[2] & 0x3) << 24);\n+    r->n[9] = (uint32_t)((a[2] >> 2) & 0x3f) | ((uint32_t)a[1] << 6) | ((uint32_t)a[0] << 14);\n+\n     if (r->n[9] == 0x3FFFFFUL && (r->n[8] & r->n[7] & r->n[6] & r->n[5] & r->n[4] & r->n[3] & r->n[2]) == 0x3FFFFFFUL && (r->n[1] + 0x40UL + ((r->n[0] + 0x3D1UL) >> 26)) > 0x3FFFFFFUL) {\n         return 0;\n     }\n@@ -349,21 +345,42 @@ static int secp256k1_fe_set_b32(secp256k1_fe *r, const unsigned char *a) {\n \n /** Convert a field element to a 32-byte big endian value. Requires the input to be normalized */\n static void secp256k1_fe_get_b32(unsigned char *r, const secp256k1_fe *a) {\n-    int i;\n #ifdef VERIFY\n     VERIFY_CHECK(a->normalized);\n     secp256k1_fe_verify(a);\n #endif\n-    for (i=0; i<32; i++) {\n-        int j;\n-        int c = 0;\n-        for (j=0; j<4; j++) {\n-            int limb = (8*i+2*j)/26;\n-            int shift = (8*i+2*j)%26;\n-            c |= ((a->n[limb] >> shift) & 0x3) << (2 * j);\n-        }\n-        r[31-i] = c;\n-    }\n+    r[0] = (a->n[9] >> 14) & 0xff;\n+    r[1] = (a->n[9] >> 6) & 0xff;\n+    r[2] = ((a->n[9] & 0x3F) << 2) | ((a->n[8] >> 24) & 0x3);\n+    r[3] = (a->n[8] >> 16) & 0xff;\n+    r[4] = (a->n[8] >> 8) & 0xff;\n+    r[5] = a->n[8] & 0xff;\n+    r[6] = (a->n[7] >> 18) & 0xff;\n+    r[7] = (a->n[7] >> 10) & 0xff;\n+    r[8] = (a->n[7] >> 2) & 0xff;\n+    r[9] = ((a->n[7] & 0x3) << 6) | ((a->n[6] >> 20) & 0x3f);\n+    r[10] = (a->n[6] >> 12) & 0xff;\n+    r[11] = (a->n[6] >> 4) & 0xff;\n+    r[12] = ((a->n[6] & 0xf) << 4) | ((a->n[5] >> 22) & 0xf);\n+    r[13] = (a->n[5] >> 14) & 0xff;\n+    r[14] = (a->n[5] >> 6) & 0xff;\n+    r[15] = ((a->n[5] & 0x3f) << 2) | ((a->n[4] >> 24) & 0x3);\n+    r[16] = (a->n[4] >> 16) & 0xff;\n+    r[17] = (a->n[4] >> 8) & 0xff;\n+    r[18] = a->n[4] & 0xff;\n+    r[19] = (a->n[3] >> 18) & 0xff;\n+    r[20] = (a->n[3] >> 10) & 0xff;\n+    r[21] = (a->n[3] >> 2) & 0xff;\n+    r[22] = ((a->n[3] & 0x3) << 6) | ((a->n[2] >> 20) & 0x3f);\n+    r[23] = (a->n[2] >> 12) & 0xff;\n+    r[24] = (a->n[2] >> 4) & 0xff;\n+    r[25] = ((a->n[2] & 0xf) << 4) | ((a->n[1] >> 22) & 0xf);\n+    r[26] = (a->n[1] >> 14) & 0xff;\n+    r[27] = (a->n[1] >> 6) & 0xff;\n+    r[28] = ((a->n[1] & 0x3f) << 2) | ((a->n[0] >> 24) & 0x3);\n+    r[29] = (a->n[0] >> 16) & 0xff;\n+    r[30] = (a->n[0] >> 8) & 0xff;\n+    r[31] = a->n[0] & 0xff;\n }\n \n SECP256K1_INLINE static void secp256k1_fe_negate(secp256k1_fe *r, const secp256k1_fe *a, int m) {"
      },
      {
        "sha": "8e8b286baff86a7e7796380e977194c2255483c2",
        "filename": "src/secp256k1/src/field_5x52_impl.h",
        "status": "modified",
        "additions": 66,
        "deletions": 25,
        "changes": 91,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/525282769e8e3e3491b71174a13afaa696f51652/src/secp256k1/src/field_5x52_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/525282769e8e3e3491b71174a13afaa696f51652/src/secp256k1/src/field_5x52_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field_5x52_impl.h?ref=525282769e8e3e3491b71174a13afaa696f51652",
        "patch": "@@ -49,10 +49,6 @@ static void secp256k1_fe_verify(const secp256k1_fe *a) {\n     }\n     VERIFY_CHECK(r == 1);\n }\n-#else\n-static void secp256k1_fe_verify(const secp256k1_fe *a) {\n-    (void)a;\n-}\n #endif\n \n static void secp256k1_fe_normalize(secp256k1_fe *r) {\n@@ -288,16 +284,40 @@ static int secp256k1_fe_cmp_var(const secp256k1_fe *a, const secp256k1_fe *b) {\n }\n \n static int secp256k1_fe_set_b32(secp256k1_fe *r, const unsigned char *a) {\n-    int i;\n-    r->n[0] = r->n[1] = r->n[2] = r->n[3] = r->n[4] = 0;\n-    for (i=0; i<32; i++) {\n-        int j;\n-        for (j=0; j<2; j++) {\n-            int limb = (8*i+4*j)/52;\n-            int shift = (8*i+4*j)%52;\n-            r->n[limb] |= (uint64_t)((a[31-i] >> (4*j)) & 0xF) << shift;\n-        }\n-    }\n+    r->n[0] = (uint64_t)a[31]\n+            | ((uint64_t)a[30] << 8)\n+            | ((uint64_t)a[29] << 16)\n+            | ((uint64_t)a[28] << 24)\n+            | ((uint64_t)a[27] << 32)\n+            | ((uint64_t)a[26] << 40)\n+            | ((uint64_t)(a[25] & 0xF)  << 48);\n+    r->n[1] = (uint64_t)((a[25] >> 4) & 0xF)\n+            | ((uint64_t)a[24] << 4)\n+            | ((uint64_t)a[23] << 12)\n+            | ((uint64_t)a[22] << 20)\n+            | ((uint64_t)a[21] << 28)\n+            | ((uint64_t)a[20] << 36)\n+            | ((uint64_t)a[19] << 44);\n+    r->n[2] = (uint64_t)a[18]\n+            | ((uint64_t)a[17] << 8)\n+            | ((uint64_t)a[16] << 16)\n+            | ((uint64_t)a[15] << 24)\n+            | ((uint64_t)a[14] << 32)\n+            | ((uint64_t)a[13] << 40)\n+            | ((uint64_t)(a[12] & 0xF) << 48);\n+    r->n[3] = (uint64_t)((a[12] >> 4) & 0xF)\n+            | ((uint64_t)a[11] << 4)\n+            | ((uint64_t)a[10] << 12)\n+            | ((uint64_t)a[9]  << 20)\n+            | ((uint64_t)a[8]  << 28)\n+            | ((uint64_t)a[7]  << 36)\n+            | ((uint64_t)a[6]  << 44);\n+    r->n[4] = (uint64_t)a[5]\n+            | ((uint64_t)a[4] << 8)\n+            | ((uint64_t)a[3] << 16)\n+            | ((uint64_t)a[2] << 24)\n+            | ((uint64_t)a[1] << 32)\n+            | ((uint64_t)a[0] << 40);\n     if (r->n[4] == 0x0FFFFFFFFFFFFULL && (r->n[3] & r->n[2] & r->n[1]) == 0xFFFFFFFFFFFFFULL && r->n[0] >= 0xFFFFEFFFFFC2FULL) {\n         return 0;\n     }\n@@ -311,21 +331,42 @@ static int secp256k1_fe_set_b32(secp256k1_fe *r, const unsigned char *a) {\n \n /** Convert a field element to a 32-byte big endian value. Requires the input to be normalized */\n static void secp256k1_fe_get_b32(unsigned char *r, const secp256k1_fe *a) {\n-    int i;\n #ifdef VERIFY\n     VERIFY_CHECK(a->normalized);\n     secp256k1_fe_verify(a);\n #endif\n-    for (i=0; i<32; i++) {\n-        int j;\n-        int c = 0;\n-        for (j=0; j<2; j++) {\n-            int limb = (8*i+4*j)/52;\n-            int shift = (8*i+4*j)%52;\n-            c |= ((a->n[limb] >> shift) & 0xF) << (4 * j);\n-        }\n-        r[31-i] = c;\n-    }\n+    r[0] = (a->n[4] >> 40) & 0xFF;\n+    r[1] = (a->n[4] >> 32) & 0xFF;\n+    r[2] = (a->n[4] >> 24) & 0xFF;\n+    r[3] = (a->n[4] >> 16) & 0xFF;\n+    r[4] = (a->n[4] >> 8) & 0xFF;\n+    r[5] = a->n[4] & 0xFF;\n+    r[6] = (a->n[3] >> 44) & 0xFF;\n+    r[7] = (a->n[3] >> 36) & 0xFF;\n+    r[8] = (a->n[3] >> 28) & 0xFF;\n+    r[9] = (a->n[3] >> 20) & 0xFF;\n+    r[10] = (a->n[3] >> 12) & 0xFF;\n+    r[11] = (a->n[3] >> 4) & 0xFF;\n+    r[12] = ((a->n[2] >> 48) & 0xF) | ((a->n[3] & 0xF) << 4);\n+    r[13] = (a->n[2] >> 40) & 0xFF;\n+    r[14] = (a->n[2] >> 32) & 0xFF;\n+    r[15] = (a->n[2] >> 24) & 0xFF;\n+    r[16] = (a->n[2] >> 16) & 0xFF;\n+    r[17] = (a->n[2] >> 8) & 0xFF;\n+    r[18] = a->n[2] & 0xFF;\n+    r[19] = (a->n[1] >> 44) & 0xFF;\n+    r[20] = (a->n[1] >> 36) & 0xFF;\n+    r[21] = (a->n[1] >> 28) & 0xFF;\n+    r[22] = (a->n[1] >> 20) & 0xFF;\n+    r[23] = (a->n[1] >> 12) & 0xFF;\n+    r[24] = (a->n[1] >> 4) & 0xFF;\n+    r[25] = ((a->n[0] >> 48) & 0xF) | ((a->n[1] & 0xF) << 4);\n+    r[26] = (a->n[0] >> 40) & 0xFF;\n+    r[27] = (a->n[0] >> 32) & 0xFF;\n+    r[28] = (a->n[0] >> 24) & 0xFF;\n+    r[29] = (a->n[0] >> 16) & 0xFF;\n+    r[30] = (a->n[0] >> 8) & 0xFF;\n+    r[31] = a->n[0] & 0xFF;\n }\n \n SECP256K1_INLINE static void secp256k1_fe_negate(secp256k1_fe *r, const secp256k1_fe *a, int m) {"
      },
      {
        "sha": "7d723532ff3e12c1767540d019e35ede17a7c6c4",
        "filename": "src/secp256k1/src/group_impl.h",
        "status": "modified",
        "additions": 0,
        "deletions": 6,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/525282769e8e3e3491b71174a13afaa696f51652/src/secp256k1/src/group_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/525282769e8e3e3491b71174a13afaa696f51652/src/secp256k1/src/group_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/group_impl.h?ref=525282769e8e3e3491b71174a13afaa696f51652",
        "patch": "@@ -200,12 +200,6 @@ static void secp256k1_gej_set_infinity(secp256k1_gej *r) {\n     secp256k1_fe_clear(&r->z);\n }\n \n-static void secp256k1_ge_set_infinity(secp256k1_ge *r) {\n-    r->infinity = 1;\n-    secp256k1_fe_clear(&r->x);\n-    secp256k1_fe_clear(&r->y);\n-}\n-\n static void secp256k1_gej_clear(secp256k1_gej *r) {\n     r->infinity = 0;\n     secp256k1_fe_clear(&r->x);"
      },
      {
        "sha": "9e30fb73dd7fb98b6e860cfb9054f1d66fb4089a",
        "filename": "src/secp256k1/src/modules/ecdh/main_impl.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/525282769e8e3e3491b71174a13afaa696f51652/src/secp256k1/src/modules/ecdh/main_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/525282769e8e3e3491b71174a13afaa696f51652/src/secp256k1/src/modules/ecdh/main_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/ecdh/main_impl.h?ref=525282769e8e3e3491b71174a13afaa696f51652",
        "patch": "@@ -16,10 +16,10 @@ int secp256k1_ecdh(const secp256k1_context* ctx, unsigned char *result, const se\n     secp256k1_gej res;\n     secp256k1_ge pt;\n     secp256k1_scalar s;\n+    VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(result != NULL);\n     ARG_CHECK(point != NULL);\n     ARG_CHECK(scalar != NULL);\n-    (void)ctx;\n \n     secp256k1_pubkey_load(ctx, &pt, point);\n     secp256k1_scalar_set_b32(&s, scalar, &overflow);"
      },
      {
        "sha": "85a5d0a9a69e10d585c2bc2ad4df03f14cf0def6",
        "filename": "src/secp256k1/src/modules/ecdh/tests_impl.h",
        "status": "modified",
        "additions": 30,
        "deletions": 0,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/525282769e8e3e3491b71174a13afaa696f51652/src/secp256k1/src/modules/ecdh/tests_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/525282769e8e3e3491b71174a13afaa696f51652/src/secp256k1/src/modules/ecdh/tests_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/ecdh/tests_impl.h?ref=525282769e8e3e3491b71174a13afaa696f51652",
        "patch": "@@ -7,6 +7,35 @@\n #ifndef _SECP256K1_MODULE_ECDH_TESTS_\n #define _SECP256K1_MODULE_ECDH_TESTS_\n \n+void test_ecdh_api(void) {\n+    /* Setup context that just counts errors */\n+    secp256k1_context *tctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN);\n+    secp256k1_pubkey point;\n+    unsigned char res[32];\n+    unsigned char s_one[32] = { 0 };\n+    int32_t ecount = 0;\n+    s_one[31] = 1;\n+\n+    secp256k1_context_set_error_callback(tctx, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_illegal_callback(tctx, counting_illegal_callback_fn, &ecount);\n+    CHECK(secp256k1_ec_pubkey_create(tctx, &point, s_one) == 1);\n+\n+    /* Check all NULLs are detected */\n+    CHECK(secp256k1_ecdh(tctx, res, &point, s_one) == 1);\n+    CHECK(ecount == 0);\n+    CHECK(secp256k1_ecdh(tctx, NULL, &point, s_one) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_ecdh(tctx, res, NULL, s_one) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_ecdh(tctx, res, &point, NULL) == 0);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_ecdh(tctx, res, &point, s_one) == 1);\n+    CHECK(ecount == 3);\n+\n+    /* Cleanup */\n+    secp256k1_context_destroy(tctx);\n+}\n+\n void test_ecdh_generator_basepoint(void) {\n     unsigned char s_one[32] = { 0 };\n     secp256k1_pubkey point[2];\n@@ -68,6 +97,7 @@ void test_bad_scalar(void) {\n }\n \n void run_ecdh_tests(void) {\n+    test_ecdh_api();\n     test_ecdh_generator_basepoint();\n     test_bad_scalar();\n }"
      },
      {
        "sha": "c6fbe239813a3e45559bd36098d3d2ca2dac145a",
        "filename": "src/secp256k1/src/modules/recovery/main_impl.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/525282769e8e3e3491b71174a13afaa696f51652/src/secp256k1/src/modules/recovery/main_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/525282769e8e3e3491b71174a13afaa696f51652/src/secp256k1/src/modules/recovery/main_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/recovery/main_impl.h?ref=525282769e8e3e3491b71174a13afaa696f51652",
        "patch": "@@ -179,7 +179,7 @@ int secp256k1_ecdsa_recover(const secp256k1_context* ctx, secp256k1_pubkey *pubk\n     ARG_CHECK(pubkey != NULL);\n \n     secp256k1_ecdsa_recoverable_signature_load(ctx, &r, &s, &recid, signature);\n-    ARG_CHECK(recid >= 0 && recid < 4);\n+    VERIFY_CHECK(recid >= 0 && recid < 4);  /* should have been caught in parse_compact */\n     secp256k1_scalar_set_b32(&m, msg32, NULL);\n     if (secp256k1_ecdsa_sig_recover(&ctx->ecmult_ctx, &r, &s, &q, &m, recid)) {\n         secp256k1_pubkey_save(pubkey, &q);"
      },
      {
        "sha": "765c7dd81e958c9ca37ee50117b286e90b6c7f7f",
        "filename": "src/secp256k1/src/modules/recovery/tests_impl.h",
        "status": "modified",
        "additions": 143,
        "deletions": 0,
        "changes": 143,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/525282769e8e3e3491b71174a13afaa696f51652/src/secp256k1/src/modules/recovery/tests_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/525282769e8e3e3491b71174a13afaa696f51652/src/secp256k1/src/modules/recovery/tests_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/recovery/tests_impl.h?ref=525282769e8e3e3491b71174a13afaa696f51652",
        "patch": "@@ -7,6 +7,146 @@\n #ifndef _SECP256K1_MODULE_RECOVERY_TESTS_\n #define _SECP256K1_MODULE_RECOVERY_TESTS_\n \n+static int recovery_test_nonce_function(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *algo16, void *data, unsigned int counter) {\n+    (void) msg32;\n+    (void) key32;\n+    (void) algo16;\n+    (void) data;\n+\n+    /* On the first run, return 0 to force a second run */\n+    if (counter == 0) {\n+        memset(nonce32, 0, 32);\n+        return 1;\n+    }\n+    /* On the second run, return an overflow to force a third run */\n+    if (counter == 1) {\n+        memset(nonce32, 0xff, 32);\n+        return 1;\n+    }\n+    /* On the next run, return a valid nonce, but flip a coin as to whether or not to fail signing. */\n+    memset(nonce32, 1, 32);\n+    return secp256k1_rand_bits(1);\n+}\n+\n+void test_ecdsa_recovery_api(void) {\n+    /* Setup contexts that just count errors */\n+    secp256k1_context *none = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    secp256k1_context *sign = secp256k1_context_create(SECP256K1_CONTEXT_SIGN);\n+    secp256k1_context *vrfy = secp256k1_context_create(SECP256K1_CONTEXT_VERIFY);\n+    secp256k1_context *both = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n+    secp256k1_pubkey pubkey;\n+    secp256k1_pubkey recpubkey;\n+    secp256k1_ecdsa_signature normal_sig;\n+    secp256k1_ecdsa_recoverable_signature recsig;\n+    unsigned char privkey[32] = { 1 };\n+    unsigned char message[32] = { 2 };\n+    int32_t ecount = 0;\n+    int recid = 0;\n+    unsigned char sig[74];\n+    unsigned char zero_privkey[32] = { 0 };\n+    unsigned char over_privkey[32] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+                                       0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+                                       0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+                                       0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };\n+\n+    secp256k1_context_set_error_callback(none, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_error_callback(sign, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_error_callback(vrfy, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_error_callback(both, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_illegal_callback(none, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_illegal_callback(sign, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_illegal_callback(vrfy, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_illegal_callback(both, counting_illegal_callback_fn, &ecount);\n+\n+    /* Construct and verify corresponding public key. */\n+    CHECK(secp256k1_ec_seckey_verify(ctx, privkey) == 1);\n+    CHECK(secp256k1_ec_pubkey_create(ctx, &pubkey, privkey) == 1);\n+\n+    /* Check bad contexts and NULLs for signing */\n+    ecount = 0;\n+    CHECK(secp256k1_ecdsa_sign_recoverable(none, &recsig, message, privkey, NULL, NULL) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_ecdsa_sign_recoverable(sign, &recsig, message, privkey, NULL, NULL) == 1);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_ecdsa_sign_recoverable(vrfy, &recsig, message, privkey, NULL, NULL) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_ecdsa_sign_recoverable(both, &recsig, message, privkey, NULL, NULL) == 1);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_ecdsa_sign_recoverable(both, NULL, message, privkey, NULL, NULL) == 0);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_ecdsa_sign_recoverable(both, &recsig, NULL, privkey, NULL, NULL) == 0);\n+    CHECK(ecount == 4);\n+    CHECK(secp256k1_ecdsa_sign_recoverable(both, &recsig, message, NULL, NULL, NULL) == 0);\n+    CHECK(ecount == 5);\n+    /* This will fail or succeed randomly, and in either case will not ARG_CHECK failure */\n+    secp256k1_ecdsa_sign_recoverable(both, &recsig, message, privkey, recovery_test_nonce_function, NULL);\n+    CHECK(ecount == 5);\n+    /* These will all fail, but not in ARG_CHECK way */\n+    CHECK(secp256k1_ecdsa_sign_recoverable(both, &recsig, message, zero_privkey, NULL, NULL) == 0);\n+    CHECK(secp256k1_ecdsa_sign_recoverable(both, &recsig, message, over_privkey, NULL, NULL) == 0);\n+    /* This one will succeed. */\n+    CHECK(secp256k1_ecdsa_sign_recoverable(both, &recsig, message, privkey, NULL, NULL) == 1);\n+    CHECK(ecount == 5);\n+\n+    /* Check signing with a goofy nonce function */\n+\n+    /* Check bad contexts and NULLs for recovery */\n+    ecount = 0;\n+    CHECK(secp256k1_ecdsa_recover(none, &recpubkey, &recsig, message) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_ecdsa_recover(sign, &recpubkey, &recsig, message) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_ecdsa_recover(vrfy, &recpubkey, &recsig, message) == 1);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_ecdsa_recover(both, &recpubkey, &recsig, message) == 1);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_ecdsa_recover(both, NULL, &recsig, message) == 0);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_ecdsa_recover(both, &recpubkey, NULL, message) == 0);\n+    CHECK(ecount == 4);\n+    CHECK(secp256k1_ecdsa_recover(both, &recpubkey, &recsig, NULL) == 0);\n+    CHECK(ecount == 5);\n+\n+    /* Check NULLs for conversion */\n+    CHECK(secp256k1_ecdsa_sign(both, &normal_sig, message, privkey, NULL, NULL) == 1);\n+    ecount = 0;\n+    CHECK(secp256k1_ecdsa_recoverable_signature_convert(both, NULL, &recsig) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_ecdsa_recoverable_signature_convert(both, &normal_sig, NULL) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_ecdsa_recoverable_signature_convert(both, &normal_sig, &recsig) == 1);\n+\n+    /* Check NULLs for de/serialization */\n+    CHECK(secp256k1_ecdsa_sign_recoverable(both, &recsig, message, privkey, NULL, NULL) == 1);\n+    ecount = 0;\n+    CHECK(secp256k1_ecdsa_recoverable_signature_serialize_compact(both, NULL, &recid, &recsig) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_ecdsa_recoverable_signature_serialize_compact(both, sig, NULL, &recsig) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_ecdsa_recoverable_signature_serialize_compact(both, sig, &recid, NULL) == 0);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_ecdsa_recoverable_signature_serialize_compact(both, sig, &recid, &recsig) == 1);\n+\n+    CHECK(secp256k1_ecdsa_recoverable_signature_parse_compact(both, NULL, sig, recid) == 0);\n+    CHECK(ecount == 4);\n+    CHECK(secp256k1_ecdsa_recoverable_signature_parse_compact(both, &recsig, NULL, recid) == 0);\n+    CHECK(ecount == 5);\n+    CHECK(secp256k1_ecdsa_recoverable_signature_parse_compact(both, &recsig, sig, -1) == 0);\n+    CHECK(ecount == 6);\n+    CHECK(secp256k1_ecdsa_recoverable_signature_parse_compact(both, &recsig, sig, 5) == 0);\n+    CHECK(ecount == 7);\n+    /* overflow in signature will fail but not affect ecount */\n+    memcpy(sig, over_privkey, 32);\n+    CHECK(secp256k1_ecdsa_recoverable_signature_parse_compact(both, &recsig, sig, recid) == 0);\n+    CHECK(ecount == 7);\n+\n+    /* cleanup */\n+    secp256k1_context_destroy(none);\n+    secp256k1_context_destroy(sign);\n+    secp256k1_context_destroy(vrfy);\n+    secp256k1_context_destroy(both);\n+}\n+\n void test_ecdsa_recovery_end_to_end(void) {\n     unsigned char extra[32] = {0x00};\n     unsigned char privkey[32];\n@@ -241,6 +381,9 @@ void test_ecdsa_recovery_edge_cases(void) {\n \n void run_recovery_tests(void) {\n     int i;\n+    for (i = 0; i < count; i++) {\n+        test_ecdsa_recovery_api();\n+    }\n     for (i = 0; i < 64*count; i++) {\n         test_ecdsa_recovery_end_to_end();\n     }"
      },
      {
        "sha": "2690d86558a9a1973ee5f4cc9c339c527718c54c",
        "filename": "src/secp256k1/src/scalar_impl.h",
        "status": "modified",
        "additions": 67,
        "deletions": 104,
        "changes": 171,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/525282769e8e3e3491b71174a13afaa696f51652/src/secp256k1/src/scalar_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/525282769e8e3e3491b71174a13afaa696f51652/src/secp256k1/src/scalar_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/scalar_impl.h?ref=525282769e8e3e3491b71174a13afaa696f51652",
        "patch": "@@ -66,88 +66,79 @@ static void secp256k1_scalar_inverse(secp256k1_scalar *r, const secp256k1_scalar\n #else\n     secp256k1_scalar *t;\n     int i;\n-    /* First compute x ^ (2^N - 1) for some values of N. */\n-    secp256k1_scalar x2, x3, x4, x6, x7, x8, x15, x30, x60, x120, x127;\n+    /* First compute xN as x ^ (2^N - 1) for some values of N,\n+     * and uM as x ^ M for some values of M. */\n+    secp256k1_scalar x2, x3, x6, x8, x14, x28, x56, x112, x126;\n+    secp256k1_scalar u2, u5, u9, u11, u13;\n \n-    secp256k1_scalar_sqr(&x2,  x);\n-    secp256k1_scalar_mul(&x2, &x2,  x);\n+    secp256k1_scalar_sqr(&u2, x);\n+    secp256k1_scalar_mul(&x2, &u2,  x);\n+    secp256k1_scalar_mul(&u5, &u2, &x2);\n+    secp256k1_scalar_mul(&x3, &u5,  &u2);\n+    secp256k1_scalar_mul(&u9, &x3, &u2);\n+    secp256k1_scalar_mul(&u11, &u9, &u2);\n+    secp256k1_scalar_mul(&u13, &u11, &u2);\n \n-    secp256k1_scalar_sqr(&x3, &x2);\n-    secp256k1_scalar_mul(&x3, &x3,  x);\n-\n-    secp256k1_scalar_sqr(&x4, &x3);\n-    secp256k1_scalar_mul(&x4, &x4,  x);\n-\n-    secp256k1_scalar_sqr(&x6, &x4);\n+    secp256k1_scalar_sqr(&x6, &u13);\n     secp256k1_scalar_sqr(&x6, &x6);\n-    secp256k1_scalar_mul(&x6, &x6, &x2);\n-\n-    secp256k1_scalar_sqr(&x7, &x6);\n-    secp256k1_scalar_mul(&x7, &x7,  x);\n+    secp256k1_scalar_mul(&x6, &x6, &u11);\n \n-    secp256k1_scalar_sqr(&x8, &x7);\n-    secp256k1_scalar_mul(&x8, &x8,  x);\n+    secp256k1_scalar_sqr(&x8, &x6);\n+    secp256k1_scalar_sqr(&x8, &x8);\n+    secp256k1_scalar_mul(&x8, &x8,  &x2);\n \n-    secp256k1_scalar_sqr(&x15, &x8);\n-    for (i = 0; i < 6; i++) {\n-        secp256k1_scalar_sqr(&x15, &x15);\n+    secp256k1_scalar_sqr(&x14, &x8);\n+    for (i = 0; i < 5; i++) {\n+        secp256k1_scalar_sqr(&x14, &x14);\n     }\n-    secp256k1_scalar_mul(&x15, &x15, &x7);\n+    secp256k1_scalar_mul(&x14, &x14, &x6);\n \n-    secp256k1_scalar_sqr(&x30, &x15);\n-    for (i = 0; i < 14; i++) {\n-        secp256k1_scalar_sqr(&x30, &x30);\n+    secp256k1_scalar_sqr(&x28, &x14);\n+    for (i = 0; i < 13; i++) {\n+        secp256k1_scalar_sqr(&x28, &x28);\n     }\n-    secp256k1_scalar_mul(&x30, &x30, &x15);\n+    secp256k1_scalar_mul(&x28, &x28, &x14);\n \n-    secp256k1_scalar_sqr(&x60, &x30);\n-    for (i = 0; i < 29; i++) {\n-        secp256k1_scalar_sqr(&x60, &x60);\n+    secp256k1_scalar_sqr(&x56, &x28);\n+    for (i = 0; i < 27; i++) {\n+        secp256k1_scalar_sqr(&x56, &x56);\n     }\n-    secp256k1_scalar_mul(&x60, &x60, &x30);\n+    secp256k1_scalar_mul(&x56, &x56, &x28);\n \n-    secp256k1_scalar_sqr(&x120, &x60);\n-    for (i = 0; i < 59; i++) {\n-        secp256k1_scalar_sqr(&x120, &x120);\n+    secp256k1_scalar_sqr(&x112, &x56);\n+    for (i = 0; i < 55; i++) {\n+        secp256k1_scalar_sqr(&x112, &x112);\n     }\n-    secp256k1_scalar_mul(&x120, &x120, &x60);\n+    secp256k1_scalar_mul(&x112, &x112, &x56);\n \n-    secp256k1_scalar_sqr(&x127, &x120);\n-    for (i = 0; i < 6; i++) {\n-        secp256k1_scalar_sqr(&x127, &x127);\n+    secp256k1_scalar_sqr(&x126, &x112);\n+    for (i = 0; i < 13; i++) {\n+        secp256k1_scalar_sqr(&x126, &x126);\n     }\n-    secp256k1_scalar_mul(&x127, &x127, &x7);\n+    secp256k1_scalar_mul(&x126, &x126, &x14);\n \n-    /* Then accumulate the final result (t starts at x127). */\n-    t = &x127;\n-    for (i = 0; i < 2; i++) { /* 0 */\n+    /* Then accumulate the final result (t starts at x126). */\n+    t = &x126;\n+    for (i = 0; i < 3; i++) {\n         secp256k1_scalar_sqr(t, t);\n     }\n-    secp256k1_scalar_mul(t, t, x); /* 1 */\n+    secp256k1_scalar_mul(t, t, &u5); /* 101 */\n     for (i = 0; i < 4; i++) { /* 0 */\n         secp256k1_scalar_sqr(t, t);\n     }\n     secp256k1_scalar_mul(t, t, &x3); /* 111 */\n-    for (i = 0; i < 2; i++) { /* 0 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 2; i++) { /* 0 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 2; i++) { /* 0 */\n+    for (i = 0; i < 4; i++) { /* 0 */\n         secp256k1_scalar_sqr(t, t);\n     }\n-    secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 4; i++) { /* 0 */\n+    secp256k1_scalar_mul(t, t, &u5); /* 101 */\n+    for (i = 0; i < 5; i++) { /* 0 */\n         secp256k1_scalar_sqr(t, t);\n     }\n-    secp256k1_scalar_mul(t, t, &x3); /* 111 */\n-    for (i = 0; i < 3; i++) { /* 0 */\n+    secp256k1_scalar_mul(t, t, &u11); /* 1011 */\n+    for (i = 0; i < 4; i++) {\n         secp256k1_scalar_sqr(t, t);\n     }\n-    secp256k1_scalar_mul(t, t, &x2); /* 11 */\n+    secp256k1_scalar_mul(t, t, &u11); /* 1011 */\n     for (i = 0; i < 4; i++) { /* 0 */\n         secp256k1_scalar_sqr(t, t);\n     }\n@@ -156,38 +147,26 @@ static void secp256k1_scalar_inverse(secp256k1_scalar *r, const secp256k1_scalar\n         secp256k1_scalar_sqr(t, t);\n     }\n     secp256k1_scalar_mul(t, t, &x3); /* 111 */\n-    for (i = 0; i < 4; i++) { /* 00 */\n+    for (i = 0; i < 6; i++) { /* 00 */\n         secp256k1_scalar_sqr(t, t);\n     }\n-    secp256k1_scalar_mul(t, t, &x2); /* 11 */\n-    for (i = 0; i < 2; i++) { /* 0 */\n+    secp256k1_scalar_mul(t, t, &u13); /* 1101 */\n+    for (i = 0; i < 4; i++) { /* 0 */\n         secp256k1_scalar_sqr(t, t);\n     }\n-    secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 2; i++) { /* 0 */\n+    secp256k1_scalar_mul(t, t, &u5); /* 101 */\n+    for (i = 0; i < 3; i++) {\n         secp256k1_scalar_sqr(t, t);\n     }\n-    secp256k1_scalar_mul(t, t, x); /* 1 */\n+    secp256k1_scalar_mul(t, t, &x3); /* 111 */\n     for (i = 0; i < 5; i++) { /* 0 */\n         secp256k1_scalar_sqr(t, t);\n     }\n-    secp256k1_scalar_mul(t, t, &x4); /* 1111 */\n-    for (i = 0; i < 2; i++) { /* 0 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 3; i++) { /* 00 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 4; i++) { /* 000 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 2; i++) { /* 0 */\n+    secp256k1_scalar_mul(t, t, &u9); /* 1001 */\n+    for (i = 0; i < 6; i++) { /* 000 */\n         secp256k1_scalar_sqr(t, t);\n     }\n-    secp256k1_scalar_mul(t, t, x); /* 1 */\n+    secp256k1_scalar_mul(t, t, &u5); /* 101 */\n     for (i = 0; i < 10; i++) { /* 0000000 */\n         secp256k1_scalar_sqr(t, t);\n     }\n@@ -200,50 +179,34 @@ static void secp256k1_scalar_inverse(secp256k1_scalar *r, const secp256k1_scalar\n         secp256k1_scalar_sqr(t, t);\n     }\n     secp256k1_scalar_mul(t, t, &x8); /* 11111111 */\n-    for (i = 0; i < 2; i++) { /* 0 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 3; i++) { /* 00 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 3; i++) { /* 00 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, x); /* 1 */\n     for (i = 0; i < 5; i++) { /* 0 */\n         secp256k1_scalar_sqr(t, t);\n     }\n-    secp256k1_scalar_mul(t, t, &x4); /* 1111 */\n-    for (i = 0; i < 2; i++) { /* 0 */\n+    secp256k1_scalar_mul(t, t, &u9); /* 1001 */\n+    for (i = 0; i < 6; i++) { /* 00 */\n         secp256k1_scalar_sqr(t, t);\n     }\n-    secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 5; i++) { /* 000 */\n+    secp256k1_scalar_mul(t, t, &u11); /* 1011 */\n+    for (i = 0; i < 4; i++) {\n         secp256k1_scalar_sqr(t, t);\n     }\n-    secp256k1_scalar_mul(t, t, &x2); /* 11 */\n-    for (i = 0; i < 4; i++) { /* 00 */\n+    secp256k1_scalar_mul(t, t, &u13); /* 1101 */\n+    for (i = 0; i < 5; i++) {\n         secp256k1_scalar_sqr(t, t);\n     }\n     secp256k1_scalar_mul(t, t, &x2); /* 11 */\n-    for (i = 0; i < 2; i++) { /* 0 */\n+    for (i = 0; i < 6; i++) { /* 00 */\n         secp256k1_scalar_sqr(t, t);\n     }\n-    secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 8; i++) { /* 000000 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, &x2); /* 11 */\n-    for (i = 0; i < 3; i++) { /* 0 */\n+    secp256k1_scalar_mul(t, t, &u13); /* 1101 */\n+    for (i = 0; i < 10; i++) { /* 000000 */\n         secp256k1_scalar_sqr(t, t);\n     }\n-    secp256k1_scalar_mul(t, t, &x2); /* 11 */\n-    for (i = 0; i < 3; i++) { /* 00 */\n+    secp256k1_scalar_mul(t, t, &u13); /* 1101 */\n+    for (i = 0; i < 4; i++) {\n         secp256k1_scalar_sqr(t, t);\n     }\n-    secp256k1_scalar_mul(t, t, x); /* 1 */\n+    secp256k1_scalar_mul(t, t, &u9); /* 1001 */\n     for (i = 0; i < 6; i++) { /* 00000 */\n         secp256k1_scalar_sqr(t, t);\n     }"
      },
      {
        "sha": "4f8c01655bd00eed0565b698f7029421b5fd1562",
        "filename": "src/secp256k1/src/secp256k1.c",
        "status": "modified",
        "additions": 27,
        "deletions": 4,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/525282769e8e3e3491b71174a13afaa696f51652/src/secp256k1/src/secp256k1.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/525282769e8e3e3491b71174a13afaa696f51652/src/secp256k1/src/secp256k1.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/secp256k1.c?ref=525282769e8e3e3491b71174a13afaa696f51652",
        "patch": "@@ -424,6 +424,33 @@ int secp256k1_ec_pubkey_create(const secp256k1_context* ctx, secp256k1_pubkey *p\n     return ret;\n }\n \n+int secp256k1_ec_privkey_negate(const secp256k1_context* ctx, unsigned char *seckey) {\n+    secp256k1_scalar sec;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    secp256k1_scalar_set_b32(&sec, seckey, NULL);\n+    secp256k1_scalar_negate(&sec, &sec);\n+    secp256k1_scalar_get_b32(seckey, &sec);\n+\n+    return 1;\n+}\n+\n+int secp256k1_ec_pubkey_negate(const secp256k1_context* ctx, secp256k1_pubkey *pubkey) {\n+    int ret = 0;\n+    secp256k1_ge p;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    ret = secp256k1_pubkey_load(ctx, &p, pubkey);\n+    memset(pubkey, 0, sizeof(*pubkey));\n+    if (ret) {\n+        secp256k1_ge_neg(&p, &p);\n+        secp256k1_pubkey_save(pubkey, &p);\n+    }\n+    return ret;\n+}\n+\n int secp256k1_ec_privkey_tweak_add(const secp256k1_context* ctx, unsigned char *seckey, const unsigned char *tweak) {\n     secp256k1_scalar term;\n     secp256k1_scalar sec;\n@@ -552,10 +579,6 @@ int secp256k1_ec_pubkey_combine(const secp256k1_context* ctx, secp256k1_pubkey *\n # include \"modules/ecdh/main_impl.h\"\n #endif\n \n-#ifdef ENABLE_MODULE_SCHNORR\n-# include \"modules/schnorr/main_impl.h\"\n-#endif\n-\n #ifdef ENABLE_MODULE_RECOVERY\n # include \"modules/recovery/main_impl.h\"\n #endif"
      },
      {
        "sha": "3d9bd5ebb48d46dff2d677976f850ad8809592e7",
        "filename": "src/secp256k1/src/tests.c",
        "status": "modified",
        "additions": 31,
        "deletions": 20,
        "changes": 51,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/525282769e8e3e3491b71174a13afaa696f51652/src/secp256k1/src/tests.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/525282769e8e3e3491b71174a13afaa696f51652/src/secp256k1/src/tests.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/tests.c?ref=525282769e8e3e3491b71174a13afaa696f51652",
        "patch": "@@ -10,6 +10,7 @@\n \n #include <stdio.h>\n #include <stdlib.h>\n+#include <string.h>\n \n #include <time.h>\n \n@@ -135,6 +136,7 @@ void random_scalar_order(secp256k1_scalar *num) {\n \n void run_context_tests(void) {\n     secp256k1_pubkey pubkey;\n+    secp256k1_pubkey zero_pubkey;\n     secp256k1_ecdsa_signature sig;\n     unsigned char ctmp[32];\n     int32_t ecount;\n@@ -149,6 +151,8 @@ void run_context_tests(void) {\n     secp256k1_scalar msg, key, nonce;\n     secp256k1_scalar sigr, sigs;\n \n+    memset(&zero_pubkey, 0, sizeof(zero_pubkey));\n+\n     ecount = 0;\n     ecount2 = 10;\n     secp256k1_context_set_illegal_callback(vrfy, counting_illegal_callback_fn, &ecount);\n@@ -201,12 +205,20 @@ void run_context_tests(void) {\n     CHECK(ecount == 2);\n     CHECK(secp256k1_ec_pubkey_tweak_mul(sign, &pubkey, ctmp) == 0);\n     CHECK(ecount2 == 13);\n-    CHECK(secp256k1_ec_pubkey_tweak_mul(vrfy, &pubkey, ctmp) == 1);\n+    CHECK(secp256k1_ec_pubkey_negate(vrfy, &pubkey) == 1);\n     CHECK(ecount == 2);\n-    CHECK(secp256k1_context_randomize(vrfy, ctmp) == 0);\n+    CHECK(secp256k1_ec_pubkey_negate(sign, &pubkey) == 1);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_ec_pubkey_negate(sign, NULL) == 0);\n+    CHECK(ecount2 == 14);\n+    CHECK(secp256k1_ec_pubkey_negate(vrfy, &zero_pubkey) == 0);\n     CHECK(ecount == 3);\n+    CHECK(secp256k1_ec_pubkey_tweak_mul(vrfy, &pubkey, ctmp) == 1);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_context_randomize(vrfy, ctmp) == 0);\n+    CHECK(ecount == 4);\n     CHECK(secp256k1_context_randomize(sign, NULL) == 1);\n-    CHECK(ecount2 == 13);\n+    CHECK(ecount2 == 14);\n     secp256k1_context_set_illegal_callback(vrfy, NULL, NULL);\n     secp256k1_context_set_illegal_callback(sign, NULL, NULL);\n \n@@ -1879,9 +1891,9 @@ void test_ge(void) {\n      *\n      * When the endomorphism code is compiled in, p5 = lambda*p1 and p6 = lambda^2*p1 are added as well.\n      */\n-    secp256k1_ge *ge = (secp256k1_ge *)malloc(sizeof(secp256k1_ge) * (1 + 4 * runs));\n-    secp256k1_gej *gej = (secp256k1_gej *)malloc(sizeof(secp256k1_gej) * (1 + 4 * runs));\n-    secp256k1_fe *zinv = (secp256k1_fe *)malloc(sizeof(secp256k1_fe) * (1 + 4 * runs));\n+    secp256k1_ge *ge = (secp256k1_ge *)checked_malloc(&ctx->error_callback, sizeof(secp256k1_ge) * (1 + 4 * runs));\n+    secp256k1_gej *gej = (secp256k1_gej *)checked_malloc(&ctx->error_callback, sizeof(secp256k1_gej) * (1 + 4 * runs));\n+    secp256k1_fe *zinv = (secp256k1_fe *)checked_malloc(&ctx->error_callback, sizeof(secp256k1_fe) * (1 + 4 * runs));\n     secp256k1_fe zf;\n     secp256k1_fe zfi2, zfi3;\n \n@@ -1919,7 +1931,7 @@ void test_ge(void) {\n \n     /* Compute z inverses. */\n     {\n-        secp256k1_fe *zs = malloc(sizeof(secp256k1_fe) * (1 + 4 * runs));\n+        secp256k1_fe *zs = checked_malloc(&ctx->error_callback, sizeof(secp256k1_fe) * (1 + 4 * runs));\n         for (i = 0; i < 4 * runs + 1; i++) {\n             if (i == 0) {\n                 /* The point at infinity does not have a meaningful z inverse. Any should do. */\n@@ -2020,7 +2032,7 @@ void test_ge(void) {\n     /* Test adding all points together in random order equals infinity. */\n     {\n         secp256k1_gej sum = SECP256K1_GEJ_CONST_INFINITY;\n-        secp256k1_gej *gej_shuffled = (secp256k1_gej *)malloc((4 * runs + 1) * sizeof(secp256k1_gej));\n+        secp256k1_gej *gej_shuffled = (secp256k1_gej *)checked_malloc(&ctx->error_callback, (4 * runs + 1) * sizeof(secp256k1_gej));\n         for (i = 0; i < 4 * runs + 1; i++) {\n             gej_shuffled[i] = gej[i];\n         }\n@@ -2041,9 +2053,9 @@ void test_ge(void) {\n \n     /* Test batch gej -> ge conversion with and without known z ratios. */\n     {\n-        secp256k1_fe *zr = (secp256k1_fe *)malloc((4 * runs + 1) * sizeof(secp256k1_fe));\n-        secp256k1_ge *ge_set_table = (secp256k1_ge *)malloc((4 * runs + 1) * sizeof(secp256k1_ge));\n-        secp256k1_ge *ge_set_all = (secp256k1_ge *)malloc((4 * runs + 1) * sizeof(secp256k1_ge));\n+        secp256k1_fe *zr = (secp256k1_fe *)checked_malloc(&ctx->error_callback, (4 * runs + 1) * sizeof(secp256k1_fe));\n+        secp256k1_ge *ge_set_table = (secp256k1_ge *)checked_malloc(&ctx->error_callback, (4 * runs + 1) * sizeof(secp256k1_ge));\n+        secp256k1_ge *ge_set_all = (secp256k1_ge *)checked_malloc(&ctx->error_callback, (4 * runs + 1) * sizeof(secp256k1_ge));\n         for (i = 0; i < 4 * runs + 1; i++) {\n             /* Compute gej[i + 1].z / gez[i].z (with gej[n].z taken to be 1). */\n             if (i < 4 * runs) {\n@@ -3436,6 +3448,7 @@ void test_ecdsa_end_to_end(void) {\n     unsigned char pubkeyc[65];\n     size_t pubkeyclen = 65;\n     secp256k1_pubkey pubkey;\n+    secp256k1_pubkey pubkey_tmp;\n     unsigned char seckey[300];\n     size_t seckeylen = 300;\n \n@@ -3457,6 +3470,13 @@ void test_ecdsa_end_to_end(void) {\n     memset(&pubkey, 0, sizeof(pubkey));\n     CHECK(secp256k1_ec_pubkey_parse(ctx, &pubkey, pubkeyc, pubkeyclen) == 1);\n \n+    /* Verify negation changes the key and changes it back */\n+    memcpy(&pubkey_tmp, &pubkey, sizeof(pubkey));\n+    CHECK(secp256k1_ec_pubkey_negate(ctx, &pubkey_tmp) == 1);\n+    CHECK(memcmp(&pubkey_tmp, &pubkey, sizeof(pubkey)) != 0);\n+    CHECK(secp256k1_ec_pubkey_negate(ctx, &pubkey_tmp) == 1);\n+    CHECK(memcmp(&pubkey_tmp, &pubkey, sizeof(pubkey)) == 0);\n+\n     /* Verify private key import and export. */\n     CHECK(ec_privkey_export_der(ctx, seckey, &seckeylen, privkey, secp256k1_rand_bits(1) == 1));\n     CHECK(ec_privkey_import_der(ctx, privkey2, seckey, seckeylen) == 1);\n@@ -4383,10 +4403,6 @@ void run_ecdsa_openssl(void) {\n # include \"modules/ecdh/tests_impl.h\"\n #endif\n \n-#ifdef ENABLE_MODULE_SCHNORR\n-# include \"modules/schnorr/tests_impl.h\"\n-#endif\n-\n #ifdef ENABLE_MODULE_RECOVERY\n # include \"modules/recovery/tests_impl.h\"\n #endif\n@@ -4504,11 +4520,6 @@ int main(int argc, char **argv) {\n     run_ecdsa_openssl();\n #endif\n \n-#ifdef ENABLE_MODULE_SCHNORR\n-    /* Schnorr tests */\n-    run_schnorr_tests();\n-#endif\n-\n #ifdef ENABLE_MODULE_RECOVERY\n     /* ECDSA pubkey recovery tests */\n     run_recovery_tests();"
      },
      {
        "sha": "b040bb0733ddf1abef0b715b807d3133db37d2f8",
        "filename": "src/secp256k1/src/tests_exhaustive.c",
        "status": "modified",
        "additions": 142,
        "deletions": 1,
        "changes": 143,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/525282769e8e3e3491b71174a13afaa696f51652/src/secp256k1/src/tests_exhaustive.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/525282769e8e3e3491b71174a13afaa696f51652/src/secp256k1/src/tests_exhaustive.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/tests_exhaustive.c?ref=525282769e8e3e3491b71174a13afaa696f51652",
        "patch": "@@ -26,6 +26,11 @@\n #include \"secp256k1.c\"\n #include \"testrand_impl.h\"\n \n+#ifdef ENABLE_MODULE_RECOVERY\n+#include \"src/modules/recovery/main_impl.h\"\n+#include \"include/secp256k1_recovery.h\"\n+#endif\n+\n /** stolen from tests.c */\n void ge_equals_ge(const secp256k1_ge *a, const secp256k1_ge *b) {\n     CHECK(a->infinity == b->infinity);\n@@ -77,7 +82,7 @@ int secp256k1_nonce_function_smallint(unsigned char *nonce32, const unsigned cha\n      * function with an increased `attempt`. So if attempt > 0 this means we\n      * need to change the nonce to avoid an infinite loop. */\n     if (attempt > 0) {\n-        (*idata)++;\n+        *idata = (*idata + 1) % EXHAUSTIVE_TEST_ORDER;\n     }\n     secp256k1_scalar_set_int(&s, *idata);\n     secp256k1_scalar_get_b32(nonce32, &s);\n@@ -244,6 +249,7 @@ void test_exhaustive_sign(const secp256k1_context *ctx, const secp256k1_ge *grou\n     for (i = 1; i < order; i++) {  /* message */\n         for (j = 1; j < order; j++) {  /* key */\n             for (k = 1; k < order; k++) {  /* nonce */\n+                const int starting_k = k;\n                 secp256k1_ecdsa_signature sig;\n                 secp256k1_scalar sk, msg, r, s, expected_r;\n                 unsigned char sk32[32], msg32[32];\n@@ -262,6 +268,11 @@ void test_exhaustive_sign(const secp256k1_context *ctx, const secp256k1_ge *grou\n                 CHECK(r == expected_r);\n                 CHECK((k * s) % order == (i + r * j) % order ||\n                       (k * (EXHAUSTIVE_TEST_ORDER - s)) % order == (i + r * j) % order);\n+\n+                /* Overflow means we've tried every possible nonce */\n+                if (k < starting_k) {\n+                    break;\n+                }\n             }\n         }\n     }\n@@ -276,6 +287,130 @@ void test_exhaustive_sign(const secp256k1_context *ctx, const secp256k1_ge *grou\n      */\n }\n \n+#ifdef ENABLE_MODULE_RECOVERY\n+void test_exhaustive_recovery_sign(const secp256k1_context *ctx, const secp256k1_ge *group, int order) {\n+    int i, j, k;\n+\n+    /* Loop */\n+    for (i = 1; i < order; i++) {  /* message */\n+        for (j = 1; j < order; j++) {  /* key */\n+            for (k = 1; k < order; k++) {  /* nonce */\n+                const int starting_k = k;\n+                secp256k1_fe r_dot_y_normalized;\n+                secp256k1_ecdsa_recoverable_signature rsig;\n+                secp256k1_ecdsa_signature sig;\n+                secp256k1_scalar sk, msg, r, s, expected_r;\n+                unsigned char sk32[32], msg32[32];\n+                int expected_recid;\n+                int recid;\n+                secp256k1_scalar_set_int(&msg, i);\n+                secp256k1_scalar_set_int(&sk, j);\n+                secp256k1_scalar_get_b32(sk32, &sk);\n+                secp256k1_scalar_get_b32(msg32, &msg);\n+\n+                secp256k1_ecdsa_sign_recoverable(ctx, &rsig, msg32, sk32, secp256k1_nonce_function_smallint, &k);\n+\n+                /* Check directly */\n+                secp256k1_ecdsa_recoverable_signature_load(ctx, &r, &s, &recid, &rsig);\n+                r_from_k(&expected_r, group, k);\n+                CHECK(r == expected_r);\n+                CHECK((k * s) % order == (i + r * j) % order ||\n+                      (k * (EXHAUSTIVE_TEST_ORDER - s)) % order == (i + r * j) % order);\n+                /* In computing the recid, there is an overflow condition that is disabled in\n+                 * scalar_low_impl.h `secp256k1_scalar_set_b32` because almost every r.y value\n+                 * will exceed the group order, and our signing code always holds out for r\n+                 * values that don't overflow, so with a proper overflow check the tests would\n+                 * loop indefinitely. */\n+                r_dot_y_normalized = group[k].y;\n+                secp256k1_fe_normalize(&r_dot_y_normalized);\n+                /* Also the recovery id is flipped depending if we hit the low-s branch */\n+                if ((k * s) % order == (i + r * j) % order) {\n+                    expected_recid = secp256k1_fe_is_odd(&r_dot_y_normalized) ? 1 : 0;\n+                } else {\n+                    expected_recid = secp256k1_fe_is_odd(&r_dot_y_normalized) ? 0 : 1;\n+                }\n+                CHECK(recid == expected_recid);\n+\n+                /* Convert to a standard sig then check */\n+                secp256k1_ecdsa_recoverable_signature_convert(ctx, &sig, &rsig);\n+                secp256k1_ecdsa_signature_load(ctx, &r, &s, &sig);\n+                /* Note that we compute expected_r *after* signing -- this is important\n+                 * because our nonce-computing function function might change k during\n+                 * signing. */\n+                r_from_k(&expected_r, group, k);\n+                CHECK(r == expected_r);\n+                CHECK((k * s) % order == (i + r * j) % order ||\n+                      (k * (EXHAUSTIVE_TEST_ORDER - s)) % order == (i + r * j) % order);\n+\n+                /* Overflow means we've tried every possible nonce */\n+                if (k < starting_k) {\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+void test_exhaustive_recovery_verify(const secp256k1_context *ctx, const secp256k1_ge *group, int order) {\n+    /* This is essentially a copy of test_exhaustive_verify, with recovery added */\n+    int s, r, msg, key;\n+    for (s = 1; s < order; s++) {\n+        for (r = 1; r < order; r++) {\n+            for (msg = 1; msg < order; msg++) {\n+                for (key = 1; key < order; key++) {\n+                    secp256k1_ge nonconst_ge;\n+                    secp256k1_ecdsa_recoverable_signature rsig;\n+                    secp256k1_ecdsa_signature sig;\n+                    secp256k1_pubkey pk;\n+                    secp256k1_scalar sk_s, msg_s, r_s, s_s;\n+                    secp256k1_scalar s_times_k_s, msg_plus_r_times_sk_s;\n+                    int recid = 0;\n+                    int k, should_verify;\n+                    unsigned char msg32[32];\n+\n+                    secp256k1_scalar_set_int(&s_s, s);\n+                    secp256k1_scalar_set_int(&r_s, r);\n+                    secp256k1_scalar_set_int(&msg_s, msg);\n+                    secp256k1_scalar_set_int(&sk_s, key);\n+                    secp256k1_scalar_get_b32(msg32, &msg_s);\n+\n+                    /* Verify by hand */\n+                    /* Run through every k value that gives us this r and check that *one* works.\n+                     * Note there could be none, there could be multiple, ECDSA is weird. */\n+                    should_verify = 0;\n+                    for (k = 0; k < order; k++) {\n+                        secp256k1_scalar check_x_s;\n+                        r_from_k(&check_x_s, group, k);\n+                        if (r_s == check_x_s) {\n+                            secp256k1_scalar_set_int(&s_times_k_s, k);\n+                            secp256k1_scalar_mul(&s_times_k_s, &s_times_k_s, &s_s);\n+                            secp256k1_scalar_mul(&msg_plus_r_times_sk_s, &r_s, &sk_s);\n+                            secp256k1_scalar_add(&msg_plus_r_times_sk_s, &msg_plus_r_times_sk_s, &msg_s);\n+                            should_verify |= secp256k1_scalar_eq(&s_times_k_s, &msg_plus_r_times_sk_s);\n+                        }\n+                    }\n+                    /* nb we have a \"high s\" rule */\n+                    should_verify &= !secp256k1_scalar_is_high(&s_s);\n+\n+                    /* We would like to try recovering the pubkey and checking that it matches,\n+                     * but pubkey recovery is impossible in the exhaustive tests (the reason\n+                     * being that there are 12 nonzero r values, 12 nonzero points, and no\n+                     * overlap between the sets, so there are no valid signatures). */\n+\n+                    /* Verify by converting to a standard signature and calling verify */\n+                    secp256k1_ecdsa_recoverable_signature_save(&rsig, &r_s, &s_s, recid);\n+                    secp256k1_ecdsa_recoverable_signature_convert(ctx, &sig, &rsig);\n+                    memcpy(&nonconst_ge, &group[sk_s], sizeof(nonconst_ge));\n+                    secp256k1_pubkey_save(&pk, &nonconst_ge);\n+                    CHECK(should_verify ==\n+                          secp256k1_ecdsa_verify(ctx, &sig, msg32, &pk));\n+                }\n+            }\n+        }\n+    }\n+}\n+#endif\n+\n int main(void) {\n     int i;\n     secp256k1_gej groupj[EXHAUSTIVE_TEST_ORDER];\n@@ -324,6 +459,12 @@ int main(void) {\n     test_exhaustive_sign(ctx, group, EXHAUSTIVE_TEST_ORDER);\n     test_exhaustive_verify(ctx, group, EXHAUSTIVE_TEST_ORDER);\n \n+#ifdef ENABLE_MODULE_RECOVERY\n+    test_exhaustive_recovery_sign(ctx, group, EXHAUSTIVE_TEST_ORDER);\n+    test_exhaustive_recovery_verify(ctx, group, EXHAUSTIVE_TEST_ORDER);\n+#endif\n+\n+    secp256k1_context_destroy(ctx);\n     return 0;\n }\n "
      },
      {
        "sha": "4092a86c9175cb7815cd4ebe5cf791940f72fb47",
        "filename": "src/secp256k1/src/util.h",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/525282769e8e3e3491b71174a13afaa696f51652/src/secp256k1/src/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/525282769e8e3e3491b71174a13afaa696f51652/src/secp256k1/src/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/util.h?ref=525282769e8e3e3491b71174a13afaa696f51652",
        "patch": "@@ -57,7 +57,10 @@ static SECP256K1_INLINE void secp256k1_callback_call(const secp256k1_callback *\n #endif\n \n /* Like assert(), but when VERIFY is defined, and side-effect safe. */\n-#ifdef VERIFY\n+#if defined(COVERAGE)\n+#define VERIFY_CHECK(check)\n+#define VERIFY_SETUP(stmt)\n+#elif defined(VERIFY)\n #define VERIFY_CHECK CHECK\n #define VERIFY_SETUP(stmt) do { stmt; } while(0)\n #else"
      }
    ]
  }
]