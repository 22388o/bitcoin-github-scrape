[
  {
    "sha": "f8dcd5ca6f55ad49807cf7491c1f153f6158400e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmOGRjZDVjYTZmNTVhZDQ5ODA3Y2Y3NDkxYzFmMTUzZjYxNTg0MDBl",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-04-06T16:39:12Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-04-08T23:59:46Z"
      },
      "message": "Use scoped locks instead of CRITICAL_BLOCK",
      "tree": {
        "sha": "6049e300099aa5f509e408acfff0236367b4a26e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6049e300099aa5f509e408acfff0236367b4a26e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f8dcd5ca6f55ad49807cf7491c1f153f6158400e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f8dcd5ca6f55ad49807cf7491c1f153f6158400e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f8dcd5ca6f55ad49807cf7491c1f153f6158400e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f8dcd5ca6f55ad49807cf7491c1f153f6158400e/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "138d08c5315c45b3dd08184c4eeb77ee3e47ef0a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/138d08c5315c45b3dd08184c4eeb77ee3e47ef0a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/138d08c5315c45b3dd08184c4eeb77ee3e47ef0a"
      }
    ],
    "stats": {
      "total": 476,
      "additions": 286,
      "deletions": 190
    },
    "files": [
      {
        "sha": "7652df66ae5cc641425da6134ad9bacf12ad8538",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 11,
        "deletions": 9,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f8dcd5ca6f55ad49807cf7491c1f153f6158400e/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f8dcd5ca6f55ad49807cf7491c1f153f6158400e/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=f8dcd5ca6f55ad49807cf7491c1f153f6158400e",
        "patch": "@@ -266,8 +266,8 @@ class CAddrMan\n         //\n         // This format is more complex, but significantly smaller (at most 1.5 MiB), and supports\n         // changes to the ADDRMAN_ parameters without breaking the on-disk structure.\n-        CRITICAL_BLOCK(cs)\n         {\n+            LOCK(cs);\n             unsigned char nVersion = 0;\n             READWRITE(nVersion);\n             READWRITE(nKey);\n@@ -398,8 +398,8 @@ class CAddrMan\n     void Check()\n     {\n #ifdef DEBUG_ADDRMAN\n-        CRITICAL_BLOCK(cs)\n         {\n+            LOCK(cs);\n             int err;\n             if ((err=Check_()))\n                 printf(\"ADDRMAN CONSISTENCY CHECK FAILED!!! err=%i\\n\", err);\n@@ -411,8 +411,8 @@ class CAddrMan\n     bool Add(const CAddress &addr, const CNetAddr& source, int64 nTimePenalty = 0)\n     {\n         bool fRet = false;\n-        CRITICAL_BLOCK(cs)\n         {\n+            LOCK(cs);\n             Check();\n             fRet |= Add_(addr, source, nTimePenalty);\n             Check();\n@@ -426,8 +426,8 @@ class CAddrMan\n     bool Add(const std::vector<CAddress> &vAddr, const CNetAddr& source, int64 nTimePenalty = 0)\n     {\n         int nAdd = 0;\n-        CRITICAL_BLOCK(cs)\n         {\n+            LOCK(cs);\n             Check();\n             for (std::vector<CAddress>::const_iterator it = vAddr.begin(); it != vAddr.end(); it++)\n                 nAdd += Add_(*it, source, nTimePenalty) ? 1 : 0;\n@@ -441,8 +441,8 @@ class CAddrMan\n     // Mark an entry as accessible.\n     void Good(const CService &addr, int64 nTime = GetAdjustedTime())\n     {\n-        CRITICAL_BLOCK(cs)\n         {\n+            LOCK(cs);\n             Check();\n             Good_(addr, nTime);\n             Check();\n@@ -452,8 +452,8 @@ class CAddrMan\n     // Mark an entry as connection attempted to.\n     void Attempt(const CService &addr, int64 nTime = GetAdjustedTime())\n     {\n-        CRITICAL_BLOCK(cs)\n         {\n+            LOCK(cs);\n             Check();\n             Attempt_(addr, nTime);\n             Check();\n@@ -465,8 +465,8 @@ class CAddrMan\n     CAddress Select(int nUnkBias = 50)\n     {\n         CAddress addrRet;\n-        CRITICAL_BLOCK(cs)\n         {\n+            LOCK(cs);\n             Check();\n             addrRet = Select_(nUnkBias);\n             Check();\n@@ -479,17 +479,19 @@ class CAddrMan\n     {\n         Check();\n         std::vector<CAddress> vAddr;\n-        CRITICAL_BLOCK(cs)\n+        {\n+            LOCK(cs);\n             GetAddr_(vAddr);\n+        }\n         Check();\n         return vAddr;\n     }\n \n     // Mark an entry as currently-connected-to.\n     void Connected(const CService &addr, int64 nTime = GetAdjustedTime())\n     {\n-        CRITICAL_BLOCK(cs)\n         {\n+            LOCK(cs);\n             Check();\n             Connected_(addr, nTime);\n             Check();"
      },
      {
        "sha": "200105174c643c7003ff49d9ba9a0349df76ad18",
        "filename": "src/bitcoinrpc.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f8dcd5ca6f55ad49807cf7491c1f153f6158400e/src/bitcoinrpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f8dcd5ca6f55ad49807cf7491c1f153f6158400e/src/bitcoinrpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoinrpc.cpp?ref=f8dcd5ca6f55ad49807cf7491c1f153f6158400e",
        "patch": "@@ -1648,8 +1648,8 @@ Value walletlock(const Array& params, bool fHelp)\n     if (!pwalletMain->IsCrypted())\n         throw JSONRPCError(-15, \"Error: running with an unencrypted wallet, but walletlock was called.\");\n \n-    CRITICAL_BLOCK(cs_nWalletUnlockTime)\n     {\n+        LOCK(cs_nWalletUnlockTime);\n         pwalletMain->Lock();\n         nWalletUnlockTime = 0;\n     }\n@@ -2498,9 +2498,10 @@ void ThreadRPCServer2(void* parg)\n             {\n                 // Execute\n                 Value result;\n-                CRITICAL_BLOCK(cs_main)\n-                CRITICAL_BLOCK(pwalletMain->cs_wallet)\n+                {\n+                    LOCK2(cs_main, pwalletMain->cs_wallet);\n                     result = (*(*mi).second)(params, false);\n+                }\n \n                 // Send reply\n                 string strReply = JSONRPCReply(result, Value::null, id);"
      },
      {
        "sha": "52db39a3d5e6dff0ed6efc73cfddfc5d2bafbe83",
        "filename": "src/db.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 9,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f8dcd5ca6f55ad49807cf7491c1f153f6158400e/src/db.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f8dcd5ca6f55ad49807cf7491c1f153f6158400e/src/db.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/db.cpp?ref=f8dcd5ca6f55ad49807cf7491c1f153f6158400e",
        "patch": "@@ -72,8 +72,8 @@ CDB::CDB(const char* pszFile, const char* pszMode) : pdb(NULL)\n     if (fCreate)\n         nFlags |= DB_CREATE;\n \n-    CRITICAL_BLOCK(cs_db)\n     {\n+        LOCK(cs_db);\n         if (!fDbEnvInit)\n         {\n             if (fShutdown)\n@@ -126,8 +126,10 @@ CDB::CDB(const char* pszFile, const char* pszMode) : pdb(NULL)\n             {\n                 delete pdb;\n                 pdb = NULL;\n-                CRITICAL_BLOCK(cs_db)\n+                {\n+                     LOCK(cs_db);\n                     --mapFileUseCount[strFile];\n+                }\n                 strFile = \"\";\n                 throw runtime_error(strprintf(\"CDB() : can't open database file %s, error %d\", pszFile, ret));\n             }\n@@ -165,14 +167,16 @@ void CDB::Close()\n \n     dbenv.txn_checkpoint(nMinutes ? GetArg(\"-dblogsize\", 100)*1024 : 0, nMinutes, 0);\n \n-    CRITICAL_BLOCK(cs_db)\n+    {\n+        LOCK(cs_db);\n         --mapFileUseCount[strFile];\n+    }\n }\n \n void static CloseDb(const string& strFile)\n {\n-    CRITICAL_BLOCK(cs_db)\n     {\n+        LOCK(cs_db);\n         if (mapDb[strFile] != NULL)\n         {\n             // Close the database handle\n@@ -188,8 +192,8 @@ bool CDB::Rewrite(const string& strFile, const char* pszSkip)\n {\n     while (!fShutdown)\n     {\n-        CRITICAL_BLOCK(cs_db)\n         {\n+            LOCK(cs_db);\n             if (!mapFileUseCount.count(strFile) || mapFileUseCount[strFile] == 0)\n             {\n                 // Flush log data to the dat file\n@@ -286,8 +290,8 @@ void DBFlush(bool fShutdown)\n     printf(\"DBFlush(%s)%s\\n\", fShutdown ? \"true\" : \"false\", fDbEnvInit ? \"\" : \" db not started\");\n     if (!fDbEnvInit)\n         return;\n-    CRITICAL_BLOCK(cs_db)\n     {\n+        LOCK(cs_db);\n         map<string, int>::iterator mi = mapFileUseCount.begin();\n         while (mi != mapFileUseCount.end())\n         {\n@@ -877,8 +881,8 @@ int CWalletDB::LoadWallet(CWallet* pwallet)\n     bool fIsEncrypted = false;\n \n     //// todo: shouldn't we catch exceptions and try to recover and continue?\n-    CRITICAL_BLOCK(pwallet->cs_wallet)\n     {\n+        LOCK(pwallet->cs_wallet);\n         int nMinVersion = 0;\n         if (Read((string)\"minversion\", nMinVersion))\n         {\n@@ -1119,7 +1123,8 @@ void ThreadFlushWalletDB(void* parg)\n \n         if (nLastFlushed != nWalletDBUpdated && GetTime() - nLastWalletUpdate >= 2)\n         {\n-            TRY_CRITICAL_BLOCK(cs_db)\n+            TRY_LOCK(cs_db,lockDb);\n+            if (lockDb)\n             {\n                 // Don't do this if any databases are in use\n                 int nRefCount = 0;\n@@ -1160,8 +1165,8 @@ bool BackupWallet(const CWallet& wallet, const string& strDest)\n         return false;\n     while (!fShutdown)\n     {\n-        CRITICAL_BLOCK(cs_db)\n         {\n+            LOCK(cs_db);\n             if (!mapFileUseCount.count(wallet.strWalletFile) || mapFileUseCount[wallet.strWalletFile] == 0)\n             {\n                 // Flush log data to the dat file"
      },
      {
        "sha": "a1e45b1c6bcf7d736c4ac276facd336005ccd7de",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 3,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f8dcd5ca6f55ad49807cf7491c1f153f6158400e/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f8dcd5ca6f55ad49807cf7491c1f153f6158400e/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=f8dcd5ca6f55ad49807cf7491c1f153f6158400e",
        "patch": "@@ -40,10 +40,13 @@ void Shutdown(void* parg)\n     static CCriticalSection cs_Shutdown;\n     static bool fTaken;\n     bool fFirstThread = false;\n-    TRY_CRITICAL_BLOCK(cs_Shutdown)\n     {\n-        fFirstThread = !fTaken;\n-        fTaken = true;\n+        TRY_LOCK(cs_Shutdown, lockShutdown);\n+        if (lockShutdown)\n+        {\n+            fFirstThread = !fTaken;\n+            fTaken = true;\n+        }\n     }\n     static bool fExit;\n     if (fFirstThread)"
      },
      {
        "sha": "7b46f6b07a121fb48666aaf4ef3e7b0b0645063b",
        "filename": "src/keystore.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 11,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f8dcd5ca6f55ad49807cf7491c1f153f6158400e/src/keystore.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f8dcd5ca6f55ad49807cf7491c1f153f6158400e/src/keystore.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/keystore.cpp?ref=f8dcd5ca6f55ad49807cf7491c1f153f6158400e",
        "patch": "@@ -21,31 +21,37 @@ bool CBasicKeyStore::AddKey(const CKey& key)\n {\n     bool fCompressed = false;\n     CSecret secret = key.GetSecret(fCompressed);\n-    CRITICAL_BLOCK(cs_KeyStore)\n+    {\n+        LOCK(cs_KeyStore);\n         mapKeys[CBitcoinAddress(key.GetPubKey())] = make_pair(secret, fCompressed);\n+    }\n     return true;\n }\n \n bool CBasicKeyStore::AddCScript(const CScript& redeemScript)\n {\n-    CRITICAL_BLOCK(cs_KeyStore)\n+    {\n+        LOCK(cs_KeyStore);\n         mapScripts[Hash160(redeemScript)] = redeemScript;\n+    }\n     return true;\n }\n \n bool CBasicKeyStore::HaveCScript(const uint160& hash) const\n {\n     bool result;\n-    CRITICAL_BLOCK(cs_KeyStore)\n+    {\n+        LOCK(cs_KeyStore);\n         result = (mapScripts.count(hash) > 0);\n+    }\n     return result;\n }\n \n \n bool CBasicKeyStore::GetCScript(const uint160 &hash, CScript& redeemScriptOut) const\n {\n-    CRITICAL_BLOCK(cs_KeyStore)\n     {\n+        LOCK(cs_KeyStore);\n         ScriptMap::const_iterator mi = mapScripts.find(hash);\n         if (mi != mapScripts.end())\n         {\n@@ -58,8 +64,8 @@ bool CBasicKeyStore::GetCScript(const uint160 &hash, CScript& redeemScriptOut) c\n \n bool CCryptoKeyStore::SetCrypted()\n {\n-    CRITICAL_BLOCK(cs_KeyStore)\n     {\n+        LOCK(cs_KeyStore);\n         if (fUseCrypto)\n             return true;\n         if (!mapKeys.empty())\n@@ -71,8 +77,8 @@ bool CCryptoKeyStore::SetCrypted()\n \n bool CCryptoKeyStore::Unlock(const CKeyingMaterial& vMasterKeyIn)\n {\n-    CRITICAL_BLOCK(cs_KeyStore)\n     {\n+        LOCK(cs_KeyStore);\n         if (!SetCrypted())\n             return false;\n \n@@ -100,8 +106,8 @@ bool CCryptoKeyStore::Unlock(const CKeyingMaterial& vMasterKeyIn)\n \n bool CCryptoKeyStore::AddKey(const CKey& key)\n {\n-    CRITICAL_BLOCK(cs_KeyStore)\n     {\n+        LOCK(cs_KeyStore);\n         if (!IsCrypted())\n             return CBasicKeyStore::AddKey(key);\n \n@@ -123,8 +129,8 @@ bool CCryptoKeyStore::AddKey(const CKey& key)\n \n bool CCryptoKeyStore::AddCryptedKey(const std::vector<unsigned char> &vchPubKey, const std::vector<unsigned char> &vchCryptedSecret)\n {\n-    CRITICAL_BLOCK(cs_KeyStore)\n     {\n+        LOCK(cs_KeyStore);\n         if (!SetCrypted())\n             return false;\n \n@@ -135,8 +141,8 @@ bool CCryptoKeyStore::AddCryptedKey(const std::vector<unsigned char> &vchPubKey,\n \n bool CCryptoKeyStore::GetKey(const CBitcoinAddress &address, CKey& keyOut) const\n {\n-    CRITICAL_BLOCK(cs_KeyStore)\n     {\n+        LOCK(cs_KeyStore);\n         if (!IsCrypted())\n             return CBasicKeyStore::GetKey(address, keyOut);\n \n@@ -160,8 +166,8 @@ bool CCryptoKeyStore::GetKey(const CBitcoinAddress &address, CKey& keyOut) const\n \n bool CCryptoKeyStore::GetPubKey(const CBitcoinAddress &address, std::vector<unsigned char>& vchPubKeyOut) const\n {\n-    CRITICAL_BLOCK(cs_KeyStore)\n     {\n+        LOCK(cs_KeyStore);\n         if (!IsCrypted())\n             return CKeyStore::GetPubKey(address, vchPubKeyOut);\n \n@@ -177,8 +183,8 @@ bool CCryptoKeyStore::GetPubKey(const CBitcoinAddress &address, std::vector<unsi\n \n bool CCryptoKeyStore::EncryptKeys(CKeyingMaterial& vMasterKeyIn)\n {\n-    CRITICAL_BLOCK(cs_KeyStore)\n     {\n+        LOCK(cs_KeyStore);\n         if (!mapCryptedKeys.empty() || IsCrypted())\n             return false;\n "
      },
      {
        "sha": "282eaaa047d67d22f30e37171e77dc42f9a1bb7d",
        "filename": "src/keystore.h",
        "status": "modified",
        "additions": 12,
        "deletions": 6,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f8dcd5ca6f55ad49807cf7491c1f153f6158400e/src/keystore.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f8dcd5ca6f55ad49807cf7491c1f153f6158400e/src/keystore.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/keystore.h?ref=f8dcd5ca6f55ad49807cf7491c1f153f6158400e",
        "patch": "@@ -54,15 +54,17 @@ class CBasicKeyStore : public CKeyStore\n     bool HaveKey(const CBitcoinAddress &address) const\n     {\n         bool result;\n-        CRITICAL_BLOCK(cs_KeyStore)\n+        {\n+            LOCK(cs_KeyStore);\n             result = (mapKeys.count(address) > 0);\n+        }\n         return result;\n     }\n     void GetKeys(std::set<CBitcoinAddress> &setAddress) const\n     {\n         setAddress.clear();\n-        CRITICAL_BLOCK(cs_KeyStore)\n         {\n+            LOCK(cs_KeyStore);\n             KeyMap::const_iterator mi = mapKeys.begin();\n             while (mi != mapKeys.end())\n             {\n@@ -73,8 +75,8 @@ class CBasicKeyStore : public CKeyStore\n     }\n     bool GetKey(const CBitcoinAddress &address, CKey &keyOut) const\n     {\n-        CRITICAL_BLOCK(cs_KeyStore)\n         {\n+            LOCK(cs_KeyStore);\n             KeyMap::const_iterator mi = mapKeys.find(address);\n             if (mi != mapKeys.end())\n             {\n@@ -129,8 +131,10 @@ class CCryptoKeyStore : public CBasicKeyStore\n         if (!IsCrypted())\n             return false;\n         bool result;\n-        CRITICAL_BLOCK(cs_KeyStore)\n+        {\n+            LOCK(cs_KeyStore);\n             result = vMasterKey.empty();\n+        }\n         return result;\n     }\n \n@@ -139,8 +143,10 @@ class CCryptoKeyStore : public CBasicKeyStore\n         if (!SetCrypted())\n             return false;\n \n-        CRITICAL_BLOCK(cs_KeyStore)\n+        {\n+            LOCK(cs_KeyStore);\n             vMasterKey.clear();\n+        }\n \n         return true;\n     }\n@@ -149,8 +155,8 @@ class CCryptoKeyStore : public CBasicKeyStore\n     bool AddKey(const CKey& key);\n     bool HaveKey(const CBitcoinAddress &address) const\n     {\n-        CRITICAL_BLOCK(cs_KeyStore)\n         {\n+            LOCK(cs_KeyStore);\n             if (!IsCrypted())\n                 return CBasicKeyStore::HaveKey(address);\n             return mapCryptedKeys.count(address) > 0;"
      },
      {
        "sha": "dea60f0384a829ebaa5fa308ffa85f5b21f91a1a",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 42,
        "deletions": 30,
        "changes": 72,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f8dcd5ca6f55ad49807cf7491c1f153f6158400e/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f8dcd5ca6f55ad49807cf7491c1f153f6158400e/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=f8dcd5ca6f55ad49807cf7491c1f153f6158400e",
        "patch": "@@ -75,16 +75,16 @@ int64 nTransactionFee = 0;\n \n void RegisterWallet(CWallet* pwalletIn)\n {\n-    CRITICAL_BLOCK(cs_setpwalletRegistered)\n     {\n+        LOCK(cs_setpwalletRegistered);\n         setpwalletRegistered.insert(pwalletIn);\n     }\n }\n \n void UnregisterWallet(CWallet* pwalletIn)\n {\n-    CRITICAL_BLOCK(cs_setpwalletRegistered)\n     {\n+        LOCK(cs_setpwalletRegistered);\n         setpwalletRegistered.erase(pwalletIn);\n     }\n }\n@@ -478,9 +478,11 @@ bool CTransaction::AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs, bool* pfMi\n \n     // Do we already have it?\n     uint256 hash = GetHash();\n-    CRITICAL_BLOCK(cs_mapTransactions)\n+    {\n+        LOCK(cs_mapTransactions);\n         if (mapTransactions.count(hash))\n             return false;\n+    }\n     if (fCheckInputs)\n         if (txdb.ContainsTx(hash))\n             return false;\n@@ -552,8 +554,8 @@ bool CTransaction::AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs, bool* pfMi\n             static int64 nLastTime;\n             int64 nNow = GetTime();\n \n-            CRITICAL_BLOCK(cs)\n             {\n+                LOCK(cs);\n                 // Use an exponentially decaying ~10-minute window:\n                 dFreeCount *= pow(1.0 - 1.0/600.0, (double)(nNow - nLastTime));\n                 nLastTime = nNow;\n@@ -576,8 +578,8 @@ bool CTransaction::AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs, bool* pfMi\n     }\n \n     // Store transaction in memory\n-    CRITICAL_BLOCK(cs_mapTransactions)\n     {\n+        LOCK(cs_mapTransactions);\n         if (ptxOld)\n         {\n             printf(\"AcceptToMemoryPool() : replacing tx %s with new version\\n\", ptxOld->GetHash().ToString().c_str());\n@@ -608,8 +610,8 @@ bool CTransaction::AddToMemoryPoolUnchecked()\n     printf(\"AcceptToMemoryPoolUnchecked(): size %lu\\n\",  mapTransactions.size());\n     // Add to memory pool without checking anything.  Don't call this directly,\n     // call AcceptToMemoryPool to properly check the transaction first.\n-    CRITICAL_BLOCK(cs_mapTransactions)\n     {\n+        LOCK(cs_mapTransactions);\n         uint256 hash = GetHash();\n         mapTransactions[hash] = *this;\n         for (int i = 0; i < vin.size(); i++)\n@@ -624,8 +626,8 @@ bool CTransaction::AddToMemoryPoolUnchecked()\n bool CTransaction::RemoveFromMemoryPool()\n {\n     // Remove transaction from memory pool\n-    CRITICAL_BLOCK(cs_mapTransactions)\n     {\n+        LOCK(cs_mapTransactions);\n         uint256 hash = GetHash();\n         if (mapTransactions.count(hash))\n         {\n@@ -702,8 +704,9 @@ bool CMerkleTx::AcceptToMemoryPool()\n \n bool CWalletTx::AcceptWalletTransaction(CTxDB& txdb, bool fCheckInputs)\n {\n-    CRITICAL_BLOCK(cs_mapTransactions)\n+\n     {\n+        LOCK(cs_mapTransactions);\n         // Add previous supporting transactions first\n         BOOST_FOREACH(CMerkleTx& tx, vtxPrev)\n         {\n@@ -1024,8 +1027,8 @@ bool CTransaction::FetchInputs(CTxDB& txdb, const map<uint256, CTxIndex>& mapTes\n         if (!fFound || txindex.pos == CDiskTxPos(1,1,1))\n         {\n             // Get prev tx from single transactions in memory\n-            CRITICAL_BLOCK(cs_mapTransactions)\n             {\n+                LOCK(cs_mapTransactions);\n                 if (!mapTransactions.count(prevout.hash))\n                     return error(\"FetchInputs() : %s mapTransactions prev not found %s\", GetHash().ToString().substr(0,10).c_str(),  prevout.hash.ToString().substr(0,10).c_str());\n                 txPrev = mapTransactions[prevout.hash];\n@@ -1190,8 +1193,8 @@ bool CTransaction::ClientConnectInputs()\n         return false;\n \n     // Take over previous transactions' spent pointers\n-    CRITICAL_BLOCK(cs_mapTransactions)\n     {\n+        LOCK(cs_mapTransactions);\n         int64 nValueIn = 0;\n         for (int i = 0; i < vin.size(); i++)\n         {\n@@ -1707,10 +1710,12 @@ bool CBlock::AcceptBlock()\n     // Relay inventory, but don't relay old inventory during initial block download\n     int nBlockEstimate = Checkpoints::GetTotalBlocksEstimate();\n     if (hashBestChain == hash)\n-        CRITICAL_BLOCK(cs_vNodes)\n-            BOOST_FOREACH(CNode* pnode, vNodes)\n-                if (nBestHeight > (pnode->nStartingHeight != -1 ? pnode->nStartingHeight - 2000 : nBlockEstimate))\n-                    pnode->PushInventory(CInv(MSG_BLOCK, hash));\n+    {\n+        LOCK(cs_vNodes);\n+        BOOST_FOREACH(CNode* pnode, vNodes)\n+            if (nBestHeight > (pnode->nStartingHeight != -1 ? pnode->nStartingHeight - 2000 : nBlockEstimate))\n+                pnode->PushInventory(CInv(MSG_BLOCK, hash));\n+    }\n \n     return true;\n }\n@@ -2052,8 +2057,8 @@ string GetWarnings(string strFor)\n     }\n \n     // Alerts\n-    CRITICAL_BLOCK(cs_mapAlerts)\n     {\n+        LOCK(cs_mapAlerts);\n         BOOST_FOREACH(PAIRTYPE(const uint256, CAlert)& item, mapAlerts)\n         {\n             const CAlert& alert = item.second;\n@@ -2080,8 +2085,8 @@ bool CAlert::ProcessAlert()\n     if (!IsInEffect())\n         return false;\n \n-    CRITICAL_BLOCK(cs_mapAlerts)\n     {\n+        LOCK(cs_mapAlerts);\n         // Cancel previous alerts\n         for (map<uint256, CAlert>::iterator mi = mapAlerts.begin(); mi != mapAlerts.end();)\n         {\n@@ -2260,9 +2265,11 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n         }\n \n         // Relay alerts\n-        CRITICAL_BLOCK(cs_mapAlerts)\n+        {\n+            LOCK(cs_mapAlerts);\n             BOOST_FOREACH(PAIRTYPE(const uint256, CAlert)& item, mapAlerts)\n                 item.second.RelayTo(pfrom);\n+        }\n \n         pfrom->fSuccessfullyConnected = true;\n \n@@ -2316,8 +2323,8 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n             if (addr.nTime > nSince && !pfrom->fGetAddr && vAddr.size() <= 10 && addr.IsRoutable())\n             {\n                 // Relay to a limited number of other nodes\n-                CRITICAL_BLOCK(cs_vNodes)\n                 {\n+                    LOCK(cs_vNodes);\n                     // Use deterministic randomness to send to the same nodes for 24 hours\n                     // at a time so the setAddrKnowns of the chosen nodes prevent repeats\n                     static uint256 hashSalt;\n@@ -2428,8 +2435,8 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n             else if (inv.IsKnownType())\n             {\n                 // Send stream from relay memory\n-                CRITICAL_BLOCK(cs_mapRelay)\n                 {\n+                    LOCK(cs_mapRelay);\n                     map<CInv, CDataStream>::iterator mi = mapRelay.find(inv);\n                     if (mi != mapRelay.end())\n                         pfrom->PushMessage(inv.GetCommand(), (*mi).second);\n@@ -2634,8 +2641,8 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n         vRecv >> hashReply;\n \n         CRequestTracker tracker;\n-        CRITICAL_BLOCK(pfrom->cs_mapRequests)\n         {\n+            LOCK(pfrom->cs_mapRequests);\n             map<uint256, CRequestTracker>::iterator mi = pfrom->mapRequests.find(hashReply);\n             if (mi != pfrom->mapRequests.end())\n             {\n@@ -2662,9 +2669,11 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n         {\n             // Relay\n             pfrom->setKnown.insert(alert.GetHash());\n-            CRITICAL_BLOCK(cs_vNodes)\n+            {\n+                LOCK(cs_vNodes);\n                 BOOST_FOREACH(CNode* pnode, vNodes)\n                     alert.RelayTo(pnode);\n+            }\n         }\n     }\n \n@@ -2763,8 +2772,10 @@ bool ProcessMessages(CNode* pfrom)\n         bool fRet = false;\n         try\n         {\n-            CRITICAL_BLOCK(cs_main)\n+            {\n+                LOCK(cs_main);\n                 fRet = ProcessMessage(pfrom, strCommand, vMsg);\n+            }\n             if (fShutdown)\n                 return true;\n         }\n@@ -2802,8 +2813,8 @@ bool ProcessMessages(CNode* pfrom)\n \n bool SendMessages(CNode* pto, bool fSendTrickle)\n {\n-    CRITICAL_BLOCK(cs_main)\n     {\n+        LOCK(cs_main);\n         // Don't send anything until we get their version message\n         if (pto->nVersion == 0)\n             return true;\n@@ -2819,8 +2830,8 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n         static int64 nLastRebroadcast;\n         if (!IsInitialBlockDownload() && (GetTime() - nLastRebroadcast > 24 * 60 * 60))\n         {\n-            CRITICAL_BLOCK(cs_vNodes)\n             {\n+                LOCK(cs_vNodes);\n                 BOOST_FOREACH(CNode* pnode, vNodes)\n                 {\n                     // Periodically clear setAddrKnown to allow refresh broadcasts\n@@ -2871,8 +2882,8 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n         //\n         vector<CInv> vInv;\n         vector<CInv> vInvWait;\n-        CRITICAL_BLOCK(pto->cs_inventory)\n         {\n+            LOCK(pto->cs_inventory);\n             vInv.reserve(pto->vInventoryToSend.size());\n             vInvWait.reserve(pto->vInventoryToSend.size());\n             BOOST_FOREACH(const CInv& inv, pto->vInventoryToSend)\n@@ -3087,9 +3098,8 @@ CBlock* CreateNewBlock(CReserveKey& reservekey)\n \n     // Collect memory pool transactions into the block\n     int64 nFees = 0;\n-    CRITICAL_BLOCK(cs_main)\n-    CRITICAL_BLOCK(cs_mapTransactions)\n     {\n+        LOCK2(cs_main, cs_mapTransactions);\n         CTxDB txdb(\"r\");\n \n         // Priority order to process transactions\n@@ -3317,17 +3327,19 @@ bool CheckWork(CBlock* pblock, CWallet& wallet, CReserveKey& reservekey)\n     printf(\"generated %s\\n\", FormatMoney(pblock->vtx[0].vout[0].nValue).c_str());\n \n     // Found a solution\n-    CRITICAL_BLOCK(cs_main)\n     {\n+        LOCK(cs_main);\n         if (pblock->hashPrevBlock != hashBestChain)\n             return error(\"BitcoinMiner : generated block is stale\");\n \n         // Remove key from key pool\n         reservekey.KeepKey();\n \n         // Track how many getdata requests this block gets\n-        CRITICAL_BLOCK(wallet.cs_wallet)\n+        {\n+            LOCK(wallet.cs_wallet);\n             wallet.mapRequestCount[pblock->GetHash()] = 0;\n+        }\n \n         // Process this block the same as if we had received it from another node\n         if (!ProcessBlock(NULL, pblock))\n@@ -3443,8 +3455,8 @@ void static BitcoinMiner(CWallet *pwallet)\n             if (GetTimeMillis() - nHPSTimerStart > 4000)\n             {\n                 static CCriticalSection cs;\n-                CRITICAL_BLOCK(cs)\n                 {\n+                    LOCK(cs);\n                     if (GetTimeMillis() - nHPSTimerStart > 4000)\n                     {\n                         dHashesPerSec = 1000.0 * nHashCounter / (GetTimeMillis() - nHPSTimerStart);"
      },
      {
        "sha": "8272b255618e032166c797eaaf3e1a54efb29f64",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 80,
        "deletions": 36,
        "changes": 116,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f8dcd5ca6f55ad49807cf7491c1f153f6158400e/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f8dcd5ca6f55ad49807cf7491c1f153f6158400e/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=f8dcd5ca6f55ad49807cf7491c1f153f6158400e",
        "patch": "@@ -272,9 +272,11 @@ void ThreadGetMyExternalIP(void* parg)\n             // setAddrKnown automatically filters any duplicate sends.\n             CAddress addr(addrLocalHost);\n             addr.nTime = GetAdjustedTime();\n-            CRITICAL_BLOCK(cs_vNodes)\n+            {\n+                LOCK(cs_vNodes);\n                 BOOST_FOREACH(CNode* pnode, vNodes)\n                     pnode->PushAddress(addr);\n+            }\n         }\n     }\n }\n@@ -296,8 +298,8 @@ void AddressCurrentlyConnected(const CService& addr)\n \n CNode* FindNode(const CNetAddr& ip)\n {\n-    CRITICAL_BLOCK(cs_vNodes)\n     {\n+        LOCK(cs_vNodes);\n         BOOST_FOREACH(CNode* pnode, vNodes)\n             if ((CNetAddr)pnode->addr == ip)\n                 return (pnode);\n@@ -307,8 +309,8 @@ CNode* FindNode(const CNetAddr& ip)\n \n CNode* FindNode(const CService& addr)\n {\n-    CRITICAL_BLOCK(cs_vNodes)\n     {\n+        LOCK(cs_vNodes);\n         BOOST_FOREACH(CNode* pnode, vNodes)\n             if ((CService)pnode->addr == addr)\n                 return (pnode);\n@@ -362,10 +364,14 @@ CNode* ConnectNode(CAddress addrConnect, int64 nTimeout)\n             pnode->AddRef(nTimeout);\n         else\n             pnode->AddRef();\n-        CRITICAL_BLOCK(cs_vNodes)\n+        {\n+            LOCK(cs_vNodes);\n             vNodes.push_back(pnode);\n-        WAITABLE_CRITICAL_BLOCK(csOutbound)\n+        }\n+        {\n+            WAITABLE_LOCK(csOutbound);\n             nOutbound++;\n+        }\n \n         pnode->nTimeConnected = GetTime();\n         return pnode;\n@@ -421,8 +427,8 @@ void CNode::ClearBanned()\n bool CNode::IsBanned(CNetAddr ip)\n {\n     bool fResult = false;\n-    CRITICAL_BLOCK(cs_setBanned)\n     {\n+        LOCK(cs_setBanned);\n         std::map<CNetAddr, int64>::iterator i = setBanned.find(ip);\n         if (i != setBanned.end())\n         {\n@@ -446,9 +452,11 @@ bool CNode::Misbehaving(int howmuch)\n     if (nMisbehavior >= GetArg(\"-banscore\", 100))\n     {\n         int64 banTime = GetTime()+GetArg(\"-bantime\", 60*60*24);  // Default 24-hour ban\n-        CRITICAL_BLOCK(cs_setBanned)\n+        {\n+            LOCK(cs_setBanned);\n             if (setBanned[addr] < banTime)\n                 setBanned[addr] = banTime;\n+        }\n         CloseSocketDisconnect();\n         printf(\"Disconnected %s for misbehavior (score=%d)\\n\", addr.ToString().c_str(), nMisbehavior);\n         return true;\n@@ -497,8 +505,8 @@ void ThreadSocketHandler2(void* parg)\n         //\n         // Disconnect nodes\n         //\n-        CRITICAL_BLOCK(cs_vNodes)\n         {\n+            LOCK(cs_vNodes);\n             // Disconnect unused nodes\n             vector<CNode*> vNodesCopy = vNodes;\n             BOOST_FOREACH(CNode* pnode, vNodesCopy)\n@@ -510,8 +518,8 @@ void ThreadSocketHandler2(void* parg)\n                     vNodes.erase(remove(vNodes.begin(), vNodes.end(), pnode), vNodes.end());\n \n                     if (!pnode->fInbound)\n-                        WAITABLE_CRITICAL_BLOCK(csOutbound)\n                         {\n+                            WAITABLE_LOCK(csOutbound);\n                             nOutbound--;\n \n                             // Connection slot(s) were removed, notify connection creator(s)\n@@ -538,11 +546,23 @@ void ThreadSocketHandler2(void* parg)\n                 if (pnode->GetRefCount() <= 0)\n                 {\n                     bool fDelete = false;\n-                    TRY_CRITICAL_BLOCK(pnode->cs_vSend)\n-                     TRY_CRITICAL_BLOCK(pnode->cs_vRecv)\n-                      TRY_CRITICAL_BLOCK(pnode->cs_mapRequests)\n-                       TRY_CRITICAL_BLOCK(pnode->cs_inventory)\n-                        fDelete = true;\n+                    {\n+                        TRY_LOCK(pnode->cs_vSend, lockSend);\n+                        if (lockSend)\n+                        {\n+                            TRY_LOCK(pnode->cs_vRecv, lockRecv);\n+                            if (lockRecv)\n+                            {\n+                                TRY_LOCK(pnode->cs_mapRequests, lockReq);\n+                                if (lockReq)\n+                                {\n+                                    TRY_LOCK(pnode->cs_inventory, lockInv);\n+                                    if (lockInv)\n+                                        fDelete = true;\n+                                }\n+                            }\n+                        }\n+                    }\n                     if (fDelete)\n                     {\n                         vNodesDisconnected.remove(pnode);\n@@ -576,18 +596,20 @@ void ThreadSocketHandler2(void* parg)\n         if(hListenSocket != INVALID_SOCKET)\n             FD_SET(hListenSocket, &fdsetRecv);\n         hSocketMax = max(hSocketMax, hListenSocket);\n-        CRITICAL_BLOCK(cs_vNodes)\n         {\n+            LOCK(cs_vNodes);\n             BOOST_FOREACH(CNode* pnode, vNodes)\n             {\n                 if (pnode->hSocket == INVALID_SOCKET)\n                     continue;\n                 FD_SET(pnode->hSocket, &fdsetRecv);\n                 FD_SET(pnode->hSocket, &fdsetError);\n                 hSocketMax = max(hSocketMax, pnode->hSocket);\n-                TRY_CRITICAL_BLOCK(pnode->cs_vSend)\n-                    if (!pnode->vSend.empty())\n+                {\n+                    TRY_LOCK(pnode->cs_vSend, lockSend);\n+                    if (lockSend && !pnode->vSend.empty())\n                         FD_SET(pnode->hSocket, &fdsetSend);\n+                }\n             }\n         }\n \n@@ -625,10 +647,12 @@ void ThreadSocketHandler2(void* parg)\n             if (hSocket != INVALID_SOCKET)\n                 addr = CAddress(sockaddr);\n \n-            CRITICAL_BLOCK(cs_vNodes)\n+            {\n+                LOCK(cs_vNodes);\n                 BOOST_FOREACH(CNode* pnode, vNodes)\n-                if (pnode->fInbound)\n-                    nInbound++;\n+                    if (pnode->fInbound)\n+                        nInbound++;\n+            }\n \n             if (hSocket == INVALID_SOCKET)\n             {\n@@ -637,9 +661,11 @@ void ThreadSocketHandler2(void* parg)\n             }\n             else if (nInbound >= GetArg(\"-maxconnections\", 125) - MAX_OUTBOUND_CONNECTIONS)\n             {\n-                CRITICAL_BLOCK(cs_setservAddNodeAddresses)\n+                {\n+                    LOCK(cs_setservAddNodeAddresses);\n                     if (!setservAddNodeAddresses.count(addr))\n                         closesocket(hSocket);\n+                }\n             }\n             else if (CNode::IsBanned(addr))\n             {\n@@ -651,8 +677,10 @@ void ThreadSocketHandler2(void* parg)\n                 printf(\"accepted connection %s\\n\", addr.ToString().c_str());\n                 CNode* pnode = new CNode(hSocket, addr, true);\n                 pnode->AddRef();\n-                CRITICAL_BLOCK(cs_vNodes)\n+                {\n+                    LOCK(cs_vNodes);\n                     vNodes.push_back(pnode);\n+                }\n             }\n         }\n \n@@ -661,8 +689,8 @@ void ThreadSocketHandler2(void* parg)\n         // Service each socket\n         //\n         vector<CNode*> vNodesCopy;\n-        CRITICAL_BLOCK(cs_vNodes)\n         {\n+            LOCK(cs_vNodes);\n             vNodesCopy = vNodes;\n             BOOST_FOREACH(CNode* pnode, vNodesCopy)\n                 pnode->AddRef();\n@@ -679,7 +707,8 @@ void ThreadSocketHandler2(void* parg)\n                 continue;\n             if (FD_ISSET(pnode->hSocket, &fdsetRecv) || FD_ISSET(pnode->hSocket, &fdsetError))\n             {\n-                TRY_CRITICAL_BLOCK(pnode->cs_vRecv)\n+                TRY_LOCK(pnode->cs_vRecv, lockRecv);\n+                if (lockRecv)\n                 {\n                     CDataStream& vRecv = pnode->vRecv;\n                     unsigned int nPos = vRecv.size();\n@@ -728,7 +757,8 @@ void ThreadSocketHandler2(void* parg)\n                 continue;\n             if (FD_ISSET(pnode->hSocket, &fdsetSend))\n             {\n-                TRY_CRITICAL_BLOCK(pnode->cs_vSend)\n+                TRY_LOCK(pnode->cs_vSend, lockSend);\n+                if (lockSend)\n                 {\n                     CDataStream& vSend = pnode->vSend;\n                     if (!vSend.empty())\n@@ -782,8 +812,8 @@ void ThreadSocketHandler2(void* parg)\n                 }\n             }\n         }\n-        CRITICAL_BLOCK(cs_vNodes)\n         {\n+            LOCK(cs_vNodes);\n             BOOST_FOREACH(CNode* pnode, vNodesCopy)\n                 pnode->Release();\n         }\n@@ -1195,8 +1225,10 @@ void ThreadOpenConnections2(void* parg)\n         // Limit outbound connections\n         int nMaxOutbound = min(MAX_OUTBOUND_CONNECTIONS, (int)GetArg(\"-maxconnections\", 125));\n         vnThreadsRunning[THREAD_OPENCONNECTIONS]--;\n-        WAITABLE_CRITICAL_BLOCK(csOutbound)\n+        {\n+            WAITABLE_LOCK(csOutbound);\n             WAIT(condOutbound, fShutdown || nOutbound < nMaxOutbound);\n+        }\n         vnThreadsRunning[THREAD_OPENCONNECTIONS]++;\n         if (fShutdown)\n             return;\n@@ -1233,9 +1265,11 @@ void ThreadOpenConnections2(void* parg)\n         // Only connect to one address per a.b.?.? range.\n         // Do this here so we don't have to critsect vNodes inside mapAddresses critsect.\n         set<vector<unsigned char> > setConnected;\n-        CRITICAL_BLOCK(cs_vNodes)\n+        {\n+            LOCK(cs_vNodes);\n             BOOST_FOREACH(CNode* pnode, vNodes)\n                 setConnected.insert(pnode->addr.GetGroup());\n+        }\n \n         int64 nANow = GetAdjustedTime();\n \n@@ -1301,17 +1335,20 @@ void ThreadOpenAddedConnections2(void* parg)\n         if(Lookup(strAddNode.c_str(), vservNode, GetDefaultPort(), fAllowDNS, 0))\n         {\n             vservAddressesToAdd.push_back(vservNode);\n-            CRITICAL_BLOCK(cs_setservAddNodeAddresses)\n+            {\n+                LOCK(cs_setservAddNodeAddresses);\n                 BOOST_FOREACH(CService& serv, vservNode)\n                     setservAddNodeAddresses.insert(serv);\n+            }\n         }\n     }\n     loop\n     {\n         vector<vector<CService> > vservConnectAddresses = vservAddressesToAdd;\n         // Attempt to connect to each IP for each addnode entry until at least one is successful per addnode entry\n         // (keeping in mind that addnode entries can have many IPs if fAllowDNS)\n-        CRITICAL_BLOCK(cs_vNodes)\n+        {\n+            LOCK(cs_vNodes);\n             BOOST_FOREACH(CNode* pnode, vNodes)\n                 for (vector<vector<CService> >::iterator it = vservConnectAddresses.begin(); it != vservConnectAddresses.end(); it++)\n                     BOOST_FOREACH(CService& addrNode, *(it))\n@@ -1321,6 +1358,7 @@ void ThreadOpenAddedConnections2(void* parg)\n                             it--;\n                             break;\n                         }\n+        }\n         BOOST_FOREACH(vector<CService>& vserv, vservConnectAddresses)\n         {\n             OpenNetworkConnection(CAddress(*(vserv.begin())));\n@@ -1394,8 +1432,8 @@ void ThreadMessageHandler2(void* parg)\n     while (!fShutdown)\n     {\n         vector<CNode*> vNodesCopy;\n-        CRITICAL_BLOCK(cs_vNodes)\n         {\n+            LOCK(cs_vNodes);\n             vNodesCopy = vNodes;\n             BOOST_FOREACH(CNode* pnode, vNodesCopy)\n                 pnode->AddRef();\n@@ -1408,20 +1446,26 @@ void ThreadMessageHandler2(void* parg)\n         BOOST_FOREACH(CNode* pnode, vNodesCopy)\n         {\n             // Receive messages\n-            TRY_CRITICAL_BLOCK(pnode->cs_vRecv)\n-                ProcessMessages(pnode);\n+            {\n+                TRY_LOCK(pnode->cs_vRecv, lockRecv);\n+                if (lockRecv)\n+                    ProcessMessages(pnode);\n+            }\n             if (fShutdown)\n                 return;\n \n             // Send messages\n-            TRY_CRITICAL_BLOCK(pnode->cs_vSend)\n-                SendMessages(pnode, pnode == pnodeTrickle);\n+            {\n+                TRY_LOCK(pnode->cs_vSend, lockSend);\n+                if (lockSend)\n+                    SendMessages(pnode, pnode == pnodeTrickle);\n+            }\n             if (fShutdown)\n                 return;\n         }\n \n-        CRITICAL_BLOCK(cs_vNodes)\n         {\n+            LOCK(cs_vNodes);\n             BOOST_FOREACH(CNode* pnode, vNodesCopy)\n                 pnode->Release();\n         }"
      },
      {
        "sha": "3c84650c27f36d38508eb15d2c74ad0f4d99188d",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 19,
        "deletions": 7,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f8dcd5ca6f55ad49807cf7491c1f153f6158400e/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f8dcd5ca6f55ad49807cf7491c1f153f6158400e/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=f8dcd5ca6f55ad49807cf7491c1f153f6158400e",
        "patch": "@@ -247,15 +247,19 @@ class CNode\n \n     void AddInventoryKnown(const CInv& inv)\n     {\n-        CRITICAL_BLOCK(cs_inventory)\n+        {\n+            LOCK(cs_inventory);\n             setInventoryKnown.insert(inv);\n+        }\n     }\n \n     void PushInventory(const CInv& inv)\n     {\n-        CRITICAL_BLOCK(cs_inventory)\n+        {\n+            LOCK(cs_inventory);\n             if (!setInventoryKnown.count(inv))\n                 vInventoryToSend.push_back(inv);\n+        }\n     }\n \n     void AskFor(const CInv& inv)\n@@ -519,8 +523,10 @@ class CNode\n         uint256 hashReply;\n         RAND_bytes((unsigned char*)&hashReply, sizeof(hashReply));\n \n-        CRITICAL_BLOCK(cs_mapRequests)\n+        {\n+            LOCK(cs_mapRequests);\n             mapRequests[hashReply] = CRequestTracker(fn, param1);\n+        }\n \n         PushMessage(pszCommand, hashReply);\n     }\n@@ -532,8 +538,10 @@ class CNode\n         uint256 hashReply;\n         RAND_bytes((unsigned char*)&hashReply, sizeof(hashReply));\n \n-        CRITICAL_BLOCK(cs_mapRequests)\n+        {\n+            LOCK(cs_mapRequests);\n             mapRequests[hashReply] = CRequestTracker(fn, param1);\n+        }\n \n         PushMessage(pszCommand, hashReply, a1);\n     }\n@@ -545,8 +553,10 @@ class CNode\n         uint256 hashReply;\n         RAND_bytes((unsigned char*)&hashReply, sizeof(hashReply));\n \n-        CRITICAL_BLOCK(cs_mapRequests)\n+        {\n+            LOCK(cs_mapRequests);\n             mapRequests[hashReply] = CRequestTracker(fn, param1);\n+        }\n \n         PushMessage(pszCommand, hashReply, a1, a2);\n     }\n@@ -592,9 +602,11 @@ class CNode\n inline void RelayInventory(const CInv& inv)\n {\n     // Put on lists to offer to the other nodes\n-    CRITICAL_BLOCK(cs_vNodes)\n+    {\n+        LOCK(cs_vNodes);\n         BOOST_FOREACH(CNode* pnode, vNodes)\n             pnode->PushInventory(inv);\n+    }\n }\n \n template<typename T>\n@@ -609,8 +621,8 @@ void RelayMessage(const CInv& inv, const T& a)\n template<>\n inline void RelayMessage<>(const CInv& inv, const CDataStream& ss)\n {\n-    CRITICAL_BLOCK(cs_mapRelay)\n     {\n+        LOCK(cs_mapRelay);\n         // Expire old relay messages\n         while (!vRelayExpiration.empty() && vRelayExpiration.front().first < GetTime())\n         {"
      },
      {
        "sha": "05f3a81698a716bdac09dce132859655f3ced17a",
        "filename": "src/qt/addresstablemodel.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 6,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f8dcd5ca6f55ad49807cf7491c1f153f6158400e/src/qt/addresstablemodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f8dcd5ca6f55ad49807cf7491c1f153f6158400e/src/qt/addresstablemodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/addresstablemodel.cpp?ref=f8dcd5ca6f55ad49807cf7491c1f153f6158400e",
        "patch": "@@ -39,8 +39,8 @@ struct AddressTablePriv\n     {\n         cachedAddressTable.clear();\n \n-        CRITICAL_BLOCK(wallet->cs_wallet)\n         {\n+            LOCK(wallet->cs_wallet);\n             BOOST_FOREACH(const PAIRTYPE(CBitcoinAddress, std::string)& item, wallet->mapAddressBook)\n             {\n                 const CBitcoinAddress& address = item.first;\n@@ -169,8 +169,8 @@ bool AddressTableModel::setData(const QModelIndex & index, const QVariant & valu\n             // Double-check that we're not overwriting a receiving address\n             if(rec->type == AddressTableEntry::Sending)\n             {\n-                CRITICAL_BLOCK(wallet->cs_wallet)\n                 {\n+                    LOCK(wallet->cs_wallet);\n                     // Remove old entry\n                     wallet->DelAddressBookName(rec->address.toStdString());\n                     // Add new entry with new address\n@@ -254,8 +254,8 @@ QString AddressTableModel::addRow(const QString &type, const QString &label, con\n             return QString();\n         }\n         // Check for duplicate addresses\n-        CRITICAL_BLOCK(wallet->cs_wallet)\n         {\n+            LOCK(wallet->cs_wallet);\n             if(wallet->mapAddressBook.count(strAddress))\n             {\n                 editStatus = DUPLICATE_ADDRESS;\n@@ -286,8 +286,10 @@ QString AddressTableModel::addRow(const QString &type, const QString &label, con\n         return QString();\n     }\n     // Add entry\n-    CRITICAL_BLOCK(wallet->cs_wallet)\n+    {\n+        LOCK(wallet->cs_wallet);\n         wallet->SetAddressBookName(strAddress, strLabel);\n+    }\n     return QString::fromStdString(strAddress);\n }\n \n@@ -301,8 +303,8 @@ bool AddressTableModel::removeRows(int row, int count, const QModelIndex & paren\n         // Also refuse to remove receiving addresses.\n         return false;\n     }\n-    CRITICAL_BLOCK(wallet->cs_wallet)\n     {\n+        LOCK(wallet->cs_wallet);\n         wallet->DelAddressBookName(rec->address.toStdString());\n     }\n     return true;\n@@ -312,8 +314,8 @@ bool AddressTableModel::removeRows(int row, int count, const QModelIndex & paren\n  */\n QString AddressTableModel::labelForAddress(const QString &address) const\n {\n-    CRITICAL_BLOCK(wallet->cs_wallet)\n     {\n+        LOCK(wallet->cs_wallet);\n         CBitcoinAddress address_parsed(address.toStdString());\n         std::map<CBitcoinAddress, std::string>::iterator mi = wallet->mapAddressBook.find(address_parsed);\n         if (mi != wallet->mapAddressBook.end())"
      },
      {
        "sha": "dd7dd613903c7e090ae58f75441abe239f59a07a",
        "filename": "src/qt/transactiondesc.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f8dcd5ca6f55ad49807cf7491c1f153f6158400e/src/qt/transactiondesc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f8dcd5ca6f55ad49807cf7491c1f153f6158400e/src/qt/transactiondesc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactiondesc.cpp?ref=f8dcd5ca6f55ad49807cf7491c1f153f6158400e",
        "patch": "@@ -34,8 +34,9 @@ QString TransactionDesc::FormatTxStatus(const CWalletTx& wtx)\n QString TransactionDesc::toHTML(CWallet *wallet, CWalletTx &wtx)\n {\n     QString strHTML;\n-    CRITICAL_BLOCK(wallet->cs_wallet)\n+\n     {\n+        LOCK(wallet->cs_wallet);\n         strHTML.reserve(4000);\n         strHTML += \"<html><font face='verdana, arial, helvetica, sans-serif'>\";\n \n@@ -243,8 +244,9 @@ QString TransactionDesc::toHTML(CWallet *wallet, CWalletTx &wtx)\n \n             strHTML += \"<br><b>Inputs:</b>\";\n             strHTML += \"<ul>\";\n-            CRITICAL_BLOCK(wallet->cs_wallet)\n+\n             {\n+                LOCK(wallet->cs_wallet);\n                 BOOST_FOREACH(const CTxIn& txin, wtx.vin)\n                 {\n                     COutPoint prevout = txin.prevout;"
      },
      {
        "sha": "aa11df979f9ea64f64af3c42310fd195784795e1",
        "filename": "src/qt/transactiontablemodel.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f8dcd5ca6f55ad49807cf7491c1f153f6158400e/src/qt/transactiontablemodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f8dcd5ca6f55ad49807cf7491c1f153f6158400e/src/qt/transactiontablemodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactiontablemodel.cpp?ref=f8dcd5ca6f55ad49807cf7491c1f153f6158400e",
        "patch": "@@ -69,8 +69,8 @@ struct TransactionTablePriv\n         qDebug() << \"refreshWallet\";\n #endif\n         cachedWallet.clear();\n-        CRITICAL_BLOCK(wallet->cs_wallet)\n         {\n+            LOCK(wallet->cs_wallet);\n             for(std::map<uint256, CWalletTx>::iterator it = wallet->mapWallet.begin(); it != wallet->mapWallet.end(); ++it)\n             {\n                 cachedWallet.append(TransactionRecord::decomposeTransaction(wallet, it->second));\n@@ -95,8 +95,8 @@ struct TransactionTablePriv\n         QList<uint256> updated_sorted = updated;\n         qSort(updated_sorted);\n \n-        CRITICAL_BLOCK(wallet->cs_wallet)\n         {\n+            LOCK(wallet->cs_wallet);\n             for(int update_idx = updated_sorted.size()-1; update_idx >= 0; --update_idx)\n             {\n                 const uint256 &hash = updated_sorted.at(update_idx);\n@@ -171,8 +171,8 @@ struct TransactionTablePriv\n             // simply re-use the cached status.\n             if(rec->statusUpdateNeeded())\n             {\n-                CRITICAL_BLOCK(wallet->cs_wallet)\n                 {\n+                    LOCK(wallet->cs_wallet);\n                     std::map<uint256, CWalletTx>::iterator mi = wallet->mapWallet.find(rec->hash);\n \n                     if(mi != wallet->mapWallet.end())\n@@ -191,8 +191,8 @@ struct TransactionTablePriv\n \n     QString describe(TransactionRecord *rec)\n     {\n-        CRITICAL_BLOCK(wallet->cs_wallet)\n         {\n+            LOCK(wallet->cs_wallet);\n             std::map<uint256, CWalletTx>::iterator mi = wallet->mapWallet.find(rec->hash);\n             if(mi != wallet->mapWallet.end())\n             {\n@@ -229,9 +229,9 @@ void TransactionTableModel::update()\n     QList<uint256> updated;\n \n     // Check if there are changes to wallet map\n-    TRY_CRITICAL_BLOCK(wallet->cs_wallet)\n     {\n-        if(!wallet->vWalletUpdated.empty())\n+        TRY_LOCK(wallet->cs_wallet, lockWallet);\n+        if (lockWallet && !wallet->vWalletUpdated.empty())\n         {\n             BOOST_FOREACH(uint256 hash, wallet->vWalletUpdated)\n             {"
      },
      {
        "sha": "9c28a8abc8b570cd4a546b6d6e0aee99776f4b89",
        "filename": "src/qt/walletmodel.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f8dcd5ca6f55ad49807cf7491c1f153f6158400e/src/qt/walletmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f8dcd5ca6f55ad49807cf7491c1f153f6158400e/src/qt/walletmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletmodel.cpp?ref=f8dcd5ca6f55ad49807cf7491c1f153f6158400e",
        "patch": "@@ -32,8 +32,8 @@ qint64 WalletModel::getUnconfirmedBalance() const\n int WalletModel::getNumTransactions() const\n {\n     int numTransactions = 0;\n-    CRITICAL_BLOCK(wallet->cs_wallet)\n     {\n+        LOCK(wallet->cs_wallet);\n         numTransactions = wallet->mapWallet.size();\n     }\n     return numTransactions;\n@@ -115,9 +115,9 @@ WalletModel::SendCoinsReturn WalletModel::sendCoins(const QList<SendCoinsRecipie\n         return SendCoinsReturn(AmountWithFeeExceedsBalance, nTransactionFee);\n     }\n \n-    CRITICAL_BLOCK(cs_main)\n-    CRITICAL_BLOCK(wallet->cs_wallet)\n     {\n+        LOCK2(cs_main, wallet->cs_wallet);\n+\n         // Sendmany\n         std::vector<std::pair<CScript, int64> > vecSend;\n         foreach(const SendCoinsRecipient &rcp, recipients)\n@@ -155,8 +155,8 @@ WalletModel::SendCoinsReturn WalletModel::sendCoins(const QList<SendCoinsRecipie\n     foreach(const SendCoinsRecipient &rcp, recipients)\n     {\n         std::string strAddress = rcp.address.toStdString();\n-        CRITICAL_BLOCK(wallet->cs_wallet)\n         {\n+            LOCK(wallet->cs_wallet);\n             if (!wallet->mapAddressBook.count(strAddress))\n                 wallet->SetAddressBookName(strAddress, rcp.label.toStdString());\n         }\n@@ -227,8 +227,8 @@ bool WalletModel::setWalletLocked(bool locked, const SecureString &passPhrase)\n bool WalletModel::changePassphrase(const SecureString &oldPass, const SecureString &newPass)\n {\n     bool retval;\n-    CRITICAL_BLOCK(wallet->cs_wallet)\n     {\n+        LOCK(wallet->cs_wallet);\n         wallet->Lock(); // Make sure wallet is locked before attempting pass change\n         retval = wallet->ChangeWalletPassphrase(oldPass, newPass);\n     }"
      },
      {
        "sha": "5bb4789cd341f52b6d2c1e128a02e2a5259dd4ef",
        "filename": "src/rpcdump.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f8dcd5ca6f55ad49807cf7491c1f153f6158400e/src/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f8dcd5ca6f55ad49807cf7491c1f153f6158400e/src/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcdump.cpp?ref=f8dcd5ca6f55ad49807cf7491c1f153f6158400e",
        "patch": "@@ -60,9 +60,9 @@ Value importprivkey(const Array& params, bool fHelp)\n     key.SetSecret(secret, fCompressed);\n     CBitcoinAddress vchAddress = CBitcoinAddress(key.GetPubKey());\n \n-    CRITICAL_BLOCK(cs_main)\n-    CRITICAL_BLOCK(pwalletMain->cs_wallet)\n     {\n+        LOCK2(cs_main, pwalletMain->cs_wallet);\n+\n         pwalletMain->MarkDirty();\n         pwalletMain->SetAddressBookName(vchAddress, strLabel);\n "
      },
      {
        "sha": "db31f4988a96ec14f73564b549162d5dd3a5b939",
        "filename": "src/test/util_tests.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f8dcd5ca6f55ad49807cf7491c1f153f6158400e/src/test/util_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f8dcd5ca6f55ad49807cf7491c1f153f6158400e/src/test/util_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util_tests.cpp?ref=f8dcd5ca6f55ad49807cf7491c1f153f6158400e",
        "patch": "@@ -15,14 +15,15 @@ BOOST_AUTO_TEST_CASE(util_criticalsection)\n     CCriticalSection cs;\n \n     do {\n-        CRITICAL_BLOCK(cs)\n-            break;\n+        LOCK(cs);\n+        break;\n \n         BOOST_ERROR(\"break was swallowed!\");\n     } while(0);\n \n     do {\n-        TRY_CRITICAL_BLOCK(cs)\n+        TRY_LOCK(cs, lockTest);\n+        if (lockTest)\n             break;\n \n         BOOST_ERROR(\"break was swallowed!\");"
      },
      {
        "sha": "fd4847b1aa8f43ef1f9e8cc557fa51f489aa8e24",
        "filename": "src/util.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f8dcd5ca6f55ad49807cf7491c1f153f6158400e/src/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f8dcd5ca6f55ad49807cf7491c1f153f6158400e/src/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.cpp?ref=f8dcd5ca6f55ad49807cf7491c1f153f6158400e",
        "patch": "@@ -195,8 +195,8 @@ inline int OutputDebugStringF(const char* pszFormat, ...)\n         static CCriticalSection cs_OutputDebugStringF;\n \n         // accumulate a line at a time\n-        CRITICAL_BLOCK(cs_OutputDebugStringF)\n         {\n+            LOCK(cs_OutputDebugStringF);\n             static char pszBuffer[50000];\n             static char* pend;\n             if (pend == NULL)"
      },
      {
        "sha": "7027e62b09b53c279bc2135074b765f14cb05970",
        "filename": "src/util.h",
        "status": "modified",
        "additions": 4,
        "deletions": 11,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f8dcd5ca6f55ad49807cf7491c1f153f6158400e/src/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f8dcd5ca6f55ad49807cf7491c1f153f6158400e/src/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.h?ref=f8dcd5ca6f55ad49807cf7491c1f153f6158400e",
        "patch": "@@ -282,13 +282,10 @@ typedef boost::interprocess::interprocess_condition CConditionVariable;\n #define NOTIFY_ALL(name) \\\n    do { (name).notify_all(); } while(0)\n \n-#define CRITICAL_BLOCK(cs)     \\\n-    for (bool fcriticalblockonce=true; fcriticalblockonce; assert((\"break caught by CRITICAL_BLOCK!\" && !fcriticalblockonce)), fcriticalblockonce=false) \\\n-        for (CCriticalBlock criticalblock(cs, #cs, __FILE__, __LINE__); fcriticalblockonce; fcriticalblockonce=false)\n-\n-#define WAITABLE_CRITICAL_BLOCK(cs)     \\\n-    for (bool fcriticalblockonce=true; fcriticalblockonce; assert((\"break caught by WAITABLE_CRITICAL_BLOCK!\" && !fcriticalblockonce)), fcriticalblockonce=false) \\\n-        for (CWaitableCriticalBlock waitablecriticalblock(cs, #cs, __FILE__, __LINE__); fcriticalblockonce; fcriticalblockonce=false)\n+#define LOCK(cs) CCriticalBlock criticalblock(cs, #cs, __FILE__, __LINE__)\n+#define LOCK2(cs1,cs2) CCriticalBlock criticalblock1(cs1, #cs1, __FILE__, __LINE__),criticalblock2(cs2, #cs2, __FILE__, __LINE__)\n+#define TRY_LOCK(cs,name) CCriticalBlock name(cs, #cs, __FILE__, __LINE__, true)\n+#define WAITABLE_LOCK(cs) CWaitableCriticalBlock waitablecriticalblock(cs, #cs, __FILE__, __LINE__)\n \n #define ENTER_CRITICAL_SECTION(cs) \\\n     { \\\n@@ -302,10 +299,6 @@ typedef boost::interprocess::interprocess_condition CConditionVariable;\n         LeaveCritical(); \\\n     }\n \n-#define TRY_CRITICAL_BLOCK(cs)     \\\n-    for (bool fcriticalblockonce=true; fcriticalblockonce; assert((\"break caught by TRY_CRITICAL_BLOCK!\" && !fcriticalblockonce)), fcriticalblockonce=false) \\\n-        for (CCriticalBlock criticalblock(cs, #cs, __FILE__, __LINE__, true); fcriticalblockonce && (fcriticalblockonce = criticalblock); fcriticalblockonce=false)\n-\n \n // This is exactly like std::string, but with a custom allocator.\n // (secure_allocator<> is defined in serialize.h)"
      },
      {
        "sha": "97ed6aa58028555b78d68b5b7c5a92dcd12d4935",
        "filename": "src/wallet.cpp",
        "status": "modified",
        "additions": 43,
        "deletions": 38,
        "changes": 81,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f8dcd5ca6f55ad49807cf7491c1f153f6158400e/src/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f8dcd5ca6f55ad49807cf7491c1f153f6158400e/src/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.cpp?ref=f8dcd5ca6f55ad49807cf7491c1f153f6158400e",
        "patch": "@@ -49,8 +49,8 @@ bool CWallet::AddCryptedKey(const vector<unsigned char> &vchPubKey, const vector\n         return false;\n     if (!fFileBacked)\n         return true;\n-    CRITICAL_BLOCK(cs_wallet)\n     {\n+        LOCK(cs_wallet);\n         if (pwalletdbEncryption)\n             return pwalletdbEncryption->WriteCryptedKey(vchPubKey, vchCryptedSecret);\n         else\n@@ -76,7 +76,8 @@ bool CWallet::Unlock(const SecureString& strWalletPassphrase)\n     CCrypter crypter;\n     CKeyingMaterial vMasterKey;\n \n-    CRITICAL_BLOCK(cs_wallet)\n+    {\n+        LOCK(cs_wallet);\n         BOOST_FOREACH(const MasterKeyMap::value_type& pMasterKey, mapMasterKeys)\n         {\n             if(!crypter.SetKeyFromPassphrase(strWalletPassphrase, pMasterKey.second.vchSalt, pMasterKey.second.nDeriveIterations, pMasterKey.second.nDerivationMethod))\n@@ -86,15 +87,16 @@ bool CWallet::Unlock(const SecureString& strWalletPassphrase)\n             if (CCryptoKeyStore::Unlock(vMasterKey))\n                 return true;\n         }\n+    }\n     return false;\n }\n \n bool CWallet::ChangeWalletPassphrase(const SecureString& strOldWalletPassphrase, const SecureString& strNewWalletPassphrase)\n {\n     bool fWasLocked = IsLocked();\n \n-    CRITICAL_BLOCK(cs_wallet)\n     {\n+        LOCK(cs_wallet);\n         Lock();\n \n         CCrypter crypter;\n@@ -228,8 +230,8 @@ bool CWallet::EncryptWallet(const SecureString& strWalletPassphrase)\n     if (!crypter.Encrypt(vMasterKey, kMasterKey.vchCryptedKey))\n         return false;\n \n-    CRITICAL_BLOCK(cs_wallet)\n     {\n+        LOCK(cs_wallet);\n         mapMasterKeys[++nMasterKeyMaxID] = kMasterKey;\n         if (fFileBacked)\n         {\n@@ -275,8 +277,8 @@ void CWallet::WalletUpdateSpent(const CTransaction &tx)\n     // Anytime a signature is successfully verified, it's proof the outpoint is spent.\n     // Update the wallet spent flag if it doesn't know due to wallet.dat being\n     // restored from backup or the user making copies of wallet.dat.\n-    CRITICAL_BLOCK(cs_wallet)\n     {\n+        LOCK(cs_wallet);\n         BOOST_FOREACH(const CTxIn& txin, tx.vin)\n         {\n             map<uint256, CWalletTx>::iterator mi = mapWallet.find(txin.prevout.hash);\n@@ -297,8 +299,8 @@ void CWallet::WalletUpdateSpent(const CTransaction &tx)\n \n void CWallet::MarkDirty()\n {\n-    CRITICAL_BLOCK(cs_wallet)\n     {\n+        LOCK(cs_wallet);\n         BOOST_FOREACH(PAIRTYPE(const uint256, CWalletTx)& item, mapWallet)\n             item.second.MarkDirty();\n     }\n@@ -307,8 +309,8 @@ void CWallet::MarkDirty()\n bool CWallet::AddToWallet(const CWalletTx& wtxIn)\n {\n     uint256 hash = wtxIn.GetHash();\n-    CRITICAL_BLOCK(cs_wallet)\n     {\n+        LOCK(cs_wallet);\n         // Inserts only if not already there, returns tx inserted or tx found\n         pair<map<uint256, CWalletTx>::iterator, bool> ret = mapWallet.insert(make_pair(hash, wtxIn));\n         CWalletTx& wtx = (*ret.first).second;\n@@ -382,8 +384,8 @@ bool CWallet::AddToWallet(const CWalletTx& wtxIn)\n bool CWallet::AddToWalletIfInvolvingMe(const CTransaction& tx, const CBlock* pblock, bool fUpdate, bool fFindBlock)\n {\n     uint256 hash = tx.GetHash();\n-    CRITICAL_BLOCK(cs_wallet)\n     {\n+        LOCK(cs_wallet);\n         bool fExisted = mapWallet.count(hash);\n         if (fExisted && !fUpdate) return false;\n         if (fExisted || IsMine(tx) || IsFromMe(tx))\n@@ -404,8 +406,8 @@ bool CWallet::EraseFromWallet(uint256 hash)\n {\n     if (!fFileBacked)\n         return false;\n-    CRITICAL_BLOCK(cs_wallet)\n     {\n+        LOCK(cs_wallet);\n         if (mapWallet.erase(hash))\n             CWalletDB(strWalletFile).EraseTx(hash);\n     }\n@@ -415,8 +417,8 @@ bool CWallet::EraseFromWallet(uint256 hash)\n \n bool CWallet::IsMine(const CTxIn &txin) const\n {\n-    CRITICAL_BLOCK(cs_wallet)\n     {\n+        LOCK(cs_wallet);\n         map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(txin.prevout.hash);\n         if (mi != mapWallet.end())\n         {\n@@ -431,8 +433,8 @@ bool CWallet::IsMine(const CTxIn &txin) const\n \n int64 CWallet::GetDebit(const CTxIn &txin) const\n {\n-    CRITICAL_BLOCK(cs_wallet)\n     {\n+        LOCK(cs_wallet);\n         map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(txin.prevout.hash);\n         if (mi != mapWallet.end())\n         {\n@@ -457,9 +459,11 @@ bool CWallet::IsChange(const CTxOut& txout) const\n     // 'the change' will need to be implemented (maybe extend CWalletTx to remember\n     // which output, if any, was change).\n     if (ExtractAddress(txout.scriptPubKey, address) && HaveKey(address))\n-        CRITICAL_BLOCK(cs_wallet)\n-            if (!mapAddressBook.count(address))\n-                return true;\n+    {\n+        LOCK(cs_wallet);\n+        if (!mapAddressBook.count(address))\n+            return true;\n+    }\n     return false;\n }\n \n@@ -472,8 +476,8 @@ int CWalletTx::GetRequestCount() const\n {\n     // Returns -1 if it wasn't being tracked\n     int nRequests = -1;\n-    CRITICAL_BLOCK(pwallet->cs_wallet)\n     {\n+        LOCK(pwallet->cs_wallet);\n         if (IsCoinBase())\n         {\n             // Generated block\n@@ -577,8 +581,8 @@ void CWalletTx::GetAccountAmounts(const string& strAccount, int64& nGenerated, i\n             nSent += s.second;\n         nFee = allFee;\n     }\n-    CRITICAL_BLOCK(pwallet->cs_wallet)\n     {\n+        LOCK(pwallet->cs_wallet);\n         BOOST_FOREACH(const PAIRTYPE(CBitcoinAddress,int64)& r, listReceived)\n         {\n             if (pwallet->mapAddressBook.count(r.first))\n@@ -607,8 +611,8 @@ void CWalletTx::AddSupportingTransactions(CTxDB& txdb)\n             vWorkQueue.push_back(txin.prevout.hash);\n \n         // This critsect is OK because txdb is already open\n-        CRITICAL_BLOCK(pwallet->cs_wallet)\n         {\n+            LOCK(pwallet->cs_wallet);\n             map<uint256, const CMerkleTx*> mapWalletPrev;\n             set<uint256> setAlreadyDone;\n             for (int i = 0; i < vWorkQueue.size(); i++)\n@@ -666,8 +670,8 @@ int CWallet::ScanForWalletTransactions(CBlockIndex* pindexStart, bool fUpdate)\n     int ret = 0;\n \n     CBlockIndex* pindex = pindexStart;\n-    CRITICAL_BLOCK(cs_wallet)\n     {\n+        LOCK(cs_wallet);\n         while (pindex)\n         {\n             CBlock block;\n@@ -696,8 +700,9 @@ void CWallet::ReacceptWalletTransactions()\n {\n     CTxDB txdb(\"r\");\n     bool fRepeat = true;\n-    while (fRepeat) CRITICAL_BLOCK(cs_wallet)\n+    while (fRepeat)\n     {\n+        LOCK(cs_wallet);\n         fRepeat = false;\n         vector<CDiskTxPos> vMissingTx;\n         BOOST_FOREACH(PAIRTYPE(const uint256, CWalletTx)& item, mapWallet)\n@@ -799,8 +804,8 @@ void CWallet::ResendWalletTransactions()\n     // Rebroadcast any of our txes that aren't in a block yet\n     printf(\"ResendWalletTransactions()\\n\");\n     CTxDB txdb(\"r\");\n-    CRITICAL_BLOCK(cs_wallet)\n     {\n+        LOCK(cs_wallet);\n         // Sort them in chronological order\n         multimap<unsigned int, CWalletTx*> mapSorted;\n         BOOST_FOREACH(PAIRTYPE(const uint256, CWalletTx)& item, mapWallet)\n@@ -833,8 +838,8 @@ void CWallet::ResendWalletTransactions()\n int64 CWallet::GetBalance() const\n {\n     int64 nTotal = 0;\n-    CRITICAL_BLOCK(cs_wallet)\n     {\n+        LOCK(cs_wallet);\n         for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n         {\n             const CWalletTx* pcoin = &(*it).second;\n@@ -850,8 +855,8 @@ int64 CWallet::GetBalance() const\n int64 CWallet::GetUnconfirmedBalance() const\n {\n     int64 nTotal = 0;\n-    CRITICAL_BLOCK(cs_wallet)\n     {\n+        LOCK(cs_wallet);\n         for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n         {\n             const CWalletTx* pcoin = &(*it).second;\n@@ -875,8 +880,8 @@ bool CWallet::SelectCoinsMinConf(int64 nTargetValue, int nConfMine, int nConfThe\n     vector<pair<int64, pair<const CWalletTx*,unsigned int> > > vValue;\n     int64 nTotalLower = 0;\n \n-    CRITICAL_BLOCK(cs_wallet)\n     {\n+       LOCK(cs_wallet);\n        vector<const CWalletTx*> vCoins;\n        vCoins.reserve(mapWallet.size());\n        for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n@@ -1032,9 +1037,8 @@ bool CWallet::CreateTransaction(const vector<pair<CScript, int64> >& vecSend, CW\n \n     wtxNew.BindWallet(this);\n \n-    CRITICAL_BLOCK(cs_main)\n-    CRITICAL_BLOCK(cs_wallet)\n     {\n+        LOCK2(cs_main, cs_wallet);\n         // txdb must be opened before the mapWallet lock\n         CTxDB txdb(\"r\");\n         {\n@@ -1146,9 +1150,8 @@ bool CWallet::CreateTransaction(CScript scriptPubKey, int64 nValue, CWalletTx& w\n // Call after CreateTransaction unless you want to abort\n bool CWallet::CommitTransaction(CWalletTx& wtxNew, CReserveKey& reservekey)\n {\n-    CRITICAL_BLOCK(cs_main)\n-    CRITICAL_BLOCK(cs_wallet)\n     {\n+        LOCK2(cs_main, cs_wallet);\n         printf(\"CommitTransaction:\\n%s\", wtxNew.ToString().c_str());\n         {\n             // This is only to keep the database open to defeat the auto-flush for the\n@@ -1297,8 +1300,8 @@ bool CWallet::DelAddressBookName(const CBitcoinAddress& address)\n \n void CWallet::PrintWallet(const CBlock& block)\n {\n-    CRITICAL_BLOCK(cs_wallet)\n     {\n+        LOCK(cs_wallet);\n         if (mapWallet.count(block.vtx[0].GetHash()))\n         {\n             CWalletTx& wtx = mapWallet[block.vtx[0].GetHash()];\n@@ -1310,8 +1313,8 @@ void CWallet::PrintWallet(const CBlock& block)\n \n bool CWallet::GetTransaction(const uint256 &hashTx, CWalletTx& wtx)\n {\n-    CRITICAL_BLOCK(cs_wallet)\n     {\n+        LOCK(cs_wallet);\n         map<uint256, CWalletTx>::iterator mi = mapWallet.find(hashTx);\n         if (mi != mapWallet.end())\n         {\n@@ -1347,8 +1350,8 @@ bool GetWalletFile(CWallet* pwallet, string &strWalletFileOut)\n //\n bool CWallet::NewKeyPool()\n {\n-    CRITICAL_BLOCK(cs_wallet)\n     {\n+        LOCK(cs_wallet);\n         CWalletDB walletdb(strWalletFile);\n         BOOST_FOREACH(int64 nIndex, setKeyPool)\n             walletdb.ErasePool(nIndex);\n@@ -1371,8 +1374,9 @@ bool CWallet::NewKeyPool()\n \n bool CWallet::TopUpKeyPool()\n {\n-    CRITICAL_BLOCK(cs_wallet)\n     {\n+        LOCK(cs_wallet);\n+\n         if (IsLocked())\n             return false;\n \n@@ -1398,8 +1402,9 @@ void CWallet::ReserveKeyFromKeyPool(int64& nIndex, CKeyPool& keypool)\n {\n     nIndex = -1;\n     keypool.vchPubKey.clear();\n-    CRITICAL_BLOCK(cs_wallet)\n     {\n+        LOCK(cs_wallet);\n+\n         if (!IsLocked())\n             TopUpKeyPool();\n \n@@ -1422,9 +1427,8 @@ void CWallet::ReserveKeyFromKeyPool(int64& nIndex, CKeyPool& keypool)\n \n int64 CWallet::AddReserveKey(const CKeyPool& keypool)\n {\n-    CRITICAL_BLOCK(cs_main)\n-    CRITICAL_BLOCK(cs_wallet)\n     {\n+        LOCK2(cs_main, cs_wallet);\n         CWalletDB walletdb(strWalletFile);\n \n         int64 nIndex = 1 + *(--setKeyPool.end());\n@@ -1450,17 +1454,19 @@ void CWallet::KeepKey(int64 nIndex)\n void CWallet::ReturnKey(int64 nIndex)\n {\n     // Return to key pool\n-    CRITICAL_BLOCK(cs_wallet)\n+    {\n+        LOCK(cs_wallet);\n         setKeyPool.insert(nIndex);\n+    }\n     printf(\"keypool return %\"PRI64d\"\\n\", nIndex);\n }\n \n bool CWallet::GetKeyFromPool(vector<unsigned char>& result, bool fAllowReuse)\n {\n     int64 nIndex = 0;\n     CKeyPool keypool;\n-    CRITICAL_BLOCK(cs_wallet)\n     {\n+        LOCK(cs_wallet);\n         ReserveKeyFromKeyPool(nIndex, keypool);\n         if (nIndex == -1)\n         {\n@@ -1530,8 +1536,7 @@ void CWallet::GetAllReserveAddresses(set<CBitcoinAddress>& setAddress)\n \n     CWalletDB walletdb(strWalletFile);\n \n-    CRITICAL_BLOCK(cs_main)\n-    CRITICAL_BLOCK(cs_wallet)\n+    LOCK2(cs_main, cs_wallet);\n     BOOST_FOREACH(const int64& id, setKeyPool)\n     {\n         CKeyPool keypool;"
      },
      {
        "sha": "f864370acf1808df4c16f92c269d1b494778290a",
        "filename": "src/wallet.h",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f8dcd5ca6f55ad49807cf7491c1f153f6158400e/src/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f8dcd5ca6f55ad49807cf7491c1f153f6158400e/src/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.h?ref=f8dcd5ca6f55ad49807cf7491c1f153f6158400e",
        "patch": "@@ -211,16 +211,18 @@ class CWallet : public CCryptoKeyStore\n \n     void UpdatedTransaction(const uint256 &hashTx)\n     {\n-        CRITICAL_BLOCK(cs_wallet)\n+        {\n+            LOCK(cs_wallet);\n             vWalletUpdated.push_back(hashTx);\n+        }\n     }\n \n     void PrintWallet(const CBlock& block);\n \n     void Inventory(const uint256 &hash)\n     {\n-        CRITICAL_BLOCK(cs_wallet)\n         {\n+            LOCK(cs_wallet);\n             std::map<uint256, int>::iterator mi = mapRequestCount.find(hash);\n             if (mi != mapRequestCount.end())\n                 (*mi).second++;"
      }
    ]
  },
  {
    "sha": "908037fe16843aa354f63af8f14804821aaf70f1",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5MDgwMzdmZTE2ODQzYWEzNTRmNjNhZjhmMTQ4MDQ4MjFhYWY3MGYx",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-04-07T16:29:31Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-04-08T23:59:57Z"
      },
      "message": "Support for parametrized locks in deadlock detector",
      "tree": {
        "sha": "81fc35c44ace6ceefb0a4e9b9ae292ef437c7dc5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/81fc35c44ace6ceefb0a4e9b9ae292ef437c7dc5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/908037fe16843aa354f63af8f14804821aaf70f1",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/908037fe16843aa354f63af8f14804821aaf70f1",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/908037fe16843aa354f63af8f14804821aaf70f1",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/908037fe16843aa354f63af8f14804821aaf70f1/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f8dcd5ca6f55ad49807cf7491c1f153f6158400e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f8dcd5ca6f55ad49807cf7491c1f153f6158400e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f8dcd5ca6f55ad49807cf7491c1f153f6158400e"
      }
    ],
    "stats": {
      "total": 18,
      "additions": 9,
      "deletions": 9
    },
    "files": [
      {
        "sha": "17442a3bcfad2daca18c33b6feaefc3f901eb065",
        "filename": "src/util.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/908037fe16843aa354f63af8f14804821aaf70f1/src/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/908037fe16843aa354f63af8f14804821aaf70f1/src/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.cpp?ref=908037fe16843aa354f63af8f14804821aaf70f1",
        "patch": "@@ -1115,33 +1115,33 @@ struct CLockLocation\n     int sourceLine;\n };\n \n-typedef std::vector< std::pair<CCriticalSection*, CLockLocation> > LockStack;\n+typedef std::vector< std::pair<void*, CLockLocation> > LockStack;\n \n static boost::interprocess::interprocess_mutex dd_mutex;\n-static std::map<std::pair<CCriticalSection*, CCriticalSection*>, LockStack> lockorders;\n+static std::map<std::pair<void*, void*>, LockStack> lockorders;\n static boost::thread_specific_ptr<LockStack> lockstack;\n \n \n-static void potential_deadlock_detected(const std::pair<CCriticalSection*, CCriticalSection*>& mismatch, const LockStack& s1, const LockStack& s2)\n+static void potential_deadlock_detected(const std::pair<void*, void*>& mismatch, const LockStack& s1, const LockStack& s2)\n {\n     printf(\"POTENTIAL DEADLOCK DETECTED\\n\");\n     printf(\"Previous lock order was:\\n\");\n-    BOOST_FOREACH(const PAIRTYPE(CCriticalSection*, CLockLocation)& i, s2)\n+    BOOST_FOREACH(const PAIRTYPE(void*, CLockLocation)& i, s2)\n     {\n         if (i.first == mismatch.first) printf(\" (1)\");\n         if (i.first == mismatch.second) printf(\" (2)\");\n         printf(\" %s\\n\", i.second.ToString().c_str());\n     }\n     printf(\"Current lock order is:\\n\");\n-    BOOST_FOREACH(const PAIRTYPE(CCriticalSection*, CLockLocation)& i, s1)\n+    BOOST_FOREACH(const PAIRTYPE(void*, CLockLocation)& i, s1)\n     {\n         if (i.first == mismatch.first) printf(\" (1)\");\n         if (i.first == mismatch.second) printf(\" (2)\");\n         printf(\" %s\\n\", i.second.ToString().c_str());\n     }\n }\n \n-static void push_lock(CCriticalSection* c, const CLockLocation& locklocation)\n+static void push_lock(void* c, const CLockLocation& locklocation)\n {\n     bool fOrderOK = true;\n     if (lockstack.get() == NULL)\n@@ -1152,16 +1152,16 @@ static void push_lock(CCriticalSection* c, const CLockLocation& locklocation)\n \n     (*lockstack).push_back(std::make_pair(c, locklocation));\n \n-    BOOST_FOREACH(const PAIRTYPE(CCriticalSection*, CLockLocation)& i, (*lockstack))\n+    BOOST_FOREACH(const PAIRTYPE(void*, CLockLocation)& i, (*lockstack))\n     {\n         if (i.first == c) break;\n \n-        std::pair<CCriticalSection*, CCriticalSection*> p1 = std::make_pair(i.first, c);\n+        std::pair<void*, void*> p1 = std::make_pair(i.first, c);\n         if (lockorders.count(p1))\n             continue;\n         lockorders[p1] = (*lockstack);\n \n-        std::pair<CCriticalSection*, CCriticalSection*> p2 = std::make_pair(c, i.first);\n+        std::pair<void*, void*> p2 = std::make_pair(c, i.first);\n         if (lockorders.count(p2))\n         {\n             potential_deadlock_detected(p1, lockorders[p2], lockorders[p1]);"
      }
    ]
  },
  {
    "sha": "f342dac1cb06d5b0d264fa59e448ef6477ec5b6b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmMzQyZGFjMWNiMDZkNWIwZDI2NGZhNTllNDQ4ZWY2NDc3ZWM1YjZi",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-04-07T16:55:29Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-04-08T23:59:57Z"
      },
      "message": "Do not report spurious deadlocks caused by TRY_LOCK",
      "tree": {
        "sha": "e718ee1c9a8dd355238639a61ebbbba7226918ae",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e718ee1c9a8dd355238639a61ebbbba7226918ae"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f342dac1cb06d5b0d264fa59e448ef6477ec5b6b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f342dac1cb06d5b0d264fa59e448ef6477ec5b6b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f342dac1cb06d5b0d264fa59e448ef6477ec5b6b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f342dac1cb06d5b0d264fa59e448ef6477ec5b6b/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "908037fe16843aa354f63af8f14804821aaf70f1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/908037fe16843aa354f63af8f14804821aaf70f1",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/908037fe16843aa354f63af8f14804821aaf70f1"
      }
    ],
    "stats": {
      "total": 14,
      "additions": 7,
      "deletions": 7
    },
    "files": [
      {
        "sha": "affca341ce033eb66b2851fac3d8d0585f28b9a6",
        "filename": "src/util.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f342dac1cb06d5b0d264fa59e448ef6477ec5b6b/src/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f342dac1cb06d5b0d264fa59e448ef6477ec5b6b/src/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.cpp?ref=f342dac1cb06d5b0d264fa59e448ef6477ec5b6b",
        "patch": "@@ -1141,7 +1141,7 @@ static void potential_deadlock_detected(const std::pair<void*, void*>& mismatch,\n     }\n }\n \n-static void push_lock(void* c, const CLockLocation& locklocation)\n+static void push_lock(void* c, const CLockLocation& locklocation, bool fTry)\n {\n     bool fOrderOK = true;\n     if (lockstack.get() == NULL)\n@@ -1152,7 +1152,7 @@ static void push_lock(void* c, const CLockLocation& locklocation)\n \n     (*lockstack).push_back(std::make_pair(c, locklocation));\n \n-    BOOST_FOREACH(const PAIRTYPE(void*, CLockLocation)& i, (*lockstack))\n+    if (!fTry) BOOST_FOREACH(const PAIRTYPE(void*, CLockLocation)& i, (*lockstack))\n     {\n         if (i.first == c) break;\n \n@@ -1183,9 +1183,9 @@ static void pop_lock()\n     dd_mutex.unlock();\n }\n \n-void EnterCritical(const char* pszName, const char* pszFile, int nLine, void* cs)\n+void EnterCritical(const char* pszName, const char* pszFile, int nLine, void* cs, bool fTry)\n {\n-    push_lock(cs, CLockLocation(pszName, pszFile, nLine));\n+    push_lock(cs, CLockLocation(pszName, pszFile, nLine), fTry);\n }\n \n void LeaveCritical()"
      },
      {
        "sha": "a04ab2c948bdc96f20c611421c9dec791742a506",
        "filename": "src/util.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f342dac1cb06d5b0d264fa59e448ef6477ec5b6b/src/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f342dac1cb06d5b0d264fa59e448ef6477ec5b6b/src/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.h?ref=f342dac1cb06d5b0d264fa59e448ef6477ec5b6b",
        "patch": "@@ -190,10 +190,10 @@ typedef boost::interprocess::interprocess_recursive_mutex CCriticalSection;\n typedef boost::interprocess::interprocess_mutex CWaitableCriticalSection;\n \n #ifdef DEBUG_LOCKORDER\n-void EnterCritical(const char* pszName, const char* pszFile, int nLine, void* cs);\n+void EnterCritical(const char* pszName, const char* pszFile, int nLine, void* cs, bool fTry = false);\n void LeaveCritical();\n #else\n-void static inline EnterCritical(const char* pszName, const char* pszFile, int nLine, void* cs) {}\n+void static inline EnterCritical(const char* pszName, const char* pszFile, int nLine, void* cs, bool fTry = false) {}\n void static inline LeaveCritical() {}\n #endif\n \n@@ -234,7 +234,7 @@ class CMutexLock\n     {\n         if (!lock.owns())\n         {\n-            EnterCritical(pszName, pszFile, nLine, (void*)(lock.mutex()));\n+            EnterCritical(pszName, pszFile, nLine, (void*)(lock.mutex()), true);\n             lock.try_lock();\n             if (!lock.owns())\n                 LeaveCritical();"
      }
    ]
  }
]