[
  {
    "sha": "5d0629c1c19866b6defde573142d7fa23daea4bf",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1ZDA2MjljMWMxOTg2NmI2ZGVmZGU1NzMxNDJkN2ZhMjNkYWVhNGJm",
    "commit": {
      "author": {
        "name": "p2k",
        "email": "patrick.p2k.schneider@gmail.com",
        "date": "2012-01-19T20:45:49Z"
      },
      "committer": {
        "name": "p2k",
        "email": "patrick.p2k.schneider@gmail.com",
        "date": "2012-01-19T20:45:49Z"
      },
      "message": "miniupnpc Porfile removed; new and improved macdeployqtplus\n\n* My patch for miniupnpc has made it into the latest MacPorts release: https://trac.macports.org/ticket/31354\n* Documentation has been changed appropriately\n* New pure-Python macdeployqt; leverages all problems with the stock macdeployqt",
      "tree": {
        "sha": "5a3372a3e26f759809cdcf482404c7ad6e361abc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5a3372a3e26f759809cdcf482404c7ad6e361abc"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5d0629c1c19866b6defde573142d7fa23daea4bf",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5d0629c1c19866b6defde573142d7fa23daea4bf",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5d0629c1c19866b6defde573142d7fa23daea4bf",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5d0629c1c19866b6defde573142d7fa23daea4bf/comments",
    "author": {
      "login": "p2k",
      "id": 116037,
      "node_id": "MDQ6VXNlcjExNjAzNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/116037?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/p2k",
      "html_url": "https://github.com/p2k",
      "followers_url": "https://api.github.com/users/p2k/followers",
      "following_url": "https://api.github.com/users/p2k/following{/other_user}",
      "gists_url": "https://api.github.com/users/p2k/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/p2k/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/p2k/subscriptions",
      "organizations_url": "https://api.github.com/users/p2k/orgs",
      "repos_url": "https://api.github.com/users/p2k/repos",
      "events_url": "https://api.github.com/users/p2k/events{/privacy}",
      "received_events_url": "https://api.github.com/users/p2k/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "p2k",
      "id": 116037,
      "node_id": "MDQ6VXNlcjExNjAzNw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/116037?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/p2k",
      "html_url": "https://github.com/p2k",
      "followers_url": "https://api.github.com/users/p2k/followers",
      "following_url": "https://api.github.com/users/p2k/following{/other_user}",
      "gists_url": "https://api.github.com/users/p2k/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/p2k/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/p2k/subscriptions",
      "organizations_url": "https://api.github.com/users/p2k/orgs",
      "repos_url": "https://api.github.com/users/p2k/repos",
      "events_url": "https://api.github.com/users/p2k/events{/privacy}",
      "received_events_url": "https://api.github.com/users/p2k/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1240a1b0a82e0e944a6fdcf6ff26001e1bd68904",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1240a1b0a82e0e944a6fdcf6ff26001e1bd68904",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1240a1b0a82e0e944a6fdcf6ff26001e1bd68904"
      }
    ],
    "stats": {
      "total": 535,
      "additions": 441,
      "deletions": 94
    },
    "files": [
      {
        "sha": "914edb76f8081a38c6caa89f8a37f2a7f2718d70",
        "filename": "contrib/macdeploy/macdeployqtplus",
        "status": "modified",
        "additions": 433,
        "deletions": 31,
        "changes": 464,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5d0629c1c19866b6defde573142d7fa23daea4bf/contrib/macdeploy/macdeployqtplus",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5d0629c1c19866b6defde573142d7fa23daea4bf/contrib/macdeploy/macdeployqtplus",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/macdeploy/macdeployqtplus?ref=5d0629c1c19866b6defde573142d7fa23daea4bf",
        "patch": "@@ -21,12 +21,397 @@ import subprocess, sys, re, os, shutil, os.path\n from time import sleep\n from argparse import ArgumentParser\n \n+# This is ported from the original macdeployqt with modifications\n+\n+class FrameworkInfo(object):\n+    def __init__(self):\n+        self.frameworkDirectory = \"\"\n+        self.frameworkName = \"\"\n+        self.frameworkPath = \"\"\n+        self.binaryDirectory = \"\"\n+        self.binaryName = \"\"\n+        self.binaryPath = \"\"\n+        self.version = \"\"\n+        self.installName = \"\"\n+        self.deployedInstallName = \"\"\n+        self.sourceFilePath = \"\"\n+        self.destinationDirectory = \"\"\n+        self.sourceResourcesDirectory = \"\"\n+        self.destinationResourcesDirectory = \"\"\n+    \n+    def __eq__(self, other):\n+        if self.__class__ == other.__class__:\n+            return self.__dict__ == other.__dict__\n+        else:\n+            return False\n+    \n+    def __str__(self):\n+        return \"\"\" Framework name: %s\n+ Framework directory: %s\n+ Framework path: %s\n+ Binary name: %s\n+ Binary directory: %s\n+ Binary path: %s\n+ Version: %s\n+ Install name: %s\n+ Deployed install name: %s\n+ Source file Path: %s\n+ Deployed Directory (relative to bundle): %s\n+\"\"\" % (self.frameworkName,\n+       self.frameworkDirectory,\n+       self.frameworkPath,\n+       self.binaryName,\n+       self.binaryDirectory,\n+       self.binaryPath,\n+       self.version,\n+       self.installName,\n+       self.deployedInstallName,\n+       self.sourceFilePath,\n+       self.destinationDirectory)\n+    \n+    def isDylib(self):\n+        return self.frameworkName.endswith(\".dylib\")\n+    \n+    def isQtFramework(self):\n+        if self.isDylib():\n+            return self.frameworkName.startswith(\"libQt\")\n+        else:\n+            return self.frameworkName.startswith(\"Qt\")\n+    \n+    reOLine = re.compile(r'^(.+) \\(compatibility version [0-9.]+, current version [0-9.]+\\)$')\n+    bundleFrameworkDirectory = \"Contents/Frameworks\"\n+    bundleBinaryDirectory = \"Contents/MacOS\"\n+    \n+    @classmethod\n+    def fromOtoolLibraryLine(cls, line):\n+        # Note: line must be trimmed\n+        if line == \"\":\n+            return None\n+        \n+        # Don't deploy system libraries (exception for libQtuitools and libQtlucene).\n+        if line.startswith(\"/System/Library/\") or line.startswith(\"@executable_path\") or (line.startswith(\"/usr/lib/\") and \"libQt\" not in line):\n+            return None\n+        \n+        m = cls.reOLine.match(line)\n+        if m is None:\n+            raise RuntimeError(\"otool line could not be parsed: \" + line)\n+        \n+        path = m.group(1)\n+        \n+        info = cls()\n+        info.sourceFilePath = path\n+        info.installName = path\n+        \n+        if path.endswith(\".dylib\"):\n+            dirname, filename = os.path.split(path)\n+            info.frameworkName = filename\n+            info.frameworkDirectory = dirname\n+            info.frameworkPath = path\n+            \n+            info.binaryDirectory = dirname\n+            info.binaryName = filename\n+            info.binaryPath = path\n+            info.version = \"-\"\n+            \n+            info.installName = path\n+            info.deployedInstallName = \"@executable_path/../Frameworks/\" + info.binaryName\n+            info.sourceFilePath = path\n+            info.destinationDirectory = cls.bundleFrameworkDirectory\n+        else:\n+            parts = path.split(\"/\")\n+            i = 0\n+            # Search for the .framework directory\n+            for part in parts:\n+                if part.endswith(\".framework\"):\n+                    break\n+                i += 1\n+            if i == len(parts):\n+                raise RuntimeError(\"Could not find .framework or .dylib in otool line: \" + line)\n+            \n+            info.frameworkName = parts[i]\n+            info.frameworkDirectory = \"/\".join(parts[:i])\n+            info.frameworkPath = os.path.join(info.frameworkDirectory, info.frameworkName)\n+            \n+            info.binaryName = parts[i+3]\n+            info.binaryDirectory = \"/\".join(parts[i+1:i+3])\n+            info.binaryPath = os.path.join(info.binaryDirectory, info.binaryName)\n+            info.version = parts[i+2]\n+            \n+            info.deployedInstallName = \"@executable_path/../Frameworks/\" + os.path.join(info.frameworkName, info.binaryPath)\n+            info.destinationDirectory = os.path.join(cls.bundleFrameworkDirectory, info.frameworkName, info.binaryDirectory)\n+            \n+            info.sourceResourcesDirectory = os.path.join(info.frameworkPath, \"Resources\")\n+            info.destinationResourcesDirectory = os.path.join(cls.bundleFrameworkDirectory, info.frameworkName, \"Resources\")\n+        \n+        return info\n+\n+class ApplicationBundleInfo(object):\n+    def __init__(self, path):\n+        self.path = path\n+        appName = os.path.splitext(os.path.basename(path))[0]\n+        self.binaryPath = os.path.join(path, \"Contents\", \"MacOS\", appName)\n+        if not os.path.exists(self.binaryPath):\n+            raise RuntimeError(\"Could not find bundle binary for \" + path)\n+        self.resourcesPath = os.path.join(path, \"Contents\", \"Resources\")\n+        self.pluginPath = os.path.join(path, \"Contents\", \"PlugIns\")\n+\n+class DeploymentInfo(object):\n+    def __init__(self):\n+        self.qtPath = None\n+        self.pluginPath = None\n+        self.deployedFrameworks = []\n+    \n+    def detectQtPath(self, frameworkDirectory):\n+        parentDir = os.path.dirname(frameworkDirectory)\n+        if os.path.exists(os.path.join(parentDir, \"translations\")):\n+            # Classic layout, e.g. \"/usr/local/Trolltech/Qt-4.x.x\"\n+            self.qtPath = parentDir\n+        elif os.path.exists(os.path.join(parentDir, \"share\", \"qt4\", \"translations\")):\n+            # MacPorts layout, e.g. \"/opt/local/share/qt4\"\n+            self.qtPath = os.path.join(parentDir, \"share\", \"qt4\")\n+        \n+        if self.qtPath is not None:\n+            pluginPath = os.path.join(self.qtPath, \"plugins\")\n+            if os.path.exists(pluginPath):\n+                self.pluginPath = pluginPath\n+    \n+    def usesFramework(self, name):\n+        nameDot = \"%s.\" % name\n+        libNameDot = \"lib%s.\" % name\n+        for framework in self.deployedFrameworks:\n+            if framework.endswith(\".framework\"):\n+                if framework.startswith(nameDot):\n+                    return True\n+            elif framework.endswith(\".dylib\"):\n+                if framework.startswith(libNameDot):\n+                    return True\n+        return False\n+\n+def getFrameworks(binaryPath, verbose):\n+    if verbose >= 3:\n+        print \"Inspecting with otool: \" + binaryPath\n+    otool = subprocess.Popen([\"otool\", \"-L\", binaryPath], stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n+    o_stdout, o_stderr = otool.communicate()\n+    if otool.returncode != 0:\n+        if verbose >= 1:\n+            sys.stderr.write(o_stderr)\n+            sys.stderr.flush()\n+            raise RuntimeError(\"otool failed with return code %d\" % otool.returncode)\n+    \n+    otoolLines = o_stdout.split(\"\\n\")\n+    otoolLines.pop(0) # First line is the inspected binary\n+    if \".framework\" in binaryPath or binaryPath.endswith(\".dylib\"):\n+        otoolLines.pop(0) # Frameworks and dylibs list themselves as a dependency.\n+    \n+    libraries = []\n+    for line in otoolLines:\n+        info = FrameworkInfo.fromOtoolLibraryLine(line.strip())\n+        if info is not None:\n+            if verbose >= 3:\n+                print \"Found framework:\"\n+                print info\n+            libraries.append(info)\n+    \n+    return libraries\n+\n+def runInstallNameTool(action, *args):\n+    subprocess.check_call([\"install_name_tool\", \"-\"+action] + list(args))\n+\n+def changeInstallName(oldName, newName, binaryPath, verbose):\n+    if verbose >= 3:\n+        print \"Using install_name_tool:\"\n+        print \" in\", binaryPath\n+        print \" change reference\", oldName\n+        print \" to\", newName\n+    runInstallNameTool(\"change\", oldName, newName, binaryPath)\n+\n+def changeIdentification(id, binaryPath, verbose):\n+    if verbose >= 3:\n+        print \"Using install_name_tool:\"\n+        print \" change identification in\", binaryPath\n+        print \" to\", id\n+    runInstallNameTool(\"id\", id, binaryPath)\n+\n+def runStrip(binaryPath, verbose):\n+    if verbose >= 3:\n+        print \"Using strip:\"\n+        print \" stripped\", binaryPath\n+    subprocess.check_call([\"strip\", \"-x\", binaryPath])\n+\n+def copyFramework(framework, path, verbose):\n+    fromPath = framework.sourceFilePath\n+    toDir = os.path.join(path, framework.destinationDirectory)\n+    toPath = os.path.join(toDir, framework.binaryName)\n+    \n+    if not os.path.exists(fromPath):\n+        raise RuntimeError(\"No file at \" + fromPath)\n+    \n+    if os.path.exists(toPath):\n+        return None # Already there\n+    \n+    if not os.path.exists(toDir):\n+        os.makedirs(toDir)\n+    \n+    shutil.copy2(fromPath, toPath)\n+    if verbose >= 3:\n+        print \"Copied:\", fromPath\n+        print \" to:\", toPath\n+    \n+    if not framework.isDylib(): # Copy resources for real frameworks\n+        fromResourcesDir = framework.sourceResourcesDirectory\n+        if os.path.exists(fromResourcesDir):\n+            toResourcesDir = os.path.join(path, framework.destinationResourcesDirectory)\n+            shutil.copytree(fromResourcesDir, toResourcesDir)\n+            if verbose >= 3:\n+                print \"Copied resources:\", fromResourcesDir\n+                print \" to:\", toResourcesDir\n+    elif framework.frameworkName.startswith(\"libQtGui\"): # Copy qt_menu.nib (applies to non-framework layout)\n+        qtMenuNibSourcePath = os.path.join(framework.frameworkDirectory, \"Resources\", \"qt_menu.nib\")\n+        qtMenuNibDestinationPath = os.path.join(path, \"Contents\", \"Resources\", \"qt_menu.nib\")\n+        if os.path.exists(qtMenuNibSourcePath) and not os.path.exists(qtMenuNibDestinationPath):\n+            shutil.copytree(qtMenuNibSourcePath, qtMenuNibDestinationPath)\n+            if verbose >= 3:\n+                print \"Copied for libQtGui:\", qtMenuNibSourcePath\n+                print \" to:\", qtMenuNibDestinationPath\n+    \n+    return toPath\n+\n+def deployFrameworks(frameworks, bundlePath, binaryPath, strip, verbose, deploymentInfo=None):\n+    if deploymentInfo is None:\n+        deploymentInfo = DeploymentInfo()\n+    \n+    while len(frameworks) > 0:\n+        framework = frameworks.pop(0)\n+        deploymentInfo.deployedFrameworks.append(framework.frameworkName)\n+        \n+        if verbose >= 2:\n+            print \"Processing\", framework.frameworkName, \"...\"\n+        \n+        # Get the Qt path from one of the Qt frameworks\n+        if deploymentInfo.qtPath is None and framework.isQtFramework():\n+            deploymentInfo.detectQtPath(framework.frameworkDirectory)\n+        \n+        if framework.installName.startswith(\"@executable_path\"):\n+            if verbose >= 2:\n+                print framework.frameworkName, \"already deployed, skipping.\"\n+            continue\n+        \n+        # install_name_tool the new id into the binary\n+        changeInstallName(framework.installName, framework.deployedInstallName, binaryPath, verbose)\n+        \n+        # Copy farmework to app bundle.\n+        deployedBinaryPath = copyFramework(framework, bundlePath, verbose)\n+        # Skip the rest if already was deployed.\n+        if deployedBinaryPath is None:\n+            continue\n+        \n+        if strip:\n+            runStrip(deployedBinaryPath, verbose)\n+        \n+        # install_name_tool it a new id.\n+        changeIdentification(framework.deployedInstallName, deployedBinaryPath, verbose)\n+        # Check for framework dependencies\n+        dependencies = getFrameworks(deployedBinaryPath, verbose)\n+        \n+        for dependency in dependencies:\n+            changeInstallName(dependency.installName, dependency.deployedInstallName, deployedBinaryPath, verbose)\n+            \n+            # Deploy framework if necessary.\n+            if dependency.frameworkName not in deploymentInfo.deployedFrameworks and dependency not in frameworks:\n+                frameworks.append(dependency)\n+    \n+    return deploymentInfo\n+\n+def deployFrameworksForAppBundle(applicationBundle, strip, verbose):\n+    frameworks = getFrameworks(applicationBundle.binaryPath, verbose)\n+    if len(frameworks) == 0 and verbose >= 1:\n+        print \"Warning: Could not find any external frameworks to deploy in %s.\" % (applicationBundle.path)\n+        return DeploymentInfo()\n+    else:\n+        return deployFrameworks(frameworks, applicationBundle.path, applicationBundle.binaryPath, strip, verbose)\n+\n+def deployPlugins(appBundleInfo, deploymentInfo, strip, verbose):\n+    # Lookup available plugins, exclude unneeded\n+    plugins = []\n+    for dirpath, dirnames, filenames in os.walk(deploymentInfo.pluginPath):\n+        pluginDirectory = os.path.relpath(dirpath, deploymentInfo.pluginPath)\n+        if pluginDirectory == \"designer\":\n+            # Skip designer plugins\n+            continue\n+        elif pluginDirectory == \"phonon\":\n+            # Deploy the phonon plugins only if phonon is in use\n+            if not deploymentInfo.usesFramework(\"phonon\"):\n+                continue\n+        elif pluginDirectory == \"sqldrivers\":\n+            # Deploy the sql plugins only if QtSql is in use\n+            if not deploymentInfo.usesFramework(\"QtSql\"):\n+                continue\n+        elif pluginDirectory == \"script\":\n+            # Deploy the script plugins only if QtScript is in use\n+            if not deploymentInfo.usesFramework(\"QtScript\"):\n+                continue\n+        elif pluginDirectory == \"qmltooling\":\n+            # Deploy the qml plugins only if QtDeclarative is in use\n+            if not deploymentInfo.usesFramework(\"QtDeclarative\"):\n+                continue\n+        elif pluginDirectory == \"bearer\":\n+            # Deploy the bearer plugins only if QtNetwork is in use\n+            if not deploymentInfo.usesFramework(\"QtNetwork\"):\n+                continue\n+        \n+        for pluginName in filenames:\n+            pluginPath = os.path.join(pluginDirectory, pluginName)\n+            if pluginName.endswith(\"_debug.dylib\"):\n+                # Skip debug plugins\n+                continue\n+            elif pluginPath == \"imageformats/libqsvg.dylib\" or pluginPath == \"iconengines/libqsvgicon.dylib\":\n+                # Deploy the svg plugins only if QtSvg is in use\n+                if not deploymentInfo.usesFramework(\"QtSvg\"):\n+                    continue\n+            elif pluginPath == \"accessible/libqtaccessiblecompatwidgets.dylib\":\n+                # Deploy accessibility for Qt3Support only if the Qt3Support is in use\n+                if not deploymentInfo.usesFramework(\"Qt3Support\"):\n+                    continue\n+            elif pluginPath == \"graphicssystems/libqglgraphicssystem.dylib\":\n+                # Deploy the opengl graphicssystem plugin only if QtOpenGL is in use\n+                if not deploymentInfo.usesFramework(\"QtOpenGL\"):\n+                    continue\n+            \n+            plugins.append((pluginDirectory, pluginName))\n+    \n+    for pluginDirectory, pluginName in plugins:\n+        if verbose >= 2:\n+            print \"Processing plugin\", os.path.join(pluginDirectory, pluginName), \"...\"\n+        \n+        sourcePath = os.path.join(deploymentInfo.pluginPath, pluginDirectory, pluginName)\n+        destinationDirectory = os.path.join(appBundleInfo.pluginPath, pluginDirectory)\n+        if not os.path.exists(destinationDirectory):\n+            os.makedirs(destinationDirectory)\n+        \n+        destinationPath = os.path.join(destinationDirectory, pluginName)\n+        shutil.copy2(sourcePath, destinationPath)\n+        if verbose >= 3:\n+            print \"Copied:\", sourcePath\n+            print \" to:\", destinationPath\n+        \n+        if strip:\n+            runStrip(destinationPath, verbose)\n+        \n+        dependencies = getFrameworks(destinationPath, verbose)\n+        \n+        for dependency in dependencies:\n+            changeInstallName(dependency.installName, dependency.deployedInstallName, destinationPath, verbose)\n+            \n+            # Deploy framework if necessary.\n+            if dependency.frameworkName not in deploymentInfo.deployedFrameworks:\n+                deployFrameworks([dependency], appBundleInfo.path, destinationPath, strip, verbose, deploymentInfo)\n+\n qt_conf=\"\"\"[Paths]\n translations=Resources\n plugins=PlugIns\n \"\"\"\n \n-ap = ArgumentParser(description=\"\"\"Front-end to macdeployqt with some additional functions.\n+ap = ArgumentParser(description=\"\"\"Improved version of macdeployqt.\n \n Outputs a ready-to-deploy app in a folder \"dist\" and optionally wraps it in a .dmg file.\n Note, that the \"dist\" folder will be deleted before deploying on each run.\n@@ -69,22 +454,6 @@ for p in config.add_resources:\n \n # ------------------------------------------------\n \n-if len(config.add_qt_tr) == 0:\n-    add_qt_tr = []\n-else:\n-    qt_tr_dir = os.path.join(os.getenv(\"QTDIR\", \"\"), \"translations\")\n-    add_qt_tr = [\"qt_%s.qm\" % lng for lng in config.add_qt_tr[0].split(\",\")]\n-    for lng_file in add_qt_tr:\n-        p = os.path.join(qt_tr_dir, lng_file)\n-        if verbose >= 3:\n-            print \"Checking for \\\"%s\\\"...\" % p\n-        if not os.path.exists(p):\n-            if verbose >= 1:\n-                sys.stderr.write(\"Error: Could not find Qt translation file \\\"%s\\\"\\n\" % (lng_file))\n-                sys.exit(1)\n-\n-# ------------------------------------------------\n-\n if len(config.fancy) == 1:\n     if verbose >= 3:\n         print \"Fancy: Importing plistlib...\"\n@@ -160,7 +529,6 @@ if os.path.exists(\"dist\"):\n # ------------------------------------------------\n \n target = os.path.join(\"dist\", app_bundle)\n-target_res = os.path.join(target, \"Contents\", \"Resources\")\n \n if verbose >= 2:\n     print \"+ Copying source bundle +\"\n@@ -170,27 +538,61 @@ if verbose >= 3:\n os.mkdir(\"dist\")\n shutil.copytree(app_bundle, target)\n \n-# ------------------------------------------------\n+applicationBundle = ApplicationBundleInfo(target)\n \n-macdeployqt_args = [\"macdeployqt\", target, \"-verbose=%d\" % verbose]\n-if not config.plugins:\n-    macdeployqt_args.append(\"-no-plugins\")\n-if not config.strip:\n-    macdeployqt_args.append(\"-no-strip\")\n+# ------------------------------------------------\n \n if verbose >= 2:\n-    print \"+ Running macdeployqt +\"\n+    print \"+ Deploying frameworks +\"\n \n-ret = subprocess.call(macdeployqt_args)\n-if ret != 0:\n+try:\n+    deploymentInfo = deployFrameworksForAppBundle(applicationBundle, config.strip, verbose)\n+    if deploymentInfo.qtPath is None:\n+        deploymentInfo.qtPath = os.getenv(\"QTDIR\", None)\n+        if deploymentInfo.qtPath is None:\n+            if verbose >= 1:\n+                sys.stderr.write(\"Warning: Could not detect Qt's path, skipping plugin deployment!\\n\")\n+            config.plugins = False\n+except RuntimeError as e:\n+    if verbose >= 1:\n+        sys.stderr.write(\"Error: %s\\n\" % str(e))\n     sys.exit(ret)\n \n # ------------------------------------------------\n \n+if config.plugins:\n+    if verbose >= 2:\n+        print \"+ Deploying plugins +\"\n+    \n+    try:\n+        deployPlugins(applicationBundle, deploymentInfo, config.strip, verbose)\n+    except RuntimeError as e:\n+        if verbose >= 1:\n+            sys.stderr.write(\"Error: %s\\n\" % str(e))\n+        sys.exit(ret)\n+\n+# ------------------------------------------------\n+\n+if len(config.add_qt_tr) == 0:\n+    add_qt_tr = []\n+else:\n+    qt_tr_dir = os.path.join(deploymentInfo.qtPath, \"translations\")\n+    add_qt_tr = [\"qt_%s.qm\" % lng for lng in config.add_qt_tr[0].split(\",\")]\n+    for lng_file in add_qt_tr:\n+        p = os.path.join(qt_tr_dir, lng_file)\n+        if verbose >= 3:\n+            print \"Checking for \\\"%s\\\"...\" % p\n+        if not os.path.exists(p):\n+            if verbose >= 1:\n+                sys.stderr.write(\"Error: Could not find Qt translation file \\\"%s\\\"\\n\" % (lng_file))\n+                sys.exit(1)\n+\n+# ------------------------------------------------\n+\n if verbose >= 2:\n     print \"+ Installing qt.conf +\"\n \n-f = open(os.path.join(target_res, \"qt.conf\"), \"wb\")\n+f = open(os.path.join(applicationBundle.resourcesPath, \"qt.conf\"), \"wb\")\n f.write(qt_conf)\n f.close()\n \n@@ -201,16 +603,16 @@ if len(add_qt_tr) > 0 and verbose >= 2:\n \n for lng_file in add_qt_tr:\n     if verbose >= 3:\n-        print os.path.join(qt_tr_dir, lng_file), \"->\", os.path.join(target_res, lng_file)\n-    shutil.copy2(os.path.join(qt_tr_dir, lng_file), os.path.join(target_res, lng_file))\n+        print os.path.join(qt_tr_dir, lng_file), \"->\", os.path.join(applicationBundle.resourcesPath, lng_file)\n+    shutil.copy2(os.path.join(qt_tr_dir, lng_file), os.path.join(applicationBundle.resourcesPath, lng_file))\n \n # ------------------------------------------------\n \n if len(config.add_resources) > 0 and verbose >= 2:\n     print \"+ Adding additional resources +\"\n \n for p in config.add_resources:\n-    t = os.path.join(target_res, os.path.basename(p))\n+    t = os.path.join(applicationBundle.resourcesPath, os.path.basename(p))\n     if verbose >= 3:\n         print p, \"->\", t\n     if os.path.isdir(p):"
      },
      {
        "sha": "a3f0b5447dd47087dd9ab98edc36ab4c21caea06",
        "filename": "contrib/macdeploy/notes.txt",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5d0629c1c19866b6defde573142d7fa23daea4bf/contrib/macdeploy/notes.txt",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5d0629c1c19866b6defde573142d7fa23daea4bf/contrib/macdeploy/notes.txt",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/macdeploy/notes.txt?ref=5d0629c1c19866b6defde573142d7fa23daea4bf",
        "patch": "@@ -6,7 +6,7 @@ You will need the appscript package for the fancy disk image creation to work.\n Install it by invoking \"sudo easy_install appscript\".\n \n Ths script should be invoked in the target directory like this:\n-$source_dir/contrib/macdeploy/macdeployqtplus Bitcoin-Qt.app -add-qt-tr de,es,ru -dmg -fancy $source_dir/contrib/macdeploy/fancy.plist\n+$source_dir/contrib/macdeploy/macdeployqtplus Bitcoin-Qt.app -add-qt-tr da,de,es,hu,ru,uk,zh_CN,zh_TW -dmg -fancy $source_dir/contrib/macdeploy/fancy.plist -verbose 2\n \n During the process, the disk image window will pop up briefly where the fancy\n settings are applied. This is normal, please do not interfere.\n@@ -19,7 +19,7 @@ Fill in the following.\n Enable custom process step: [x]\n Command: %{sourceDir}/contrib/macdeploy/macdeployqtplus\n Working directory: %{buildDir}\n-Command arguments: Bitcoin-Qt.app -add-qt-tr de,ru -dmg -fancy %{sourceDir}/contrib/macdeploy/fancy.plist \n+Command arguments: Bitcoin-Qt.app -add-qt-tr da,de,es,hu,ru,uk,zh_CN,zh_TW -dmg -fancy %{sourceDir}/contrib/macdeploy/fancy.plist -verbose 2\n \n After that you can start the deployment process through the menu with\n Build -> Deploy Project \"bitcoin-qt\""
      },
      {
        "sha": "133aee532c07d774597ae283e6ab6daa9e4d47ec",
        "filename": "contrib/miniupnpc/Portfile",
        "status": "removed",
        "additions": 0,
        "deletions": 43,
        "changes": 43,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1240a1b0a82e0e944a6fdcf6ff26001e1bd68904/contrib/miniupnpc/Portfile",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1240a1b0a82e0e944a6fdcf6ff26001e1bd68904/contrib/miniupnpc/Portfile",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/miniupnpc/Portfile?ref=1240a1b0a82e0e944a6fdcf6ff26001e1bd68904",
        "patch": "@@ -1,43 +0,0 @@\n-# -*- coding: utf-8; mode: tcl; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- vim:fenc=utf-8:filetype=tcl:et:sw=4:ts=4:sts=4\n-# $Id$\n-\n-PortSystem          1.0\n-\n-name                miniupnpc\n-epoch               2\n-version             1.6\n-revision            2\n-categories          net\n-platforms           darwin\n-license             BSD\n-maintainers         singingwolfboy openmaintainer\n-description         Lightweight client for UPnP protocol\n-long_description    \\\n-    ${description}\n-    \n-homepage            http://miniupnp.free.fr/\n-master_sites        http://miniupnp.free.fr/files/download.php?file=${distname}${extract.suffix}&dummy=\n-checksums           md5     88055f2d4a061cfd4cfe25a9eae22f67 \\\n-                    sha1    ef8f2edb17f2e7c5b8dc67ee80a65c199d823e0a \\\n-                    rmd160  d86b75b331a3fb5525c71708548f311977c0598f\n-\n-use_configure       no\n-\n-variant universal {}\n-if {[variant_isset universal]} {\n-    set archflags ${configure.universal_cflags}\n-} else {\n-    set archflags ${configure.cc_archflags}\n-}\n-\n-build.args-append   CC=\"${configure.cc} ${archflags}\"\n-\n-post-patch {\n-    reinplace \"s|-Wl,-install_name,|-Wl,-install_name,${prefix}/lib/|\" ${worksrcpath}/Makefile\n-}\n-\n-destroot.destdir    PREFIX=${prefix} INSTALLPREFIX=${destroot}${prefix}\n-\n-livecheck.type      regex\n-livecheck.url       http://miniupnp.free.fr/files/\n-livecheck.regex     ${name}-(\\\\d+(\\\\.\\\\d{1,4})+)${extract.suffix}"
      },
      {
        "sha": "8d89745679a9adada603d78c439da8de8eebe546",
        "filename": "doc/build-osx.txt",
        "status": "modified",
        "additions": 1,
        "deletions": 6,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5d0629c1c19866b6defde573142d7fa23daea4bf/doc/build-osx.txt",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5d0629c1c19866b6defde573142d7fa23daea4bf/doc/build-osx.txt",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/build-osx.txt?ref=5d0629c1c19866b6defde573142d7fa23daea4bf",
        "patch": "@@ -36,12 +36,7 @@ git clone git@github.com:bitcoin/bitcoin.git bitcoin\n \n 3.  Install dependencies from MacPorts\n \n-sudo port install boost db48 openssl\n-\n-Install the right version of miniupnpc:\n-pushd bitcoin/contrib/minipupnpc; sudo port install; popd\n-(this will be unnecessary soon, you will just port install miniupnpc\n-along with the rest of the dependencies).\n+sudo port install boost db48 openssl miniupnpc\n \n Optionally install qrencode (and set USE_QRCODE=1):\n sudo port install qrencode"
      },
      {
        "sha": "8fce96bb07b791f3efc4498e5019b8d8ddab399d",
        "filename": "doc/readme-qt.rst",
        "status": "modified",
        "additions": 1,
        "deletions": 9,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5d0629c1c19866b6defde573142d7fa23daea4bf/doc/readme-qt.rst",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5d0629c1c19866b6defde573142d7fa23daea4bf/doc/readme-qt.rst",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/readme-qt.rst?ref=5d0629c1c19866b6defde573142d7fa23daea4bf",
        "patch": "@@ -92,7 +92,7 @@ Mac OS X\n ::\n \n \tsudo port selfupdate\n-\tsudo port install boost db48\n+\tsudo port install boost db48 miniupnpc\n \n - Open the .pro file in Qt Creator and build as normal (cmd-B)\n \n@@ -127,14 +127,6 @@ Set USE_UPNP to a different value to control this:\n | USE_UPNP=1 | build with UPnP support turned on by default at runtime.                 |\n +------------+--------------------------------------------------------------------------+\n \n-Mac OS X users: miniupnpc is currently outdated on MacPorts. An updated Portfile is provided in contrib/miniupnpc within this project.\n-You can execute the following commands in a terminal to install it:\n-\n-::\n-\n-\tcd <location of bitcoin-qt>/contrib/miniupnpc\n-\tsudo port install\n-\n Notification support for recent (k)ubuntu versions\n ---------------------------------------------------\n "
      },
      {
        "sha": "ff9e0569025154cb92b132b8312b6ca5656deb1a",
        "filename": "doc/release-process.txt",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5d0629c1c19866b6defde573142d7fa23daea4bf/doc/release-process.txt",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5d0629c1c19866b6defde573142d7fa23daea4bf/doc/release-process.txt",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-process.txt?ref=5d0629c1c19866b6defde573142d7fa23daea4bf",
        "patch": "@@ -65,14 +65,15 @@\n    rm -rf bitcoin-${VERSION}-win32\n \n * perform Mac build\n-  See this blog post for how Gavin set up his build environment and\n-  patched macdeployqt to build the OSX release:\n+  See this blog post for how Gavin set up his build environment to build the OSX\n+  release; note that a patched version of macdeployqt is not needed anymore, as\n+  the required functionality and fixes are implemented directly in macdeployqtplus:\n     http://gavintech.blogspot.com/2011/11/deploying-bitcoin-qt-on-osx.html\n   qmake USE_SSL=1 USE_UPNP=1 bitcoin-qt.pro\n   make\n   export QTDIR=/opt/local/share/qt4  # needed to find translations/qt_*.qm files\n   T=$(contrib/qt_translations.py $QTDIR/translations src/qt/locale)\n-  contrib/macdeploy/macdeployqtplus Bitcoin-Qt.app -add-qt-tr $T -dmg -fancy contrib/macdeploy/fancy.plist  \n+  contrib/macdeploy/macdeployqtplus Bitcoin-Qt.app -add-qt-tr $T -dmg -fancy contrib/macdeploy/fancy.plist\n \n  Build output expected:\n   Bitcoin-Qt.dmg"
      }
    ]
  }
]