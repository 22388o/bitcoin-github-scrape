[
  {
    "sha": "40fbdea9e82ddd24b0ac2ed50cd872dc0b2cd787",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0MGZiZGVhOWU4MmRkZDI0YjBhYzJlZDUwY2Q4NzJkYzBiMmNkNzg3",
    "commit": {
      "author": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2019-04-03T09:01:03Z"
      },
      "committer": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2019-04-03T09:37:09Z"
      },
      "message": "bitcoin-cli -yaml support",
      "tree": {
        "sha": "4cba52a0cbd069cdb27cf5e7b4a5c5c3d23b122f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4cba52a0cbd069cdb27cf5e7b4a5c5c3d23b122f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/40fbdea9e82ddd24b0ac2ed50cd872dc0b2cd787",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/40fbdea9e82ddd24b0ac2ed50cd872dc0b2cd787",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/40fbdea9e82ddd24b0ac2ed50cd872dc0b2cd787",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/40fbdea9e82ddd24b0ac2ed50cd872dc0b2cd787/comments",
    "author": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2c364fde423e74b4e03ebcff4582a9db7a6c4e4b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2c364fde423e74b4e03ebcff4582a9db7a6c4e4b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2c364fde423e74b4e03ebcff4582a9db7a6c4e4b"
      }
    ],
    "stats": {
      "total": 223,
      "additions": 219,
      "deletions": 4
    },
    "files": [
      {
        "sha": "902d4682ea2b234093e4016a21f1ef448661baea",
        "filename": "src/bitcoin-cli.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 4,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/40fbdea9e82ddd24b0ac2ed50cd872dc0b2cd787/src/bitcoin-cli.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/40fbdea9e82ddd24b0ac2ed50cd872dc0b2cd787/src/bitcoin-cli.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-cli.cpp?ref=40fbdea9e82ddd24b0ac2ed50cd872dc0b2cd787",
        "patch": "@@ -24,6 +24,7 @@\n #include <support/events.h>\n \n #include <univalue.h>\n+#include <univalue_write_yaml.h>\n \n const std::function<std::string(const char*)> G_TRANSLATION_FUN = nullptr;\n \n@@ -56,6 +57,7 @@ static void SetupCliArgs()\n     gArgs.AddArg(\"-rpcwallet=<walletname>\", \"Send RPC for non-default wallet on RPC server (needs to exactly match corresponding -wallet option passed to bitcoind). This changes the RPC endpoint used, e.g. http://127.0.0.1:8332/wallet/<walletname>\", false, OptionsCategory::OPTIONS);\n     gArgs.AddArg(\"-stdin\", \"Read extra arguments from standard input, one per line until EOF/Ctrl-D (recommended for sensitive information such as passphrases). When combined with -stdinrpcpass, the first line from standard input is used for the RPC password.\", false, OptionsCategory::OPTIONS);\n     gArgs.AddArg(\"-stdinrpcpass\", \"Read RPC password from standard input as a single line. When combined with -stdin, the first line from standard input is used for the RPC password.\", false, OptionsCategory::OPTIONS);\n+    gArgs.AddArg(\"-yaml\", \"Format output as YAML instead of JSON\", false, OptionsCategory::OPTIONS);\n }\n \n /** libevent event log callback */\n@@ -467,12 +469,17 @@ static int CommandLineRPC(int argc, char *argv[])\n                     }\n                 } else {\n                     // Result\n-                    if (result.isNull())\n+                    if (result.isNull()) {\n                         strPrint = \"\";\n-                    else if (result.isStr())\n+                    } else if (result.isStr()) {\n                         strPrint = result.get_str();\n-                    else\n-                        strPrint = result.write(2);\n+                    } else {\n+                        if (gArgs.GetBoolArg(\"-yaml\", false)) {\n+                            strPrint = univalue_yaml(result, 2);\n+                        } else {\n+                            strPrint = result.write(2);\n+                        }\n+                    }\n                 }\n                 // Connection succeeded, no need to retry.\n                 break;"
      },
      {
        "sha": "fe693a9f5594649049eba5b1dd1f4d9871ca14fc",
        "filename": "src/univalue_write_yaml.h",
        "status": "added",
        "additions": 208,
        "deletions": 0,
        "changes": 208,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/40fbdea9e82ddd24b0ac2ed50cd872dc0b2cd787/src/univalue_write_yaml.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/40fbdea9e82ddd24b0ac2ed50cd872dc0b2cd787/src/univalue_write_yaml.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/univalue_write_yaml.h?ref=40fbdea9e82ddd24b0ac2ed50cd872dc0b2cd787",
        "patch": "@@ -0,0 +1,208 @@\n+// Copyright 2014 BitPay Inc.\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <iomanip>\n+#include <sstream>\n+#include <stdio.h>\n+#include \"univalue.h\"\n+#include \"univalue/lib/univalue_escapes.h\"\n+\n+static std::string univalue_yaml(const UniValue& u, unsigned int prettyIndent = 0,\n+                                 unsigned int indentLevel = 0, unsigned int preIndent = 0);\n+\n+static std::string yaml_escape(const std::string& inS)\n+{\n+    std::string outS;\n+    outS.reserve(inS.size() * 2);\n+\n+    for (unsigned int i = 0; i < inS.size(); i++) {\n+        unsigned char ch = inS[i];\n+        const char *escStr = escapes[ch];\n+\n+        if (escStr)\n+            outS += escStr;\n+        else\n+            outS += ch;\n+    }\n+\n+    return outS;\n+}\n+\n+static void indentStr(unsigned int prettyIndent, unsigned int indentLevel, std::string& s, unsigned int preIndent = 0)\n+{\n+    assert(prettyIndent < 2000 && indentLevel < 2000 && preIndent <= prettyIndent * indentLevel);\n+    s.append(prettyIndent * indentLevel - preIndent, ' ');\n+}\n+\n+std::string yaml_key(std::string k)\n+{\n+    if (k == \"\" || k[0] == '_' || k.find_first_of(\"0123456789_\") == 0 || k.find_first_not_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_0123456789\") != std::string::npos) {\n+        return \"\\\"\" + yaml_escape(k) + \"\\\":\";\n+    } else {\n+        return k + \":\";\n+    }\n+}\n+\n+static std::string num_to_yaml(const std::string &num)\n+{\n+    std::string res;\n+    size_t p = num.find(\".\");\n+    if (p == std::string::npos) p = num.size();\n+    if (p > 0) {\n+        size_t i = (p + 2) % 3 + 1;\n+        res = num.substr(0, i);\n+        for (; i < p; i+=3) {\n+            res += \"_\" + num.substr(i,3);\n+        }\n+    } else {\n+        res = \"0\";\n+    }\n+    if (p < num.size()) {\n+        res += \".\";\n+        p += 1;\n+        while (p + 3 < num.size()) {\n+            res += num.substr(p,3) + \"_\";\n+            p += 3;\n+        }\n+        res += num.substr(p);\n+    }\n+    return res;\n+}\n+\n+static unsigned int numalign(const std::string& num) {\n+    const std::string v = num_to_yaml(num);\n+    auto i = std::min(v.size(), v.find(\".\"));\n+    assert(i < 1000);\n+    assert(i >= 0);\n+    return i;\n+}\n+\n+void writeArray(const UniValue& u, unsigned int prettyIndent, unsigned int indentLevel, unsigned int preIndent, std::string& s)\n+{\n+    assert(preIndent == 0 || preIndent + 2 <= prettyIndent * indentLevel);\n+\n+    const auto& values = u.getValues();\n+\n+    if (values.size() == 0) {\n+        s += \"[]\";\n+        return;\n+    }\n+\n+    std::string indentSpaces = \"\";\n+    if (!prettyIndent) s += \"[\";\n+    const std::string indentDash = \"- \";\n+    const unsigned int indentBump = (prettyIndent == 1 ? 2 : 1);\n+    const unsigned int indentWithDash = prettyIndent * indentLevel + 2;\n+\n+    for (unsigned int i = 0; i < values.size(); i++) {\n+        if (prettyIndent) {\n+            indentStr(prettyIndent, indentLevel, s, preIndent);\n+            s += indentDash;\n+            preIndent = 0;\n+        }\n+        s += univalue_yaml(values[i], prettyIndent, indentLevel + indentBump, indentWithDash);\n+\n+        if (i != (values.size() - 1)) {\n+            if (!prettyIndent) s += \",\";\n+            if (prettyIndent) s += \"\\n\";\n+        }\n+    }\n+    if (!prettyIndent) s += \"]\";\n+}\n+\n+void writeObject(const UniValue& u, unsigned int prettyIndent, unsigned int indentLevel, unsigned int preIndent, std::string& s)\n+{\n+    assert(preIndent <= prettyIndent * indentLevel);\n+\n+    const auto& keys = u.getKeys();\n+    const auto& values = u.getValues();\n+\n+    unsigned long alignNums = 0;\n+\n+    if (keys.size() == 0) {\n+        s += \"{}\";\n+        return;\n+    }\n+\n+    if (!prettyIndent) s += \"{\";\n+    if (prettyIndent && !s.empty() && s.back() != '\\n') s += '\\n';\n+    for (unsigned int i = 0; i < keys.size(); ++i) {\n+        if (prettyIndent) {\n+            indentStr(prettyIndent, indentLevel, s, preIndent);\n+            preIndent = 0;\n+        }\n+        const std::string key = yaml_key(keys[i]);\n+        s += key;\n+        switch (values[i].getType()) {\n+        case UniValue::VOBJ:\n+        case UniValue::VARR:\n+            if (prettyIndent && values[i].getValues().size() > 0) {\n+                s+=\"\\n\";\n+                break;\n+            }\n+        case UniValue::VNULL:\n+        case UniValue::VSTR:\n+        case UniValue::VNUM:\n+        case UniValue::VBOOL:\n+            if (prettyIndent) s += \" \";\n+        }\n+        if (prettyIndent && !alignNums) {\n+            unsigned int j = i;\n+            while (j < values.size() && values[j].getType() == UniValue::VNUM) {\n+                alignNums = std::max(alignNums, yaml_key(keys[j]).size() + numalign(values[j].getValStr()));\n+                ++j;\n+            }\n+        }\n+        if (prettyIndent && alignNums) {\n+            if (values[i].getType() != UniValue::VNUM) {\n+                alignNums = 0;\n+            } else {\n+                auto amt = key.size() + numalign(values[i].getValStr());\n+                assert(amt <= alignNums);\n+                s.append(alignNums - amt, ' ');\n+            }\n+        }\n+        s += univalue_yaml(values[i], prettyIndent, indentLevel + 1);\n+        if (i < keys.size() - 1) {\n+            if (!prettyIndent) s += \",\";\n+            if (prettyIndent) s += \"\\n\";\n+        }\n+    }\n+    if (!prettyIndent) s += \"}\";\n+    if (prettyIndent && keys.size() > 10 && s[s.length()-1] != '\\n') s += \"\\n\";\n+}\n+\n+static std::string univalue_yaml(const UniValue& u, unsigned int prettyIndent,\n+                            unsigned int indentLevel, unsigned int preIndent)\n+{\n+    std::string s;\n+    const std::string& val = u.getValStr();\n+    s.reserve(1024);\n+\n+    unsigned int modIndent = indentLevel;\n+\n+    switch (u.getType()) {\n+    case UniValue::VNULL:\n+        s += \"null\";\n+        break;\n+    case UniValue::VOBJ:\n+        writeObject(u, prettyIndent, modIndent, preIndent, s);\n+        break;\n+    case UniValue::VARR:\n+        writeArray(u, prettyIndent, modIndent, preIndent, s);\n+        break;\n+    case UniValue::VSTR:\n+        s += \"\\\"\" + yaml_escape(val) + \"\\\"\";\n+        break;\n+    case UniValue::VNUM:\n+        s += num_to_yaml(val);\n+        break;\n+    case UniValue::VBOOL:\n+        s += (val == \"1\" ? \"true\" : \"false\");\n+        break;\n+    }\n+\n+    return s;\n+}\n+"
      }
    ]
  }
]