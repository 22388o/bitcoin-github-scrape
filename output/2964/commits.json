[
  {
    "sha": "ad3f97004e71a474f47c5fb78f12efb76f06060c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphZDNmOTcwMDRlNzFhNDc0ZjQ3YzVmYjc4ZjEyZWZiNzZmMDYwNjBj",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2013-07-20T12:34:16Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2013-09-28T14:05:00Z"
      },
      "message": "Allow SendMessages to run partially without cs_main\n\nSendMessages() tries to acquire a cs_main lock now, but this isn't nessecary\nfor much of its functionality. Move those parts out of the locked section,\nso they can always be performed, and we hold cs_main for a shorter time.",
      "tree": {
        "sha": "076ee5d4a2203027c39ead7560db56c077e9de16",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/076ee5d4a2203027c39ead7560db56c077e9de16"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ad3f97004e71a474f47c5fb78f12efb76f06060c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ad3f97004e71a474f47c5fb78f12efb76f06060c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ad3f97004e71a474f47c5fb78f12efb76f06060c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ad3f97004e71a474f47c5fb78f12efb76f06060c/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b41fa66ba7eaf3e56ce43bfb28114f59a7ea58ac",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b41fa66ba7eaf3e56ce43bfb28114f59a7ea58ac",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b41fa66ba7eaf3e56ce43bfb28114f59a7ea58ac"
      }
    ],
    "stats": {
      "total": 262,
      "additions": 131,
      "deletions": 131
    },
    "files": [
      {
        "sha": "fef1774640e1820e51109d3bc684e30434267bc1",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 131,
        "deletions": 131,
        "changes": 262,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ad3f97004e71a474f47c5fb78f12efb76f06060c/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ad3f97004e71a474f47c5fb78f12efb76f06060c/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=ad3f97004e71a474f47c5fb78f12efb76f06060c",
        "patch": "@@ -4076,170 +4076,170 @@ bool ProcessMessages(CNode* pfrom)\n \n bool SendMessages(CNode* pto, bool fSendTrickle)\n {\n-    TRY_LOCK(cs_main, lockMain);\n-    if (lockMain) {\n-        // Don't send anything until we get their version message\n-        if (pto->nVersion == 0)\n-            return true;\n-\n-        // Keep-alive ping. We send a nonce of zero because we don't use it anywhere\n-        // right now.\n-        if (pto->nLastSend && GetTime() - pto->nLastSend > 30 * 60 && pto->vSendMsg.empty()) {\n-            uint64 nonce = 0;\n-            if (pto->nVersion > BIP0031_VERSION)\n-                pto->PushMessage(\"ping\", nonce);\n-            else\n-                pto->PushMessage(\"ping\");\n-        }\n-\n-        // Start block sync\n-        if (pto->fStartSync && !fImporting && !fReindex) {\n-            pto->fStartSync = false;\n-            PushGetBlocks(pto, pindexBest, uint256(0));\n-        }\n+    // Don't send anything until we get their version message\n+    if (pto->nVersion == 0)\n+        return true;\n \n-        // Resend wallet transactions that haven't gotten in a block yet\n-        // Except during reindex, importing and IBD, when old wallet\n-        // transactions become unconfirmed and spams other nodes.\n-        if (!fReindex && !fImporting && !IsInitialBlockDownload())\n-        {\n-            ResendWalletTransactions();\n-        }\n+    // Keep-alive ping. We send a nonce of zero because we don't use it anywhere\n+    // right now.\n+    if (pto->nLastSend && GetTime() - pto->nLastSend > 30 * 60 && pto->vSendMsg.empty()) {\n+        uint64 nonce = 0;\n+        if (pto->nVersion > BIP0031_VERSION)\n+            pto->PushMessage(\"ping\", nonce);\n+        else\n+            pto->PushMessage(\"ping\");\n+    }\n \n-        // Address refresh broadcast\n-        static int64 nLastRebroadcast;\n-        if (!IsInitialBlockDownload() && (GetTime() - nLastRebroadcast > 24 * 60 * 60))\n+    // Address refresh broadcast\n+    static int64 nLastRebroadcast;\n+    if (!IsInitialBlockDownload() && (GetTime() - nLastRebroadcast > 24 * 60 * 60))\n+    {\n         {\n+            LOCK(cs_vNodes);\n+            BOOST_FOREACH(CNode* pnode, vNodes)\n             {\n-                LOCK(cs_vNodes);\n-                BOOST_FOREACH(CNode* pnode, vNodes)\n-                {\n-                    // Periodically clear setAddrKnown to allow refresh broadcasts\n-                    if (nLastRebroadcast)\n-                        pnode->setAddrKnown.clear();\n+                // Periodically clear setAddrKnown to allow refresh broadcasts\n+                if (nLastRebroadcast)\n+                    pnode->setAddrKnown.clear();\n \n-                    // Rebroadcast our address\n-                    if (!fNoListen)\n-                    {\n-                        CAddress addr = GetLocalAddress(&pnode->addr);\n-                        if (addr.IsRoutable())\n-                            pnode->PushAddress(addr);\n-                    }\n+                // Rebroadcast our address\n+                if (!fNoListen)\n+                {\n+                    CAddress addr = GetLocalAddress(&pnode->addr);\n+                    if (addr.IsRoutable())\n+                        pnode->PushAddress(addr);\n                 }\n             }\n-            nLastRebroadcast = GetTime();\n         }\n+        nLastRebroadcast = GetTime();\n+    }\n \n-        //\n-        // Message: addr\n-        //\n-        if (fSendTrickle)\n+    //\n+    // Message: addr\n+    //\n+    if (fSendTrickle)\n+    {\n+        vector<CAddress> vAddr;\n+        vAddr.reserve(pto->vAddrToSend.size());\n+        BOOST_FOREACH(const CAddress& addr, pto->vAddrToSend)\n         {\n-            vector<CAddress> vAddr;\n-            vAddr.reserve(pto->vAddrToSend.size());\n-            BOOST_FOREACH(const CAddress& addr, pto->vAddrToSend)\n+            // returns true if wasn't already contained in the set\n+            if (pto->setAddrKnown.insert(addr).second)\n             {\n-                // returns true if wasn't already contained in the set\n-                if (pto->setAddrKnown.insert(addr).second)\n+                vAddr.push_back(addr);\n+                // receiver rejects addr messages larger than 1000\n+                if (vAddr.size() >= 1000)\n                 {\n-                    vAddr.push_back(addr);\n-                    // receiver rejects addr messages larger than 1000\n-                    if (vAddr.size() >= 1000)\n-                    {\n-                        pto->PushMessage(\"addr\", vAddr);\n-                        vAddr.clear();\n-                    }\n+                    pto->PushMessage(\"addr\", vAddr);\n+                    vAddr.clear();\n                 }\n             }\n-            pto->vAddrToSend.clear();\n-            if (!vAddr.empty())\n-                pto->PushMessage(\"addr\", vAddr);\n         }\n+        pto->vAddrToSend.clear();\n+        if (!vAddr.empty())\n+            pto->PushMessage(\"addr\", vAddr);\n+    }\n \n+    TRY_LOCK(cs_main, lockMain);\n \n-        //\n-        // Message: inventory\n-        //\n-        vector<CInv> vInv;\n-        vector<CInv> vInvWait;\n-        {\n-            LOCK(pto->cs_inventory);\n-            vInv.reserve(pto->vInventoryToSend.size());\n-            vInvWait.reserve(pto->vInventoryToSend.size());\n-            BOOST_FOREACH(const CInv& inv, pto->vInventoryToSend)\n-            {\n-                if (pto->setInventoryKnown.count(inv))\n-                    continue;\n+    if (!lockMain)\n+        return true;\n \n-                // trickle out tx inv to protect privacy\n-                if (inv.type == MSG_TX && !fSendTrickle)\n-                {\n-                    // 1/4 of tx invs blast to all immediately\n-                    static uint256 hashSalt;\n-                    if (hashSalt == 0)\n-                        hashSalt = GetRandHash();\n-                    uint256 hashRand = inv.hash ^ hashSalt;\n-                    hashRand = Hash(BEGIN(hashRand), END(hashRand));\n-                    bool fTrickleWait = ((hashRand & 3) != 0);\n+    // Start block sync\n+    if (pto->fStartSync && !fImporting && !fReindex) {\n+        pto->fStartSync = false;\n+        PushGetBlocks(pto, pindexBest, uint256(0));\n+    }\n \n-                    // always trickle our own transactions\n-                    if (!fTrickleWait)\n-                    {\n-                        CWalletTx wtx;\n-                        if (GetTransaction(inv.hash, wtx))\n-                            if (wtx.fFromMe)\n-                                fTrickleWait = true;\n-                    }\n+    // Resend wallet transactions that haven't gotten in a block yet\n+    // Except during reindex, importing and IBD, when old wallet\n+    // transactions become unconfirmed and spams other nodes.\n+    if (!fReindex && !fImporting && !IsInitialBlockDownload())\n+    {\n+        ResendWalletTransactions();\n+    }\n \n-                    if (fTrickleWait)\n-                    {\n-                        vInvWait.push_back(inv);\n-                        continue;\n-                    }\n+    //\n+    // Message: inventory\n+    //\n+    vector<CInv> vInv;\n+    vector<CInv> vInvWait;\n+    {\n+        LOCK(pto->cs_inventory);\n+        vInv.reserve(pto->vInventoryToSend.size());\n+        vInvWait.reserve(pto->vInventoryToSend.size());\n+        BOOST_FOREACH(const CInv& inv, pto->vInventoryToSend)\n+        {\n+            if (pto->setInventoryKnown.count(inv))\n+                continue;\n+\n+            // trickle out tx inv to protect privacy\n+            if (inv.type == MSG_TX && !fSendTrickle)\n+            {\n+                // 1/4 of tx invs blast to all immediately\n+                static uint256 hashSalt;\n+                if (hashSalt == 0)\n+                    hashSalt = GetRandHash();\n+                uint256 hashRand = inv.hash ^ hashSalt;\n+                hashRand = Hash(BEGIN(hashRand), END(hashRand));\n+                bool fTrickleWait = ((hashRand & 3) != 0);\n+\n+                // always trickle our own transactions\n+                if (!fTrickleWait)\n+                {\n+                    CWalletTx wtx;\n+                    if (GetTransaction(inv.hash, wtx))\n+                        if (wtx.fFromMe)\n+                            fTrickleWait = true;\n                 }\n \n-                // returns true if wasn't already contained in the set\n-                if (pto->setInventoryKnown.insert(inv).second)\n+                if (fTrickleWait)\n                 {\n-                    vInv.push_back(inv);\n-                    if (vInv.size() >= 1000)\n-                    {\n-                        pto->PushMessage(\"inv\", vInv);\n-                        vInv.clear();\n-                    }\n+                    vInvWait.push_back(inv);\n+                    continue;\n                 }\n             }\n-            pto->vInventoryToSend = vInvWait;\n-        }\n-        if (!vInv.empty())\n-            pto->PushMessage(\"inv\", vInv);\n \n-\n-        //\n-        // Message: getdata\n-        //\n-        vector<CInv> vGetData;\n-        int64 nNow = GetTime() * 1000000;\n-        while (!pto->mapAskFor.empty() && (*pto->mapAskFor.begin()).first <= nNow)\n-        {\n-            const CInv& inv = (*pto->mapAskFor.begin()).second;\n-            if (!AlreadyHave(inv))\n+            // returns true if wasn't already contained in the set\n+            if (pto->setInventoryKnown.insert(inv).second)\n             {\n-                if (fDebugNet)\n-                    LogPrint(\"net\", \"sending getdata: %s\\n\", inv.ToString().c_str());\n-                vGetData.push_back(inv);\n-                if (vGetData.size() >= 1000)\n+                vInv.push_back(inv);\n+                if (vInv.size() >= 1000)\n                 {\n-                    pto->PushMessage(\"getdata\", vGetData);\n-                    vGetData.clear();\n+                    pto->PushMessage(\"inv\", vInv);\n+                    vInv.clear();\n                 }\n             }\n-            pto->mapAskFor.erase(pto->mapAskFor.begin());\n         }\n-        if (!vGetData.empty())\n-            pto->PushMessage(\"getdata\", vGetData);\n+        pto->vInventoryToSend = vInvWait;\n+    }\n+    if (!vInv.empty())\n+        pto->PushMessage(\"inv\", vInv);\n \n+    //\n+    // Message: getdata\n+    //\n+    vector<CInv> vGetData;\n+    int64 nNow = GetTime() * 1000000;\n+    while (!pto->mapAskFor.empty() && (*pto->mapAskFor.begin()).first <= nNow)\n+    {\n+        const CInv& inv = (*pto->mapAskFor.begin()).second;\n+        if (!AlreadyHave(inv))\n+        {\n+            if (fDebugNet)\n+                LogPrint(\"net\", \"sending getdata: %s\\n\", inv.ToString().c_str());\n+            vGetData.push_back(inv);\n+            if (vGetData.size() >= 1000)\n+            {\n+                pto->PushMessage(\"getdata\", vGetData);\n+                vGetData.clear();\n+            }\n+        }\n+        pto->mapAskFor.erase(pto->mapAskFor.begin());\n     }\n+    if (!vGetData.empty())\n+        pto->PushMessage(\"getdata\", vGetData);\n+\n     return true;\n }\n "
      }
    ]
  },
  {
    "sha": "6b6f08978040b2279eb69c57a764642cb0c86d83",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2YjZmMDg5NzgwNDBiMjI3OWViNjljNTdhNzY0NjQyY2IwYzg2ZDgz",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2013-07-25T00:25:25Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2013-09-28T14:05:00Z"
      },
      "message": "Run node deletions outside of cs_vNodes",
      "tree": {
        "sha": "824a70bf9d4bb4e418d01d43c496b6321ca3b625",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/824a70bf9d4bb4e418d01d43c496b6321ca3b625"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6b6f08978040b2279eb69c57a764642cb0c86d83",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6b6f08978040b2279eb69c57a764642cb0c86d83",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6b6f08978040b2279eb69c57a764642cb0c86d83",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6b6f08978040b2279eb69c57a764642cb0c86d83/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ad3f97004e71a474f47c5fb78f12efb76f06060c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ad3f97004e71a474f47c5fb78f12efb76f06060c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ad3f97004e71a474f47c5fb78f12efb76f06060c"
      }
    ],
    "stats": {
      "total": 3,
      "additions": 2,
      "deletions": 1
    },
    "files": [
      {
        "sha": "f502f9607df4717a85ac853316a3350ca046ce43",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6b6f08978040b2279eb69c57a764642cb0c86d83/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6b6f08978040b2279eb69c57a764642cb0c86d83/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=6b6f08978040b2279eb69c57a764642cb0c86d83",
        "patch": "@@ -781,7 +781,8 @@ void ThreadSocketHandler()\n                     vNodesDisconnected.push_back(pnode);\n                 }\n             }\n-\n+        }\n+        {\n             // Delete disconnected nodes\n             list<CNode*> vNodesDisconnectedCopy = vNodesDisconnected;\n             BOOST_FOREACH(CNode* pnode, vNodesDisconnectedCopy)"
      }
    ]
  },
  {
    "sha": "7826f7e5b57ced0de5615b9be0af7e3d1b201148",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3ODI2ZjdlNWI1N2NlZDBkZTU2MTViOWJlMGFmN2UzZDFiMjAxMTQ4",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2013-07-25T00:34:42Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2013-09-28T14:05:01Z"
      },
      "message": "Push down cs_main locking in ProcessMessage",
      "tree": {
        "sha": "ab0ca7e6e25d387bb53ba13d6c57e4dda59a49a2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ab0ca7e6e25d387bb53ba13d6c57e4dda59a49a2"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7826f7e5b57ced0de5615b9be0af7e3d1b201148",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7826f7e5b57ced0de5615b9be0af7e3d1b201148",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7826f7e5b57ced0de5615b9be0af7e3d1b201148",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7826f7e5b57ced0de5615b9be0af7e3d1b201148/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6b6f08978040b2279eb69c57a764642cb0c86d83",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6b6f08978040b2279eb69c57a764642cb0c86d83",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6b6f08978040b2279eb69c57a764642cb0c86d83"
      }
    ],
    "stats": {
      "total": 20,
      "additions": 16,
      "deletions": 4
    },
    "files": [
      {
        "sha": "fdc918bc1f85cf92d236385035e3502f4975c8fe",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 4,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7826f7e5b57ced0de5615b9be0af7e3d1b201148/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7826f7e5b57ced0de5615b9be0af7e3d1b201148/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=7826f7e5b57ced0de5615b9be0af7e3d1b201148",
        "patch": "@@ -3279,6 +3279,8 @@ void static ProcessGetData(CNode* pfrom)\n \n     vector<CInv> vNotFound;\n \n+    LOCK(cs_main);\n+\n     while (it != pfrom->vRecvGetData.end()) {\n         // Don't bother if send buffer is too full to respond anyway\n         if (pfrom->nSendSize >= SendBufferSize())\n@@ -3596,6 +3598,9 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n                 break;\n             }\n         }\n+\n+        LOCK(cs_main);\n+\n         for (unsigned int nInv = 0; nInv < vInv.size(); nInv++)\n         {\n             const CInv &inv = vInv[nInv];\n@@ -3653,6 +3658,8 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n         uint256 hashStop;\n         vRecv >> locator >> hashStop;\n \n+        LOCK(cs_main);\n+\n         // Find the last block the caller has in the main chain\n         CBlockIndex* pindex = locator.GetBlockIndex();\n \n@@ -3687,6 +3694,8 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n         uint256 hashStop;\n         vRecv >> locator >> hashStop;\n \n+        LOCK(cs_main);\n+\n         CBlockIndex* pindex = NULL;\n         if (locator.IsNull())\n         {\n@@ -3729,6 +3738,8 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n         CInv inv(MSG_TX, tx.GetHash());\n         pfrom->AddInventoryKnown(inv);\n \n+        LOCK(cs_main);\n+\n         bool fMissingInputs = false;\n         CValidationState state;\n         if (mempool.accept(state, tx, true, &fMissingInputs))\n@@ -3802,6 +3813,8 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n         CInv inv(MSG_BLOCK, block.GetHash());\n         pfrom->AddInventoryKnown(inv);\n \n+        LOCK(cs_main);\n+\n         CValidationState state;\n         if (ProcessBlock(state, pfrom, &block))\n             mapAlreadyAskedFor.erase(inv);\n@@ -3822,6 +3835,8 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n \n     else if (strCommand == \"mempool\")\n     {\n+        LOCK(cs_main);\n+\n         std::vector<uint256> vtxid;\n         LOCK2(mempool.cs, pfrom->cs_filter);\n         mempool.queryHashes(vtxid);\n@@ -4030,10 +4045,7 @@ bool ProcessMessages(CNode* pfrom)\n         bool fRet = false;\n         try\n         {\n-            {\n-                LOCK(cs_main);\n-                fRet = ProcessMessage(pfrom, strCommand, vRecv);\n-            }\n+            fRet = ProcessMessage(pfrom, strCommand, vRecv);\n             boost::this_thread::interruption_point();\n         }\n         catch (std::ios_base::failure& e)"
      }
    ]
  },
  {
    "sha": "1646093619905b4b894d33492585f0fc9c4f2b07",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxNjQ2MDkzNjE5OTA1YjRiODk0ZDMzNDkyNTg1ZjBmYzljNGYyYjA3",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2013-07-20T11:12:43Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2013-09-28T14:05:01Z"
      },
      "message": "Improve handling of obscure reorganizations\n\nThis fixes some weird reorganization issues that probably don't normally\noccur, but can be triggered when blacklisting arbitrary blocks is enabled.",
      "tree": {
        "sha": "45782dd84ccb46658954d2a5d1174864843eee16",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/45782dd84ccb46658954d2a5d1174864843eee16"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1646093619905b4b894d33492585f0fc9c4f2b07",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1646093619905b4b894d33492585f0fc9c4f2b07",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1646093619905b4b894d33492585f0fc9c4f2b07",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1646093619905b4b894d33492585f0fc9c4f2b07/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7826f7e5b57ced0de5615b9be0af7e3d1b201148",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7826f7e5b57ced0de5615b9be0af7e3d1b201148",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7826f7e5b57ced0de5615b9be0af7e3d1b201148"
      }
    ],
    "stats": {
      "total": 21,
      "additions": 18,
      "deletions": 3
    },
    "files": [
      {
        "sha": "0d84831052cd08445ddc2558bb497fe0a64ef23f",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 3,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1646093619905b4b894d33492585f0fc9c4f2b07/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1646093619905b4b894d33492585f0fc9c4f2b07/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=1646093619905b4b894d33492585f0fc9c4f2b07",
        "patch": "@@ -1516,12 +1516,21 @@ void static InvalidChainFound(CBlockIndex* pindexNew)\n     CheckForkWarningConditions();\n }\n \n-void static InvalidBlockFound(CBlockIndex *pindex) {\n+void InvalidBlockFound(CBlockIndex *pindex) {\n     pindex->nStatus |= BLOCK_FAILED_VALID;\n     pblocktree->WriteBlockIndex(CDiskBlockIndex(pindex));\n     setBlockIndexValid.erase(pindex);\n     InvalidChainFound(pindex);\n+    CBlockIndex *pindexWalk = pindex;\n+    do {\n+        CBlockIndex *pindexNext = pindexWalk->GetNextInMainChain();\n+        if (!pindexNext) break;\n+        pindexWalk = pindexNext;\n+        pindexWalk->nStatus |= BLOCK_FAILED_CHILD;\n+        printf(\"Marked %s as descending from invalid\\n\", pindexWalk->GetBlockHash().ToString().c_str());\n+    } while(true);\n     if (pindex->GetNextInMainChain()) {\n+        setBlockIndexValid.insert(pindex->pprev);\n         CValidationState stateDummy;\n         ConnectBestBlock(stateDummy); // reorganise away from the failed block\n     }\n@@ -1533,12 +1542,16 @@ bool ConnectBestBlock(CValidationState &state) {\n \n         {\n             std::set<CBlockIndex*,CBlockIndexWorkComparator>::reverse_iterator it = setBlockIndexValid.rbegin();\n+            while (it != setBlockIndexValid.rend() && (*it)->nStatus & BLOCK_FAILED_MASK) {\n+                printf(\"Not considering failed %s (%i)\\n\", (*it)->GetBlockHash().ToString().c_str(), (*it)->nHeight);\n+                it++;\n+            }\n             if (it == setBlockIndexValid.rend())\n                 return true;\n             pindexNewBest = *it;\n         }\n \n-        if (pindexNewBest == pindexBest || (pindexBest && pindexNewBest->nChainWork == pindexBest->nChainWork))\n+        if ((pindexNewBest == pindexBest || (pindexBest && pindexNewBest->nChainWork == pindexBest->nChainWork)) && !(pindexBest->nStatus & BLOCK_FAILED_MASK))\n             return true; // nothing to do\n \n         // check ancestry\n@@ -1558,7 +1571,7 @@ bool ConnectBestBlock(CValidationState &state) {\n                 break;\n             }\n \n-            if (pindexBest == NULL || pindexTest->nChainWork > pindexBest->nChainWork)\n+            if (pindexBest == NULL || pindexTest->nChainWork > pindexBest->nChainWork || (pindexBest->nStatus & BLOCK_FAILED_MASK))\n                 vAttach.push_back(pindexTest);\n \n             if (pindexTest->pprev == NULL || pindexTest->GetNextInMainChain()) {"
      },
      {
        "sha": "89a57931a1b698d68c2a63fd2bc06a560929ca8c",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1646093619905b4b894d33492585f0fc9c4f2b07/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1646093619905b4b894d33492585f0fc9c4f2b07/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=1646093619905b4b894d33492585f0fc9c4f2b07",
        "patch": "@@ -188,6 +188,8 @@ CBlockIndex * InsertBlockIndex(uint256 hash);\n bool VerifySignature(const CCoins& txFrom, const CTransaction& txTo, unsigned int nIn, unsigned int flags, int nHashType);\n /** Abort with a message */\n bool AbortNode(const std::string &msg);\n+/** Mark a block as invalid, and reorganize away from it if necessary */\n+void InvalidBlockFound(CBlockIndex *pindex);\n \n \n "
      }
    ]
  },
  {
    "sha": "dee601dbf9d1f1b84a5ce57d51edff1f0f0a73fe",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkZWU2MDFkYmY5ZDFmMWI4NGE1Y2U1N2Q1MWVkZmYxZjBmMGE3M2Zl",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2013-07-20T11:13:17Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2013-09-28T14:05:01Z"
      },
      "message": "Add blacklistblock RPC\n\nAs this is a fairly dangerous operation, it is normally disabled when\nbuilding. Define ENABLE_BLOCK_BLACKLISTING to enable compiling it in.",
      "tree": {
        "sha": "835dd7b7192f3c80601a93e87927bfb166e0097e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/835dd7b7192f3c80601a93e87927bfb166e0097e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/dee601dbf9d1f1b84a5ce57d51edff1f0f0a73fe",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dee601dbf9d1f1b84a5ce57d51edff1f0f0a73fe",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/dee601dbf9d1f1b84a5ce57d51edff1f0f0a73fe",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dee601dbf9d1f1b84a5ce57d51edff1f0f0a73fe/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1646093619905b4b894d33492585f0fc9c4f2b07",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1646093619905b4b894d33492585f0fc9c4f2b07",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1646093619905b4b894d33492585f0fc9c4f2b07"
      }
    ],
    "stats": {
      "total": 25,
      "additions": 25,
      "deletions": 0
    },
    "files": [
      {
        "sha": "b35f23c83f97ff62bb78fd5ca628394491bd6548",
        "filename": "src/bitcoinrpc.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dee601dbf9d1f1b84a5ce57d51edff1f0f0a73fe/src/bitcoinrpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dee601dbf9d1f1b84a5ce57d51edff1f0f0a73fe/src/bitcoinrpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoinrpc.cpp?ref=dee601dbf9d1f1b84a5ce57d51edff1f0f0a73fe",
        "patch": "@@ -261,6 +261,9 @@ static const CRPCCommand vRPCCommands[] =\n     { \"getrawmempool\",          &getrawmempool,          true,      false },\n     { \"getblock\",               &getblock,               false,     false },\n     { \"getblockhash\",           &getblockhash,           false,     false },\n+#ifdef ENABLE_BLOCK_BLACKLISTING\n+    { \"blacklistblock\",         &blacklistblock,         true,      false },\n+#endif\n     { \"gettransaction\",         &gettransaction,         false,     false },\n     { \"listtransactions\",       &listtransactions,       false,     false },\n     { \"listaddressgroupings\",   &listaddressgroupings,   false,     false },"
      },
      {
        "sha": "c66dcb837106e70453ea56ef59d913a4a7292419",
        "filename": "src/bitcoinrpc.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dee601dbf9d1f1b84a5ce57d51edff1f0f0a73fe/src/bitcoinrpc.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dee601dbf9d1f1b84a5ce57d51edff1f0f0a73fe/src/bitcoinrpc.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoinrpc.h?ref=dee601dbf9d1f1b84a5ce57d51edff1f0f0a73fe",
        "patch": "@@ -218,6 +218,7 @@ extern json_spirit::Value settxfee(const json_spirit::Array& params, bool fHelp)\n extern json_spirit::Value getrawmempool(const json_spirit::Array& params, bool fHelp);\n extern json_spirit::Value getblockhash(const json_spirit::Array& params, bool fHelp);\n extern json_spirit::Value getblock(const json_spirit::Array& params, bool fHelp);\n+extern json_spirit::Value blacklistblock(const json_spirit::Array& params, bool fHelp);\n extern json_spirit::Value gettxoutsetinfo(const json_spirit::Array& params, bool fHelp);\n extern json_spirit::Value gettxout(const json_spirit::Array& params, bool fHelp);\n extern json_spirit::Value verifychain(const json_spirit::Array& params, bool fHelp);"
      },
      {
        "sha": "82285213cd56fd4761a7a677f3d14e9ab2c9d22f",
        "filename": "src/rpcblockchain.cpp",
        "status": "modified",
        "additions": 21,
        "deletions": 0,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dee601dbf9d1f1b84a5ce57d51edff1f0f0a73fe/src/rpcblockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dee601dbf9d1f1b84a5ce57d51edff1f0f0a73fe/src/rpcblockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcblockchain.cpp?ref=dee601dbf9d1f1b84a5ce57d51edff1f0f0a73fe",
        "patch": "@@ -208,6 +208,27 @@ Value gettxoutsetinfo(const Array& params, bool fHelp)\n     return ret;\n }\n \n+Value blacklistblock(const Array &params, bool fHelp)\n+{\n+    if (fHelp || params.size() < 1)\n+        throw runtime_error(\n+            \"blacklistblock <blkid>\\n\"\n+            \"Blacklist a block, and reorganize away from it.\\n\"\n+            \"WARNING: USE ONLY IN EMERGENCY SITUATIONS.\\n\");\n+\n+    std::string strHash = params[0].get_str();\n+    uint256 hash(strHash);\n+    \n+    if (mapBlockIndex.count(hash) == 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block not found\");\n+\n+    CBlockIndex* pblockindex = mapBlockIndex[hash];\n+\n+    InvalidBlockFound(pblockindex);\n+\n+    return Value::null;\n+}\n+\n Value gettxout(const Array& params, bool fHelp)\n {\n     if (fHelp || params.size() < 2 || params.size() > 3)"
      }
    ]
  },
  {
    "sha": "b230a6599e884e158fe49e2cf946801eea83dcaa",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiMjMwYTY1OTllODg0ZTE1OGZlNDllMmNmOTQ2ODAxZWVhODNkY2Fh",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2013-07-27T13:44:42Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2013-09-28T14:05:01Z"
      },
      "message": "Switch to headers-based synchronization.\n\nInstead of using \"getblocks\" to learn about the hashes of blocks peers have,\nuse \"getheaders\" to retrieve the headers of those blocks entirely. This\nallows the client to immediately build an internal representation of the\nblock tree. This means the best chain (or at least its most likely candidate,\ndisregarding invalid transactions) is almost instantly known, and block download\ncan proceed as a secondary (though in practice simultaneous) and very robust\nprocess to acquire the transaction data along this already-known best chain.\n\nAdvantages include:\n* No more vulnerabilities related to orphan blocks, as they simply don't exist\n  anymore. We only fetch blocks along the best chain; any other block we're not\n  interested in.\n* No more need for checkpoints to determine bounds on difficulties of received\n  blocks, as we never receive a block without knowing (the headers of) its\n  ancestry. For a new, smaller vulnerability (sending many long low-difficulty\n  header chains, consuming memory), checkpoints are still useful.\n* No more need for checkpoints for safety when disabling signature check. A rule\n  like \"Do not check signatures in blocks covered by N weeks worth of hash\n  power\" could be used, though this is currently not yet implemented.\n* The IsInitialBlockDownload() become very precises and safe: we're\n  syncing a backlog as long as there are headers in our best chain for which\n  blocks are missing. There is no need for relying on peers' reported number\n  of blocks anymore.\n* It can serve as a basis to implement SPV mode, which is basically the same\n  logic, but with the blockchain-driven block fetching replaced by wallet-driven\n  filtered block fetching.\n* Efficient parallel block download, and generally avoiding many edge cases\n  that were possible during the previous getblocks-based synchronization\n  (including frequent duplicate downloads, orphans and and needing to wait for\n  the next block to be announced before resuming). Additionally, good\n  synchronization speed does not rely on guessing a good initial peer to fetch\n  from anymore - a single slow peer does not hurt you anymore. This also means\n  that throttling upload speeds will no longer be a problem to the network.\n  For now, block sync is only done from outbound peers, to retain the\n  \"no listening == less bandwidth\" property that currently exist. As soon as\n  enough nodes upgrade to headers-first sync, this can be removed.\n\nPotentially significant semantical changes:\n* In case a new best chain is known, but its tip blocks are not yet known, the\n  best known ancestor of the new tip is used instead of the old tip. On the\n  other hand, during this period it is known that we're not up to date. The\n  effects of this on mining should be considered, probably.\n\nMore in detail, changes include:\n* All redundant globals are gone (nBestHeight, nBestChainWork, nBestInvalidWork,\n  hashBestChain) - instead, we just have 4 pointers into the block tree\n  (pindexGenesisBlock, pindexBest, pindexBestHeader, pindexBestInvalid).\n* ProcessBlock and AcceptBlock are split into ProcessBlockHeader and\n  AcceptBlockHeader.\n* Instead of 'getblocks', push out 'getheaders' to the sync node.\n* Implement 'headers' P2P handler, causing headers to be included in the block\n  index.\n* pindexBest remains as pointer to the \"current state of the UTXO set\"\n  (chainstate), meaning the point until where we are synchronized.\n  pindexBestHeader is added as a pointer to the tip of the currently best known\n  (and validated, except for transaction validity) header. pindexBest is\n  guaranteed to be always an ancestor of (or equal to) pindexBestHeader.\n* A new function SwitchToBestHeader finds the best header in the database, and\n  switches to it. SwitchToBestBlock connects blocks along this best chain. These\n  replace ConnectBestBlock.\n* The block tree internally can deal with orphan blocks (whose parents are\n  unknown), but this mechanism is only used during reindexing, as block may be\n  stored out-of-order. A new function LinkOrphans connects orphans to the tree,\n  and replaces some code in LoadBlockIndex.\n* Actual blocks are only fetched along the known-best chain, using parallel\n  block downloading logic in SendMessages. For each peer, a (bounded) list of\n  requested blocks is maintained. New requests are pipelined, as the requested\n  blocks arrive. As the tree they belong to is already known, we can receive and\n  store them out-of-order. This also means that the concept of orphan blocks\n  disappears. If one peer stalls us, it is disconnected and the blocks requested\n  from it are sent elsewhere. This is nicer both for us and for them.\n* One exception to the headers-first syncing, is when we are fully synced\n  (pindexBest==pindexBestHeader), and a new block 'inv' is announced. In this\n  case, the block is fetched immediately ('getdata') after asking for the headers\n  preceding it, to avoid the extra roundtrip.\n* SetBestChain (which handled reorganizations) is no longer necessary, as\n  SwitchToBestHeader and SwitchToBestBlock only ever connect/disconnect\n  individual blocks. It is therefore replaced by two simpler functions,\n  ConnectTip and DisconnectTip, implented using helpers WriteChainState and\n  UpdateTip.\n* In several places code is added to deal with the case that a CBlockIndex\n  entry does not have corresponding block data available.",
      "tree": {
        "sha": "8980e356d891ac9f6319d98a2d34058b8ffc2765",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8980e356d891ac9f6319d98a2d34058b8ffc2765"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b230a6599e884e158fe49e2cf946801eea83dcaa",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b230a6599e884e158fe49e2cf946801eea83dcaa",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b230a6599e884e158fe49e2cf946801eea83dcaa",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b230a6599e884e158fe49e2cf946801eea83dcaa/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "dee601dbf9d1f1b84a5ce57d51edff1f0f0a73fe",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dee601dbf9d1f1b84a5ce57d51edff1f0f0a73fe",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/dee601dbf9d1f1b84a5ce57d51edff1f0f0a73fe"
      }
    ],
    "stats": {
      "total": 1400,
      "additions": 771,
      "deletions": 629
    },
    "files": [
      {
        "sha": "6695b56e5481d90bb9352d0dbda5b44a66c8f761",
        "filename": "src/checkpoints.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 12,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b230a6599e884e158fe49e2cf946801eea83dcaa/src/checkpoints.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b230a6599e884e158fe49e2cf946801eea83dcaa/src/checkpoints.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/checkpoints.cpp?ref=b230a6599e884e158fe49e2cf946801eea83dcaa",
        "patch": "@@ -141,20 +141,15 @@ namespace Checkpoints\n         return checkpoints.rbegin()->first;\n     }\n \n-    CBlockIndex* GetLastCheckpoint(const std::map<uint256, CBlockIndex*>& mapBlockIndex)\n+    int GetLastCheckpointHeight(int nHeight)\n     {\n         if (!fEnabled)\n-            return NULL;\n-\n-        const MapCheckpoints& checkpoints = *Checkpoints().mapCheckpoints;\n+            return 0;\n \n-        BOOST_REVERSE_FOREACH(const MapCheckpoints::value_type& i, checkpoints)\n-        {\n-            const uint256& hash = i.second;\n-            std::map<uint256, CBlockIndex*>::const_iterator t = mapBlockIndex.find(hash);\n-            if (t != mapBlockIndex.end())\n-                return t->second;\n-        }\n-        return NULL;\n+        MapCheckpoints::const_iterator it = Checkpoints().mapCheckpoints->upper_bound(nHeight);\n+        if (it == Checkpoints().mapCheckpoints->begin())\n+            return 0;\n+        it--;\n+        return it->first;\n     }\n }"
      },
      {
        "sha": "87f3b34f5ef4a96da06197eda483604e2b0f5348",
        "filename": "src/checkpoints.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b230a6599e884e158fe49e2cf946801eea83dcaa/src/checkpoints.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b230a6599e884e158fe49e2cf946801eea83dcaa/src/checkpoints.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/checkpoints.h?ref=b230a6599e884e158fe49e2cf946801eea83dcaa",
        "patch": "@@ -20,11 +20,11 @@ namespace Checkpoints\n     // Return conservative estimate of total number of blocks, 0 if unknown\n     int GetTotalBlocksEstimate();\n \n-    // Returns last CBlockIndex* in mapBlockIndex that is a checkpoint\n-    CBlockIndex* GetLastCheckpoint(const std::map<uint256, CBlockIndex*>& mapBlockIndex);\n-\n     double GuessVerificationProgress(CBlockIndex *pindex);\n \n+    // Get the height of the last checkpoint not further than nHeight.\n+    int GetLastCheckpointHeight(int nHeight);\n+\n     extern bool fEnabled;\n }\n "
      },
      {
        "sha": "6f9ad7e6591a0ede3bd4cef477cf3df51a1691b4",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b230a6599e884e158fe49e2cf946801eea83dcaa/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b230a6599e884e158fe49e2cf946801eea83dcaa/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=b230a6599e884e158fe49e2cf946801eea83dcaa",
        "patch": "@@ -942,7 +942,7 @@ bool AppInit2(boost::thread_group& threadGroup)\n \n     // scan for better chains in the block chain database, that are not yet connected in the active best chain\n     CValidationState state;\n-    if (!ConnectBestBlock(state))\n+    if (!SwitchToBestBlock(state))\n         strErrors << \"Failed to connect best block\";\n \n     std::vector<boost::filesystem::path> vImportFiles;\n@@ -980,7 +980,8 @@ bool AppInit2(boost::thread_group& threadGroup)\n \n     //// debug print\n     LogPrintf(\"mapBlockIndex.size() = %\"PRIszu\"\\n\",   mapBlockIndex.size());\n-    LogPrintf(\"nBestHeight = %d\\n\",                   nBestHeight);\n+    LogPrintf(\"nBestHeight = %d\\n\",                   pindexBest ? pindexBest->nHeight : -1);\n+    LogPrintf(\"nBestHeaderHeight = %d\\n\",             pindexBestHeader ? pindexBestHeader->nHeight : -1);\n     LogPrintf(\"setKeyPool.size() = %\"PRIszu\"\\n\",      pwalletMain->setKeyPool.size());\n     LogPrintf(\"mapWallet.size() = %\"PRIszu\"\\n\",       pwalletMain->mapWallet.size());\n     LogPrintf(\"mapAddressBook.size() = %\"PRIszu\"\\n\",  pwalletMain->mapAddressBook.size());"
      },
      {
        "sha": "5b78a344a89175b87004118300fa434828b6dc23",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 665,
        "deletions": 511,
        "changes": 1176,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b230a6599e884e158fe49e2cf946801eea83dcaa/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b230a6599e884e158fe49e2cf946801eea83dcaa/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=b230a6599e884e158fe49e2cf946801eea83dcaa",
        "patch": "@@ -34,12 +34,10 @@ unsigned int nTransactionsUpdated = 0;\n map<uint256, CBlockIndex*> mapBlockIndex;\n std::vector<CBlockIndex*> vBlockIndexByHeight;\n CBlockIndex* pindexGenesisBlock = NULL;\n-int nBestHeight = -1;\n-uint256 nBestChainWork = 0;\n-uint256 nBestInvalidWork = 0;\n-uint256 hashBestChain = 0;\n+CBlockIndex* pindexBestHeader = NULL;\n CBlockIndex* pindexBest = NULL;\n-set<CBlockIndex*, CBlockIndexWorkComparator> setBlockIndexValid; // may contain all CBlockIndex*'s that have validness >=BLOCK_VALID_TRANSACTIONS, and must contain those who aren't failed\n+CBlockIndex* pindexBestInvalid = NULL;\n+set<CBlockIndex*, CBlockIndexWorkComparator> setBlockIndexValid; // may contain all CBlockIndex*'s that have validness >=BLOCK_VALID_TREE, and must contain those who aren't failed\n int64 nTimeBestReceived = 0;\n int nScriptCheckThreads = 0;\n bool fImporting = false;\n@@ -49,15 +47,18 @@ bool fTxIndex = false;\n unsigned int nCoinCacheSize = 5000;\n bool fHaveGUI = false;\n \n+static std::set<int> setHeightMissing; // All heights that are > pindexBest, <= pindexBestHeight, <= pindexBest+MAX_BLOCKS_IN_TRANSIT, and not requested from peers.\n+static std::map<CBlockIndex*, int64> mapBlocksAskedFor;\n+\n /** Fees smaller than this (in satoshi) are considered zero fee (for transaction creation) */\n int64 CTransaction::nMinTxFee = 10000;  // Override with -mintxfee\n /** Fees smaller than this (in satoshi) are considered zero fee (for relaying) */\n int64 CTransaction::nMinRelayTxFee = 10000;\n \n-CMedianFilter<int> cPeerBlockCounts(8, 0); // Amount of blocks that other nodes claim to have\n-\n-map<uint256, CBlock*> mapOrphanBlocks;\n-multimap<uint256, CBlock*> mapOrphanBlocksByPrev;\n+// multimap with orphan entries in the block index, indexed by their hashPrev.\n+// This is only used for dealing with out-of-order blocks in imported block files,\n+// not for dealing with orphans received from the network.\n+static std::multimap<uint256, CBlockIndex*> mapOrphanBlocksByPrev;\n \n map<uint256, CTransaction> mapOrphanTransactions;\n map<uint256, set<uint256> > mapOrphanTransactionsByPrev;\n@@ -70,7 +71,12 @@ const string strMessageMagic = \"Bitcoin Signed Message:\\n\";\n // Settings\n int64 nTransactionFee = 0;\n \n-\n+// Forward declarations\n+void InitializeNode(CNode *pnode);\n+void FinalizeNode(CNode *pnode);\n+bool static LinkOrphans(const uint256 *phashParent = NULL);\n+bool static ConnectTip(CValidationState &state, CBlockIndex *pindex);\n+bool static DisconnectTip(CValidationState &state);\n \n //////////////////////////////////////////////////////////////////////////////\n //\n@@ -177,12 +183,16 @@ void RegisterNodeSignals(CNodeSignals& nodeSignals)\n {\n     nodeSignals.ProcessMessages.connect(&ProcessMessages);\n     nodeSignals.SendMessages.connect(&SendMessages);\n+    nodeSignals.FinalizeNode.connect(&FinalizeNode);\n+    nodeSignals.InitializeNode.connect(&InitializeNode);\n }\n \n void UnregisterNodeSignals(CNodeSignals& nodeSignals)\n {\n     nodeSignals.ProcessMessages.disconnect(&ProcessMessages);\n     nodeSignals.SendMessages.disconnect(&SendMessages);\n+    nodeSignals.FinalizeNode.disconnect(&FinalizeNode);\n+    nodeSignals.InitializeNode.disconnect(&InitializeNode);\n }\n \n //////////////////////////////////////////////////////////////////////////////\n@@ -517,7 +527,7 @@ bool IsFinalTx(const CTransaction &tx, int nBlockHeight, int64 nBlockTime)\n     if (tx.nLockTime == 0)\n         return true;\n     if (nBlockHeight == 0)\n-        nBlockHeight = nBestHeight;\n+        nBlockHeight = pindexBest->nHeight;\n     if (nBlockTime == 0)\n         nBlockTime = GetAdjustedTime();\n     if ((int64)tx.nLockTime < ((int64)tx.nLockTime < LOCKTIME_THRESHOLD ? (int64)nBlockHeight : nBlockTime))\n@@ -1203,7 +1213,6 @@ bool GetTransaction(const uint256 &hash, CTransaction &txOut, uint256 &hashBlock\n // CBlock and CBlockIndex\n //\n \n-static CBlockIndex* pblockindexFBBHLast;\n CBlockIndex* FindBlockByHeight(int nHeight)\n {\n     if (nHeight >= (int)vBlockIndexByHeight.size())\n@@ -1270,14 +1279,6 @@ bool ReadBlockFromDisk(CBlock& block, const CBlockIndex* pindex)\n     return true;\n }\n \n-uint256 static GetOrphanRoot(const CBlockHeader* pblock)\n-{\n-    // Work back to the first block in the orphan chain\n-    while (mapOrphanBlocks.count(pblock->hashPrevBlock))\n-        pblock = mapOrphanBlocks[pblock->hashPrevBlock];\n-    return pblock->GetHash();\n-}\n-\n int64 GetBlockValue(int nHeight, int64 nFees)\n {\n     int64 nSubsidy = 50 * COIN;\n@@ -1396,44 +1397,61 @@ bool CheckProofOfWork(uint256 hash, unsigned int nBits)\n     return true;\n }\n \n-// Return maximum amount of blocks that other nodes claim to have\n-int GetNumBlocksOfPeers()\n-{\n-    return std::max(cPeerBlockCounts.median(), Checkpoints::GetTotalBlocksEstimate());\n-}\n-\n bool IsInitialBlockDownload()\n {\n-    if (pindexBest == NULL || fImporting || fReindex || nBestHeight < Checkpoints::GetTotalBlocksEstimate())\n+    if (pindexBest == NULL || (pindexBest != pindexBestHeader && pindexBest != pindexBestHeader->pprev) || fImporting || fReindex || pindexBest->nHeight < Checkpoints::GetTotalBlocksEstimate())\n         return true;\n-    static int64 nLastUpdate;\n-    static CBlockIndex* pindexLastBest;\n-    if (pindexBest != pindexLastBest)\n-    {\n-        pindexLastBest = pindexBest;\n-        nLastUpdate = GetTime();\n-    }\n-    return (GetTime() - nLastUpdate < 10 &&\n-            pindexBest->GetBlockTime() < GetTime() - 24 * 60 * 60);\n+    return false;\n }\n \n bool fLargeWorkForkFound = false;\n bool fLargeWorkInvalidChainFound = false;\n-CBlockIndex *pindexBestForkTip = NULL, *pindexBestForkBase = NULL;\n \n-void CheckForkWarningConditions()\n+void CheckForkWarningConditions(bool fReorganized = false)\n {\n     // Before we get past initial download, we cannot reliably alert about forks\n     // (we assume we don't get stuck on a fork before the last checkpoint)\n     if (IsInitialBlockDownload())\n         return;\n \n-    // If our best fork is no longer within 72 blocks (+/- 12 hours if no one mines it)\n-    // of our head, drop it\n-    if (pindexBestForkTip && nBestHeight - pindexBestForkTip->nHeight >= 72)\n-        pindexBestForkTip = NULL;\n+    // We define a condition which we should warn the user about as a fork of at least 7 blocks\n+    // who's tip is within 72 blocks (+/- 12 hours if no one mines it) of ours\n+    // We use 7 blocks rather arbitrarily as it represents just under 10% of sustained network\n+    // hash rate operating on the fork.\n+    // or a chain that is entirely longer than ours and invalid (note that this should be detected by both)\n+    // We define it this way because it allows us to only store the highest fork tip (+ base) which meets\n+    // the 7-block condition and from this always have the most-likely-to-cause-warning fork\n+    CBlockIndex *pindexBestForkBase = NULL;\n+    CBlockIndex *pindexBestForkTip = NULL;\n+    if (pindexBestInvalid && pindexBestInvalid->nChainWork > pindexBest->nChainWork + (pindexBest->GetBlockWork() * 6).getuint256()) {\n+        pindexBestForkBase = pindexBestInvalid->pprev;\n+    } else if (fReorganized) {\n+        // Find a fork up to 72 blocks deep.\n+        std::set<CBlockIndex*,CBlockIndexWorkComparator>::reverse_iterator it = setBlockIndexValid.rbegin();\n+        while (it != setBlockIndexValid.rend() && (*it)->nHeight + 72 > pindexBestHeader->nHeight) {\n+            if (!(*it)->IsInMainChain()) {\n+                pindexBestForkTip = *it;\n+                pindexBestForkBase = pindexBestForkTip->pprev;\n+                break;\n+            }\n+            it++;\n+        }\n+    }\n+    while (pindexBestForkBase && !pindexBestForkBase->IsInMainChain())\n+        pindexBestForkBase = pindexBestForkBase->pprev;\n+    if (pindexBestForkBase) {\n+        LogPrintf(\"CheckForkWarningConditions(): bestForkTip=%s(%i) bestForkBase=%s(%i)\\n\", pindexBestForkTip->GetBlockHash().ToString().c_str(), pindexBestForkTip->nHeight,\n+                                                                                         pindexBestForkBase->GetBlockHash().ToString().c_str(), pindexBestForkBase->nHeight);\n+    }\n+\n+    if (pindexBestForkTip && pindexBestForkBase) {\n+        if (pindexBestForkBase == pindexBestHeader || pindexBestForkTip->nChainWork < (pindexBestForkBase->GetBlockWork() * 7).getuint256() + pindexBestForkBase->nChainWork) {\n+            LogPrintf(\"CheckForkWarningConditions(): best fork is not dangerous\");\n+            pindexBestForkBase = NULL;\n+        }\n+    }\n \n-    if (pindexBestForkTip || nBestInvalidWork > nBestChainWork + (pindexBest->GetBlockWork() * 6).getuint256())\n+    if (pindexBestForkBase)\n     {\n         if (!fLargeWorkForkFound)\n         {\n@@ -1466,130 +1484,180 @@ void CheckForkWarningConditions()\n     }\n }\n \n-void CheckForkWarningConditionsOnNewFork(CBlockIndex* pindexNewForkTip)\n-{\n-    // If we are on a fork that is sufficiently large, set a warning flag\n-    CBlockIndex* pfork = pindexNewForkTip;\n-    CBlockIndex* plonger = pindexBest;\n-    while (pfork && pfork != plonger)\n-    {\n-        while (plonger && plonger->nHeight > pfork->nHeight)\n-            plonger = plonger->pprev;\n-        if (pfork == plonger)\n-            break;\n-        pfork = pfork->pprev;\n-    }\n-\n-    // We define a condition which we should warn the user about as a fork of at least 7 blocks\n-    // who's tip is within 72 blocks (+/- 12 hours if no one mines it) of ours\n-    // We use 7 blocks rather arbitrarily as it represents just under 10% of sustained network\n-    // hash rate operating on the fork.\n-    // or a chain that is entirely longer than ours and invalid (note that this should be detected by both)\n-    // We define it this way because it allows us to only store the highest fork tip (+ base) which meets\n-    // the 7-block condition and from this always have the most-likely-to-cause-warning fork\n-    if (pfork && (!pindexBestForkTip || (pindexBestForkTip && pindexNewForkTip->nHeight > pindexBestForkTip->nHeight)) &&\n-            pindexNewForkTip->nChainWork - pfork->nChainWork > (pfork->GetBlockWork() * 7).getuint256() &&\n-            nBestHeight - pindexNewForkTip->nHeight < 72)\n-    {\n-        pindexBestForkTip = pindexNewForkTip;\n-        pindexBestForkBase = pfork;\n-    }\n-\n-    CheckForkWarningConditions();\n-}\n-\n-void static InvalidChainFound(CBlockIndex* pindexNew)\n-{\n-    if (pindexNew->nChainWork > nBestInvalidWork)\n-    {\n-        nBestInvalidWork = pindexNew->nChainWork;\n-        pblocktree->WriteBestInvalidWork(CBigNum(nBestInvalidWork));\n-        uiInterface.NotifyBlocksChanged();\n-    }\n-    LogPrintf(\"InvalidChainFound: invalid block=%s  height=%d  log2_work=%.8g  date=%s\\n\",\n-      pindexNew->GetBlockHash().ToString().c_str(), pindexNew->nHeight,\n-      log(pindexNew->nChainWork.getdouble())/log(2.0), DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\",\n-      pindexNew->GetBlockTime()).c_str());\n-    LogPrintf(\"InvalidChainFound:  current best=%s  height=%d  log2_work=%.8g  date=%s\\n\",\n-      hashBestChain.ToString().c_str(), nBestHeight, log(nBestChainWork.getdouble())/log(2.0),\n-      DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", pindexBest->GetBlockTime()).c_str());\n-    CheckForkWarningConditions();\n-}\n-\n void InvalidBlockFound(CBlockIndex *pindex) {\n+\n+    // Mark pindex as invalid.\n     pindex->nStatus |= BLOCK_FAILED_VALID;\n     pblocktree->WriteBlockIndex(CDiskBlockIndex(pindex));\n+    LogPrintf(\"Marked %s as invalid\\n\", pindex->GetBlockHash().ToString().c_str());\n     setBlockIndexValid.erase(pindex);\n-    InvalidChainFound(pindex);\n+\n+    // Mark its decendants in the main chain (if any) as invalid.\n     CBlockIndex *pindexWalk = pindex;\n     do {\n         CBlockIndex *pindexNext = pindexWalk->GetNextInMainChain();\n         if (!pindexNext) break;\n         pindexWalk = pindexNext;\n+        setBlockIndexValid.erase(pindexWalk);\n         pindexWalk->nStatus |= BLOCK_FAILED_CHILD;\n-        printf(\"Marked %s as descending from invalid\\n\", pindexWalk->GetBlockHash().ToString().c_str());\n+        LogPrintf(\"Marked %s as descending from invalid\\n\", pindexWalk->GetBlockHash().ToString().c_str());\n     } while(true);\n-    if (pindex->GetNextInMainChain()) {\n-        setBlockIndexValid.insert(pindex->pprev);\n-        CValidationState stateDummy;\n-        ConnectBestBlock(stateDummy); // reorganise away from the failed block\n+\n+    // Update pindexBestInvalid if necessary.\n+    if (pindexBestInvalid==NULL || pindexWalk->nChainWork > pindexBestInvalid->nChainWork) {\n+        pindexBestInvalid = pindexWalk;\n+        pblocktree->WriteBestInvalidWork(CBigNum(pindexWalk->nChainWork)); // only for compatibility\n+        uiInterface.NotifyBlocksChanged();\n     }\n+\n+    // reorganise away from the failed block\n+    CValidationState stateDummy;\n+    SwitchToBestBlock(stateDummy);\n+    CheckForkWarningConditions(true);\n+\n+    LogPrintf(\"InvalidBlockFound: invalid block=%s  height=%d  log2_work=%.8g  date=%s\\n\",\n+      pindex->GetBlockHash().ToString().c_str(), pindex->nHeight,\n+      log(pindex->nChainWork.getdouble())/log(2.0), DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\",\n+      pindex->GetBlockTime()).c_str());\n+    LogPrintf(\"InvalidChainFound:  current best=%s  height=%d  log2_work=%.8g  date=%s\\n\",\n+      pindexBest->GetBlockHash().ToString().c_str(), pindexBest->nHeight, log(pindexBest->nChainWork.getdouble())/log(2.0),\n+      DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", pindexBest->GetBlockTime()).c_str());\n }\n \n-bool ConnectBestBlock(CValidationState &state) {\n-    do {\n-        CBlockIndex *pindexNewBest;\n+// Requires cs_main\n+void static UpdateMissingHeight(int nHeight) {\n+    if (nHeight == 0)\n+        return;\n+    setHeightMissing.erase(nHeight);\n+    int nBestHeight = pindexBest ? pindexBest->nHeight : -1;\n+    int nBestHeaderHeight = pindexBestHeader ? pindexBestHeader->nHeight : -1;\n+    if (nHeight > nBestHeight &&\n+        nHeight <= nBestHeight + MAX_BLOCKS_IN_TRANSIT &&\n+        nHeight <= nBestHeaderHeight &&\n+        mapBlocksAskedFor.count(vBlockIndexByHeight[nHeight]) == 0)\n+        setHeightMissing.insert(nHeight);\n+}\n+\n+bool SwitchToBestHeader(CValidationState &state) {\n+    CBlockIndex *pindexNewBest = NULL;\n+\n+    // In case the current best is invalid, do not consider it.\n+    while (pindexBestHeader && pindexBestHeader->nStatus & BLOCK_FAILED_MASK)\n+        pindexBestHeader = pindexBestHeader->pprev;\n \n+    do {\n+        // Find best candidate header.\n         {\n-            std::set<CBlockIndex*,CBlockIndexWorkComparator>::reverse_iterator it = setBlockIndexValid.rbegin();\n-            while (it != setBlockIndexValid.rend() && (*it)->nStatus & BLOCK_FAILED_MASK) {\n-                printf(\"Not considering failed %s (%i)\\n\", (*it)->GetBlockHash().ToString().c_str(), (*it)->nHeight);\n-                it++;\n-            }\n-            if (it == setBlockIndexValid.rend())\n+            std::set<CBlockIndex*,CBlockIndexWorkComparator>::iterator it = setBlockIndexValid.end();\n+            if (it == setBlockIndexValid.begin()) {\n                 return true;\n+            }\n+            it--;\n             pindexNewBest = *it;\n+            if ((pindexNewBest->nStatus & BLOCK_FAILED_MASK) || (pindexNewBest->nStatus & BLOCK_VALID_MASK) < BLOCK_VALID_TREE) {\n+                // Entry isn't a valid candidate; drop it, and find another.\n+                setBlockIndexValid.erase(it);\n+                continue;\n+            }\n         }\n \n-        if ((pindexNewBest == pindexBest || (pindexBest && pindexNewBest->nChainWork == pindexBest->nChainWork)) && !(pindexBest->nStatus & BLOCK_FAILED_MASK))\n-            return true; // nothing to do\n+        // Check whether it's actually an improvement.\n+        if (pindexBestHeader && pindexNewBest->nChainWork <= pindexBestHeader->nChainWork) {\n+            break;\n+        }\n \n-        // check ancestry\n+        // Check tree nodes between the candidate new best and the currently-accepted best.\n         CBlockIndex *pindexTest = pindexNewBest;\n-        std::vector<CBlockIndex*> vAttach;\n-        do {\n+        while (pindexTest && !pindexTest->IsInMainChain()) {\n             if (pindexTest->nStatus & BLOCK_FAILED_MASK) {\n-                // mark descendants failed\n+                // Invalid node found, remove the entire chain after it from the set of candidates.\n+                if (pindexBestInvalid == NULL || pindexTest->nChainWork > pindexBestInvalid->nChainWork)\n+                    pindexBestInvalid = pindexTest;\n                 CBlockIndex *pindexFailed = pindexNewBest;\n                 while (pindexTest != pindexFailed) {\n                     pindexFailed->nStatus |= BLOCK_FAILED_CHILD;\n                     setBlockIndexValid.erase(pindexFailed);\n-                    pblocktree->WriteBlockIndex(CDiskBlockIndex(pindexFailed));\n                     pindexFailed = pindexFailed->pprev;\n                 }\n-                InvalidChainFound(pindexNewBest);\n                 break;\n             }\n-\n-            if (pindexBest == NULL || pindexTest->nChainWork > pindexBest->nChainWork || (pindexBest->nStatus & BLOCK_FAILED_MASK))\n-                vAttach.push_back(pindexTest);\n-\n-            if (pindexTest->pprev == NULL || pindexTest->GetNextInMainChain()) {\n-                reverse(vAttach.begin(), vAttach.end());\n-                BOOST_FOREACH(CBlockIndex *pindexSwitch, vAttach) {\n-                    boost::this_thread::interruption_point();\n-                    try {\n-                        if (!SetBestChain(state, pindexSwitch))\n-                            return false;\n-                    } catch(std::runtime_error &e) {\n-                        return state.Abort(_(\"System error: \") + e.what());\n-                    }\n-                }\n-                return true;\n-            }\n             pindexTest = pindexTest->pprev;\n-        } while(true);\n+        }\n+        if (pindexTest && pindexTest->nStatus & BLOCK_FAILED_MASK)\n+            continue;\n+        break;\n     } while(true);\n+\n+    // We have a new best header.\n+    if (pindexNewBest->nHeight + 1 > (int)vBlockIndexByHeight.size())\n+        vBlockIndexByHeight.resize(pindexNewBest->nHeight + 1);\n+    CBlockIndex *pindexFork = pindexNewBest;\n+    pindexBestHeader = pindexNewBest;\n+    bool fDisconnectedAny = false;\n+    while (pindexFork && !pindexFork->IsInMainChain()) {\n+        if (pindexBest && pindexFork->nHeight == pindexBest->nHeight && vBlockIndexByHeight[pindexFork->nHeight-1]) {\n+            // We need to disconnect a block, as it's no longer in the best chain.\n+            if (!DisconnectTip(state))\n+                return error(\"Disconnecting tip %i (%s) failed\", pindexBest->nHeight, pindexBest->GetBlockHash().ToString().c_str());\n+            fDisconnectedAny = true;\n+        }\n+        vBlockIndexByHeight[pindexFork->nHeight] = pindexFork;\n+        UpdateMissingHeight(pindexFork->nHeight);\n+        pindexFork = pindexFork->pprev;\n+    }\n+    if (pindexNewBest->nHeight + 1 < (int)vBlockIndexByHeight.size())\n+        vBlockIndexByHeight.resize(pindexNewBest->nHeight + 1);\n+    if (fDisconnectedAny)\n+        CheckForkWarningConditions(true);\n+    return true;\n+}\n+\n+bool SwitchToBestBlock(CValidationState &state) {\n+    CBlockIndex *pindexOldBestInvalid = pindexBestInvalid;\n+    CBlockIndex *pindexOldBest = pindexBest;\n+\n+    if (!SwitchToBestHeader(state))\n+        return false;\n+\n+    if (pindexBestHeader == NULL)\n+        return true;\n+\n+    bool fChanged = false;\n+    int nHeight = pindexBest ? pindexBest->nHeight+1 : 0;\n+\n+    while (nHeight < (int)vBlockIndexByHeight.size()) {\n+        CBlockIndex *pindexNew = vBlockIndexByHeight[nHeight];\n+        if (!(pindexNew->nStatus & BLOCK_HAVE_DATA) ||\n+            (pindexNew->nStatus & BLOCK_VALID_MASK) < BLOCK_VALID_TRANSACTIONS)\n+            return true;\n+        pindexNew->nChainTx = (pindexNew->pprev ? pindexNew->pprev->nChainTx : 0) + pindexNew->nTx;\n+        if (!ConnectTip(state, pindexNew))\n+            return error(\"Connecting tip %i (%s) failed\", pindexNew->nHeight, pindexNew->GetBlockHash().ToString().c_str());\n+        UpdateMissingHeight(nHeight);\n+        UpdateMissingHeight(nHeight + MAX_BLOCKS_IN_TRANSIT);\n+        nHeight++;\n+        fChanged = true;\n+    }\n+\n+    if (fChanged)\n+    {\n+        // Relay inventory, but don't relay old inventory during initial block download\n+        int nBlockEstimate = Checkpoints::GetTotalBlocksEstimate();\n+\n+        // TODO: make logic take hashLastBlock and pindexLastBlock into account.\n+        LOCK(cs_vNodes);\n+        BOOST_FOREACH(CNode* pnode, vNodes)\n+            if (pindexBest->nHeight > (pnode->nStartingHeight != -1 ? pnode->nStartingHeight - 2000 : nBlockEstimate))\n+                pnode->PushInventory(CInv(MSG_BLOCK, pindexBest->GetBlockHash()));\n+    }\n+\n+    if (pindexOldBest && !pindexOldBest->IsInMainChain()) {\n+        CheckForkWarningConditions(true);\n+    } else if (fChanged || pindexBestInvalid != pindexOldBestInvalid) {\n+        CheckForkWarningConditions(false);\n+    }\n+\n+    return true;\n }\n \n void UpdateTime(CBlockHeader& block, const CBlockIndex* pindexPrev)\n@@ -1894,7 +1962,6 @@ bool ConnectBlock(CBlock& block, CValidationState& state, CBlockIndex* pindex, C\n     // (its coinbase is unspendable)\n     if (block.GetHash() == Params().HashGenesisBlock()) {\n         view.SetBestBlock(pindex);\n-        pindexGenesisBlock = pindex;\n         return true;\n     }\n \n@@ -2033,96 +2100,7 @@ bool ConnectBlock(CBlock& block, CValidationState& state, CBlockIndex* pindex, C\n     return true;\n }\n \n-bool SetBestChain(CValidationState &state, CBlockIndex* pindexNew)\n-{\n-    mempool.check(pcoinsTip);\n-\n-    // All modifications to the coin state will be done in this cache.\n-    // Only when all have succeeded, we push it to pcoinsTip.\n-    CCoinsViewCache view(*pcoinsTip, true);\n-\n-    // Find the fork (typically, there is none)\n-    CBlockIndex* pfork = view.GetBestBlock();\n-    CBlockIndex* plonger = pindexNew;\n-    while (pfork && pfork != plonger)\n-    {\n-        while (plonger->nHeight > pfork->nHeight) {\n-            plonger = plonger->pprev;\n-            assert(plonger != NULL);\n-        }\n-        if (pfork == plonger)\n-            break;\n-        pfork = pfork->pprev;\n-        assert(pfork != NULL);\n-    }\n-\n-    // List of what to disconnect (typically nothing)\n-    vector<CBlockIndex*> vDisconnect;\n-    for (CBlockIndex* pindex = view.GetBestBlock(); pindex != pfork; pindex = pindex->pprev)\n-        vDisconnect.push_back(pindex);\n-\n-    // List of what to connect (typically only pindexNew)\n-    vector<CBlockIndex*> vConnect;\n-    for (CBlockIndex* pindex = pindexNew; pindex != pfork; pindex = pindex->pprev)\n-        vConnect.push_back(pindex);\n-    reverse(vConnect.begin(), vConnect.end());\n-\n-    if (vDisconnect.size() > 0) {\n-        LogPrintf(\"REORGANIZE: Disconnect %\"PRIszu\" blocks; %s...\\n\", vDisconnect.size(), pfork->GetBlockHash().ToString().c_str());\n-        LogPrintf(\"REORGANIZE: Connect %\"PRIszu\" blocks; ...%s\\n\", vConnect.size(), pindexNew->GetBlockHash().ToString().c_str());\n-    }\n-\n-    // Disconnect shorter branch\n-    list<CTransaction> vResurrect;\n-    BOOST_FOREACH(CBlockIndex* pindex, vDisconnect) {\n-        CBlock block;\n-        if (!ReadBlockFromDisk(block, pindex))\n-            return state.Abort(_(\"Failed to read block\"));\n-        int64 nStart = GetTimeMicros();\n-        if (!DisconnectBlock(block, state, pindex, view))\n-            return error(\"SetBestBlock() : DisconnectBlock %s failed\", pindex->GetBlockHash().ToString().c_str());\n-        if (fBenchmark)\n-            LogPrintf(\"- Disconnect: %.2fms\\n\", (GetTimeMicros() - nStart) * 0.001);\n-\n-        // Queue memory transactions to resurrect.\n-        // We only do this for blocks after the last checkpoint (reorganisation before that\n-        // point should only happen with -reindex/-loadblock, or a misbehaving peer.\n-        BOOST_REVERSE_FOREACH(const CTransaction& tx, block.vtx)\n-            if (!tx.IsCoinBase() && pindex->nHeight > Checkpoints::GetTotalBlocksEstimate())\n-                vResurrect.push_front(tx);\n-    }\n-\n-    // Connect longer branch\n-    vector<CTransaction> vDelete;\n-    BOOST_FOREACH(CBlockIndex *pindex, vConnect) {\n-        CBlock block;\n-        if (!ReadBlockFromDisk(block, pindex))\n-            return state.Abort(_(\"Failed to read block\"));\n-        int64 nStart = GetTimeMicros();\n-        if (!ConnectBlock(block, state, pindex, view)) {\n-            if (state.IsInvalid()) {\n-                InvalidChainFound(pindexNew);\n-                InvalidBlockFound(pindex);\n-            }\n-            return error(\"SetBestBlock() : ConnectBlock %s failed\", pindex->GetBlockHash().ToString().c_str());\n-        }\n-        if (fBenchmark)\n-            LogPrintf(\"- Connect: %.2fms\\n\", (GetTimeMicros() - nStart) * 0.001);\n-\n-        // Queue memory transactions to delete\n-        BOOST_FOREACH(const CTransaction& tx, block.vtx)\n-            vDelete.push_back(tx);\n-    }\n-\n-    // Flush changes to global coin state\n-    int64 nStart = GetTimeMicros();\n-    int nModified = view.GetCacheSize();\n-    assert(view.Flush());\n-    int64 nTime = GetTimeMicros() - nStart;\n-    if (fBenchmark)\n-        LogPrintf(\"- Flush %i transactions: %.2fms (%.4fms/tx)\\n\", nModified, 0.001 * nTime, 0.001 * nTime / nModified);\n-\n-    // Make sure it's successfully written to disk before changing memory structure\n+bool static WriteChainState(CValidationState &state) {\n     bool fIsInitialDownload = IsInitialBlockDownload();\n     if (!fIsInitialDownload || pcoinsTip->GetCacheSize() > nCoinCacheSize) {\n         // Typical CCoins structures on disk are around 100 bytes in size.\n@@ -2137,28 +2115,11 @@ bool SetBestChain(CValidationState &state, CBlockIndex* pindexNew)\n         if (!pcoinsTip->Flush())\n             return state.Abort(_(\"Failed to write to coin database\"));\n     }\n+    return true;\n+}\n \n-    // At this point, all changes have been done to the database.\n-    // Proceed by updating the memory structures.\n-\n-    // Register new best chain\n-    vBlockIndexByHeight.resize(pindexNew->nHeight + 1);\n-    BOOST_FOREACH(CBlockIndex* pindex, vConnect)\n-        vBlockIndexByHeight[pindex->nHeight] = pindex;\n-\n-    // Resurrect memory transactions that were in the disconnected branch\n-    BOOST_FOREACH(CTransaction& tx, vResurrect) {\n-        // ignore validation errors in resurrected transactions\n-        CValidationState stateDummy;\n-        if (!mempool.accept(stateDummy, tx, false, NULL))\n-            mempool.remove(tx, true);\n-    }\n-\n-    // Delete redundant memory transactions that are in the connected branch\n-    BOOST_FOREACH(CTransaction& tx, vDelete) {\n-        mempool.remove(tx);\n-        mempool.removeConflicts(tx);\n-    }\n+void static UpdateTip(CBlockIndex *pindexNew) {\n+    bool fIsInitialDownload = IsInitialBlockDownload();\n \n     mempool.check(pcoinsTip);\n \n@@ -2170,15 +2131,11 @@ bool SetBestChain(CValidationState &state, CBlockIndex* pindexNew)\n     }\n \n     // New best block\n-    hashBestChain = pindexNew->GetBlockHash();\n     pindexBest = pindexNew;\n-    pblockindexFBBHLast = NULL;\n-    nBestHeight = pindexBest->nHeight;\n-    nBestChainWork = pindexNew->nChainWork;\n     nTimeBestReceived = GetTime();\n     nTransactionsUpdated++;\n     LogPrintf(\"SetBestChain: new best=%s  height=%d  log2_work=%.8g  tx=%lu  date=%s progress=%f\\n\",\n-      hashBestChain.ToString().c_str(), nBestHeight, log(nBestChainWork.getdouble())/log(2.0), (unsigned long)pindexNew->nChainTx,\n+      pindexBest->GetBlockHash().ToString().c_str(), pindexBest->nHeight, log(pindexBest->nChainWork.getdouble())/log(2.0), (unsigned long)pindexNew->nChainTx,\n       DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", pindexBest->GetBlockTime()).c_str(),\n       Checkpoints::GuessVerificationProgress(pindexBest));\n \n@@ -2201,67 +2158,95 @@ bool SetBestChain(CValidationState &state, CBlockIndex* pindexNew)\n     }\n \n     std::string strCmd = GetArg(\"-blocknotify\", \"\");\n-\n     if (!fIsInitialDownload && !strCmd.empty())\n     {\n-        boost::replace_all(strCmd, \"%s\", hashBestChain.GetHex());\n+        boost::replace_all(strCmd, \"%s\", pindexBest->GetBlockHash().GetHex());\n         boost::thread t(runCommand, strCmd); // thread runs free\n     }\n+}\n \n+bool static DisconnectTip(CValidationState &state) {\n+    // Read block from disk.\n+    CBlock block;\n+    if (!ReadBlockFromDisk(block, pindexBest))\n+        return state.Abort(_(\"Failed to read block\"));\n+    // Apply the block atomically to the chain state.\n+    int64 nStart = GetTimeMicros();\n+    {\n+        CCoinsViewCache view(*pcoinsTip, true);\n+        assert(view.GetBestBlock() == pindexBest);\n+        if (!DisconnectBlock(block, state, pindexBest, view))\n+            return error(\"DisconnectTip() : DisconnectBlock %s failed\", pindexBest->GetBlockHash().ToString().c_str());\n+        assert(view.Flush());\n+    }\n+    if (fBenchmark)\n+        LogPrintf(\"- Disconnect: %.2fms\\n\", (GetTimeMicros() - nStart) * 0.001);\n+    // Write the chain state to disk, if necessary.\n+    if (!WriteChainState(state))\n+        return false;\n+    // Ressurect mempool transactions from the disconnected block.\n+    BOOST_FOREACH(const CTransaction &tx, block.vtx) {\n+        // ignore validation errors in resurrected transactions\n+        CValidationState stateDummy;\n+        mempool.accept(stateDummy, tx, false, NULL);\n+    }\n+    // Update pindexBest and related variables.\n+    UpdateTip(pindexBest->pprev);\n     return true;\n }\n \n-\n-bool AddToBlockIndex(CBlock& block, CValidationState& state, const CDiskBlockPos& pos)\n-{\n-    // Check for duplicate\n-    uint256 hash = block.GetHash();\n-    if (mapBlockIndex.count(hash))\n-        return state.Invalid(error(\"AddToBlockIndex() : %s already exists\", hash.ToString().c_str()));\n-\n-    // Construct new block index object\n-    CBlockIndex* pindexNew = new CBlockIndex(block);\n-    assert(pindexNew);\n-    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.insert(make_pair(hash, pindexNew)).first;\n-    pindexNew->phashBlock = &((*mi).first);\n-    map<uint256, CBlockIndex*>::iterator miPrev = mapBlockIndex.find(block.hashPrevBlock);\n-    if (miPrev != mapBlockIndex.end())\n+bool static ConnectTip(CValidationState &state, CBlockIndex *pindexNew) {\n+    assert(pindexNew->pprev == pindexBest);\n+    // Read block from disk.\n+    CBlock block;\n+    if (!ReadBlockFromDisk(block, pindexNew))\n+        return state.Abort(_(\"Failed to read block\"));\n+    // Apply the block atomically to the chain state.\n+    int64 nStart = GetTimeMicros();\n     {\n-        pindexNew->pprev = (*miPrev).second;\n-        pindexNew->nHeight = pindexNew->pprev->nHeight + 1;\n+        CCoinsViewCache view(*pcoinsTip, true);\n+        assert(view.GetBestBlock() == pindexBest);\n+        if (!ConnectBlock(block, state, pindexNew, view)) {\n+            if (state.IsInvalid())\n+                InvalidBlockFound(pindexNew);\n+            return error(\"SetBestBlock() : ConnectBlock %s failed\", pindexNew->GetBlockHash().ToString().c_str());\n+        }\n+        assert(view.Flush());\n     }\n+    if (fBenchmark)\n+        LogPrintf(\"- Connect: %.2fms\\n\", (GetTimeMicros() - nStart) * 0.001);\n+    // Write the chain state to disk, if necessary.\n+    if (!WriteChainState(state))\n+        return false;\n+    // Remove conflicting transactions from the mempool.\n+    BOOST_FOREACH(const CTransaction &tx, block.vtx) {\n+        mempool.remove(tx);\n+        mempool.removeConflicts(tx);\n+    }\n+    // Update pindexBest & related variables.\n+    UpdateTip(pindexNew);\n+\n+    // Notify UI to display prev block's coinbase if it was ours\n+    static uint256 hashPrevBestCoinBase;\n+    UpdatedTransaction(hashPrevBestCoinBase);\n+    hashPrevBestCoinBase = block.GetTxHash(0);\n+    uiInterface.NotifyBlocksChanged();\n+\n+    return true;\n+}\n+\n+bool static WriteBlockPosition(CBlockIndex *pindexNew, const CBlock &block, const CDiskBlockPos& pos)\n+{\n     pindexNew->nTx = block.vtx.size();\n-    pindexNew->nChainWork = (pindexNew->pprev ? pindexNew->pprev->nChainWork : 0) + pindexNew->GetBlockWork().getuint256();\n-    pindexNew->nChainTx = (pindexNew->pprev ? pindexNew->pprev->nChainTx : 0) + pindexNew->nTx;\n+    pindexNew->nChainTx = 0;\n     pindexNew->nFile = pos.nFile;\n     pindexNew->nDataPos = pos.nPos;\n     pindexNew->nUndoPos = 0;\n-    pindexNew->nStatus = BLOCK_VALID_TRANSACTIONS | BLOCK_HAVE_DATA;\n-    setBlockIndexValid.insert(pindexNew);\n-\n-    if (!pblocktree->WriteBlockIndex(CDiskBlockIndex(pindexNew)))\n-        return state.Abort(_(\"Failed to write block index\"));\n-\n-    // New best?\n-    if (!ConnectBestBlock(state))\n-        return false;\n-\n-    if (pindexNew == pindexBest)\n-    {\n-        // Clear fork warning if its no longer applicable\n-        CheckForkWarningConditions();\n-        // Notify UI to display prev block's coinbase if it was ours\n-        static uint256 hashPrevBestCoinBase;\n-        UpdatedTransaction(hashPrevBestCoinBase);\n-        hashPrevBestCoinBase = block.GetTxHash(0);\n-    } else\n-        CheckForkWarningConditionsOnNewFork(pindexNew);\n+    pindexNew->nStatus = (pindexNew->nStatus & ~BLOCK_HAVE_MASK) | BLOCK_HAVE_DATA;\n+    if ((pindexNew->nStatus & BLOCK_VALID_MASK) < BLOCK_VALID_TRANSACTIONS)\n+        pindexNew->nStatus = (pindexNew->nStatus & ~BLOCK_VALID_MASK) | BLOCK_VALID_TRANSACTIONS;\n \n-    if (!pblocktree->Flush())\n-        return state.Abort(_(\"Failed to sync block index\"));\n-\n-    uiInterface.NotifyBlocksChanged();\n-    return true;\n+    return pblocktree->WriteBlockIndex(CDiskBlockIndex(pindexNew));\n }\n \n \n@@ -2360,23 +2345,30 @@ bool FindUndoPos(CValidationState &state, int nFile, CDiskBlockPos &pos, unsigne\n }\n \n \n+bool CheckBlockHeader(const CBlockHeader &header, CValidationState &state, bool fCheckPOW)\n+{\n+    // Check proof of work matches claimed amount\n+    if (fCheckPOW && !CheckProofOfWork(header.GetHash(), header.nBits))\n+        return state.DoS(50, error(\"CheckBlockHeader() : proof of work failed\"));\n+\n+    // Check timestamp\n+    if (header.GetBlockTime() > GetAdjustedTime() + 2 * 60 * 60)\n+        return state.Invalid(error(\"CheckBlockHeader() : block timestamp too far in the future\"));\n+\n+    return true;\n+}\n+\n+\n bool CheckBlock(const CBlock& block, CValidationState& state, bool fCheckPOW, bool fCheckMerkleRoot)\n {\n     // These are checks that are independent of context\n-    // that can be verified before saving an orphan block.\n+    if (!CheckBlockHeader(block, state, fCheckPOW))\n+        return false;\n \n     // Size limits\n     if (block.vtx.empty() || block.vtx.size() > MAX_BLOCK_SIZE || ::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION) > MAX_BLOCK_SIZE)\n         return state.DoS(100, error(\"CheckBlock() : size limits failed\"));\n \n-    // Check proof of work matches claimed amount\n-    if (fCheckPOW && !CheckProofOfWork(block.GetHash(), block.nBits))\n-        return state.DoS(50, error(\"CheckBlock() : proof of work failed\"));\n-\n-    // Check timestamp\n-    if (block.GetBlockTime() > GetAdjustedTime() + 2 * 60 * 60)\n-        return state.Invalid(error(\"CheckBlock() : block timestamp too far in the future\"));\n-\n     // First transaction must be coinbase, the rest must not be\n     if (block.vtx.empty() || !block.vtx[0].IsCoinBase())\n         return state.DoS(100, error(\"CheckBlock() : first tx is not coinbase\"));\n@@ -2418,49 +2410,90 @@ bool CheckBlock(const CBlock& block, CValidationState& state, bool fCheckPOW, bo\n     return true;\n }\n \n-bool AcceptBlock(CBlock& block, CValidationState& state, CDiskBlockPos* dbp)\n+// Precondition: header passes CheckBlockHeader()\n+bool static AcceptBlockHeader(const CBlockHeader &block, CValidationState& state, CBlockIndex* &pindexNew)\n {\n-    // Check for duplicate\n     uint256 hash = block.GetHash();\n-    if (mapBlockIndex.count(hash))\n-        return state.Invalid(error(\"AcceptBlock() : block already in mapBlockIndex\"));\n+    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hash);\n+    if (mi != mapBlockIndex.end())\n+        pindexNew = mi->second;\n+    if (pindexNew && ((pindexNew->nStatus & BLOCK_FAILED_MASK) != 0 || (pindexNew->nStatus & BLOCK_VALID_MASK) >= BLOCK_VALID_TREE))\n+        return true;\n \n-    // Get prev block index\n-    CBlockIndex* pindexPrev = NULL;\n+    CBlockIndex *pindexPrev = NULL;\n     int nHeight = 0;\n     if (hash != Params().HashGenesisBlock()) {\n         map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(block.hashPrevBlock);\n         if (mi == mapBlockIndex.end())\n-            return state.DoS(10, error(\"AcceptBlock() : prev block not found\"));\n+            return state.DoS(10, error(\"AcceptBlockHeader() : prev block not found\"));\n         pindexPrev = (*mi).second;\n+        if (pindexPrev->nStatus & BLOCK_FAILED_MASK)\n+            return state.DoS(100, error(\"AcceptBlockHeader() : extended invalid chain\"));\n+        if (pindexPrev->nHeight == -1)\n+            return state.Invalid(error(\"AcceptBlockHeader() : %s extending orphan block %s\", hash.ToString().c_str(), pindexPrev->ToString().c_str()));\n+\n         nHeight = pindexPrev->nHeight+1;\n \n         // Check proof of work\n         if (block.nBits != GetNextWorkRequired(pindexPrev, &block))\n-            return state.DoS(100, error(\"AcceptBlock() : incorrect proof of work\"));\n+            return state.DoS(100, error(\"AcceptBlockHeader() : incorrect proof of work\"));\n \n         // Check timestamp against prev\n         if (block.GetBlockTime() <= pindexPrev->GetMedianTimePast())\n-            return state.Invalid(error(\"AcceptBlock() : block's timestamp is too early\"));\n+            return state.Invalid(error(\"AcceptBlockHeader() : block's timestamp is too early\"));\n \n-        // Check that all transactions are finalized\n-        BOOST_FOREACH(const CTransaction& tx, block.vtx)\n-            if (!IsFinalTx(tx, nHeight, block.GetBlockTime()))\n-                return state.DoS(10, error(\"AcceptBlock() : contains a non-final transaction\"));\n+        // Do not allow headers before a checkpoint we have reached already.\n+        if (nHeight <= Checkpoints::GetLastCheckpointHeight(pindexBestHeader->nHeight))\n+            return state.DoS(100, error(\"AcceptBlockHeader() : rewriting pre-checkpoint chain\"));\n \n         // Check that the block chain matches the known block chain up to a checkpoint\n         if (!Checkpoints::CheckBlock(nHeight, hash))\n-            return state.DoS(100, error(\"AcceptBlock() : rejected by checkpoint lock-in at %d\", nHeight));\n+            return state.DoS(100, error(\"AcceptBlockHeader() : rejected by checkpoint lock-in at %d\", nHeight));\n \n         // Reject block.nVersion=1 blocks when 95% (75% on testnet) of the network has upgraded:\n         if (block.nVersion < 2)\n         {\n             if ((!TestNet() && CBlockIndex::IsSuperMajority(2, pindexPrev, 950, 1000)) ||\n                 (TestNet() && CBlockIndex::IsSuperMajority(2, pindexPrev, 75, 100)))\n             {\n-                return state.Invalid(error(\"AcceptBlock() : rejected nVersion=1 block\"));\n+                return state.Invalid(error(\"AcceptBlockHeader() : rejected nVersion=1 block\"));\n             }\n         }\n+    }\n+\n+    // Construct new block index object\n+    if (pindexNew==NULL)\n+        pindexNew = InsertBlockIndex(hash, block);\n+\n+    if ((pindexNew->nStatus & BLOCK_VALID_MASK) < BLOCK_VALID_TREE)\n+        pindexNew->nStatus = (pindexNew->nStatus & ~BLOCK_VALID_MASK) | BLOCK_VALID_TREE;\n+    if (LinkOrphans(&block.hashPrevBlock))\n+        if (!SwitchToBestHeader(state))\n+            return false;\n+    if (!pblocktree->WriteBlockIndex(CDiskBlockIndex(pindexNew)))\n+        return state.Abort(_(\"Failed to write block index\"));\n+\n+    return true;\n+}\n+\n+// Precondition: block passes CheckBlock()\n+bool static AcceptBlock(CBlock& block, CValidationState& state)\n+{\n+    CBlockIndex *pindexNew = NULL;\n+    if (!AcceptBlockHeader(block, state, pindexNew))\n+        return false;\n+\n+    if (pindexNew->nStatus & BLOCK_HAVE_DATA || (pindexNew->nStatus & BLOCK_VALID_MASK) >= BLOCK_VALID_SCRIPTS)\n+        return true;\n+\n+    CBlockIndex *pindexPrev = pindexNew->pprev;\n+    int nHeight = pindexNew->nHeight;\n+    if (nHeight > 0) {\n+        // Check that all transactions are finalized\n+        BOOST_FOREACH(const CTransaction& tx, block.vtx)\n+            if (!IsFinalTx(tx, nHeight, block.GetBlockTime()))\n+                return state.DoS(10, error(\"AcceptBlock() : contains a non-final transaction\"));\n+\n         // Enforce block.nVersion=2 rule that the coinbase starts with serialized block height\n         if (block.nVersion >= 2)\n         {\n@@ -2480,28 +2513,20 @@ bool AcceptBlock(CBlock& block, CValidationState& state, CDiskBlockPos* dbp)\n     try {\n         unsigned int nBlockSize = ::GetSerializeSize(block, SER_DISK, CLIENT_VERSION);\n         CDiskBlockPos blockPos;\n-        if (dbp != NULL)\n-            blockPos = *dbp;\n-        if (!FindBlockPos(state, blockPos, nBlockSize+8, nHeight, block.nTime, dbp != NULL))\n+        if (!FindBlockPos(state, blockPos, nBlockSize+8, nHeight, block.nTime, false))\n             return error(\"AcceptBlock() : FindBlockPos failed\");\n-        if (dbp == NULL)\n-            if (!WriteBlockToDisk(block, blockPos))\n-                return state.Abort(_(\"Failed to write block\"));\n-        if (!AddToBlockIndex(block, state, blockPos))\n-            return error(\"AcceptBlock() : AddToBlockIndex failed\");\n+        if (!WriteBlockToDisk(block, blockPos))\n+            return state.Abort(_(\"Failed to write block\"));\n+        if (!WriteBlockPosition(pindexNew, block, blockPos))\n+            return state.Abort(_(\"Failed to write block position to index\"));\n+        if (!SwitchToBestBlock(state))\n+            return false;\n     } catch(std::runtime_error &e) {\n         return state.Abort(_(\"System error: \") + e.what());\n     }\n \n-    // Relay inventory, but don't relay old inventory during initial block download\n-    int nBlockEstimate = Checkpoints::GetTotalBlocksEstimate();\n-    if (hashBestChain == hash)\n-    {\n-        LOCK(cs_vNodes);\n-        BOOST_FOREACH(CNode* pnode, vNodes)\n-            if (nBestHeight > (pnode->nStartingHeight != -1 ? pnode->nStartingHeight - 2000 : nBlockEstimate))\n-                pnode->PushInventory(CInv(MSG_BLOCK, hash));\n-    }\n+    if (!pblocktree->Flush())\n+        return state.Abort(_(\"Failed to sync block index\"));\n \n     return true;\n }\n@@ -2518,92 +2543,43 @@ bool CBlockIndex::IsSuperMajority(int minVersion, const CBlockIndex* pstart, uns\n     return (nFound >= nRequired);\n }\n \n-void PushGetBlocks(CNode* pnode, CBlockIndex* pindexBegin, uint256 hashEnd)\n+bool ProcessBlockHeader(CValidationState &state, const CBlockHeader* pheader)\n {\n-    // Filter out duplicate requests\n-    if (pindexBegin == pnode->pindexLastGetBlocksBegin && hashEnd == pnode->hashLastGetBlocksEnd)\n-        return;\n-    pnode->pindexLastGetBlocksBegin = pindexBegin;\n-    pnode->hashLastGetBlocksEnd = hashEnd;\n+    uint256 hash = pheader->GetHash();\n+    if (mapBlockIndex.count(hash))\n+        return true;\n+\n+    // Preliminary checks\n+    if (!CheckBlockHeader(*pheader, state))\n+        return error(\"ProcessBlockHeader() : CheckBlockHeader FAILED\");\n \n-    pnode->PushMessage(\"getblocks\", CBlockLocator(pindexBegin), hashEnd);\n+    // Include in the block tree.\n+    CBlockIndex *pindexNew = NULL;\n+    if (!AcceptBlockHeader(*pheader, state, pindexNew))\n+        return error(\"ProcessBlockHeader() : AcceptBlockHeader FAILED\");\n+\n+    return true;\n }\n \n-bool ProcessBlock(CValidationState &state, CNode* pfrom, CBlock* pblock, CDiskBlockPos *dbp)\n+bool ProcessBlock(CValidationState &state, CBlock* pblock)\n {\n-    // Check for duplicate\n-    uint256 hash = pblock->GetHash();\n-    if (mapBlockIndex.count(hash))\n-        return state.Invalid(error(\"ProcessBlock() : already have block %d %s\", mapBlockIndex[hash]->nHeight, hash.ToString().c_str()));\n-    if (mapOrphanBlocks.count(hash))\n-        return state.Invalid(error(\"ProcessBlock() : already have block (orphan) %s\", hash.ToString().c_str()));\n-\n     // Preliminary checks\n+    // TODO: in case the transactions and merkle root match, but CheckBlock still fails, we can mark the block as permanently invalid.\n     if (!CheckBlock(*pblock, state))\n         return error(\"ProcessBlock() : CheckBlock FAILED\");\n \n-    CBlockIndex* pcheckpoint = Checkpoints::GetLastCheckpoint(mapBlockIndex);\n-    if (pcheckpoint && pblock->hashPrevBlock != hashBestChain)\n-    {\n-        // Extra checks to prevent \"fill up memory by spamming with bogus blocks\"\n-        int64 deltaTime = pblock->GetBlockTime() - pcheckpoint->nTime;\n-        if (deltaTime < 0)\n-        {\n-            return state.DoS(100, error(\"ProcessBlock() : block with timestamp before last checkpoint\"));\n-        }\n-        CBigNum bnNewBlock;\n-        bnNewBlock.SetCompact(pblock->nBits);\n-        CBigNum bnRequired;\n-        bnRequired.SetCompact(ComputeMinWork(pcheckpoint->nBits, deltaTime));\n-        if (bnNewBlock > bnRequired)\n-        {\n-            return state.DoS(100, error(\"ProcessBlock() : block with too little proof-of-work\"));\n-        }\n+    if (mapBlockIndex.count(pblock->hashPrevBlock) == 0) {\n+        // We received an orphan (block without known parent). This should not\n+        // ever happen.\n+        return state.DoS(20, error(\"ProcessBlock() : orphan block received\"));\n     }\n \n+    // Process the header, store the block to disk, and connect it if necessary.\n+    bool fSuccess = AcceptBlock(*pblock, state);\n \n-    // If we don't already have its previous block, shunt it off to holding area until we get it\n-    if (pblock->hashPrevBlock != 0 && !mapBlockIndex.count(pblock->hashPrevBlock))\n-    {\n-        LogPrintf(\"ProcessBlock: ORPHAN BLOCK, prev=%s\\n\", pblock->hashPrevBlock.ToString().c_str());\n-\n-        // Accept orphans as long as there is a node to request its parents from\n-        if (pfrom) {\n-            CBlock* pblock2 = new CBlock(*pblock);\n-            mapOrphanBlocks.insert(make_pair(hash, pblock2));\n-            mapOrphanBlocksByPrev.insert(make_pair(pblock2->hashPrevBlock, pblock2));\n-\n-            // Ask this guy to fill in what we're missing\n-            PushGetBlocks(pfrom, pindexBest, GetOrphanRoot(pblock2));\n-        }\n-        return true;\n-    }\n-\n-    // Store to disk\n-    if (!AcceptBlock(*pblock, state, dbp))\n+    if (!fSuccess)\n         return error(\"ProcessBlock() : AcceptBlock FAILED\");\n \n-    // Recursively process any orphan blocks that depended on this one\n-    vector<uint256> vWorkQueue;\n-    vWorkQueue.push_back(hash);\n-    for (unsigned int i = 0; i < vWorkQueue.size(); i++)\n-    {\n-        uint256 hashPrev = vWorkQueue[i];\n-        for (multimap<uint256, CBlock*>::iterator mi = mapOrphanBlocksByPrev.lower_bound(hashPrev);\n-             mi != mapOrphanBlocksByPrev.upper_bound(hashPrev);\n-             ++mi)\n-        {\n-            CBlock* pblockOrphan = (*mi).second;\n-            // Use a dummy CValidationState so someone can't setup nodes to counter-DoS based on orphan resolution (that is, feeding people an invalid block based on LegitBlockX in order to get anyone relaying LegitBlockX banned)\n-            CValidationState stateDummy;\n-            if (AcceptBlock(*pblockOrphan, stateDummy))\n-                vWorkQueue.push_back(pblockOrphan->GetHash());\n-            mapOrphanBlocks.erase(pblockOrphan->GetHash());\n-            delete pblockOrphan;\n-        }\n-        mapOrphanBlocksByPrev.erase(hashPrev);\n-    }\n-\n     LogPrintf(\"ProcessBlock: ACCEPTED\\n\");\n     return true;\n }\n@@ -2822,22 +2798,106 @@ FILE* OpenUndoFile(const CDiskBlockPos &pos, bool fReadOnly) {\n     return OpenDiskFile(pos, \"rev\", fReadOnly);\n }\n \n-CBlockIndex * InsertBlockIndex(uint256 hash)\n+bool static LinkOrphans(const uint256 *phashParent) {\n+    bool fWorkDone = false;\n+    const uint256 &hashGenesisBlock = Params().HashGenesisBlock();\n+\n+    deque<multimap<uint256, CBlockIndex*>::iterator> vTodo;\n+    if (phashParent) {\n+        map<uint256, CBlockIndex*>::iterator itpar = mapBlockIndex.find(*phashParent);\n+        if (*phashParent == uint256(0) || (itpar != mapBlockIndex.end() && itpar->second->nHeight != -1)) {\n+            multimap<uint256, CBlockIndex*>::iterator it = mapOrphanBlocksByPrev.find(*phashParent);\n+            while (it != mapOrphanBlocksByPrev.end() && it->first == *phashParent) {\n+                vTodo.push_back(it);\n+                it++;\n+            }\n+        }\n+    } else {\n+        // First find unconnected blocks whose parent is connected.\n+        for (multimap<uint256, CBlockIndex*>::iterator it = mapOrphanBlocksByPrev.begin(); it != mapOrphanBlocksByPrev.end(); ) {\n+            multimap<uint256, CBlockIndex*>::iterator itnow = it++;\n+            if (itnow->second->nHeight != -1) {\n+                mapOrphanBlocksByPrev.erase(itnow);\n+                continue;\n+            }\n+            map<uint256, CBlockIndex*>::iterator itprev = mapBlockIndex.find(itnow->first);\n+            if (itnow->first == uint256(0) || (itprev != mapBlockIndex.end() && itprev->second->nHeight != -1)) {\n+                vTodo.push_back(itnow);\n+            }\n+        }\n+    }\n+\n+    // Iterate as long as such parent-connected unconnecteds exist, adding children to the\n+    // queue after adding a node.\n+    while (!vTodo.empty()) {\n+        multimap<uint256, CBlockIndex*>::iterator it = vTodo.front();\n+        uint256 hashPrev = it->first;\n+        CBlockIndex *pindex = it->second;\n+        mapOrphanBlocksByPrev.erase(it);\n+        vTodo.pop_front();\n+        if (hashPrev == uint256(0)) {\n+            if (pindex->GetBlockHash() != hashGenesisBlock) {\n+                continue;\n+            }\n+            // Deal with the genesis block specially.\n+            pindexGenesisBlock = pindex;\n+            pindex->nHeight = 0;\n+            pindex->nTx = 1;\n+            pindex->nChainTx = 1;\n+            pindex->nChainWork = pindex->GetBlockWork().getuint256();\n+            pindex->nStatus = (pindex->nStatus & ~BLOCK_VALID_MASK) | BLOCK_VALID_TRANSACTIONS;\n+            pindex->nStatus &= ~BLOCK_FAILED_MASK;\n+        } else {\n+            pindex->pprev = mapBlockIndex[hashPrev];\n+            pindex->nHeight = pindex->pprev->nHeight + 1;\n+            pindex->nChainWork = pindex->pprev->nChainWork + pindex->GetBlockWork().getuint256();\n+            if (pindex->nTx && pindex->pprev->nChainTx)\n+                pindex->nChainTx = pindex->pprev->nChainTx + pindex->nTx;\n+            if (pindex->pprev->nStatus & BLOCK_FAILED_MASK) {\n+               pindex->nStatus |= BLOCK_FAILED_CHILD;\n+               if (pindexBestInvalid == NULL || pindex->nChainWork > pindexBestInvalid->nChainWork)\n+                   pindexBestInvalid = pindex;\n+            }\n+        }\n+        fWorkDone = true;\n+        if (!(pindex->nStatus & BLOCK_FAILED_MASK) && (pindex->nStatus & BLOCK_VALID_TREE))\n+            setBlockIndexValid.insert(pindex);\n+        const uint256 &hashBlock = pindex->GetBlockHash();\n+        multimap<uint256, CBlockIndex*>::iterator itadd = mapOrphanBlocksByPrev.lower_bound(hashBlock);\n+        while (itadd != mapOrphanBlocksByPrev.end() && itadd->first == hashBlock)\n+            vTodo.push_back(itadd++);\n+    }\n+\n+    return fWorkDone;\n+}\n+\n+CBlockIndex * InsertBlockIndex(const uint256 &hash, const CBlockHeader &header)\n {\n     if (hash == 0)\n         return NULL;\n \n+    CBlockIndex* pindexNew = NULL;\n+\n     // Return existing\n     map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hash);\n     if (mi != mapBlockIndex.end())\n-        return (*mi).second;\n+        pindexNew = mi->second;\n \n     // Create new\n-    CBlockIndex* pindexNew = new CBlockIndex();\n-    if (!pindexNew)\n-        throw runtime_error(\"LoadBlockIndex() : new CBlockIndex failed\");\n-    mi = mapBlockIndex.insert(make_pair(hash, pindexNew)).first;\n-    pindexNew->phashBlock = &((*mi).first);\n+    if (pindexNew == NULL) {\n+        pindexNew = new CBlockIndex();\n+        mi = mapBlockIndex.insert(make_pair(hash, pindexNew)).first;\n+        pindexNew->phashBlock = &((*mi).first);\n+        pindexNew->nVersion = header.nVersion;\n+        pindexNew->hashMerkleRoot = header.hashMerkleRoot;\n+        pindexNew->nTime = header.nTime;\n+        pindexNew->nBits = header.nBits;\n+        pindexNew->nNonce = header.nNonce;\n+    }\n+\n+    // Store hashPrev if orphan.\n+    if (pindexNew->nHeight == -1)\n+        mapOrphanBlocksByPrev.insert(make_pair(header.hashPrevBlock, pindexNew));\n \n     return pindexNew;\n }\n@@ -2847,26 +2907,9 @@ bool static LoadBlockIndexDB()\n     if (!pblocktree->LoadBlockIndexGuts())\n         return false;\n \n+    LinkOrphans();\n     boost::this_thread::interruption_point();\n \n-    // Calculate nChainWork\n-    vector<pair<int, CBlockIndex*> > vSortedByHeight;\n-    vSortedByHeight.reserve(mapBlockIndex.size());\n-    BOOST_FOREACH(const PAIRTYPE(uint256, CBlockIndex*)& item, mapBlockIndex)\n-    {\n-        CBlockIndex* pindex = item.second;\n-        vSortedByHeight.push_back(make_pair(pindex->nHeight, pindex));\n-    }\n-    sort(vSortedByHeight.begin(), vSortedByHeight.end());\n-    BOOST_FOREACH(const PAIRTYPE(int, CBlockIndex*)& item, vSortedByHeight)\n-    {\n-        CBlockIndex* pindex = item.second;\n-        pindex->nChainWork = (pindex->pprev ? pindex->pprev->nChainWork : 0) + pindex->GetBlockWork().getuint256();\n-        pindex->nChainTx = (pindex->pprev ? pindex->pprev->nChainTx : 0) + pindex->nTx;\n-        if ((pindex->nStatus & BLOCK_VALID_MASK) >= BLOCK_VALID_TRANSACTIONS && !(pindex->nStatus & BLOCK_FAILED_MASK))\n-            setBlockIndexValid.insert(pindex);\n-    }\n-\n     // Load block file info\n     pblocktree->ReadLastBlockFile(nLastBlockFile);\n     LogPrintf(\"LoadBlockIndexDB(): last block file = %i\\n\", nLastBlockFile);\n@@ -2876,7 +2919,6 @@ bool static LoadBlockIndexDB()\n     // Load nBestInvalidWork, OK if it doesn't exist\n     CBigNum bnBestInvalidWork;\n     pblocktree->ReadBestInvalidWork(bnBestInvalidWork);\n-    nBestInvalidWork = bnBestInvalidWork.getuint256();\n \n     // Check whether we need to continue reindexing\n     bool fReindexing = false;\n@@ -2889,21 +2931,22 @@ bool static LoadBlockIndexDB()\n \n     // Load hashBestChain pointer to end of best chain\n     pindexBest = pcoinsTip->GetBestBlock();\n+    if (pindexBest == NULL && pindexGenesisBlock)\n+        pindexBest = pindexGenesisBlock;\n     if (pindexBest == NULL)\n         return true;\n-    hashBestChain = pindexBest->GetBlockHash();\n-    nBestHeight = pindexBest->nHeight;\n-    nBestChainWork = pindexBest->nChainWork;\n \n-    // register best chain\n-    CBlockIndex *pindex = pindexBest;\n-    vBlockIndexByHeight.resize(pindexBest->nHeight + 1);\n-    while(pindex != NULL) {\n-         vBlockIndexByHeight[pindex->nHeight] = pindex;\n-         pindex = pindex->pprev;\n-    }\n+    pindexBestHeader = pindexBest;\n+    vBlockIndexByHeight.resize(1);\n+    vBlockIndexByHeight[0] = pindexGenesisBlock;\n+\n+    CValidationState state;\n+    SwitchToBestHeader(state);\n+\n+    CheckForkWarningConditions(true);\n+\n     LogPrintf(\"LoadBlockIndexDB(): hashBestChain=%s  height=%d date=%s\\n\",\n-        hashBestChain.ToString().c_str(), nBestHeight,\n+        pindexBest->GetBlockHash().ToString().c_str(), pindexBest->nHeight,\n         DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", pindexBest->GetBlockTime()).c_str());\n \n     return true;\n@@ -2917,8 +2960,8 @@ bool VerifyDB(int nCheckLevel, int nCheckDepth)\n     // Verify blocks in the best chain\n     if (nCheckDepth <= 0)\n         nCheckDepth = 1000000000; // suffices until the year 19000\n-    if (nCheckDepth > nBestHeight)\n-        nCheckDepth = nBestHeight;\n+    if (nCheckDepth > pindexBest->nHeight)\n+        nCheckDepth = pindexBest->nHeight;\n     nCheckLevel = std::max(0, std::min(4, nCheckLevel));\n     LogPrintf(\"Verifying last %i blocks at level %i\\n\", nCheckDepth, nCheckLevel);\n     CCoinsViewCache coins(*pcoinsTip, true);\n@@ -2929,7 +2972,7 @@ bool VerifyDB(int nCheckLevel, int nCheckDepth)\n     for (CBlockIndex* pindex = pindexBest; pindex && pindex->pprev; pindex = pindex->pprev)\n     {\n         boost::this_thread::interruption_point();\n-        if (pindex->nHeight < nBestHeight-nCheckDepth)\n+        if (pindex->nHeight < pindexBest->nHeight-nCheckDepth)\n             break;\n         CBlock block;\n         // check level 0: read from disk\n@@ -2987,11 +3030,9 @@ void UnloadBlockIndex()\n     mapBlockIndex.clear();\n     setBlockIndexValid.clear();\n     pindexGenesisBlock = NULL;\n-    nBestHeight = 0;\n-    nBestChainWork = 0;\n-    nBestInvalidWork = 0;\n-    hashBestChain = 0;\n     pindexBest = NULL;\n+    pindexBestHeader = NULL;\n+    pindexBestInvalid = NULL;\n }\n \n bool LoadBlockIndex()\n@@ -3018,15 +3059,10 @@ bool InitBlockIndex() {\n         try {\n             CBlock &block = const_cast<CBlock&>(Params().GenesisBlock());\n             // Start new block file\n-            unsigned int nBlockSize = ::GetSerializeSize(block, SER_DISK, CLIENT_VERSION);\n             CDiskBlockPos blockPos;\n             CValidationState state;\n-            if (!FindBlockPos(state, blockPos, nBlockSize+8, 0, block.nTime))\n-                return error(\"LoadBlockIndex() : FindBlockPos failed\");\n-            if (!WriteBlockToDisk(block, blockPos))\n-                return error(\"LoadBlockIndex() : writing genesis block to disk failed\");\n-            if (!AddToBlockIndex(block, state, blockPos))\n-                return error(\"LoadBlockIndex() : genesis block not accepted\");\n+            if (!AcceptBlock(block, state))\n+                return error(\"LoadBlockIndex() : accepting genesis header failed\");\n         } catch(std::runtime_error &e) {\n             return error(\"LoadBlockIndex() : failed to initialize block database: %s\", e.what());\n         }\n@@ -3157,14 +3193,27 @@ bool LoadExternalBlockFile(FILE* fileIn, CDiskBlockPos *dbp)\n \n                 // process block\n                 if (nBlockPos >= nStartByte) {\n+                    CValidationState state;\n+                    if (!CheckBlock(block, state))\n+                        continue;\n                     LOCK(cs_main);\n                     if (dbp)\n                         dbp->nPos = nBlockPos;\n-                    CValidationState state;\n-                    if (ProcessBlock(state, NULL, &block, dbp))\n-                        nLoaded++;\n-                    if (state.IsError())\n-                        break;\n+\n+                    CBlockIndex *pindex = InsertBlockIndex(block.GetHash(), block);\n+                    if (pindex->nHeight == -1) {\n+                        pindex->nFile = dbp->nFile;\n+                        pindex->nDataPos = nBlockPos;\n+                        pindex->nUndoPos = 0;\n+                        pindex->nTx = block.vtx.size();\n+                        pindex->nStatus = BLOCK_VALID_TRANSACTIONS | BLOCK_HAVE_DATA;\n+                    }\n+                    FindBlockPos(state, *dbp, nSize+8, 0, pindex->nTime, true);\n+                    if (LinkOrphans(&block.hashPrevBlock)) {\n+                        SwitchToBestHeader(state);\n+                        SwitchToBestBlock(state);\n+                        pblocktree->WriteBlockIndex(CDiskBlockIndex(pindex));\n+                    }\n                 }\n             } catch (std::exception &e) {\n                 LogPrintf(\"%s() : Deserialize or I/O error caught during load\\n\", __PRETTY_FUNCTION__);\n@@ -3187,7 +3236,6 @@ bool LoadExternalBlockFile(FILE* fileIn, CDiskBlockPos *dbp)\n \n \n \n-\n //////////////////////////////////////////////////////////////////////////////\n //\n // CAlert\n@@ -3276,8 +3324,7 @@ bool static AlreadyHave(const CInv& inv)\n                 pcoinsTip->HaveCoins(inv.hash);\n         }\n     case MSG_BLOCK:\n-        return mapBlockIndex.count(inv.hash) ||\n-               mapOrphanBlocks.count(inv.hash);\n+        return mapBlockIndex.count(inv.hash);\n     }\n     // Don't know what it is, just say we already got one\n     return true;\n@@ -3343,7 +3390,7 @@ void static ProcessGetData(CNode* pfrom)\n                         // and we want it right after the last block so they don't\n                         // wait for other stuff first.\n                         vector<CInv> vInv;\n-                        vInv.push_back(CInv(MSG_BLOCK, hashBestChain));\n+                        vInv.push_back(CInv(MSG_BLOCK, pindexBest->GetBlockHash()));\n                         pfrom->PushMessage(\"inv\", vInv);\n                         pfrom->hashContinue = 0;\n                     }\n@@ -3424,10 +3471,13 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n         CAddress addrFrom;\n         uint64 nNonce = 1;\n         vRecv >> pfrom->nVersion >> pfrom->nServices >> nTime >> addrMe;\n-        if (pfrom->nVersion < MIN_PROTO_VERSION)\n-        {\n+        if ((pfrom->nVersion < MIN_PROTO_VERSION) ||\n+            (!pfrom->fInbound && pfrom->nVersion < GETHEADERS_VERSION)) {\n             // Since February 20, 2012, the protocol is initiated at version 209,\n-            // and earlier versions are no longer supported\n+            // and earlier versions are no longer supported.\n+            // For headers-based sync, we rely on peers supporting the 'getheaders'\n+            // command. As long as we restrict block fetching to outbound peers,\n+            // we probably want at least those to support it.\n             LogPrintf(\"partner %s using obsolete version %i; disconnecting\\n\", pfrom->addr.ToString().c_str(), pfrom->nVersion);\n             pfrom->fDisconnect = true;\n             return false;\n@@ -3462,7 +3512,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n \n         // Be shy and don't send version until we hear\n         if (pfrom->fInbound)\n-            pfrom->PushVersion();\n+            pfrom->PushVersion(pindexBest->nHeight);\n \n         pfrom->fClient = !(pfrom->nServices & NODE_NETWORK);\n \n@@ -3507,8 +3557,6 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n         pfrom->fSuccessfullyConnected = true;\n \n         LogPrintf(\"receive version message: version %d, blocks=%d, us=%s, them=%s, peer=%s\\n\", pfrom->nVersion, pfrom->nStartingHeight, addrMe.ToString().c_str(), addrFrom.ToString().c_str(), pfrom->addr.ToString().c_str());\n-\n-        cPeerBlockCounts.input(pfrom->nStartingHeight);\n     }\n \n \n@@ -3603,15 +3651,6 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n             return error(\"message inv size() = %\"PRIszu\"\", vInv.size());\n         }\n \n-        // find last block in inv vector\n-        unsigned int nLastBlock = (unsigned int)(-1);\n-        for (unsigned int nInv = 0; nInv < vInv.size(); nInv++) {\n-            if (vInv[vInv.size() - 1 - nInv].type == MSG_BLOCK) {\n-                nLastBlock = vInv.size() - 1 - nInv;\n-                break;\n-            }\n-        }\n-\n         LOCK(cs_main);\n \n         for (unsigned int nInv = 0; nInv < vInv.size(); nInv++)\n@@ -3624,22 +3663,34 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n             bool fAlreadyHave = AlreadyHave(inv);\n             LogPrint(\"net\", \"  got inventory: %s  %s\\n\", inv.ToString().c_str(), fAlreadyHave ? \"have\" : \"new\");\n \n-            if (!fAlreadyHave) {\n-                if (!fImporting && !fReindex)\n-                    pfrom->AskFor(inv);\n-            } else if (inv.type == MSG_BLOCK && mapOrphanBlocks.count(inv.hash)) {\n-                PushGetBlocks(pfrom, pindexBest, GetOrphanRoot(mapOrphanBlocks[inv.hash]));\n-            } else if (nInv == nLastBlock) {\n-                // In case we are on a very long side-chain, it is possible that we already have\n-                // the last block in an inv bundle sent in response to getblocks. Try to detect\n-                // this situation and push another getblocks to continue.\n-                PushGetBlocks(pfrom, mapBlockIndex[inv.hash], uint256(0));\n-                if (fDebug)\n-                    LogPrintf(\"force request: %s\\n\", inv.ToString().c_str());\n-            }\n-\n             // Track requests for our stuff\n             Inventory(inv.hash);\n+\n+            if (fAlreadyHave)\n+                continue;\n+\n+            if (inv.type == MSG_BLOCK) {\n+                std::map<uint256, CBlockIndex*>::iterator it = mapBlockIndex.find(inv.hash);\n+                if (it != mapBlockIndex.end()) {\n+                    CBlockIndex *pindex = it->second;\n+                    if (pfrom->pindexLastBlock == NULL || pindex->nChainWork >= pfrom->pindexLastBlock->nChainWork)\n+                        pfrom->pindexLastBlock = pindex;\n+                } else {\n+                    pfrom->hashLastBlock = inv.hash;\n+                }\n+\n+                // First request the headers preceeding the announced block. In the normal fully-synced\n+                // case where a new block is announced that succeeds the current tip (no reorganization),\n+                // there are no such headers.\n+                // Secondly, and only when we are fully synced, we request the announced block afterwards,\n+                // to avoid an extra round-trip. Note that we *must* first ask for the headers, so by the\n+                // time the block arrives, the header chain leading up to it is already validated. Not\n+                // doing this will result in the received block being rejected as an orphan.\n+                pfrom->PushMessage(\"getheaders\", CBlockLocator(pindexBestHeader), inv.hash);\n+            }\n+\n+            if (!IsInitialBlockDownload())\n+                pfrom->AskFor(inv);\n         }\n     }\n \n@@ -3681,7 +3732,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n             pindex = pindex->GetNextInMainChain();\n         int nLimit = 500;\n         LogPrint(\"net\", \"getblocks %d to %s limit %d\\n\", (pindex ? pindex->nHeight : -1), hashStop.ToString().c_str(), nLimit);\n-        for (; pindex; pindex = pindex->GetNextInMainChain())\n+        for (; pindex && pindex->nHeight <= pindexBest->nHeight; pindex = pindex->GetNextInMainChain())\n         {\n             if (pindex->GetBlockHash() == hashStop)\n             {\n@@ -3730,7 +3781,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n         vector<CBlock> vHeaders;\n         int nLimit = 2000;\n         LogPrint(\"net\", \"getheaders %d to %s\\n\", (pindex ? pindex->nHeight : -1), hashStop.ToString().c_str());\n-        for (; pindex; pindex = pindex->GetNextInMainChain())\n+        for (; pindex && pindex->nHeight <= pindexBest->nHeight; pindex = pindex->GetNextInMainChain())\n         {\n             vHeaders.push_back(pindex->GetBlockHeader());\n             if (--nLimit <= 0 || pindex->GetBlockHash() == hashStop)\n@@ -3829,11 +3880,58 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n         LOCK(cs_main);\n \n         CValidationState state;\n-        if (ProcessBlock(state, pfrom, &block))\n-            mapAlreadyAskedFor.erase(inv);\n+        ProcessBlock(state, &block);\n         int nDoS;\n         if (state.IsInvalid(nDoS))\n             pfrom->Misbehaving(nDoS);\n+\n+        std::map<uint256, CBlockIndex*>::iterator it = mapBlockIndex.find(inv.hash);\n+        if (it != mapBlockIndex.end() && it->second->nStatus & BLOCK_HAVE_DATA) {\n+            pfrom->setBlocksAskedFor.erase(it->second);\n+            mapBlocksAskedFor.erase(it->second);\n+            mapAlreadyAskedFor.erase(inv);\n+        }\n+    }\n+\n+\n+    else if (strCommand == \"headers\" && !fImporting && !fReindex)\n+    {\n+        std::vector<CBlock> vBlocks;\n+        vRecv >> vBlocks;\n+\n+        if (vBlocks.size() == 0)\n+            return true;\n+\n+        CBlockIndex *pindexBefore = pindexBestHeader;\n+\n+        CValidationState state;\n+        BOOST_FOREACH(const CBlock &block, vBlocks) {\n+            if (!ProcessBlockHeader(state, &block)) {\n+                int nDoS;\n+                if (state.IsInvalid(nDoS))\n+                    pfrom->Misbehaving(nDoS);\n+                break;\n+            }\n+        }\n+\n+        if (pindexBestHeader != pindexBefore) {\n+            LogPrint(\"net\", \"received %i headers: %s  height=%i->%i  log2_work=%.8g  date=%s\\n\",\n+              (int)vBlocks.size(), pindexBestHeader->GetBlockHash().ToString().c_str(),\n+              pindexBefore ? pindexBefore->nHeight : -1, pindexBestHeader->nHeight,\n+              log(pindexBestHeader->nChainWork.getdouble())/log(2.0),\n+              DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", pindexBestHeader->GetBlockTime()).c_str());\n+\n+            // Assume the headers are in order, so only check the last one to update pindexLastBlock.\n+            std::map<uint256, CBlockIndex*>::iterator it = mapBlockIndex.find(vBlocks.back().GetHash());\n+            if (it != mapBlockIndex.end()) {\n+                CBlockIndex *pindex = it->second;\n+                if (pfrom->pindexLastBlock == NULL || pindex->nChainWork >= pfrom->pindexLastBlock->nChainWork)\n+                    pfrom->pindexLastBlock = it->second;\n+            }\n+\n+            // Continue syncing from this node.\n+            pfrom->PushMessage(\"getheaders\", CBlockLocator(pindexBestHeader), uint256(0));\n+        }\n     }\n \n \n@@ -4173,7 +4271,7 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n     // Start block sync\n     if (pto->fStartSync && !fImporting && !fReindex) {\n         pto->fStartSync = false;\n-        PushGetBlocks(pto, pindexBest, uint256(0));\n+        pto->PushMessage(\"getheaders\", CBlockLocator(pindexBestHeader), uint256(0));\n     }\n \n     // Resend wallet transactions that haven't gotten in a block yet\n@@ -4241,10 +4339,52 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n     if (!vInv.empty())\n         pto->PushMessage(\"inv\", vInv);\n \n+    // Update pindexLastBlock\n+    if (pto->hashLastBlock != 0) {\n+        std::map<uint256, CBlockIndex*>::iterator it = mapBlockIndex.find(pto->hashLastBlock);\n+        if (it != mapBlockIndex.end()) {\n+            if (pto->pindexLastBlock == NULL || it->second->nChainWork >= pto->pindexLastBlock->nChainWork)\n+                pto->pindexLastBlock = it->second;\n+            pto->hashLastBlock = 0;\n+        }\n+    }\n+\n     //\n-    // Message: getdata\n+    // Message: getdata (blocks)\n     //\n     vector<CInv> vGetData;\n+    int nLastHeight = std::min(pindexBestHeader->nHeight, pto->pindexLastBlock ? pto->pindexLastBlock->nHeight : pto->nStartingHeight);\n+    if (pindexBest && !fReindex && !fImporting && pto->nServices & NODE_NETWORK && !pto->fInbound && nLastHeight > pindexBest->nHeight) {\n+        if (setHeightMissing.empty()) {\n+            // We're stalled.\n+            if (mapBlocksAskedFor.size() == pto->setBlocksAskedFor.size() && mapBlocksAskedFor.begin()->second + 30 < GetTime()) {\n+                // This peer is the one stalling everyone!\n+                LogPrintf(\"Block download stalled by %s; disconnecting\\n\", pto->addr.ToString().c_str());\n+                pto->fDisconnect = true;\n+            }\n+        }\n+        while ((int)pto->setBlocksAskedFor.size() < MAX_BLOCKS_IN_TRANSIT_PER_PEER && !setHeightMissing.empty()) {\n+            if (4*pto->setBlocksAskedFor.size() > setHeightMissing.size() + mapBlocksAskedFor.size())\n+                break;\n+            std::set<int>::iterator it = setHeightMissing.begin();\n+            int nHeight = *it;\n+            if (nHeight > nLastHeight)\n+                break;\n+            CBlockIndex *pindex = vBlockIndexByHeight[nHeight];\n+            if (mapAlreadyAskedFor.count(CInv(MSG_BLOCK, pindex->GetBlockHash())))\n+                break;\n+            setHeightMissing.erase(it);\n+            pto->setBlocksAskedFor.insert(pindex);\n+            mapBlocksAskedFor[pindex] = GetTime();\n+            vGetData.push_back(CInv(MSG_BLOCK, pindex->GetBlockHash()));\n+        }\n+        if (vGetData.size())\n+            LogPrintf(\"Requesting %i blocks from %s\\n\", (int)vGetData.size(), pto->addr.ToString().c_str());\n+    }\n+\n+    //\n+    // Message: getdata (others)\n+    //\n     int64 nNow = GetTime() * 1000000;\n     while (!pto->mapAskFor.empty() && (*pto->mapAskFor.begin()).first <= nNow)\n     {\n@@ -4268,6 +4408,26 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n     return true;\n }\n \n+void FinalizeNode(CNode *pnode) {\n+    // Do not bother grabbing the lock if not necessary.\n+    if (pnode->setBlocksAskedFor.empty())\n+        return;\n+\n+    LOCK(cs_main);\n+\n+    BOOST_FOREACH(CBlockIndex *pindex, pnode->setBlocksAskedFor) {\n+        mapBlocksAskedFor.erase(pindex);\n+        UpdateMissingHeight(pindex->nHeight);\n+    }\n+}\n+\n+void InitializeNode(CNode *pnode) {\n+    // Be shy and don't send version until we hear.\n+    if (pnode->hSocket != INVALID_SOCKET && !pnode->fInbound) {\n+        LOCK(cs_main);\n+        pnode->PushVersion(pindexBest->nHeight);\n+    }\n+}\n \n \n \n@@ -4284,12 +4444,6 @@ class CMainCleanup\n             delete (*it1).second;\n         mapBlockIndex.clear();\n \n-        // orphan blocks\n-        std::map<uint256, CBlock*>::iterator it2 = mapOrphanBlocks.begin();\n-        for (; it2 != mapOrphanBlocks.end(); it2++)\n-            delete (*it2).second;\n-        mapOrphanBlocks.clear();\n-\n         // orphan transactions\n         mapOrphanTransactions.clear();\n     }"
      },
      {
        "sha": "db3190d1e4914484f66939d643d5d71db519ef12",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 29,
        "deletions": 36,
        "changes": 65,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b230a6599e884e158fe49e2cf946801eea83dcaa/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b230a6599e884e158fe49e2cf946801eea83dcaa/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=b230a6599e884e158fe49e2cf946801eea83dcaa",
        "patch": "@@ -58,6 +58,11 @@ static const unsigned int LOCKTIME_THRESHOLD = 500000000; // Tue Nov  5 00:53:20\n static const int MAX_SCRIPTCHECK_THREADS = 16;\n /** Default amount of block size reserved for high-priority transactions (in bytes) */\n static const int DEFAULT_BLOCK_PRIORITY_SIZE = 27000;\n+/** Number of blocks that can be requested at any given time. */\n+static const int MAX_BLOCKS_IN_TRANSIT = 1008;\n+/** Number of blocks that can be requested at any given time. */\n+static const int MAX_BLOCKS_IN_TRANSIT_PER_PEER = 32;\n+\n #ifdef USE_UPNP\n static const int fHaveUPnP = true;\n #else\n@@ -76,12 +81,10 @@ extern CCriticalSection cs_main;\n extern std::map<uint256, CBlockIndex*> mapBlockIndex;\n extern std::vector<CBlockIndex*> vBlockIndexByHeight;\n extern std::set<CBlockIndex*, CBlockIndexWorkComparator> setBlockIndexValid;\n-extern CBlockIndex* pindexGenesisBlock;\n-extern int nBestHeight;\n-extern uint256 nBestChainWork;\n-extern uint256 nBestInvalidWork;\n-extern uint256 hashBestChain;\n-extern CBlockIndex* pindexBest;\n+extern CBlockIndex* pindexGenesisBlock; // Pointer to the genesis block index entry.\n+extern CBlockIndex* pindexBest; // Pointer to the block index entry corresponding to pcoinsTip (until where we are synchronized).\n+extern CBlockIndex* pindexBestHeader; // Pointer to the block index entry corresponding to the best known header (until where we are headers-synchronized).\n+extern CBlockIndex* pindexBestInvalid; // Pointer to the invalid block index entry with the highest nChainWork (if any).\n extern unsigned int nTransactionsUpdated;\n extern uint64 nLastBlockTx;\n extern uint64 nLastBlockSize;\n@@ -131,10 +134,10 @@ void RegisterNodeSignals(CNodeSignals& nodeSignals);\n /** Unregister a network node */\n void UnregisterNodeSignals(CNodeSignals& nodeSignals);\n \n-void PushGetBlocks(CNode* pnode, CBlockIndex* pindexBegin, uint256 hashEnd);\n-\n+/** Process an incoming block header */\n+bool ProcessBlockHeader(CValidationState &state, const CBlockHeader* pheader);\n /** Process an incoming block */\n-bool ProcessBlock(CValidationState &state, CNode* pfrom, CBlock* pblock, CDiskBlockPos *dbp = NULL);\n+bool ProcessBlock(CValidationState &state, CBlock* pblock);\n /** Check whether enough disk space is available for an incoming block */\n bool CheckDiskSpace(uint64 nAdditionalBytes = 0);\n /** Open a block file (blk?????.dat) */\n@@ -165,25 +168,23 @@ void ThreadScriptCheck();\n bool CheckProofOfWork(uint256 hash, unsigned int nBits);\n /** Calculate the minimum amount of work a received block needs, without knowing its direct parent */\n unsigned int ComputeMinWork(unsigned int nBase, int64 nTime);\n-/** Get the number of active peers */\n-int GetNumBlocksOfPeers();\n /** Check whether we are doing an initial block download (synchronizing from disk or network) */\n bool IsInitialBlockDownload();\n /** Format a string that describes several potential problems detected by the core */\n std::string GetWarnings(std::string strFor);\n /** Retrieve a transaction (from memory pool, or from disk, if possible) */\n bool GetTransaction(const uint256 &hash, CTransaction &tx, uint256 &hashBlock, bool fAllowSlow = false);\n /** Connect/disconnect blocks until pindexNew is the new tip of the active block chain */\n-bool SetBestChain(CValidationState &state, CBlockIndex* pindexNew);\n+bool SwitchToBestHeader(CValidationState &state);\n /** Find the best known block, and make it the tip of the block chain */\n-bool ConnectBestBlock(CValidationState &state);\n+bool SwitchToBestBlock(CValidationState &state);\n int64 GetBlockValue(int nHeight, int64 nFees);\n unsigned int GetNextWorkRequired(const CBlockIndex* pindexLast, const CBlockHeader *pblock);\n \n void UpdateTime(CBlockHeader& block, const CBlockIndex* pindexPrev);\n \n /** Create a new block index entry for a given block hash */\n-CBlockIndex * InsertBlockIndex(uint256 hash);\n+CBlockIndex * InsertBlockIndex(const uint256 &hash, const CBlockHeader &header);\n /** Verify a signature */\n bool VerifySignature(const CCoins& txFrom, const CTransaction& txTo, unsigned int nIn, unsigned int flags, int nHashType);\n /** Abort with a message */\n@@ -597,16 +598,10 @@ bool DisconnectBlock(CBlock& block, CValidationState& state, CBlockIndex* pindex\n // Apply the effects of this block (with given index) on the UTXO set represented by coins\n bool ConnectBlock(CBlock& block, CValidationState& state, CBlockIndex* pindex, CCoinsViewCache& coins, bool fJustCheck = false);\n \n-// Add this block to the block index, and if necessary, switch the active block chain to this\n-bool AddToBlockIndex(CBlock& block, CValidationState& state, const CDiskBlockPos& pos);\n-\n // Context-independent validity checks\n+bool CheckBlockHeader(const CBlockHeader& header, CValidationState& state, bool fCheckPOW = true);\n bool CheckBlock(const CBlock& block, CValidationState& state, bool fCheckPOW = true, bool fCheckMerkleRoot = true);\n \n-// Store block on disk\n-// if dbp is provided, the file is known to already reside on disk\n-bool AcceptBlock(CBlock& block, CValidationState& state, CDiskBlockPos* dbp = NULL);\n-\n \n \n class CBlockFileInfo\n@@ -735,7 +730,7 @@ class CBlockIndex\n     {\n         phashBlock = NULL;\n         pprev = NULL;\n-        nHeight = 0;\n+        nHeight = -1;\n         nFile = 0;\n         nDataPos = 0;\n         nUndoPos = 0;\n@@ -751,7 +746,7 @@ class CBlockIndex\n         nNonce         = 0;\n     }\n \n-    CBlockIndex(CBlockHeader& block)\n+    CBlockIndex(const CBlockHeader& block)\n     {\n         phashBlock = NULL;\n         pprev = NULL;\n@@ -830,11 +825,6 @@ class CBlockIndex\n         return nHeight+1 >= (int)vBlockIndexByHeight.size() ? NULL : vBlockIndexByHeight[nHeight+1];\n     }\n \n-    bool CheckIndex() const\n-    {\n-        return CheckProofOfWork(GetBlockHash(), nBits);\n-    }\n-\n     enum { nMedianTimeSpan=11 };\n \n     int64 GetMedianTimePast() const\n@@ -937,18 +927,21 @@ class CDiskBlockIndex : public CBlockIndex\n         READWRITE(nNonce);\n     )\n \n+    CBlockHeader GetBlockHeader() const {\n+        CBlockHeader ret = CBlockIndex::GetBlockHeader();\n+        ret.hashPrevBlock = hashPrev;\n+        return ret;\n+    }\n+\n     uint256 GetBlockHash() const\n     {\n-        CBlockHeader block;\n-        block.nVersion        = nVersion;\n-        block.hashPrevBlock   = hashPrev;\n-        block.hashMerkleRoot  = hashMerkleRoot;\n-        block.nTime           = nTime;\n-        block.nBits           = nBits;\n-        block.nNonce          = nNonce;\n-        return block.GetHash();\n+        return GetBlockHeader().GetHash();\n     }\n \n+    bool CheckIndex() const\n+    {\n+        return CheckProofOfWork(GetBlockHash(), nBits);\n+    }\n \n     std::string ToString() const\n     {"
      },
      {
        "sha": "f7a1884b042cade8f372894a1d09f06cd2b20b99",
        "filename": "src/miner.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b230a6599e884e158fe49e2cf946801eea83dcaa/src/miner.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b230a6599e884e158fe49e2cf946801eea83dcaa/src/miner.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.cpp?ref=b230a6599e884e158fe49e2cf946801eea83dcaa",
        "patch": "@@ -467,7 +467,7 @@ bool CheckWork(CBlock* pblock, CWallet& wallet, CReserveKey& reservekey)\n     // Found a solution\n     {\n         LOCK(cs_main);\n-        if (pblock->hashPrevBlock != hashBestChain)\n+        if (pblock->hashPrevBlock != pindexBest->GetBlockHash())\n             return error(\"BitcoinMiner : generated block is stale\");\n \n         // Remove key from key pool\n@@ -481,7 +481,7 @@ bool CheckWork(CBlock* pblock, CWallet& wallet, CReserveKey& reservekey)\n \n         // Process this block the same as if we had received it from another node\n         CValidationState state;\n-        if (!ProcessBlock(state, NULL, pblock))\n+        if (!ProcessBlock(state, pblock))\n             return error(\"BitcoinMiner : ProcessBlock, block not accepted\");\n     }\n "
      },
      {
        "sha": "0c89bf8b0035c4b4158b145241fc669def23d125",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 4,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b230a6599e884e158fe49e2cf946801eea83dcaa/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b230a6599e884e158fe49e2cf946801eea83dcaa/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=b230a6599e884e158fe49e2cf946801eea83dcaa",
        "patch": "@@ -538,16 +538,16 @@ void CNode::Cleanup()\n }\n \n \n-void CNode::PushVersion()\n+void CNode::PushVersion(int nHeight)\n {\n     /// when NTP implemented, change to just nTime = GetAdjustedTime()\n     int64 nTime = (fInbound ? GetAdjustedTime() : GetTime());\n     CAddress addrYou = (addr.IsRoutable() && !IsProxy(addr) ? addr : CAddress(CService(\"0.0.0.0\",0)));\n     CAddress addrMe = GetLocalAddress(&addr);\n     RAND_bytes((unsigned char*)&nLocalHostNonce, sizeof(nLocalHostNonce));\n-    LogPrint(\"net\", \"send version message: version %d, blocks=%d, us=%s, them=%s, peer=%s\\n\", PROTOCOL_VERSION, nBestHeight, addrMe.ToString().c_str(), addrYou.ToString().c_str(), addr.ToString().c_str());\n+    LogPrintf(\"send version message: version %d, blocks=%d, us=%s, them=%s, peer=%s\\n\", PROTOCOL_VERSION, nHeight, addrMe.ToString().c_str(), addrYou.ToString().c_str(), addr.ToString().c_str());\n     PushMessage(\"version\", PROTOCOL_VERSION, nLocalServices, nTime, addrYou, addrMe,\n-                nLocalHostNonce, FormatSubVersion(CLIENT_NAME, CLIENT_VERSION, std::vector<string>()), nBestHeight, true);\n+                nLocalHostNonce, FormatSubVersion(CLIENT_NAME, CLIENT_VERSION, std::vector<string>()), nHeight, true);\n }\n \n \n@@ -806,6 +806,7 @@ void ThreadSocketHandler()\n                     }\n                     if (fDelete)\n                     {\n+                        g_signals.FinalizeNode(pnode);\n                         vNodesDisconnected.remove(pnode);\n                         delete pnode;\n                     }\n@@ -1465,6 +1466,8 @@ double static NodeSyncScore(const CNode *pnode) {\n }\n \n void static StartSync(const vector<CNode*> &vNodes) {\n+    // TODO: turn into a hook and move to main, so it has access to chain data.\n+\n     CNode *pnodeNewSync = NULL;\n     double dBestScore = 0;\n \n@@ -1473,7 +1476,6 @@ void static StartSync(const vector<CNode*> &vNodes) {\n         // check preconditions for allowing a sync\n         if (!pnode->fClient && !pnode->fOneShot &&\n             !pnode->fDisconnect && pnode->fSuccessfullyConnected &&\n-            (pnode->nStartingHeight > (nBestHeight - 144)) &&\n             (pnode->nVersion < NOBLKS_VERSION_START || pnode->nVersion >= NOBLKS_VERSION_END)) {\n             // if ok, compare node's score with the best so far\n             double dScore = NodeSyncScore(pnode);"
      },
      {
        "sha": "b8fa7c18f5e076610ae180e8814c1880a8bbc0ac",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 9,
        "deletions": 11,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b230a6599e884e158fe49e2cf946801eea83dcaa/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b230a6599e884e158fe49e2cf946801eea83dcaa/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=b230a6599e884e158fe49e2cf946801eea83dcaa",
        "patch": "@@ -28,7 +28,6 @@ static const unsigned int MAX_INV_SZ = 50000;\n \n class CNode;\n class CBlockIndex;\n-extern int nBestHeight;\n \n \n \n@@ -54,6 +53,8 @@ struct CNodeSignals\n {\n     boost::signals2::signal<bool (CNode*)> ProcessMessages;\n     boost::signals2::signal<bool (CNode*, bool)> SendMessages;\n+    boost::signals2::signal<void (CNode*)> FinalizeNode;\n+    boost::signals2::signal<void (CNode*)> InitializeNode;\n };\n \n CNodeSignals& GetNodeSignals();\n@@ -101,8 +102,6 @@ extern std::vector<std::string> vAddedNodes;\n extern CCriticalSection cs_vAddedNodes;\n \n \n-\n-\n class CNodeStats\n {\n public:\n@@ -217,10 +216,11 @@ class CNode\n \n public:\n     uint256 hashContinue;\n-    CBlockIndex* pindexLastGetBlocksBegin;\n-    uint256 hashLastGetBlocksEnd;\n     int nStartingHeight;\n     bool fStartSync;\n+    uint256 hashLastBlock;        // Last block we don't know ourself, that we've seen this peer announce.\n+    CBlockIndex *pindexLastBlock; // Best block we've seen this peer announce.\n+    std::set<CBlockIndex*> setBlocksAskedFor;\n \n     // flood relay\n     std::vector<CAddress> vAddrToSend;\n@@ -259,19 +259,17 @@ class CNode\n         nSendSize = 0;\n         nSendOffset = 0;\n         hashContinue = 0;\n-        pindexLastGetBlocksBegin = 0;\n-        hashLastGetBlocksEnd = 0;\n         nStartingHeight = -1;\n+        hashLastBlock = 0;\n+        pindexLastBlock = NULL;\n         fStartSync = false;\n         fGetAddr = false;\n         nMisbehavior = 0;\n         fRelayTxes = false;\n         setInventoryKnown.max_size(SendBufferSize() / 1000);\n         pfilter = new CBloomFilter();\n \n-        // Be shy and don't send version until we hear\n-        if (hSocket != INVALID_SOCKET && !fInbound)\n-            PushVersion();\n+        GetNodeSignals().InitializeNode(this);\n     }\n \n     ~CNode()\n@@ -448,7 +446,7 @@ class CNode\n         LEAVE_CRITICAL_SECTION(cs_vSend);\n     }\n \n-    void PushVersion();\n+    void PushVersion(int nHeight);\n \n \n     void PushMessage(const char* pszCommand)"
      },
      {
        "sha": "b0c7009ec03b3563c0a78bd92f52cedc4f8f2b13",
        "filename": "src/qt/bitcoingui.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b230a6599e884e158fe49e2cf946801eea83dcaa/src/qt/bitcoingui.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b230a6599e884e158fe49e2cf946801eea83dcaa/src/qt/bitcoingui.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoingui.cpp?ref=b230a6599e884e158fe49e2cf946801eea83dcaa",
        "patch": "@@ -327,7 +327,7 @@ void BitcoinGUI::setClientModel(ClientModel *clientModel)\n         setNumConnections(clientModel->getNumConnections());\n         connect(clientModel, SIGNAL(numConnectionsChanged(int)), this, SLOT(setNumConnections(int)));\n \n-        setNumBlocks(clientModel->getNumBlocks(), clientModel->getNumBlocksOfPeers());\n+        setNumBlocks(clientModel->getNumBlocks(), clientModel->getNumBlocksTotal());\n         connect(clientModel, SIGNAL(numBlocksChanged(int,int)), this, SLOT(setNumBlocks(int,int)));\n \n         // Receive and report messages from network/worker thread"
      },
      {
        "sha": "6a2a69f1201f2ecbd553f01ebbfe1fa7eda5507e",
        "filename": "src/qt/clientmodel.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b230a6599e884e158fe49e2cf946801eea83dcaa/src/qt/clientmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b230a6599e884e158fe49e2cf946801eea83dcaa/src/qt/clientmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/clientmodel.cpp?ref=b230a6599e884e158fe49e2cf946801eea83dcaa",
        "patch": "@@ -19,7 +19,7 @@ static const int64 nClientStartupTime = GetTime();\n \n ClientModel::ClientModel(OptionsModel *optionsModel, QObject *parent) :\n     QObject(parent), optionsModel(optionsModel),\n-    cachedNumBlocks(0), cachedNumBlocksOfPeers(0),\n+    cachedNumBlocks(0), cachedNumBlocksTotal(0),\n     cachedReindexing(0), cachedImporting(0),\n     numBlocksAtStartup(-1), pollTimer(0)\n {\n@@ -43,7 +43,7 @@ int ClientModel::getNumConnections() const\n \n int ClientModel::getNumBlocks() const\n {\n-    return nBestHeight;\n+    return pindexBest->nHeight;\n }\n \n int ClientModel::getNumBlocksAtStartup()\n@@ -72,19 +72,19 @@ void ClientModel::updateTimer()\n     // Some quantities (such as number of blocks) change so fast that we don't want to be notified for each change.\n     // Periodically check and update with a timer.\n     int newNumBlocks = getNumBlocks();\n-    int newNumBlocksOfPeers = getNumBlocksOfPeers();\n+    int newNumBlocksTotal = getNumBlocksTotal();\n \n     // check for changed number of blocks we have, number of blocks peers claim to have, reindexing state and importing state\n-    if (cachedNumBlocks != newNumBlocks || cachedNumBlocksOfPeers != newNumBlocksOfPeers ||\n+    if (cachedNumBlocks != newNumBlocks || cachedNumBlocksTotal != newNumBlocksTotal ||\n         cachedReindexing != fReindex || cachedImporting != fImporting)\n     {\n         cachedNumBlocks = newNumBlocks;\n-        cachedNumBlocksOfPeers = newNumBlocksOfPeers;\n+        cachedNumBlocksTotal = newNumBlocksTotal;\n         cachedReindexing = fReindex;\n         cachedImporting = fImporting;\n \n         // ensure we return the maximum of newNumBlocksOfPeers and newNumBlocks to not create weird displays in the GUI\n-        emit numBlocksChanged(newNumBlocks, std::max(newNumBlocksOfPeers, newNumBlocks));\n+        emit numBlocksChanged(newNumBlocks, std::max(newNumBlocksTotal, newNumBlocks));\n     }\n }\n \n@@ -132,9 +132,9 @@ enum BlockSource ClientModel::getBlockSource() const\n     return BLOCK_SOURCE_NONE;\n }\n \n-int ClientModel::getNumBlocksOfPeers() const\n+int ClientModel::getNumBlocksTotal() const\n {\n-    return GetNumBlocksOfPeers();\n+    return pindexBestHeader->nHeight;\n }\n \n QString ClientModel::getStatusBarWarnings() const"
      },
      {
        "sha": "097d723db2a46faf026a3a85f4b364e47fd3a3ab",
        "filename": "src/qt/clientmodel.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b230a6599e884e158fe49e2cf946801eea83dcaa/src/qt/clientmodel.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b230a6599e884e158fe49e2cf946801eea83dcaa/src/qt/clientmodel.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/clientmodel.h?ref=b230a6599e884e158fe49e2cf946801eea83dcaa",
        "patch": "@@ -45,7 +45,7 @@ class ClientModel : public QObject\n     //! Return true if core is importing blocks\n     enum BlockSource getBlockSource() const;\n     //! Return conservative estimate of total number of blocks, or 0 if unknown\n-    int getNumBlocksOfPeers() const;\n+    int getNumBlocksTotal() const;\n     //! Return warnings to be displayed in status bar\n     QString getStatusBarWarnings() const;\n \n@@ -59,7 +59,7 @@ class ClientModel : public QObject\n     OptionsModel *optionsModel;\n \n     int cachedNumBlocks;\n-    int cachedNumBlocksOfPeers;\n+    int cachedNumBlocksTotal;\n     bool cachedReindexing;\n     bool cachedImporting;\n \n@@ -72,7 +72,7 @@ class ClientModel : public QObject\n \n signals:\n     void numConnectionsChanged(int count);\n-    void numBlocksChanged(int count, int countOfPeers);\n+    void numBlocksChanged(int count, int countTotal);\n     void alertsChanged(const QString &warnings);\n \n     //! Asynchronous message notification"
      },
      {
        "sha": "864026ed59888e0d40285e87bab74ed8516046c3",
        "filename": "src/qt/rpcconsole.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b230a6599e884e158fe49e2cf946801eea83dcaa/src/qt/rpcconsole.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b230a6599e884e158fe49e2cf946801eea83dcaa/src/qt/rpcconsole.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/rpcconsole.cpp?ref=b230a6599e884e158fe49e2cf946801eea83dcaa",
        "patch": "@@ -260,7 +260,7 @@ void RPCConsole::setClientModel(ClientModel *model)\n         setNumConnections(model->getNumConnections());\n         connect(model, SIGNAL(numConnectionsChanged(int)), this, SLOT(setNumConnections(int)));\n \n-        setNumBlocks(model->getNumBlocks(), model->getNumBlocksOfPeers());\n+        setNumBlocks(model->getNumBlocks(), model->getNumBlocksTotal());\n         connect(model, SIGNAL(numBlocksChanged(int,int)), this, SLOT(setNumBlocks(int,int)));\n \n         // Provide initial values"
      },
      {
        "sha": "bd2a82634bb6f570d69a1fd87d742b96d95cf059",
        "filename": "src/qt/transactiondesc.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b230a6599e884e158fe49e2cf946801eea83dcaa/src/qt/transactiondesc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b230a6599e884e158fe49e2cf946801eea83dcaa/src/qt/transactiondesc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactiondesc.cpp?ref=b230a6599e884e158fe49e2cf946801eea83dcaa",
        "patch": "@@ -17,7 +17,7 @@ QString TransactionDesc::FormatTxStatus(const CWalletTx& wtx)\n     if (!IsFinalTx(wtx))\n     {\n         if (wtx.nLockTime < LOCKTIME_THRESHOLD)\n-            return tr(\"Open for %n more block(s)\", \"\", wtx.nLockTime - nBestHeight + 1);\n+            return tr(\"Open for %n more block(s)\", \"\", wtx.nLockTime - pindexBest->nHeight + 1);\n         else\n             return tr(\"Open until %1\").arg(GUIUtil::dateTimeStr(wtx.nLockTime));\n     }"
      },
      {
        "sha": "2601cb21376f8ec00fe4f616661b6607c8823e0c",
        "filename": "src/qt/transactionrecord.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b230a6599e884e158fe49e2cf946801eea83dcaa/src/qt/transactionrecord.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b230a6599e884e158fe49e2cf946801eea83dcaa/src/qt/transactionrecord.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactionrecord.cpp?ref=b230a6599e884e158fe49e2cf946801eea83dcaa",
        "patch": "@@ -160,14 +160,14 @@ void TransactionRecord::updateStatus(const CWalletTx &wtx)\n         idx);\n     status.confirmed = wtx.IsConfirmed();\n     status.depth = wtx.GetDepthInMainChain();\n-    status.cur_num_blocks = nBestHeight;\n+    status.cur_num_blocks = pindexBest->nHeight;\n \n     if (!IsFinalTx(wtx))\n     {\n         if (wtx.nLockTime < LOCKTIME_THRESHOLD)\n         {\n             status.status = TransactionStatus::OpenUntilBlock;\n-            status.open_for = wtx.nLockTime - nBestHeight + 1;\n+            status.open_for = wtx.nLockTime - pindexBest->nHeight + 1;\n         }\n         else\n         {\n@@ -221,7 +221,7 @@ void TransactionRecord::updateStatus(const CWalletTx &wtx)\n \n bool TransactionRecord::statusUpdateNeeded()\n {\n-    return status.cur_num_blocks != nBestHeight;\n+    return status.cur_num_blocks != pindexBest->nHeight;\n }\n \n QString TransactionRecord::getTxID() const"
      },
      {
        "sha": "452739d34357baa23fce885799de2dceaf8ff4f1",
        "filename": "src/qt/transactiontablemodel.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b230a6599e884e158fe49e2cf946801eea83dcaa/src/qt/transactiontablemodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b230a6599e884e158fe49e2cf946801eea83dcaa/src/qt/transactiontablemodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactiontablemodel.cpp?ref=b230a6599e884e158fe49e2cf946801eea83dcaa",
        "patch": "@@ -250,9 +250,9 @@ void TransactionTableModel::updateTransaction(const QString &hash, int status)\n \n void TransactionTableModel::updateConfirmations()\n {\n-    if(nBestHeight != cachedNumBlocks)\n+    if(pindexBest->nHeight != cachedNumBlocks)\n     {\n-        cachedNumBlocks = nBestHeight;\n+        cachedNumBlocks = pindexBest->nHeight;\n         // Blocks came in since last poll.\n         // Invalidate status (number of confirmations) and (possibly) description\n         //  for all rows. Qt is smart enough to only actually request the data for the"
      },
      {
        "sha": "c1a372338f0f6f3e0040694106f3ac23168b2456",
        "filename": "src/qt/walletmodel.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b230a6599e884e158fe49e2cf946801eea83dcaa/src/qt/walletmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b230a6599e884e158fe49e2cf946801eea83dcaa/src/qt/walletmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletmodel.cpp?ref=b230a6599e884e158fe49e2cf946801eea83dcaa",
        "patch": "@@ -73,10 +73,10 @@ void WalletModel::updateStatus()\n \n void WalletModel::pollBalanceChanged()\n {\n-    if(nBestHeight != cachedNumBlocks)\n+    if(pindexBest->nHeight != cachedNumBlocks)\n     {\n         // Balance and number of transactions might have changed\n-        cachedNumBlocks = nBestHeight;\n+        cachedNumBlocks = pindexBest->nHeight;\n         checkBalanceChanged();\n     }\n }"
      },
      {
        "sha": "8995eefd66c97690557c2225d36282e821e2082e",
        "filename": "src/rpcblockchain.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 3,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b230a6599e884e158fe49e2cf946801eea83dcaa/src/rpcblockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b230a6599e884e158fe49e2cf946801eea83dcaa/src/rpcblockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcblockchain.cpp?ref=b230a6599e884e158fe49e2cf946801eea83dcaa",
        "patch": "@@ -80,7 +80,7 @@ Value getblockcount(const Array& params, bool fHelp)\n             \"getblockcount\\n\"\n             \"Returns the number of blocks in the longest block chain.\");\n \n-    return nBestHeight;\n+    return pindexBest->nHeight;\n }\n \n Value getbestblockhash(const Array& params, bool fHelp)\n@@ -90,7 +90,7 @@ Value getbestblockhash(const Array& params, bool fHelp)\n             \"getbestblockhash\\n\"\n             \"Returns the hash of the best (tip) block in the longest block chain.\");\n \n-    return hashBestChain.GetHex();\n+    return pindexBest->GetBlockHash().GetHex();\n }\n \n Value getdifficulty(const Array& params, bool fHelp)\n@@ -145,7 +145,7 @@ Value getblockhash(const Array& params, bool fHelp)\n             \"Returns hash of block in best-block-chain at <index>.\");\n \n     int nHeight = params[0].get_int();\n-    if (nHeight < 0 || nHeight > nBestHeight)\n+    if (nHeight < 0 || nHeight > pindexBestHeader->nHeight)\n         throw runtime_error(\"Block number out of range.\");\n \n     CBlockIndex* pblockindex = FindBlockByHeight(nHeight);\n@@ -173,6 +173,9 @@ Value getblock(const Array& params, bool fHelp)\n \n     CBlock block;\n     CBlockIndex* pblockindex = mapBlockIndex[hash];\n+    if (!(pblockindex->nStatus & BLOCK_HAVE_DATA))\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Block data not available\");\n+\n     ReadBlockFromDisk(block, pblockindex);\n \n     if (!fVerbose)"
      },
      {
        "sha": "430479e8dd393ab27d8df3aad7d23a79f749a807",
        "filename": "src/rpcdump.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b230a6599e884e158fe49e2cf946801eea83dcaa/src/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b230a6599e884e158fe49e2cf946801eea83dcaa/src/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcdump.cpp?ref=b230a6599e884e158fe49e2cf946801eea83dcaa",
        "patch": "@@ -243,7 +243,7 @@ Value dumpwallet(const Array& params, bool fHelp)\n     // produce output\n     file << strprintf(\"# Wallet dump created by Bitcoin %s (%s)\\n\", CLIENT_BUILD.c_str(), CLIENT_DATE.c_str());\n     file << strprintf(\"# * Created on %s\\n\", EncodeDumpTime(GetTime()).c_str());\n-    file << strprintf(\"# * Best block at time of backup was %i (%s),\\n\", nBestHeight, hashBestChain.ToString().c_str());\n+    file << strprintf(\"# * Best block at time of backup was %i (%s),\\n\", pindexBest->nHeight, pindexBest->GetBlockHash().ToString().c_str());\n     file << strprintf(\"#   mined on %s\\n\", EncodeDumpTime(pindexBest->nTime).c_str());\n     file << \"\\n\";\n     for (std::vector<std::pair<int64, CKeyID> >::const_iterator it = vKeyBirth.begin(); it != vKeyBirth.end(); it++) {"
      },
      {
        "sha": "08dd96b850ce35d8bb2671edcd2f75e7c463c9fc",
        "filename": "src/rpcmining.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b230a6599e884e158fe49e2cf946801eea83dcaa/src/rpcmining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b230a6599e884e158fe49e2cf946801eea83dcaa/src/rpcmining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcmining.cpp?ref=b230a6599e884e158fe49e2cf946801eea83dcaa",
        "patch": "@@ -85,7 +85,7 @@ Value getmininginfo(const Array& params, bool fHelp)\n             \"Returns an object containing mining-related information.\");\n \n     Object obj;\n-    obj.push_back(Pair(\"blocks\",           (int)nBestHeight));\n+    obj.push_back(Pair(\"blocks\",           (int)pindexBest->nHeight));\n     obj.push_back(Pair(\"currentblocksize\", (uint64_t)nLastBlockSize));\n     obj.push_back(Pair(\"currentblocktx\",   (uint64_t)nLastBlockTx));\n     obj.push_back(Pair(\"difficulty\",       (double)GetDifficulty()));\n@@ -380,7 +380,7 @@ Value submitblock(const Array& params, bool fHelp)\n     }\n \n     CValidationState state;\n-    bool fAccepted = ProcessBlock(state, NULL, &pblock);\n+    bool fAccepted = ProcessBlock(state, &pblock);\n     if (!fAccepted)\n         return \"rejected\"; // TODO: report validation state\n "
      },
      {
        "sha": "22fd824bfc7cb7eb56b3a1f2daf7bff00676a667",
        "filename": "src/rpcrawtransaction.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b230a6599e884e158fe49e2cf946801eea83dcaa/src/rpcrawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b230a6599e884e158fe49e2cf946801eea83dcaa/src/rpcrawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcrawtransaction.cpp?ref=b230a6599e884e158fe49e2cf946801eea83dcaa",
        "patch": "@@ -89,7 +89,7 @@ void TxToJSON(const CTransaction& tx, const uint256 hashBlock, Object& entry)\n             CBlockIndex* pindex = (*mi).second;\n             if (pindex->IsInMainChain())\n             {\n-                entry.push_back(Pair(\"confirmations\", 1 + nBestHeight - pindex->nHeight));\n+                entry.push_back(Pair(\"confirmations\", 1 + pindexBest->nHeight - pindex->nHeight));\n                 entry.push_back(Pair(\"time\", (boost::int64_t)pindex->nTime));\n                 entry.push_back(Pair(\"blocktime\", (boost::int64_t)pindex->nTime));\n             }"
      },
      {
        "sha": "d7f0e7a1bfd22a1daf9ddeb763fe17e8b20e26f3",
        "filename": "src/rpcwallet.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b230a6599e884e158fe49e2cf946801eea83dcaa/src/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b230a6599e884e158fe49e2cf946801eea83dcaa/src/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcwallet.cpp?ref=b230a6599e884e158fe49e2cf946801eea83dcaa",
        "patch": "@@ -74,7 +74,8 @@ Value getinfo(const Array& params, bool fHelp)\n     obj.push_back(Pair(\"protocolversion\",(int)PROTOCOL_VERSION));\n     obj.push_back(Pair(\"walletversion\", pwalletMain->GetVersion()));\n     obj.push_back(Pair(\"balance\",       ValueFromAmount(pwalletMain->GetBalance())));\n-    obj.push_back(Pair(\"blocks\",        (int)nBestHeight));\n+    obj.push_back(Pair(\"blocks\",        (int)pindexBest->nHeight));\n+    obj.push_back(Pair(\"headers\",       (int)pindexBestHeader->nHeight));\n     obj.push_back(Pair(\"timeoffset\",    (boost::int64_t)GetTimeOffset()));\n     obj.push_back(Pair(\"connections\",   (int)vNodes.size()));\n     obj.push_back(Pair(\"proxy\",         (proxy.first.IsValid() ? proxy.first.ToStringIPPort() : string())));\n@@ -1176,7 +1177,7 @@ Value listsinceblock(const Array& params, bool fHelp)\n             throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid parameter\");\n     }\n \n-    int depth = pindex ? (1 + nBestHeight - pindex->nHeight) : -1;\n+    int depth = pindex ? (1 + pindexBest->nHeight - pindex->nHeight) : -1;\n \n     Array transactions;\n \n@@ -1192,7 +1193,7 @@ Value listsinceblock(const Array& params, bool fHelp)\n \n     if (target_confirms == 1)\n     {\n-        lastblock = hashBestChain;\n+        lastblock = pindexBest->GetBlockHash();\n     }\n     else\n     {"
      },
      {
        "sha": "cc5ceea537ea0e9cc2f0486d99c5c855a56e90d9",
        "filename": "src/test/miner_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b230a6599e884e158fe49e2cf946801eea83dcaa/src/test/miner_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b230a6599e884e158fe49e2cf946801eea83dcaa/src/test/miner_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/miner_tests.cpp?ref=b230a6599e884e158fe49e2cf946801eea83dcaa",
        "patch": "@@ -75,7 +75,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n         pblock->hashMerkleRoot = pblock->BuildMerkleTree();\n         pblock->nNonce = blockinfo[i].nonce;\n         CValidationState state;\n-        BOOST_CHECK(ProcessBlock(state, NULL, pblock));\n+        BOOST_CHECK(ProcessBlock(state, pblock));\n         BOOST_CHECK(state.IsValid());\n         pblock->hashPrevBlock = pblock->GetHash();\n     }"
      },
      {
        "sha": "1486973e74acdf525caf2a1ed24bd1404b23515f",
        "filename": "src/txdb.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 15,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b230a6599e884e158fe49e2cf946801eea83dcaa/src/txdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b230a6599e884e158fe49e2cf946801eea83dcaa/src/txdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.cpp?ref=b230a6599e884e158fe49e2cf946801eea83dcaa",
        "patch": "@@ -208,28 +208,20 @@ bool CBlockTreeDB::LoadBlockIndexGuts()\n                 CDiskBlockIndex diskindex;\n                 ssValue >> diskindex;\n \n+                if (!diskindex.CheckIndex()) {\n+                    error(\"LoadBlockIndex() : CheckIndex failed: %s\", diskindex.GetBlockHash().ToString().c_str());\n+                    pcursor->Next();\n+                    continue;\n+                }\n+\n                 // Construct block index object\n-                CBlockIndex* pindexNew = InsertBlockIndex(diskindex.GetBlockHash());\n-                pindexNew->pprev          = InsertBlockIndex(diskindex.hashPrev);\n-                pindexNew->nHeight        = diskindex.nHeight;\n+                CBlockIndex* pindexNew = InsertBlockIndex(diskindex.GetBlockHash(), diskindex.GetBlockHeader());\n                 pindexNew->nFile          = diskindex.nFile;\n                 pindexNew->nDataPos       = diskindex.nDataPos;\n                 pindexNew->nUndoPos       = diskindex.nUndoPos;\n-                pindexNew->nVersion       = diskindex.nVersion;\n-                pindexNew->hashMerkleRoot = diskindex.hashMerkleRoot;\n-                pindexNew->nTime          = diskindex.nTime;\n-                pindexNew->nBits          = diskindex.nBits;\n-                pindexNew->nNonce         = diskindex.nNonce;\n                 pindexNew->nStatus        = diskindex.nStatus;\n                 pindexNew->nTx            = diskindex.nTx;\n \n-                // Watch for genesis block\n-                if (pindexGenesisBlock == NULL && diskindex.GetBlockHash() == Params().HashGenesisBlock())\n-                    pindexGenesisBlock = pindexNew;\n-\n-                if (!pindexNew->CheckIndex())\n-                    return error(\"LoadBlockIndex() : CheckIndex failed: %s\", pindexNew->ToString().c_str());\n-\n                 pcursor->Next();\n             } else {\n                 break; // if shutdown requested or finished loading block index"
      },
      {
        "sha": "818016c1adaf09980dfc8414250147576bb8cab0",
        "filename": "src/version.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b230a6599e884e158fe49e2cf946801eea83dcaa/src/version.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b230a6599e884e158fe49e2cf946801eea83dcaa/src/version.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/version.h?ref=b230a6599e884e158fe49e2cf946801eea83dcaa",
        "patch": "@@ -34,6 +34,9 @@ static const int MIN_PROTO_VERSION = 209;\n // if possible, avoid requesting addresses nodes older than this\n static const int CADDR_TIME_VERSION = 31402;\n \n+// In this version, 'headers' and 'getheaders' where added.\n+static const int GETHEADERS_VERSION = 31800;\n+\n // only request blocks from nodes outside this range of versions\n static const int NOBLKS_VERSION_START = 32000;\n static const int NOBLKS_VERSION_END = 32400;"
      },
      {
        "sha": "ac39a6e8d4c83929fd524b45647105bd62fe333a",
        "filename": "src/wallet.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b230a6599e884e158fe49e2cf946801eea83dcaa/src/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b230a6599e884e158fe49e2cf946801eea83dcaa/src/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.cpp?ref=b230a6599e884e158fe49e2cf946801eea83dcaa",
        "patch": "@@ -1933,7 +1933,7 @@ void CWallet::GetKeyBirthTimes(std::map<CKeyID, int64> &mapKeyBirth) const {\n             mapKeyBirth[it->first] = it->second.nCreateTime;\n \n     // map in which we'll infer heights of other keys\n-    CBlockIndex *pindexMax = FindBlockByHeight(std::max(0, nBestHeight - 144)); // the tip can be reorganised; use a 144-block safety margin\n+    CBlockIndex *pindexMax = FindBlockByHeight(std::max(0, pindexBest->nHeight - 144)); // the tip can be reorganised; use a 144-block safety margin\n     std::map<CKeyID, CBlockIndex*> mapKeyFirstBlock;\n     std::set<CKeyID> setKeys;\n     GetKeys(setKeys);"
      }
    ]
  },
  {
    "sha": "8f05f6f4f61a1fb61f4d2544d5b757237ca81e78",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4ZjA1ZjZmNGY2MWExZmI2MWY0ZDI1NDRkNWI3NTcyMzdjYTgxZTc4",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2013-07-27T13:44:57Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2013-09-28T14:05:01Z"
      },
      "message": "RPC updates after header-first synchronization",
      "tree": {
        "sha": "2df3814e74a8fd00ec199b089dc444ba9f9d1e69",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2df3814e74a8fd00ec199b089dc444ba9f9d1e69"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8f05f6f4f61a1fb61f4d2544d5b757237ca81e78",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8f05f6f4f61a1fb61f4d2544d5b757237ca81e78",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8f05f6f4f61a1fb61f4d2544d5b757237ca81e78",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8f05f6f4f61a1fb61f4d2544d5b757237ca81e78/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b230a6599e884e158fe49e2cf946801eea83dcaa",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b230a6599e884e158fe49e2cf946801eea83dcaa",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b230a6599e884e158fe49e2cf946801eea83dcaa"
      }
    ],
    "stats": {
      "total": 71,
      "additions": 56,
      "deletions": 15
    },
    "files": [
      {
        "sha": "27197d2b929617b20859ccb5e57347c9347f78ba",
        "filename": "src/bitcoinrpc.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8f05f6f4f61a1fb61f4d2544d5b757237ca81e78/src/bitcoinrpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8f05f6f4f61a1fb61f4d2544d5b757237ca81e78/src/bitcoinrpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoinrpc.cpp?ref=8f05f6f4f61a1fb61f4d2544d5b757237ca81e78",
        "patch": "@@ -259,6 +259,7 @@ static const CRPCCommand vRPCCommands[] =\n     { \"addmultisigaddress\",     &addmultisigaddress,     false,     false },\n     { \"createmultisig\",         &createmultisig,         true,      true  },\n     { \"getrawmempool\",          &getrawmempool,          true,      false },\n+    { \"getblockheader\",         &getblockheader,         true,      false },\n     { \"getblock\",               &getblock,               false,     false },\n     { \"getblockhash\",           &getblockhash,           false,     false },\n #ifdef ENABLE_BLOCK_BLACKLISTING\n@@ -1221,6 +1222,7 @@ Array RPCConvertValues(const std::string &strMethod, const std::vector<std::stri\n     if (strMethod == \"listunspent\"            && n > 1) ConvertTo<boost::int64_t>(params[1]);\n     if (strMethod == \"listunspent\"            && n > 2) ConvertTo<Array>(params[2]);\n     if (strMethod == \"getblock\"               && n > 1) ConvertTo<bool>(params[1]);\n+    if (strMethod == \"getblockheader\"         && n > 1) ConvertTo<bool>(params[1]);\n     if (strMethod == \"getrawtransaction\"      && n > 1) ConvertTo<boost::int64_t>(params[1]);\n     if (strMethod == \"createrawtransaction\"   && n > 0) ConvertTo<Array>(params[0]);\n     if (strMethod == \"createrawtransaction\"   && n > 1) ConvertTo<Object>(params[1]);"
      },
      {
        "sha": "73c064a961a592b7eb78cca2e2e19f219996563c",
        "filename": "src/bitcoinrpc.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8f05f6f4f61a1fb61f4d2544d5b757237ca81e78/src/bitcoinrpc.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8f05f6f4f61a1fb61f4d2544d5b757237ca81e78/src/bitcoinrpc.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoinrpc.h?ref=8f05f6f4f61a1fb61f4d2544d5b757237ca81e78",
        "patch": "@@ -218,6 +218,7 @@ extern json_spirit::Value settxfee(const json_spirit::Array& params, bool fHelp)\n extern json_spirit::Value getrawmempool(const json_spirit::Array& params, bool fHelp);\n extern json_spirit::Value getblockhash(const json_spirit::Array& params, bool fHelp);\n extern json_spirit::Value getblock(const json_spirit::Array& params, bool fHelp);\n+extern json_spirit::Value getblockheader(const json_spirit::Array& params, bool fHelp);\n extern json_spirit::Value blacklistblock(const json_spirit::Array& params, bool fHelp);\n extern json_spirit::Value gettxoutsetinfo(const json_spirit::Array& params, bool fHelp);\n extern json_spirit::Value gettxout(const json_spirit::Array& params, bool fHelp);"
      },
      {
        "sha": "9e7272f7121ed760fd6dc58ce34a7dd0bf3c7aac",
        "filename": "src/rpcblockchain.cpp",
        "status": "modified",
        "additions": 53,
        "deletions": 15,
        "changes": 68,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8f05f6f4f61a1fb61f4d2544d5b757237ca81e78/src/rpcblockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8f05f6f4f61a1fb61f4d2544d5b757237ca81e78/src/rpcblockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcblockchain.cpp?ref=8f05f6f4f61a1fb61f4d2544d5b757237ca81e78",
        "patch": "@@ -43,24 +43,19 @@ double GetDifficulty(const CBlockIndex* blockindex)\n }\n \n \n-Object blockToJSON(const CBlock& block, const CBlockIndex* blockindex)\n+Object blockHeaderToJSON(const CBlockIndex* blockindex)\n {\n     Object result;\n-    result.push_back(Pair(\"hash\", block.GetHash().GetHex()));\n-    CMerkleTx txGen(block.vtx[0]);\n-    txGen.SetMerkleBranch(&block);\n-    result.push_back(Pair(\"confirmations\", (int)txGen.GetDepthInMainChain()));\n-    result.push_back(Pair(\"size\", (int)::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION)));\n+\n+    result.push_back(Pair(\"hash\", blockindex->GetBlockHash().GetHex()));\n+    int nConfirmations = blockindex->IsInMainChain() ? std::max(0, pindexBest->nHeight - blockindex->nHeight + 1) : 0;\n+    result.push_back(Pair(\"confirmations\", nConfirmations));\n     result.push_back(Pair(\"height\", blockindex->nHeight));\n-    result.push_back(Pair(\"version\", block.nVersion));\n-    result.push_back(Pair(\"merkleroot\", block.hashMerkleRoot.GetHex()));\n-    Array txs;\n-    BOOST_FOREACH(const CTransaction&tx, block.vtx)\n-        txs.push_back(tx.GetHash().GetHex());\n-    result.push_back(Pair(\"tx\", txs));\n-    result.push_back(Pair(\"time\", (boost::int64_t)block.GetBlockTime()));\n-    result.push_back(Pair(\"nonce\", (boost::uint64_t)block.nNonce));\n-    result.push_back(Pair(\"bits\", HexBits(block.nBits)));\n+    result.push_back(Pair(\"merkleroot\", blockindex->hashMerkleRoot.GetHex()));\n+    result.push_back(Pair(\"version\", blockindex->nVersion));\n+    result.push_back(Pair(\"time\", (boost::int64_t)blockindex->GetBlockTime()));\n+    result.push_back(Pair(\"nonce\", (boost::uint64_t)blockindex->nNonce));\n+    result.push_back(Pair(\"bits\", HexBits(blockindex->nBits)));\n     result.push_back(Pair(\"difficulty\", GetDifficulty(blockindex)));\n     result.push_back(Pair(\"chainwork\", blockindex->nChainWork.GetHex()));\n \n@@ -72,6 +67,18 @@ Object blockToJSON(const CBlock& block, const CBlockIndex* blockindex)\n     return result;\n }\n \n+Object blockToJSON(const CBlock& block, const CBlockIndex* blockindex)\n+{\n+    Object result = blockHeaderToJSON(blockindex);\n+\n+    result.push_back(Pair(\"size\", (int)::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION)));\n+    Array txs;\n+    BOOST_FOREACH(const CTransaction&tx, block.vtx)\n+        txs.push_back(tx.GetHash().GetHex());\n+    result.push_back(Pair(\"tx\", txs));\n+    return result;\n+}\n+\n \n Value getblockcount(const Array& params, bool fHelp)\n {\n@@ -152,6 +159,37 @@ Value getblockhash(const Array& params, bool fHelp)\n     return pblockindex->phashBlock->GetHex();\n }\n \n+Value getblockheader(const Array& params, bool fHelp)\n+{\n+    if (fHelp || params.size() < 1 || params.size() > 2)\n+        throw runtime_error(\n+            \"getblockheader <hash> [verbose=true]\\n\"\n+            \"If verbose is false, returns a string that is the serialized, base64-encoded form of a block header.\\n\"\n+            \"If verbose is true, returns an Object with information contained in block header <hash>.\\n\"\n+        );\n+\n+    std::string strHash = params[0].get_str();\n+    uint256 hash(strHash);\n+\n+    bool fVerbose = true;\n+    if (params.size() > 1)\n+        fVerbose = params[1].get_bool();\n+\n+    if (mapBlockIndex.count(hash) == 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block not found\");\n+\n+    CBlockIndex *pindex = mapBlockIndex[hash];\n+\n+    if (!fVerbose)\n+    {\n+        CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n+        ss << pindex->GetBlockHeader();\n+        return EncodeBase64((unsigned char*)&ss[0], ss.size());\n+    }\n+\n+    return blockHeaderToJSON(pindex);\n+}\n+\n Value getblock(const Array& params, bool fHelp)\n {\n     if (fHelp || params.size() < 1 || params.size() > 2)"
      }
    ]
  },
  {
    "sha": "da5cbf628001c7abd54d63df51cb682a561706be",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkYTVjYmY2MjgwMDFjN2FiZDU0ZDYzZGY1MWNiNjgyYTU2MTcwNmJl",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "sipa@ulyssis.org",
        "date": "2013-09-14T09:46:30Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2013-09-28T14:05:01Z"
      },
      "message": "Enforce first not-invalid best-pow chain",
      "tree": {
        "sha": "95997527840afdf70f044285259031729d772c90",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/95997527840afdf70f044285259031729d772c90"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/da5cbf628001c7abd54d63df51cb682a561706be",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/da5cbf628001c7abd54d63df51cb682a561706be",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/da5cbf628001c7abd54d63df51cb682a561706be",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/da5cbf628001c7abd54d63df51cb682a561706be/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8f05f6f4f61a1fb61f4d2544d5b757237ca81e78",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8f05f6f4f61a1fb61f4d2544d5b757237ca81e78",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8f05f6f4f61a1fb61f4d2544d5b757237ca81e78"
      }
    ],
    "stats": {
      "total": 17,
      "additions": 15,
      "deletions": 2
    },
    "files": [
      {
        "sha": "d13597458cfa41c942004a57676ee98a0c56d09c",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 2,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/da5cbf628001c7abd54d63df51cb682a561706be/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/da5cbf628001c7abd54d63df51cb682a561706be/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=da5cbf628001c7abd54d63df51cb682a561706be",
        "patch": "@@ -1562,7 +1562,7 @@ bool SwitchToBestHeader(CValidationState &state) {\n         }\n \n         // Check whether it's actually an improvement.\n-        if (pindexBestHeader && pindexNewBest->nChainWork <= pindexBestHeader->nChainWork) {\n+        if (pindexBestHeader && !CBlockIndexWorkComparator()(pindexBestHeader, pindexNewBest)) {\n             break;\n         }\n \n@@ -2801,6 +2801,7 @@ FILE* OpenUndoFile(const CDiskBlockPos &pos, bool fReadOnly) {\n bool static LinkOrphans(const uint256 *phashParent) {\n     bool fWorkDone = false;\n     const uint256 &hashGenesisBlock = Params().HashGenesisBlock();\n+    static unsigned int nLastBlockOrder = 0;\n \n     deque<multimap<uint256, CBlockIndex*>::iterator> vTodo;\n     if (phashParent) {\n@@ -2860,8 +2861,10 @@ bool static LinkOrphans(const uint256 *phashParent) {\n             }\n         }\n         fWorkDone = true;\n-        if (!(pindex->nStatus & BLOCK_FAILED_MASK) && (pindex->nStatus & BLOCK_VALID_TREE))\n+        if (!(pindex->nStatus & BLOCK_FAILED_MASK) && (pindex->nStatus & BLOCK_VALID_TREE)) {\n+            pindex->nOrder = ++nLastBlockOrder;\n             setBlockIndexValid.insert(pindex);\n+        }\n         const uint256 &hashBlock = pindex->GetBlockHash();\n         multimap<uint256, CBlockIndex*>::iterator itadd = mapOrphanBlocksByPrev.lower_bound(hashBlock);\n         while (itadd != mapOrphanBlocksByPrev.end() && itadd->first == hashBlock)"
      },
      {
        "sha": "7413b8c33b20be160c44d7f1ea1330cf7504405d",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/da5cbf628001c7abd54d63df51cb682a561706be/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/da5cbf628001c7abd54d63df51cb682a561706be/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=da5cbf628001c7abd54d63df51cb682a561706be",
        "patch": "@@ -718,6 +718,9 @@ class CBlockIndex\n     // Verification status of this block. See enum BlockStatus\n     unsigned int nStatus;\n \n+    // (memory only) Order of adding to setBlockIndexValid.\n+    unsigned int nOrder;\n+\n     // block header\n     int nVersion;\n     uint256 hashMerkleRoot;\n@@ -738,6 +741,7 @@ class CBlockIndex\n         nTx = 0;\n         nChainTx = 0;\n         nStatus = 0;\n+        nOrder = 0;\n \n         nVersion       = 0;\n         hashMerkleRoot = 0;\n@@ -758,6 +762,7 @@ class CBlockIndex\n         nTx = 0;\n         nChainTx = 0;\n         nStatus = 0;\n+        nOrder = 0;\n \n         nVersion       = block.nVersion;\n         hashMerkleRoot = block.hashMerkleRoot;\n@@ -877,9 +882,14 @@ class CBlockIndex\n struct CBlockIndexWorkComparator\n {\n     bool operator()(CBlockIndex *pa, CBlockIndex *pb) {\n+        if (pa == pb) return false;\n+\n         if (pa->nChainWork > pb->nChainWork) return false;\n         if (pa->nChainWork < pb->nChainWork) return true;\n \n+        if (pa->nOrder < pb->nOrder) return false;\n+        if (pa->nOrder > pb->nOrder) return true;\n+\n         if (pa->GetBlockHash() < pb->GetBlockHash()) return false;\n         if (pa->GetBlockHash() > pb->GetBlockHash()) return true;\n "
      }
    ]
  },
  {
    "sha": "924e9929f54815d80e9d12b1da714977334968d4",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5MjRlOTkyOWY1NDgxNWQ4MGU5ZDEyYjFkYTcxNDk3NzMzNDk2OGQ0",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2013-09-28T21:19:21Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2013-09-28T21:44:06Z"
      },
      "message": "Only prevent historic blocks from being downloaded from inbound peers",
      "tree": {
        "sha": "02d31e136e6a84643c921284b230b4cdd94d8256",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/02d31e136e6a84643c921284b230b4cdd94d8256"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/924e9929f54815d80e9d12b1da714977334968d4",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/924e9929f54815d80e9d12b1da714977334968d4",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/924e9929f54815d80e9d12b1da714977334968d4",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/924e9929f54815d80e9d12b1da714977334968d4/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "da5cbf628001c7abd54d63df51cb682a561706be",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/da5cbf628001c7abd54d63df51cb682a561706be",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/da5cbf628001c7abd54d63df51cb682a561706be"
      }
    ],
    "stats": {
      "total": 4,
      "additions": 3,
      "deletions": 1
    },
    "files": [
      {
        "sha": "42e63a9145c3beca4ec067fe9ad1709559b3c6e5",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/924e9929f54815d80e9d12b1da714977334968d4/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/924e9929f54815d80e9d12b1da714977334968d4/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=924e9929f54815d80e9d12b1da714977334968d4",
        "patch": "@@ -4357,7 +4357,7 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n     //\n     vector<CInv> vGetData;\n     int nLastHeight = std::min(pindexBestHeader->nHeight, pto->pindexLastBlock ? pto->pindexLastBlock->nHeight : pto->nStartingHeight);\n-    if (pindexBest && !fReindex && !fImporting && pto->nServices & NODE_NETWORK && !pto->fInbound && nLastHeight > pindexBest->nHeight) {\n+    if (pindexBest && !fReindex && !fImporting && pto->nServices & NODE_NETWORK && nLastHeight > pindexBest->nHeight) {\n         if (setHeightMissing.empty()) {\n             // We're stalled.\n             if (mapBlocksAskedFor.size() == pto->setBlocksAskedFor.size() && mapBlocksAskedFor.begin()->second + 30 < GetTime()) {\n@@ -4373,6 +4373,8 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n             int nHeight = *it;\n             if (nHeight > nLastHeight)\n                 break;\n+            if (pto->fInbound && nHeight+100 < pindexBestHeader->nHeight)\n+                break;\n             CBlockIndex *pindex = vBlockIndexByHeight[nHeight];\n             if (mapAlreadyAskedFor.count(CInv(MSG_BLOCK, pindex->GetBlockHash())))\n                 break;"
      }
    ]
  },
  {
    "sha": "668a9b12c9c9cd24cd3b021b72d499f373ab077a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2NjhhOWIxMmM5YzljZDI0Y2QzYjAyMWI3MmQ0OTlmMzczYWIwNzdh",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2013-09-28T22:01:03Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2013-09-28T22:01:03Z"
      },
      "message": "Print incoming peer's service bits",
      "tree": {
        "sha": "454154cbf05ba908de69174253914a015c235ba8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/454154cbf05ba908de69174253914a015c235ba8"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/668a9b12c9c9cd24cd3b021b72d499f373ab077a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/668a9b12c9c9cd24cd3b021b72d499f373ab077a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/668a9b12c9c9cd24cd3b021b72d499f373ab077a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/668a9b12c9c9cd24cd3b021b72d499f373ab077a/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "924e9929f54815d80e9d12b1da714977334968d4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/924e9929f54815d80e9d12b1da714977334968d4",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/924e9929f54815d80e9d12b1da714977334968d4"
      }
    ],
    "stats": {
      "total": 2,
      "additions": 1,
      "deletions": 1
    },
    "files": [
      {
        "sha": "ab8264a700f16fe309208356d3f0be6191aa1085",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/668a9b12c9c9cd24cd3b021b72d499f373ab077a/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/668a9b12c9c9cd24cd3b021b72d499f373ab077a/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=668a9b12c9c9cd24cd3b021b72d499f373ab077a",
        "patch": "@@ -3559,7 +3559,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n \n         pfrom->fSuccessfullyConnected = true;\n \n-        LogPrintf(\"receive version message: version %d, blocks=%d, us=%s, them=%s, peer=%s\\n\", pfrom->nVersion, pfrom->nStartingHeight, addrMe.ToString().c_str(), addrFrom.ToString().c_str(), pfrom->addr.ToString().c_str());\n+        LogPrintf(\"receive version message: version %d, service=%x, blocks=%d, us=%s, them=%s, peer=%s\\n\", pfrom->nVersion, pfrom->nServices, pfrom->nStartingHeight, addrMe.ToString().c_str(), addrFrom.ToString().c_str(), pfrom->addr.ToString().c_str());\n     }\n \n "
      }
    ]
  },
  {
    "sha": "bd49d084540ebd15c19b3dcb660802aa40da5f2d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiZDQ5ZDA4NDU0MGViZDE1YzE5YjNkY2I2NjA4MDJhYTQwZGE1ZjJk",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2013-09-29T00:26:25Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2013-09-29T00:26:25Z"
      },
      "message": "Debugging",
      "tree": {
        "sha": "57a182d34fe5f0b219cd5e9c39ca92e04bfa0a09",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/57a182d34fe5f0b219cd5e9c39ca92e04bfa0a09"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/bd49d084540ebd15c19b3dcb660802aa40da5f2d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bd49d084540ebd15c19b3dcb660802aa40da5f2d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/bd49d084540ebd15c19b3dcb660802aa40da5f2d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bd49d084540ebd15c19b3dcb660802aa40da5f2d/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "668a9b12c9c9cd24cd3b021b72d499f373ab077a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/668a9b12c9c9cd24cd3b021b72d499f373ab077a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/668a9b12c9c9cd24cd3b021b72d499f373ab077a"
      }
    ],
    "stats": {
      "total": 21,
      "additions": 16,
      "deletions": 5
    },
    "files": [
      {
        "sha": "e8bcb4bf7a06516109c50777c964e528de4942be",
        "filename": "qa/pull-tester/run-bitcoind-for-test.sh.in",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bd49d084540ebd15c19b3dcb660802aa40da5f2d/qa/pull-tester/run-bitcoind-for-test.sh.in",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bd49d084540ebd15c19b3dcb660802aa40da5f2d/qa/pull-tester/run-bitcoind-for-test.sh.in",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/pull-tester/run-bitcoind-for-test.sh.in?ref=bd49d084540ebd15c19b3dcb660802aa40da5f2d",
        "patch": "@@ -5,7 +5,7 @@ mkdir -p \"$DATADIR\"/regtest\n touch \"$DATADIR/regtest/debug.log\"\n tail -q -n 1 -F \"$DATADIR/regtest/debug.log\" | grep -m 1 -q \"Done loading\" &\n WAITER=$!\n-\"@abs_top_builddir@/src/bitcoind@EXEEXT@\" -connect=0.0.0.0 -datadir=\"$DATADIR\" -rpcuser=user -rpcpassword=pass -listen -keypool=3 -debug -logtimestamps -port=18444 -regtest &\n+\"@abs_top_builddir@/src/bitcoind@EXEEXT@\" -connect=0.0.0.0 -datadir=\"$DATADIR\" -rpcuser=user -rpcpassword=pass -listen -keypool=3 -debug -debug=net -logtimestamps -port=18444 -regtest &\n BITCOIND=$!\n \n #Install a watchdog."
      },
      {
        "sha": "8cc04c88800fc64d636e75ca1452fd8f8de01339",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 4,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bd49d084540ebd15c19b3dcb660802aa40da5f2d/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bd49d084540ebd15c19b3dcb660802aa40da5f2d/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=bd49d084540ebd15c19b3dcb660802aa40da5f2d",
        "patch": "@@ -4358,7 +4358,9 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n     vector<CInv> vGetData;\n     int nLastHeight = std::min(pindexBestHeader->nHeight, pto->pindexLastBlock ? pto->pindexLastBlock->nHeight : pto->nStartingHeight);\n     if (pindexBest && !fReindex && !fImporting && pto->nServices & NODE_NETWORK && nLastHeight > pindexBest->nHeight) {\n+        printf(\"Sync from %s: peerHeight=%i pindexBest->nHeight=%i pindexBestHeader->nHeight=%i\\n\", pto->addr.ToString().c_str(), nLastHeight, pindexBest->nHeight, pindexBestHeader->nHeight);\n         if (setHeightMissing.empty()) {\n+            printf(\"* We're stalled\\n\");\n             // We're stalled.\n             if (mapBlocksAskedFor.size() == pto->setBlocksAskedFor.size() && mapBlocksAskedFor.begin()->second + 30 < GetTime()) {\n                 // This peer is the one stalling everyone!\n@@ -4367,20 +4369,29 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n             }\n         }\n         while ((int)pto->setBlocksAskedFor.size() < MAX_BLOCKS_IN_TRANSIT_PER_PEER && !setHeightMissing.empty()) {\n-            if (4*pto->setBlocksAskedFor.size() > setHeightMissing.size() + mapBlocksAskedFor.size())\n+            if (pto->setBlocksAskedFor.size() > 6 && 4*pto->setBlocksAskedFor.size() > setHeightMissing.size() + mapBlocksAskedFor.size()) {\n+                printf(\"* Too large %% already requested (%i req, %i missing, %i total req).\\n\", pto->setBlocksAskedFor.size(), setHeightMissing.size(), mapBlocksAskedFor.size());\n                 break;\n+            }\n             std::set<int>::iterator it = setHeightMissing.begin();\n             int nHeight = *it;\n-            if (nHeight > nLastHeight)\n+            if (nHeight > nLastHeight) {\n+                printf(\"* Height %i beyond what peer has\\n\", nHeight);\n                 break;\n-            if (pto->fInbound && nHeight+100 < pindexBestHeader->nHeight)\n+            }\n+            if (pto->fInbound && nHeight+100 < pindexBestHeader->nHeight) {\n+                printf(\"* Height %i is historic, don't request from inbound peer.\\n\", nHeight);\n                 break;\n+            }\n             CBlockIndex *pindex = vBlockIndexByHeight[nHeight];\n-            if (mapAlreadyAskedFor.count(CInv(MSG_BLOCK, pindex->GetBlockHash())))\n+            if (mapAlreadyAskedFor.count(CInv(MSG_BLOCK, pindex->GetBlockHash()))) {\n+                printf(\"* Height %i already asked for\\n\", nHeight);\n                 break;\n+            }\n             setHeightMissing.erase(it);\n             pto->setBlocksAskedFor.insert(pindex);\n             mapBlocksAskedFor[pindex] = GetTime();\n+            printf(\"- Fetching height %i\\n\", nHeight);\n             vGetData.push_back(CInv(MSG_BLOCK, pindex->GetBlockHash()));\n         }\n         if (vGetData.size())"
      }
    ]
  }
]