[
  {
    "sha": "8bda0960f94dfb6462fc810cd61a8a065730eb79",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4YmRhMDk2MGY5NGRmYjY0NjJmYzgxMGNkNjFhOGEwNjU3MzBlYjc5",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2019-12-04T23:14:43Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2019-12-05T17:49:11Z"
      },
      "message": "Move events_hasher into RNGState()",
      "tree": {
        "sha": "00f0858e156cb12eb2ff90b15f8d5dc033a6aff3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/00f0858e156cb12eb2ff90b15f8d5dc033a6aff3"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8bda0960f94dfb6462fc810cd61a8a065730eb79",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8bda0960f94dfb6462fc810cd61a8a065730eb79",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8bda0960f94dfb6462fc810cd61a8a065730eb79",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8bda0960f94dfb6462fc810cd61a8a065730eb79/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6fff333c9f00cf379562ed38c2599997f9821cfb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6fff333c9f00cf379562ed38c2599997f9821cfb",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6fff333c9f00cf379562ed38c2599997f9821cfb"
      }
    ],
    "stats": {
      "total": 73,
      "additions": 40,
      "deletions": 33
    },
    "files": [
      {
        "sha": "50b84777336607365caa9975f4230d4793a3520d",
        "filename": "src/random.cpp",
        "status": "modified",
        "additions": 39,
        "deletions": 32,
        "changes": 71,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8bda0960f94dfb6462fc810cd61a8a065730eb79/src/random.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8bda0960f94dfb6462fc810cd61a8a065730eb79/src/random.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/random.cpp?ref=8bda0960f94dfb6462fc810cd61a8a065730eb79",
        "patch": "@@ -360,6 +360,9 @@ class RNGState {\n     uint64_t m_counter GUARDED_BY(m_mutex) = 0;\n     bool m_strongly_seeded GUARDED_BY(m_mutex) = false;\n \n+    Mutex m_events_mutex;\n+    CSHA256 m_events_hasher GUARDED_BY(m_events_mutex);\n+\n public:\n     RNGState() noexcept\n     {\n@@ -370,6 +373,35 @@ class RNGState {\n     {\n     }\n \n+    void AddEvent(uint32_t event_info) noexcept\n+    {\n+        LOCK(m_events_mutex);\n+\n+        m_events_hasher.Write((const unsigned char *)&event_info, sizeof(event_info));\n+        // Get the low four bytes of the performance counter. This translates to roughly the\n+        // subsecond part.\n+        uint32_t perfcounter = (GetPerformanceCounter() & 0xffffffff);\n+        m_events_hasher.Write((const unsigned char*)&perfcounter, sizeof(perfcounter));\n+    }\n+\n+    /**\n+     * Feed (the hash of) all events added through AddEvent() to hasher.\n+     */\n+    void SeedEvents(CSHA512& hasher) noexcept\n+    {\n+        // We use only SHA256 for the events hashing to get the ASM speedups we have for SHA256,\n+        // since we want it to be fast as network peers may be able to trigger it repeatedly.\n+        LOCK(m_events_mutex);\n+\n+        unsigned char events_hash[32];\n+        m_events_hasher.Finalize(events_hash);\n+        hasher.Write(events_hash, 32);\n+\n+        // Re-initialize the hasher with the finalized state to use later.\n+        m_events_hasher.Reset();\n+        m_events_hasher.Write(events_hash, 32);\n+    }\n+\n     /** Extract up to 32 bytes of entropy from the RNG state, mixing in new entropy from hasher.\n      *\n      * If this function has never been called with strong_seed = true, false is returned.\n@@ -440,24 +472,7 @@ static void SeedFast(CSHA512& hasher) noexcept\n     SeedTimestamp(hasher);\n }\n \n-// We use only SHA256 for the events hashing to get the ASM speedups we have for SHA256,\n-// since we want it to be fast as network peers may be able to trigger it repeatedly.\n-static Mutex events_mutex;\n-static CSHA256 events_hasher;\n-static void SeedEvents(CSHA512& hasher)\n-{\n-    LOCK(events_mutex);\n-\n-    unsigned char events_hash[32];\n-    events_hasher.Finalize(events_hash);\n-    hasher.Write(events_hash, 32);\n-\n-    // Re-initialize the hasher with the finalized state to use later.\n-    events_hasher.Reset();\n-    events_hasher.Write(events_hash, 32);\n-}\n-\n-static void SeedSlow(CSHA512& hasher) noexcept\n+static void SeedSlow(CSHA512& hasher, RNGState& rng) noexcept\n {\n     unsigned char buffer[32];\n \n@@ -469,7 +484,7 @@ static void SeedSlow(CSHA512& hasher) noexcept\n     hasher.Write(buffer, sizeof(buffer));\n \n     // Add the events hasher into the mix\n-    SeedEvents(hasher);\n+    rng.SeedEvents(hasher);\n \n     // High-precision timestamp.\n     //\n@@ -497,7 +512,7 @@ static void SeedPeriodic(CSHA512& hasher, RNGState& rng) noexcept\n     SeedTimestamp(hasher);\n \n     // Add the events hasher into the mix\n-    SeedEvents(hasher);\n+    rng.SeedEvents(hasher);\n \n     // Dynamic environment data (performance monitoring, ...)\n     auto old_size = hasher.Size();\n@@ -514,7 +529,7 @@ static void SeedStartup(CSHA512& hasher, RNGState& rng) noexcept\n     SeedHardwareSlow(hasher);\n \n     // Everything that the 'slow' seeder includes.\n-    SeedSlow(hasher);\n+    SeedSlow(hasher, rng);\n \n     // Dynamic environment data (performance monitoring, ...)\n     auto old_size = hasher.Size();\n@@ -534,7 +549,7 @@ enum class RNGLevel {\n     PERIODIC, //!< Called by RandAddPeriodic()\n };\n \n-static void ProcRand(unsigned char* out, int num, RNGLevel level)\n+static void ProcRand(unsigned char* out, int num, RNGLevel level) noexcept\n {\n     // Make sure the RNG is initialized first (as all Seed* function possibly need hwrand to be available).\n     RNGState& rng = GetRNGState();\n@@ -547,7 +562,7 @@ static void ProcRand(unsigned char* out, int num, RNGLevel level)\n         SeedFast(hasher);\n         break;\n     case RNGLevel::SLOW:\n-        SeedSlow(hasher);\n+        SeedSlow(hasher, rng);\n         break;\n     case RNGLevel::PERIODIC:\n         SeedPeriodic(hasher, rng);\n@@ -566,15 +581,7 @@ static void ProcRand(unsigned char* out, int num, RNGLevel level)\n void GetRandBytes(unsigned char* buf, int num) noexcept { ProcRand(buf, num, RNGLevel::FAST); }\n void GetStrongRandBytes(unsigned char* buf, int num) noexcept { ProcRand(buf, num, RNGLevel::SLOW); }\n void RandAddPeriodic() noexcept { ProcRand(nullptr, 0, RNGLevel::PERIODIC); }\n-\n-void RandAddEvent(const uint32_t event_info) {\n-    LOCK(events_mutex);\n-    events_hasher.Write((const unsigned char *)&event_info, sizeof(event_info));\n-    // Get the low four bytes of the performance counter. This translates to roughly the\n-    // subsecond part.\n-    uint32_t perfcounter = (GetPerformanceCounter() & 0xffffffff);\n-    events_hasher.Write((const unsigned char*)&perfcounter, sizeof(perfcounter));\n-}\n+void RandAddEvent(const uint32_t event_info) noexcept { GetRNGState().AddEvent(event_info); }\n \n bool g_mock_deterministic_tests{false};\n "
      },
      {
        "sha": "e1b105168d5d76062bb70ffc6ba61bcb47db7074",
        "filename": "src/random.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8bda0960f94dfb6462fc810cd61a8a065730eb79/src/random.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8bda0960f94dfb6462fc810cd61a8a065730eb79/src/random.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/random.h?ref=8bda0960f94dfb6462fc810cd61a8a065730eb79",
        "patch": "@@ -95,7 +95,7 @@ void RandAddPeriodic() noexcept;\n  *\n  * Thread-safe.\n  */\n-void RandAddEvent(const uint32_t event_info);\n+void RandAddEvent(const uint32_t event_info) noexcept;\n \n /**\n  * Fast randomness source. This is seeded once with secure random data, but"
      }
    ]
  }
]