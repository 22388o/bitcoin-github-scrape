[
  {
    "sha": "92edbbfd862545a97db932095491ea155feb32ec",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5MmVkYmJmZDg2MjU0NWE5N2RiOTMyMDk1NDkxZWExNTVmZWIzMmVj",
    "commit": {
      "author": {
        "name": "dboures",
        "email": "dboures@att.net",
        "date": "2020-05-31T22:56:45Z"
      },
      "committer": {
        "name": "dboures",
        "email": "dboures@att.net",
        "date": "2020-07-23T00:39:49Z"
      },
      "message": "test: Replace global wait_until with mininode wait_until",
      "tree": {
        "sha": "c498e8f1fe60287117715087e2ba53dfb726b788",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c498e8f1fe60287117715087e2ba53dfb726b788"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/92edbbfd862545a97db932095491ea155feb32ec",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/92edbbfd862545a97db932095491ea155feb32ec",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/92edbbfd862545a97db932095491ea155feb32ec",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/92edbbfd862545a97db932095491ea155feb32ec/comments",
    "author": {
      "login": "dboures",
      "id": 24765307,
      "node_id": "MDQ6VXNlcjI0NzY1MzA3",
      "avatar_url": "https://avatars.githubusercontent.com/u/24765307?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dboures",
      "html_url": "https://github.com/dboures",
      "followers_url": "https://api.github.com/users/dboures/followers",
      "following_url": "https://api.github.com/users/dboures/following{/other_user}",
      "gists_url": "https://api.github.com/users/dboures/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dboures/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dboures/subscriptions",
      "organizations_url": "https://api.github.com/users/dboures/orgs",
      "repos_url": "https://api.github.com/users/dboures/repos",
      "events_url": "https://api.github.com/users/dboures/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dboures/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "dboures",
      "id": 24765307,
      "node_id": "MDQ6VXNlcjI0NzY1MzA3",
      "avatar_url": "https://avatars.githubusercontent.com/u/24765307?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dboures",
      "html_url": "https://github.com/dboures",
      "followers_url": "https://api.github.com/users/dboures/followers",
      "following_url": "https://api.github.com/users/dboures/following{/other_user}",
      "gists_url": "https://api.github.com/users/dboures/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dboures/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dboures/subscriptions",
      "organizations_url": "https://api.github.com/users/dboures/orgs",
      "repos_url": "https://api.github.com/users/dboures/repos",
      "events_url": "https://api.github.com/users/dboures/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dboures/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ccef10261efc235c8fcc8aad54556615b0cc23be",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ccef10261efc235c8fcc8aad54556615b0cc23be",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ccef10261efc235c8fcc8aad54556615b0cc23be"
      }
    ],
    "stats": {
      "total": 72,
      "additions": 34,
      "deletions": 38
    },
    "files": [
      {
        "sha": "5eb1f848c6d50c17c0fff3857e4cc90986c19ba8",
        "filename": "test/functional/feature_abortnode.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92edbbfd862545a97db932095491ea155feb32ec/test/functional/feature_abortnode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92edbbfd862545a97db932095491ea155feb32ec/test/functional/feature_abortnode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_abortnode.py?ref=92edbbfd862545a97db932095491ea155feb32ec",
        "patch": "@@ -11,7 +11,7 @@\n \"\"\"\n \n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import wait_until, get_datadir_path, connect_nodes\n+from test_framework.util import get_datadir_path, connect_nodes\n import os\n \n \n@@ -41,7 +41,7 @@ def run_test(self):\n \n             # Check that node0 aborted\n             self.log.info(\"Waiting for crash\")\n-            wait_until(lambda: self.nodes[0].is_node_stopped(), timeout=200)\n+            self.nodes[0].wait_until_stopped()\n         self.log.info(\"Node crashed - now verifying restart fails\")\n         self.nodes[0].assert_start_raises_init_error()\n "
      },
      {
        "sha": "1a46e9f35b2b2ab9abbd1c7723cf4d45021c1466",
        "filename": "test/functional/p2p_compactblocks.py",
        "status": "modified",
        "additions": 14,
        "deletions": 14,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92edbbfd862545a97db932095491ea155feb32ec/test/functional/p2p_compactblocks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92edbbfd862545a97db932095491ea155feb32ec/test/functional/p2p_compactblocks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_compactblocks.py?ref=92edbbfd862545a97db932095491ea155feb32ec",
        "patch": "@@ -14,7 +14,7 @@\n from test_framework.mininode import mininode_lock, P2PInterface\n from test_framework.script import CScript, OP_TRUE, OP_DROP\n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import assert_equal, wait_until, softfork_active\n+from test_framework.util import assert_equal, softfork_active\n \n # TestP2PConn: A peer we use to send messages to bitcoind, and store responses.\n class TestP2PConn(P2PInterface):\n@@ -73,23 +73,23 @@ def send_header_for_blocks(self, new_blocks):\n     def request_headers_and_sync(self, locator, hashstop=0):\n         self.clear_block_announcement()\n         self.get_headers(locator, hashstop)\n-        wait_until(self.received_block_announcement, timeout=30, lock=mininode_lock)\n+        self.wait_until(self.received_block_announcement, timeout=30)\n         self.clear_block_announcement()\n \n     # Block until a block announcement for a particular block hash is\n     # received.\n     def wait_for_block_announcement(self, block_hash, timeout=30):\n         def received_hash():\n             return (block_hash in self.announced_blockhashes)\n-        wait_until(received_hash, timeout=timeout, lock=mininode_lock)\n+        self.wait_until(received_hash, timeout=timeout)\n \n     def send_await_disconnect(self, message, timeout=30):\n         \"\"\"Sends a message to the node and wait for disconnect.\n \n         This is used when we want to send a message into the node that we expect\n         will get us disconnected, eg an invalid block.\"\"\"\n         self.send_message(message)\n-        wait_until(lambda: not self.is_connected, timeout=timeout, lock=mininode_lock)\n+        self.wait_until(lambda: not self.is_connected, timeout=timeout)\n \n class CompactBlocksTest(BitcoinTestFramework):\n     def set_test_params(self):\n@@ -154,7 +154,7 @@ def test_sendcmpct(self, test_node, old_node=None):\n         # Make sure we get a SENDCMPCT message from our peer\n         def received_sendcmpct():\n             return (len(test_node.last_sendcmpct) > 0)\n-        wait_until(received_sendcmpct, timeout=30, lock=mininode_lock)\n+        test_node.wait_until(received_sendcmpct, timeout=30)\n         with mininode_lock:\n             # Check that the first version received is the preferred one\n             assert_equal(test_node.last_sendcmpct[0].version, preferred_version)\n@@ -294,7 +294,7 @@ def test_compactblock_construction(self, test_node, use_witness_address=True):\n         block.rehash()\n \n         # Wait until the block was announced (via compact blocks)\n-        wait_until(test_node.received_block_announcement, timeout=30, lock=mininode_lock)\n+        test_node.wait_until(test_node.received_block_announcement, timeout=30)\n \n         # Now fetch and check the compact block\n         header_and_shortids = None\n@@ -309,7 +309,7 @@ def test_compactblock_construction(self, test_node, use_witness_address=True):\n         inv = CInv(MSG_CMPCT_BLOCK, block_hash)\n         test_node.send_message(msg_getdata([inv]))\n \n-        wait_until(test_node.received_block_announcement, timeout=30, lock=mininode_lock)\n+        test_node.wait_until(test_node.received_block_announcement, timeout=30)\n \n         # Now fetch and check the compact block\n         header_and_shortids = None\n@@ -380,7 +380,7 @@ def test_compactblock_requests(self, test_node, segwit=True):\n \n             if announce == \"inv\":\n                 test_node.send_message(msg_inv([CInv(MSG_BLOCK, block.sha256)]))\n-                wait_until(lambda: \"getheaders\" in test_node.last_message, timeout=30, lock=mininode_lock)\n+                test_node.wait_until(lambda: \"getheaders\" in test_node.last_message, timeout=30)\n                 test_node.send_header_for_blocks([block])\n             else:\n                 test_node.send_header_for_blocks([block])\n@@ -590,7 +590,7 @@ def test_getblocktxn_handler(self, test_node):\n             num_to_request = random.randint(1, len(block.vtx))\n             msg.block_txn_request.from_absolute(sorted(random.sample(range(len(block.vtx)), num_to_request)))\n             test_node.send_message(msg)\n-            wait_until(lambda: \"blocktxn\" in test_node.last_message, timeout=10, lock=mininode_lock)\n+            test_node.wait_until(lambda: \"blocktxn\" in test_node.last_message, timeout=10)\n \n             [tx.calc_sha256() for tx in block.vtx]\n             with mininode_lock:\n@@ -630,20 +630,20 @@ def test_compactblocks_not_at_tip(self, test_node):\n         for i in range(MAX_CMPCTBLOCK_DEPTH + 1):\n             test_node.clear_block_announcement()\n             new_blocks.append(node.generate(1)[0])\n-            wait_until(test_node.received_block_announcement, timeout=30, lock=mininode_lock)\n+            test_node.wait_until(test_node.received_block_announcement, timeout=30)\n \n         test_node.clear_block_announcement()\n         test_node.send_message(msg_getdata([CInv(MSG_CMPCT_BLOCK, int(new_blocks[0], 16))]))\n-        wait_until(lambda: \"cmpctblock\" in test_node.last_message, timeout=30, lock=mininode_lock)\n+        test_node.wait_until(lambda: \"cmpctblock\" in test_node.last_message, timeout=30)\n \n         test_node.clear_block_announcement()\n         node.generate(1)\n-        wait_until(test_node.received_block_announcement, timeout=30, lock=mininode_lock)\n+        test_node.wait_until(test_node.received_block_announcement, timeout=30)\n         test_node.clear_block_announcement()\n         with mininode_lock:\n             test_node.last_message.pop(\"block\", None)\n         test_node.send_message(msg_getdata([CInv(MSG_CMPCT_BLOCK, int(new_blocks[0], 16))]))\n-        wait_until(lambda: \"block\" in test_node.last_message, timeout=30, lock=mininode_lock)\n+        test_node.wait_until(lambda: \"block\" in test_node.last_message, timeout=30)\n         with mininode_lock:\n             test_node.last_message[\"block\"].block.calc_sha256()\n             assert_equal(test_node.last_message[\"block\"].block.sha256, int(new_blocks[0], 16))\n@@ -691,7 +691,7 @@ def test_end_to_end_block_relay(self, listeners):\n         node.submitblock(ToHex(block))\n \n         for l in listeners:\n-            wait_until(lambda: l.received_block_announcement(), timeout=30, lock=mininode_lock)\n+            l.wait_until(lambda: l.received_block_announcement(), timeout=30)\n         with mininode_lock:\n             for l in listeners:\n                 assert \"cmpctblock\" in l.last_message"
      },
      {
        "sha": "05bee47c559d89877ae7f9332caa058113a9a6ed",
        "filename": "test/functional/p2p_fingerprint.py",
        "status": "modified",
        "additions": 4,
        "deletions": 5,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92edbbfd862545a97db932095491ea155feb32ec/test/functional/p2p_fingerprint.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92edbbfd862545a97db932095491ea155feb32ec/test/functional/p2p_fingerprint.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_fingerprint.py?ref=92edbbfd862545a97db932095491ea155feb32ec",
        "patch": "@@ -22,7 +22,6 @@\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n     assert_equal,\n-    wait_until,\n )\n \n class P2PFingerprintTest(BitcoinTestFramework):\n@@ -102,12 +101,12 @@ def run_test(self):\n         # Check that getdata request for stale block succeeds\n         self.send_block_request(stale_hash, node0)\n         test_function = lambda: self.last_block_equals(stale_hash, node0)\n-        wait_until(test_function, timeout=3)\n+        node0.wait_until(test_function, timeout=3)\n \n         # Check that getheader request for stale block header succeeds\n         self.send_header_request(stale_hash, node0)\n         test_function = lambda: self.last_header_equals(stale_hash, node0)\n-        wait_until(test_function, timeout=3)\n+        node0.wait_until(test_function, timeout=3)\n \n         # Longest chain is extended so stale is much older than chain tip\n         self.nodes[0].setmocktime(0)\n@@ -138,11 +137,11 @@ def run_test(self):\n \n         self.send_block_request(block_hash, node0)\n         test_function = lambda: self.last_block_equals(block_hash, node0)\n-        wait_until(test_function, timeout=3)\n+        node0.wait_until(test_function, timeout=3)\n \n         self.send_header_request(block_hash, node0)\n         test_function = lambda: self.last_header_equals(block_hash, node0)\n-        wait_until(test_function, timeout=3)\n+        node0.wait_until(test_function, timeout=3)\n \n if __name__ == '__main__':\n     P2PFingerprintTest().main()"
      },
      {
        "sha": "439f155658b7734dd98a1a5af802e8321cbb479e",
        "filename": "test/functional/p2p_node_network_limited.py",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92edbbfd862545a97db932095491ea155feb32ec/test/functional/p2p_node_network_limited.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92edbbfd862545a97db932095491ea155feb32ec/test/functional/p2p_node_network_limited.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_node_network_limited.py?ref=92edbbfd862545a97db932095491ea155feb32ec",
        "patch": "@@ -9,13 +9,12 @@\n     - send a block within 288 + 2 of the tip\n     - disconnect peers who request blocks older than that.\"\"\"\n from test_framework.messages import CInv, MSG_BLOCK, msg_getdata, msg_verack, NODE_NETWORK_LIMITED, NODE_WITNESS\n-from test_framework.mininode import P2PInterface, mininode_lock\n+from test_framework.mininode import P2PInterface\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n     assert_equal,\n     disconnect_nodes,\n     connect_nodes,\n-    wait_until,\n )\n \n \n@@ -28,7 +27,7 @@ def on_addr(self, message):\n         self.firstAddrnServices = message.addrs[0].nServices\n     def wait_for_addr(self, timeout=5):\n         test_function = lambda: self.last_message.get(\"addr\")\n-        wait_until(test_function, timeout=timeout, lock=mininode_lock)\n+        self.wait_until(test_function)\n     def send_getdata_for_block(self, blockhash):\n         getdata_request = msg_getdata()\n         getdata_request.inv.append(CInv(MSG_BLOCK, int(blockhash, 16)))"
      },
      {
        "sha": "50f2ee20ecf82dd402c375702da5d4b3f3267925",
        "filename": "test/functional/p2p_ping.py",
        "status": "modified",
        "additions": 6,
        "deletions": 7,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92edbbfd862545a97db932095491ea155feb32ec/test/functional/p2p_ping.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92edbbfd862545a97db932095491ea155feb32ec/test/functional/p2p_ping.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_ping.py?ref=92edbbfd862545a97db932095491ea155feb32ec",
        "patch": "@@ -12,7 +12,6 @@\n )\n from test_framework.mininode import (\n     P2PInterface,\n-    wait_until,\n )\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import assert_equal\n@@ -78,7 +77,7 @@ def run_test(self):\n         with self.nodes[0].assert_debug_log(['pong peer=0: Nonce mismatch']):\n             # mock time PING_INTERVAL ahead to trigger node into sending a ping\n             self.mock_forward(PING_INTERVAL + 1)\n-            wait_until(lambda: 'ping' in no_pong_node.last_message)\n+            no_pong_node.wait_until(lambda: 'ping' in no_pong_node.last_message)\n             self.mock_forward(9)\n             # Send the wrong pong\n             no_pong_node.send_and_ping(msg_pong(no_pong_node.last_message.pop('ping').nonce - 1))\n@@ -93,27 +92,27 @@ def run_test(self):\n         assert 'ping' not in no_pong_node.last_message\n         # mock time PING_INTERVAL ahead to trigger node into sending a ping\n         self.mock_forward(PING_INTERVAL + 1)\n-        wait_until(lambda: 'ping' in no_pong_node.last_message)\n+        no_pong_node.wait_until(lambda: 'ping' in no_pong_node.last_message)\n         ping_delay = 29\n         self.mock_forward(ping_delay)\n-        wait_until(lambda: 'ping' in no_pong_node.last_message)\n+        no_pong_node.wait_until(lambda: 'ping' in no_pong_node.last_message)\n         no_pong_node.send_and_ping(msg_pong(no_pong_node.last_message.pop('ping').nonce))\n         self.check_peer_info(pingtime=ping_delay, minping=ping_delay, pingwait=None)\n \n         self.log.info('Check that minping is decreased after a fast roundtrip')\n         # mock time PING_INTERVAL ahead to trigger node into sending a ping\n         self.mock_forward(PING_INTERVAL + 1)\n-        wait_until(lambda: 'ping' in no_pong_node.last_message)\n+        no_pong_node.wait_until(lambda: 'ping' in no_pong_node.last_message)\n         ping_delay = 9\n         self.mock_forward(ping_delay)\n-        wait_until(lambda: 'ping' in no_pong_node.last_message)\n+        no_pong_node.wait_until(lambda: 'ping' in no_pong_node.last_message)\n         no_pong_node.send_and_ping(msg_pong(no_pong_node.last_message.pop('ping').nonce))\n         self.check_peer_info(pingtime=ping_delay, minping=ping_delay, pingwait=None)\n \n         self.log.info('Check that peer is disconnected after ping timeout')\n         assert 'ping' not in no_pong_node.last_message\n         self.nodes[0].ping()\n-        wait_until(lambda: 'ping' in no_pong_node.last_message)\n+        no_pong_node.wait_until(lambda: 'ping' in no_pong_node.last_message)\n         with self.nodes[0].assert_debug_log(['ping timeout: 1201.000000s']):\n             self.mock_forward(20 * 60 + 1)\n             time.sleep(4)  # peertimeout + 1"
      },
      {
        "sha": "c2b8d4e0b3449404ffd5c9e7d8200a9090020649",
        "filename": "test/functional/p2p_tx_download.py",
        "status": "modified",
        "additions": 6,
        "deletions": 7,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92edbbfd862545a97db932095491ea155feb32ec/test/functional/p2p_tx_download.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92edbbfd862545a97db932095491ea155feb32ec/test/functional/p2p_tx_download.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_tx_download.py?ref=92edbbfd862545a97db932095491ea155feb32ec",
        "patch": "@@ -23,7 +23,6 @@\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n     assert_equal,\n-    wait_until,\n )\n from test_framework.address import ADDRESS_BCRT1_UNSPENDABLE\n \n@@ -80,7 +79,7 @@ def getdata_found(peer_index):\n         while outstanding_peer_index:\n             node_0_mocktime += MAX_GETDATA_INBOUND_WAIT\n             self.nodes[0].setmocktime(node_0_mocktime)\n-            wait_until(lambda: any(getdata_found(i) for i in outstanding_peer_index))\n+            p.wait_until(lambda: any(getdata_found(i) for i in outstanding_peer_index))\n             for i in outstanding_peer_index:\n                 if getdata_found(i):\n                     outstanding_peer_index.remove(i)\n@@ -137,21 +136,21 @@ def test_in_flight_max(self):\n         with mininode_lock:\n             p.tx_getdata_count = 0\n \n-        p.send_message(msg_inv([CInv(t=MSG_WTX, h=i) for i in txids]))\n-        wait_until(lambda: p.tx_getdata_count >= MAX_GETDATA_IN_FLIGHT, lock=mininode_lock)\n+        p.send_message(msg_inv([CInv(t=MSG_TX, h=i) for i in txids]))\n+        p.wait_until(lambda: p.tx_getdata_count >= MAX_GETDATA_IN_FLIGHT)\n         with mininode_lock:\n             assert_equal(p.tx_getdata_count, MAX_GETDATA_IN_FLIGHT)\n \n         self.log.info(\"Now check that if we send a NOTFOUND for a transaction, we'll get one more request\")\n-        p.send_message(msg_notfound(vec=[CInv(t=MSG_WTX, h=txids[0])]))\n-        wait_until(lambda: p.tx_getdata_count >= MAX_GETDATA_IN_FLIGHT + 1, timeout=10, lock=mininode_lock)\n+        p.send_message(msg_notfound(vec=[CInv(t=MSG_TX, h=txids[0])]))\n+        p.wait_until(lambda: p.tx_getdata_count >= MAX_GETDATA_IN_FLIGHT + 1, timeout=10)\n         with mininode_lock:\n             assert_equal(p.tx_getdata_count, MAX_GETDATA_IN_FLIGHT + 1)\n \n         WAIT_TIME = TX_EXPIRY_INTERVAL // 2 + TX_EXPIRY_INTERVAL\n         self.log.info(\"if we wait about {} minutes, we should eventually get more requests\".format(WAIT_TIME / 60))\n         self.nodes[0].setmocktime(int(time.time() + WAIT_TIME))\n-        wait_until(lambda: p.tx_getdata_count == MAX_GETDATA_IN_FLIGHT + 2)\n+        p.wait_until(lambda: p.tx_getdata_count == MAX_GETDATA_IN_FLIGHT + 2)\n         self.nodes[0].setmocktime(0)\n \n     def test_spurious_notfound(self):"
      }
    ]
  },
  {
    "sha": "4dd014e0d4d69b5fd11aaca1426626d869c0e744",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0ZGQwMTRlMGQ0ZDY5YjVmZDExYWFjYTE0MjY2MjZkODY5YzBlNzQ0",
    "commit": {
      "author": {
        "name": "dboures",
        "email": "dboures@att.net",
        "date": "2020-06-08T18:28:16Z"
      },
      "committer": {
        "name": "dboures",
        "email": "dboures@att.net",
        "date": "2020-07-23T00:39:49Z"
      },
      "message": "test: Use test framework wait_until",
      "tree": {
        "sha": "1a38f0c604e3e664c679c949514c372a8f01ce09",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1a38f0c604e3e664c679c949514c372a8f01ce09"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4dd014e0d4d69b5fd11aaca1426626d869c0e744",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4dd014e0d4d69b5fd11aaca1426626d869c0e744",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4dd014e0d4d69b5fd11aaca1426626d869c0e744",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4dd014e0d4d69b5fd11aaca1426626d869c0e744/comments",
    "author": {
      "login": "dboures",
      "id": 24765307,
      "node_id": "MDQ6VXNlcjI0NzY1MzA3",
      "avatar_url": "https://avatars.githubusercontent.com/u/24765307?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dboures",
      "html_url": "https://github.com/dboures",
      "followers_url": "https://api.github.com/users/dboures/followers",
      "following_url": "https://api.github.com/users/dboures/following{/other_user}",
      "gists_url": "https://api.github.com/users/dboures/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dboures/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dboures/subscriptions",
      "organizations_url": "https://api.github.com/users/dboures/orgs",
      "repos_url": "https://api.github.com/users/dboures/repos",
      "events_url": "https://api.github.com/users/dboures/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dboures/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "dboures",
      "id": 24765307,
      "node_id": "MDQ6VXNlcjI0NzY1MzA3",
      "avatar_url": "https://avatars.githubusercontent.com/u/24765307?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dboures",
      "html_url": "https://github.com/dboures",
      "followers_url": "https://api.github.com/users/dboures/followers",
      "following_url": "https://api.github.com/users/dboures/following{/other_user}",
      "gists_url": "https://api.github.com/users/dboures/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dboures/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dboures/subscriptions",
      "organizations_url": "https://api.github.com/users/dboures/orgs",
      "repos_url": "https://api.github.com/users/dboures/repos",
      "events_url": "https://api.github.com/users/dboures/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dboures/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "92edbbfd862545a97db932095491ea155feb32ec",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/92edbbfd862545a97db932095491ea155feb32ec",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/92edbbfd862545a97db932095491ea155feb32ec"
      }
    ],
    "stats": {
      "total": 108,
      "additions": 47,
      "deletions": 61
    },
    "files": [
      {
        "sha": "1986354959e1d3051221aaf6c9832ac2c2957783",
        "filename": "test/functional/example_test.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4dd014e0d4d69b5fd11aaca1426626d869c0e744/test/functional/example_test.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4dd014e0d4d69b5fd11aaca1426626d869c0e744/test/functional/example_test.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/example_test.py?ref=4dd014e0d4d69b5fd11aaca1426626d869c0e744",
        "patch": "@@ -26,7 +26,6 @@\n from test_framework.util import (\n     assert_equal,\n     connect_nodes,\n-    wait_until,\n )\n \n # P2PInterface is a class containing callbacks to be executed when a P2P\n@@ -203,7 +202,7 @@ def run_test(self):\n \n         # wait_until() will loop until a predicate condition is met. Use it to test properties of the\n         # P2PInterface objects.\n-        wait_until(lambda: sorted(blocks) == sorted(list(self.nodes[2].p2p.block_receive_map.keys())), timeout=5, lock=mininode_lock)\n+        self.wait_until(lambda: sorted(blocks) == sorted(list(self.nodes[2].p2p.block_receive_map.keys())), timeout=5, lock=mininode_lock)\n \n         self.log.info(\"Check that each block was received only once\")\n         # The network thread uses a global lock on data access to the P2PConnection objects when sending and receiving"
      },
      {
        "sha": "3497b49a196588f16603b55fa2767538b82fe1d7",
        "filename": "test/functional/feature_notifications.py",
        "status": "modified",
        "additions": 4,
        "deletions": 5,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4dd014e0d4d69b5fd11aaca1426626d869c0e744/test/functional/feature_notifications.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4dd014e0d4d69b5fd11aaca1426626d869c0e744/test/functional/feature_notifications.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_notifications.py?ref=4dd014e0d4d69b5fd11aaca1426626d869c0e744",
        "patch": "@@ -9,7 +9,6 @@\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n     assert_equal,\n-    wait_until,\n     connect_nodes,\n     disconnect_nodes,\n     hex_str_to_bytes,\n@@ -56,15 +55,15 @@ def run_test(self):\n         blocks = self.nodes[1].generatetoaddress(block_count, self.nodes[1].getnewaddress() if self.is_wallet_compiled() else ADDRESS_BCRT1_UNSPENDABLE)\n \n         # wait at most 10 seconds for expected number of files before reading the content\n-        wait_until(lambda: len(os.listdir(self.blocknotify_dir)) == block_count, timeout=10)\n+        self.wait_until(lambda: len(os.listdir(self.blocknotify_dir)) == block_count, timeout=10)\n \n         # directory content should equal the generated blocks hashes\n         assert_equal(sorted(blocks), sorted(os.listdir(self.blocknotify_dir)))\n \n         if self.is_wallet_compiled():\n             self.log.info(\"test -walletnotify\")\n             # wait at most 10 seconds for expected number of files before reading the content\n-            wait_until(lambda: len(os.listdir(self.walletnotify_dir)) == block_count, timeout=10)\n+            self.wait_until(lambda: len(os.listdir(self.walletnotify_dir)) == block_count, timeout=10)\n \n             # directory content should equal the generated transaction hashes\n             txids_rpc = list(map(lambda t: notify_outputname(self.wallet, t['txid']), self.nodes[1].listtransactions(\"*\", block_count)))\n@@ -78,7 +77,7 @@ def run_test(self):\n             self.start_node(1)\n             connect_nodes(self.nodes[0], 1)\n \n-            wait_until(lambda: len(os.listdir(self.walletnotify_dir)) == block_count, timeout=10)\n+            self.wait_until(lambda: len(os.listdir(self.walletnotify_dir)) == block_count, timeout=10)\n \n             # directory content should equal the generated transaction hashes\n             txids_rpc = list(map(lambda t: notify_outputname(self.wallet, t['txid']), self.nodes[1].listtransactions(\"*\", block_count)))\n@@ -140,7 +139,7 @@ def run_test(self):\n         # TODO: add test for `-alertnotify` large fork notifications\n \n     def expect_wallet_notify(self, tx_ids):\n-        wait_until(lambda: len(os.listdir(self.walletnotify_dir)) >= len(tx_ids), timeout=10)\n+        self.wait_until(lambda: len(os.listdir(self.walletnotify_dir)) >= len(tx_ids), timeout=10)\n         assert_equal(sorted(notify_outputname(self.wallet, tx_id) for tx_id in tx_ids), sorted(os.listdir(self.walletnotify_dir)))\n         for tx_file in os.listdir(self.walletnotify_dir):\n             os.remove(os.path.join(self.walletnotify_dir, tx_file))"
      },
      {
        "sha": "074467497d9d73d540e74ef6cad8aab9baced56a",
        "filename": "test/functional/feature_pruning.py",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4dd014e0d4d69b5fd11aaca1426626d869c0e744/test/functional/feature_pruning.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4dd014e0d4d69b5fd11aaca1426626d869c0e744/test/functional/feature_pruning.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_pruning.py?ref=4dd014e0d4d69b5fd11aaca1426626d869c0e744",
        "patch": "@@ -20,7 +20,6 @@\n     assert_raises_rpc_error,\n     connect_nodes,\n     disconnect_nodes,\n-    wait_until,\n )\n \n # Rescans start at the earliest block up to 2 hours before a key timestamp, so\n@@ -136,7 +135,7 @@ def test_height_min(self):\n         mine_large_blocks(self.nodes[0], 25)\n \n         # Wait for blk00000.dat to be pruned\n-        wait_until(lambda: not os.path.isfile(os.path.join(self.prunedir, \"blk00000.dat\")), timeout=30)\n+        self.wait_until(lambda: not os.path.isfile(os.path.join(self.prunedir, \"blk00000.dat\")), timeout=30)\n \n         self.log.info(\"Success\")\n         usage = calc_usage(self.prunedir)\n@@ -250,7 +249,7 @@ def reorg_back(self):\n \n         self.log.info(\"Verify node 2 reorged back to the main chain, some blocks of which it had to redownload\")\n         # Wait for Node 2 to reorg to proper height\n-        wait_until(lambda: self.nodes[2].getblockcount() >= goalbestheight, timeout=900)\n+        self.wait_until(lambda: self.nodes[2].getblockcount() >= goalbestheight, timeout=900)\n         assert_equal(self.nodes[2].getbestblockhash(), goalbesthash)\n         # Verify we can now have the data for a block previously pruned\n         assert_equal(self.nodes[2].getblock(self.forkhash)[\"height\"], self.forkheight)"
      },
      {
        "sha": "a76e0f1b50afc9a81b9fb580c6cd1a85b557ada9",
        "filename": "test/functional/feature_shutdown.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4dd014e0d4d69b5fd11aaca1426626d869c0e744/test/functional/feature_shutdown.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4dd014e0d4d69b5fd11aaca1426626d869c0e744/test/functional/feature_shutdown.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_shutdown.py?ref=4dd014e0d4d69b5fd11aaca1426626d869c0e744",
        "patch": "@@ -5,7 +5,7 @@\n \"\"\"Test bitcoind shutdown.\"\"\"\n \n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import assert_equal, get_rpc_proxy, wait_until\n+from test_framework.util import assert_equal, get_rpc_proxy\n from threading import Thread\n \n def test_long_call(node):\n@@ -25,7 +25,7 @@ def run_test(self):\n         node.getblockcount()\n         Thread(target=test_long_call, args=(node,)).start()\n         # Wait until the server is executing the above `waitfornewblock`.\n-        wait_until(lambda: len(self.nodes[0].getrpcinfo()['active_commands']) == 2)\n+        self.wait_until(lambda: len(self.nodes[0].getrpcinfo()['active_commands']) == 2)\n         # Wait 1 second after requesting shutdown but not before the `stop` call\n         # finishes. This is to ensure event loop waits for current connections\n         # to close."
      },
      {
        "sha": "0a1a3708d8e2167c45b69d9f1606762d5f049b6a",
        "filename": "test/functional/feature_versionbits_warning.py",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4dd014e0d4d69b5fd11aaca1426626d869c0e744/test/functional/feature_versionbits_warning.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4dd014e0d4d69b5fd11aaca1426626d869c0e744/test/functional/feature_versionbits_warning.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_versionbits_warning.py?ref=4dd014e0d4d69b5fd11aaca1426626d869c0e744",
        "patch": "@@ -14,7 +14,6 @@\n from test_framework.messages import msg_block\n from test_framework.mininode import P2PInterface, mininode_lock\n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import wait_until\n \n VB_PERIOD = 144           # versionbits period length for regtest\n VB_THRESHOLD = 108        # versionbits activation threshold for regtest\n@@ -91,14 +90,14 @@ def run_test(self):\n \n         # Generating one block guarantees that we'll get out of IBD\n         node.generatetoaddress(1, node_deterministic_address)\n-        wait_until(lambda: not node.getblockchaininfo()['initialblockdownload'], timeout=10, lock=mininode_lock)\n+        self.wait_until(lambda: not node.getblockchaininfo()['initialblockdownload'], timeout=10, lock=mininode_lock)\n         # Generating one more block will be enough to generate an error.\n         node.generatetoaddress(1, node_deterministic_address)\n         # Check that get*info() shows the versionbits unknown rules warning\n         assert WARN_UNKNOWN_RULES_ACTIVE in node.getmininginfo()[\"warnings\"]\n         assert WARN_UNKNOWN_RULES_ACTIVE in node.getnetworkinfo()[\"warnings\"]\n         # Check that the alert file shows the versionbits unknown rules warning\n-        wait_until(lambda: self.versionbits_in_alert_file(), timeout=60)\n+        self.wait_until(lambda: self.versionbits_in_alert_file())\n \n if __name__ == '__main__':\n     VersionBitsWarningTest().main()"
      },
      {
        "sha": "da716e952f24140be49e60cdaf3acaf3636fc78a",
        "filename": "test/functional/mempool_packages.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4dd014e0d4d69b5fd11aaca1426626d869c0e744/test/functional/mempool_packages.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4dd014e0d4d69b5fd11aaca1426626d869c0e744/test/functional/mempool_packages.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_packages.py?ref=4dd014e0d4d69b5fd11aaca1426626d869c0e744",
        "patch": "@@ -13,7 +13,6 @@\n     assert_equal,\n     assert_raises_rpc_error,\n     satoshi_round,\n-    wait_until,\n )\n \n # default limits\n@@ -269,7 +268,7 @@ def run_test(self):\n         # - txs from previous ancestor test (-> custom ancestor limit)\n         # - parent tx for descendant test\n         # - txs chained off parent tx (-> custom descendant limit)\n-        wait_until(lambda: len(self.nodes[1].getrawmempool(False)) ==\n+        self.wait_until(lambda: len(self.nodes[1].getrawmempool(False)) ==\n                            MAX_ANCESTORS_CUSTOM + 1 + MAX_DESCENDANTS_CUSTOM, timeout=10)\n         mempool0 = self.nodes[0].getrawmempool(False)\n         mempool1 = self.nodes[1].getrawmempool(False)"
      },
      {
        "sha": "e8cee0e30c9b382a36f8bd87914fdcceba5803dd",
        "filename": "test/functional/mempool_persist.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4dd014e0d4d69b5fd11aaca1426626d869c0e744/test/functional/mempool_persist.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4dd014e0d4d69b5fd11aaca1426626d869c0e744/test/functional/mempool_persist.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_persist.py?ref=4dd014e0d4d69b5fd11aaca1426626d869c0e744",
        "patch": "@@ -47,7 +47,6 @@\n     assert_raises_rpc_error,\n     connect_nodes,\n     disconnect_nodes,\n-    wait_until,\n )\n \n \n@@ -172,7 +171,7 @@ def test_persist_unbroadcast(self):\n         # check that txn gets broadcast due to unbroadcast logic\n         conn = node0.add_p2p_connection(P2PTxInvStore())\n         node0.mockscheduler(16*60) # 15 min + 1 for buffer\n-        wait_until(lambda: len(conn.get_invs()) == 1)\n+        self.wait_until(lambda: len(conn.get_invs()) == 1)\n \n if __name__ == '__main__':\n     MempoolPersistTest().main()"
      },
      {
        "sha": "2414a1f2240957c6ccf6510215b20064d8960e01",
        "filename": "test/functional/p2p_blockfilters.py",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4dd014e0d4d69b5fd11aaca1426626d869c0e744/test/functional/p2p_blockfilters.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4dd014e0d4d69b5fd11aaca1426626d869c0e744/test/functional/p2p_blockfilters.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_blockfilters.py?ref=4dd014e0d4d69b5fd11aaca1426626d869c0e744",
        "patch": "@@ -23,7 +23,6 @@\n     assert_equal,\n     connect_nodes,\n     disconnect_nodes,\n-    wait_until,\n )\n \n class CFiltersClient(P2PInterface):\n@@ -64,11 +63,11 @@ def run_test(self):\n         disconnect_nodes(self.nodes[0], 1)\n \n         self.nodes[0].generate(1)\n-        wait_until(lambda: self.nodes[0].getblockcount() == 1000)\n+        self.wait_until(lambda: self.nodes[0].getblockcount() == 1000)\n         stale_block_hash = self.nodes[0].getblockhash(1000)\n \n         self.nodes[1].generate(1001)\n-        wait_until(lambda: self.nodes[1].getblockcount() == 2000)\n+        self.wait_until(lambda: self.nodes[1].getblockcount() == 2000)\n \n         self.log.info(\"get cfcheckpt on chain to be re-orged out.\")\n         request = msg_getcfcheckpt("
      },
      {
        "sha": "b7c2a306ebc60a685b7cc5925b59de35ba3e10ea",
        "filename": "test/functional/p2p_disconnect_ban.py",
        "status": "modified",
        "additions": 3,
        "deletions": 4,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4dd014e0d4d69b5fd11aaca1426626d869c0e744/test/functional/p2p_disconnect_ban.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4dd014e0d4d69b5fd11aaca1426626d869c0e744/test/functional/p2p_disconnect_ban.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_disconnect_ban.py?ref=4dd014e0d4d69b5fd11aaca1426626d869c0e744",
        "patch": "@@ -10,7 +10,6 @@\n     assert_equal,\n     assert_raises_rpc_error,\n     connect_nodes,\n-    wait_until,\n )\n \n class DisconnectBanTest(BitcoinTestFramework):\n@@ -28,7 +27,7 @@ def run_test(self):\n         self.log.info(\"setban: successfully ban single IP address\")\n         assert_equal(len(self.nodes[1].getpeerinfo()), 2)  # node1 should have 2 connections to node0 at this point\n         self.nodes[1].setban(subnet=\"127.0.0.1\", command=\"add\")\n-        wait_until(lambda: len(self.nodes[1].getpeerinfo()) == 0, timeout=10)\n+        self.wait_until(lambda: len(self.nodes[1].getpeerinfo()) == 0, timeout=10)\n         assert_equal(len(self.nodes[1].getpeerinfo()), 0)  # all nodes must be disconnected at this point\n         assert_equal(len(self.nodes[1].listbanned()), 1)\n \n@@ -95,7 +94,7 @@ def run_test(self):\n         self.log.info(\"disconnectnode: successfully disconnect node by address\")\n         address1 = self.nodes[0].getpeerinfo()[0]['addr']\n         self.nodes[0].disconnectnode(address=address1)\n-        wait_until(lambda: len(self.nodes[0].getpeerinfo()) == 1, timeout=10)\n+        self.wait_until(lambda: len(self.nodes[0].getpeerinfo()) == 1, timeout=10)\n         assert not [node for node in self.nodes[0].getpeerinfo() if node['addr'] == address1]\n \n         self.log.info(\"disconnectnode: successfully reconnect node\")\n@@ -106,7 +105,7 @@ def run_test(self):\n         self.log.info(\"disconnectnode: successfully disconnect node by node id\")\n         id1 = self.nodes[0].getpeerinfo()[0]['id']\n         self.nodes[0].disconnectnode(nodeid=id1)\n-        wait_until(lambda: len(self.nodes[0].getpeerinfo()) == 1, timeout=10)\n+        self.wait_until(lambda: len(self.nodes[0].getpeerinfo()) == 1, timeout=10)\n         assert not [node for node in self.nodes[0].getpeerinfo() if node['id'] == id1]\n \n if __name__ == '__main__':"
      },
      {
        "sha": "64b88799ec9c6107503a3252e7446ca804c5316c",
        "filename": "test/functional/p2p_eviction.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4dd014e0d4d69b5fd11aaca1426626d869c0e744/test/functional/p2p_eviction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4dd014e0d4d69b5fd11aaca1426626d869c0e744/test/functional/p2p_eviction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_eviction.py?ref=4dd014e0d4d69b5fd11aaca1426626d869c0e744",
        "patch": "@@ -17,7 +17,7 @@\n \n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.mininode import P2PInterface, P2PDataStore\n-from test_framework.util import assert_equal, wait_until\n+from test_framework.util import assert_equal\n from test_framework.blocktools import create_block, create_coinbase\n from test_framework.messages import CTransaction, FromHex, msg_pong, msg_tx\n \n@@ -92,7 +92,7 @@ def run_test(self):\n         for _ in range(8):\n             fastpeer = node.add_p2p_connection(P2PInterface())\n             current_peer += 1\n-            wait_until(lambda: \"ping\" in fastpeer.last_message, timeout=10)\n+            self.wait_until(lambda: \"ping\" in fastpeer.last_message, timeout=10)\n \n         # Make sure by asking the node what the actual min pings are\n         peerinfo = node.getpeerinfo()"
      },
      {
        "sha": "3a605f193ff5c225aa333968464e251b3598d74a",
        "filename": "test/functional/p2p_invalid_messages.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4dd014e0d4d69b5fd11aaca1426626d869c0e744/test/functional/p2p_invalid_messages.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4dd014e0d4d69b5fd11aaca1426626d869c0e744/test/functional/p2p_invalid_messages.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_invalid_messages.py?ref=4dd014e0d4d69b5fd11aaca1426626d869c0e744",
        "patch": "@@ -24,7 +24,6 @@\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n     assert_equal,\n-    wait_until,\n )\n \n VALID_DATA_LIMIT = MAX_PROTOCOL_MESSAGE_LENGTH - 5  # Account for the 5-byte length prefix\n@@ -70,7 +69,7 @@ def test_buffer(self):\n         before = int(self.nodes[0].getnettotals()['totalbytesrecv'])\n         conn.send_raw_message(msg[:cut_pos])\n         # Wait until node has processed the first half of the message\n-        wait_until(lambda: int(self.nodes[0].getnettotals()['totalbytesrecv']) != before)\n+        self.wait_until(lambda: int(self.nodes[0].getnettotals()['totalbytesrecv']) != before)\n         middle = int(self.nodes[0].getnettotals()['totalbytesrecv'])\n         # If this assert fails, we've hit an unlikely race\n         # where the test framework sent a message in between the two halves"
      },
      {
        "sha": "630abb82b09610b33eb4db9ab3c09cb523396aea",
        "filename": "test/functional/p2p_invalid_tx.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4dd014e0d4d69b5fd11aaca1426626d869c0e744/test/functional/p2p_invalid_tx.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4dd014e0d4d69b5fd11aaca1426626d869c0e744/test/functional/p2p_invalid_tx.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_invalid_tx.py?ref=4dd014e0d4d69b5fd11aaca1426626d869c0e744",
        "patch": "@@ -17,7 +17,6 @@\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n     assert_equal,\n-    wait_until,\n )\n from data import invalid_txs\n \n@@ -146,7 +145,7 @@ def run_test(self):\n         # tx_orphan_no_fee, because it has too low fee (p2ps[0] is not disconnected for relaying that tx)\n         # tx_orphan_invaid, because it has negative fee (p2ps[1] is disconnected for relaying that tx)\n \n-        wait_until(lambda: 1 == len(node.getpeerinfo()), timeout=12)  # p2ps[1] is no longer connected\n+        self.wait_until(lambda: 1 == len(node.getpeerinfo()), timeout=12)  # p2ps[1] is no longer connected\n         assert_equal(expected_mempool, set(node.getrawmempool()))\n \n         self.log.info('Test orphan pool overflow')"
      },
      {
        "sha": "d3eb3451e2c6ee0ff916831700256c7f9a696d6b",
        "filename": "test/functional/p2p_leak.py",
        "status": "modified",
        "additions": 7,
        "deletions": 5,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4dd014e0d4d69b5fd11aaca1426626d869c0e744/test/functional/p2p_leak.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4dd014e0d4d69b5fd11aaca1426626d869c0e744/test/functional/p2p_leak.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_leak.py?ref=4dd014e0d4d69b5fd11aaca1426626d869c0e744",
        "patch": "@@ -23,7 +23,6 @@\n from test_framework.util import (\n     assert_equal,\n     assert_greater_than_or_equal,\n-    wait_until,\n )\n \n DISCOURAGEMENT_THRESHOLD = 100\n@@ -118,9 +117,9 @@ def run_test(self):\n         # verack, since we never sent one\n         no_verack_idlenode.wait_for_verack()\n \n-        wait_until(lambda: no_version_disconnect_node.ever_connected, timeout=10, lock=mininode_lock)\n-        wait_until(lambda: no_version_idlenode.ever_connected, timeout=10, lock=mininode_lock)\n-        wait_until(lambda: no_verack_idlenode.version_received, timeout=10, lock=mininode_lock)\n+        self.wait_until(lambda: no_version_disconnect_node.ever_connected, timeout=10, lock=mininode_lock)\n+        self.wait_until(lambda: no_version_idlenode.ever_connected, timeout=10, lock=mininode_lock)\n+        self.wait_until(lambda: no_verack_idlenode.version_received, timeout=10, lock=mininode_lock)\n \n         # Mine a block and make sure that it's not sent to the connected nodes\n         self.nodes[0].generatetoaddress(1, self.nodes[0].get_deterministic_priv_key().address)\n@@ -133,6 +132,9 @@ def run_test(self):\n \n         self.nodes[0].disconnect_p2ps()\n \n+        # Wait until all connections are closed\n+        self.wait_until(lambda: len(self.nodes[0].getpeerinfo()) == 0)\n+\n         # Make sure no unexpected messages came in\n         assert no_version_disconnect_node.unexpected_msg == False\n         assert no_version_idlenode.unexpected_msg == False\n@@ -153,7 +155,7 @@ def run_test(self):\n         p2p_old_node = self.nodes[0].add_p2p_connection(P2PInterface(), send_version=False, wait_for_verack=False)\n         old_version_msg = msg_version()\n         old_version_msg.nVersion = 31799\n-        wait_until(lambda: p2p_old_node.is_connected)\n+        self.wait_until(lambda: p2p_old_node.is_connected)\n         with self.nodes[0].assert_debug_log(['peer=4 using obsolete version 31799; disconnecting']):\n             p2p_old_node.send_message(old_version_msg)\n             p2p_old_node.wait_for_disconnect()"
      },
      {
        "sha": "6d7dede36c9fdb6b3ac7de651b7cc0454ea1b67e",
        "filename": "test/functional/p2p_permissions.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4dd014e0d4d69b5fd11aaca1426626d869c0e744/test/functional/p2p_permissions.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4dd014e0d4d69b5fd11aaca1426626d869c0e744/test/functional/p2p_permissions.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_permissions.py?ref=4dd014e0d4d69b5fd11aaca1426626d869c0e744",
        "patch": "@@ -24,7 +24,6 @@\n     assert_equal,\n     connect_nodes,\n     p2p_port,\n-    wait_until,\n )\n \n \n@@ -137,7 +136,7 @@ def check_tx_relay(self):\n         connect_nodes(self.nodes[1], 0)\n         with self.nodes[1].assert_debug_log([\"Force relaying tx {} from peer=0\".format(txid)]):\n             p2p_rebroadcast_wallet.send_txs_and_test([tx], self.nodes[1])\n-            wait_until(lambda: txid in self.nodes[0].getrawmempool())\n+            self.wait_until(lambda: txid in self.nodes[0].getrawmempool())\n \n         self.log.debug(\"Check that node[1] will not send an invalid tx to node[0]\")\n         tx.vout[0].nValue += 1"
      },
      {
        "sha": "fc59d8804e9f12e37571cb48c35db176eb39d2ce",
        "filename": "test/functional/p2p_sendheaders.py",
        "status": "modified",
        "additions": 5,
        "deletions": 6,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4dd014e0d4d69b5fd11aaca1426626d869c0e744/test/functional/p2p_sendheaders.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4dd014e0d4d69b5fd11aaca1426626d869c0e744/test/functional/p2p_sendheaders.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_sendheaders.py?ref=4dd014e0d4d69b5fd11aaca1426626d869c0e744",
        "patch": "@@ -104,7 +104,6 @@\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import (\n     assert_equal,\n-    wait_until,\n )\n \n DIRECT_FETCH_RESPONSE_TIME = 0.05\n@@ -145,9 +144,9 @@ def send_getblocks(self, locator):\n         getblocks_message.locator.vHave = locator\n         self.send_message(getblocks_message)\n \n-    def wait_for_block_announcement(self, block_hash, timeout=60):\n+    def wait_for_block_announcement(self, block_hash):\n         test_function = lambda: self.last_blockhash_announced == block_hash\n-        wait_until(test_function, timeout=timeout, lock=mininode_lock)\n+        self.wait_until(test_function)\n \n     def on_inv(self, message):\n         self.block_announced = True\n@@ -174,7 +173,7 @@ def check_last_headers_announcement(self, headers):\n         \"\"\"Test whether the last headers announcements received are right.\n            Headers may be announced across more than one message.\"\"\"\n         test_function = lambda: (len(self.recent_headers_announced) >= len(headers))\n-        wait_until(test_function, timeout=60, lock=mininode_lock)\n+        self.wait_until(test_function)\n         with mininode_lock:\n             assert_equal(self.recent_headers_announced, headers)\n             self.block_announced = False\n@@ -186,7 +185,7 @@ def check_last_inv_announcement(self, inv):\n         inv should be a list of block hashes.\"\"\"\n \n         test_function = lambda: self.block_announced\n-        wait_until(test_function, timeout=60, lock=mininode_lock)\n+        self.wait_until(test_function)\n \n         with mininode_lock:\n             compare_inv = []\n@@ -298,7 +297,7 @@ def test_nonnull_locators(self, test_node, inv_node):\n                 test_node.send_header_for_blocks([new_block])\n                 test_node.wait_for_getdata([new_block.sha256])\n                 test_node.send_and_ping(msg_block(new_block))  # make sure this block is processed\n-                wait_until(lambda: inv_node.block_announced, timeout=60, lock=mininode_lock)\n+                self.wait_until(lambda: inv_node.block_announced, lock=mininode_lock)\n                 inv_node.clear_block_announcements()\n                 test_node.clear_block_announcements()\n "
      },
      {
        "sha": "e788e75557a96038bf6aeb4a158d0fd39661de29",
        "filename": "test/functional/rpc_invalidateblock.py",
        "status": "modified",
        "additions": 3,
        "deletions": 4,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4dd014e0d4d69b5fd11aaca1426626d869c0e744/test/functional/rpc_invalidateblock.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4dd014e0d4d69b5fd11aaca1426626d869c0e744/test/functional/rpc_invalidateblock.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_invalidateblock.py?ref=4dd014e0d4d69b5fd11aaca1426626d869c0e744",
        "patch": "@@ -9,7 +9,6 @@\n from test_framework.util import (\n     assert_equal,\n     connect_nodes,\n-    wait_until,\n )\n \n \n@@ -57,9 +56,9 @@ def run_test(self):\n         self.log.info(\"..and then mine a block\")\n         self.nodes[2].generatetoaddress(1, self.nodes[2].get_deterministic_priv_key().address)\n         self.log.info(\"Verify all nodes are at the right height\")\n-        wait_until(lambda: self.nodes[2].getblockcount() == 3, timeout=5)\n-        wait_until(lambda: self.nodes[0].getblockcount() == 4, timeout=5)\n-        wait_until(lambda: self.nodes[1].getblockcount() == 4, timeout=5)\n+        self.wait_until(lambda: self.nodes[2].getblockcount() == 3, timeout=5)\n+        self.wait_until(lambda: self.nodes[0].getblockcount() == 4, timeout=5)\n+        self.wait_until(lambda: self.nodes[1].getblockcount() == 4, timeout=5)\n \n         self.log.info(\"Verify that we reconsider all ancestors as well\")\n         blocks = self.nodes[1].generatetodescriptor(10, ADDRESS_BCRT1_UNSPENDABLE_DESCRIPTOR)"
      },
      {
        "sha": "cd38c255fc2e1b8f25e69bd125db24a429f5043c",
        "filename": "test/functional/rpc_net.py",
        "status": "modified",
        "additions": 3,
        "deletions": 4,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4dd014e0d4d69b5fd11aaca1426626d869c0e744/test/functional/rpc_net.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4dd014e0d4d69b5fd11aaca1426626d869c0e744/test/functional/rpc_net.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_net.py?ref=4dd014e0d4d69b5fd11aaca1426626d869c0e744",
        "patch": "@@ -17,7 +17,6 @@\n     assert_raises_rpc_error,\n     connect_nodes,\n     p2p_port,\n-    wait_until,\n )\n from test_framework.mininode import P2PInterface\n import test_framework.messages\n@@ -90,8 +89,8 @@ def _test_getnettotals(self):\n         # the bytes sent/received should change\n         # note ping and pong are 32 bytes each\n         self.nodes[0].ping()\n-        wait_until(lambda: (self.nodes[0].getnettotals()['totalbytessent'] >= net_totals_after['totalbytessent'] + 32 * 2), timeout=1)\n-        wait_until(lambda: (self.nodes[0].getnettotals()['totalbytesrecv'] >= net_totals_after['totalbytesrecv'] + 32 * 2), timeout=1)\n+        self.wait_until(lambda: (self.nodes[0].getnettotals()['totalbytessent'] >= net_totals_after['totalbytessent'] + 32 * 2), timeout=1)\n+        self.wait_until(lambda: (self.nodes[0].getnettotals()['totalbytesrecv'] >= net_totals_after['totalbytesrecv'] + 32 * 2), timeout=1)\n \n         peer_info_after_ping = self.nodes[0].getpeerinfo()\n         for before, after in zip(peer_info, peer_info_after_ping):\n@@ -105,7 +104,7 @@ def _test_getnetworkinfo(self):\n         self.nodes[0].setnetworkactive(state=False)\n         assert_equal(self.nodes[0].getnetworkinfo()['networkactive'], False)\n         # Wait a bit for all sockets to close\n-        wait_until(lambda: self.nodes[0].getnetworkinfo()['connections'] == 0, timeout=3)\n+        self.wait_until(lambda: self.nodes[0].getnetworkinfo()['connections'] == 0, timeout=3)\n \n         self.nodes[0].setnetworkactive(state=True)\n         self.log.info('Connect nodes both way')"
      },
      {
        "sha": "d3ccff0abbd5723cf156159da7fc270b6e4b15ca",
        "filename": "test/functional/wallet_basic.py",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4dd014e0d4d69b5fd11aaca1426626d869c0e744/test/functional/wallet_basic.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4dd014e0d4d69b5fd11aaca1426626d869c0e744/test/functional/wallet_basic.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_basic.py?ref=4dd014e0d4d69b5fd11aaca1426626d869c0e744",
        "patch": "@@ -12,7 +12,6 @@\n     assert_fee_amount,\n     assert_raises_rpc_error,\n     connect_nodes,\n-    wait_until,\n )\n from test_framework.wallet_util import test_address\n \n@@ -540,7 +539,7 @@ def run_test(self):\n             self.start_node(2, [m, \"-limitancestorcount=\" + str(chainlimit)])\n             if m == '-reindex':\n                 # reindex will leave rpc warm up \"early\"; Wait for it to finish\n-                wait_until(lambda: [block_count] * 3 == [self.nodes[i].getblockcount() for i in range(3)])\n+                self.wait_until(lambda: [block_count] * 3 == [self.nodes[i].getblockcount() for i in range(3)])\n             assert_equal(balance_nodes, [self.nodes[i].getbalance() for i in range(3)])\n \n         # Exercise listsinceblock with the last two blocks\n@@ -589,7 +588,7 @@ def run_test(self):\n         self.start_node(0, extra_args=extra_args)\n \n         # wait until the wallet has submitted all transactions to the mempool\n-        wait_until(lambda: len(self.nodes[0].getrawmempool()) == chainlimit * 2)\n+        self.wait_until(lambda: len(self.nodes[0].getrawmempool()) == chainlimit * 2)\n \n         node0_balance = self.nodes[0].getbalance()\n         # With walletrejectlongchains we will not create the tx and store it in our wallet."
      },
      {
        "sha": "6500e81f90ab2599a2ce4f53dc090e1e8b1cccb0",
        "filename": "test/functional/wallet_resendwallettransactions.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4dd014e0d4d69b5fd11aaca1426626d869c0e744/test/functional/wallet_resendwallettransactions.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4dd014e0d4d69b5fd11aaca1426626d869c0e744/test/functional/wallet_resendwallettransactions.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_resendwallettransactions.py?ref=4dd014e0d4d69b5fd11aaca1426626d869c0e744",
        "patch": "@@ -9,7 +9,7 @@\n from test_framework.messages import ToHex\n from test_framework.mininode import P2PTxInvStore, mininode_lock\n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import assert_equal, wait_until\n+from test_framework.util import assert_equal\n \n class ResendWalletTransactionsTest(BitcoinTestFramework):\n     def set_test_params(self):\n@@ -33,7 +33,7 @@ def run_test(self):\n         time.sleep(1.1)\n \n         # Can take a few seconds due to transaction trickling\n-        wait_until(lambda: node.p2p.tx_invs_received[txid] >= 1, lock=mininode_lock)\n+        self.wait_until(lambda: node.p2p.tx_invs_received[txid] >= 1, lock=mininode_lock)\n \n         # Add a second peer since txs aren't rebroadcast to the same peer (see filterInventoryKnown)\n         node.add_p2p_connection(P2PTxInvStore())\n@@ -64,7 +64,7 @@ def run_test(self):\n         # Transaction should be rebroadcast approximately 24 hours in the future,\n         # but can range from 12-36. So bump 36 hours to be sure.\n         node.setmocktime(now + 36 * 60 * 60)\n-        wait_until(lambda: node.p2ps[1].tx_invs_received[txid] >= 1, lock=mininode_lock)\n+        self.wait_until(lambda: node.p2ps[1].tx_invs_received[txid] >= 1, lock=mininode_lock)\n \n \n if __name__ == '__main__':"
      },
      {
        "sha": "845923def201a31491a8f88f64f2069b0fbb7fae",
        "filename": "test/functional/wallet_zapwallettxes.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4dd014e0d4d69b5fd11aaca1426626d869c0e744/test/functional/wallet_zapwallettxes.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4dd014e0d4d69b5fd11aaca1426626d869c0e744/test/functional/wallet_zapwallettxes.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_zapwallettxes.py?ref=4dd014e0d4d69b5fd11aaca1426626d869c0e744",
        "patch": "@@ -18,7 +18,6 @@\n from test_framework.util import (\n     assert_equal,\n     assert_raises_rpc_error,\n-    wait_until,\n )\n \n class ZapWalletTXesTest (BitcoinTestFramework):\n@@ -59,7 +58,7 @@ def run_test(self):\n         # transaction is zapped from the wallet, but is re-added when the mempool is reloaded.\n         self.restart_node(0, [\"-persistmempool=1\", \"-zapwallettxes=2\"])\n \n-        wait_until(lambda: self.nodes[0].getmempoolinfo()['size'] == 1, timeout=3)\n+        self.wait_until(lambda: self.nodes[0].getmempoolinfo()['size'] == 1, timeout=3)\n         self.nodes[0].syncwithvalidationinterfacequeue()  # Flush mempool to wallet\n \n         assert_equal(self.nodes[0].gettransaction(txid1)['txid'], txid1)"
      }
    ]
  }
]