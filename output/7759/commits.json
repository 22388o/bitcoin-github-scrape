[
  {
    "sha": "2498324ff9eab770ffddca643f843f0b9a85dd1c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyNDk4MzI0ZmY5ZWFiNzcwZmZkZGNhNjQzZjg0M2YwYjlhODVkZDFj",
    "commit": {
      "author": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2016-03-28T13:56:13Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2016-09-28T15:11:49Z"
      },
      "message": "rest: Stream entire utxo set\n\nThis builds on #7756 and\n\n- Adds a streaming API to the HTTP server. This allows streaming data to\n  the client chunk by chunk, which is useful when not the entire data is\n  available at once or it is huge and wouldn't fit (efficiently) in\n  memory.\n\n- Allows downloading the entire UTXO set through `/rest/utxoset`. This\n  is a raw dump of all outputs, the state normally hashed by\n  `gettxoutsetinfo`. The dump is performed in the background by making\n  use of leveldb snapshotting, so without keeping cs_main locked.\n\n    - This can be useful for analysis purposes if you don't want to mess\n      with bitcoin core's database\n\n    - Filename (via content-disposition) is\n      `utxoset-<height>-<bestblockhash>.dat`. Also a custom\n      `X-Best-Block` and `X-Block-Height` header is added.",
      "tree": {
        "sha": "8eb616227c101c39ddf7a9455d0b1debedbc3c3e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8eb616227c101c39ddf7a9455d0b1debedbc3c3e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2498324ff9eab770ffddca643f843f0b9a85dd1c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2498324ff9eab770ffddca643f843f0b9a85dd1c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2498324ff9eab770ffddca643f843f0b9a85dd1c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2498324ff9eab770ffddca643f843f0b9a85dd1c/comments",
    "author": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "dc641415e75ed9be53e460587fc3fed8c1cd9987",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dc641415e75ed9be53e460587fc3fed8c1cd9987",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/dc641415e75ed9be53e460587fc3fed8c1cd9987"
      }
    ],
    "stats": {
      "total": 199,
      "additions": 197,
      "deletions": 2
    },
    "files": [
      {
        "sha": "26dd99dca81d949264660c934eb490071f63742f",
        "filename": "src/httpserver.cpp",
        "status": "modified",
        "additions": 101,
        "deletions": 2,
        "changes": 103,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2498324ff9eab770ffddca643f843f0b9a85dd1c/src/httpserver.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2498324ff9eab770ffddca643f843f0b9a85dd1c/src/httpserver.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/httpserver.cpp?ref=2498324ff9eab770ffddca643f843f0b9a85dd1c",
        "patch": "@@ -27,6 +27,7 @@\n #include <event2/buffer.h>\n #include <event2/util.h>\n #include <event2/keyvalq_struct.h>\n+#include <event2/bufferevent.h>\n \n #ifdef EVENT__HAVE_NETINET_IN_H\n #include <netinet/in.h>\n@@ -540,12 +541,19 @@ void HTTPEvent::trigger(struct timeval* tv)\n         evtimer_add(ev, tv); // trigger after timeval passed\n }\n HTTPRequest::HTTPRequest(struct evhttp_request* _req) : req(_req),\n-                                                       replySent(false)\n+                                                       replySent(false), streaming(0)\n {\n }\n HTTPRequest::~HTTPRequest()\n {\n-    if (!replySent) {\n+    if (streaming) {\n+        // Finish streaming in main thread\n+        HTTPEvent* ev = new HTTPEvent(eventBase, true, boost::bind(evhttp_send_reply_end, req));\n+        ev->trigger(0);\n+        LogPrintf(\"%s: The end\\n\", __func__);\n+        // TODO: MEMORY LEAK deallocate 'streaming' in event thread, after there is no risk\n+        // of any of the callbacks being called anymore (e.g. request done and finished, or failed).\n+    } else if (!replySent) {\n         // Keep track of whether reply was sent to avoid request leaks\n         LogPrintf(\"%s: Unhandled request\\n\", __func__);\n         WriteReply(HTTP_INTERNAL, \"Unhandled request\");\n@@ -650,6 +658,97 @@ HTTPRequest::RequestMethod HTTPRequest::GetRequestMethod()\n     }\n }\n \n+bool HTTPRequest::StartStreaming(int nStatus)\n+{\n+    assert(!streaming);\n+    streaming = new StreamingData();\n+    HTTPEvent* ev = new HTTPEvent(eventBase, true, boost::bind(evhttp_send_reply_start, req, nStatus, (const char*)NULL));\n+    ev->trigger(0);\n+    return true;\n+}\n+\n+/** TODO: move HTTPRequest::StreamingData to another unit */\n+#define MAX_CHUNK_BUFFER (256*1024)\n+\n+HTTPRequest::StreamingData::StreamingData():\n+    buffer_bytes(0)\n+{\n+    databuf = evbuffer_new();\n+    assert(databuf);\n+}\n+\n+HTTPRequest::StreamingData::~StreamingData()\n+{\n+    evbuffer_free(databuf);\n+}\n+\n+/** Update buffer length in synchronization structure.\n+ * @note: Can only safely read the length of the buffer from the event thread.\n+ */\n+void HTTPRequest::StreamingData::Update(struct evhttp_connection* evcon)\n+{\n+    {\n+        std::unique_lock<std::mutex> lock(cs);\n+        struct bufferevent* bufev = evhttp_connection_get_bufferevent(evcon);\n+        assert(bufev);\n+        struct evbuffer *output = bufferevent_get_output(bufev);\n+        assert(output);\n+        buffer_bytes = evbuffer_get_length(output);\n+    }\n+    cond.notify_all();\n+}\n+\n+/** Called by evhttp from event thread after a chunk has been written.\n+ */\n+void HTTPRequest::StreamingData::http_chunk_cb(struct evhttp_connection* evcon, void* arg)\n+{\n+    HTTPRequest::StreamingData *self = (HTTPRequest::StreamingData*) arg;\n+    self->Update(evcon);\n+    // LogPrintf(\"http_chunk_cb %i\\n\", self->buffer_bytes);\n+}\n+\n+/** Send current chunk in databuf.\n+ * @note: Can only safely be called from event thread\n+ */\n+void HTTPRequest::StreamingData::SendChunk(struct evhttp_request* req)\n+{\n+    // LogPrintf(\"set_http_chunk_cb\\n\");\n+    {\n+        std::unique_lock<std::mutex> lock(cs);\n+        evhttp_send_reply_chunk_with_cb(req, databuf, &http_chunk_cb, this);\n+    }\n+    struct evhttp_connection* evcon = evhttp_request_get_connection(req);\n+    if (evcon) // If not, the connection closed\n+        Update(evcon);\n+    else // TODO need a way to signal losing connection so the application doesn't keep sending unnecessarily, and doesn't hang\n+        LogPrintf(\"warning: evcon is 0 in SendChunk\\n\");\n+}\n+\n+bool HTTPRequest::SendChunk(const void *data, size_t size)\n+{\n+    // Block as long as connection buffer is above maximum\n+    assert(streaming);\n+    std::unique_lock<std::mutex> lock(streaming->cs);\n+    bool delayed = false;\n+    while (streaming->buffer_bytes >= MAX_CHUNK_BUFFER) {\n+        LogPrintf(\"buffer full: %i\\n\", streaming->buffer_bytes);\n+        streaming->cond.wait(lock);\n+        delayed = true;\n+    }\n+    if (delayed)\n+        LogPrintf(\"buffer ok: %i\\n\", streaming->buffer_bytes);\n+\n+    // Send data\n+    evbuffer_add(streaming->databuf, data, size);\n+    // Trigger chunk send on http event thread\n+    // In principle, this doesn't need to be done every time a chunk is submitted - if a usage\n+    // scenario wants to to lots of small chunks it may make sense to queue them up and send\n+    // the event after reaching a high-water mark.\n+    HTTPEvent* ev = new HTTPEvent(eventBase, true, boost::bind(&StreamingData::SendChunk, streaming, req));\n+    ev->trigger(0);\n+    return true;\n+}\n+\n void RegisterHTTPHandler(const std::string &prefix, bool exactMatch, const HTTPRequestHandler &handler)\n {\n     LogPrint(\"http\", \"Registering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);"
      },
      {
        "sha": "be7945eac09c6cdbf49920ff2606bd27d307b233",
        "filename": "src/httpserver.h",
        "status": "modified",
        "additions": 35,
        "deletions": 0,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2498324ff9eab770ffddca643f843f0b9a85dd1c/src/httpserver.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2498324ff9eab770ffddca643f843f0b9a85dd1c/src/httpserver.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/httpserver.h?ref=2498324ff9eab770ffddca643f843f0b9a85dd1c",
        "patch": "@@ -8,12 +8,15 @@\n #include <string>\n #include <stdint.h>\n #include <functional>\n+#include <mutex>\n+#include <condition_variable>\n \n static const int DEFAULT_HTTP_THREADS=4;\n static const int DEFAULT_HTTP_WORKQUEUE=16;\n static const int DEFAULT_HTTP_SERVER_TIMEOUT=30;\n \n struct evhttp_request;\n+struct evhttp_connection;\n struct event_base;\n class CService;\n class HTTPRequest;\n@@ -56,6 +59,25 @@ class HTTPRequest\n     struct evhttp_request* req;\n     bool replySent;\n \n+    /** Synchronization data between worker thread and http event thread, for streaming.\n+     * This should be alive until the http request is destroyed (as long as it is still possible for\n+     * the http_chunk_cb to be called).\n+     */\n+    struct StreamingData\n+    {\n+        StreamingData();\n+        ~StreamingData();\n+        void Update(struct evhttp_connection* evcon);\n+        static void http_chunk_cb(struct evhttp_connection* req, void* arg);\n+        void SendChunk(struct evhttp_request* req);\n+\n+        std::mutex cs; /* protects entire object */\n+        std::condition_variable cond;\n+        size_t buffer_bytes;\n+        struct evbuffer* databuf;\n+    };\n+    StreamingData *streaming;\n+\n public:\n     HTTPRequest(struct evhttp_request* req);\n     ~HTTPRequest();\n@@ -110,6 +132,19 @@ class HTTPRequest\n      * main thread, do not call any other HTTPRequest methods after calling this.\n      */\n     void WriteReply(int nStatus, const std::string& strReply = \"\");\n+\n+    /**\n+     * Start streaming. After calling this, send chunks of data using\n+     * SendChunk.\n+     */\n+    bool StartStreaming(int nStatus);\n+\n+    /**\n+     * Send a chunk of data.\n+     * Call this only after StartStreaming.\n+     * This can block if there is not enough space in the send queue.\n+     */\n+    bool SendChunk(const void *data, size_t size);\n };\n \n /** Event handler closure."
      },
      {
        "sha": "f855b70edd4a402f9c4e63a79f11e6f85e5acc5f",
        "filename": "src/rest.cpp",
        "status": "modified",
        "additions": 61,
        "deletions": 0,
        "changes": 61,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2498324ff9eab770ffddca643f843f0b9a85dd1c/src/rest.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2498324ff9eab770ffddca643f843f0b9a85dd1c/src/rest.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rest.cpp?ref=2498324ff9eab770ffddca643f843f0b9a85dd1c",
        "patch": "@@ -15,6 +15,7 @@\n #include \"txmempool.h\"\n #include \"utilstrencodings.h\"\n #include \"version.h\"\n+#include \"util.h\"\n \n #include <boost/algorithm/string.hpp>\n #include <boost/dynamic_bitset.hpp>\n@@ -599,6 +600,65 @@ static bool rest_getutxos(HTTPRequest* req, const std::string& strURIPart)\n     return true; // continue to process further HTTP reqs on this cxn\n }\n \n+// Size of one chunk for streaming utxo set\n+const size_t CHUNK_SIZE = 256*1024;\n+\n+static bool rest_utxoset(HTTPRequest* req, const std::string& strURIPart)\n+{\n+    if (!CheckWarmup(req))\n+        return false;\n+\n+    req->WriteHeader(\"Content-Type\", \"application/octet-stream\");\n+    // We're timing out during *send*?\n+\n+    boost::scoped_ptr<CCoinsViewCursor> pcursor(pcoinsTip->Cursor());\n+    const uint256 &bestBlock = pcursor->GetBestBlock();\n+    int nHeight;\n+    {\n+        LOCK(cs_main);\n+        nHeight = mapBlockIndex.find(bestBlock)->second->nHeight;\n+    }\n+    std::string filename = strprintf(\"utxoset-%i-%s.dat\", nHeight, bestBlock.ToString());\n+    req->WriteHeader(\"Content-Disposition\", \"attachment; filename=\\\"\"+filename+\"\\\"\");\n+    req->WriteHeader(\"X-Best-Block\", bestBlock.ToString());\n+    req->WriteHeader(\"X-Block-Height\", strprintf(\"%i\", nHeight));\n+    req->StartStreaming(HTTP_OK);\n+\n+    CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n+    ss << bestBlock;\n+    while (pcursor->Valid()) {\n+        uint256 key;\n+        CCoins coins;\n+        if (pcursor->GetKey(key) && pcursor->GetValue(coins)) {\n+            ss << key;\n+            for (unsigned int i=0; i<coins.vout.size(); i++) {\n+                const CTxOut &out = coins.vout[i];\n+                if (!out.IsNull()) {\n+                    ss << VARINT(i+1);\n+                    ss << out;\n+                }\n+            }\n+            ss << VARINT(0);\n+        } else {\n+            // Not clear what to do here - we've sent part of the data so it's\n+            // too late to report an error.\n+            ss << VARINT(-1);\n+            ss << std::string(\"Database error - output corrupted\");\n+            LogPrintf(\"Database error during utxo dump\\n\");\n+            break;\n+        }\n+        pcursor->Next();\n+        if(ss.size() >= CHUNK_SIZE) {\n+            req->SendChunk(&(*ss.begin()), ss.size());\n+            ss.clear();\n+        }\n+    }\n+    req->SendChunk(&(*ss.begin()), ss.size());\n+    LogPrintf(\"Got to EOF\\n\");\n+    return true; // continue to process further HTTP reqs on this cxn\n+}\n+\n+\n static const struct {\n     const char* prefix;\n     bool (*handler)(HTTPRequest* req, const std::string& strReq);\n@@ -611,6 +671,7 @@ static const struct {\n       {\"/rest/mempool/contents\", rest_mempool_contents},\n       {\"/rest/headers/\", rest_headers},\n       {\"/rest/getutxos\", rest_getutxos},\n+      {\"/rest/utxoset\", rest_utxoset},\n };\n \n bool StartREST()"
      }
    ]
  },
  {
    "sha": "5cd59bbe03d7b4763155acc76e16867f2c66dc7c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1Y2Q1OWJiZTAzZDdiNDc2MzE1NWFjYzc2ZTE2ODY3ZjJjNjZkYzdj",
    "commit": {
      "author": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2016-09-28T16:07:24Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2016-09-29T07:33:50Z"
      },
      "message": "Add hack to prevent this from failing compile on older libevent\n\nThis needs a better interface so that HTTPServer's users (such as rest)\ncan query capabilities.",
      "tree": {
        "sha": "0c460c5589815b23c1cb24c33356be2721b72b71",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0c460c5589815b23c1cb24c33356be2721b72b71"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5cd59bbe03d7b4763155acc76e16867f2c66dc7c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5cd59bbe03d7b4763155acc76e16867f2c66dc7c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5cd59bbe03d7b4763155acc76e16867f2c66dc7c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5cd59bbe03d7b4763155acc76e16867f2c66dc7c/comments",
    "author": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2498324ff9eab770ffddca643f843f0b9a85dd1c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2498324ff9eab770ffddca643f843f0b9a85dd1c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2498324ff9eab770ffddca643f843f0b9a85dd1c"
      }
    ],
    "stats": {
      "total": 7,
      "additions": 7,
      "deletions": 0
    },
    "files": [
      {
        "sha": "e728e914633ccb8db8be9b9236d2334750148aea",
        "filename": "src/httpserver.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5cd59bbe03d7b4763155acc76e16867f2c66dc7c/src/httpserver.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5cd59bbe03d7b4763155acc76e16867f2c66dc7c/src/httpserver.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/httpserver.cpp?ref=5cd59bbe03d7b4763155acc76e16867f2c66dc7c",
        "patch": "@@ -712,6 +712,7 @@ void HTTPRequest::StreamingData::http_chunk_cb(struct evhttp_connection* evcon,\n  */\n void HTTPRequest::StreamingData::SendChunk(struct evhttp_request* req)\n {\n+#if LIBEVENT_VERSION_NUMBER >= 0x02010401\n     // LogPrintf(\"set_http_chunk_cb\\n\");\n     {\n         std::unique_lock<std::mutex> lock(cs);\n@@ -722,10 +723,12 @@ void HTTPRequest::StreamingData::SendChunk(struct evhttp_request* req)\n         Update(evcon);\n     else // TODO need a way to signal losing connection so the application doesn't keep sending unnecessarily, and doesn't hang\n         LogPrintf(\"warning: evcon is 0 in SendChunk\\n\");\n+#endif\n }\n \n bool HTTPRequest::SendChunk(const void *data, size_t size)\n {\n+#if LIBEVENT_VERSION_NUMBER >= 0x02010401\n     // Block as long as connection buffer is above maximum\n     assert(streaming);\n     std::unique_lock<std::mutex> lock(streaming->cs);\n@@ -747,6 +750,10 @@ bool HTTPRequest::SendChunk(const void *data, size_t size)\n     HTTPEvent* ev = new HTTPEvent(eventBase, true, boost::bind(&StreamingData::SendChunk, streaming, req));\n     ev->trigger(0);\n     return true;\n+#else\n+    LogPrintf(\"Error: HTTP streaming is only supported with libevent 2.1.4+\\n\");\n+    throw std::runtime_error(\"Not implemented: HTTP streaming is only supported with libevent 2.1.4+\");\n+#endif\n }\n \n void RegisterHTTPHandler(const std::string &prefix, bool exactMatch, const HTTPRequestHandler &handler)"
      }
    ]
  }
]