[
  {
    "sha": "b94b7b05a7b1d27e28ca9a8684877ca605d70256",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiOTRiN2IwNWE3YjFkMjdlMjhjYTlhODY4NDg3N2NhNjA1ZDcwMjU2",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "matt@bluematt.me",
        "date": "2011-03-11T17:28:16Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "matt@bluematt.me",
        "date": "2011-03-11T17:28:16Z"
      },
      "message": "Automatically map port 8333 on the default UPnP Device via miniupnpc.",
      "tree": {
        "sha": "2d84f7801fd1801b3d60fcb3475a0db557d169ca",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2d84f7801fd1801b3d60fcb3475a0db557d169ca"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b94b7b05a7b1d27e28ca9a8684877ca605d70256",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b94b7b05a7b1d27e28ca9a8684877ca605d70256",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b94b7b05a7b1d27e28ca9a8684877ca605d70256",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b94b7b05a7b1d27e28ca9a8684877ca605d70256/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "b104df742d1acfcccb35e35c5427ef221296db73",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b104df742d1acfcccb35e35c5427ef221296db73",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b104df742d1acfcccb35e35c5427ef221296db73"
      }
    ],
    "stats": {
      "total": 7205,
      "additions": 7204,
      "deletions": 1
    },
    "files": [
      {
        "sha": "c35642e3e746d10ce262cad8f363dd48a8e40919",
        "filename": "makefile.unix",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b94b7b05a7b1d27e28ca9a8684877ca605d70256/makefile.unix",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b94b7b05a7b1d27e28ca9a8684877ca605d70256/makefile.unix",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/makefile.unix?ref=b94b7b05a7b1d27e28ca9a8684877ca605d70256",
        "patch": "@@ -18,6 +18,7 @@ LIBS= \\\n    -l db_cxx \\\n    -l ssl \\\n    -l crypto \\\n+   -l miniupnpc \\\n  -Wl,-Bdynamic \\\n    -l gthread-2.0 \\\n    -l z \\"
      },
      {
        "sha": "88498314ff3483e59d487fdd235402cf23d80a25",
        "filename": "miniupnpc/Changelog.txt",
        "status": "added",
        "additions": 371,
        "deletions": 0,
        "changes": 371,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/Changelog.txt",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/Changelog.txt",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/miniupnpc/Changelog.txt?ref=b94b7b05a7b1d27e28ca9a8684877ca605d70256",
        "patch": "@@ -0,0 +1,371 @@\n+$Id: Changelog.txt,v 1.125 2010/12/21 16:13:13 nanard Exp $\n+miniUPnP client Changelog.\n+\n+2010/12/21:\n+  use NO_GETADDRINFO macro to disable the use of getaddrinfo/freeaddrinfo\n+\n+2010/12/11:\n+  Improvements on getHTTPResponse() code.\n+\n+2010/12/09:\n+  new code for miniwget that handle Chunked transfer encoding\n+  using getHTTPResponse() in SOAP call code\n+  Adding MANIFEST.in for 'python setup.py bdist_rpm'\n+\n+2010/11/25:\n+  changes to minissdpc.c to compile under Win32.\n+  see http://miniupnp.tuxfamily.org/forum/viewtopic.php?t=729\n+\n+2010/09/17:\n+  Various improvement to Makefile from Micha\u0142 G\u00f3rny\n+\n+2010/08/05:\n+  Adding the script \"external-ip.sh\" from Reuben Hawkins\n+\n+2010/06/09:\n+  update to python module to match modification made on 2010/04/05\n+  update to Java test code to match modification made on 2010/04/05\n+  all UPNP_* function now return an error if the SOAP request failed\n+  at HTTP level.\n+\n+2010/04/17:\n+  Using GetBestRoute() under win32 in order to find the\n+  right interface to use.\n+\n+2010/04/12:\n+  Retrying with HTTP/1.1 if HTTP/1.0 failed. see\n+  http://miniupnp.tuxfamily.org/forum/viewtopic.php?p=1703\n+\n+2010/04/07:\n+  avoid returning duplicates in upnpDiscover()\n+\n+2010/04/05:\n+  Create a connecthostport.h/.c with connecthostport() function\n+  and use it in miniwget and miniupnpc.\n+  Use getnameinfo() instead of inet_ntop or inet_ntoa\n+  Work to make miniupnpc IPV6 compatible...\n+  Add java test code.\n+  Big changes in order to support device having both WANIPConnection\n+  and WANPPPConnection.\n+\n+2010/04/04:\n+  Use getaddrinfo() instead of gethostbyname() in miniwget.\n+\n+2010/01/06:\n+  #define _DARWIN_C_SOURCE for Mac OS X\n+\n+2009/12/19:\n+  Improve MinGW32 build\n+\n+2009/12/11:\n+  adding a MSVC9 project to build the static library and executable\n+\n+2009/12/10:\n+  Fixing some compilation stuff for Windows/MinGW\n+\n+2009/12/07:\n+  adaptations in Makefile and updateminiupnpcstring.sh for AmigaOS\n+  some fixes for Windows when using virtual ethernet adapters (it is the\n+  case with VMWare installed).\n+\n+2009/12/04:\n+  some fixes for AmigaOS compilation\n+  Changed HTTP version to HTTP/1.0 for Soap too (to prevent chunked\n+  transfer encoding)\n+\n+2009/12/03:\n+  updating printIDG and testigddescparse.c for debug.\n+  modifications to compile under AmigaOS\n+  adding a testminiwget program\n+  Changed miniwget to advertise itself as HTTP/1.0 to prevent chunked\n+  transfer encoding\n+\n+2009/11/26:\n+  fixing updateminiupnpcstrings.sh to take into account\n+  which command that does not return an error code.\n+\n+VERSION 1.4 : released 2009/10/30\n+\n+2009/10/16:\n+  using Py_BEGIN_ALLOW_THREADS and Py_END_ALLOW_THREADS in python module.\n+\n+2009/10/10:\n+  Some fixes for compilation under Solaris\n+  compilation fixes : http://miniupnp.tuxfamily.org/forum/viewtopic.php?p=1464\n+\n+2009/09/21:\n+  fixing the code to ignore EINTR during connect() calls.\n+\n+2009/08/07:\n+  Set socket timeout for connect()\n+  Some cleanup in miniwget.c\n+\n+2009/08/04:\n+  remove multiple redirections with -d in upnpc.c\n+  Print textual error code in upnpc.c\n+  Ignore EINTR during the connect() and poll() calls.\n+\n+2009/07/29:\n+  fix in updateminiupnpcstrings.sh if OS name contains \"/\"\n+  Sending a correct value for MX: field in SSDP request\n+\n+2009/07/20:\n+  Change the Makefile to compile under Mac OS X\n+  Fixed a stackoverflow in getDevicesFromMiniSSDPD()\n+\n+2009/07/09:\n+  Compile under Haiku\n+  generate miniupnpcstrings.h.in from miniupnpcstrings.h\n+\n+2009/06/04:\n+  patching to compile under CygWin and cross compile for minGW\n+\n+VERSION 1.3 :\n+\n+2009/04/17:\n+  updating python module\n+  Use strtoull() when using C99\n+\n+2009/02/28:\n+  Fixed miniwget.c for compiling under sun\n+\n+2008/12/18:\n+  cleanup in Makefile (thanks to Paul de Weerd)\n+  minissdpc.c : win32 compatibility\n+  miniupnpc.c : changed xmlns prefix from 'm' to 'u'\n+  Removed NDEBUG (using DEBUG)\n+\n+2008/10/14:\n+  Added the ExternalHost argument to DeletePortMapping()\n+\n+2008/10/11:\n+  Added the ExternalHost argument to AddPortMapping()\n+  Put a correct User-Agent: header in HTTP requests.\n+\n+VERSION 1.2 :\n+\n+2008/10/07:\n+  Update docs\n+\n+2008/09/25:\n+  Integrated sameport patch from Dario Meloni : Added a \"sameport\"\n+  argument to upnpDiscover().\n+\n+2008/07/18:\n+  small modif to make Clang happy :)\n+\n+2008/07/17:\n+  #define SOAPPREFIX \"s\" in miniupnpc.c in order to remove SOAP-ENV... \n+\n+2008/07/14:\n+  include declspec.h in installation (to /usr/include/miniupnpc)\n+\n+VERSION 1.1 :\n+\n+2008/07/04:\n+  standard options for install/ln instead of gnu-specific stuff.\n+\n+2008/07/03:\n+  now builds a .dll and .lib with win32. (mingw32)\n+\n+2008/04/28:\n+  make install now install the binary of the upnpc tool\n+\n+2008/04/27:\n+  added testupnpigd.py\n+  added error strings for miniupnpc \"internal\" errors\n+  improved python module error/exception reporting.\n+\n+2008/04/23:\n+  Completely rewrite igd_desc_parse.c in order to be compatible with \n+  Linksys WAG200G\n+  Added testigddescparse\n+  updated python module\n+\n+VERSION 1.0 :\n+\n+2008/02/21:\n+  put some #ifdef DEBUG around DisplayNameValueList()\n+\n+2008/02/18:\n+  Improved error reporting in upnpcommands.c\n+  UPNP_GetStatusInfo() returns LastConnectionError\n+\n+2008/02/16:\n+  better error handling in minisoap.c\n+  improving display of \"valid IGD found\" in upnpc.c\n+\n+2008/02/03:\n+  Fixing UPNP_GetValidIGD()\n+  improved make install :)\n+\n+2007/12/22:\n+  Adding upnperrors.c/h to provide a strupnperror() function \n+  used to translate UPnP error codes to string.\n+\n+2007/12/19:\n+  Fixing getDevicesFromMiniSSDPD()\n+  improved error reporting of UPnP functions\n+\n+2007/12/18:\n+  It is now possible to specify a different location for MiniSSDPd socket.\n+  working with MiniSSDPd is now more efficient.\n+  python module improved.\n+\n+2007/12/16:\n+  improving error reporting\n+\n+2007/12/13:\n+  Try to improve compatibility by using HTTP/1.0 instead of 1.1 and\n+  XML a bit different for SOAP.\n+\n+2007/11/25:\n+  fixed select() call for linux\n+\n+2007/11/15:\n+  Added -fPIC to CFLAG for better shared library code.\n+\n+2007/11/02:\n+  Fixed a potential socket leak in miniwget2()\n+\n+2007/10/16:\n+  added a parameter to upnpDiscover() in order to allow the use of another\n+  interface than the default multicast interface.\n+\n+2007/10/12:\n+  Fixed the creation of symbolic link in Makefile\n+\n+2007/10/08:\n+  Added man page\n+\n+2007/10/02:\n+  fixed memory bug in GetUPNPUrls()\n+\n+2007/10/01:\n+  fixes in the Makefile\n+  Added UPNP_GetIGDFromUrl() and adapted the sample program accordingly.\n+  Added SONAME in the shared library to please debian :)\n+  fixed MS Windows compilation (minissdpd is not available under MS Windows).\n+\n+2007/09/25:\n+  small change to Makefile to be able to install in a different location\n+  (default is /usr)\n+\n+2007/09/24:\n+  now compiling both shared and static library\n+\n+2007/09/19:\n+  Cosmetic changes on upnpc.c\n+\n+2007/09/02:\n+  adapting to new miniSSDPd (release version ?)\n+\n+2007/08/31:\n+  Usage of miniSSDPd to skip discovery process.\n+\n+2007/08/27:\n+  fixed python module to allow compilation with Python older than Python 2.4\n+\n+2007/06/12:\n+  Added a python module.\n+\n+2007/05/19:\n+  Fixed compilation under MinGW\n+\n+2007/05/15:\n+  fixed a memory leak in AddPortMapping()\n+  Added testupnpreplyparse executable to check the parsing of\n+  upnp soap messages\n+  minixml now ignore namespace prefixes.\n+\n+2007/04/26:\n+  upnpc now displays external ip address with -s or -l\n+\n+2007/04/11:\n+  changed MINIUPNPC_URL_MAXSIZE to 128 to accomodate the \"BT Voyager 210\"\n+\n+2007/03/19:\n+  cleanup in miniwget.c\n+\n+2007/03/01:\n+  Small typo fix...\n+\n+2007/01/30:\n+  Now parsing the HTTP header from SOAP responses in order to\n+  get content-length value.\n+\n+2007/01/29:\n+  Fixed the Soap Query to speedup the HTTP request.\n+  added some Win32 DLL stuff...\n+\n+2007/01/27:\n+  Fixed some WIN32 compatibility issues\n+\n+2006/12/14:\n+  Added UPNPIGD_IsConnected() function in miniupnp.c/.h\n+  Added UPNP_GetValidIGD() in miniupnp.c/.h\n+  cleaned upnpc.c main(). now using UPNP_GetValidIGD()\n+\n+2006/12/07:\n+  Version 1.0-RC1 released\n+\n+2006/12/03:\n+  Minor changes to compile under SunOS/Solaris\n+\n+2006/11/30:\n+  made a minixml parser validator program\n+  updated minixml to handle attributes correctly\n+\n+2006/11/22:\n+  Added a -r option to the upnpc sample thanks to Alexander Hubmann.\n+\n+2006/11/19:\n+  Cleanup code to make it more ANSI C compliant\n+\n+2006/11/10:\n+  detect and display local lan address.\n+\n+2006/11/04:\n+  Packets and Bytes Sent/Received are now unsigned int.\n+\n+2006/11/01:\n+  Bug fix thanks to Giuseppe D'Angelo\n+\n+2006/10/31:\n+  C++ compatibility for .h files.\n+  Added a way to get ip Address on the LAN used to reach the IGD.\n+\n+2006/10/25:\n+  Added M-SEARCH to the services in the discovery process.\n+\n+2006/10/22:\n+  updated the Makefile to use makedepend, added a \"make install\"\n+  update Makefile\n+\n+2006/10/20:\n+  fixing the description url parsing thanks to patch sent by\n+  Wayne Dawe.\n+  Fixed/translated some comments.\n+  Implemented a better discover process, first looking\n+  for IGD then for root devices (as some devices only reply to\n+  M-SEARCH for root devices).\n+\n+2006/09/02:\n+  added freeUPNPDevlist() function.\n+\n+2006/08/04:\n+  More command line arguments checking\n+\n+2006/08/01:\n+  Added the .bat file to compile under Win32 with minGW32\n+\n+2006/07/31:\n+  Fixed the rootdesc parser (igd_desc_parse.c)\n+\n+2006/07/20:\n+  parseMSEARCHReply() is now returning the ST: line as well\n+  starting changes to detect several UPnP devices on the network\n+\n+2006/07/19:\n+  using GetCommonLinkProperties to get down/upload bitrate\n+"
      },
      {
        "sha": "2b561fb4f372b22ba44ee5401f1b964d5a73c991",
        "filename": "miniupnpc/LICENSE",
        "status": "added",
        "additions": 26,
        "deletions": 0,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/LICENSE",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/LICENSE",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/miniupnpc/LICENSE?ref=b94b7b05a7b1d27e28ca9a8684877ca605d70256",
        "patch": "@@ -0,0 +1,26 @@\n+Copyright (c) 2005-2009, Thomas BERNARD \n+All rights reserved.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are met:\n+\n+    * Redistributions of source code must retain the above copyright notice,\n+      this list of conditions and the following disclaimer.\n+    * Redistributions in binary form must reproduce the above copyright notice,\n+      this list of conditions and the following disclaimer in the documentation\n+      and/or other materials provided with the distribution.\n+    * The name of the author may not be used to endorse or promote products\n+\t  derived from this software without specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.\n+"
      },
      {
        "sha": "54b86f95e3a150a2c2fa846c2c88e5d3d28d9390",
        "filename": "miniupnpc/MANIFEST.in",
        "status": "added",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/MANIFEST.in",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/MANIFEST.in",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/miniupnpc/MANIFEST.in?ref=b94b7b05a7b1d27e28ca9a8684877ca605d70256",
        "patch": "@@ -0,0 +1,5 @@\n+include README\n+include miniupnpcmodule.c\n+include setup.py\n+include *.h\n+include libminiupnpc.a"
      },
      {
        "sha": "cbafdfaa05f40074975a39e59968395e3c83eed3",
        "filename": "miniupnpc/Makefile",
        "status": "added",
        "additions": 200,
        "deletions": 0,
        "changes": 200,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/Makefile",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/Makefile",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/miniupnpc/Makefile?ref=b94b7b05a7b1d27e28ca9a8684877ca605d70256",
        "patch": "@@ -0,0 +1,200 @@\n+# $Id: Makefile,v 1.68 2010/12/21 16:13:14 nanard Exp $\n+# MiniUPnP Project\n+# http://miniupnp.free.fr/\n+# (c) 2005-2010 Thomas Bernard\n+# to install use :\n+# $ PREFIX=/tmp/dummylocation make install\n+# or\n+# $ INSTALLPREFIX=/usr/local make install\n+# or \n+# make install (will go to /usr/bin, /usr/lib, etc...)\n+OS = $(shell uname -s)\n+CC ?= gcc\n+#AR = gar\n+#CFLAGS = -O -Wall -g -DDEBUG\n+CFLAGS ?= -O -Wall -DNDEBUG -DMINIUPNPC_SET_SOCKET_TIMEOUT\n+# -DNO_GETADDRINFO\n+INSTALL = install\n+SH = /bin/sh\n+JAVA = java\n+# see http://code.google.com/p/jnaerator/\n+JNAERATOR = jnaerator-0.9.3.jar\n+#following libs are needed on Solaris\n+#LDLIBS=-lsocket -lnsl -lresolv\n+\n+# APIVERSION is used to build SONAME\n+APIVERSION = 5\n+\n+SRCS = igd_desc_parse.c miniupnpc.c minixml.c minisoap.c miniwget.c \\\n+       upnpc.c upnpcommands.c upnpreplyparse.c testminixml.c \\\n+\t   minixmlvalid.c testupnpreplyparse.c minissdpc.c \\\n+\t   upnperrors.c testigddescparse.c testminiwget.c \\\n+       connecthostport.c\n+\n+LIBOBJS = miniwget.o minixml.o igd_desc_parse.o minisoap.o \\\n+          miniupnpc.o upnpreplyparse.o upnpcommands.o upnperrors.o \\\n+          connecthostport.o\n+\n+ifneq ($(OS), AmigaOS)\n+CFLAGS := -fPIC $(CFLAGS)\n+LIBOBJS := $(LIBOBJS) minissdpc.o\n+endif\n+\n+OBJS = $(patsubst %.c,%.o,$(SRCS))\n+\n+# HEADERS to install\n+HEADERS = miniupnpc.h miniwget.h upnpcommands.h igd_desc_parse.h \\\n+          upnpreplyparse.h upnperrors.h declspec.h\n+# library names\n+LIBRARY = libminiupnpc.a\n+ifeq ($(OS), Darwin)\n+  SHAREDLIBRARY = libminiupnpc.dylib\n+  SONAME = $(basename $(SHAREDLIBRARY)).$(APIVERSION).dylib\n+  CFLAGS := -DMACOSX -D_DARWIN_C_SOURCE $(CFLAGS)\n+else \n+  SHAREDLIBRARY = libminiupnpc.so\n+  SONAME = $(SHAREDLIBRARY).$(APIVERSION)\n+endif\n+\n+EXECUTABLES = upnpc-static\n+EXECUTABLES_ADDTESTS = testminixml minixmlvalid testupnpreplyparse \\\n+\t\t\t  testigddescparse testminiwget\n+\n+TESTMINIXMLOBJS = minixml.o igd_desc_parse.o testminixml.o\n+\n+TESTMINIWGETOBJS = miniwget.o testminiwget.o miniupnpc.o minisoap.o \\\n+                   upnpcommands.o upnpreplyparse.o minixml.o \\\n+                   igd_desc_parse.o connecthostport.o\n+\n+TESTUPNPREPLYPARSE = testupnpreplyparse.o minixml.o upnpreplyparse.o\n+\n+TESTIGDDESCPARSE = testigddescparse.o igd_desc_parse.o minixml.o \\\n+                   miniupnpc.o miniwget.o upnpcommands.o upnpreplyparse.o \\\n+                   minisoap.o connecthostport.o\n+\n+ifneq ($(OS), AmigaOS)\n+EXECUTABLES := $(EXECUTABLES) upnpc-shared\n+TESTMINIWGETOBJS := $(TESTMINIWGETOBJS) minissdpc.o\n+TESTIGDDESCPARSE := $(TESTIGDDESCPARSE) minissdpc.o\n+endif\n+\n+# install directories\n+INSTALLPREFIX ?= $(PREFIX)/usr\n+INSTALLDIRINC = $(INSTALLPREFIX)/include/miniupnpc\n+INSTALLDIRLIB = $(INSTALLPREFIX)/lib\n+INSTALLDIRBIN = $(INSTALLPREFIX)/bin\n+\n+FILESTOINSTALL = $(LIBRARY) $(EXECUTABLES)\n+ifneq ($(OS), AmigaOS)\n+FILESTOINSTALL := $(FILESTOINSTALL) $(SHAREDLIBRARY)\n+endif\n+\n+\n+.PHONY:\tinstall clean depend all check everything installpythonmodule \\\n+\tvalidateminixml\n+\n+all:\t$(LIBRARY) $(EXECUTABLES)\n+\n+check:\tvalidateminixml\n+\n+everything:\tall $(EXECUTABLES_ADDTESTS)\n+\n+pythonmodule:\t$(LIBRARY) miniupnpcmodule.c setup.py\n+\tpython setup.py build\n+\ttouch $@\n+\n+installpythonmodule:\tpythonmodule\n+\tpython setup.py install\n+\n+validateminixml:\tminixmlvalid\n+\t@echo \"minixml validation test\"\n+\t./minixmlvalid\n+\ttouch $@\n+\n+clean:\n+\t$(RM) $(LIBRARY) $(SHAREDLIBRARY) $(EXECUTABLES) $(OBJS) miniupnpcstrings.h\n+\t# clean python stuff\n+\t$(RM) pythonmodule validateminixml\n+\t$(RM) -r build/ dist/\n+\t#python setup.py clean\n+\n+install:\t$(FILESTOINSTALL)\n+\t$(INSTALL) -d $(INSTALLDIRINC)\n+\t$(INSTALL) -m 644 $(HEADERS) $(INSTALLDIRINC)\n+\t$(INSTALL) -d $(INSTALLDIRLIB)\n+\t$(INSTALL) -m 644 $(LIBRARY) $(INSTALLDIRLIB)\n+ifneq ($(OS), AmigaOS)\n+\t$(INSTALL) -m 644 $(SHAREDLIBRARY) $(INSTALLDIRLIB)/$(SONAME)\n+\tln -fs $(SONAME) $(INSTALLDIRLIB)/$(SHAREDLIBRARY)\n+endif\n+\t$(INSTALL) -d $(INSTALLDIRBIN)\n+ifeq ($(OS), AmigaOS)\n+\t$(INSTALL) -m 755 upnpc-static $(INSTALLDIRBIN)/upnpc\n+else\n+\t$(INSTALL) -m 755 upnpc-shared $(INSTALLDIRBIN)/upnpc\n+endif\n+\t$(INSTALL) -m 755 external-ip.sh $(INSTALLDIRBIN)/external-ip\n+\n+cleaninstall:\n+\t$(RM) -r $(INSTALLDIRINC)\n+\t$(RM) $(INSTALLDIRLIB)/$(LIBRARY)\n+\t$(RM) $(INSTALLDIRLIB)/$(SHAREDLIBRARY)\n+\n+depend:\n+\tmakedepend -Y -- $(CFLAGS) -- $(SRCS) 2>/dev/null\n+\n+$(LIBRARY):\t$(LIBOBJS)\n+\t$(AR) crs $@ $?\n+\n+$(SHAREDLIBRARY):\t$(LIBOBJS)\n+ifeq ($(OS), Darwin)\n+\t$(CC) -dynamiclib $(LDFLAGS) -Wl,-install_name,$(SONAME) -o $@ $^ \n+else\n+\t$(CC) -shared $(LDFLAGS) -Wl,-soname,$(SONAME) -o $@ $^\n+endif\n+\n+upnpc-static:\tupnpc.o $(LIBRARY) $(LDLIBS)\n+\t$(CC) $(LDFLAGS) -o $@ $^\n+\n+upnpc-shared:\tupnpc.o $(SHAREDLIBRARY) $(LDLIBS)\n+\t$(CC) $(LDFLAGS) -o $@ $^\n+\n+testminixml:\t$(TESTMINIXMLOBJS)\n+\n+testminiwget:\t$(TESTMINIWGETOBJS)\n+\n+minixmlvalid:\tminixml.o minixmlvalid.o\n+\n+testupnpreplyparse:\t$(TESTUPNPREPLYPARSE)\n+\n+testigddescparse:\t$(TESTIGDDESCPARSE)\n+\n+miniupnpcstrings.h:\tminiupnpcstrings.h.in updateminiupnpcstrings.sh\n+\t$(SH) updateminiupnpcstrings.sh\n+\n+jar:\t$(SHAREDLIBRARY) \n+\t$(JAVA) -jar $(JNAERATOR) -library miniupnpc miniupnpc.h declspec.h upnpcommands.h upnpreplyparse.h igd_desc_parse.h miniwget.h upnperrors.h $(SHAREDLIBRARY) -package fr.free.miniupnp -o . -jar java/miniupnpc_$(OS).jar -v\n+\n+# DO NOT DELETE THIS LINE -- make depend depends on it.\n+\n+igd_desc_parse.o: igd_desc_parse.h\n+miniupnpc.o: miniupnpc.h declspec.h igd_desc_parse.h minissdpc.h miniwget.h\n+miniupnpc.o: minisoap.h minixml.h upnpcommands.h upnpreplyparse.h\n+miniupnpc.o: connecthostport.h\n+minixml.o: minixml.h\n+minisoap.o: minisoap.h miniupnpcstrings.h\n+miniwget.o: miniupnpc.h declspec.h igd_desc_parse.h miniupnpcstrings.h\n+miniwget.o: miniwget.h connecthostport.h\n+upnpc.o: miniwget.h declspec.h miniupnpc.h igd_desc_parse.h upnpcommands.h\n+upnpc.o: upnpreplyparse.h upnperrors.h\n+upnpcommands.o: upnpcommands.h upnpreplyparse.h declspec.h miniupnpc.h\n+upnpcommands.o: igd_desc_parse.h\n+upnpreplyparse.o: upnpreplyparse.h minixml.h\n+testminixml.o: minixml.h igd_desc_parse.h\n+minixmlvalid.o: minixml.h\n+testupnpreplyparse.o: upnpreplyparse.h\n+minissdpc.o: minissdpc.h miniupnpc.h declspec.h igd_desc_parse.h codelength.h\n+upnperrors.o: upnperrors.h declspec.h upnpcommands.h upnpreplyparse.h\n+testigddescparse.o: igd_desc_parse.h minixml.h miniupnpc.h declspec.h\n+testminiwget.o: miniwget.h declspec.h\n+connecthostport.o: connecthostport.h"
      },
      {
        "sha": "4d7a5b7891f9d08327ac547ca3be4b4a673c340b",
        "filename": "miniupnpc/Makefile.mingw",
        "status": "added",
        "additions": 88,
        "deletions": 0,
        "changes": 88,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/Makefile.mingw",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/Makefile.mingw",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/miniupnpc/Makefile.mingw?ref=b94b7b05a7b1d27e28ca9a8684877ca605d70256",
        "patch": "@@ -0,0 +1,88 @@\n+# $Id: Makefile.mingw,v 1.13 2010/04/17 22:07:59 nanard Exp $\n+# Miniupnp project.\n+# http://miniupnp.free.fr/ or http://miniupnp.tuxfamily.org/\n+# (c) 2005-2008 Thomas Bernard\n+# This Makefile is made for MinGW\n+#\n+CC = gcc\n+#CFLAGS = -Wall -g -DDEBUG\n+CFLAGS = -Wall -Os -DNDEBUG\n+LDLIBS = -lws2_32 -liphlpapi\n+# -lwsock32\n+# -liphlpapi is used for GetBestRoute()\n+PYTHON=\\utils\\python25\\python\n+OBJS=miniwget.o minixml.o igd_desc_parse.o minisoap.o \\\n+     miniupnpc.o upnpreplyparse.o upnpcommands.o upnperrors.o \\\n+     connecthostport.o\n+OBJSDLL=$(addprefix dll/, $(OBJS))\n+\n+all:\tinit upnpc-static upnpc-shared testminixml libminiupnpc.a miniupnpc.dll\n+\n+init:\n+\tmkdir dll\n+\techo init > init\n+\n+clean:\n+\tdel upnpc testminixml *.o\n+\tdel dll\\*.o\n+\tdel *.exe\n+\tdel miniupnpc.dll\n+\tdel libminiupnpc.a\n+\n+libminiupnpc.a:\t$(OBJS)\n+\t$(AR) cr $@ $?\n+\n+pythonmodule:\tlibminiupnpc.a\n+\t$(PYTHON) setupmingw32.py build --compiler=mingw32\n+\t$(PYTHON) setupmingw32.py install --skip-build\n+\n+miniupnpc.dll:\tlibminiupnpc.a $(OBJSDLL)\n+\tdllwrap -k --driver-name gcc --def miniupnpc.def \\\n+\t--output-def miniupnpc.dll.def --implib miniupnpc.lib -o $@ \\\n+\t$(OBJSDLL) $(LDLIBS)\n+\n+miniupnpc.lib:\tminiupnpc.dll\n+\techo $@ generated with $<\n+\n+dll/upnpc.o:\tupnpc.o\n+\techo $@ generated with $<\n+\n+.c.o:\n+\t$(CC) $(CFLAGS) -DSTATICLIB -c -o $@ $<\n+\t$(CC) $(CFLAGS) -DMINIUPNP_EXPORTS -c -o dll/$@ $<\n+\n+upnpc.o:\n+\t$(CC) $(CFLAGS) -DSTATICLIB -c -o $@ $<\n+\t$(CC) $(CFLAGS) -c -o dll/$@ $<\n+\n+upnpc-static:\tupnpc.o libminiupnpc.a\n+\t$(CC) -o $@ $^ $(LDLIBS)\n+\n+upnpc-shared:\tdll/upnpc.o miniupnpc.lib\n+\t$(CC) -o $@ $^ $(LDLIBS)\n+\n+wingenminiupnpcstrings:\twingenminiupnpcstrings.o\n+\n+wingenminiupnpcstrings.o:\twingenminiupnpcstrings.c\n+\n+miniupnpcstrings.h: miniupnpcstrings.h.in wingenminiupnpcstrings\n+\twingenminiupnpcstrings $< $@\n+\n+minixml.o:\tminixml.c minixml.h miniupnpcstrings.h\n+\n+upnpc.o:\tupnpc.c miniwget.h minisoap.h miniupnpc.h igd_desc_parse.h upnpreplyparse.h upnpcommands.h\n+\n+miniwget.o:\tminiwget.c miniwget.h miniupnpcstrings.h\n+\n+minisoap.o:\tminisoap.c minisoap.h\n+\n+miniupnpc.o:\tminiupnpc.c miniupnpc.h minisoap.h miniwget.h minixml.h\n+\n+igd_desc_parse.o:\tigd_desc_parse.c igd_desc_parse.h\n+\n+testminixml:\tminixml.o igd_desc_parse.o testminixml.c\n+\n+upnpreplyparse.o:\tupnpreplyparse.c upnpreplyparse.h minixml.h\n+\n+upnpcommands.o:\tupnpcommands.c upnpcommands.h upnpreplyparse.h miniupnpc.h\n+"
      },
      {
        "sha": "4295070623d2ebd772af99ba0cdb284236112f48",
        "filename": "miniupnpc/README",
        "status": "added",
        "additions": 56,
        "deletions": 0,
        "changes": 56,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/README",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/README",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/miniupnpc/README?ref=b94b7b05a7b1d27e28ca9a8684877ca605d70256",
        "patch": "@@ -0,0 +1,56 @@\n+Project: miniupnp\n+Project web page: http://miniupnp.free.fr/ or http://miniupnp.tuxfamily.org/\n+Author: Thomas Bernard\n+Copyright (c) 2005-2009 Thomas Bernard\n+This software is subject to the conditions detailed in the\n+LICENSE file provided within this distribution.\n+\n+For the comfort of Win32 users, bsdqueue.h is included in the distribution.\n+Its licence is included in the header of the file.\n+bsdqueue.h is a copy of the sys/queue.h of an OpenBSD system.\n+\n+* miniupnp Client *\n+\n+To compile, simply run 'gmake' (could be 'make' on your system).\n+Under win32, to compile with MinGW, type \"mingw32make.bat\".\n+The compilation is known to work under linux, FreeBSD,\n+OpenBSD, MacOS X, AmigaOS and cygwin.\n+The official AmigaOS4.1 SDK was used for AmigaOS4 and GeekGadgets for AmigaOS3.\n+\n+To install the library and headers on the system use :\n+> su\n+> make install\n+> exit\n+\n+alternatively, to install in a specific location, use :\n+> INSTALLPREFIX=/usr/local make install\n+\n+upnpc.c is a sample client using the libminiupnpc.\n+To use the libminiupnpc in your application, link it with\n+libminiupnpc.a (or .so) and use the following functions found in miniupnpc.h,\n+upnpcommands.h and miniwget.h :\n+- upnpDiscover()\n+- miniwget()\n+- parserootdesc()\n+- GetUPNPUrls()\n+- UPNP_* (calling UPNP methods)\n+\n+Note : use #include <miniupnpc/miniupnpc.h> etc... for the includes\n+and -lminiupnpc for the link\n+\n+Discovery process is speeded up when MiniSSDPd is running on the machine.\n+\n+* Python module *\n+\n+you can build a python module with 'make pythonmodule' \n+and install it with 'make installpythonmodule'.\n+setup.py (and setupmingw32.py) are included in the distribution.\n+\n+\n+Feel free to contact me if you have any problem :\n+e-mail : miniupnp@free.fr\n+\n+If you are using libminiupnpc in your application, please\n+send me an email !\n+\n+"
      },
      {
        "sha": "c239c60cba28a79a295acb60a122b8c46eb57271",
        "filename": "miniupnpc/VERSION",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/VERSION",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/VERSION",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/miniupnpc/VERSION?ref=b94b7b05a7b1d27e28ca9a8684877ca605d70256",
        "patch": "@@ -0,0 +1 @@\n+1.5"
      },
      {
        "sha": "1fe0599f5016bf79aa2a59e1df70e792dde7a6e2",
        "filename": "miniupnpc/bsdqueue.h",
        "status": "added",
        "additions": 531,
        "deletions": 0,
        "changes": 531,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/bsdqueue.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/bsdqueue.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/miniupnpc/bsdqueue.h?ref=b94b7b05a7b1d27e28ca9a8684877ca605d70256",
        "patch": "@@ -0,0 +1,531 @@\n+/*\t$OpenBSD: queue.h,v 1.31 2005/11/25 08:06:25 otto Exp $\t*/\n+/*\t$NetBSD: queue.h,v 1.11 1996/05/16 05:17:14 mycroft Exp $\t*/\n+\n+/*\n+ * Copyright (c) 1991, 1993\n+ *\tThe Regents of the University of California.  All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the University nor the names of its contributors\n+ *    may be used to endorse or promote products derived from this software\n+ *    without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ *\n+ *\t@(#)queue.h\t8.5 (Berkeley) 8/20/94\n+ */\n+\n+#ifndef\t_SYS_QUEUE_H_\n+#define\t_SYS_QUEUE_H_\n+\n+/*\n+ * This file defines five types of data structures: singly-linked lists, \n+ * lists, simple queues, tail queues, and circular queues.\n+ *\n+ *\n+ * A singly-linked list is headed by a single forward pointer. The elements\n+ * are singly linked for minimum space and pointer manipulation overhead at\n+ * the expense of O(n) removal for arbitrary elements. New elements can be\n+ * added to the list after an existing element or at the head of the list.\n+ * Elements being removed from the head of the list should use the explicit\n+ * macro for this purpose for optimum efficiency. A singly-linked list may\n+ * only be traversed in the forward direction.  Singly-linked lists are ideal\n+ * for applications with large datasets and few or no removals or for\n+ * implementing a LIFO queue.\n+ *\n+ * A list is headed by a single forward pointer (or an array of forward\n+ * pointers for a hash table header). The elements are doubly linked\n+ * so that an arbitrary element can be removed without a need to\n+ * traverse the list. New elements can be added to the list before\n+ * or after an existing element or at the head of the list. A list\n+ * may only be traversed in the forward direction.\n+ *\n+ * A simple queue is headed by a pair of pointers, one the head of the\n+ * list and the other to the tail of the list. The elements are singly\n+ * linked to save space, so elements can only be removed from the\n+ * head of the list. New elements can be added to the list before or after\n+ * an existing element, at the head of the list, or at the end of the\n+ * list. A simple queue may only be traversed in the forward direction.\n+ *\n+ * A tail queue is headed by a pair of pointers, one to the head of the\n+ * list and the other to the tail of the list. The elements are doubly\n+ * linked so that an arbitrary element can be removed without a need to\n+ * traverse the list. New elements can be added to the list before or\n+ * after an existing element, at the head of the list, or at the end of\n+ * the list. A tail queue may be traversed in either direction.\n+ *\n+ * A circle queue is headed by a pair of pointers, one to the head of the\n+ * list and the other to the tail of the list. The elements are doubly\n+ * linked so that an arbitrary element can be removed without a need to\n+ * traverse the list. New elements can be added to the list before or after\n+ * an existing element, at the head of the list, or at the end of the list.\n+ * A circle queue may be traversed in either direction, but has a more\n+ * complex end of list detection.\n+ *\n+ * For details on the use of these macros, see the queue(3) manual page.\n+ */\n+\n+#ifdef QUEUE_MACRO_DEBUG\n+#define _Q_INVALIDATE(a) (a) = ((void *)-1)\n+#else\n+#define _Q_INVALIDATE(a)\n+#endif\n+\n+/*\n+ * Singly-linked List definitions.\n+ */\n+#define SLIST_HEAD(name, type)\t\t\t\t\t\t\\\n+struct name {\t\t\t\t\t\t\t\t\\\n+\tstruct type *slh_first;\t/* first element */\t\t\t\\\n+}\n+ \n+#define\tSLIST_HEAD_INITIALIZER(head)\t\t\t\t\t\\\n+\t{ NULL }\n+\n+#ifdef SLIST_ENTRY\n+#undef SLIST_ENTRY\n+#endif\n+\n+#define SLIST_ENTRY(type)\t\t\t\t\t\t\\\n+struct {\t\t\t\t\t\t\t\t\\\n+\tstruct type *sle_next;\t/* next element */\t\t\t\\\n+}\n+ \n+/*\n+ * Singly-linked List access methods.\n+ */\n+#define\tSLIST_FIRST(head)\t((head)->slh_first)\n+#define\tSLIST_END(head)\t\tNULL\n+#define\tSLIST_EMPTY(head)\t(SLIST_FIRST(head) == SLIST_END(head))\n+#define\tSLIST_NEXT(elm, field)\t((elm)->field.sle_next)\n+\n+#define\tSLIST_FOREACH(var, head, field)\t\t\t\t\t\\\n+\tfor((var) = SLIST_FIRST(head);\t\t\t\t\t\\\n+\t    (var) != SLIST_END(head);\t\t\t\t\t\\\n+\t    (var) = SLIST_NEXT(var, field))\n+\n+#define\tSLIST_FOREACH_PREVPTR(var, varp, head, field)\t\t\t\\\n+\tfor ((varp) = &SLIST_FIRST((head));\t\t\t\t\\\n+\t    ((var) = *(varp)) != SLIST_END(head);\t\t\t\\\n+\t    (varp) = &SLIST_NEXT((var), field))\n+\n+/*\n+ * Singly-linked List functions.\n+ */\n+#define\tSLIST_INIT(head) {\t\t\t\t\t\t\\\n+\tSLIST_FIRST(head) = SLIST_END(head);\t\t\t\t\\\n+}\n+\n+#define\tSLIST_INSERT_AFTER(slistelm, elm, field) do {\t\t\t\\\n+\t(elm)->field.sle_next = (slistelm)->field.sle_next;\t\t\\\n+\t(slistelm)->field.sle_next = (elm);\t\t\t\t\\\n+} while (0)\n+\n+#define\tSLIST_INSERT_HEAD(head, elm, field) do {\t\t\t\\\n+\t(elm)->field.sle_next = (head)->slh_first;\t\t\t\\\n+\t(head)->slh_first = (elm);\t\t\t\t\t\\\n+} while (0)\n+\n+#define\tSLIST_REMOVE_NEXT(head, elm, field) do {\t\t\t\\\n+\t(elm)->field.sle_next = (elm)->field.sle_next->field.sle_next;\t\\\n+} while (0)\n+\n+#define\tSLIST_REMOVE_HEAD(head, field) do {\t\t\t\t\\\n+\t(head)->slh_first = (head)->slh_first->field.sle_next;\t\t\\\n+} while (0)\n+\n+#define SLIST_REMOVE(head, elm, type, field) do {\t\t\t\\\n+\tif ((head)->slh_first == (elm)) {\t\t\t\t\\\n+\t\tSLIST_REMOVE_HEAD((head), field);\t\t\t\\\n+\t} else {\t\t\t\t\t\t\t\\\n+\t\tstruct type *curelm = (head)->slh_first;\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t\twhile (curelm->field.sle_next != (elm))\t\t\t\\\n+\t\t\tcurelm = curelm->field.sle_next;\t\t\\\n+\t\tcurelm->field.sle_next =\t\t\t\t\\\n+\t\t    curelm->field.sle_next->field.sle_next;\t\t\\\n+\t\t_Q_INVALIDATE((elm)->field.sle_next);\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+} while (0)\n+\n+/*\n+ * List definitions.\n+ */\n+#define LIST_HEAD(name, type)\t\t\t\t\t\t\\\n+struct name {\t\t\t\t\t\t\t\t\\\n+\tstruct type *lh_first;\t/* first element */\t\t\t\\\n+}\n+\n+#define LIST_HEAD_INITIALIZER(head)\t\t\t\t\t\\\n+\t{ NULL }\n+\n+#define LIST_ENTRY(type)\t\t\t\t\t\t\\\n+struct {\t\t\t\t\t\t\t\t\\\n+\tstruct type *le_next;\t/* next element */\t\t\t\\\n+\tstruct type **le_prev;\t/* address of previous next element */\t\\\n+}\n+\n+/*\n+ * List access methods\n+ */\n+#define\tLIST_FIRST(head)\t\t((head)->lh_first)\n+#define\tLIST_END(head)\t\t\tNULL\n+#define\tLIST_EMPTY(head)\t\t(LIST_FIRST(head) == LIST_END(head))\n+#define\tLIST_NEXT(elm, field)\t\t((elm)->field.le_next)\n+\n+#define LIST_FOREACH(var, head, field)\t\t\t\t\t\\\n+\tfor((var) = LIST_FIRST(head);\t\t\t\t\t\\\n+\t    (var)!= LIST_END(head);\t\t\t\t\t\\\n+\t    (var) = LIST_NEXT(var, field))\n+\n+/*\n+ * List functions.\n+ */\n+#define\tLIST_INIT(head) do {\t\t\t\t\t\t\\\n+\tLIST_FIRST(head) = LIST_END(head);\t\t\t\t\\\n+} while (0)\n+\n+#define LIST_INSERT_AFTER(listelm, elm, field) do {\t\t\t\\\n+\tif (((elm)->field.le_next = (listelm)->field.le_next) != NULL)\t\\\n+\t\t(listelm)->field.le_next->field.le_prev =\t\t\\\n+\t\t    &(elm)->field.le_next;\t\t\t\t\\\n+\t(listelm)->field.le_next = (elm);\t\t\t\t\\\n+\t(elm)->field.le_prev = &(listelm)->field.le_next;\t\t\\\n+} while (0)\n+\n+#define\tLIST_INSERT_BEFORE(listelm, elm, field) do {\t\t\t\\\n+\t(elm)->field.le_prev = (listelm)->field.le_prev;\t\t\\\n+\t(elm)->field.le_next = (listelm);\t\t\t\t\\\n+\t*(listelm)->field.le_prev = (elm);\t\t\t\t\\\n+\t(listelm)->field.le_prev = &(elm)->field.le_next;\t\t\\\n+} while (0)\n+\n+#define LIST_INSERT_HEAD(head, elm, field) do {\t\t\t\t\\\n+\tif (((elm)->field.le_next = (head)->lh_first) != NULL)\t\t\\\n+\t\t(head)->lh_first->field.le_prev = &(elm)->field.le_next;\\\n+\t(head)->lh_first = (elm);\t\t\t\t\t\\\n+\t(elm)->field.le_prev = &(head)->lh_first;\t\t\t\\\n+} while (0)\n+\n+#define LIST_REMOVE(elm, field) do {\t\t\t\t\t\\\n+\tif ((elm)->field.le_next != NULL)\t\t\t\t\\\n+\t\t(elm)->field.le_next->field.le_prev =\t\t\t\\\n+\t\t    (elm)->field.le_prev;\t\t\t\t\\\n+\t*(elm)->field.le_prev = (elm)->field.le_next;\t\t\t\\\n+\t_Q_INVALIDATE((elm)->field.le_prev);\t\t\t\t\\\n+\t_Q_INVALIDATE((elm)->field.le_next);\t\t\t\t\\\n+} while (0)\n+\n+#define LIST_REPLACE(elm, elm2, field) do {\t\t\t\t\\\n+\tif (((elm2)->field.le_next = (elm)->field.le_next) != NULL)\t\\\n+\t\t(elm2)->field.le_next->field.le_prev =\t\t\t\\\n+\t\t    &(elm2)->field.le_next;\t\t\t\t\\\n+\t(elm2)->field.le_prev = (elm)->field.le_prev;\t\t\t\\\n+\t*(elm2)->field.le_prev = (elm2);\t\t\t\t\\\n+\t_Q_INVALIDATE((elm)->field.le_prev);\t\t\t\t\\\n+\t_Q_INVALIDATE((elm)->field.le_next);\t\t\t\t\\\n+} while (0)\n+\n+/*\n+ * Simple queue definitions.\n+ */\n+#define SIMPLEQ_HEAD(name, type)\t\t\t\t\t\\\n+struct name {\t\t\t\t\t\t\t\t\\\n+\tstruct type *sqh_first;\t/* first element */\t\t\t\\\n+\tstruct type **sqh_last;\t/* addr of last next element */\t\t\\\n+}\n+\n+#define SIMPLEQ_HEAD_INITIALIZER(head)\t\t\t\t\t\\\n+\t{ NULL, &(head).sqh_first }\n+\n+#define SIMPLEQ_ENTRY(type)\t\t\t\t\t\t\\\n+struct {\t\t\t\t\t\t\t\t\\\n+\tstruct type *sqe_next;\t/* next element */\t\t\t\\\n+}\n+\n+/*\n+ * Simple queue access methods.\n+ */\n+#define\tSIMPLEQ_FIRST(head)\t    ((head)->sqh_first)\n+#define\tSIMPLEQ_END(head)\t    NULL\n+#define\tSIMPLEQ_EMPTY(head)\t    (SIMPLEQ_FIRST(head) == SIMPLEQ_END(head))\n+#define\tSIMPLEQ_NEXT(elm, field)    ((elm)->field.sqe_next)\n+\n+#define SIMPLEQ_FOREACH(var, head, field)\t\t\t\t\\\n+\tfor((var) = SIMPLEQ_FIRST(head);\t\t\t\t\\\n+\t    (var) != SIMPLEQ_END(head);\t\t\t\t\t\\\n+\t    (var) = SIMPLEQ_NEXT(var, field))\n+\n+/*\n+ * Simple queue functions.\n+ */\n+#define\tSIMPLEQ_INIT(head) do {\t\t\t\t\t\t\\\n+\t(head)->sqh_first = NULL;\t\t\t\t\t\\\n+\t(head)->sqh_last = &(head)->sqh_first;\t\t\t\t\\\n+} while (0)\n+\n+#define SIMPLEQ_INSERT_HEAD(head, elm, field) do {\t\t\t\\\n+\tif (((elm)->field.sqe_next = (head)->sqh_first) == NULL)\t\\\n+\t\t(head)->sqh_last = &(elm)->field.sqe_next;\t\t\\\n+\t(head)->sqh_first = (elm);\t\t\t\t\t\\\n+} while (0)\n+\n+#define SIMPLEQ_INSERT_TAIL(head, elm, field) do {\t\t\t\\\n+\t(elm)->field.sqe_next = NULL;\t\t\t\t\t\\\n+\t*(head)->sqh_last = (elm);\t\t\t\t\t\\\n+\t(head)->sqh_last = &(elm)->field.sqe_next;\t\t\t\\\n+} while (0)\n+\n+#define SIMPLEQ_INSERT_AFTER(head, listelm, elm, field) do {\t\t\\\n+\tif (((elm)->field.sqe_next = (listelm)->field.sqe_next) == NULL)\\\n+\t\t(head)->sqh_last = &(elm)->field.sqe_next;\t\t\\\n+\t(listelm)->field.sqe_next = (elm);\t\t\t\t\\\n+} while (0)\n+\n+#define SIMPLEQ_REMOVE_HEAD(head, field) do {\t\t\t\\\n+\tif (((head)->sqh_first = (head)->sqh_first->field.sqe_next) == NULL) \\\n+\t\t(head)->sqh_last = &(head)->sqh_first;\t\t\t\\\n+} while (0)\n+\n+/*\n+ * Tail queue definitions.\n+ */\n+#define TAILQ_HEAD(name, type)\t\t\t\t\t\t\\\n+struct name {\t\t\t\t\t\t\t\t\\\n+\tstruct type *tqh_first;\t/* first element */\t\t\t\\\n+\tstruct type **tqh_last;\t/* addr of last next element */\t\t\\\n+}\n+\n+#define TAILQ_HEAD_INITIALIZER(head)\t\t\t\t\t\\\n+\t{ NULL, &(head).tqh_first }\n+\n+#define TAILQ_ENTRY(type)\t\t\t\t\t\t\\\n+struct {\t\t\t\t\t\t\t\t\\\n+\tstruct type *tqe_next;\t/* next element */\t\t\t\\\n+\tstruct type **tqe_prev;\t/* address of previous next element */\t\\\n+}\n+\n+/* \n+ * tail queue access methods \n+ */\n+#define\tTAILQ_FIRST(head)\t\t((head)->tqh_first)\n+#define\tTAILQ_END(head)\t\t\tNULL\n+#define\tTAILQ_NEXT(elm, field)\t\t((elm)->field.tqe_next)\n+#define TAILQ_LAST(head, headname)\t\t\t\t\t\\\n+\t(*(((struct headname *)((head)->tqh_last))->tqh_last))\n+/* XXX */\n+#define TAILQ_PREV(elm, headname, field)\t\t\t\t\\\n+\t(*(((struct headname *)((elm)->field.tqe_prev))->tqh_last))\n+#define\tTAILQ_EMPTY(head)\t\t\t\t\t\t\\\n+\t(TAILQ_FIRST(head) == TAILQ_END(head))\n+\n+#define TAILQ_FOREACH(var, head, field)\t\t\t\t\t\\\n+\tfor((var) = TAILQ_FIRST(head);\t\t\t\t\t\\\n+\t    (var) != TAILQ_END(head);\t\t\t\t\t\\\n+\t    (var) = TAILQ_NEXT(var, field))\n+\n+#define TAILQ_FOREACH_REVERSE(var, head, headname, field)\t\t\\\n+\tfor((var) = TAILQ_LAST(head, headname);\t\t\t\t\\\n+\t    (var) != TAILQ_END(head);\t\t\t\t\t\\\n+\t    (var) = TAILQ_PREV(var, headname, field))\n+\n+/*\n+ * Tail queue functions.\n+ */\n+#define\tTAILQ_INIT(head) do {\t\t\t\t\t\t\\\n+\t(head)->tqh_first = NULL;\t\t\t\t\t\\\n+\t(head)->tqh_last = &(head)->tqh_first;\t\t\t\t\\\n+} while (0)\n+\n+#define TAILQ_INSERT_HEAD(head, elm, field) do {\t\t\t\\\n+\tif (((elm)->field.tqe_next = (head)->tqh_first) != NULL)\t\\\n+\t\t(head)->tqh_first->field.tqe_prev =\t\t\t\\\n+\t\t    &(elm)->field.tqe_next;\t\t\t\t\\\n+\telse\t\t\t\t\t\t\t\t\\\n+\t\t(head)->tqh_last = &(elm)->field.tqe_next;\t\t\\\n+\t(head)->tqh_first = (elm);\t\t\t\t\t\\\n+\t(elm)->field.tqe_prev = &(head)->tqh_first;\t\t\t\\\n+} while (0)\n+\n+#define TAILQ_INSERT_TAIL(head, elm, field) do {\t\t\t\\\n+\t(elm)->field.tqe_next = NULL;\t\t\t\t\t\\\n+\t(elm)->field.tqe_prev = (head)->tqh_last;\t\t\t\\\n+\t*(head)->tqh_last = (elm);\t\t\t\t\t\\\n+\t(head)->tqh_last = &(elm)->field.tqe_next;\t\t\t\\\n+} while (0)\n+\n+#define TAILQ_INSERT_AFTER(head, listelm, elm, field) do {\t\t\\\n+\tif (((elm)->field.tqe_next = (listelm)->field.tqe_next) != NULL)\\\n+\t\t(elm)->field.tqe_next->field.tqe_prev =\t\t\t\\\n+\t\t    &(elm)->field.tqe_next;\t\t\t\t\\\n+\telse\t\t\t\t\t\t\t\t\\\n+\t\t(head)->tqh_last = &(elm)->field.tqe_next;\t\t\\\n+\t(listelm)->field.tqe_next = (elm);\t\t\t\t\\\n+\t(elm)->field.tqe_prev = &(listelm)->field.tqe_next;\t\t\\\n+} while (0)\n+\n+#define\tTAILQ_INSERT_BEFORE(listelm, elm, field) do {\t\t\t\\\n+\t(elm)->field.tqe_prev = (listelm)->field.tqe_prev;\t\t\\\n+\t(elm)->field.tqe_next = (listelm);\t\t\t\t\\\n+\t*(listelm)->field.tqe_prev = (elm);\t\t\t\t\\\n+\t(listelm)->field.tqe_prev = &(elm)->field.tqe_next;\t\t\\\n+} while (0)\n+\n+#define TAILQ_REMOVE(head, elm, field) do {\t\t\t\t\\\n+\tif (((elm)->field.tqe_next) != NULL)\t\t\t\t\\\n+\t\t(elm)->field.tqe_next->field.tqe_prev =\t\t\t\\\n+\t\t    (elm)->field.tqe_prev;\t\t\t\t\\\n+\telse\t\t\t\t\t\t\t\t\\\n+\t\t(head)->tqh_last = (elm)->field.tqe_prev;\t\t\\\n+\t*(elm)->field.tqe_prev = (elm)->field.tqe_next;\t\t\t\\\n+\t_Q_INVALIDATE((elm)->field.tqe_prev);\t\t\t\t\\\n+\t_Q_INVALIDATE((elm)->field.tqe_next);\t\t\t\t\\\n+} while (0)\n+\n+#define TAILQ_REPLACE(head, elm, elm2, field) do {\t\t\t\\\n+\tif (((elm2)->field.tqe_next = (elm)->field.tqe_next) != NULL)\t\\\n+\t\t(elm2)->field.tqe_next->field.tqe_prev =\t\t\\\n+\t\t    &(elm2)->field.tqe_next;\t\t\t\t\\\n+\telse\t\t\t\t\t\t\t\t\\\n+\t\t(head)->tqh_last = &(elm2)->field.tqe_next;\t\t\\\n+\t(elm2)->field.tqe_prev = (elm)->field.tqe_prev;\t\t\t\\\n+\t*(elm2)->field.tqe_prev = (elm2);\t\t\t\t\\\n+\t_Q_INVALIDATE((elm)->field.tqe_prev);\t\t\t\t\\\n+\t_Q_INVALIDATE((elm)->field.tqe_next);\t\t\t\t\\\n+} while (0)\n+\n+/*\n+ * Circular queue definitions.\n+ */\n+#define CIRCLEQ_HEAD(name, type)\t\t\t\t\t\\\n+struct name {\t\t\t\t\t\t\t\t\\\n+\tstruct type *cqh_first;\t\t/* first element */\t\t\\\n+\tstruct type *cqh_last;\t\t/* last element */\t\t\\\n+}\n+\n+#define CIRCLEQ_HEAD_INITIALIZER(head)\t\t\t\t\t\\\n+\t{ CIRCLEQ_END(&head), CIRCLEQ_END(&head) }\n+\n+#define CIRCLEQ_ENTRY(type)\t\t\t\t\t\t\\\n+struct {\t\t\t\t\t\t\t\t\\\n+\tstruct type *cqe_next;\t\t/* next element */\t\t\\\n+\tstruct type *cqe_prev;\t\t/* previous element */\t\t\\\n+}\n+\n+/*\n+ * Circular queue access methods \n+ */\n+#define\tCIRCLEQ_FIRST(head)\t\t((head)->cqh_first)\n+#define\tCIRCLEQ_LAST(head)\t\t((head)->cqh_last)\n+#define\tCIRCLEQ_END(head)\t\t((void *)(head))\n+#define\tCIRCLEQ_NEXT(elm, field)\t((elm)->field.cqe_next)\n+#define\tCIRCLEQ_PREV(elm, field)\t((elm)->field.cqe_prev)\n+#define\tCIRCLEQ_EMPTY(head)\t\t\t\t\t\t\\\n+\t(CIRCLEQ_FIRST(head) == CIRCLEQ_END(head))\n+\n+#define CIRCLEQ_FOREACH(var, head, field)\t\t\t\t\\\n+\tfor((var) = CIRCLEQ_FIRST(head);\t\t\t\t\\\n+\t    (var) != CIRCLEQ_END(head);\t\t\t\t\t\\\n+\t    (var) = CIRCLEQ_NEXT(var, field))\n+\n+#define CIRCLEQ_FOREACH_REVERSE(var, head, field)\t\t\t\\\n+\tfor((var) = CIRCLEQ_LAST(head);\t\t\t\t\t\\\n+\t    (var) != CIRCLEQ_END(head);\t\t\t\t\t\\\n+\t    (var) = CIRCLEQ_PREV(var, field))\n+\n+/*\n+ * Circular queue functions.\n+ */\n+#define\tCIRCLEQ_INIT(head) do {\t\t\t\t\t\t\\\n+\t(head)->cqh_first = CIRCLEQ_END(head);\t\t\t\t\\\n+\t(head)->cqh_last = CIRCLEQ_END(head);\t\t\t\t\\\n+} while (0)\n+\n+#define CIRCLEQ_INSERT_AFTER(head, listelm, elm, field) do {\t\t\\\n+\t(elm)->field.cqe_next = (listelm)->field.cqe_next;\t\t\\\n+\t(elm)->field.cqe_prev = (listelm);\t\t\t\t\\\n+\tif ((listelm)->field.cqe_next == CIRCLEQ_END(head))\t\t\\\n+\t\t(head)->cqh_last = (elm);\t\t\t\t\\\n+\telse\t\t\t\t\t\t\t\t\\\n+\t\t(listelm)->field.cqe_next->field.cqe_prev = (elm);\t\\\n+\t(listelm)->field.cqe_next = (elm);\t\t\t\t\\\n+} while (0)\n+\n+#define CIRCLEQ_INSERT_BEFORE(head, listelm, elm, field) do {\t\t\\\n+\t(elm)->field.cqe_next = (listelm);\t\t\t\t\\\n+\t(elm)->field.cqe_prev = (listelm)->field.cqe_prev;\t\t\\\n+\tif ((listelm)->field.cqe_prev == CIRCLEQ_END(head))\t\t\\\n+\t\t(head)->cqh_first = (elm);\t\t\t\t\\\n+\telse\t\t\t\t\t\t\t\t\\\n+\t\t(listelm)->field.cqe_prev->field.cqe_next = (elm);\t\\\n+\t(listelm)->field.cqe_prev = (elm);\t\t\t\t\\\n+} while (0)\n+\n+#define CIRCLEQ_INSERT_HEAD(head, elm, field) do {\t\t\t\\\n+\t(elm)->field.cqe_next = (head)->cqh_first;\t\t\t\\\n+\t(elm)->field.cqe_prev = CIRCLEQ_END(head);\t\t\t\\\n+\tif ((head)->cqh_last == CIRCLEQ_END(head))\t\t\t\\\n+\t\t(head)->cqh_last = (elm);\t\t\t\t\\\n+\telse\t\t\t\t\t\t\t\t\\\n+\t\t(head)->cqh_first->field.cqe_prev = (elm);\t\t\\\n+\t(head)->cqh_first = (elm);\t\t\t\t\t\\\n+} while (0)\n+\n+#define CIRCLEQ_INSERT_TAIL(head, elm, field) do {\t\t\t\\\n+\t(elm)->field.cqe_next = CIRCLEQ_END(head);\t\t\t\\\n+\t(elm)->field.cqe_prev = (head)->cqh_last;\t\t\t\\\n+\tif ((head)->cqh_first == CIRCLEQ_END(head))\t\t\t\\\n+\t\t(head)->cqh_first = (elm);\t\t\t\t\\\n+\telse\t\t\t\t\t\t\t\t\\\n+\t\t(head)->cqh_last->field.cqe_next = (elm);\t\t\\\n+\t(head)->cqh_last = (elm);\t\t\t\t\t\\\n+} while (0)\n+\n+#define\tCIRCLEQ_REMOVE(head, elm, field) do {\t\t\t\t\\\n+\tif ((elm)->field.cqe_next == CIRCLEQ_END(head))\t\t\t\\\n+\t\t(head)->cqh_last = (elm)->field.cqe_prev;\t\t\\\n+\telse\t\t\t\t\t\t\t\t\\\n+\t\t(elm)->field.cqe_next->field.cqe_prev =\t\t\t\\\n+\t\t    (elm)->field.cqe_prev;\t\t\t\t\\\n+\tif ((elm)->field.cqe_prev == CIRCLEQ_END(head))\t\t\t\\\n+\t\t(head)->cqh_first = (elm)->field.cqe_next;\t\t\\\n+\telse\t\t\t\t\t\t\t\t\\\n+\t\t(elm)->field.cqe_prev->field.cqe_next =\t\t\t\\\n+\t\t    (elm)->field.cqe_next;\t\t\t\t\\\n+\t_Q_INVALIDATE((elm)->field.cqe_prev);\t\t\t\t\\\n+\t_Q_INVALIDATE((elm)->field.cqe_next);\t\t\t\t\\\n+} while (0)\n+\n+#define CIRCLEQ_REPLACE(head, elm, elm2, field) do {\t\t\t\\\n+\tif (((elm2)->field.cqe_next = (elm)->field.cqe_next) ==\t\t\\\n+\t    CIRCLEQ_END(head))\t\t\t\t\t\t\\\n+\t\t(head).cqh_last = (elm2);\t\t\t\t\\\n+\telse\t\t\t\t\t\t\t\t\\\n+\t\t(elm2)->field.cqe_next->field.cqe_prev = (elm2);\t\\\n+\tif (((elm2)->field.cqe_prev = (elm)->field.cqe_prev) ==\t\t\\\n+\t    CIRCLEQ_END(head))\t\t\t\t\t\t\\\n+\t\t(head).cqh_first = (elm2);\t\t\t\t\\\n+\telse\t\t\t\t\t\t\t\t\\\n+\t\t(elm2)->field.cqe_prev->field.cqe_next = (elm2);\t\\\n+\t_Q_INVALIDATE((elm)->field.cqe_prev);\t\t\t\t\\\n+\t_Q_INVALIDATE((elm)->field.cqe_next);\t\t\t\t\\\n+} while (0)\n+\n+#endif\t/* !_SYS_QUEUE_H_ */"
      },
      {
        "sha": "f11e5e9367cb6e6e1635a05cc6dcf709549ee857",
        "filename": "miniupnpc/codelength.h",
        "status": "added",
        "additions": 24,
        "deletions": 0,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/codelength.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/codelength.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/miniupnpc/codelength.h?ref=b94b7b05a7b1d27e28ca9a8684877ca605d70256",
        "patch": "@@ -0,0 +1,24 @@\n+/* $Id: codelength.h,v 1.1 2008/10/06 22:04:06 nanard Exp $ */\n+/* Project : miniupnp\n+ * Author : Thomas BERNARD\n+ * copyright (c) 2005-2008 Thomas Bernard\n+ * This software is subjet to the conditions detailed in the\n+ * provided LICENCE file. */\n+#ifndef __CODELENGTH_H__\n+#define __CODELENGTH_H__\n+\n+/* Encode length by using 7bit per Byte :\n+ * Most significant bit of each byte specifies that the\n+ * following byte is part of the code */\n+#define DECODELENGTH(n, p) n = 0; \\\n+                           do { n = (n << 7) | (*p & 0x7f); } \\\n+                           while(*(p++)&0x80);\n+\n+#define CODELENGTH(n, p) if(n>=268435456) *(p++) = (n >> 28) | 0x80; \\\n+                         if(n>=2097152) *(p++) = (n >> 21) | 0x80; \\\n+                         if(n>=16384) *(p++) = (n >> 14) | 0x80; \\\n+                         if(n>=128) *(p++) = (n >> 7) | 0x80; \\\n+                         *(p++) = n & 0x7f;\n+\n+#endif\n+"
      },
      {
        "sha": "5e5da3af7aca73938c16836f28ce92854f5db20c",
        "filename": "miniupnpc/connecthostport.c",
        "status": "added",
        "additions": 223,
        "deletions": 0,
        "changes": 223,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/connecthostport.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/connecthostport.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/miniupnpc/connecthostport.c?ref=b94b7b05a7b1d27e28ca9a8684877ca605d70256",
        "patch": "@@ -0,0 +1,223 @@\n+/* $Id: connecthostport.c,v 1.3 2010/12/21 16:13:14 nanard Exp $ */\n+/* Project : miniupnp\n+ * Author : Thomas Bernard\n+ * Copyright (c) 2010 Thomas Bernard\n+ * This software is subject to the conditions detailed in the\n+ * LICENCE file provided in this distribution. */\n+\n+/* use getaddrinfo() or gethostbyname()\n+ * uncomment the following line in order to use gethostbyname() */\n+#ifdef NO_GETADDRINFO\n+#define USE_GETHOSTBYNAME\n+#endif\n+\n+#include <string.h>\n+#include <stdio.h>\n+#ifdef WIN32\n+#include <winsock2.h>\n+#include <ws2tcpip.h>\n+#include <io.h>\n+#define snprintf _snprintf\n+#define herror\n+#define socklen_t int\n+#else /* #ifdef WIN32 */\n+#include <unistd.h>\n+#include <errno.h>\n+#define closesocket close\n+#include <netdb.h>\n+/* defining MINIUPNPC_IGNORE_EINTR enable the ignore of interruptions\n+ * during the connect() call */\n+#define MINIUPNPC_IGNORE_EINTR\n+#ifndef USE_GETHOSTBYNAME\n+#include <sys/types.h>\n+#include <sys/socket.h>\n+#endif /* #ifndef USE_GETHOSTBYNAME */\n+#endif /* #else WIN32 */\n+\n+/* definition of PRINT_SOCKET_ERROR */\n+#ifdef WIN32\n+#define PRINT_SOCKET_ERROR(x)    printf(\"Socket error: %s, %d\\n\", x, WSAGetLastError());\n+#else\n+#define PRINT_SOCKET_ERROR(x) perror(x)\n+#endif\n+\n+#if defined(__amigaos__) || defined(__amigaos4__)\n+#define herror(A) printf(\"%s\\n\", A)\n+#endif\n+\n+#include \"connecthostport.h\"\n+\n+/* connecthostport()\n+ * return a socket connected (TCP) to the host and port\n+ * or -1 in case of error */\n+int connecthostport(const char * host, unsigned short port)\n+{\n+\tint s, n;\n+#ifdef USE_GETHOSTBYNAME\n+\tstruct sockaddr_in dest;\n+\tstruct hostent *hp;\n+#else /* #ifdef USE_GETHOSTBYNAME */\n+\tchar port_str[8];\n+\tstruct addrinfo *ai, *p;\n+\tstruct addrinfo hints;\n+#endif /* #ifdef USE_GETHOSTBYNAME */\n+#ifdef MINIUPNPC_SET_SOCKET_TIMEOUT\n+\tstruct timeval timeout;\n+#endif /* #ifdef MINIUPNPC_SET_SOCKET_TIMEOUT */\n+\t\n+#ifdef USE_GETHOSTBYNAME\n+\thp = gethostbyname(host);\n+\tif(hp == NULL)\n+\t{\n+\t\therror(host);\n+\t\treturn -1;\n+\t}\n+\tmemcpy(&dest.sin_addr, hp->h_addr, sizeof(dest.sin_addr));\n+\tmemset(dest.sin_zero, 0, sizeof(dest.sin_zero));\n+\ts = socket(PF_INET, SOCK_STREAM, 0);\n+\tif(s < 0)\n+\t{\n+\t\tPRINT_SOCKET_ERROR(\"socket\");\n+\t\treturn -1;\n+\t}\n+#ifdef MINIUPNPC_SET_SOCKET_TIMEOUT\n+\t/* setting a 3 seconds timeout for the connect() call */\n+\ttimeout.tv_sec = 3;\n+\ttimeout.tv_usec = 0;\n+\tif(setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof(struct timeval)) < 0)\n+\t{\n+\t\tPRINT_SOCKET_ERROR(\"setsockopt\");\n+\t}\n+\ttimeout.tv_sec = 3;\n+\ttimeout.tv_usec = 0;\n+\tif(setsockopt(s, SOL_SOCKET, SO_SNDTIMEO, &timeout, sizeof(struct timeval)) < 0)\n+\t{\n+\t\tPRINT_SOCKET_ERROR(\"setsockopt\");\n+\t}\n+#endif /* #ifdef MINIUPNPC_SET_SOCKET_TIMEOUT */\n+\tdest.sin_family = AF_INET;\n+\tdest.sin_port = htons(port);\n+\tn = connect(s, (struct sockaddr *)&dest, sizeof(struct sockaddr_in));\n+#ifdef MINIUPNPC_IGNORE_EINTR\n+\twhile(n < 0 && errno == EINTR)\n+\t{\n+\t\tsocklen_t len;\n+\t\tfd_set wset;\n+\t\tint err;\n+\t\tFD_ZERO(&wset);\n+\t\tFD_SET(s, &wset);\n+\t\tif((n = select(s + 1, NULL, &wset, NULL, NULL)) == -1 && errno == EINTR)\n+\t\t\tcontinue;\n+\t\t/*len = 0;*/\n+\t\t/*n = getpeername(s, NULL, &len);*/\n+\t\tlen = sizeof(err);\n+\t\tif(getsockopt(s, SOL_SOCKET, SO_ERROR, &err, &len) < 0) {\n+\t\t\tPRINT_SOCKET_ERROR(\"getsockopt\");\n+\t\t\tclosesocket(s);\n+\t\t\treturn -1;\n+\t\t}\n+\t\tif(err != 0) {\n+\t\t\terrno = err;\n+\t\t\tn = -1;\n+\t\t}\n+\t}\n+#endif /* #ifdef MINIUPNPC_IGNORE_EINTR */\n+\tif(n<0)\n+\t{\n+\t\tPRINT_SOCKET_ERROR(\"connect\");\n+\t\tclosesocket(s);\n+\t\treturn -1;\n+\t}\n+#else /* #ifdef USE_GETHOSTBYNAME */\n+\t/* use getaddrinfo() instead of gethostbyname() */\n+\tmemset(&hints, 0, sizeof(hints));\n+\t/* hints.ai_flags = AI_ADDRCONFIG; */\n+#ifdef AI_NUMERICSERV\n+\thints.ai_flags = AI_NUMERICSERV;\n+#endif\n+\thints.ai_socktype = SOCK_STREAM;\n+\thints.ai_family = AF_UNSPEC; /* AF_INET, AF_INET6 or AF_UNSPEC */\n+\t/* hints.ai_protocol = IPPROTO_TCP; */\n+\tsnprintf(port_str, sizeof(port_str), \"%hu\", port);\n+\tn = getaddrinfo(host, port_str, &hints, &ai);\n+\tif(n != 0)\n+\t{\n+#ifdef WIN32\n+\t\tfprintf(stderr, \"getaddrinfo() error : %d\\n\", n);\n+#else\n+\t\tfprintf(stderr, \"getaddrinfo() error : %s\\n\", gai_strerror(n));\n+#endif\n+\t\treturn -1;\n+\t}\n+\ts = -1;\n+\tfor(p = ai; p; p = p->ai_next)\n+\t{\n+\t\ts = socket(p->ai_family, p->ai_socktype, p->ai_protocol);\n+\t\tif(s < 0)\n+\t\t\tcontinue;\n+#ifdef MINIUPNPC_SET_SOCKET_TIMEOUT\n+\t\t/* setting a 3 seconds timeout for the connect() call */\n+\t\ttimeout.tv_sec = 3;\n+\t\ttimeout.tv_usec = 0;\n+\t\tif(setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof(struct timeval)) < 0)\n+\t\t{\n+\t\t\tPRINT_SOCKET_ERROR(\"setsockopt\");\n+\t\t}\n+\t\ttimeout.tv_sec = 3;\n+\t\ttimeout.tv_usec = 0;\n+\t\tif(setsockopt(s, SOL_SOCKET, SO_SNDTIMEO, &timeout, sizeof(struct timeval)) < 0)\n+\t\t{\n+\t\t\tPRINT_SOCKET_ERROR(\"setsockopt\");\n+\t\t}\n+#endif /* #ifdef MINIUPNPC_SET_SOCKET_TIMEOUT */\n+\t\tn = connect(s, p->ai_addr, p->ai_addrlen);\n+#ifdef MINIUPNPC_IGNORE_EINTR\n+\t\twhile(n < 0 && errno == EINTR)\n+\t\t{\n+\t\t\tsocklen_t len;\n+\t\t\tfd_set wset;\n+\t\t\tint err;\n+\t\t\tFD_ZERO(&wset);\n+\t\t\tFD_SET(s, &wset);\n+\t\t\tif((n = select(s + 1, NULL, &wset, NULL, NULL)) == -1 && errno == EINTR)\n+\t\t\t\tcontinue;\n+\t\t\t/*len = 0;*/\n+\t\t\t/*n = getpeername(s, NULL, &len);*/\n+\t\t\tlen = sizeof(err);\n+\t\t\tif(getsockopt(s, SOL_SOCKET, SO_ERROR, &err, &len) < 0) {\n+\t\t\t\tPRINT_SOCKET_ERROR(\"getsockopt\");\n+\t\t\t\tclosesocket(s);\n+\t\t\t\tfreeaddrinfo(ai);\n+\t\t\t\treturn -1;\n+\t\t\t}\n+\t\t\tif(err != 0) {\n+\t\t\t\terrno = err;\n+\t\t\t\tn = -1;\n+\t\t\t}\n+\t\t}\n+#endif /* #ifdef MINIUPNPC_IGNORE_EINTR */\n+\t\tif(n < 0)\n+\t\t{\n+\t\t\tclosesocket(s);\n+\t\t\tcontinue;\n+\t\t}\n+\t\telse\n+\t\t{\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+\tfreeaddrinfo(ai);\n+\tif(s < 0)\n+\t{\n+\t\tPRINT_SOCKET_ERROR(\"socket\");\n+\t\treturn -1;\n+\t}\n+\tif(n < 0)\n+\t{\n+\t\tPRINT_SOCKET_ERROR(\"connect\");\n+\t\treturn -1;\n+\t}\n+#endif /* #ifdef USE_GETHOSTBYNAME */\n+\treturn s;\n+}\n+"
      },
      {
        "sha": "57e24eb27681aa61a8a4a42fe6c1ffab84bc8691",
        "filename": "miniupnpc/connecthostport.h",
        "status": "added",
        "additions": 17,
        "deletions": 0,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/connecthostport.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/connecthostport.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/miniupnpc/connecthostport.h?ref=b94b7b05a7b1d27e28ca9a8684877ca605d70256",
        "patch": "@@ -0,0 +1,17 @@\n+/* $Id: connecthostport.h,v 1.1 2010/04/04 23:21:03 nanard Exp $ */\n+/* Project: miniupnp\n+ * http://miniupnp.free.fr/\n+ * Author: Thomas Bernard\n+ * Copyright (c) 2010 Thomas Bernard\n+ * This software is subjects to the conditions detailed\n+ * in the LICENCE file provided within this distribution */\n+#ifndef __CONNECTHOSTPORT_H__\n+#define __CONNECTHOSTPORT_H__\n+\n+/* connecthostport()\n+ * return a socket connected (TCP) to the host and port\n+ * or -1 in case of error */\n+int connecthostport(const char * host, unsigned short port);\n+\n+#endif\n+"
      },
      {
        "sha": "b804247d255f2e4d12e2e48323f90ac24013b931",
        "filename": "miniupnpc/declspec.h",
        "status": "added",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/declspec.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/declspec.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/miniupnpc/declspec.h?ref=b94b7b05a7b1d27e28ca9a8684877ca605d70256",
        "patch": "@@ -0,0 +1,15 @@\n+#ifndef __DECLSPEC_H__\n+#define __DECLSPEC_H__\n+\n+#if defined(WIN32) && !defined(STATICLIB)\n+\t#ifdef MINIUPNP_EXPORTS\n+\t\t#define LIBSPEC __declspec(dllexport)\n+\t#else\n+\t\t#define LIBSPEC __declspec(dllimport)\n+\t#endif\n+#else\n+\t#define LIBSPEC\n+#endif\n+\n+#endif\n+"
      },
      {
        "sha": "965d86b2a6ec40726ce24f90e87377600685884c",
        "filename": "miniupnpc/external-ip.sh",
        "status": "added",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/external-ip.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/external-ip.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/miniupnpc/external-ip.sh?ref=b94b7b05a7b1d27e28ca9a8684877ca605d70256",
        "patch": "@@ -0,0 +1,4 @@\n+#!/bin/sh\n+# $Id: external-ip.sh,v 1.1 2010/08/05 12:57:41 nanard Exp $\n+# (c) 2010 Reuben Hawkins\n+upnpc -s | grep ExternalIPAddress | sed 's/[^0-9\\.]//g'"
      },
      {
        "sha": "8df6950e1be3a7063b19ecec30cf817608300167",
        "filename": "miniupnpc/igd_desc_parse.c",
        "status": "added",
        "additions": 114,
        "deletions": 0,
        "changes": 114,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/igd_desc_parse.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/igd_desc_parse.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/miniupnpc/igd_desc_parse.c?ref=b94b7b05a7b1d27e28ca9a8684877ca605d70256",
        "patch": "@@ -0,0 +1,114 @@\n+/* $Id: igd_desc_parse.c,v 1.11 2010/12/11 17:56:51 nanard Exp $ */\n+/* Project : miniupnp\n+ * http://miniupnp.free.fr/\n+ * Author : Thomas Bernard\n+ * Copyright (c) 2005-2010 Thomas Bernard\n+ * This software is subject to the conditions detailed in the\n+ * LICENCE file provided in this distribution. */\n+\n+#include \"igd_desc_parse.h\"\n+#include <stdio.h>\n+#include <string.h>\n+\n+/* Start element handler :\n+ * update nesting level counter and copy element name */\n+void IGDstartelt(void * d, const char * name, int l)\n+{\n+\tstruct IGDdatas * datas = (struct IGDdatas *)d;\n+\tmemcpy( datas->cureltname, name, l);\n+\tdatas->cureltname[l] = '\\0';\n+\tdatas->level++;\n+\tif( (l==7) && !memcmp(name, \"service\", l) ) {\n+\t\tdatas->tmp.controlurl[0] = '\\0';\n+\t\tdatas->tmp.eventsuburl[0] = '\\0';\n+\t\tdatas->tmp.scpdurl[0] = '\\0';\n+\t\tdatas->tmp.servicetype[0] = '\\0';\n+\t}\n+}\n+\n+/* End element handler :\n+ * update nesting level counter and update parser state if\n+ * service element is parsed */\n+void IGDendelt(void * d, const char * name, int l)\n+{\n+\tstruct IGDdatas * datas = (struct IGDdatas *)d;\n+\tdatas->level--;\n+\t/*printf(\"endelt %2d %.*s\\n\", datas->level, l, name);*/\n+\tif( (l==7) && !memcmp(name, \"service\", l) )\n+\t{\n+\t\t/*\n+\t\tif( datas->state < 1\n+\t\t\t&& !strcmp(datas->servicetype,\n+\t\t\t\t//\t\"urn:schemas-upnp-org:service:WANIPConnection:1\") )\n+\t\t\t\t\"urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1\"))\n+\t\t\tdatas->state ++;\n+\t\t*/\n+\t\tif(0==strcmp(datas->tmp.servicetype,\n+\t\t\t\t\"urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1\")) {\n+\t\t\tmemcpy(&datas->CIF, &datas->tmp, sizeof(struct IGDdatas_service));\n+\t\t} else if(0==strcmp(datas->tmp.servicetype,\n+\t\t\t\t\"urn:schemas-upnp-org:service:WANIPConnection:1\")\n+\t\t\t\t || 0==strcmp(datas->tmp.servicetype,\n+\t\t\t\t\"urn:schemas-upnp-org:service:WANPPPConnection:1\") ) {\n+\t\t\tif(datas->first.servicetype[0] == '\\0') {\n+\t\t\t\tmemcpy(&datas->first, &datas->tmp, sizeof(struct IGDdatas_service));\n+\t\t\t} else {\n+\t\t\t\tmemcpy(&datas->second, &datas->tmp, sizeof(struct IGDdatas_service));\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+/* Data handler :\n+ * copy data depending on the current element name and state */\n+void IGDdata(void * d, const char * data, int l)\n+{\n+\tstruct IGDdatas * datas = (struct IGDdatas *)d;\n+\tchar * dstmember = 0;\n+\t/*printf(\"%2d %s : %.*s\\n\",\n+           datas->level, datas->cureltname, l, data);\t*/\n+\tif( !strcmp(datas->cureltname, \"URLBase\") )\n+\t\tdstmember = datas->urlbase;\n+\telse if( !strcmp(datas->cureltname, \"serviceType\") )\n+\t\tdstmember = datas->tmp.servicetype;\n+\telse if( !strcmp(datas->cureltname, \"controlURL\") )\n+\t\tdstmember = datas->tmp.controlurl;\n+\telse if( !strcmp(datas->cureltname, \"eventSubURL\") )\n+\t\tdstmember = datas->tmp.eventsuburl;\n+\telse if( !strcmp(datas->cureltname, \"SCPDURL\") )\n+\t\tdstmember = datas->tmp.scpdurl;\n+/*\telse if( !strcmp(datas->cureltname, \"deviceType\") )\n+\t\tdstmember = datas->devicetype_tmp;*/\n+\tif(dstmember)\n+\t{\n+\t\tif(l>=MINIUPNPC_URL_MAXSIZE)\n+\t\t\tl = MINIUPNPC_URL_MAXSIZE-1;\n+\t\tmemcpy(dstmember, data, l);\n+\t\tdstmember[l] = '\\0';\n+\t}\n+}\n+\n+void printIGD(struct IGDdatas * d)\n+{\n+\tprintf(\"urlbase = '%s'\\n\", d->urlbase);\n+\tprintf(\"WAN Device (Common interface config) :\\n\");\n+\t/*printf(\" deviceType = '%s'\\n\", d->CIF.devicetype);*/\n+\tprintf(\" serviceType = '%s'\\n\", d->CIF.servicetype);\n+\tprintf(\" controlURL = '%s'\\n\", d->CIF.controlurl);\n+\tprintf(\" eventSubURL = '%s'\\n\", d->CIF.eventsuburl);\n+\tprintf(\" SCPDURL = '%s'\\n\", d->CIF.scpdurl);\n+\tprintf(\"primary WAN Connection Device (IP or PPP Connection):\\n\");\n+\t/*printf(\" deviceType = '%s'\\n\", d->first.devicetype);*/\n+\tprintf(\" servicetype = '%s'\\n\", d->first.servicetype);\n+\tprintf(\" controlURL = '%s'\\n\", d->first.controlurl);\n+\tprintf(\" eventSubURL = '%s'\\n\", d->first.eventsuburl);\n+\tprintf(\" SCPDURL = '%s'\\n\", d->first.scpdurl);\n+\tprintf(\"secondary WAN Connection Device (IP or PPP Connection):\\n\");\n+\t/*printf(\" deviceType = '%s'\\n\", d->second.devicetype);*/\n+\tprintf(\" servicetype = '%s'\\n\", d->second.servicetype);\n+\tprintf(\" controlURL = '%s'\\n\", d->second.controlurl);\n+\tprintf(\" eventSubURL = '%s'\\n\", d->second.eventsuburl);\n+\tprintf(\" SCPDURL = '%s'\\n\", d->second.scpdurl);\n+}\n+\n+"
      },
      {
        "sha": "40cca60b2a617f7f110101dd7ab7134e60b1c85a",
        "filename": "miniupnpc/igd_desc_parse.h",
        "status": "added",
        "additions": 45,
        "deletions": 0,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/igd_desc_parse.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/igd_desc_parse.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/miniupnpc/igd_desc_parse.h?ref=b94b7b05a7b1d27e28ca9a8684877ca605d70256",
        "patch": "@@ -0,0 +1,45 @@\n+/* $Id: igd_desc_parse.h,v 1.7 2010/04/05 20:36:59 nanard Exp $ */\n+/* Project : miniupnp\n+ * http://miniupnp.free.fr/\n+ * Author : Thomas Bernard\n+ * Copyright (c) 2005-2010 Thomas Bernard\n+ * This software is subject to the conditions detailed in the\n+ * LICENCE file provided in this distribution.\n+ * */\n+#ifndef __IGD_DESC_PARSE_H__\n+#define __IGD_DESC_PARSE_H__\n+\n+/* Structure to store the result of the parsing of UPnP\n+ * descriptions of Internet Gateway Devices */\n+#define MINIUPNPC_URL_MAXSIZE (128)\n+struct IGDdatas_service {\n+\tchar controlurl[MINIUPNPC_URL_MAXSIZE];\n+\tchar eventsuburl[MINIUPNPC_URL_MAXSIZE];\n+\tchar scpdurl[MINIUPNPC_URL_MAXSIZE];\n+\tchar servicetype[MINIUPNPC_URL_MAXSIZE];\n+\t/*char devicetype[MINIUPNPC_URL_MAXSIZE];*/\n+};\n+\n+struct IGDdatas {\n+\tchar cureltname[MINIUPNPC_URL_MAXSIZE];\n+\tchar urlbase[MINIUPNPC_URL_MAXSIZE];\n+\tint level;\n+\t/*int state;*/\n+\t/* \"urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1\" */\n+\tstruct IGDdatas_service CIF;\n+\t/* \"urn:schemas-upnp-org:service:WANIPConnection:1\"\n+\t * \"urn:schemas-upnp-org:service:WANPPPConnection:1\" */\n+\tstruct IGDdatas_service first;\n+\t/* if both WANIPConnection and WANPPPConnection are present */\n+\tstruct IGDdatas_service second;\n+\t/* tmp */\n+\tstruct IGDdatas_service tmp;\n+};\n+\n+void IGDstartelt(void *, const char *, int);\n+void IGDendelt(void *, const char *, int);\n+void IGDdata(void *, const char *, int);\n+void printIGD(struct IGDdatas *);\n+\n+#endif\n+"
      },
      {
        "sha": "9990010013b50e8299521f4e7d99cc0452d698c6",
        "filename": "miniupnpc/java/JavaBridgeTest.java",
        "status": "added",
        "additions": 89,
        "deletions": 0,
        "changes": 89,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/java/JavaBridgeTest.java",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/java/JavaBridgeTest.java",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/miniupnpc/java/JavaBridgeTest.java?ref=b94b7b05a7b1d27e28ca9a8684877ca605d70256",
        "patch": "@@ -0,0 +1,89 @@\n+import java.nio.ByteBuffer;\n+import fr.free.miniupnp.*;\n+\n+/**\n+ *\n+ * @author syuu\n+ */\n+public class JavaBridgeTest {\n+    public static void main(String[] args) {\n+        int UPNP_DELAY = 2000;\n+        MiniupnpcLibrary miniupnpc = MiniupnpcLibrary.INSTANCE;\n+        UPNPDev devlist = null;\n+        UPNPUrls urls = new UPNPUrls();\n+        IGDdatas data = new IGDdatas();\n+        ByteBuffer lanaddr = ByteBuffer.allocate(16);\n+        ByteBuffer intClient = ByteBuffer.allocate(16);\n+        ByteBuffer intPort = ByteBuffer.allocate(6);\n+        int ret;\n+        int i;\n+\n+        if(args.length < 2) {\n+            System.err.println(\"Usage : java [...] JavaBridgeTest port protocol\");\n+            System.out.println(\"  port is numeric, protocol is TCP or UDP\");\n+            return;\n+        }\n+\n+        devlist = miniupnpc.upnpDiscover(UPNP_DELAY, (String) null, (String) null, 0);\n+        if (devlist != null) {\n+            System.out.println(\"List of UPNP devices found on the network :\");\n+            for (UPNPDev device = devlist; device != null; device = device.pNext) {\n+                System.out.println(\"desc: \" + device.descURL.getString(0) + \" st: \" + device.st.getString(0));\n+            }\n+            if ((i = miniupnpc.UPNP_GetValidIGD(devlist, urls, data, lanaddr, 16)) != 0) {\n+                switch (i) {\n+                    case 1:\n+                        System.out.println(\"Found valid IGD : \" + urls.controlURL.getString(0));\n+                        break;\n+                    case 2:\n+                        System.out.println(\"Found a (not connected?) IGD : \" + urls.controlURL.getString(0));\n+                        System.out.println(\"Trying to continue anyway\");\n+                        break;\n+                    case 3:\n+                        System.out.println(\"UPnP device found. Is it an IGD ? : \" + urls.controlURL.getString(0));\n+                        System.out.println(\"Trying to continue anyway\");\n+                        break;\n+                    default:\n+                        System.out.println(\"Found device (igd ?) : \" + urls.controlURL.getString(0));\n+                        System.out.println(\"Trying to continue anyway\");\n+\n+                }\n+                System.out.println(\"Local LAN ip address : \" + new String(lanaddr.array()));\n+                ByteBuffer externalAddress = ByteBuffer.allocate(16);\n+                miniupnpc.UPNP_GetExternalIPAddress(urls.controlURL.getString(0),\n+                        new String(data.first.servicetype), externalAddress);\n+                System.out.println(\"ExternalIPAddress = \" + new String(externalAddress.array()));\n+                ret = miniupnpc.UPNP_AddPortMapping(\n+                        urls.controlURL.getString(0), // controlURL\n+                        new String(data.first.servicetype), // servicetype\n+                        args[0], // external Port\n+                        args[0], // internal Port\n+                        new String(lanaddr.array()), // internal client\n+                        \"added via miniupnpc/JAVA !\", // description\n+                        args[1], // protocol UDP or TCP\n+                        null); // remote host (useless)\n+                if (ret != MiniupnpcLibrary.UPNPCOMMAND_SUCCESS)\n+                    System.out.println(\"AddPortMapping() failed with code \" + ret);\n+                ret = miniupnpc.UPNP_GetSpecificPortMappingEntry(\n+                        urls.controlURL.getString(0), new String(data.first.servicetype),\n+                        args[0], args[1], intClient, intPort);\n+                if (ret != MiniupnpcLibrary.UPNPCOMMAND_SUCCESS)\n+                    System.out.println(\"GetSpecificPortMappingEntry() failed with code \" + ret);\n+                System.out.println(\"InternalIP:Port = \" +\n+                        new String(intClient.array()) + \":\" + new String(intPort.array()));\n+                ret = miniupnpc.UPNP_DeletePortMapping(\n+                        urls.controlURL.getString(0),\n+                        new String(data.first.servicetype),\n+                        args[0], args[1], null);\n+                if (ret != MiniupnpcLibrary.UPNPCOMMAND_SUCCESS)\n+                    System.out.println(\"DelPortMapping() failed with code \" + ret);\n+                miniupnpc.FreeUPNPUrls(urls);\n+            } else {\n+                System.out.println(\"No valid UPNP Internet Gateway Device found.\");\n+            }\n+            miniupnpc.freeUPNPDevlist(devlist);\n+        } else {\n+            System.out.println(\"No IGD UPnP Device found on the network !\\n\");\n+        }\n+    }\n+}"
      },
      {
        "sha": "c997baf9e8a9d7906febe1b5c4f1b22f8c87e971",
        "filename": "miniupnpc/java/testjava.sh",
        "status": "added",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/java/testjava.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/java/testjava.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/miniupnpc/java/testjava.sh?ref=b94b7b05a7b1d27e28ca9a8684877ca605d70256",
        "patch": "@@ -0,0 +1,8 @@\n+#! /bin/sh\n+\n+JAVA=java\n+JAVAC=javac\n+\n+$JAVAC -cp miniupnpc_Linux.jar JavaBridgeTest.java\n+$JAVA -cp miniupnpc_Linux.jar:. JavaBridgeTest 12345 UDP\n+"
      },
      {
        "sha": "9d0e23e881031e730d0bff6a381a349a73254595",
        "filename": "miniupnpc/man3/miniupnpc.3",
        "status": "added",
        "additions": 52,
        "deletions": 0,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/man3/miniupnpc.3",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/man3/miniupnpc.3",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/miniupnpc/man3/miniupnpc.3?ref=b94b7b05a7b1d27e28ca9a8684877ca605d70256",
        "patch": "@@ -0,0 +1,52 @@\n+\\\" $Id: miniupnpc.3,v 1.2 2008/10/07 13:51:55 nanard Exp $\n+.TH miniupnpc 3\n+.SH NAME\n+miniupnpc \\- UPnP client library\n+.SH SYNOPSIS\n+.SH DESCRIPTION\n+The miniupnpc library implement the UPnP protocol defined\n+to dialog with Internet Gateway Devices. It also has\n+the ability to use data gathered by minissdpd(1) about\n+UPnP devices up on the network in order to skip the\n+long UPnP device discovery process.\n+.PP\n+At first, upnpDiscover(3) has to be used to discover UPnP IGD present\n+on the network. Then UPNP_GetValidIGD(3) to select the right one.\n+Alternatively, UPNP_GetIGDFromUrl(3) could be used to bypass discovery\n+process if the root description url of the device to use is known.\n+Then all the UPNP_* functions can be used, such as\n+UPNP_GetConnectionTypeInfo(3), UPNP_AddPortMapping(3), etc...\n+.SH \"HEADER FILES\"\n+.IP miniupnpc.h\n+That's the main header file for the miniupnpc library API.\n+It contains all the functions and structures related to device discovery.\n+.IP upnpcommands.h\n+This header file contain the UPnP IGD methods that are accessible\n+through the miniupnpc API. The name of the C functions are matching\n+the UPnP methods names. ie: GetGenericPortMappingEntry is\n+UPNP_GetGenericPortMappingEntry.\n+.SH \"API FUNCTIONS\"\n+.IP \"struct UPNPDev * upnpDiscover(int delay, const char * multicastif, const char * minissdpdsock, int sameport);\"\n+execute the discovery process.\n+delay (in millisecond) is the maximum time for waiting any device response.\n+If available, device list will be obtained from MiniSSDPd.\n+Default path for minissdpd socket will be used if minissdpdsock argument is NULL.\n+If multicastif is not NULL, it will be used instead of the default multicast interface for sending SSDP discover packets.\n+If sameport is not null, SSDP packets will be sent from the source port 1900 (same as destination port) otherwise system assign a source port.\n+.IP \"void freeUPNPDevlist(struct UPNPDev * devlist);\"\n+free the list returned by upnpDiscover().\n+.IP \"int UPNP_GetValidIGD(struct UPNPDev * devlist, struct UPNPUrls * urls, struct IGDdatas * data, char * lanaddr, int lanaddrlen);\"\n+browse the list of device returned by upnpDiscover(), find\n+a live UPnP internet gateway device and fill structures passed as arguments\n+with data used for UPNP methods invokation.\n+.IP \"int UPNP_GetIGDFromUrl(const char * rootdescurl, struct UPNPUrls * urls, struct IGDdatas * data, char * lanaddr, int lanaddrlen);\"\n+permit to bypass the upnpDiscover() call if the xml root description\n+URL of the UPnP IGD is known.\n+Fill structures passed as arguments\n+with data used for UPNP methods invokation.\n+.IP \"void GetUPNPUrls(struct UPNPUrls *, struct IGDdatas *, const char *);\"\n+.IP \"void FreeUPNPUrls(struct UPNPUrls *);\"\n+\n+.SH \"SEE ALSO\"\n+minissdpd(1)\n+.SH BUGS"
      },
      {
        "sha": "c5d3cc4ff5d7d4c1661e530d2d553c4ecfcd2d3a",
        "filename": "miniupnpc/mingw32make.bat",
        "status": "added",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/mingw32make.bat",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/mingw32make.bat",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/miniupnpc/mingw32make.bat?ref=b94b7b05a7b1d27e28ca9a8684877ca605d70256",
        "patch": "@@ -0,0 +1,8 @@\n+@mingw32-make -f Makefile.mingw %1\n+@if errorlevel 1 goto end\n+@if not exist upnpc-static.exe goto end\n+@strip upnpc-static.exe\n+@upx --best upnpc-static.exe\n+@strip upnpc-shared.exe\n+@upx --best upnpc-shared.exe\n+:end"
      },
      {
        "sha": "a834c5e2a0f43a483ba8473eb934371a2c9508a0",
        "filename": "miniupnpc/minisoap.c",
        "status": "added",
        "additions": 120,
        "deletions": 0,
        "changes": 120,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/minisoap.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/minisoap.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/miniupnpc/minisoap.c?ref=b94b7b05a7b1d27e28ca9a8684877ca605d70256",
        "patch": "@@ -0,0 +1,120 @@\n+/* $Id: minisoap.c,v 1.20 2010/12/11 17:56:51 nanard Exp $ */\n+/* Project : miniupnp\n+ * Author : Thomas Bernard\n+ * Copyright (c) 2005-2009 Thomas Bernard\n+ * This software is subject to the conditions detailed in the\n+ * LICENCE file provided in this distribution.\n+ *\n+ * Minimal SOAP implementation for UPnP protocol.\n+ */\n+#include <stdio.h>\n+#include <string.h>\n+#ifdef WIN32\n+#include <io.h>\n+#include <winsock2.h>\n+#define snprintf _snprintf\n+#else\n+#include <unistd.h>\n+#include <sys/types.h>\n+#include <sys/socket.h>\n+#endif\n+#include \"minisoap.h\"\n+#include \"miniupnpcstrings.h\"\n+\n+/* only for malloc */\n+#include <stdlib.h>\n+\n+#ifdef WIN32\n+#define PRINT_SOCKET_ERROR(x)    printf(\"Socket error: %s, %d\\n\", x, WSAGetLastError());\n+#else\n+#define PRINT_SOCKET_ERROR(x) perror(x)\n+#endif\n+\n+/* httpWrite sends the headers and the body to the socket\n+ * and returns the number of bytes sent */\n+static int\n+httpWrite(int fd, const char * body, int bodysize,\n+          const char * headers, int headerssize)\n+{\n+\tint n = 0;\n+\t/*n = write(fd, headers, headerssize);*/\n+\t/*if(bodysize>0)\n+\t\tn += write(fd, body, bodysize);*/\n+\t/* Note : my old linksys router only took into account\n+\t * soap request that are sent into only one packet */\n+\tchar * p;\n+\t/* TODO: AVOID MALLOC */\n+\tp = malloc(headerssize+bodysize);\n+\tif(!p)\n+\t  return 0;\n+\tmemcpy(p, headers, headerssize);\n+\tmemcpy(p+headerssize, body, bodysize);\n+\t/*n = write(fd, p, headerssize+bodysize);*/\n+\tn = send(fd, p, headerssize+bodysize, 0);\n+\tif(n<0) {\n+\t  PRINT_SOCKET_ERROR(\"send\");\n+\t}\n+\t/* disable send on the socket */\n+\t/* draytek routers dont seems to like that... */\n+#if 0\n+#ifdef WIN32\n+\tif(shutdown(fd, SD_SEND)<0) {\n+#else\n+\tif(shutdown(fd, SHUT_WR)<0)\t{ /*SD_SEND*/\n+#endif\n+\t\tPRINT_SOCKET_ERROR(\"shutdown\");\n+\t}\n+#endif\n+\tfree(p);\n+\treturn n;\n+}\n+\n+/* self explanatory  */\n+int soapPostSubmit(int fd,\n+                   const char * url,\n+\t\t\t\t   const char * host,\n+\t\t\t\t   unsigned short port,\n+\t\t\t\t   const char * action,\n+\t\t\t\t   const char * body,\n+\t\t\t\t   const char * httpversion)\n+{\n+\tint bodysize;\n+\tchar headerbuf[512];\n+\tint headerssize;\n+\tchar portstr[8];\n+\tbodysize = (int)strlen(body);\n+\t/* We are not using keep-alive HTTP connections.\n+\t * HTTP/1.1 needs the header Connection: close to do that.\n+\t * This is the default with HTTP/1.0\n+\t * Using HTTP/1.1 means we need to support chunked transfer-encoding :\n+\t * When using HTTP/1.1, the router \"BiPAC 7404VNOX\" always use chunked\n+\t * transfer encoding. */\n+    /* Connection: Close is normally there only in HTTP/1.1 but who knows */\n+\tportstr[0] = '\\0';\n+\tif(port != 80)\n+\t\tsnprintf(portstr, sizeof(portstr), \":%hu\", port);\n+\theaderssize = snprintf(headerbuf, sizeof(headerbuf),\n+                       \"POST %s HTTP/%s\\r\\n\"\n+\t                   \"Host: %s%s\\r\\n\"\n+\t\t\t\t\t   \"User-Agent: \" OS_STRING \", UPnP/1.0, MiniUPnPc/\" MINIUPNPC_VERSION_STRING \"\\r\\n\"\n+\t                   \"Content-Length: %d\\r\\n\"\n+\t\t\t\t\t   \"Content-Type: text/xml\\r\\n\"\n+\t\t\t\t\t   \"SOAPAction: \\\"%s\\\"\\r\\n\"\n+\t\t\t\t\t   \"Connection: Close\\r\\n\"\n+\t\t\t\t\t   \"Cache-Control: no-cache\\r\\n\"\t/* ??? */\n+\t\t\t\t\t   \"Pragma: no-cache\\r\\n\"\n+\t\t\t\t\t   \"\\r\\n\",\n+\t\t\t\t\t   url, httpversion, host, portstr, bodysize, action);\n+#ifdef DEBUG\n+\t/*printf(\"SOAP request : headersize=%d bodysize=%d\\n\",\n+\t       headerssize, bodysize);\n+\t*/\n+\tprintf(\"SOAP request : POST %s HTTP/%s - Host: %s%s\\n\",\n+\t        url, httpversion, host, portstr);\n+\tprintf(\"SOAPAction: \\\"%s\\\" - Content-Length: %d\\n\", action, bodysize);\n+\t/*printf(\"%s\", headerbuf);*/\n+#endif\n+\treturn httpWrite(fd, body, bodysize, headerbuf, headerssize);\n+}\n+\n+"
      },
      {
        "sha": "696725f625ea7e4ed7e04281875977b352d054b6",
        "filename": "miniupnpc/minisoap.h",
        "status": "added",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/minisoap.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/minisoap.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/miniupnpc/minisoap.h?ref=b94b7b05a7b1d27e28ca9a8684877ca605d70256",
        "patch": "@@ -0,0 +1,15 @@\n+/* $Id: minisoap.h,v 1.4 2010/04/12 20:39:41 nanard Exp $ */\n+/* Project : miniupnp\n+ * Author : Thomas Bernard\n+ * Copyright (c) 2005 Thomas Bernard\n+ * This software is subject to the conditions detailed in the\n+ * LICENCE file provided in this distribution. */\n+#ifndef __MINISOAP_H__\n+#define __MINISOAP_H__\n+\n+/*int httpWrite(int, const char *, int, const char *);*/\n+int soapPostSubmit(int, const char *, const char *, unsigned short,\n+\t\t   const char *, const char *, const char *);\n+\n+#endif\n+"
      },
      {
        "sha": "e5e852855ccf8003ffaf06ae07bf98cccf64f583",
        "filename": "miniupnpc/minissdpc.c",
        "status": "added",
        "additions": 132,
        "deletions": 0,
        "changes": 132,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/minissdpc.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/minissdpc.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/miniupnpc/minissdpc.c?ref=b94b7b05a7b1d27e28ca9a8684877ca605d70256",
        "patch": "@@ -0,0 +1,132 @@\n+/* $Id: minissdpc.c,v 1.14 2010/11/25 09:57:25 nanard Exp $ */\n+/* Project : miniupnp\n+ * Author : Thomas BERNARD\n+ * copyright (c) 2005-2009 Thomas Bernard\n+ * This software is subjet to the conditions detailed in the\n+ * provided LICENCE file. */\n+/*#include <syslog.h>*/\n+#include <stdio.h>\n+#include <string.h>\n+#include <stdlib.h>\n+#include <unistd.h>\n+#include <sys/types.h>\n+#if defined(WIN32) || defined(__amigaos__) || defined(__amigaos4__)\n+#ifdef WIN32\n+#include <winsock2.h>\n+#include <ws2tcpip.h>\n+#include <io.h>\n+#include <winsock.h>\n+#include <stdint.h>\n+#endif\n+#if defined(__amigaos__) || defined(__amigaos4__)\n+#include <sys/socket.h>\n+#endif\n+#if defined(__amigaos__)\n+#define uint16_t unsigned short\n+#endif\n+/* Hack */\n+#define UNIX_PATH_LEN   108\n+struct sockaddr_un {\n+  uint16_t sun_family;\n+  char     sun_path[UNIX_PATH_LEN];\n+};\n+#else\n+#include <sys/socket.h>\n+#include <sys/un.h>\n+#endif\n+\n+#include \"minissdpc.h\"\n+#include \"miniupnpc.h\"\n+\n+#include \"codelength.h\"\n+\n+struct UPNPDev *\n+getDevicesFromMiniSSDPD(const char * devtype, const char * socketpath)\n+{\n+\tstruct UPNPDev * tmp;\n+\tstruct UPNPDev * devlist = NULL;\n+\tunsigned char buffer[2048];\n+\tssize_t n;\n+\tunsigned char * p;\n+\tunsigned char * url;\n+\tunsigned int i;\n+\tunsigned int urlsize, stsize, usnsize, l;\n+\tint s;\n+\tstruct sockaddr_un addr;\n+\n+\ts = socket(AF_UNIX, SOCK_STREAM, 0);\n+\tif(s < 0)\n+\t{\n+\t\t/*syslog(LOG_ERR, \"socket(unix): %m\");*/\n+\t\tperror(\"socket(unix)\");\n+\t\treturn NULL;\n+\t}\n+\taddr.sun_family = AF_UNIX;\n+\tstrncpy(addr.sun_path, socketpath, sizeof(addr.sun_path));\n+\t/* TODO : check if we need to handle the EINTR */\n+\tif(connect(s, (struct sockaddr *)&addr, sizeof(struct sockaddr_un)) < 0)\n+\t{\n+\t\t/*syslog(LOG_WARNING, \"connect(\\\"%s\\\"): %m\", socketpath);*/\n+\t\tclose(s);\n+\t\treturn NULL;\n+\t}\n+\tstsize = strlen(devtype);\n+\tbuffer[0] = 1; /* request type 1 : request devices/services by type */\n+\tp = buffer + 1;\n+\tl = stsize;\tCODELENGTH(l, p);\n+\tif(p + stsize > buffer + sizeof(buffer))\n+\t{\n+\t\t/* devtype is too long ! */\n+\t\tclose(s);\n+\t\treturn NULL;\n+\t}\n+\tmemcpy(p, devtype, stsize);\n+\tp += stsize;\n+\tif(write(s, buffer, p - buffer) < 0)\n+\t{\n+\t\t/*syslog(LOG_ERR, \"write(): %m\");*/\n+\t\tperror(\"minissdpc.c: write()\");\n+\t\tclose(s);\n+\t\treturn NULL;\n+\t}\n+\tn = read(s, buffer, sizeof(buffer));\n+\tif(n<=0)\n+\t{\n+\t\tperror(\"minissdpc.c: read()\");\n+\t\tclose(s);\n+\t\treturn NULL;\n+\t}\n+\tp = buffer + 1;\n+\tfor(i = 0; i < buffer[0]; i++)\n+\t{\n+\t\tif(p+2>=buffer+sizeof(buffer))\n+\t\t\tbreak;\n+\t\tDECODELENGTH(urlsize, p);\n+\t\tif(p+urlsize+2>=buffer+sizeof(buffer))\n+\t\t\tbreak;\n+\t\turl = p;\n+\t\tp += urlsize;\n+\t\tDECODELENGTH(stsize, p);\n+\t\tif(p+stsize+2>=buffer+sizeof(buffer))\n+\t\t\tbreak;\n+\t\ttmp = (struct UPNPDev *)malloc(sizeof(struct UPNPDev)+urlsize+stsize);\n+\t\ttmp->pNext = devlist;\n+\t\ttmp->descURL = tmp->buffer;\n+\t\ttmp->st = tmp->buffer + 1 + urlsize;\n+\t\tmemcpy(tmp->buffer, url, urlsize);\n+\t\ttmp->buffer[urlsize] = '\\0';\n+\t\tmemcpy(tmp->buffer + urlsize + 1, p, stsize);\n+\t\tp += stsize;\n+\t\ttmp->buffer[urlsize+1+stsize] = '\\0';\n+\t\tdevlist = tmp;\n+\t\t/* added for compatibility with recent versions of MiniSSDPd \n+\t\t * >= 2007/12/19 */\n+\t\tDECODELENGTH(usnsize, p);\n+\t\tp += usnsize;\n+\t\tif(p>buffer + sizeof(buffer))\n+\t\t\tbreak;\n+\t}\n+\tclose(s);\n+\treturn devlist;\n+}\n+"
      },
      {
        "sha": "25e91ce3198886635e4c7fe23776d63da8bbb0f8",
        "filename": "miniupnpc/minissdpc.h",
        "status": "added",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/minissdpc.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/minissdpc.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/miniupnpc/minissdpc.h?ref=b94b7b05a7b1d27e28ca9a8684877ca605d70256",
        "patch": "@@ -0,0 +1,15 @@\n+/* $Id: minissdpc.h,v 1.1 2007/08/31 15:15:33 nanard Exp $ */\n+/* Project: miniupnp\n+ * http://miniupnp.free.fr/ or http://miniupnp.tuxfamily.org/\n+ * Author: Thomas Bernard\n+ * Copyright (c) 2005-2007 Thomas Bernard\n+ * This software is subjects to the conditions detailed\n+ * in the LICENCE file provided within this distribution */\n+#ifndef __MINISSDPC_H__\n+#define __MINISSDPC_H__\n+\n+struct UPNPDev *\n+getDevicesFromMiniSSDPD(const char * devtype, const char * socketpath);\n+\n+#endif\n+"
      },
      {
        "sha": "d91591c2cec80ad24f13d17137b1d8e43a1c00d7",
        "filename": "miniupnpc/miniupnpc.c",
        "status": "added",
        "additions": 969,
        "deletions": 0,
        "changes": 969,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/miniupnpc.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/miniupnpc.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/miniupnpc/miniupnpc.c?ref=b94b7b05a7b1d27e28ca9a8684877ca605d70256",
        "patch": "@@ -0,0 +1,969 @@\n+/* $Id: miniupnpc.c,v 1.85 2010/12/21 16:13:14 nanard Exp $ */\n+/* Project : miniupnp\n+ * Author : Thomas BERNARD\n+ * copyright (c) 2005-2010 Thomas Bernard\n+ * This software is subjet to the conditions detailed in the\n+ * provided LICENSE file. */\n+#define __EXTENSIONS__ 1\n+#if !defined(MACOSX) && !defined(__sun)\n+#if !defined(_XOPEN_SOURCE) && !defined(__OpenBSD__) && !defined(__NetBSD__)\n+#ifndef __cplusplus\n+#define _XOPEN_SOURCE 600\n+#endif\n+#endif\n+#ifndef __BSD_VISIBLE\n+#define __BSD_VISIBLE 1\n+#endif\n+#endif\n+\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <string.h>\n+#ifdef WIN32\n+/* Win32 Specific includes and defines */\n+#include <winsock2.h>\n+#include <ws2tcpip.h>\n+#include <io.h>\n+#include <iphlpapi.h>\n+#define snprintf _snprintf\n+#if defined(_MSC_VER) && (_MSC_VER >= 1400)\n+#define strncasecmp _memicmp\n+#else /* defined(_MSC_VER) && (_MSC_VER >= 1400) */\n+#define strncasecmp memicmp\n+#endif /* defined(_MSC_VER) && (_MSC_VER >= 1400) */\n+#define MAXHOSTNAMELEN 64\n+#else /* #ifdef WIN32 */\n+/* Standard POSIX includes */\n+#include <unistd.h>\n+#if defined(__amigaos__) && !defined(__amigaos4__)\n+/* Amiga OS 3 specific stuff */\n+#define socklen_t int\n+#else\n+#include <sys/select.h>\n+#endif\n+#include <sys/socket.h>\n+#include <sys/types.h>\n+#include <sys/param.h>\n+#include <netinet/in.h>\n+#include <arpa/inet.h>\n+#include <netdb.h>\n+#if !defined(__amigaos__) && !defined(__amigaos4__)\n+#include <poll.h>\n+#endif\n+#include <strings.h>\n+#include <errno.h>\n+#define closesocket close\n+#define MINIUPNPC_IGNORE_EINTR\n+#endif /* #else WIN32 */\n+#ifdef MINIUPNPC_SET_SOCKET_TIMEOUT\n+#include <sys/time.h>\n+#endif\n+#if defined(__amigaos__) || defined(__amigaos4__)\n+/* Amiga OS specific stuff */\n+#define TIMEVAL struct timeval\n+#endif\n+\n+#include \"miniupnpc.h\"\n+#include \"minissdpc.h\"\n+#include \"miniwget.h\"\n+#include \"minisoap.h\"\n+#include \"minixml.h\"\n+#include \"upnpcommands.h\"\n+#include \"connecthostport.h\"\n+\n+#ifdef WIN32\n+#define PRINT_SOCKET_ERROR(x)    printf(\"Socket error: %s, %d\\n\", x, WSAGetLastError());\n+#else\n+#define PRINT_SOCKET_ERROR(x) perror(x)\n+#endif\n+\n+#define SOAPPREFIX \"s\"\n+#define SERVICEPREFIX \"u\"\n+#define SERVICEPREFIX2 'u'\n+\n+/* root description parsing */\n+LIBSPEC void parserootdesc(const char * buffer, int bufsize, struct IGDdatas * data)\n+{\n+\tstruct xmlparser parser;\n+\t/* xmlparser object */\n+\tparser.xmlstart = buffer;\n+\tparser.xmlsize = bufsize;\n+\tparser.data = data;\n+\tparser.starteltfunc = IGDstartelt;\n+\tparser.endeltfunc = IGDendelt;\n+\tparser.datafunc = IGDdata;\n+\tparser.attfunc = 0;\n+\tparsexml(&parser);\n+#ifdef DEBUG\n+\tprintIGD(data);\n+#endif\n+}\n+\n+#if 0\n+/* getcontentlenfromline() : parse the Content-Length HTTP header line.\n+ * Content-length: nnn */\n+static int getcontentlenfromline(const char * p, int n)\n+{\n+\tstatic const char contlenstr[] = \"content-length\";\n+\tconst char * p2 = contlenstr;\n+\tint a = 0;\n+\twhile(*p2)\n+\t{\n+\t\tif(n==0)\n+\t\t\treturn -1;\n+\t\tif(*p2 != *p && *p2 != (*p + 32))\n+\t\t\treturn -1;\n+\t\tp++; p2++; n--;\n+\t}\n+\tif(n==0)\n+\t\treturn -1;\n+\tif(*p != ':')\n+\t\treturn -1;\n+\tp++; n--;\n+\twhile(*p == ' ')\n+\t{\n+\t\tif(n==0)\n+\t\t\treturn -1;\n+\t\tp++; n--;\n+\t}\n+\twhile(*p >= '0' && *p <= '9')\n+\t{\n+\t\tif(n==0)\n+\t\t\treturn -1;\n+\t\ta = (a * 10) + (*p - '0');\n+\t\tp++; n--;\n+\t}\n+\treturn a;\n+}\n+\n+/* getContentLengthAndHeaderLength()\n+ * retrieve header length and content length from an HTTP response\n+ * TODO : retrieve Transfer-Encoding: header value, in order to support\n+ *        HTTP/1.1, chunked transfer encoding must be supported. */\n+static void\n+getContentLengthAndHeaderLength(char * p, int n,\n+                                int * contentlen, int * headerlen)\n+{\n+\tchar * line;\n+\tint linelen;\n+\tint r;\n+\tline = p;\n+\twhile(line < p + n)\n+\t{\n+\t\tlinelen = 0;\n+\t\twhile(line[linelen] != '\\r' && line[linelen] != '\\r')\n+\t\t{\n+\t\t\tif(line+linelen >= p+n)\n+\t\t\t\treturn;\n+\t\t\tlinelen++;\n+\t\t}\n+\t\tr = getcontentlenfromline(line, linelen);\n+\t\tif(r>0)\n+\t\t\t*contentlen = r;\n+\t\tline = line + linelen + 2;\n+\t\tif(line[0] == '\\r' && line[1] == '\\n')\n+\t\t{\n+\t\t\t*headerlen = (line - p) + 2;\n+\t\t\treturn;\n+\t\t}\n+\t}\n+}\n+#endif\n+\n+/* simpleUPnPcommand2 :\n+ * not so simple !\n+ * return values :\n+ *   0 - OK\n+ *  -1 - error */\n+static int simpleUPnPcommand2(int s, const char * url, const char * service,\n+\t\t       const char * action, struct UPNParg * args,\n+\t\t       char * buffer, int * bufsize, const char * httpversion)\n+{\n+\tchar hostname[MAXHOSTNAMELEN+1];\n+\tunsigned short port = 0;\n+\tchar * path;\n+\tchar soapact[128];\n+\tchar soapbody[2048];\n+\tchar * buf;\n+\t/*int buffree;*/\n+    int n;\n+\t/*int contentlen, headerlen;*/\t/* for the response */\n+\n+\tsnprintf(soapact, sizeof(soapact), \"%s#%s\", service, action);\n+\tif(args==NULL)\n+\t{\n+\t\t/*soapbodylen = */snprintf(soapbody, sizeof(soapbody),\n+\t\t\t\t\t\t\"<?xml version=\\\"1.0\\\"?>\\r\\n\"\n+\t    \t              \"<\" SOAPPREFIX \":Envelope \"\n+\t\t\t\t\t\t  \"xmlns:\" SOAPPREFIX \"=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\" \"\n+\t\t\t\t\t\t  SOAPPREFIX \":encodingStyle=\\\"http://schemas.xmlsoap.org/soap/encoding/\\\">\"\n+\t\t\t\t\t\t  \"<\" SOAPPREFIX \":Body>\"\n+\t\t\t\t\t\t  \"<\" SERVICEPREFIX \":%s xmlns:\" SERVICEPREFIX \"=\\\"%s\\\">\"\n+\t\t\t\t\t\t  \"</\" SERVICEPREFIX \":%s>\"\n+\t\t\t\t\t\t  \"</\" SOAPPREFIX \":Body></\" SOAPPREFIX \":Envelope>\"\n+\t\t\t\t\t \t  \"\\r\\n\", action, service, action);\n+\t}\n+\telse\n+\t{\n+\t\tchar * p;\n+\t\tconst char * pe, * pv;\n+\t\tint soapbodylen;\n+\t\tsoapbodylen = snprintf(soapbody, sizeof(soapbody),\n+\t\t\t\t\t\t\"<?xml version=\\\"1.0\\\"?>\\r\\n\"\n+\t    \t            \"<\" SOAPPREFIX \":Envelope \"\n+\t\t\t\t\t\t\"xmlns:\" SOAPPREFIX \"=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\" \"\n+\t\t\t\t\t\tSOAPPREFIX \":encodingStyle=\\\"http://schemas.xmlsoap.org/soap/encoding/\\\">\"\n+\t\t\t\t\t\t\"<\" SOAPPREFIX \":Body>\"\n+\t\t\t\t\t\t\"<\" SERVICEPREFIX \":%s xmlns:\" SERVICEPREFIX \"=\\\"%s\\\">\",\n+\t\t\t\t\t\taction, service);\n+\t\tp = soapbody + soapbodylen;\n+\t\twhile(args->elt)\n+\t\t{\n+\t\t\t/* check that we are never overflowing the string... */\n+\t\t\tif(soapbody + sizeof(soapbody) <= p + 100)\n+\t\t\t{\n+\t\t\t\t/* we keep a margin of at least 100 bytes */\n+\t\t\t\t*bufsize = 0;\n+\t\t\t\treturn -1;\n+\t\t\t}\n+\t\t\t*(p++) = '<';\n+\t\t\tpe = args->elt;\n+\t\t\twhile(*pe)\n+\t\t\t\t*(p++) = *(pe++);\n+\t\t\t*(p++) = '>';\n+\t\t\tif((pv = args->val))\n+\t\t\t{\n+\t\t\t\twhile(*pv)\n+\t\t\t\t\t*(p++) = *(pv++);\n+\t\t\t}\n+\t\t\t*(p++) = '<';\n+\t\t\t*(p++) = '/';\n+\t\t\tpe = args->elt;\n+\t\t\twhile(*pe)\n+\t\t\t\t*(p++) = *(pe++);\n+\t\t\t*(p++) = '>';\n+\t\t\targs++;\n+\t\t}\n+\t\t*(p++) = '<';\n+\t\t*(p++) = '/';\n+\t\t*(p++) = SERVICEPREFIX2;\n+\t\t*(p++) = ':';\n+\t\tpe = action;\n+\t\twhile(*pe)\n+\t\t\t*(p++) = *(pe++);\n+\t\tstrncpy(p, \"></\" SOAPPREFIX \":Body></\" SOAPPREFIX \":Envelope>\\r\\n\",\n+\t\t        soapbody + sizeof(soapbody) - p);\n+\t}\n+\tif(!parseURL(url, hostname, &port, &path)) return -1;\n+\tif(s<0)\n+\t{\n+\t\ts = connecthostport(hostname, port);\n+\t\tif(s < 0)\n+\t\t{\n+\t\t\t*bufsize = 0;\n+\t\t\treturn -1;\n+\t\t}\n+\t}\n+\n+\tn = soapPostSubmit(s, path, hostname, port, soapact, soapbody, httpversion);\n+\tif(n<=0) {\n+#ifdef DEBUG\n+\t\tprintf(\"Error sending SOAP request\\n\");\n+#endif\n+\t\tclosesocket(s);\n+\t\treturn -1;\n+\t}\n+\n+#if 0\n+\tcontentlen = -1;\n+\theaderlen = -1;\n+\tbuf = buffer;\n+\tbuffree = *bufsize;\n+\t*bufsize = 0;\n+\twhile ((n = ReceiveData(s, buf, buffree, 5000)) > 0) {\n+\t\tbuffree -= n;\n+\t\tbuf += n;\n+\t\t*bufsize += n;\n+\t\tgetContentLengthAndHeaderLength(buffer, *bufsize,\n+\t\t                                &contentlen, &headerlen);\n+#ifdef DEBUG\n+\t\tprintf(\"received n=%dbytes bufsize=%d ContLen=%d HeadLen=%d\\n\",\n+\t\t       n, *bufsize, contentlen, headerlen);\n+#endif\n+\t\t/* break if we received everything */\n+\t\tif(contentlen > 0 && headerlen > 0 && *bufsize >= contentlen+headerlen)\n+\t\t\tbreak;\n+\t}\n+#endif\n+\tbuf = getHTTPResponse(s, &n);\n+\tif(n > 0 && buf)\n+\t{\n+#ifdef DEBUG\n+\t\tprintf(\"SOAP Response :\\n%.*s\\n\", n, buf);\n+#endif\n+\t\tif(*bufsize > n)\n+\t\t{\n+\t\t\tmemcpy(buffer, buf, n);\n+\t\t\t*bufsize = n;\n+\t\t}\n+\t\telse\n+\t\t{\n+\t\t\tmemcpy(buffer, buf, *bufsize);\n+\t\t}\n+\t\tfree(buf);\n+\t\tbuf = 0;\n+\t}\n+\tclosesocket(s);\n+\treturn 0;\n+}\n+\n+/* simpleUPnPcommand :\n+ * not so simple !\n+ * return values :\n+ *   0 - OK\n+ *  -1 - error */\n+int simpleUPnPcommand(int s, const char * url, const char * service,\n+\t\t       const char * action, struct UPNParg * args,\n+\t\t       char * buffer, int * bufsize)\n+{\n+\tint result;\n+\t/*int origbufsize = *bufsize;*/\n+\n+\tresult = simpleUPnPcommand2(s, url, service, action, args, buffer, bufsize, \"1.1\");\n+/*\n+\tresult = simpleUPnPcommand2(s, url, service, action, args, buffer, bufsize, \"1.0\");\n+\tif (result < 0 || *bufsize == 0)\n+\t{\n+#if DEBUG\n+\t    printf(\"Error or no result from SOAP request; retrying with HTTP/1.1\\n\");\n+#endif\n+\t\t*bufsize = origbufsize;\n+\t\tresult = simpleUPnPcommand2(s, url, service, action, args, buffer, bufsize, \"1.1\");\n+\t}\n+*/\n+\treturn result;\n+}\n+\n+/* parseMSEARCHReply()\n+ * the last 4 arguments are filled during the parsing :\n+ *    - location/locationsize : \"location:\" field of the SSDP reply packet\n+ *    - st/stsize : \"st:\" field of the SSDP reply packet.\n+ * The strings are NOT null terminated */\n+static void\n+parseMSEARCHReply(const char * reply, int size,\n+                  const char * * location, int * locationsize,\n+\t\t\t      const char * * st, int * stsize)\n+{\n+\tint a, b, i;\n+\ti = 0;\n+\ta = i;\t/* start of the line */\n+\tb = 0;\n+\twhile(i<size)\n+\t{\n+\t\tswitch(reply[i])\n+\t\t{\n+\t\tcase ':':\n+\t\t\t\tif(b==0)\n+\t\t\t\t{\n+\t\t\t\t\tb = i; /* end of the \"header\" */\n+\t\t\t\t\t/*for(j=a; j<b; j++)\n+\t\t\t\t\t{\n+\t\t\t\t\t\tputchar(reply[j]);\n+\t\t\t\t\t}\n+\t\t\t\t\t*/\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\t\tcase '\\x0a':\n+\t\tcase '\\x0d':\n+\t\t\t\tif(b!=0)\n+\t\t\t\t{\n+\t\t\t\t\t/*for(j=b+1; j<i; j++)\n+\t\t\t\t\t{\n+\t\t\t\t\t\tputchar(reply[j]);\n+\t\t\t\t\t}\n+\t\t\t\t\tputchar('\\n');*/\n+\t\t\t\t\tdo { b++; } while(reply[b]==' ');\n+\t\t\t\t\tif(0==strncasecmp(reply+a, \"location\", 8))\n+\t\t\t\t\t{\n+\t\t\t\t\t\t*location = reply+b;\n+\t\t\t\t\t\t*locationsize = i-b;\n+\t\t\t\t\t}\n+\t\t\t\t\telse if(0==strncasecmp(reply+a, \"st\", 2))\n+\t\t\t\t\t{\n+\t\t\t\t\t\t*st = reply+b;\n+\t\t\t\t\t\t*stsize = i-b;\n+\t\t\t\t\t}\n+\t\t\t\t\tb = 0;\n+\t\t\t\t}\n+\t\t\t\ta = i+1;\n+\t\t\t\tbreak;\n+\t\tdefault:\n+\t\t\t\tbreak;\n+\t\t}\n+\t\ti++;\n+\t}\n+}\n+\n+/* port upnp discover : SSDP protocol */\n+#define PORT 1900\n+#define XSTR(s) STR(s)\n+#define STR(s) #s\n+#define UPNP_MCAST_ADDR \"239.255.255.250\"\n+\n+/* upnpDiscover() :\n+ * return a chained list of all devices found or NULL if\n+ * no devices was found.\n+ * It is up to the caller to free the chained list\n+ * delay is in millisecond (poll) */\n+LIBSPEC struct UPNPDev * upnpDiscover(int delay, const char * multicastif,\n+                              const char * minissdpdsock, int sameport)\n+{\n+\tstruct UPNPDev * tmp;\n+\tstruct UPNPDev * devlist = 0;\n+\tint opt = 1;\n+\tstatic const char MSearchMsgFmt[] = \n+\t\"M-SEARCH * HTTP/1.1\\r\\n\"\n+\t\"HOST: \" UPNP_MCAST_ADDR \":\" XSTR(PORT) \"\\r\\n\"\n+\t\"ST: %s\\r\\n\"\n+\t\"MAN: \\\"ssdp:discover\\\"\\r\\n\"\n+\t\"MX: %u\\r\\n\"\n+\t\"\\r\\n\";\n+\tstatic const char * const deviceList[] = {\n+\t\t\"urn:schemas-upnp-org:device:InternetGatewayDevice:1\",\n+\t\t\"urn:schemas-upnp-org:service:WANIPConnection:1\",\n+\t\t\"urn:schemas-upnp-org:service:WANPPPConnection:1\",\n+\t\t\"upnp:rootdevice\",\n+\t\t0\n+\t};\n+\tint deviceIndex = 0;\n+\tchar bufr[1536];\t/* reception and emission buffer */\n+\tint sudp;\n+\tint n;\n+\tstruct sockaddr sockudp_r;\n+\tunsigned int mx;\n+#ifdef NO_GETADDRINFO\n+\tstruct sockaddr_in sockudp_w;\n+#else\n+\tint rv;\n+\tstruct addrinfo hints, *servinfo, *p;\n+#endif\n+#ifdef WIN32\n+\tMIB_IPFORWARDROW ip_forward;\n+#endif\n+\n+#if !defined(WIN32) && !defined(__amigaos__) && !defined(__amigaos4__)\n+\t/* first try to get infos from minissdpd ! */\n+\tif(!minissdpdsock)\n+\t\tminissdpdsock = \"/var/run/minissdpd.sock\";\n+\twhile(!devlist && deviceList[deviceIndex]) {\n+\t\tdevlist = getDevicesFromMiniSSDPD(deviceList[deviceIndex],\n+\t\t                                  minissdpdsock);\n+\t\t/* We return what we have found if it was not only a rootdevice */\n+\t\tif(devlist && !strstr(deviceList[deviceIndex], \"rootdevice\"))\n+\t\t\treturn devlist;\n+\t\tdeviceIndex++;\n+\t}\n+\tdeviceIndex = 0;\n+#endif\n+\t/* fallback to direct discovery */\n+#ifdef WIN32\n+\tsudp = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP);\n+#else\n+\tsudp = socket(PF_INET, SOCK_DGRAM, 0);\n+#endif\n+\tif(sudp < 0)\n+\t{\n+\t\tPRINT_SOCKET_ERROR(\"socket\");\n+\t\treturn NULL;\n+\t}\n+\t/* reception */\n+\tmemset(&sockudp_r, 0, sizeof(struct sockaddr));\n+\tif(0/*ipv6*/) {\n+\t\tstruct sockaddr_in6 * p = (struct sockaddr_in6 *)&sockudp_r;\n+\t\tp->sin6_family = AF_INET6;\n+\t\tif(sameport)\n+\t\t\tp->sin6_port = htons(PORT);\n+\t\tp->sin6_addr = in6addr_any;//IN6ADDR_ANY_INIT;/*INADDR_ANY;*/\n+\t} else {\n+\t\tstruct sockaddr_in * p = (struct sockaddr_in *)&sockudp_r;\n+\t\tp->sin_family = AF_INET;\n+\t\tif(sameport)\n+\t\t\tp->sin_port = htons(PORT);\n+\t\tp->sin_addr.s_addr = INADDR_ANY;\n+\t}\n+#ifdef WIN32\n+/* This code could help us to use the right Network interface for \n+ * SSDP multicast traffic */\n+/* Get IP associated with the index given in the ip_forward struct\n+ * in order to give this ip to setsockopt(sudp, IPPROTO_IP, IP_MULTICAST_IF) */\n+\tif(GetBestRoute(inet_addr(\"223.255.255.255\"), 0, &ip_forward) == NO_ERROR) {\n+\t\tDWORD dwRetVal = 0;\n+\t\tPMIB_IPADDRTABLE pIPAddrTable;\n+\t\tDWORD dwSize = 0;\n+#ifdef DEBUG\n+\t\tIN_ADDR IPAddr;\n+#endif\n+\t\tint i;\n+#ifdef DEBUG\n+\t\tprintf(\"ifIndex=%lu nextHop=%lx \\n\", ip_forward.dwForwardIfIndex, ip_forward.dwForwardNextHop);\n+#endif\n+\t\tpIPAddrTable = (MIB_IPADDRTABLE *) malloc(sizeof (MIB_IPADDRTABLE));\n+\t\tif (GetIpAddrTable(pIPAddrTable, &dwSize, 0) == ERROR_INSUFFICIENT_BUFFER) {\n+\t\t\tfree(pIPAddrTable);\n+\t\t\tpIPAddrTable = (MIB_IPADDRTABLE *) malloc(dwSize);\n+\t\t}\n+\t\tif(pIPAddrTable) {\n+\t\t\tdwRetVal = GetIpAddrTable( pIPAddrTable, &dwSize, 0 );\n+#ifdef DEBUG\n+\t\t\tprintf(\"\\tNum Entries: %ld\\n\", pIPAddrTable->dwNumEntries);\n+#endif\n+\t\t\tfor (i=0; i < (int) pIPAddrTable->dwNumEntries; i++) {\n+#ifdef DEBUG\n+\t\t\t\tprintf(\"\\n\\tInterface Index[%d]:\\t%ld\\n\", i, pIPAddrTable->table[i].dwIndex);\n+\t\t\t\tIPAddr.S_un.S_addr = (u_long) pIPAddrTable->table[i].dwAddr;\n+\t\t\t\tprintf(\"\\tIP Address[%d]:     \\t%s\\n\", i, inet_ntoa(IPAddr) );\n+\t\t\t\tIPAddr.S_un.S_addr = (u_long) pIPAddrTable->table[i].dwMask;\n+\t\t\t\tprintf(\"\\tSubnet Mask[%d]:    \\t%s\\n\", i, inet_ntoa(IPAddr) );\n+\t\t\t\tIPAddr.S_un.S_addr = (u_long) pIPAddrTable->table[i].dwBCastAddr;\n+\t\t\t\tprintf(\"\\tBroadCast[%d]:      \\t%s (%ld)\\n\", i, inet_ntoa(IPAddr), pIPAddrTable->table[i].dwBCastAddr);\n+\t\t\t\tprintf(\"\\tReassembly size[%d]:\\t%ld\\n\", i, pIPAddrTable->table[i].dwReasmSize);\n+\t\t\t\tprintf(\"\\tType and State[%d]:\", i);\n+\t\t\t\tprintf(\"\\n\");\n+#endif\n+\t\t\t\tif (pIPAddrTable->table[i].dwIndex == ip_forward.dwForwardIfIndex) {\n+\t\t\t\t\t/* Set the address of this interface to be used */\n+\t\t\t\t\tstruct in_addr mc_if;\n+\t\t\t\t\tmemset(&mc_if, 0, sizeof(mc_if));\n+\t\t\t\t\tmc_if.s_addr = pIPAddrTable->table[i].dwAddr;\n+\t\t\t\t\tif(setsockopt(sudp, IPPROTO_IP, IP_MULTICAST_IF, (const char *)&mc_if, sizeof(mc_if)) < 0) {\n+\t\t\t\t\t\tPRINT_SOCKET_ERROR(\"setsockopt\");\n+\t\t\t\t\t}\n+\t\t\t\t\t((struct sockaddr_in *)&sockudp_r)->sin_addr.s_addr = pIPAddrTable->table[i].dwAddr;\n+#ifndef DEBUG\n+\t\t\t\t\tbreak;\n+#endif\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tfree(pIPAddrTable);\n+\t\t\tpIPAddrTable = NULL;\n+\t\t}\n+\t}\n+#endif\n+\n+#ifdef WIN32\n+\tif (setsockopt(sudp, SOL_SOCKET, SO_REUSEADDR, (const char *)&opt, sizeof (opt)) < 0)\n+#else\n+\tif (setsockopt(sudp, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof (opt)) < 0)\n+#endif\n+\t{\n+\t\tPRINT_SOCKET_ERROR(\"setsockopt\");\n+\t\treturn NULL;\n+\t}\n+\n+\tif(multicastif)\n+\t{\n+\t\tstruct in_addr mc_if;\n+\t\tmc_if.s_addr = inet_addr(multicastif);\n+\t\tif(0/*ipv6*/) {\n+\t\t} else {\n+\t\t\t((struct sockaddr_in *)&sockudp_r)->sin_addr.s_addr = mc_if.s_addr;\n+\t\t}\n+\t\tif(setsockopt(sudp, IPPROTO_IP, IP_MULTICAST_IF, (const char *)&mc_if, sizeof(mc_if)) < 0)\n+\t\t{\n+\t\t\tPRINT_SOCKET_ERROR(\"setsockopt\");\n+\t\t}\n+\t}\n+\n+\t/* Avant d'envoyer le paquet on bind pour recevoir la reponse */\n+    if (bind(sudp, &sockudp_r, 0/*ipv6*/?sizeof(struct sockaddr_in6):sizeof(struct sockaddr_in)) != 0)\n+\t{\n+        PRINT_SOCKET_ERROR(\"bind\");\n+\t\tclosesocket(sudp);\n+\t\treturn NULL;\n+    }\n+\n+\t/* Calculating maximum response time in seconds */\n+\tmx = ((unsigned int)delay) / 1000u;\n+\t/* receiving SSDP response packet */\n+\tfor(n = 0;;)\n+\t{\n+\tif(n == 0)\n+\t{\n+\t\t/* sending the SSDP M-SEARCH packet */\n+\t\tn = snprintf(bufr, sizeof(bufr),\n+\t\t             MSearchMsgFmt, deviceList[deviceIndex++], mx);\n+\t\t/*printf(\"Sending %s\", bufr);*/\n+#ifdef NO_GETADDRINFO\n+\t\t/* the following code is not using getaddrinfo */\n+\t\t/* emission */\n+\t\tmemset(&sockudp_w, 0, sizeof(struct sockaddr_in));\n+\t\tsockudp_w.sin_family = AF_INET;\n+\t\tsockudp_w.sin_port = htons(PORT);\n+\t\tsockudp_w.sin_addr.s_addr = inet_addr(UPNP_MCAST_ADDR);\n+\t\tn = sendto(sudp, bufr, n, 0,\n+\t\t           (struct sockaddr *)&sockudp_w, sizeof(struct sockaddr_in));\n+\t\tif (n < 0) {\n+\t\t\tPRINT_SOCKET_ERROR(\"sendto\");\n+\t\t\tclosesocket(sudp);\n+\t\t\treturn devlist;\n+\t\t}\n+#else /* #ifdef NO_GETADDRINFO */\n+\t\tmemset(&hints, 0, sizeof(hints));\n+\t\thints.ai_family = AF_UNSPEC; // AF_INET6 or AF_INET\n+\t\thints.ai_socktype = SOCK_DGRAM;\n+\t\t/*hints.ai_flags = */\n+\t\tif ((rv = getaddrinfo(UPNP_MCAST_ADDR, XSTR(PORT), &hints, &servinfo)) != 0) {\n+#ifdef WIN32\n+\t\t    fprintf(stderr, \"getaddrinfo() failed: %d\\n\", rv);\n+#else\n+\t\t    fprintf(stderr, \"getaddrinfo: %s\\n\", gai_strerror(rv));\n+#endif\n+\t\t    return devlist;\n+\t\t}\n+\t\tfor(p = servinfo; p; p = p->ai_next) {\n+\t\t\tn = sendto(sudp, bufr, n, 0, p->ai_addr, p->ai_addrlen);\n+\t\t\tif (n < 0) {\n+\t\t\t\tPRINT_SOCKET_ERROR(\"sendto\");\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t}\n+\t\tfreeaddrinfo(servinfo);\n+\t\tif(n < 0) {\n+\t\t\tclosesocket(sudp);\n+\t\t\treturn devlist;\n+\t\t}\n+#endif /* #ifdef NO_GETADDRINFO */\n+\t}\n+\t/* Waiting for SSDP REPLY packet to M-SEARCH */\n+\tn = ReceiveData(sudp, bufr, sizeof(bufr), delay);\n+\tif (n < 0) {\n+\t\t/* error */\n+\t\tclosesocket(sudp);\n+\t\treturn devlist;\n+\t} else if (n == 0) {\n+\t\t/* no data or Time Out */\n+\t\tif (devlist || (deviceList[deviceIndex] == 0)) {\n+\t\t\t/* no more device type to look for... */\n+\t\t\tclosesocket(sudp);\n+\t\t\treturn devlist;\n+\t\t}\n+\t} else {\n+\t\tconst char * descURL=NULL;\n+\t\tint urlsize=0;\n+\t\tconst char * st=NULL;\n+\t\tint stsize=0;\n+        /*printf(\"%d byte(s) :\\n%s\\n\", n, bufr);*/ /* affichage du message */\n+\t\tparseMSEARCHReply(bufr, n, &descURL, &urlsize, &st, &stsize);\n+\t\tif(st&&descURL)\n+\t\t{\n+#ifdef DEBUG\n+\t\t\tprintf(\"M-SEARCH Reply:\\nST: %.*s\\nLocation: %.*s\\n\",\n+\t\t\t       stsize, st, urlsize, descURL);\n+#endif\n+\t\t\tfor(tmp=devlist; tmp; tmp = tmp->pNext) {\n+\t\t\t\tif(memcmp(tmp->descURL, descURL, urlsize) == 0 &&\n+\t\t\t\t   tmp->descURL[urlsize] == '\\0' &&\n+\t\t\t\t   memcmp(tmp->st, st, stsize) == 0 &&\n+\t\t\t\t   tmp->st[stsize] == '\\0')\n+\t\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\t/* at the exit of the loop above, tmp is null if\n+\t\t\t * no duplicate device was found */\n+\t\t\tif(tmp)\n+\t\t\t\tcontinue;\n+\t\t\ttmp = (struct UPNPDev *)malloc(sizeof(struct UPNPDev)+urlsize+stsize);\n+\t\t\ttmp->pNext = devlist;\n+\t\t\ttmp->descURL = tmp->buffer;\n+\t\t\ttmp->st = tmp->buffer + 1 + urlsize;\n+\t\t\tmemcpy(tmp->buffer, descURL, urlsize);\n+\t\t\ttmp->buffer[urlsize] = '\\0';\n+\t\t\tmemcpy(tmp->buffer + urlsize + 1, st, stsize);\n+\t\t\ttmp->buffer[urlsize+1+stsize] = '\\0';\n+\t\t\tdevlist = tmp;\n+\t\t}\n+\t}\n+\t}\n+}\n+\n+/* freeUPNPDevlist() should be used to\n+ * free the chained list returned by upnpDiscover() */\n+LIBSPEC void freeUPNPDevlist(struct UPNPDev * devlist)\n+{\n+\tstruct UPNPDev * next;\n+\twhile(devlist)\n+\t{\n+\t\tnext = devlist->pNext;\n+\t\tfree(devlist);\n+\t\tdevlist = next;\n+\t}\n+}\n+\n+static void\n+url_cpy_or_cat(char * dst, const char * src, int n)\n+{\n+\tif(  (src[0] == 'h')\n+\t   &&(src[1] == 't')\n+\t   &&(src[2] == 't')\n+\t   &&(src[3] == 'p')\n+\t   &&(src[4] == ':')\n+\t   &&(src[5] == '/')\n+\t   &&(src[6] == '/'))\n+\t{\n+\t\tstrncpy(dst, src, n);\n+\t}\n+\telse\n+\t{\n+\t\tint l = strlen(dst);\n+\t\tif(src[0] != '/')\n+\t\t\tdst[l++] = '/';\n+\t\tif(l<=n)\n+\t\t\tstrncpy(dst + l, src, n - l);\n+\t}\n+}\n+\n+/* Prepare the Urls for usage...\n+ */\n+LIBSPEC void GetUPNPUrls(struct UPNPUrls * urls, struct IGDdatas * data,\n+                 const char * descURL)\n+{\n+\tchar * p;\n+\tint n1, n2, n3;\n+\tn1 = strlen(data->urlbase);\n+\tif(n1==0)\n+\t\tn1 = strlen(descURL);\n+\tn1 += 2;\t/* 1 byte more for Null terminator, 1 byte for '/' if needed */\n+\tn2 = n1; n3 = n1;\n+\tn1 += strlen(data->first.scpdurl);\n+\tn2 += strlen(data->first.controlurl);\n+\tn3 += strlen(data->CIF.controlurl);\n+\n+\turls->ipcondescURL = (char *)malloc(n1);\n+\turls->controlURL = (char *)malloc(n2);\n+\turls->controlURL_CIF = (char *)malloc(n3);\n+\t/* maintenant on chope la desc du WANIPConnection */\n+\tif(data->urlbase[0] != '\\0')\n+\t\tstrncpy(urls->ipcondescURL, data->urlbase, n1);\n+\telse\n+\t\tstrncpy(urls->ipcondescURL, descURL, n1);\n+\tp = strchr(urls->ipcondescURL+7, '/');\n+\tif(p) p[0] = '\\0';\n+\tstrncpy(urls->controlURL, urls->ipcondescURL, n2);\n+\tstrncpy(urls->controlURL_CIF, urls->ipcondescURL, n3);\n+\t\n+\turl_cpy_or_cat(urls->ipcondescURL, data->first.scpdurl, n1);\n+\n+\turl_cpy_or_cat(urls->controlURL, data->first.controlurl, n2);\n+\n+\turl_cpy_or_cat(urls->controlURL_CIF, data->CIF.controlurl, n3);\n+\n+#ifdef DEBUG\n+\tprintf(\"urls->ipcondescURL='%s' %u n1=%d\\n\", urls->ipcondescURL,\n+\t       (unsigned)strlen(urls->ipcondescURL), n1);\n+\tprintf(\"urls->controlURL='%s' %u n2=%d\\n\", urls->controlURL,\n+\t       (unsigned)strlen(urls->controlURL), n2);\n+\tprintf(\"urls->controlURL_CIF='%s' %u n3=%d\\n\", urls->controlURL_CIF,\n+\t       (unsigned)strlen(urls->controlURL_CIF), n3);\n+#endif\n+}\n+\n+LIBSPEC void\n+FreeUPNPUrls(struct UPNPUrls * urls)\n+{\n+\tif(!urls)\n+\t\treturn;\n+\tfree(urls->controlURL);\n+\turls->controlURL = 0;\n+\tfree(urls->ipcondescURL);\n+\turls->ipcondescURL = 0;\n+\tfree(urls->controlURL_CIF);\n+\turls->controlURL_CIF = 0;\n+}\n+\n+\n+int ReceiveData(int socket, char * data, int length, int timeout)\n+{\n+    int n;\n+#if !defined(WIN32) && !defined(__amigaos__) && !defined(__amigaos4__)\n+    struct pollfd fds[1]; /* for the poll */\n+#ifdef MINIUPNPC_IGNORE_EINTR\n+    do {\n+#endif\n+        fds[0].fd = socket;\n+        fds[0].events = POLLIN;\n+        n = poll(fds, 1, timeout);\n+#ifdef MINIUPNPC_IGNORE_EINTR\n+    } while(n < 0 && errno == EINTR);\n+#endif\n+    if(n < 0)\n+    {\n+        PRINT_SOCKET_ERROR(\"poll\");\n+        return -1;\n+    }\n+    else if(n == 0)\n+    {\n+        return 0;\n+    }\n+#else\n+    fd_set socketSet;\n+    TIMEVAL timeval;\n+    FD_ZERO(&socketSet);\n+    FD_SET(socket, &socketSet);\n+    timeval.tv_sec = timeout / 1000;\n+    timeval.tv_usec = (timeout % 1000) * 1000;\n+    n = select(FD_SETSIZE, &socketSet, NULL, NULL, &timeval);\n+    if(n < 0)\n+    {\n+        PRINT_SOCKET_ERROR(\"select\");\n+        return -1;\n+    }\n+    else if(n == 0)\n+    {\n+        return 0;\n+    }    \n+#endif\n+\tn = recv(socket, data, length, 0);\n+\tif(n<0)\n+\t{\n+\t\tPRINT_SOCKET_ERROR(\"recv\");\n+\t}\n+\treturn n;\n+}\n+\n+int\n+UPNPIGD_IsConnected(struct UPNPUrls * urls, struct IGDdatas * data)\n+{\n+\tchar status[64];\n+\tunsigned int uptime;\n+\tstatus[0] = '\\0';\n+\tUPNP_GetStatusInfo(urls->controlURL, data->first.servicetype,\n+\t                   status, &uptime, NULL);\n+\tif(0 == strcmp(\"Connected\", status))\n+\t{\n+\t\treturn 1;\n+\t}\n+\telse\n+\t\treturn 0;\n+}\n+\n+\n+/* UPNP_GetValidIGD() :\n+ * return values :\n+ *     0 = NO IGD found\n+ *     1 = A valid connected IGD has been found\n+ *     2 = A valid IGD has been found but it reported as\n+ *         not connected\n+ *     3 = an UPnP device has been found but was not recognized as an IGD\n+ *\n+ * In any non zero return case, the urls and data structures\n+ * passed as parameters are set. Donc forget to call FreeUPNPUrls(urls) to\n+ * free allocated memory.\n+ */\n+LIBSPEC int\n+UPNP_GetValidIGD(struct UPNPDev * devlist,\n+                 struct UPNPUrls * urls,\n+\t\t\t\t struct IGDdatas * data,\n+\t\t\t\t char * lanaddr, int lanaddrlen)\n+{\n+\tchar * descXML;\n+\tint descXMLsize = 0;\n+\tstruct UPNPDev * dev;\n+\tint ndev = 0;\n+\tint state; /* state 1 : IGD connected. State 2 : IGD. State 3 : anything */\n+\tif(!devlist)\n+\t{\n+#ifdef DEBUG\n+\t\tprintf(\"Empty devlist\\n\");\n+#endif\n+\t\treturn 0;\n+\t}\n+\tfor(state = 1; state <= 3; state++)\n+\t{\n+\t\tfor(dev = devlist; dev; dev = dev->pNext)\n+\t\t{\n+\t\t\t/* we should choose an internet gateway device.\n+\t\t \t* with st == urn:schemas-upnp-org:device:InternetGatewayDevice:1 */\n+\t\t\tdescXML = miniwget_getaddr(dev->descURL, &descXMLsize,\n+\t\t\t   \t                        lanaddr, lanaddrlen);\n+\t\t\tif(descXML)\n+\t\t\t{\n+\t\t\t\tndev++;\n+\t\t\t\tmemset(data, 0, sizeof(struct IGDdatas));\n+\t\t\t\tmemset(urls, 0, sizeof(struct UPNPUrls));\n+\t\t\t\tparserootdesc(descXML, descXMLsize, data);\n+\t\t\t\tfree(descXML);\n+\t\t\t\tdescXML = NULL;\n+\t\t\t\tif(0==strcmp(data->CIF.servicetype,\n+\t\t\t\t   \"urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1\")\n+\t\t\t\t   || state >= 3 )\n+\t\t\t\t{\n+\t\t\t\t  GetUPNPUrls(urls, data, dev->descURL);\n+\n+#ifdef DEBUG\n+\t\t\t\t  printf(\"UPNPIGD_IsConnected(%s) = %d\\n\",\n+\t\t\t\t     urls->controlURL,\n+\t\t\t         UPNPIGD_IsConnected(urls, data));\n+#endif\n+\t\t\t\t  if((state >= 2) || UPNPIGD_IsConnected(urls, data))\n+\t\t\t\t\treturn state;\n+\t\t\t\t  FreeUPNPUrls(urls);\n+\t\t\t\t  if(data->second.servicetype[0] != '\\0') {\n+#ifdef DEBUG\n+\t\t\t\t    printf(\"We tried %s, now we try %s !\\n\",\n+\t\t\t\t           data->first.servicetype, data->second.servicetype);\n+#endif\n+\t\t\t\t    /* swaping WANPPPConnection and WANIPConnection ! */\n+\t\t\t\t    memcpy(&data->tmp, &data->first, sizeof(struct IGDdatas_service));\n+\t\t\t\t    memcpy(&data->first, &data->second, sizeof(struct IGDdatas_service));\n+\t\t\t\t    memcpy(&data->second, &data->tmp, sizeof(struct IGDdatas_service));\n+\t\t\t\t    GetUPNPUrls(urls, data, dev->descURL);\n+#ifdef DEBUG\n+\t\t\t\t    printf(\"UPNPIGD_IsConnected(%s) = %d\\n\",\n+\t\t\t\t       urls->controlURL,\n+\t\t\t           UPNPIGD_IsConnected(urls, data));\n+#endif\n+\t\t\t\t    if((state >= 2) || UPNPIGD_IsConnected(urls, data))\n+\t\t\t\t\t  return state;\n+\t\t\t\t    FreeUPNPUrls(urls);\n+\t\t\t\t  }\n+\t\t\t\t}\n+\t\t\t\tmemset(data, 0, sizeof(struct IGDdatas));\n+\t\t\t}\n+#ifdef DEBUG\n+\t\t\telse\n+\t\t\t{\n+\t\t\t\tprintf(\"error getting XML description %s\\n\", dev->descURL);\n+\t\t\t}\n+#endif\n+\t\t}\n+\t}\n+\treturn 0;\n+}\n+\n+/* UPNP_GetIGDFromUrl()\n+ * Used when skipping the discovery process.\n+ * return value :\n+ *   0 - Not ok\n+ *   1 - OK */\n+int\n+UPNP_GetIGDFromUrl(const char * rootdescurl,\n+                   struct UPNPUrls * urls,\n+                   struct IGDdatas * data,\n+                   char * lanaddr, int lanaddrlen)\n+{\n+\tchar * descXML;\n+\tint descXMLsize = 0;\n+\tdescXML = miniwget_getaddr(rootdescurl, &descXMLsize,\n+\t   \t                       lanaddr, lanaddrlen);\n+\tif(descXML) {\n+\t\tmemset(data, 0, sizeof(struct IGDdatas));\n+\t\tmemset(urls, 0, sizeof(struct UPNPUrls));\n+\t\tparserootdesc(descXML, descXMLsize, data);\n+\t\tfree(descXML);\n+\t\tdescXML = NULL;\n+\t\tGetUPNPUrls(urls, data, rootdescurl);\n+\t\treturn 1;\n+\t} else {\n+\t\treturn 0;\n+\t}\n+}\n+"
      },
      {
        "sha": "21e66a4c36ae8c5769a7c814a4560db0b6f30ae0",
        "filename": "miniupnpc/miniupnpc.def",
        "status": "added",
        "additions": 31,
        "deletions": 0,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/miniupnpc.def",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/miniupnpc.def",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/miniupnpc/miniupnpc.def?ref=b94b7b05a7b1d27e28ca9a8684877ca605d70256",
        "patch": "@@ -0,0 +1,31 @@\n+LIBRARY\n+; miniupnpc library\n+\n+EXPORTS\n+; miniupnpc\n+   upnpDiscover\n+   freeUPNPDevlist\n+   parserootdesc\n+   UPNP_GetValidIGD\n+   UPNP_GetIGDFromUrl\n+   GetUPNPUrls\n+   FreeUPNPUrls\n+; miniwget\n+   miniwget\n+   miniwget_getaddr\n+; upnpcommands\n+   UPNP_GetTotalBytesSent\n+   UPNP_GetTotalBytesReceived\n+   UPNP_GetTotalPacketsSent\n+   UPNP_GetTotalPacketsReceived\n+   UPNP_GetStatusInfo\n+   UPNP_GetConnectionTypeInfo\n+   UPNP_GetExternalIPAddress\n+   UPNP_GetLinkLayerMaxBitRates\n+   UPNP_AddPortMapping\n+   UPNP_DeletePortMapping\n+   UPNP_GetPortMappingNumberOfEntries\n+   UPNP_GetSpecificPortMappingEntry\n+   UPNP_GetGenericPortMappingEntry \n+; upnperrors\n+   strupnperror\n\\ No newline at end of file"
      },
      {
        "sha": "2379ba14c60c1a7ef804cacd1da356223d356490",
        "filename": "miniupnpc/miniupnpc.h",
        "status": "added",
        "additions": 114,
        "deletions": 0,
        "changes": 114,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/miniupnpc.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/miniupnpc.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/miniupnpc/miniupnpc.h?ref=b94b7b05a7b1d27e28ca9a8684877ca605d70256",
        "patch": "@@ -0,0 +1,114 @@\n+/* $Id: miniupnpc.h,v 1.19 2009/10/10 19:15:35 nanard Exp $ */\n+/* Project: miniupnp\n+ * http://miniupnp.free.fr/\n+ * Author: Thomas Bernard\n+ * Copyright (c) 2005-2006 Thomas Bernard\n+ * This software is subjects to the conditions detailed\n+ * in the LICENCE file provided within this distribution */\n+#ifndef __MINIUPNPC_H__\n+#define __MINIUPNPC_H__\n+\n+#include \"declspec.h\"\n+#include \"igd_desc_parse.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* Structures definitions : */\n+struct UPNParg { const char * elt; const char * val; };\n+\n+int simpleUPnPcommand(int, const char *, const char *,\n+                      const char *, struct UPNParg *,\n+                      char *, int *);\n+\n+struct UPNPDev {\n+\tstruct UPNPDev * pNext;\n+\tchar * descURL;\n+\tchar * st;\n+\tchar buffer[2];\n+};\n+\n+/* upnpDiscover()\n+ * discover UPnP devices on the network.\n+ * The discovered devices are returned as a chained list.\n+ * It is up to the caller to free the list with freeUPNPDevlist().\n+ * delay (in millisecond) is the maximum time for waiting any device\n+ * response.\n+ * If available, device list will be obtained from MiniSSDPd.\n+ * Default path for minissdpd socket will be used if minissdpdsock argument\n+ * is NULL.\n+ * If multicastif is not NULL, it will be used instead of the default\n+ * multicast interface for sending SSDP discover packets.\n+ * If sameport is not null, SSDP packets will be sent from the source port\n+ * 1900 (same as destination port) otherwise system assign a source port. */\n+LIBSPEC struct UPNPDev * upnpDiscover(int delay, const char * multicastif,\n+                                      const char * minissdpdsock, int sameport);\n+/* freeUPNPDevlist()\n+ * free list returned by upnpDiscover() */\n+LIBSPEC void freeUPNPDevlist(struct UPNPDev * devlist);\n+\n+/* parserootdesc() :\n+ * parse root XML description of a UPnP device and fill the IGDdatas\n+ * structure. */\n+LIBSPEC void parserootdesc(const char *, int, struct IGDdatas *);\n+\n+/* structure used to get fast access to urls\n+ * controlURL: controlURL of the WANIPConnection\n+ * ipcondescURL: url of the description of the WANIPConnection\n+ * controlURL_CIF: controlURL of the WANCommonInterfaceConfig\n+ */\n+struct UPNPUrls {\n+\tchar * controlURL;\n+\tchar * ipcondescURL;\n+\tchar * controlURL_CIF;\n+};\n+\n+/* UPNP_GetValidIGD() :\n+ * return values :\n+ *     0 = NO IGD found\n+ *     1 = A valid connected IGD has been found\n+ *     2 = A valid IGD has been found but it reported as\n+ *         not connected\n+ *     3 = an UPnP device has been found but was not recognized as an IGD\n+ *\n+ * In any non zero return case, the urls and data structures\n+ * passed as parameters are set. Donc forget to call FreeUPNPUrls(urls) to\n+ * free allocated memory.\n+ */\n+LIBSPEC int\n+UPNP_GetValidIGD(struct UPNPDev * devlist,\n+                 struct UPNPUrls * urls,\n+\t\t\t\t struct IGDdatas * data,\n+\t\t\t\t char * lanaddr, int lanaddrlen);\n+\n+/* UPNP_GetIGDFromUrl()\n+ * Used when skipping the discovery process.\n+ * return value :\n+ *   0 - Not ok\n+ *   1 - OK */\n+LIBSPEC int\n+UPNP_GetIGDFromUrl(const char * rootdescurl,\n+                   struct UPNPUrls * urls,\n+                   struct IGDdatas * data,\n+                   char * lanaddr, int lanaddrlen);\n+\n+LIBSPEC void GetUPNPUrls(struct UPNPUrls *, struct IGDdatas *, const char *);\n+\n+LIBSPEC void FreeUPNPUrls(struct UPNPUrls *);\n+\n+/* Reads data from the specified socket. \n+ * Returns the number of bytes read if successful, zero if no bytes were \n+ * read or if we timed out. Returns negative if there was an error. */\n+int ReceiveData(int socket, char * data, int length, int timeout);\n+\n+/* return 0 or 1 */\n+LIBSPEC int UPNPIGD_IsConnected(struct UPNPUrls *, struct IGDdatas *);\n+\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif\n+"
      },
      {
        "sha": "c09e98261788dd4c0aa7e84e28ee35df5c52ed7e",
        "filename": "miniupnpc/miniupnpcmodule.c",
        "status": "added",
        "additions": 494,
        "deletions": 0,
        "changes": 494,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/miniupnpcmodule.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/miniupnpcmodule.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/miniupnpc/miniupnpcmodule.c?ref=b94b7b05a7b1d27e28ca9a8684877ca605d70256",
        "patch": "@@ -0,0 +1,494 @@\n+/* $Id: miniupnpcmodule.c,v 1.15 2010/06/09 10:23:01 nanard Exp $*/\n+/* Project : miniupnp\n+ * Author : Thomas BERNARD\n+ * website : http://miniupnp.tuxfamily.org/\n+ * copyright (c) 2007-2009 Thomas Bernard\n+ * This software is subjet to the conditions detailed in the\n+ * provided LICENCE file. */\n+#include <Python.h>\n+#define STATICLIB\n+#include \"structmember.h\"\n+#include \"miniupnpc.h\"\n+#include \"upnpcommands.h\"\n+#include \"upnperrors.h\"\n+\n+/* for compatibility with Python < 2.4 */\n+#ifndef Py_RETURN_NONE\n+#define Py_RETURN_NONE return Py_INCREF(Py_None), Py_None\n+#endif\n+\n+#ifndef Py_RETURN_TRUE\n+#define Py_RETURN_TRUE return Py_INCREF(Py_True), Py_True\n+#endif\n+\n+#ifndef Py_RETURN_FALSE\n+#define Py_RETURN_FALSE return Py_INCREF(Py_False), Py_False\n+#endif\n+\n+typedef struct {\n+    PyObject_HEAD\n+    /* Type-specific fields go here. */\n+\tstruct UPNPDev * devlist;\n+\tstruct UPNPUrls urls;\n+\tstruct IGDdatas data;\n+\tunsigned int discoverdelay;\t/* value passed to upnpDiscover() */\n+\tchar lanaddr[16];\t/* our ip address on the LAN */\n+\tchar * multicastif;\n+\tchar * minissdpdsocket;\n+} UPnPObject;\n+\n+static PyMemberDef UPnP_members[] = {\n+\t{\"lanaddr\", T_STRING_INPLACE, offsetof(UPnPObject, lanaddr),\n+\t READONLY, \"ip address on the LAN\"\n+\t},\n+\t{\"discoverdelay\", T_UINT, offsetof(UPnPObject, discoverdelay),\n+\t 0/*READWRITE*/, \"value in ms used to wait for SSDP responses\"\n+\t},\n+\t/* T_STRING is allways readonly :( */\n+\t{\"multicastif\", T_STRING, offsetof(UPnPObject, multicastif),\n+\t 0, \"IP of the network interface to be used for multicast operations\"\n+\t},\n+\t{\"minissdpdsocket\", T_STRING, offsetof(UPnPObject, multicastif),\n+\t 0, \"path of the MiniSSDPd unix socket\"\n+\t},\n+\t{NULL}\n+};\n+\n+static void\n+UPnPObject_dealloc(UPnPObject *self)\n+{\n+\tfreeUPNPDevlist(self->devlist);\n+\tFreeUPNPUrls(&self->urls);\n+\tself->ob_type->tp_free((PyObject*)self);\n+}\n+\n+static PyObject *\n+UPnP_discover(UPnPObject *self)\n+{\n+\tstruct UPNPDev * dev;\n+\tint i;\n+\tPyObject *res = NULL;\n+\tif(self->devlist)\n+\t{\n+\t\tfreeUPNPDevlist(self->devlist);\n+\t\tself->devlist = 0;\n+\t} \n+\tPy_BEGIN_ALLOW_THREADS\n+\tself->devlist = upnpDiscover((int)self->discoverdelay/*timeout in ms*/,\n+\t                             0/* multicast if*/,\n+\t                             0/*minissdpd socket*/,\n+\t\t\t\t\t\t\t\t 0/*sameport flag*/);\n+\tPy_END_ALLOW_THREADS\n+\t/* Py_RETURN_NONE ??? */\n+\tfor(dev = self->devlist, i = 0; dev; dev = dev->pNext)\n+\t\ti++;\n+\tres = Py_BuildValue(\"i\", i);\n+\treturn res;\n+}\n+\n+static PyObject *\n+UPnP_selectigd(UPnPObject *self)\n+{\n+\tint r;\n+Py_BEGIN_ALLOW_THREADS\n+\tr = UPNP_GetValidIGD(self->devlist, &self->urls, &self->data,\n+\t                     self->lanaddr, sizeof(self->lanaddr));\n+Py_END_ALLOW_THREADS\n+\tif(r)\n+\t{\n+\t\treturn Py_BuildValue(\"s\", self->urls.controlURL);\n+\t}\n+\telse\n+\t{\n+\t\t/* TODO: have our own exception type ! */\n+\t\tPyErr_SetString(PyExc_Exception, \"No UPnP device discovered\");\n+\t\treturn NULL;\n+\t}\n+}\n+\n+static PyObject *\n+UPnP_totalbytesent(UPnPObject *self)\n+{\n+\tUNSIGNED_INTEGER i;\n+Py_BEGIN_ALLOW_THREADS\n+\ti = UPNP_GetTotalBytesSent(self->urls.controlURL_CIF,\n+\t                           self->data.CIF.servicetype);\n+Py_END_ALLOW_THREADS\n+\treturn Py_BuildValue(\"I\", i);\n+}\n+\n+static PyObject *\n+UPnP_totalbytereceived(UPnPObject *self)\n+{\n+\tUNSIGNED_INTEGER i;\n+Py_BEGIN_ALLOW_THREADS\n+\ti = UPNP_GetTotalBytesReceived(self->urls.controlURL_CIF,\n+\t\t                           self->data.CIF.servicetype);\n+Py_END_ALLOW_THREADS\n+\treturn Py_BuildValue(\"I\", i);\n+}\n+\n+static PyObject *\n+UPnP_totalpacketsent(UPnPObject *self)\n+{\n+\tUNSIGNED_INTEGER i;\n+Py_BEGIN_ALLOW_THREADS\n+\ti = UPNP_GetTotalPacketsSent(self->urls.controlURL_CIF,\n+\t\t                         self->data.CIF.servicetype);\n+Py_END_ALLOW_THREADS\n+\treturn Py_BuildValue(\"I\", i);\n+}\n+\n+static PyObject *\n+UPnP_totalpacketreceived(UPnPObject *self)\n+{\n+\tUNSIGNED_INTEGER i;\n+Py_BEGIN_ALLOW_THREADS\n+\ti = UPNP_GetTotalPacketsReceived(self->urls.controlURL_CIF,\n+\t\t                          self->data.CIF.servicetype);\n+Py_END_ALLOW_THREADS\n+\treturn Py_BuildValue(\"I\", i);\n+}\n+\n+static PyObject *\n+UPnP_statusinfo(UPnPObject *self)\n+{\n+\tchar status[64];\n+\tchar lastconnerror[64];\n+\tunsigned int uptime = 0;\n+\tint r;\n+\tstatus[0] = '\\0';\n+\tlastconnerror[0] = '\\0';\n+Py_BEGIN_ALLOW_THREADS\n+\tr = UPNP_GetStatusInfo(self->urls.controlURL, self->data.first.servicetype,\n+\t                   status, &uptime, lastconnerror);\n+Py_END_ALLOW_THREADS\n+\tif(r==UPNPCOMMAND_SUCCESS) {\n+\t\treturn Py_BuildValue(\"(s,I,s)\", status, uptime, lastconnerror);\n+\t} else {\n+\t\t/* TODO: have our own exception type ! */\n+\t\tPyErr_SetString(PyExc_Exception, strupnperror(r));\n+\t\treturn NULL;\n+\t}\n+}\n+\n+static PyObject *\n+UPnP_connectiontype(UPnPObject *self)\n+{\n+\tchar connectionType[64];\n+\tint r;\n+\tconnectionType[0] = '\\0';\n+Py_BEGIN_ALLOW_THREADS\n+\tr = UPNP_GetConnectionTypeInfo(self->urls.controlURL,\n+\t                               self->data.first.servicetype,\n+\t                               connectionType);\n+Py_END_ALLOW_THREADS\n+\tif(r==UPNPCOMMAND_SUCCESS) {\n+\t\treturn Py_BuildValue(\"s\", connectionType);\n+\t} else {\n+\t\t/* TODO: have our own exception type ! */\n+\t\tPyErr_SetString(PyExc_Exception, strupnperror(r));\n+\t\treturn NULL;\n+\t}\n+}\n+\n+static PyObject *\n+UPnP_externalipaddress(UPnPObject *self)\n+{\n+\tchar externalIPAddress[16];\n+\tint r;\n+\texternalIPAddress[0] = '\\0';\n+Py_BEGIN_ALLOW_THREADS\n+\tr = UPNP_GetExternalIPAddress(self->urls.controlURL,\n+\t                              self->data.first.servicetype,\n+\t                              externalIPAddress);\n+Py_END_ALLOW_THREADS\n+\tif(r==UPNPCOMMAND_SUCCESS) {\n+\t\treturn Py_BuildValue(\"s\", externalIPAddress);\n+\t} else {\n+\t\t/* TODO: have our own exception type ! */\n+\t\tPyErr_SetString(PyExc_Exception, strupnperror(r));\n+\t\treturn NULL;\n+\t}\n+}\n+\n+/* AddPortMapping(externalPort, protocol, internalHost, internalPort, desc,\n+ *                remoteHost) \n+ * protocol is 'UDP' or 'TCP' */\n+static PyObject *\n+UPnP_addportmapping(UPnPObject *self, PyObject *args)\n+{\n+\tchar extPort[6];\n+\tunsigned short ePort;\n+\tchar inPort[6];\n+\tunsigned short iPort;\n+\tconst char * proto;\n+\tconst char * host;\n+\tconst char * desc;\n+\tconst char * remoteHost;\n+\tint r;\n+\tif (!PyArg_ParseTuple(args, \"HssHss\", &ePort, &proto,\n+\t                                     &host, &iPort, &desc, &remoteHost))\n+        return NULL;\n+Py_BEGIN_ALLOW_THREADS\n+\tsprintf(extPort, \"%hu\", ePort);\n+\tsprintf(inPort, \"%hu\", iPort);\n+\tr = UPNP_AddPortMapping(self->urls.controlURL, self->data.first.servicetype,\n+\t                        extPort, inPort, host, desc, proto, remoteHost);\n+Py_END_ALLOW_THREADS\n+\tif(r==UPNPCOMMAND_SUCCESS)\n+\t{\n+\t\tPy_RETURN_TRUE;\n+\t}\n+\telse\n+\t{\n+\t\t// TODO: RAISE an Exception. See upnpcommands.h for errors codes.\n+\t\t// upnperrors.c\n+\t\t//Py_RETURN_FALSE;\n+\t\t/* TODO: have our own exception type ! */\n+\t\tPyErr_SetString(PyExc_Exception, strupnperror(r));\n+\t\treturn NULL;\n+\t}\n+}\n+\n+/* DeletePortMapping(extPort, proto, removeHost='')\n+ * proto = 'UDP', 'TCP' */\n+static PyObject *\n+UPnP_deleteportmapping(UPnPObject *self, PyObject *args)\n+{\n+\tchar extPort[6];\n+\tunsigned short ePort;\n+\tconst char * proto;\n+\tconst char * remoteHost = \"\";\n+\tint r;\n+\tif(!PyArg_ParseTuple(args, \"Hs|z\", &ePort, &proto, &remoteHost))\n+\t\treturn NULL;\n+Py_BEGIN_ALLOW_THREADS\n+\tsprintf(extPort, \"%hu\", ePort);\n+\tr = UPNP_DeletePortMapping(self->urls.controlURL, self->data.first.servicetype,\n+\t                           extPort, proto, remoteHost);\n+Py_END_ALLOW_THREADS\n+\tif(r==UPNPCOMMAND_SUCCESS) {\n+\t\tPy_RETURN_TRUE;\n+\t} else {\n+\t\t/* TODO: have our own exception type ! */\n+\t\tPyErr_SetString(PyExc_Exception, strupnperror(r));\n+\t\treturn NULL;\n+\t}\n+}\n+\n+static PyObject *\n+UPnP_getportmappingnumberofentries(UPnPObject *self)\n+{\n+\tunsigned int n = 0;\n+\tint r;\n+Py_BEGIN_ALLOW_THREADS\n+\tr = UPNP_GetPortMappingNumberOfEntries(self->urls.controlURL,\n+\t                                   self->data.first.servicetype,\n+\t\t\t\t\t\t\t\t\t   &n);\n+Py_END_ALLOW_THREADS\n+\tif(r==UPNPCOMMAND_SUCCESS) {\n+\t\treturn Py_BuildValue(\"I\", n);\n+\t} else {\n+\t\t/* TODO: have our own exception type ! */\n+\t\tPyErr_SetString(PyExc_Exception, strupnperror(r));\n+\t\treturn NULL;\n+\t}\n+}\n+\n+/* GetSpecificPortMapping(ePort, proto) \n+ * proto = 'UDP' or 'TCP' */\n+static PyObject *\n+UPnP_getspecificportmapping(UPnPObject *self, PyObject *args)\n+{\n+\tchar extPort[6];\n+\tunsigned short ePort;\n+\tconst char * proto;\n+\tchar intClient[16];\n+\tchar intPort[6];\n+\tunsigned short iPort;\n+\tif(!PyArg_ParseTuple(args, \"Hs\", &ePort, &proto))\n+\t\treturn NULL;\n+Py_BEGIN_ALLOW_THREADS\n+\tsprintf(extPort, \"%hu\", ePort);\n+\tUPNP_GetSpecificPortMappingEntry(self->urls.controlURL,\n+\t                                 self->data.first.servicetype,\n+\t\t\t\t\t\t\t\t\t extPort, proto,\n+\t\t\t\t\t\t\t\t\t intClient, intPort);\n+Py_END_ALLOW_THREADS\n+\tif(intClient[0])\n+\t{\n+\t\tiPort = (unsigned short)atoi(intPort);\n+\t\treturn Py_BuildValue(\"(s,H)\", intClient, iPort);\n+\t}\n+\telse\n+\t{\n+\t\tPy_RETURN_NONE;\n+\t}\n+}\n+\n+/* GetGenericPortMapping(index) */\n+static PyObject *\n+UPnP_getgenericportmapping(UPnPObject *self, PyObject *args)\n+{\n+\tint i, r;\n+\tchar index[8];\n+\tchar intClient[16];\n+\tchar intPort[6];\n+\tunsigned short iPort;\n+\tchar extPort[6];\n+\tunsigned short ePort;\n+\tchar protocol[4];\n+\tchar desc[80];\n+\tchar enabled[6];\n+\tchar rHost[64];\n+\tchar duration[16];\t/* lease duration */\n+\tunsigned int dur;\n+\tif(!PyArg_ParseTuple(args, \"i\", &i))\n+\t\treturn NULL;\n+Py_BEGIN_ALLOW_THREADS\n+\tsnprintf(index, sizeof(index), \"%d\", i);\n+\trHost[0] = '\\0'; enabled[0] = '\\0';\n+\tduration[0] = '\\0'; desc[0] = '\\0';\n+\textPort[0] = '\\0'; intPort[0] = '\\0'; intClient[0] = '\\0';\n+\tr = UPNP_GetGenericPortMappingEntry(self->urls.controlURL,\n+\t                                    self->data.first.servicetype,\n+\t\t\t\t\t\t\t\t\t\tindex,\n+\t\t\t\t\t\t\t\t\t\textPort, intClient, intPort,\n+\t\t\t\t\t\t\t\t\t\tprotocol, desc, enabled, rHost,\n+\t\t\t\t\t\t\t\t\t\tduration);\n+Py_END_ALLOW_THREADS\n+\tif(r==UPNPCOMMAND_SUCCESS)\n+\t{\n+\t\tePort = (unsigned short)atoi(extPort);\n+\t\tiPort = (unsigned short)atoi(intPort);\n+\t\tdur = (unsigned int)strtoul(duration, 0, 0);\n+\t\treturn Py_BuildValue(\"(H,s,(s,H),s,s,s,I)\",\n+\t\t                     ePort, protocol, intClient, iPort,\n+\t\t                     desc, enabled, rHost, dur);\n+\t}\n+\telse\n+\t{\n+\t\tPy_RETURN_NONE;\n+\t}\n+}\n+\n+/* miniupnpc.UPnP object Method Table */\n+static PyMethodDef UPnP_methods[] = {\n+    {\"discover\", (PyCFunction)UPnP_discover, METH_NOARGS,\n+     \"discover UPnP IGD devices on the network\"\n+    },\n+\t{\"selectigd\", (PyCFunction)UPnP_selectigd, METH_NOARGS,\n+\t \"select a valid UPnP IGD among discovered devices\"\n+\t},\n+\t{\"totalbytesent\", (PyCFunction)UPnP_totalbytesent, METH_NOARGS,\n+\t \"return the total number of bytes sent by UPnP IGD\"\n+\t},\n+\t{\"totalbytereceived\", (PyCFunction)UPnP_totalbytereceived, METH_NOARGS,\n+\t \"return the total number of bytes received by UPnP IGD\"\n+\t},\n+\t{\"totalpacketsent\", (PyCFunction)UPnP_totalpacketsent, METH_NOARGS,\n+\t \"return the total number of packets sent by UPnP IGD\"\n+\t},\n+\t{\"totalpacketreceived\", (PyCFunction)UPnP_totalpacketreceived, METH_NOARGS,\n+\t \"return the total number of packets received by UPnP IGD\"\n+\t},\n+\t{\"statusinfo\", (PyCFunction)UPnP_statusinfo, METH_NOARGS,\n+\t \"return status and uptime\"\n+\t},\n+\t{\"connectiontype\", (PyCFunction)UPnP_connectiontype, METH_NOARGS,\n+\t \"return IGD WAN connection type\"\n+\t},\n+\t{\"externalipaddress\", (PyCFunction)UPnP_externalipaddress, METH_NOARGS,\n+\t \"return external IP address\"\n+\t},\n+\t{\"addportmapping\", (PyCFunction)UPnP_addportmapping, METH_VARARGS,\n+\t \"add a port mapping\"\n+\t},\n+\t{\"deleteportmapping\", (PyCFunction)UPnP_deleteportmapping, METH_VARARGS,\n+\t \"delete a port mapping\"\n+\t},\n+\t{\"getportmappingnumberofentries\", (PyCFunction)UPnP_getportmappingnumberofentries, METH_NOARGS,\n+\t \"-- non standard --\"\n+\t},\n+\t{\"getspecificportmapping\", (PyCFunction)UPnP_getspecificportmapping, METH_VARARGS,\n+\t \"get details about a specific port mapping entry\"\n+\t},\n+\t{\"getgenericportmapping\", (PyCFunction)UPnP_getgenericportmapping, METH_VARARGS,\n+\t \"get all details about the port mapping at index\"\n+\t},\n+    {NULL}  /* Sentinel */\n+};\n+\n+static PyTypeObject UPnPType = {\n+    PyObject_HEAD_INIT(NULL)\n+    0,                         /*ob_size*/\n+    \"miniupnpc.UPnP\",          /*tp_name*/\n+    sizeof(UPnPObject),        /*tp_basicsize*/\n+    0,                         /*tp_itemsize*/\n+    (destructor)UPnPObject_dealloc,/*tp_dealloc*/\n+    0,                         /*tp_print*/\n+    0,                         /*tp_getattr*/\n+    0,                         /*tp_setattr*/\n+    0,                         /*tp_compare*/\n+    0,                         /*tp_repr*/\n+    0,                         /*tp_as_number*/\n+    0,                         /*tp_as_sequence*/\n+    0,                         /*tp_as_mapping*/\n+    0,                         /*tp_hash */\n+    0,                         /*tp_call*/\n+    0,                         /*tp_str*/\n+    0,                         /*tp_getattro*/\n+    0,                         /*tp_setattro*/\n+    0,                         /*tp_as_buffer*/\n+    Py_TPFLAGS_DEFAULT,        /*tp_flags*/\n+    \"UPnP objects\",            /* tp_doc */\n+    0,\t\t                   /* tp_traverse */\n+    0,\t\t                   /* tp_clear */\n+    0,\t\t                   /* tp_richcompare */\n+    0,\t\t                   /* tp_weaklistoffset */\n+    0,\t\t                   /* tp_iter */\n+    0,\t\t                   /* tp_iternext */\n+    UPnP_methods,              /* tp_methods */\n+    UPnP_members,              /* tp_members */\n+    0,                         /* tp_getset */\n+    0,                         /* tp_base */\n+    0,                         /* tp_dict */\n+    0,                         /* tp_descr_get */\n+    0,                         /* tp_descr_set */\n+    0,                         /* tp_dictoffset */\n+    0,/*(initproc)UPnP_init,*/      /* tp_init */\n+    0,                         /* tp_alloc */\n+#ifndef WIN32\n+    PyType_GenericNew,/*UPnP_new,*/      /* tp_new */\n+#else\n+    0,\n+#endif\n+};\n+\n+/* module methods */\n+static PyMethodDef miniupnpc_methods[] = {\n+    {NULL}  /* Sentinel */\n+};\n+\n+#ifndef PyMODINIT_FUNC\t/* declarations for DLL import/export */\n+#define PyMODINIT_FUNC void\n+#endif\n+PyMODINIT_FUNC\n+initminiupnpc(void) \n+{\n+    PyObject* m;\n+\n+#ifdef WIN32\n+    UPnPType.tp_new = PyType_GenericNew;\n+#endif\n+    if (PyType_Ready(&UPnPType) < 0)\n+        return;\n+\n+    m = Py_InitModule3(\"miniupnpc\", miniupnpc_methods,\n+                       \"miniupnpc module.\");\n+\n+    Py_INCREF(&UPnPType);\n+    PyModule_AddObject(m, \"UPnP\", (PyObject *)&UPnPType);\n+}\n+"
      },
      {
        "sha": "509ebd485a436622629624fdff0f304a8f6064ac",
        "filename": "miniupnpc/miniupnpcstrings.h.in",
        "status": "added",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/miniupnpcstrings.h.in",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/miniupnpcstrings.h.in",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/miniupnpc/miniupnpcstrings.h.in?ref=b94b7b05a7b1d27e28ca9a8684877ca605d70256",
        "patch": "@@ -0,0 +1,15 @@\n+/* $Id: miniupnpcstrings.h.in,v 1.2 2009/10/30 09:18:18 nanard Exp $ */\n+/* Project: miniupnp\n+ * http://miniupnp.free.fr/ or http://miniupnp.tuxfamily.org/\n+ * Author: Thomas Bernard\n+ * Copyright (c) 2005-2009 Thomas Bernard\n+ * This software is subjects to the conditions detailed\n+ * in the LICENCE file provided within this distribution */\n+#ifndef __MINIUPNPCSTRINGS_H__\n+#define __MINIUPNPCSTRINGS_H__\n+\n+#define OS_STRING \"OS/version\"\n+#define MINIUPNPC_VERSION_STRING \"1.5\"\n+\n+#endif\n+"
      },
      {
        "sha": "89afe2e527890a7dd8569365e190c948d76ef9d5",
        "filename": "miniupnpc/miniwget.c",
        "status": "added",
        "additions": 459,
        "deletions": 0,
        "changes": 459,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/miniwget.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/miniwget.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/miniupnpc/miniwget.c?ref=b94b7b05a7b1d27e28ca9a8684877ca605d70256",
        "patch": "@@ -0,0 +1,459 @@\n+/* $Id: miniwget.c,v 1.41 2010/12/12 23:52:02 nanard Exp $ */\n+/* Project : miniupnp\n+ * Author : Thomas Bernard\n+ * Copyright (c) 2005-2010 Thomas Bernard\n+ * This software is subject to the conditions detailed in the\n+ * LICENCE file provided in this distribution. */\n+ \n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <ctype.h>\n+#include \"miniupnpc.h\"\n+#ifdef WIN32\n+#include <winsock2.h>\n+#include <ws2tcpip.h>\n+#include <io.h>\n+#define MAXHOSTNAMELEN 64\n+#define MIN(x,y) (((x)<(y))?(x):(y))\n+#define snprintf _snprintf\n+#define socklen_t int\n+#if defined(_MSC_VER) && (_MSC_VER >= 1400)\n+#define strncasecmp _memicmp\n+#else /* defined(_MSC_VER) && (_MSC_VER >= 1400) */\n+#define strncasecmp memicmp\n+#endif /* defined(_MSC_VER) && (_MSC_VER >= 1400) */\n+#else /* #ifdef WIN32 */\n+#include <unistd.h>\n+#include <sys/param.h>\n+#if defined(__amigaos__) && !defined(__amigaos4__)\n+#define socklen_t int\n+#else /* #if defined(__amigaos__) && !defined(__amigaos4__) */\n+#include <sys/select.h>\n+#endif /* #else defined(__amigaos__) && !defined(__amigaos4__) */\n+#include <sys/socket.h>\n+#include <arpa/inet.h>\n+#include <netdb.h>\n+#define closesocket close\n+/* defining MINIUPNPC_IGNORE_EINTR enable the ignore of interruptions\n+ * during the connect() call */\n+#define MINIUPNPC_IGNORE_EINTR\n+#endif /* #else WIN32 */\n+#if defined(__sun) || defined(sun)\n+#define MIN(x,y) (((x)<(y))?(x):(y))\n+#endif\n+\n+#include \"miniupnpcstrings.h\"\n+#include \"miniwget.h\"\n+#include \"connecthostport.h\"\n+\n+/*\n+ * Read a HTTP response from a socket.\n+ * Process Content-Length and Transfer-encoding headers.\n+ */\n+void *\n+getHTTPResponse(int s, int * size)\n+{\n+\tchar buf[2048];\n+\tint n;\n+\tint headers = 1;\n+\tint chunked = 0;\n+\tint content_length = -1;\n+\tunsigned int chunksize = 0;\n+\tunsigned int bytestocopy = 0;\n+\t/* buffers : */\n+\tchar * header_buf;\n+\tint header_buf_len = 2048;\n+\tint header_buf_used = 0;\n+\tchar * content_buf;\n+\tint content_buf_len = 2048;\n+\tint content_buf_used = 0;\n+\n+\theader_buf = malloc(header_buf_len);\n+\tcontent_buf = malloc(content_buf_len);\n+\n+\twhile((n = ReceiveData(s, buf, 2048, 5000)) > 0)\n+\t{\n+\t\tif(headers)\n+\t\t{\n+\t\t\tint i;\n+\t\t\tint linestart=0;\n+\t\t\tint colon=0;\n+\t\t\tint valuestart=0;\n+\t\t\tif(header_buf_used + n > header_buf_len) {\n+\t\t\t\theader_buf = realloc(header_buf, header_buf_used + n);\n+\t\t\t\theader_buf_len = header_buf_used + n;\n+\t\t\t}\n+\t\t\tmemcpy(header_buf + header_buf_used, buf, n);\n+\t\t\theader_buf_used += n;\n+\t\t\tfor(i = 0; i < (header_buf_used-3); i++) {\n+\t\t\t\tif(colon <= linestart && header_buf[i]==':')\n+\t\t\t\t{\n+\t\t\t\t\tcolon = i;\n+\t\t\t\t\twhile(i < (n-3)\n+\t\t\t\t\t      && (header_buf[i+1] == ' ' || header_buf[i+1] == '\\t'))\n+\t\t\t\t\t\ti++;\n+\t\t\t\t\tvaluestart = i + 1;\n+\t\t\t\t}\n+\t\t\t\t/* detecting end of line */\n+\t\t\t\telse if(header_buf[i]=='\\r' && header_buf[i+1]=='\\n')\n+\t\t\t\t{\n+\t\t\t\t\tif(colon > linestart && valuestart > colon)\n+\t\t\t\t\t{\n+#ifdef DEBUG\n+\t\t\t\t\t\tprintf(\"header='%.*s', value='%.*s'\\n\",\n+\t\t\t\t\t\t       colon-linestart, header_buf+linestart,\n+\t\t\t\t\t\t       i-valuestart, header_buf+valuestart);\n+#endif\n+\t\t\t\t\t\tif(0==strncasecmp(header_buf+linestart, \"content-length\", colon-linestart))\n+\t\t\t\t\t\t{\n+\t\t\t\t\t\t\tcontent_length = atoi(header_buf+valuestart);\n+#ifdef DEBUG\n+\t\t\t\t\t\t\tprintf(\"Content-Length: %d\\n\", content_length);\n+#endif\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\telse if(0==strncasecmp(header_buf+linestart, \"transfer-encoding\", colon-linestart)\n+\t\t\t\t\t\t   && 0==strncasecmp(buf+valuestart, \"chunked\", 7))\n+\t\t\t\t\t\t{\n+#ifdef DEBUG\n+\t\t\t\t\t\t\tprintf(\"chunked transfer-encoding!\\n\");\n+#endif\n+\t\t\t\t\t\t\tchunked = 1;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tlinestart = i+2;\n+\t\t\t\t\tcolon = linestart;\n+\t\t\t\t\tvaluestart = 0;\n+\t\t\t\t} \n+\t\t\t\t/* searching for the end of the HTTP headers */\n+\t\t\t\tif(header_buf[i]=='\\r' && header_buf[i+1]=='\\n'\n+\t\t\t\t   && header_buf[i+2]=='\\r' && header_buf[i+3]=='\\n')\n+\t\t\t\t{\n+\t\t\t\t\theaders = 0;\t/* end */\n+\t\t\t\t\ti += 4;\n+\t\t\t\t\tif(i < header_buf_used)\n+\t\t\t\t\t{\n+\t\t\t\t\t\tif(chunked)\n+\t\t\t\t\t\t{\n+\t\t\t\t\t\t\twhile(i<header_buf_used)\n+\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\twhile(i<header_buf_used && isxdigit(header_buf[i]))\n+\t\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\t\tif(header_buf[i] >= '0' && header_buf[i] <= '9')\n+\t\t\t\t\t\t\t\t\t\tchunksize = (chunksize << 4) + (header_buf[i] - '0');\n+\t\t\t\t\t\t\t\t\telse\n+\t\t\t\t\t\t\t\t\t\tchunksize = (chunksize << 4) + ((header_buf[i] | 32) - 'a' + 10);\n+\t\t\t\t\t\t\t\t\ti++;\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t/* discarding chunk-extension */\n+\t\t\t\t\t\t\t\twhile(i < header_buf_used && header_buf[i] != '\\r') i++;\n+\t\t\t\t\t\t\t\tif(i < header_buf_used && header_buf[i] == '\\r') i++;\n+\t\t\t\t\t\t\t\tif(i < header_buf_used && header_buf[i] == '\\n') i++;\n+#ifdef DEBUG\n+\t\t\t\t\t\t\t\tprintf(\"chunksize = %u (%x)\\n\", chunksize, chunksize);\n+#endif\n+\t\t\t\t\t\t\t\tif(chunksize == 0)\n+\t\t\t\t\t\t\t\t{\n+#ifdef DEBUG\n+\t\t\t\t\t\t\t\t\tprintf(\"end of HTTP content !\\n\");\n+#endif\n+\t\t\t\t\t\t\t\t\tgoto end_of_stream;\t\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tbytestocopy = ((int)chunksize < header_buf_used - i)?chunksize:(header_buf_used - i);\n+#ifdef DEBUG\n+\t\t\t\t\t\t\t\tprintf(\"chunksize=%u bytestocopy=%u (i=%d header_buf_used=%d)\\n\",\n+\t\t\t\t\t\t\t\t       chunksize, bytestocopy, i, header_buf_used);\n+#endif\n+\t\t\t\t\t\t\t\tif(content_buf_len < (int)(content_buf_used + bytestocopy))\n+\t\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\t\tcontent_buf = realloc(content_buf, content_buf_used + bytestocopy);\n+\t\t\t\t\t\t\t\t\tcontent_buf_len = content_buf_used + bytestocopy;\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tmemcpy(content_buf + content_buf_used, header_buf + i, bytestocopy);\n+\t\t\t\t\t\t\t\tcontent_buf_used += bytestocopy;\n+\t\t\t\t\t\t\t\tchunksize -= bytestocopy;\n+\t\t\t\t\t\t\t\ti += bytestocopy;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\telse\n+\t\t\t\t\t\t{\n+\t\t\t\t\t\t\tif(content_buf_len < header_buf_used - i)\n+\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\tcontent_buf = realloc(content_buf, header_buf_used - i);\n+\t\t\t\t\t\t\t\tcontent_buf_len = header_buf_used - i;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tmemcpy(content_buf, header_buf + i, header_buf_used - i);\n+\t\t\t\t\t\t\tcontent_buf_used = header_buf_used - i;\n+\t\t\t\t\t\t\ti = header_buf_used;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\telse\n+\t\t{\n+\t\t\t/* content */\n+\t\t\tif(chunked)\n+\t\t\t{\n+\t\t\t\tint i = 0;\n+\t\t\t\twhile(i < n)\n+\t\t\t\t{\n+\t\t\t\t\tif(chunksize == 0)\n+\t\t\t\t\t{\n+\t\t\t\t\t\t/* reading chunk size */\n+\t\t\t\t\t\tif(i<n && buf[i] == '\\r') i++;\n+\t\t\t\t\t\tif(i<n && buf[i] == '\\n') i++;\n+\t\t\t\t\t\twhile(i<n && isxdigit(buf[i]))\n+\t\t\t\t\t\t{\n+\t\t\t\t\t\t\tif(buf[i] >= '0' && buf[i] <= '9')\n+\t\t\t\t\t\t\t\tchunksize = (chunksize << 4) + (buf[i] - '0');\n+\t\t\t\t\t\t\telse\n+\t\t\t\t\t\t\t\tchunksize = (chunksize << 4) + ((buf[i] | 32) - 'a' + 10);\n+\t\t\t\t\t\t\ti++;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\twhile(i<n && buf[i] != '\\r') i++; /* discarding chunk-extension */\n+\t\t\t\t\t\tif(i<n && buf[i] == '\\r') i++;\n+\t\t\t\t\t\tif(i<n && buf[i] == '\\n') i++;\n+#ifdef DEBUG\n+\t\t\t\t\t\tprintf(\"chunksize = %u (%x)\\n\", chunksize, chunksize);\n+#endif\n+\t\t\t\t\t\tif(chunksize == 0)\n+\t\t\t\t\t\t{\n+#ifdef DEBUG\n+\t\t\t\t\t\t\tprintf(\"end of HTTP content - %d %d\\n\", i, n);\n+\t\t\t\t\t\t\t/*printf(\"'%.*s'\\n\", n-i, buf+i);*/\n+#endif\n+\t\t\t\t\t\t\tgoto end_of_stream;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tbytestocopy = ((int)chunksize < n - i)?chunksize:(n - i);\n+\t\t\t\t\tif((int)(content_buf_used + bytestocopy) > content_buf_len)\n+\t\t\t\t\t{\n+\t\t\t\t\t\tcontent_buf = (char *)realloc((void *)content_buf, \n+\t\t\t\t\t\t                              content_buf_used + bytestocopy);\n+\t\t\t\t\t\tcontent_buf_len = content_buf_used + bytestocopy;\n+\t\t\t\t\t}\n+\t\t\t\t\tmemcpy(content_buf + content_buf_used, buf + i, bytestocopy);\n+\t\t\t\t\tcontent_buf_used += bytestocopy;\n+\t\t\t\t\ti += bytestocopy;\n+\t\t\t\t\tchunksize -= bytestocopy;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\telse\n+\t\t\t{\n+\t\t\t\tif(content_buf_used + n > content_buf_len)\n+\t\t\t\t{\n+\t\t\t\t\tcontent_buf = (char *)realloc((void *)content_buf, \n+\t\t\t\t\t                              content_buf_used + n);\n+\t\t\t\t\tcontent_buf_len = content_buf_used + n;\n+\t\t\t\t}\n+\t\t\t\tmemcpy(content_buf + content_buf_used, buf, n);\n+\t\t\t\tcontent_buf_used += n;\n+\t\t\t}\n+\t\t}\n+\t\tif(content_length > 0 && content_buf_used >= content_length)\n+\t\t{\n+#ifdef DEBUG\n+\t\t\tprintf(\"End of HTTP content\\n\");\n+#endif\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+end_of_stream:\n+\tfree(header_buf); header_buf = NULL;\n+\t*size = content_buf_used;\n+\tif(content_buf_used == 0)\n+\t{\n+\t\tfree(content_buf);\n+\t\tcontent_buf = NULL;\n+\t}\n+\treturn content_buf;\n+}\n+\n+/* miniwget3() :\n+ * do all the work.\n+ * Return NULL if something failed. */\n+static void *\n+miniwget3(const char * url, const char * host,\n+\t\t  unsigned short port, const char * path,\n+\t\t  int * size, char * addr_str, int addr_str_len, const char * httpversion)\n+{\n+\tchar buf[2048];\n+    int s;\n+\tint n;\n+\tint len;\n+\tint sent;\n+\n+\t*size = 0;\n+\ts = connecthostport(host, port);\n+\tif(s < 0)\n+\t\treturn NULL;\n+\n+\t/* get address for caller ! */\n+\tif(addr_str)\n+\t{\n+\t\tstruct sockaddr saddr;\n+\t\tsocklen_t saddrlen;\n+\n+\t\tsaddrlen = sizeof(saddr);\n+\t\tif(getsockname(s, &saddr, &saddrlen) < 0)\n+\t\t{\n+\t\t\tperror(\"getsockname\");\n+\t\t}\n+\t\telse\n+\t\t{\n+#if defined(__amigaos__) && !defined(__amigaos4__)\n+\t/* using INT WINAPI WSAAddressToStringA(LPSOCKADDR, DWORD, LPWSAPROTOCOL_INFOA, LPSTR, LPDWORD);\n+     * But his function make a string with the port :  nn.nn.nn.nn:port */\n+/*\t\tif(WSAAddressToStringA((SOCKADDR *)&saddr, sizeof(saddr),\n+                            NULL, addr_str, (DWORD *)&addr_str_len))\n+\t\t{\n+\t\t    printf(\"WSAAddressToStringA() failed : %d\\n\", WSAGetLastError());\n+\t\t}*/\n+\t\t\tstrncpy(addr_str, inet_ntoa(((struct sockaddr_in *)&saddr)->sin_addr), addr_str_len);\n+#else\n+\t\t\t/*inet_ntop(AF_INET, &saddr.sin_addr, addr_str, addr_str_len);*/\n+\t\t\tn = getnameinfo(&saddr, saddrlen,\n+\t\t\t                addr_str, addr_str_len,\n+\t\t\t                NULL, 0,\n+\t\t\t                NI_NUMERICHOST | NI_NUMERICSERV);\n+\t\t\tif(n != 0) {\n+#ifdef WIN32\n+\t\t\t\tfprintf(stderr, \"getnameinfo() failed : %d\\n\", n);\n+#else\n+\t\t\t\tfprintf(stderr, \"getnameinfo() failed : %s\\n\", gai_strerror(n));\n+#endif\n+\t\t\t}\n+#endif\n+\t\t}\n+#ifdef DEBUG\n+\t\tprintf(\"address miniwget : %s\\n\", addr_str);\n+#endif\n+\t}\n+\n+\tlen = snprintf(buf, sizeof(buf),\n+                 \"GET %s HTTP/%s\\r\\n\"\n+\t\t\t     \"Host: %s:%d\\r\\n\"\n+\t\t\t\t \"Connection: Close\\r\\n\"\n+\t\t\t\t \"User-Agent: \" OS_STRING \", UPnP/1.0, MiniUPnPc/\" MINIUPNPC_VERSION_STRING \"\\r\\n\"\n+\n+\t\t\t\t \"\\r\\n\",\n+\t\t\t   path, httpversion, host, port);\n+\tsent = 0;\n+\t/* sending the HTTP request */\n+\twhile(sent < len)\n+\t{\n+\t\tn = send(s, buf+sent, len-sent, 0);\n+\t\tif(n < 0)\n+\t\t{\n+\t\t\tperror(\"send\");\n+\t\t\tclosesocket(s);\n+\t\t\treturn NULL;\n+\t\t}\n+\t\telse\n+\t\t{\n+\t\t\tsent += n;\n+\t\t}\n+\t}\n+\treturn getHTTPResponse(s, size);\n+}\n+\n+/* miniwget2() :\n+ * Call miniwget3(); retry with HTTP/1.1 if 1.0 fails. */\n+static void *\n+miniwget2(const char * url, const char * host,\n+\t\t  unsigned short port, const char * path,\n+\t\t  int * size, char * addr_str, int addr_str_len)\n+{\n+\tchar * respbuffer;\n+\n+\trespbuffer = miniwget3(url, host, port, path, size, addr_str, addr_str_len, \"1.1\");\n+/*\n+\trespbuffer = miniwget3(url, host, port, path, size, addr_str, addr_str_len, \"1.0\");\n+\tif (*size == 0)\n+\t{\n+#ifdef DEBUG\n+\t\tprintf(\"Retrying with HTTP/1.1\\n\");\n+#endif\n+\t\tfree(respbuffer);\n+\t\trespbuffer = miniwget3(url, host, port, path, size, addr_str, addr_str_len, \"1.1\");\n+\t}\n+*/\n+\treturn respbuffer;\n+}\n+\n+\n+\n+\n+/* parseURL()\n+ * arguments :\n+ *   url :\t\tsource string not modified\n+ *   hostname :\thostname destination string (size of MAXHOSTNAMELEN+1)\n+ *   port :\t\tport (destination)\n+ *   path :\t\tpointer to the path part of the URL \n+ *\n+ * Return values :\n+ *    0 - Failure\n+ *    1 - Success         */\n+int parseURL(const char * url, char * hostname, unsigned short * port, char * * path)\n+{\n+\tchar * p1, *p2, *p3;\n+\tp1 = strstr(url, \"://\");\n+\tif(!p1)\n+\t\treturn 0;\n+\tp1 += 3;\n+\tif(  (url[0]!='h') || (url[1]!='t')\n+\t   ||(url[2]!='t') || (url[3]!='p'))\n+\t\treturn 0;\n+\tp2 = strchr(p1, ':');\n+\tp3 = strchr(p1, '/');\n+\tif(!p3)\n+\t\treturn 0;\n+\tmemset(hostname, 0, MAXHOSTNAMELEN + 1);\n+\tif(!p2 || (p2>p3))\n+\t{\n+\t\tstrncpy(hostname, p1, MIN(MAXHOSTNAMELEN, (int)(p3-p1)));\n+\t\t*port = 80;\n+\t}\n+\telse\n+\t{\n+\t\tstrncpy(hostname, p1, MIN(MAXHOSTNAMELEN, (int)(p2-p1)));\n+\t\t*port = 0;\n+\t\tp2++;\n+\t\twhile( (*p2 >= '0') && (*p2 <= '9'))\n+\t\t{\n+\t\t\t*port *= 10;\n+\t\t\t*port += (unsigned short)(*p2 - '0');\n+\t\t\tp2++;\n+\t\t}\n+\t}\n+\t*path = p3;\n+\treturn 1;\n+}\n+\n+void * miniwget(const char * url, int * size)\n+{\n+\tunsigned short port;\n+\tchar * path;\n+\t/* protocol://host:port/chemin */\n+\tchar hostname[MAXHOSTNAMELEN+1];\n+\t*size = 0;\n+\tif(!parseURL(url, hostname, &port, &path))\n+\t\treturn NULL;\n+\treturn miniwget2(url, hostname, port, path, size, 0, 0);\n+}\n+\n+void * miniwget_getaddr(const char * url, int * size, char * addr, int addrlen)\n+{\n+\tunsigned short port;\n+\tchar * path;\n+\t/* protocol://host:port/chemin */\n+\tchar hostname[MAXHOSTNAMELEN+1];\n+\t*size = 0;\n+\tif(addr)\n+\t\taddr[0] = '\\0';\n+\tif(!parseURL(url, hostname, &port, &path))\n+\t\treturn NULL;\n+\treturn miniwget2(url, hostname, port, path, size, addr, addrlen);\n+}\n+"
      },
      {
        "sha": "8314b4000316225574d2c10184d26c5f5bb12ed5",
        "filename": "miniupnpc/miniwget.h",
        "status": "added",
        "additions": 30,
        "deletions": 0,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/miniwget.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/miniwget.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/miniupnpc/miniwget.h?ref=b94b7b05a7b1d27e28ca9a8684877ca605d70256",
        "patch": "@@ -0,0 +1,30 @@\n+/* $Id: miniwget.h,v 1.6 2010/12/09 16:11:33 nanard Exp $ */\n+/* Project : miniupnp\n+ * Author : Thomas Bernard\n+ * Copyright (c) 2005 Thomas Bernard\n+ * This software is subject to the conditions detailed in the\n+ * LICENCE file provided in this distribution.\n+ * */\n+#ifndef __MINIWGET_H__\n+#define __MINIWGET_H__\n+\n+#include \"declspec.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+LIBSPEC void * getHTTPResponse(int s, int * size);\n+\n+LIBSPEC void * miniwget(const char *, int *);\n+\n+LIBSPEC void * miniwget_getaddr(const char *, int *, char *, int);\n+\n+int parseURL(const char *, char *, unsigned short *, char * *);\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif\n+"
      },
      {
        "sha": "83c6acd975ea01e47f0d0bde824cac0c61f2de30",
        "filename": "miniupnpc/minixml.c",
        "status": "added",
        "additions": 191,
        "deletions": 0,
        "changes": 191,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/minixml.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/minixml.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/miniupnpc/minixml.c?ref=b94b7b05a7b1d27e28ca9a8684877ca605d70256",
        "patch": "@@ -0,0 +1,191 @@\n+/* $Id: minixml.c,v 1.7 2009/10/10 19:15:35 nanard Exp $ */\n+/* minixml.c : the minimum size a xml parser can be ! */\n+/* Project : miniupnp\n+ * webpage: http://miniupnp.free.fr/ or http://miniupnp.tuxfamily.org/\n+ * Author : Thomas Bernard\n+\n+Copyright (c) 2005-2009, Thomas BERNARD \n+All rights reserved.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are met:\n+\n+    * Redistributions of source code must retain the above copyright notice,\n+      this list of conditions and the following disclaimer.\n+    * Redistributions in binary form must reproduce the above copyright notice,\n+      this list of conditions and the following disclaimer in the documentation\n+      and/or other materials provided with the distribution.\n+    * The name of the author may not be used to endorse or promote products\n+\t  derived from this software without specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.\n+*/\n+#include \"minixml.h\"\n+\n+/* parseatt : used to parse the argument list\n+ * return 0 (false) in case of success and -1 (true) if the end\n+ * of the xmlbuffer is reached. */\n+static int parseatt(struct xmlparser * p)\n+{\n+\tconst char * attname;\n+\tint attnamelen;\n+\tconst char * attvalue;\n+\tint attvaluelen;\n+\twhile(p->xml < p->xmlend)\n+\t{\n+\t\tif(*p->xml=='/' || *p->xml=='>')\n+\t\t\treturn 0;\n+\t\tif( !IS_WHITE_SPACE(*p->xml) )\n+\t\t{\n+\t\t\tchar sep;\n+\t\t\tattname = p->xml;\n+\t\t\tattnamelen = 0;\n+\t\t\twhile(*p->xml!='=' && !IS_WHITE_SPACE(*p->xml) )\n+\t\t\t{\n+\t\t\t\tattnamelen++; p->xml++;\n+\t\t\t\tif(p->xml >= p->xmlend)\n+\t\t\t\t\treturn -1;\n+\t\t\t}\n+\t\t\twhile(*(p->xml++) != '=')\n+\t\t\t{\n+\t\t\t\tif(p->xml >= p->xmlend)\n+\t\t\t\t\treturn -1;\n+\t\t\t}\n+\t\t\twhile(IS_WHITE_SPACE(*p->xml))\n+\t\t\t{\n+\t\t\t\tp->xml++;\n+\t\t\t\tif(p->xml >= p->xmlend)\n+\t\t\t\t\treturn -1;\n+\t\t\t}\n+\t\t\tsep = *p->xml;\n+\t\t\tif(sep=='\\'' || sep=='\\\"')\n+\t\t\t{\n+\t\t\t\tp->xml++;\n+\t\t\t\tif(p->xml >= p->xmlend)\n+\t\t\t\t\treturn -1;\n+\t\t\t\tattvalue = p->xml;\n+\t\t\t\tattvaluelen = 0;\n+\t\t\t\twhile(*p->xml != sep)\n+\t\t\t\t{\n+\t\t\t\t\tattvaluelen++; p->xml++;\n+\t\t\t\t\tif(p->xml >= p->xmlend)\n+\t\t\t\t\t\treturn -1;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\telse\n+\t\t\t{\n+\t\t\t\tattvalue = p->xml;\n+\t\t\t\tattvaluelen = 0;\n+\t\t\t\twhile(   !IS_WHITE_SPACE(*p->xml)\n+\t\t\t\t\t  && *p->xml != '>' && *p->xml != '/')\n+\t\t\t\t{\n+\t\t\t\t\tattvaluelen++; p->xml++;\n+\t\t\t\t\tif(p->xml >= p->xmlend)\n+\t\t\t\t\t\treturn -1;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\t/*printf(\"%.*s='%.*s'\\n\",\n+\t\t\t       attnamelen, attname, attvaluelen, attvalue);*/\n+\t\t\tif(p->attfunc)\n+\t\t\t\tp->attfunc(p->data, attname, attnamelen, attvalue, attvaluelen);\n+\t\t}\n+\t\tp->xml++;\n+\t}\n+\treturn -1;\n+}\n+\n+/* parseelt parse the xml stream and\n+ * call the callback functions when needed... */\n+static void parseelt(struct xmlparser * p)\n+{\n+\tint i;\n+\tconst char * elementname;\n+\twhile(p->xml < (p->xmlend - 1))\n+\t{\n+\t\tif((p->xml)[0]=='<' && (p->xml)[1]!='?')\n+\t\t{\n+\t\t\ti = 0; elementname = ++p->xml;\n+\t\t\twhile( !IS_WHITE_SPACE(*p->xml)\n+\t\t\t\t  && (*p->xml!='>') && (*p->xml!='/')\n+\t\t\t\t )\n+\t\t\t{\n+\t\t\t\ti++; p->xml++;\n+\t\t\t\tif (p->xml >= p->xmlend)\n+\t\t\t\t\treturn;\n+\t\t\t\t/* to ignore namespace : */\n+\t\t\t\tif(*p->xml==':')\n+\t\t\t\t{\n+\t\t\t\t\ti = 0;\n+\t\t\t\t\telementname = ++p->xml;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif(i>0)\n+\t\t\t{\n+\t\t\t\tif(p->starteltfunc)\n+\t\t\t\t\tp->starteltfunc(p->data, elementname, i);\n+\t\t\t\tif(parseatt(p))\n+\t\t\t\t\treturn;\n+\t\t\t\tif(*p->xml!='/')\n+\t\t\t\t{\n+\t\t\t\t\tconst char * data;\n+\t\t\t\t\ti = 0; data = ++p->xml;\n+\t\t\t\t\tif (p->xml >= p->xmlend)\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\twhile( IS_WHITE_SPACE(*p->xml) )\n+\t\t\t\t\t{\n+\t\t\t\t\t\tp->xml++;\n+\t\t\t\t\t\tif (p->xml >= p->xmlend)\n+\t\t\t\t\t\t\treturn;\n+\t\t\t\t\t}\n+\t\t\t\t\twhile(*p->xml!='<')\n+\t\t\t\t\t{\n+\t\t\t\t\t\ti++; p->xml++;\n+\t\t\t\t\t\tif (p->xml >= p->xmlend)\n+\t\t\t\t\t\t\treturn;\n+\t\t\t\t\t}\n+\t\t\t\t\tif(i>0 && p->datafunc)\n+\t\t\t\t\t\tp->datafunc(p->data, data, i);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\telse if(*p->xml == '/')\n+\t\t\t{\n+\t\t\t\ti = 0; elementname = ++p->xml;\n+\t\t\t\tif (p->xml >= p->xmlend)\n+\t\t\t\t\treturn;\n+\t\t\t\twhile((*p->xml != '>'))\n+\t\t\t\t{\n+\t\t\t\t\ti++; p->xml++;\n+\t\t\t\t\tif (p->xml >= p->xmlend)\n+\t\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t\tif(p->endeltfunc)\n+\t\t\t\t\tp->endeltfunc(p->data, elementname, i);\n+\t\t\t\tp->xml++;\n+\t\t\t}\n+\t\t}\n+\t\telse\n+\t\t{\n+\t\t\tp->xml++;\n+\t\t}\n+\t}\n+}\n+\n+/* the parser must be initialized before calling this function */\n+void parsexml(struct xmlparser * parser)\n+{\n+\tparser->xml = parser->xmlstart;\n+\tparser->xmlend = parser->xmlstart + parser->xmlsize;\n+\tparseelt(parser);\n+}\n+\n+"
      },
      {
        "sha": "857c70ee93a51152201fd545c9cdaa88a2dad39d",
        "filename": "miniupnpc/minixml.h",
        "status": "added",
        "additions": 37,
        "deletions": 0,
        "changes": 37,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/minixml.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/minixml.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/miniupnpc/minixml.h?ref=b94b7b05a7b1d27e28ca9a8684877ca605d70256",
        "patch": "@@ -0,0 +1,37 @@\n+/* $Id: minixml.h,v 1.6 2006/11/30 11:47:21 nanard Exp $ */\n+/* minimal xml parser\n+ *\n+ * Project : miniupnp\n+ * Website : http://miniupnp.free.fr/\n+ * Author : Thomas Bernard\n+ * Copyright (c) 2005 Thomas Bernard\n+ * This software is subject to the conditions detailed in the\n+ * LICENCE file provided in this distribution.\n+ * */\n+#ifndef __MINIXML_H__\n+#define __MINIXML_H__\n+#define IS_WHITE_SPACE(c) ((c==' ') || (c=='\\t') || (c=='\\r') || (c=='\\n'))\n+\n+/* if a callback function pointer is set to NULL,\n+ * the function is not called */\n+struct xmlparser {\n+\tconst char *xmlstart;\n+\tconst char *xmlend;\n+\tconst char *xml;\t/* pointer to current character */\n+\tint xmlsize;\n+\tvoid * data;\n+\tvoid (*starteltfunc) (void *, const char *, int);\n+\tvoid (*endeltfunc) (void *, const char *, int);\n+\tvoid (*datafunc) (void *, const char *, int);\n+\tvoid (*attfunc) (void *, const char *, int, const char *, int);\n+};\n+\n+/* parsexml()\n+ * the xmlparser structure must be initialized before the call\n+ * the following structure members have to be initialized :\n+ * xmlstart, xmlsize, data, *func\n+ * xml is for internal usage, xmlend is computed automatically */\n+void parsexml(struct xmlparser *);\n+\n+#endif\n+"
      },
      {
        "sha": "e7967befad08463db21adc20870e1026c49d2b30",
        "filename": "miniupnpc/minixmlvalid.c",
        "status": "added",
        "additions": 149,
        "deletions": 0,
        "changes": 149,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/minixmlvalid.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/minixmlvalid.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/miniupnpc/minixmlvalid.c?ref=b94b7b05a7b1d27e28ca9a8684877ca605d70256",
        "patch": "@@ -0,0 +1,149 @@\n+/* $Id: minixmlvalid.c,v 1.2 2006/11/30 11:31:55 nanard Exp $ */\n+/* MiniUPnP Project\n+ * http://miniupnp.tuxfamily.org/ or http://miniupnp.free.fr/\n+ * minixmlvalid.c :\n+ * validation program for the minixml parser\n+ *\n+ * (c) 2006 Thomas Bernard */\n+\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <string.h>\n+#include \"minixml.h\"\n+\n+/* xml event structure */\n+struct event {\n+\tenum { ELTSTART, ELTEND, ATT, CHARDATA } type;\n+\tconst char * data;\n+\tint len;\n+};\n+\n+struct eventlist {\n+\tint n;\n+\tstruct event * events;\n+};\n+\n+/* compare 2 xml event lists\n+ * return 0 if the two lists are equals */\n+int evtlistcmp(struct eventlist * a, struct eventlist * b)\n+{\n+\tint i;\n+\tstruct event * ae, * be;\n+\tif(a->n != b->n)\n+\t\treturn 1;\n+\tfor(i=0; i<a->n; i++)\n+\t{\n+\t\tae = a->events + i;\n+\t\tbe = b->events + i;\n+\t\tif(  (ae->type != be->type)\n+\t\t   ||(ae->len != be->len)\n+\t\t   ||memcmp(ae->data, be->data, ae->len))\n+\t\t{\n+\t\t\tprintf(\"Found a difference : %d '%.*s' != %d '%.*s'\\n\",\n+\t\t\t       ae->type, ae->len, ae->data,\n+\t\t\t       be->type, be->len, be->data);\n+\t\t\treturn 1;\n+\t\t}\n+\t}\n+\treturn 0;\n+}\n+\n+/* Test data */\n+static const char xmldata[] =\n+\"<xmlroot>\\n\"\n+\" <elt1 att1=\\\"attvalue1\\\" att2=\\\"attvalue2\\\">\"\n+\"character data\"\n+\"</elt1> \\n \\t\"\n+\"<elt1b/>\"\n+\"<elt2a> \\t<elt2b>chardata1</elt2b><elt2b>chardata2</elt2b></elt2a>\"\n+\"</xmlroot>\";\n+\n+static const struct event evtref[] =\n+{\n+\t{ELTSTART, \"xmlroot\", 7},\n+\t{ELTSTART, \"elt1\", 4},\n+\t/* attributes */\n+\t{CHARDATA, \"character data\", 14},\n+\t{ELTEND, \"elt1\", 4},\n+\t{ELTSTART, \"elt1b\", 5},\n+\t{ELTSTART, \"elt2a\", 5},\n+\t{ELTSTART, \"elt2b\", 5},\n+\t{CHARDATA, \"chardata1\", 9},\n+\t{ELTEND, \"elt2b\", 5},\n+\t{ELTSTART, \"elt2b\", 5},\n+\t{CHARDATA, \"chardata2\", 9},\n+\t{ELTEND, \"elt2b\", 5},\n+\t{ELTEND, \"elt2a\", 5},\n+\t{ELTEND, \"xmlroot\", 7}\n+};\t\n+\n+void startelt(void * data, const char * p, int l)\n+{\n+\tstruct eventlist * evtlist = data;\n+\tstruct event * evt;\n+\tevt = evtlist->events + evtlist->n;\n+\t/*printf(\"startelt : %.*s\\n\", l, p);*/\n+\tevt->type = ELTSTART;\n+\tevt->data = p;\n+\tevt->len = l;\n+\tevtlist->n++;\n+}\n+\n+void endelt(void * data, const char * p, int l)\n+{\n+\tstruct eventlist * evtlist = data;\n+\tstruct event * evt;\n+\tevt = evtlist->events + evtlist->n;\n+\t/*printf(\"endelt : %.*s\\n\", l, p);*/\n+\tevt->type = ELTEND;\n+\tevt->data = p;\n+\tevt->len = l;\n+\tevtlist->n++;\n+}\n+\n+void chardata(void * data, const char * p, int l)\n+{\n+\tstruct eventlist * evtlist = data;\n+\tstruct event * evt;\n+\tevt = evtlist->events + evtlist->n;\n+\t/*printf(\"chardata : '%.*s'\\n\", l, p);*/\n+\tevt->type = CHARDATA;\n+\tevt->data = p;\n+\tevt->len = l;\n+\tevtlist->n++;\n+}\n+\n+int testxmlparser(const char * xml, int size)\n+{\n+\tint r;\n+\tstruct eventlist evtlist;\n+\tstruct eventlist evtlistref;\n+\tstruct xmlparser parser;\n+\tevtlist.n = 0;\n+\tevtlist.events = malloc(sizeof(struct event)*100);\n+\tmemset(&parser, 0, sizeof(parser));\n+\tparser.xmlstart = xml;\n+\tparser.xmlsize = size;\n+\tparser.data = &evtlist;\n+\tparser.starteltfunc = startelt;\n+\tparser.endeltfunc = endelt;\n+\tparser.datafunc = chardata;\n+\tparsexml(&parser);\n+\tprintf(\"%d events\\n\", evtlist.n);\n+\t/* compare */\n+\tevtlistref.n = sizeof(evtref)/sizeof(struct event);\n+\tevtlistref.events = (struct event *)evtref;\n+\tr = evtlistcmp(&evtlistref, &evtlist);\n+\tfree(evtlist.events);\n+\treturn r;\n+}\n+\n+int main(int argc, char * * argv)\n+{\n+\tint r;\n+\tr = testxmlparser(xmldata, sizeof(xmldata)-1);\n+\tif(r)\n+\t\tprintf(\"minixml validation test failed\\n\");\n+\treturn r;\n+}\n+"
      },
      {
        "sha": "b3da1919ed124590f9a2e8d7b719e46fe8697417",
        "filename": "miniupnpc/msvc/miniupnpc.sln",
        "status": "added",
        "additions": 29,
        "deletions": 0,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/msvc/miniupnpc.sln",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/msvc/miniupnpc.sln",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/miniupnpc/msvc/miniupnpc.sln?ref=b94b7b05a7b1d27e28ca9a8684877ca605d70256",
        "patch": "@@ -0,0 +1,29 @@\n+\ufeff\n+Microsoft Visual Studio Solution File, Format Version 10.00\n+# Visual C++ Express 2008\n+Project(\"{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}\") = \"miniupnpc\", \"miniupnpc.vcproj\", \"{D28CE435-CB33-4BAE-8A52-C6EF915956F5}\"\n+EndProject\n+Project(\"{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}\") = \"upnpc-static\", \"upnpc-static.vcproj\", \"{469E1CF6-08A2-4B7B-A2AA-5BDB089857C1}\"\n+\tProjectSection(ProjectDependencies) = postProject\n+\t\t{D28CE435-CB33-4BAE-8A52-C6EF915956F5} = {D28CE435-CB33-4BAE-8A52-C6EF915956F5}\n+\tEndProjectSection\n+EndProject\n+Global\n+\tGlobalSection(SolutionConfigurationPlatforms) = preSolution\n+\t\tDebug|Win32 = Debug|Win32\n+\t\tRelease|Win32 = Release|Win32\n+\tEndGlobalSection\n+\tGlobalSection(ProjectConfigurationPlatforms) = postSolution\n+\t\t{D28CE435-CB33-4BAE-8A52-C6EF915956F5}.Debug|Win32.ActiveCfg = Debug|Win32\n+\t\t{D28CE435-CB33-4BAE-8A52-C6EF915956F5}.Debug|Win32.Build.0 = Debug|Win32\n+\t\t{D28CE435-CB33-4BAE-8A52-C6EF915956F5}.Release|Win32.ActiveCfg = Release|Win32\n+\t\t{D28CE435-CB33-4BAE-8A52-C6EF915956F5}.Release|Win32.Build.0 = Release|Win32\n+\t\t{469E1CF6-08A2-4B7B-A2AA-5BDB089857C1}.Debug|Win32.ActiveCfg = Debug|Win32\n+\t\t{469E1CF6-08A2-4B7B-A2AA-5BDB089857C1}.Debug|Win32.Build.0 = Debug|Win32\n+\t\t{469E1CF6-08A2-4B7B-A2AA-5BDB089857C1}.Release|Win32.ActiveCfg = Release|Win32\n+\t\t{469E1CF6-08A2-4B7B-A2AA-5BDB089857C1}.Release|Win32.Build.0 = Release|Win32\n+\tEndGlobalSection\n+\tGlobalSection(SolutionProperties) = preSolution\n+\t\tHideSolutionNode = FALSE\n+\tEndGlobalSection\n+EndGlobal"
      },
      {
        "sha": "a2c433ea0b92fed2eb19c02a0a2148c5c1ff33b9",
        "filename": "miniupnpc/msvc/miniupnpc.vcproj",
        "status": "added",
        "additions": 251,
        "deletions": 0,
        "changes": 251,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/msvc/miniupnpc.vcproj",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/msvc/miniupnpc.vcproj",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/miniupnpc/msvc/miniupnpc.vcproj?ref=b94b7b05a7b1d27e28ca9a8684877ca605d70256",
        "patch": "@@ -0,0 +1,251 @@\n+<?xml version=\"1.0\" encoding=\"Windows-1252\"?>\n+<VisualStudioProject\n+\tProjectType=\"Visual C++\"\n+\tVersion=\"9,00\"\n+\tName=\"miniupnpc\"\n+\tProjectGUID=\"{D28CE435-CB33-4BAE-8A52-C6EF915956F5}\"\n+\tRootNamespace=\"miniupnpc\"\n+\tKeyword=\"Win32Proj\"\n+\tTargetFrameworkVersion=\"196613\"\n+\t>\n+\t<Platforms>\n+\t\t<Platform\n+\t\t\tName=\"Win32\"\n+\t\t/>\n+\t</Platforms>\n+\t<ToolFiles>\n+\t</ToolFiles>\n+\t<Configurations>\n+\t\t<Configuration\n+\t\t\tName=\"Debug|Win32\"\n+\t\t\tOutputDirectory=\"$(SolutionDir)$(ConfigurationName)\"\n+\t\t\tIntermediateDirectory=\"$(ConfigurationName)\"\n+\t\t\tConfigurationType=\"4\"\n+\t\t\tCharacterSet=\"1\"\n+\t\t\t>\n+\t\t\t<Tool\n+\t\t\t\tName=\"VCPreBuildEventTool\"\n+\t\t\t/>\n+\t\t\t<Tool\n+\t\t\t\tName=\"VCCustomBuildTool\"\n+\t\t\t/>\n+\t\t\t<Tool\n+\t\t\t\tName=\"VCXMLDataGeneratorTool\"\n+\t\t\t/>\n+\t\t\t<Tool\n+\t\t\t\tName=\"VCWebServiceProxyGeneratorTool\"\n+\t\t\t/>\n+\t\t\t<Tool\n+\t\t\t\tName=\"VCMIDLTool\"\n+\t\t\t/>\n+\t\t\t<Tool\n+\t\t\t\tName=\"VCCLCompilerTool\"\n+\t\t\t\tOptimization=\"0\"\n+\t\t\t\tPreprocessorDefinitions=\"_CRT_SECURE_NO_WARNINGS;WIN32;STATICLIB;DEBUG\"\n+\t\t\t\tMinimalRebuild=\"true\"\n+\t\t\t\tBasicRuntimeChecks=\"3\"\n+\t\t\t\tRuntimeLibrary=\"3\"\n+\t\t\t\tUsePrecompiledHeader=\"0\"\n+\t\t\t\tWarningLevel=\"3\"\n+\t\t\t\tDebugInformationFormat=\"4\"\n+\t\t\t/>\n+\t\t\t<Tool\n+\t\t\t\tName=\"VCManagedResourceCompilerTool\"\n+\t\t\t/>\n+\t\t\t<Tool\n+\t\t\t\tName=\"VCResourceCompilerTool\"\n+\t\t\t/>\n+\t\t\t<Tool\n+\t\t\t\tName=\"VCPreLinkEventTool\"\n+\t\t\t/>\n+\t\t\t<Tool\n+\t\t\t\tName=\"VCLibrarianTool\"\n+\t\t\t/>\n+\t\t\t<Tool\n+\t\t\t\tName=\"VCALinkTool\"\n+\t\t\t/>\n+\t\t\t<Tool\n+\t\t\t\tName=\"VCXDCMakeTool\"\n+\t\t\t/>\n+\t\t\t<Tool\n+\t\t\t\tName=\"VCBscMakeTool\"\n+\t\t\t/>\n+\t\t\t<Tool\n+\t\t\t\tName=\"VCFxCopTool\"\n+\t\t\t/>\n+\t\t\t<Tool\n+\t\t\t\tName=\"VCPostBuildEventTool\"\n+\t\t\t/>\n+\t\t</Configuration>\n+\t\t<Configuration\n+\t\t\tName=\"Release|Win32\"\n+\t\t\tOutputDirectory=\"$(SolutionDir)$(ConfigurationName)\"\n+\t\t\tIntermediateDirectory=\"$(ConfigurationName)\"\n+\t\t\tConfigurationType=\"4\"\n+\t\t\tCharacterSet=\"1\"\n+\t\t\tWholeProgramOptimization=\"1\"\n+\t\t\t>\n+\t\t\t<Tool\n+\t\t\t\tName=\"VCPreBuildEventTool\"\n+\t\t\t/>\n+\t\t\t<Tool\n+\t\t\t\tName=\"VCCustomBuildTool\"\n+\t\t\t/>\n+\t\t\t<Tool\n+\t\t\t\tName=\"VCXMLDataGeneratorTool\"\n+\t\t\t/>\n+\t\t\t<Tool\n+\t\t\t\tName=\"VCWebServiceProxyGeneratorTool\"\n+\t\t\t/>\n+\t\t\t<Tool\n+\t\t\t\tName=\"VCMIDLTool\"\n+\t\t\t/>\n+\t\t\t<Tool\n+\t\t\t\tName=\"VCCLCompilerTool\"\n+\t\t\t\tOptimization=\"2\"\n+\t\t\t\tEnableIntrinsicFunctions=\"true\"\n+\t\t\t\tPreprocessorDefinitions=\"_CRT_SECURE_NO_WARNINGS;WIN32;STATICLIB\"\n+\t\t\t\tRuntimeLibrary=\"2\"\n+\t\t\t\tEnableFunctionLevelLinking=\"true\"\n+\t\t\t\tUsePrecompiledHeader=\"0\"\n+\t\t\t\tWarningLevel=\"3\"\n+\t\t\t\tDebugInformationFormat=\"3\"\n+\t\t\t/>\n+\t\t\t<Tool\n+\t\t\t\tName=\"VCManagedResourceCompilerTool\"\n+\t\t\t/>\n+\t\t\t<Tool\n+\t\t\t\tName=\"VCResourceCompilerTool\"\n+\t\t\t/>\n+\t\t\t<Tool\n+\t\t\t\tName=\"VCPreLinkEventTool\"\n+\t\t\t/>\n+\t\t\t<Tool\n+\t\t\t\tName=\"VCLibrarianTool\"\n+\t\t\t/>\n+\t\t\t<Tool\n+\t\t\t\tName=\"VCALinkTool\"\n+\t\t\t/>\n+\t\t\t<Tool\n+\t\t\t\tName=\"VCXDCMakeTool\"\n+\t\t\t/>\n+\t\t\t<Tool\n+\t\t\t\tName=\"VCBscMakeTool\"\n+\t\t\t/>\n+\t\t\t<Tool\n+\t\t\t\tName=\"VCFxCopTool\"\n+\t\t\t/>\n+\t\t\t<Tool\n+\t\t\t\tName=\"VCPostBuildEventTool\"\n+\t\t\t/>\n+\t\t</Configuration>\n+\t</Configurations>\n+\t<References>\n+\t</References>\n+\t<Files>\n+\t\t<Filter\n+\t\t\tName=\"Fichiers sources\"\n+\t\t\tFilter=\"cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx\"\n+\t\t\tUniqueIdentifier=\"{4FC737F1-C7A5-4376-A066-2A32D752A2FF}\"\n+\t\t\t>\n+\t\t\t<File\n+\t\t\t\tRelativePath=\"..\\connecthostport.c\"\n+\t\t\t\t>\n+\t\t\t</File>\n+\t\t\t<File\n+\t\t\t\tRelativePath=\"..\\igd_desc_parse.c\"\n+\t\t\t\t>\n+\t\t\t</File>\n+\t\t\t<File\n+\t\t\t\tRelativePath=\"..\\minisoap.c\"\n+\t\t\t\t>\n+\t\t\t</File>\n+\t\t\t<File\n+\t\t\t\tRelativePath=\"..\\miniupnpc.c\"\n+\t\t\t\t>\n+\t\t\t</File>\n+\t\t\t<File\n+\t\t\t\tRelativePath=\"..\\miniwget.c\"\n+\t\t\t\t>\n+\t\t\t</File>\n+\t\t\t<File\n+\t\t\t\tRelativePath=\"..\\minixml.c\"\n+\t\t\t\t>\n+\t\t\t</File>\n+\t\t\t<File\n+\t\t\t\tRelativePath=\"..\\upnpcommands.c\"\n+\t\t\t\t>\n+\t\t\t</File>\n+\t\t\t<File\n+\t\t\t\tRelativePath=\"..\\upnperrors.c\"\n+\t\t\t\t>\n+\t\t\t</File>\n+\t\t\t<File\n+\t\t\t\tRelativePath=\"..\\upnpreplyparse.c\"\n+\t\t\t\t>\n+\t\t\t</File>\n+\t\t</Filter>\n+\t\t<Filter\n+\t\t\tName=\"Fichiers d&apos;en-t\ufffdte\"\n+\t\t\tFilter=\"h;hpp;hxx;hm;inl;inc;xsd\"\n+\t\t\tUniqueIdentifier=\"{93995380-89BD-4b04-88EB-625FBE52EBFB}\"\n+\t\t\t>\n+\t\t\t<File\n+\t\t\t\tRelativePath=\"..\\bsdqueue.h\"\n+\t\t\t\t>\n+\t\t\t</File>\n+\t\t\t<File\n+\t\t\t\tRelativePath=\"..\\connecthostport.h\"\n+\t\t\t\t>\n+\t\t\t</File>\n+\t\t\t<File\n+\t\t\t\tRelativePath=\"..\\declspec.h\"\n+\t\t\t\t>\n+\t\t\t</File>\n+\t\t\t<File\n+\t\t\t\tRelativePath=\"..\\igd_desc_parse.h\"\n+\t\t\t\t>\n+\t\t\t</File>\n+\t\t\t<File\n+\t\t\t\tRelativePath=\"..\\minisoap.h\"\n+\t\t\t\t>\n+\t\t\t</File>\n+\t\t\t<File\n+\t\t\t\tRelativePath=\"..\\miniupnpc.h\"\n+\t\t\t\t>\n+\t\t\t</File>\n+\t\t\t<File\n+\t\t\t\tRelativePath=\"..\\miniupnpcstrings.h\"\n+\t\t\t\t>\n+\t\t\t</File>\n+\t\t\t<File\n+\t\t\t\tRelativePath=\"..\\miniwget.h\"\n+\t\t\t\t>\n+\t\t\t</File>\n+\t\t\t<File\n+\t\t\t\tRelativePath=\"..\\minixml.h\"\n+\t\t\t\t>\n+\t\t\t</File>\n+\t\t\t<File\n+\t\t\t\tRelativePath=\"..\\upnpcommands.h\"\n+\t\t\t\t>\n+\t\t\t</File>\n+\t\t\t<File\n+\t\t\t\tRelativePath=\"..\\upnperrors.h\"\n+\t\t\t\t>\n+\t\t\t</File>\n+\t\t\t<File\n+\t\t\t\tRelativePath=\"..\\upnpreplyparse.h\"\n+\t\t\t\t>\n+\t\t\t</File>\n+\t\t</Filter>\n+\t\t<Filter\n+\t\t\tName=\"Fichiers de ressources\"\n+\t\t\tFilter=\"rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav\"\n+\t\t\tUniqueIdentifier=\"{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}\"\n+\t\t\t>\n+\t\t</Filter>\n+\t</Files>\n+\t<Globals>\n+\t</Globals>\n+</VisualStudioProject>"
      },
      {
        "sha": "294613877fd71ca1371bd319e7849ad3a4f4a3a9",
        "filename": "miniupnpc/msvc/upnpc-static.vcproj",
        "status": "added",
        "additions": 195,
        "deletions": 0,
        "changes": 195,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/msvc/upnpc-static.vcproj",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/msvc/upnpc-static.vcproj",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/miniupnpc/msvc/upnpc-static.vcproj?ref=b94b7b05a7b1d27e28ca9a8684877ca605d70256",
        "patch": "@@ -0,0 +1,195 @@\n+<?xml version=\"1.0\" encoding=\"Windows-1252\"?>\n+<VisualStudioProject\n+\tProjectType=\"Visual C++\"\n+\tVersion=\"9,00\"\n+\tName=\"upnpc-static\"\n+\tProjectGUID=\"{469E1CF6-08A2-4B7B-A2AA-5BDB089857C1}\"\n+\tRootNamespace=\"upnpcstatic\"\n+\tKeyword=\"Win32Proj\"\n+\tTargetFrameworkVersion=\"196613\"\n+\t>\n+\t<Platforms>\n+\t\t<Platform\n+\t\t\tName=\"Win32\"\n+\t\t/>\n+\t</Platforms>\n+\t<ToolFiles>\n+\t</ToolFiles>\n+\t<Configurations>\n+\t\t<Configuration\n+\t\t\tName=\"Debug|Win32\"\n+\t\t\tOutputDirectory=\"$(SolutionDir)$(ConfigurationName)\"\n+\t\t\tIntermediateDirectory=\"$(ConfigurationName)\"\n+\t\t\tConfigurationType=\"1\"\n+\t\t\tCharacterSet=\"1\"\n+\t\t\t>\n+\t\t\t<Tool\n+\t\t\t\tName=\"VCPreBuildEventTool\"\n+\t\t\t/>\n+\t\t\t<Tool\n+\t\t\t\tName=\"VCCustomBuildTool\"\n+\t\t\t/>\n+\t\t\t<Tool\n+\t\t\t\tName=\"VCXMLDataGeneratorTool\"\n+\t\t\t/>\n+\t\t\t<Tool\n+\t\t\t\tName=\"VCWebServiceProxyGeneratorTool\"\n+\t\t\t/>\n+\t\t\t<Tool\n+\t\t\t\tName=\"VCMIDLTool\"\n+\t\t\t/>\n+\t\t\t<Tool\n+\t\t\t\tName=\"VCCLCompilerTool\"\n+\t\t\t\tOptimization=\"0\"\n+\t\t\t\tPreprocessorDefinitions=\"WIN32;_DEBUG;_CONSOLE;STATICLIB;DEBUG;_CRT_SECURE_NO_WARNINGS\"\n+\t\t\t\tMinimalRebuild=\"true\"\n+\t\t\t\tBasicRuntimeChecks=\"3\"\n+\t\t\t\tRuntimeLibrary=\"3\"\n+\t\t\t\tUsePrecompiledHeader=\"0\"\n+\t\t\t\tWarningLevel=\"3\"\n+\t\t\t\tDebugInformationFormat=\"4\"\n+\t\t\t/>\n+\t\t\t<Tool\n+\t\t\t\tName=\"VCManagedResourceCompilerTool\"\n+\t\t\t/>\n+\t\t\t<Tool\n+\t\t\t\tName=\"VCResourceCompilerTool\"\n+\t\t\t/>\n+\t\t\t<Tool\n+\t\t\t\tName=\"VCPreLinkEventTool\"\n+\t\t\t/>\n+\t\t\t<Tool\n+\t\t\t\tName=\"VCLinkerTool\"\n+\t\t\t\tAdditionalDependencies=\"ws2_32.lib IPHlpApi.Lib Debug\\miniupnpc.lib\"\n+\t\t\t\tLinkIncremental=\"2\"\n+\t\t\t\tGenerateDebugInformation=\"true\"\n+\t\t\t\tSubSystem=\"1\"\n+\t\t\t\tTargetMachine=\"1\"\n+\t\t\t/>\n+\t\t\t<Tool\n+\t\t\t\tName=\"VCALinkTool\"\n+\t\t\t/>\n+\t\t\t<Tool\n+\t\t\t\tName=\"VCManifestTool\"\n+\t\t\t/>\n+\t\t\t<Tool\n+\t\t\t\tName=\"VCXDCMakeTool\"\n+\t\t\t/>\n+\t\t\t<Tool\n+\t\t\t\tName=\"VCBscMakeTool\"\n+\t\t\t/>\n+\t\t\t<Tool\n+\t\t\t\tName=\"VCFxCopTool\"\n+\t\t\t/>\n+\t\t\t<Tool\n+\t\t\t\tName=\"VCAppVerifierTool\"\n+\t\t\t/>\n+\t\t\t<Tool\n+\t\t\t\tName=\"VCPostBuildEventTool\"\n+\t\t\t/>\n+\t\t</Configuration>\n+\t\t<Configuration\n+\t\t\tName=\"Release|Win32\"\n+\t\t\tOutputDirectory=\"$(SolutionDir)$(ConfigurationName)\"\n+\t\t\tIntermediateDirectory=\"$(ConfigurationName)\"\n+\t\t\tConfigurationType=\"1\"\n+\t\t\tCharacterSet=\"1\"\n+\t\t\tWholeProgramOptimization=\"1\"\n+\t\t\t>\n+\t\t\t<Tool\n+\t\t\t\tName=\"VCPreBuildEventTool\"\n+\t\t\t/>\n+\t\t\t<Tool\n+\t\t\t\tName=\"VCCustomBuildTool\"\n+\t\t\t/>\n+\t\t\t<Tool\n+\t\t\t\tName=\"VCXMLDataGeneratorTool\"\n+\t\t\t/>\n+\t\t\t<Tool\n+\t\t\t\tName=\"VCWebServiceProxyGeneratorTool\"\n+\t\t\t/>\n+\t\t\t<Tool\n+\t\t\t\tName=\"VCMIDLTool\"\n+\t\t\t/>\n+\t\t\t<Tool\n+\t\t\t\tName=\"VCCLCompilerTool\"\n+\t\t\t\tOptimization=\"2\"\n+\t\t\t\tEnableIntrinsicFunctions=\"true\"\n+\t\t\t\tPreprocessorDefinitions=\"WIN32;NDEBUG;_CONSOLE;_CRT_SECURE_NO_WARNINGS;STATICLIB\"\n+\t\t\t\tRuntimeLibrary=\"2\"\n+\t\t\t\tEnableFunctionLevelLinking=\"true\"\n+\t\t\t\tUsePrecompiledHeader=\"0\"\n+\t\t\t\tWarningLevel=\"3\"\n+\t\t\t\tDebugInformationFormat=\"3\"\n+\t\t\t/>\n+\t\t\t<Tool\n+\t\t\t\tName=\"VCManagedResourceCompilerTool\"\n+\t\t\t/>\n+\t\t\t<Tool\n+\t\t\t\tName=\"VCResourceCompilerTool\"\n+\t\t\t/>\n+\t\t\t<Tool\n+\t\t\t\tName=\"VCPreLinkEventTool\"\n+\t\t\t/>\n+\t\t\t<Tool\n+\t\t\t\tName=\"VCLinkerTool\"\n+\t\t\t\tAdditionalDependencies=\"ws2_32.lib IPHlpApi.Lib Release\\miniupnpc.lib\"\n+\t\t\t\tLinkIncremental=\"1\"\n+\t\t\t\tGenerateDebugInformation=\"true\"\n+\t\t\t\tSubSystem=\"1\"\n+\t\t\t\tOptimizeReferences=\"2\"\n+\t\t\t\tEnableCOMDATFolding=\"2\"\n+\t\t\t\tTargetMachine=\"1\"\n+\t\t\t/>\n+\t\t\t<Tool\n+\t\t\t\tName=\"VCALinkTool\"\n+\t\t\t/>\n+\t\t\t<Tool\n+\t\t\t\tName=\"VCManifestTool\"\n+\t\t\t/>\n+\t\t\t<Tool\n+\t\t\t\tName=\"VCXDCMakeTool\"\n+\t\t\t/>\n+\t\t\t<Tool\n+\t\t\t\tName=\"VCBscMakeTool\"\n+\t\t\t/>\n+\t\t\t<Tool\n+\t\t\t\tName=\"VCFxCopTool\"\n+\t\t\t/>\n+\t\t\t<Tool\n+\t\t\t\tName=\"VCAppVerifierTool\"\n+\t\t\t/>\n+\t\t\t<Tool\n+\t\t\t\tName=\"VCPostBuildEventTool\"\n+\t\t\t/>\n+\t\t</Configuration>\n+\t</Configurations>\n+\t<References>\n+\t</References>\n+\t<Files>\n+\t\t<Filter\n+\t\t\tName=\"Fichiers sources\"\n+\t\t\tFilter=\"cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx\"\n+\t\t\tUniqueIdentifier=\"{4FC737F1-C7A5-4376-A066-2A32D752A2FF}\"\n+\t\t\t>\n+\t\t\t<File\n+\t\t\t\tRelativePath=\"..\\upnpc.c\"\n+\t\t\t\t>\n+\t\t\t</File>\n+\t\t</Filter>\n+\t\t<Filter\n+\t\t\tName=\"Fichiers d&apos;en-t\ufffdte\"\n+\t\t\tFilter=\"h;hpp;hxx;hm;inl;inc;xsd\"\n+\t\t\tUniqueIdentifier=\"{93995380-89BD-4b04-88EB-625FBE52EBFB}\"\n+\t\t\t>\n+\t\t</Filter>\n+\t\t<Filter\n+\t\t\tName=\"Fichiers de ressources\"\n+\t\t\tFilter=\"rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav\"\n+\t\t\tUniqueIdentifier=\"{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}\"\n+\t\t\t>\n+\t\t</Filter>\n+\t</Files>\n+\t<Globals>\n+\t</Globals>\n+</VisualStudioProject>"
      },
      {
        "sha": "d35a3b09219108654e33053b08999bc889cc1b13",
        "filename": "miniupnpc/pymoduletest.py",
        "status": "added",
        "additions": 52,
        "deletions": 0,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/pymoduletest.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/pymoduletest.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/miniupnpc/pymoduletest.py?ref=b94b7b05a7b1d27e28ca9a8684877ca605d70256",
        "patch": "@@ -0,0 +1,52 @@\n+#! /usr/bin/python\n+# MiniUPnP project\n+# Author : Thomas Bernard\n+# This Sample code is public domain.\n+# website : http://miniupnp.tuxfamily.org/\n+\n+# import the python miniupnpc module\n+import miniupnpc\n+import sys\n+\n+# create the object\n+u = miniupnpc.UPnP()\n+print 'inital(default) values :'\n+print ' discoverdelay', u.discoverdelay\n+print ' lanaddr', u.lanaddr\n+print ' multicastif', u.multicastif\n+print ' minissdpdsocket', u.minissdpdsocket\n+u.discoverdelay = 200;\n+#u.minissdpdsocket = '../minissdpd/minissdpd.sock'\n+# discovery process, it usualy takes several seconds (2 seconds or more)\n+print 'Discovering... delay=%ums' % u.discoverdelay\n+print u.discover(), 'device(s) detected'\n+# select an igd\n+try:\n+  u.selectigd()\n+except Exception, e:\n+  print 'Exception :', e\n+  sys.exit(1)\n+# display information about the IGD and the internet connection\n+print 'local ip address :', u.lanaddr\n+print 'external ip address :', u.externalipaddress()\n+print u.statusinfo(), u.connectiontype()\n+\n+#print u.addportmapping(64000, 'TCP',\n+#                       '192.168.1.166', 63000, 'port mapping test', '')\n+#print u.deleteportmapping(64000, 'TCP')\n+\n+port = 0\n+proto = 'UDP'\n+# list the redirections :\n+i = 0\n+while True:\n+\tp = u.getgenericportmapping(i)\n+\tif p==None:\n+\t\tbreak\n+\tprint i, p\n+\t(port, proto, (ihost,iport), desc, c, d, e) = p\n+\t#print port, desc\n+\ti = i + 1\n+\n+print u.getspecificportmapping(port, proto)\n+"
      },
      {
        "sha": "94e18d815b365bc405a17a18c7c9f20d67a88b59",
        "filename": "miniupnpc/setup.py",
        "status": "added",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/setup.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/setup.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/miniupnpc/setup.py?ref=b94b7b05a7b1d27e28ca9a8684877ca605d70256",
        "patch": "@@ -0,0 +1,15 @@\n+#! /usr/bin/python\n+# $Id: setup.py,v 1.5 2009/10/30 09:18:18 nanard Exp $\n+# the MiniUPnP Project (c) 2007-2009 Thomas Bernard\n+# http://miniupnp.tuxfamily.org/ or http://miniupnp.free.fr/\n+#\n+# python script to build the miniupnpc module under unix\n+#\n+# replace libminiupnpc.a by libminiupnpc.so for shared library usage\n+from distutils.core import setup, Extension\n+setup(name=\"miniupnpc\", version=\"1.5\",\n+      ext_modules=[\n+\t         Extension(name=\"miniupnpc\", sources=[\"miniupnpcmodule.c\"],\n+\t\t\t           extra_objects=[\"libminiupnpc.a\"])\n+\t\t\t ])\n+"
      },
      {
        "sha": "db42bc9f6916c55882b1806736e19dfd921bbc7c",
        "filename": "miniupnpc/setupmingw32.py",
        "status": "added",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/setupmingw32.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/setupmingw32.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/miniupnpc/setupmingw32.py?ref=b94b7b05a7b1d27e28ca9a8684877ca605d70256",
        "patch": "@@ -0,0 +1,15 @@\n+#! /usr/bin/python\n+# $Id: setupmingw32.py,v 1.3 2009/10/30 09:18:18 nanard Exp $\n+# the MiniUPnP Project (c) 2007-2009 Thomas Bernard\n+# http://miniupnp.tuxfamily.org/ or http://miniupnp.free.fr/\n+#\n+# python script to build the miniupnpc module under unix\n+#\n+from distutils.core import setup, Extension\n+setup(name=\"miniupnpc\", version=\"1.5\",\n+      ext_modules=[\n+\t         Extension(name=\"miniupnpc\", sources=[\"miniupnpcmodule.c\"],\n+\t                   libraries=[\"ws2_32\"],\n+\t\t\t           extra_objects=[\"libminiupnpc.a\"])\n+\t\t\t ])\n+"
      },
      {
        "sha": "1b0cde90e2ef6cfd23ef52888a77e9dbd58ba2a0",
        "filename": "miniupnpc/testigddescparse.c",
        "status": "added",
        "additions": 64,
        "deletions": 0,
        "changes": 64,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/testigddescparse.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/testigddescparse.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/miniupnpc/testigddescparse.c?ref=b94b7b05a7b1d27e28ca9a8684877ca605d70256",
        "patch": "@@ -0,0 +1,64 @@\n+/* $Id: testigddescparse.c,v 1.2 2009/12/03 13:50:06 nanard Exp $ */\n+/* Project : miniupnp\n+ * http://miniupnp.free.fr/\n+ * Author : Thomas Bernard\n+ * Copyright (c) 2008-2009 Thomas Bernard\n+ * This software is subject to the conditions detailed in the\n+ * LICENCE file provided in this distribution.\n+ * */\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include \"igd_desc_parse.h\"\n+#include \"minixml.h\"\n+#include \"miniupnpc.h\"\n+\n+int test_igd_desc_parse(char * buffer, int len)\n+{\n+\tstruct IGDdatas igd;\n+\tstruct xmlparser parser;\n+\tstruct UPNPUrls urls;\n+\tmemset(&igd, 0, sizeof(struct IGDdatas));\n+\tmemset(&parser, 0, sizeof(struct xmlparser));\n+\tparser.xmlstart = buffer;\n+\tparser.xmlsize = len;\n+\tparser.data = &igd;\n+\tparser.starteltfunc = IGDstartelt;\n+\tparser.endeltfunc = IGDendelt;\n+\tparser.datafunc = IGDdata; \n+\tparsexml(&parser);\n+\tprintIGD(&igd);\n+\tGetUPNPUrls(&urls, &igd, \"http://fake/desc/url/file.xml\");\n+\tprintf(\"ipcondescURL='%s'\\n\", urls.ipcondescURL);\n+\tprintf(\"controlURL='%s'\\n\", urls.controlURL);\n+\tprintf(\"controlURL_CIF='%s'\\n\", urls.controlURL_CIF);\n+\tFreeUPNPUrls(&urls);\n+\treturn 0;\n+}\n+\n+int main(int argc, char * * argv)\n+{\n+\tFILE * f;\n+\tchar * buffer;\n+\tint len;\n+\tint r = 0;\n+\tif(argc<2) {\n+\t\tfprintf(stderr, \"Usage: %s file.xml\\n\", argv[0]);\n+\t\treturn 1;\n+\t}\n+\tf = fopen(argv[1], \"r\");\n+\tif(!f) {\n+\t\tfprintf(stderr, \"Cannot open %s for reading.\\n\", argv[1]);\n+\t\treturn 1;\n+\t}\n+\tfseek(f, 0, SEEK_END);\n+\tlen = ftell(f);\n+\tfseek(f, 0, SEEK_SET);\n+\tbuffer = malloc(len);\n+\tfread(buffer, 1, len, f);\n+\tfclose(f);\n+\tr = test_igd_desc_parse(buffer, len);\n+\tfree(buffer);\n+\treturn r;\n+}\n+"
      },
      {
        "sha": "0624e5adfc1ae751557289eeb630724003d806d8",
        "filename": "miniupnpc/testminiwget.c",
        "status": "added",
        "additions": 45,
        "deletions": 0,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/testminiwget.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/testminiwget.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/miniupnpc/testminiwget.c?ref=b94b7b05a7b1d27e28ca9a8684877ca605d70256",
        "patch": "@@ -0,0 +1,45 @@\n+/* $Id: testminiwget.c,v 1.1 2009/12/03 18:44:32 nanard Exp $ */\n+/* Project : miniupnp\n+ * Author : Thomas Bernard\n+ * Copyright (c) 2005-2009 Thomas Bernard\n+ * This software is subject to the conditions detailed in the\n+ * LICENCE file provided in this distribution.\n+ * */\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include \"miniwget.h\"\n+\n+int main(int argc, char * * argv)\n+{\n+\tvoid * data;\n+\tint size, writtensize;\n+\tFILE *f;\n+\tif(argc < 3) {\n+\t\tfprintf(stderr, \"Usage:\\t%s url file\\n\", argv[0]);\n+\t\tfprintf(stderr, \"Example:\\t%s http://www.google.com/ out.html\\n\", argv[0]);\n+\t\treturn 1;\n+\t}\n+\tdata = miniwget(argv[1], &size);\n+\tif(!data) {\n+\t\tfprintf(stderr, \"Error fetching %s\\n\", argv[1]);\n+\t\treturn 1;\n+\t}\n+\tprintf(\"got %d bytes\\n\", size);\n+\tf = fopen(argv[2], \"wb\");\n+\tif(!f) {\n+\t\tfprintf(stderr, \"Cannot open file %s for writing\\n\", argv[2]);\n+\t\tfree(data);\n+\t\treturn 1;\n+\t}\n+\twrittensize = fwrite(data, 1, size, f);\n+\tif(writtensize != size) {\n+\t\tfprintf(stderr, \"Could only write %d bytes out of %d to %s\\n\",\n+\t\t        writtensize, size, argv[2]);\n+\t} else {\n+\t\tprintf(\"%d bytes written to %s\\n\", writtensize, argv[2]);\n+\t}\n+\tfclose(f);\n+\tfree(data);\n+\treturn 0;\n+}\n+"
      },
      {
        "sha": "3d82527b777d2d2c915d1bfc3e36352121499ba4",
        "filename": "miniupnpc/testminixml.c",
        "status": "added",
        "additions": 88,
        "deletions": 0,
        "changes": 88,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/testminixml.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/testminixml.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/miniupnpc/testminixml.c?ref=b94b7b05a7b1d27e28ca9a8684877ca605d70256",
        "patch": "@@ -0,0 +1,88 @@\n+/* $Id: testminixml.c,v 1.6 2006/11/19 22:32:35 nanard Exp $\n+ * testminixml.c\n+ * test program for the \"minixml\" functions.\n+ * Author : Thomas Bernard.\n+ */\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <string.h>\n+#include \"minixml.h\"\n+#include \"igd_desc_parse.h\"\n+\n+#ifdef WIN32\n+#define NO_BZERO\n+#endif\n+\n+#ifdef NO_BZERO\n+#define bzero(p, n) memset(p, 0, n)\n+#endif\n+\n+/* ---------------------------------------------------------------------- */\n+void printeltname1(void * d, const char * name, int l)\n+{\n+\tint i;\n+\tprintf(\"element \");\n+\tfor(i=0;i<l;i++)\n+\t\tputchar(name[i]);\n+}\n+void printeltname2(void * d, const char * name, int l)\n+{\n+\tint i;\n+\tputchar('/');\n+\tfor(i=0;i<l;i++)\n+\t\tputchar(name[i]);\n+\tputchar('\\n');\n+}\n+void printdata(void *d, const char * data, int l)\n+{\n+\tint i;\n+\tprintf(\"data : \");\n+\tfor(i=0;i<l;i++)\n+\t\tputchar(data[i]);\n+\tputchar('\\n');\n+}\n+\n+void burptest(const char * buffer, int bufsize)\n+{\n+\tstruct IGDdatas data;\n+\tstruct xmlparser parser;\n+\t/*objet IGDdatas */\n+\tbzero(&data, sizeof(struct IGDdatas));\n+\t/* objet xmlparser */\n+\tparser.xmlstart = buffer;\n+\tparser.xmlsize = bufsize;\n+\tparser.data = &data;\n+\t/*parser.starteltfunc = printeltname1;\n+\tparser.endeltfunc = printeltname2;\n+\tparser.datafunc = printdata; */\n+\tparser.starteltfunc = IGDstartelt;\n+\tparser.endeltfunc = IGDendelt;\n+\tparser.datafunc = IGDdata; \n+\tparsexml(&parser);\n+\tprintIGD(&data);\n+}\n+\n+/* ----- main ---- */\n+#define XML_MAX_SIZE (8192)\n+int main(int argc, char * * argv)\n+{\n+\tFILE * f;\n+\tchar buffer[XML_MAX_SIZE];\n+\tint bufsize;\n+\tif(argc<2)\n+\t{\n+\t\tprintf(\"usage:\\t%s file.xml\\n\", argv[0]);\n+\t\treturn 1;\n+\t}\n+\tf = fopen(argv[1], \"r\");\n+\tif(!f)\n+\t{\n+\t\tprintf(\"cannot open file %s\\n\", argv[1]);\n+\t\treturn 1;\n+\t}\n+\tbufsize = (int)fread(buffer, 1, XML_MAX_SIZE, f);\n+\tfclose(f);\n+\tburptest(buffer, bufsize);\n+\treturn 0;\n+}\n+"
      },
      {
        "sha": "6d167a4ce086de1c769b922550771f37a0d2ee76",
        "filename": "miniupnpc/testupnpigd.py",
        "status": "added",
        "additions": 84,
        "deletions": 0,
        "changes": 84,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/testupnpigd.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/testupnpigd.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/miniupnpc/testupnpigd.py?ref=b94b7b05a7b1d27e28ca9a8684877ca605d70256",
        "patch": "@@ -0,0 +1,84 @@\n+#! /usr/bin/python\n+# $Id: testupnpigd.py,v 1.4 2008/10/11 10:27:20 nanard Exp $\n+# MiniUPnP project\n+# Author : Thomas Bernard\n+# This Sample code is public domain.\n+# website : http://miniupnp.tuxfamily.org/\n+\n+# import the python miniupnpc module\n+import miniupnpc\n+import socket\n+import BaseHTTPServer\n+\n+# function definition\n+def list_redirections():\n+\ti = 0\n+\twhile True:\n+\t\tp = u.getgenericportmapping(i)\n+\t\tif p==None:\n+\t\t\tbreak\n+\t\tprint i, p\n+\t\ti = i + 1\n+\n+#define the handler class for HTTP connections\n+class handler_class(BaseHTTPServer.BaseHTTPRequestHandler):\n+\tdef do_GET(self):\n+\t\tself.send_response(200)\n+\t\tself.end_headers()\n+\t\tself.wfile.write(\"OK MON GARS\")\n+\n+# create the object\n+u = miniupnpc.UPnP()\n+#print 'inital(default) values :'\n+#print ' discoverdelay', u.discoverdelay\n+#print ' lanaddr', u.lanaddr\n+#print ' multicastif', u.multicastif\n+#print ' minissdpdsocket', u.minissdpdsocket\n+u.discoverdelay = 200;\n+\n+try:\n+\tprint 'Discovering... delay=%ums' % u.discoverdelay\n+\tndevices = u.discover()\n+\tprint ndevices, 'device(s) detected'\n+\n+\t# select an igd\n+\tu.selectigd()\n+\t# display information about the IGD and the internet connection\n+\tprint 'local ip address :', u.lanaddr\n+\texternalipaddress = u.externalipaddress()\n+\tprint 'external ip address :', externalipaddress\n+\tprint u.statusinfo(), u.connectiontype()\n+\n+\t#instanciate a HTTPd object. The port is assigned by the system.\n+\thttpd = BaseHTTPServer.HTTPServer((u.lanaddr, 0), handler_class)\n+\teport = httpd.server_port\n+\n+\t# find a free port for the redirection\n+\tr = u.getspecificportmapping(eport, 'TCP')\n+\twhile r != None and eport < 65536:\n+\t\teport = eport + 1\n+\t\tr = u.getspecificportmapping(eport, 'TCP')\n+\n+\tprint 'trying to redirect %s port %u TCP => %s port %u TCP' % (externalipaddress, eport, u.lanaddr, httpd.server_port)\n+\n+\tb = u.addportmapping(eport, 'TCP', u.lanaddr, httpd.server_port,\n+\t                    'UPnP IGD Tester port %u' % eport, '')\n+\tif b:\n+\t\tprint 'Success. Now waiting for some HTTP request on http://%s:%u' % (externalipaddress ,eport)\n+\t\ttry:\n+\t\t\thttpd.handle_request()\n+\t\t\thttpd.server_close()\n+\t\texcept KeyboardInterrupt, details:\n+\t\t\tprint \"CTRL-C exception!\", details\n+\t\tb = u.deleteportmapping(eport, 'TCP')\n+\t\tif b:\n+\t\t\tprint 'Successfully deleted port mapping'\n+\t\telse:\n+\t\t\tprint 'Failed to remove port mapping'\n+\telse:\n+\t\tprint 'Failed'\n+\n+\thttpd.server_close()\n+\n+except Exception, e:\n+\tprint 'Exception :', e"
      },
      {
        "sha": "a02e8f6a62d8e074c4a3330d6072486bbc426575",
        "filename": "miniupnpc/testupnpreplyparse.c",
        "status": "added",
        "additions": 44,
        "deletions": 0,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/testupnpreplyparse.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/testupnpreplyparse.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/miniupnpc/testupnpreplyparse.c?ref=b94b7b05a7b1d27e28ca9a8684877ca605d70256",
        "patch": "@@ -0,0 +1,44 @@\n+/* $Id: testupnpreplyparse.c,v 1.2 2008/02/21 13:05:27 nanard Exp $ */\n+/* MiniUPnP project\n+ * http://miniupnp.free.fr/ or http://miniupnp.tuxfamily.org/\n+ * (c) 2006-2007 Thomas Bernard\n+ * This software is subject to the conditions detailed\n+ * in the LICENCE file provided within the distribution */\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include \"upnpreplyparse.h\"\n+\n+void\n+test_parsing(const char * buf, int len)\n+{\n+\tstruct NameValueParserData pdata;\n+\tParseNameValue(buf, len, &pdata);\n+\tClearNameValueList(&pdata);\n+}\n+\n+int main(int argc, char * * argv)\n+{\n+\tFILE * f;\n+\tchar buffer[4096];\n+\tint l;\n+\tif(argc<2)\n+\t{\n+\t\tfprintf(stderr, \"Usage: %s file.xml\\n\", argv[0]);\n+\t\treturn 1;\n+\t}\n+\tf = fopen(argv[1], \"r\");\n+\tif(!f)\n+\t{\n+\t\tfprintf(stderr, \"Error : can not open file %s\\n\", argv[1]);\n+\t\treturn 2;\n+\t}\n+\tl = fread(buffer, 1, sizeof(buffer)-1, f);\n+\tfclose(f);\n+\tbuffer[l] = '\\0';\n+#ifdef DEBUG\n+\tDisplayNameValueList(buffer, l);\n+#endif\n+\ttest_parsing(buffer, l);\n+\treturn 0;\n+}\n+"
      },
      {
        "sha": "32fbf55abbd5409f825ed9b7f998e5ddfd25dfc1",
        "filename": "miniupnpc/updateminiupnpcstrings.sh",
        "status": "added",
        "additions": 45,
        "deletions": 0,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/updateminiupnpcstrings.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/updateminiupnpcstrings.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/miniupnpc/updateminiupnpcstrings.sh?ref=b94b7b05a7b1d27e28ca9a8684877ca605d70256",
        "patch": "@@ -0,0 +1,45 @@\n+#! /bin/sh\n+# $Id: updateminiupnpcstrings.sh,v 1.6 2009/12/07 11:29:57 nanard Exp $\n+# project miniupnp : http://miniupnp.free.fr/\n+#\u00a0(c) 2009 Thomas Bernard\n+\n+FILE=miniupnpcstrings.h\n+TEMPLATE_FILE=${FILE}.in\n+\n+# detecting the OS name and version\n+OS_NAME=`uname -s`\n+OS_VERSION=`uname -r`\n+if [ -f /etc/debian_version ]; then\n+\tOS_NAME=Debian\n+\tOS_VERSION=`cat /etc/debian_version`\n+fi\n+# use lsb_release (Linux Standard Base) when available\n+LSB_RELEASE=`which lsb_release`\n+if [ 0 -eq $? -a -x \"${LSB_RELEASE}\" ]; then\n+\tOS_NAME=`${LSB_RELEASE} -i -s`\n+\tOS_VERSION=`${LSB_RELEASE} -r -s`\n+\tcase $OS_NAME in\n+\t\tDebian)\n+\t\t\t#OS_VERSION=`${LSB_RELEASE} -c -s`\n+\t\t\t;;\n+\t\tUbuntu)\n+\t\t\t#OS_VERSION=`${LSB_RELEASE} -c -s`\n+\t\t\t;;\n+\tesac\n+fi\n+\n+# on AmigaOS 3, uname -r returns \"unknown\", so we use uname -v\n+if [ \"$OS_NAME\" = \"AmigaOS\" ]; then\n+\tif [ \"$OS_VERSION\" = \"unknown\" ]; then\n+\t\tOS_VERSION=`uname -v`\n+\tfi\n+fi\n+\n+echo \"Detected OS [$OS_NAME] version [$OS_VERSION]\"\n+\n+EXPR=\"s|OS_STRING \\\".*\\\"|OS_STRING \\\"${OS_NAME}/${OS_VERSION}\\\"|\"\n+#echo $EXPR\n+test -f ${FILE}.in\n+echo \"setting OS_STRING macro value to ${OS_NAME}/${OS_VERSION} in $FILE.\"\n+sed -e \"$EXPR\" < $TEMPLATE_FILE > $FILE\n+"
      },
      {
        "sha": "f89e8779a5d92cecbfdeefa0aa4ad24cde0c1497",
        "filename": "miniupnpc/upnpc.c",
        "status": "added",
        "additions": 385,
        "deletions": 0,
        "changes": 385,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/upnpc.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/upnpc.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/miniupnpc/upnpc.c?ref=b94b7b05a7b1d27e28ca9a8684877ca605d70256",
        "patch": "@@ -0,0 +1,385 @@\n+/* $Id: upnpc.c,v 1.72 2010/05/29 09:21:12 nanard Exp $ */\n+/* Project : miniupnp\n+ * Author : Thomas Bernard\n+ * Copyright (c) 2005-2010 Thomas Bernard\n+ * This software is subject to the conditions detailed in the\n+ * LICENCE file provided in this distribution. */\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <time.h>\n+#ifdef WIN32\n+#include <winsock2.h>\n+#define snprintf _snprintf\n+#endif\n+#include \"miniwget.h\"\n+#include \"miniupnpc.h\"\n+#include \"upnpcommands.h\"\n+#include \"upnperrors.h\"\n+\n+/* protofix() checks if protocol is \"UDP\" or \"TCP\" \n+ * returns NULL if not */\n+const char * protofix(const char * proto)\n+{\n+\tstatic const char proto_tcp[4] = { 'T', 'C', 'P', 0};\n+\tstatic const char proto_udp[4] = { 'U', 'D', 'P', 0};\n+\tint i, b;\n+\tfor(i=0, b=1; i<4; i++)\n+\t\tb = b && (   (proto[i] == proto_tcp[i]) \n+\t\t          || (proto[i] == (proto_tcp[i] | 32)) );\n+\tif(b)\n+\t\treturn proto_tcp;\n+\tfor(i=0, b=1; i<4; i++)\n+\t\tb = b && (   (proto[i] == proto_udp[i])\n+\t\t          || (proto[i] == (proto_udp[i] | 32)) );\n+\tif(b)\n+\t\treturn proto_udp;\n+\treturn 0;\n+}\n+\n+static void DisplayInfos(struct UPNPUrls * urls,\n+                         struct IGDdatas * data)\n+{\n+\tchar externalIPAddress[16];\n+\tchar connectionType[64];\n+\tchar status[64];\n+\tchar lastconnerr[64];\n+\tunsigned int uptime;\n+\tunsigned int brUp, brDown;\n+\ttime_t timenow, timestarted;\n+\tint r;\n+\tUPNP_GetConnectionTypeInfo(urls->controlURL,\n+\t                           data->first.servicetype,\n+\t\t\t\t\t\t\t   connectionType);\n+\tif(connectionType[0])\n+\t\tprintf(\"Connection Type : %s\\n\", connectionType);\n+\telse\n+\t\tprintf(\"GetConnectionTypeInfo failed.\\n\");\n+\tUPNP_GetStatusInfo(urls->controlURL, data->first.servicetype,\n+\t                   status, &uptime, lastconnerr);\n+\tprintf(\"Status : %s, uptime=%us, LastConnectionError : %s\\n\",\n+\t       status, uptime, lastconnerr);\n+\ttimenow = time(NULL);\n+\ttimestarted = timenow - uptime;\n+\tprintf(\"  Time started : %s\", ctime(&timestarted));\n+\tUPNP_GetLinkLayerMaxBitRates(urls->controlURL_CIF, data->CIF.servicetype,\n+\t\t\t&brDown, &brUp);\n+\tprintf(\"MaxBitRateDown : %u bps   MaxBitRateUp %u bps\\n\", brDown, brUp);\n+\tr = UPNP_GetExternalIPAddress(urls->controlURL,\n+\t                          data->first.servicetype,\n+\t\t\t\t\t\t\t  externalIPAddress);\n+\tif(r != UPNPCOMMAND_SUCCESS)\n+\t\tprintf(\"GetExternalIPAddress() returned %d\\n\", r);\n+\tif(externalIPAddress[0])\n+\t\tprintf(\"ExternalIPAddress = %s\\n\", externalIPAddress);\n+\telse\n+\t\tprintf(\"GetExternalIPAddress failed.\\n\");\n+}\n+\n+static void GetConnectionStatus(struct UPNPUrls * urls,\n+                               struct IGDdatas * data)\n+{\n+\tunsigned int bytessent, bytesreceived, packetsreceived, packetssent;\n+\tDisplayInfos(urls, data);\n+\tbytessent = UPNP_GetTotalBytesSent(urls->controlURL_CIF, data->CIF.servicetype);\n+\tbytesreceived = UPNP_GetTotalBytesReceived(urls->controlURL_CIF, data->CIF.servicetype);\n+\tpacketssent = UPNP_GetTotalPacketsSent(urls->controlURL_CIF, data->CIF.servicetype);\n+\tpacketsreceived = UPNP_GetTotalPacketsReceived(urls->controlURL_CIF, data->CIF.servicetype);\n+\tprintf(\"Bytes:   Sent: %8u\\tRecv: %8u\\n\", bytessent, bytesreceived);\n+\tprintf(\"Packets: Sent: %8u\\tRecv: %8u\\n\", packetssent, packetsreceived);\n+}\n+\n+static void ListRedirections(struct UPNPUrls * urls,\n+                             struct IGDdatas * data)\n+{\n+\tint r;\n+\tint i = 0;\n+\tchar index[6];\n+\tchar intClient[16];\n+\tchar intPort[6];\n+\tchar extPort[6];\n+\tchar protocol[4];\n+\tchar desc[80];\n+\tchar enabled[6];\n+\tchar rHost[64];\n+\tchar duration[16];\n+\t/*unsigned int num=0;\n+\tUPNP_GetPortMappingNumberOfEntries(urls->controlURL, data->servicetype, &num);\n+\tprintf(\"PortMappingNumberOfEntries : %u\\n\", num);*/\n+\tdo {\n+\t\tsnprintf(index, 6, \"%d\", i);\n+\t\trHost[0] = '\\0'; enabled[0] = '\\0';\n+\t\tduration[0] = '\\0'; desc[0] = '\\0';\n+\t\textPort[0] = '\\0'; intPort[0] = '\\0'; intClient[0] = '\\0';\n+\t\tr = UPNP_GetGenericPortMappingEntry(urls->controlURL,\n+\t\t                               data->first.servicetype,\n+\t\t                               index,\n+\t\t                               extPort, intClient, intPort,\n+\t\t\t\t\t\t\t\t\t   protocol, desc, enabled,\n+\t\t\t\t\t\t\t\t\t   rHost, duration);\n+\t\tif(r==0)\n+\t\t/*\n+\t\t\tprintf(\"%02d - %s %s->%s:%s\\tenabled=%s leaseDuration=%s\\n\"\n+\t\t\t       \"     desc='%s' rHost='%s'\\n\",\n+\t\t\t       i, protocol, extPort, intClient, intPort,\n+\t\t\t\t   enabled, duration,\n+\t\t\t\t   desc, rHost);\n+\t\t\t\t   */\n+\t\t\tprintf(\"%2d %s %5s->%s:%-5s '%s' '%s'\\n\",\n+\t\t\t       i, protocol, extPort, intClient, intPort,\n+\t\t\t       desc, rHost);\n+\t\telse\n+\t\t\tprintf(\"GetGenericPortMappingEntry() returned %d (%s)\\n\",\n+\t\t\t       r, strupnperror(r));\n+\t\ti++;\n+\t} while(r==0);\n+}\n+\n+/* Test function \n+ * 1 - get connection type\n+ * 2 - get extenal ip address\n+ * 3 - Add port mapping\n+ * 4 - get this port mapping from the IGD */\n+static void SetRedirectAndTest(struct UPNPUrls * urls,\n+                               struct IGDdatas * data,\n+\t\t\t\t\t\t\t   const char * iaddr,\n+\t\t\t\t\t\t\t   const char * iport,\n+\t\t\t\t\t\t\t   const char * eport,\n+                               const char * proto)\n+{\n+\tchar externalIPAddress[16];\n+\tchar intClient[16];\n+\tchar intPort[6];\n+\tint r;\n+\n+\tif(!iaddr || !iport || !eport || !proto)\n+\t{\n+\t\tfprintf(stderr, \"Wrong arguments\\n\");\n+\t\treturn;\n+\t}\n+\tproto = protofix(proto);\n+\tif(!proto)\n+\t{\n+\t\tfprintf(stderr, \"invalid protocol\\n\");\n+\t\treturn;\n+\t}\n+\t\n+\tUPNP_GetExternalIPAddress(urls->controlURL,\n+\t                          data->first.servicetype,\n+\t\t\t\t\t\t\t  externalIPAddress);\n+\tif(externalIPAddress[0])\n+\t\tprintf(\"ExternalIPAddress = %s\\n\", externalIPAddress);\n+\telse\n+\t\tprintf(\"GetExternalIPAddress failed.\\n\");\n+\t\n+\tr = UPNP_AddPortMapping(urls->controlURL, data->first.servicetype,\n+\t                        eport, iport, iaddr, 0, proto, 0);\n+\tif(r!=UPNPCOMMAND_SUCCESS)\n+\t\tprintf(\"AddPortMapping(%s, %s, %s) failed with code %d (%s)\\n\",\n+\t\t       eport, iport, iaddr, r, strupnperror(r));\n+\n+\tr = UPNP_GetSpecificPortMappingEntry(urls->controlURL,\n+\t                                 data->first.servicetype,\n+    \t                             eport, proto,\n+\t\t\t\t\t\t\t\t\t intClient, intPort);\n+\tif(r!=UPNPCOMMAND_SUCCESS)\n+\t\tprintf(\"GetSpecificPortMappingEntry() failed with code %d (%s)\\n\",\n+\t\t       r, strupnperror(r));\n+\t\n+\tif(intClient[0]) {\n+\t\tprintf(\"InternalIP:Port = %s:%s\\n\", intClient, intPort);\n+\t\tprintf(\"external %s:%s %s is redirected to internal %s:%s\\n\",\n+\t\t       externalIPAddress, eport, proto, intClient, intPort);\n+\t}\n+}\n+\n+static void\n+RemoveRedirect(struct UPNPUrls * urls,\n+               struct IGDdatas * data,\n+\t\t\t   const char * eport,\n+\t\t\t   const char * proto)\n+{\n+\tint r;\n+\tif(!proto || !eport)\n+\t{\n+\t\tfprintf(stderr, \"invalid arguments\\n\");\n+\t\treturn;\n+\t}\n+\tproto = protofix(proto);\n+\tif(!proto)\n+\t{\n+\t\tfprintf(stderr, \"protocol invalid\\n\");\n+\t\treturn;\n+\t}\n+\tr = UPNP_DeletePortMapping(urls->controlURL, data->first.servicetype, eport, proto, 0);\n+\tprintf(\"UPNP_DeletePortMapping() returned : %d\\n\", r);\n+}\n+\n+\n+/* sample upnp client program */\n+int main(int argc, char ** argv)\n+{\n+\tchar command = 0;\n+\tchar ** commandargv = 0;\n+\tint commandargc = 0;\n+\tstruct UPNPDev * devlist = 0;\n+\tchar lanaddr[64];\t/* my ip address on the LAN */\n+\tint i;\n+\tconst char * rootdescurl = 0;\n+\tconst char * multicastif = 0;\n+\tconst char * minissdpdpath = 0;\n+\tint retcode = 0;\n+\n+#ifdef WIN32\n+\tWSADATA wsaData;\n+\tint nResult = WSAStartup(MAKEWORD(2,2), &wsaData);\n+\tif(nResult != NO_ERROR)\n+\t{\n+\t\tfprintf(stderr, \"WSAStartup() failed.\\n\");\n+\t\treturn -1;\n+\t}\n+#endif\n+    printf(\"upnpc : miniupnpc library test client. (c) 2006-2010 Thomas Bernard\\n\");\n+    printf(\"Go to http://miniupnp.free.fr/ or http://miniupnp.tuxfamily.org/\\n\"\n+\t       \"for more information.\\n\");\n+\t/* command line processing */\n+\tfor(i=1; i<argc; i++)\n+\t{\n+\t\tif(argv[i][0] == '-')\n+\t\t{\n+\t\t\tif(argv[i][1] == 'u')\n+\t\t\t\trootdescurl = argv[++i];\n+\t\t\telse if(argv[i][1] == 'm')\n+\t\t\t\tmulticastif = argv[++i];\n+\t\t\telse if(argv[i][1] == 'p')\n+\t\t\t\tminissdpdpath = argv[++i];\n+\t\t\telse\n+\t\t\t{\n+\t\t\t\tcommand = argv[i][1];\n+\t\t\t\ti++;\n+\t\t\t\tcommandargv = argv + i;\n+\t\t\t\tcommandargc = argc - i;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\t\telse\n+\t\t{\n+\t\t\tfprintf(stderr, \"option '%s' invalid\\n\", argv[i]);\n+\t\t}\n+\t}\n+\n+\tif(!command || (command == 'a' && commandargc<4)\n+\t   || (command == 'd' && argc<2)\n+\t   || (command == 'r' && argc<2))\n+\t{\n+\t\tfprintf(stderr, \"Usage :\\t%s [options] -a ip port external_port protocol\\n\\t\\tAdd port redirection\\n\", argv[0]);\n+\t\tfprintf(stderr, \"       \\t%s [options] -d external_port protocol [port2 protocol2]\u00a0[...]\\n\\t\\tDelete port redirection\\n\", argv[0]);\n+\t\tfprintf(stderr, \"       \\t%s [options] -s\\n\\t\\tGet Connection status\\n\", argv[0]);\n+\t\tfprintf(stderr, \"       \\t%s [options] -l\\n\\t\\tList redirections\\n\", argv[0]);\n+\t\tfprintf(stderr, \"       \\t%s [options] -r port1 protocol1 [port2 protocol2] [...]\\n\\t\\tAdd all redirections to the current host\\n\", argv[0]);\n+\t\tfprintf(stderr, \"\\nprotocol is UDP or TCP\\n\");\n+\t\tfprintf(stderr, \"Options:\\n\");\n+\t\tfprintf(stderr, \"  -u url : bypass discovery process by providing the XML root description url.\\n\");\n+\t\tfprintf(stderr, \"  -m address : provide ip address of the interface to use for sending SSDP multicast packets.\\n\");\n+\t\tfprintf(stderr, \"  -p path : use this path for MiniSSDPd socket.\\n\");\n+\t\treturn 1;\n+\t}\n+\n+\tif( rootdescurl\n+\t  || (devlist = upnpDiscover(2000, multicastif, minissdpdpath, 0)))\n+\t{\n+\t\tstruct UPNPDev * device;\n+\t\tstruct UPNPUrls urls;\n+\t\tstruct IGDdatas data;\n+\t\tif(devlist)\n+\t\t{\n+\t\t\tprintf(\"List of UPNP devices found on the network :\\n\");\n+\t\t\tfor(device = devlist; device; device = device->pNext)\n+\t\t\t{\n+\t\t\t\tprintf(\" desc: %s\\n st: %s\\n\\n\",\n+\t\t\t\t\t   device->descURL, device->st);\n+\t\t\t}\n+\t\t}\n+\t\ti = 1;\n+\t\tif( (rootdescurl && UPNP_GetIGDFromUrl(rootdescurl, &urls, &data, lanaddr, sizeof(lanaddr)))\n+\t\t  || (i = UPNP_GetValidIGD(devlist, &urls, &data, lanaddr, sizeof(lanaddr))))\n+\t\t{\n+\t\t\tswitch(i) {\n+\t\t\tcase 1:\n+\t\t\t\tprintf(\"Found valid IGD : %s\\n\", urls.controlURL);\n+\t\t\t\tbreak;\n+\t\t\tcase 2:\n+\t\t\t\tprintf(\"Found a (not connected?) IGD : %s\\n\", urls.controlURL);\n+\t\t\t\tprintf(\"Trying to continue anyway\\n\");\n+\t\t\t\tbreak;\n+\t\t\tcase 3:\n+\t\t\t\tprintf(\"UPnP device found. Is it an IGD ? : %s\\n\", urls.controlURL);\n+\t\t\t\tprintf(\"Trying to continue anyway\\n\");\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tprintf(\"Found device (igd ?) : %s\\n\", urls.controlURL);\n+\t\t\t\tprintf(\"Trying to continue anyway\\n\");\n+\t\t\t}\n+\t\t\tprintf(\"Local LAN ip address : %s\\n\", lanaddr);\n+\t\t\t#if 0\n+\t\t\tprintf(\"getting \\\"%s\\\"\\n\", urls.ipcondescURL);\n+\t\t\tdescXML = miniwget(urls.ipcondescURL, &descXMLsize);\n+\t\t\tif(descXML)\n+\t\t\t{\n+\t\t\t\t/*fwrite(descXML, 1, descXMLsize, stdout);*/\n+\t\t\t\tfree(descXML); descXML = NULL;\n+\t\t\t}\n+\t\t\t#endif\n+\n+\t\t\tswitch(command)\n+\t\t\t{\n+\t\t\tcase 'l':\n+\t\t\t\tDisplayInfos(&urls, &data);\n+\t\t\t\tListRedirections(&urls, &data);\n+\t\t\t\tbreak;\n+\t\t\tcase 'a':\n+\t\t\t\tSetRedirectAndTest(&urls, &data,\n+\t\t\t\t                   commandargv[0], commandargv[1],\n+\t\t\t\t                   commandargv[2], commandargv[3]);\n+\t\t\t\tbreak;\n+\t\t\tcase 'd':\n+\t\t\t\tfor(i=0; i<commandargc; i+=2)\n+\t\t\t\t{\n+\t\t\t\t\tRemoveRedirect(&urls, &data, commandargv[i], commandargv[i+1]);\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\t\t\tcase 's':\n+\t\t\t\tGetConnectionStatus(&urls, &data);\n+\t\t\t\tbreak;\n+\t\t\tcase 'r':\n+\t\t\t\tfor(i=0; i<commandargc; i+=2)\n+\t\t\t\t{\n+\t\t\t\t\t/*printf(\"port %s protocol %s\\n\", argv[i], argv[i+1]);*/\n+\t\t\t\t\tSetRedirectAndTest(&urls, &data,\n+\t\t\t\t\t                   lanaddr, commandargv[i],\n+\t\t\t\t\t\t\t\t\t   commandargv[i], commandargv[i+1]);\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tfprintf(stderr, \"Unknown switch -%c\\n\", command);\n+\t\t\t\tretcode = 1;\n+\t\t\t}\n+\n+\t\t\tFreeUPNPUrls(&urls);\n+\t\t}\n+\t\telse\n+\t\t{\n+\t\t\tfprintf(stderr, \"No valid UPNP Internet Gateway Device found.\\n\");\n+\t\t\tretcode = 1;\n+\t\t}\n+\t\tfreeUPNPDevlist(devlist); devlist = 0;\n+\t}\n+\telse\n+\t{\n+\t\tfprintf(stderr, \"No IGD UPnP Device found on the network !\\n\");\n+\t\tretcode = 1;\n+\t}\n+\treturn retcode;\n+}\n+"
      },
      {
        "sha": "20e48d819bb157a6c6c320210f587f4c41e47a96",
        "filename": "miniupnpc/upnpcommands.c",
        "status": "added",
        "additions": 611,
        "deletions": 0,
        "changes": 611,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/upnpcommands.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/upnpcommands.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/miniupnpc/upnpcommands.c?ref=b94b7b05a7b1d27e28ca9a8684877ca605d70256",
        "patch": "@@ -0,0 +1,611 @@\n+/* $Id: upnpcommands.c,v 1.26 2010/06/09 10:59:09 nanard Exp $ */\n+/* Project : miniupnp\n+ * Author : Thomas Bernard\n+ * Copyright (c) 2005-2010 Thomas Bernard\n+ * This software is subject to the conditions detailed in the\n+ * LICENCE file provided in this distribution.\n+ * */\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <string.h>\n+#include \"upnpcommands.h\"\n+#include \"miniupnpc.h\"\n+\n+static UNSIGNED_INTEGER\n+my_atoui(const char * s)\n+{\n+\treturn s ? ((UNSIGNED_INTEGER)STRTOUI(s, NULL, 0)) : 0;\n+}\n+\n+/*\n+ * */\n+LIBSPEC UNSIGNED_INTEGER\n+UPNP_GetTotalBytesSent(const char * controlURL,\n+\t\t\t\t\tconst char * servicetype)\n+{\n+\tstruct NameValueParserData pdata;\n+\tchar buffer[4096];\n+\tint bufsize = 4096;\n+\tunsigned int r = 0;\n+\tchar * p;\n+\tif(simpleUPnPcommand(-1, controlURL, servicetype, \"GetTotalBytesSent\", 0, buffer, &bufsize) < 0) {\n+\t\treturn UPNPCOMMAND_HTTP_ERROR;\n+\t}\n+\tParseNameValue(buffer, bufsize, &pdata);\n+\t/*DisplayNameValueList(buffer, bufsize);*/\n+\tp = GetValueFromNameValueList(&pdata, \"NewTotalBytesSent\");\n+\tr = my_atoui(p);\n+\tClearNameValueList(&pdata);\n+\treturn r;\n+}\n+\n+/*\n+ * */\n+LIBSPEC UNSIGNED_INTEGER\n+UPNP_GetTotalBytesReceived(const char * controlURL,\n+\t\t\t\t\t\tconst char * servicetype)\n+{\n+\tstruct NameValueParserData pdata;\n+\tchar buffer[4096];\n+\tint bufsize = 4096;\n+\tunsigned int r = 0;\n+\tchar * p;\n+\tif(simpleUPnPcommand(-1, controlURL, servicetype, \"GetTotalBytesReceived\", 0, buffer, &bufsize) < 0) {\n+\t\treturn UPNPCOMMAND_HTTP_ERROR;\n+\t}\n+\tParseNameValue(buffer, bufsize, &pdata);\n+\t/*DisplayNameValueList(buffer, bufsize);*/\n+\tp = GetValueFromNameValueList(&pdata, \"NewTotalBytesReceived\");\n+\tr = my_atoui(p);\n+\tClearNameValueList(&pdata);\n+\treturn r;\n+}\n+\n+/*\n+ * */\n+LIBSPEC UNSIGNED_INTEGER\n+UPNP_GetTotalPacketsSent(const char * controlURL,\n+\t\t\t\t\t\tconst char * servicetype)\n+{\n+\tstruct NameValueParserData pdata;\n+\tchar buffer[4096];\n+\tint bufsize = 4096;\n+\tunsigned int r = 0;\n+\tchar * p;\n+\tif(simpleUPnPcommand(-1, controlURL, servicetype, \"GetTotalPacketsSent\", 0, buffer, &bufsize) < 0) {\n+\t\treturn UPNPCOMMAND_HTTP_ERROR;\n+\t}\n+\tParseNameValue(buffer, bufsize, &pdata);\n+\t/*DisplayNameValueList(buffer, bufsize);*/\n+\tp = GetValueFromNameValueList(&pdata, \"NewTotalPacketsSent\");\n+\tr = my_atoui(p);\n+\tClearNameValueList(&pdata);\n+\treturn r;\n+}\n+\n+/*\n+ * */\n+LIBSPEC UNSIGNED_INTEGER\n+UPNP_GetTotalPacketsReceived(const char * controlURL,\n+\t\t\t\t\t\tconst char * servicetype)\n+{\n+\tstruct NameValueParserData pdata;\n+\tchar buffer[4096];\n+\tint bufsize = 4096;\n+\tunsigned int r = 0;\n+\tchar * p;\n+\tif(simpleUPnPcommand(-1, controlURL, servicetype, \"GetTotalPacketsReceived\", 0, buffer, &bufsize) < 0) {\n+\t\treturn UPNPCOMMAND_HTTP_ERROR;\n+\t}\n+\tParseNameValue(buffer, bufsize, &pdata);\n+\t/*DisplayNameValueList(buffer, bufsize);*/\n+\tp = GetValueFromNameValueList(&pdata, \"NewTotalPacketsReceived\");\n+\tr = my_atoui(p);\n+\tClearNameValueList(&pdata);\n+\treturn r;\n+}\n+\n+/* UPNP_GetStatusInfo() call the corresponding UPNP method\n+ * returns the current status and uptime */\n+LIBSPEC int\n+UPNP_GetStatusInfo(const char * controlURL,\n+\t\t\t\tconst char * servicetype,\n+\t\t\t\tchar * status, \n+\t\t\t\tunsigned int * uptime,\n+\t\t\t\tchar * lastconnerror)\n+{\n+\tstruct NameValueParserData pdata;\n+\tchar buffer[4096];\n+\tint bufsize = 4096;\n+\tchar * p;\n+\tchar * up;\n+\tchar * err;\n+\tint ret = UPNPCOMMAND_UNKNOWN_ERROR;\n+\n+\tif(!status && !uptime)\n+\t\treturn UPNPCOMMAND_INVALID_ARGS;\n+\n+\tif(simpleUPnPcommand(-1, controlURL, servicetype, \"GetStatusInfo\", 0, buffer, &bufsize) < 0) {\n+\t\treturn UPNPCOMMAND_HTTP_ERROR;\n+\t}\n+\tParseNameValue(buffer, bufsize, &pdata);\n+\t/*DisplayNameValueList(buffer, bufsize);*/\n+\tup = GetValueFromNameValueList(&pdata, \"NewUptime\");\n+\tp = GetValueFromNameValueList(&pdata, \"NewConnectionStatus\");\n+\terr = GetValueFromNameValueList(&pdata, \"NewLastConnectionError\");\n+\tif(p && up)\n+\t  ret = UPNPCOMMAND_SUCCESS;\n+\n+\tif(status) {\n+\t\tif(p){\n+\t\t\tstrncpy(status, p, 64 );\n+\t\t\tstatus[63] = '\\0';\n+\t\t}else\n+\t\t\tstatus[0]= '\\0';\n+\t}\n+\n+\tif(uptime) {\n+\t\tif(up)\n+\t\t\tsscanf(up,\"%u\",uptime);\n+\t\telse\n+\t\t\tuptime = 0;\n+\t}\n+\n+\tif(lastconnerror) {\n+\t\tif(err) {\n+\t\t\tstrncpy(lastconnerror, err, 64 );\n+\t\t\tlastconnerror[63] = '\\0';\n+\t\t} else\n+\t\t\tlastconnerror[0] = '\\0';\n+\t}\n+\n+\tp = GetValueFromNameValueList(&pdata, \"errorCode\");\n+\tif(p) {\n+\t\tret = UPNPCOMMAND_UNKNOWN_ERROR;\n+\t\tsscanf(p, \"%d\", &ret);\n+\t}\n+\tClearNameValueList(&pdata);\n+\treturn ret;\n+}\n+\n+/* UPNP_GetConnectionTypeInfo() call the corresponding UPNP method\n+ * returns the connection type */\n+LIBSPEC int\n+UPNP_GetConnectionTypeInfo(const char * controlURL,\n+                           const char * servicetype,\n+                           char * connectionType)\n+{\n+\tstruct NameValueParserData pdata;\n+\tchar buffer[4096];\n+\tint bufsize = 4096;\n+\tchar * p;\n+\tint ret = UPNPCOMMAND_UNKNOWN_ERROR;\n+\n+\tif(!connectionType)\n+\t\treturn UPNPCOMMAND_INVALID_ARGS;\n+\n+\tif(simpleUPnPcommand(-1, controlURL, servicetype,\n+\t                  \"GetConnectionTypeInfo\", 0, buffer, &bufsize) < 0) {\n+\t\treturn UPNPCOMMAND_HTTP_ERROR;\n+\t}\n+\tParseNameValue(buffer, bufsize, &pdata);\n+\tp = GetValueFromNameValueList(&pdata, \"NewConnectionType\");\n+\t/*p = GetValueFromNameValueList(&pdata, \"NewPossibleConnectionTypes\");*/\n+\t/* PossibleConnectionTypes will have several values.... */\n+\tif(p) {\n+\t\tstrncpy(connectionType, p, 64 );\n+\t\tconnectionType[63] = '\\0';\n+\t\tret = UPNPCOMMAND_SUCCESS;\n+\t} else\n+\t\tconnectionType[0] = '\\0';\n+\tp = GetValueFromNameValueList(&pdata, \"errorCode\");\n+\tif(p) {\n+\t\tret = UPNPCOMMAND_UNKNOWN_ERROR;\n+\t\tsscanf(p, \"%d\", &ret);\n+\t}\n+\tClearNameValueList(&pdata);\n+\treturn ret;\n+}\n+\n+/* UPNP_GetLinkLayerMaxBitRate() call the corresponding UPNP method.\n+ * Returns 2 values: Downloadlink bandwidth and Uplink bandwidth.\n+ * One of the values can be null \n+ * Note : GetLinkLayerMaxBitRates belongs to WANPPPConnection:1 only \n+ * We can use the GetCommonLinkProperties from WANCommonInterfaceConfig:1 */\n+LIBSPEC int\n+UPNP_GetLinkLayerMaxBitRates(const char * controlURL,\n+                             const char * servicetype,\n+                             unsigned int * bitrateDown,\n+                             unsigned int* bitrateUp)\n+{\n+\tstruct NameValueParserData pdata;\n+\tchar buffer[4096];\n+\tint bufsize = 4096;\n+\tint ret = UPNPCOMMAND_UNKNOWN_ERROR;\n+\tchar * down;\n+\tchar * up;\n+\tchar * p;\n+\n+\tif(!bitrateDown && !bitrateUp)\n+\t\treturn UPNPCOMMAND_INVALID_ARGS;\n+\n+\t/* shouldn't we use GetCommonLinkProperties ? */\n+\tif(simpleUPnPcommand(-1, controlURL, servicetype,\n+\t                  \"GetCommonLinkProperties\", 0, buffer, &bufsize) < 0) {\n+\t                  /*\"GetLinkLayerMaxBitRates\", 0, buffer, &bufsize);*/\n+\t\treturn UPNPCOMMAND_HTTP_ERROR;\n+\t}\n+\t/*DisplayNameValueList(buffer, bufsize);*/\n+\tParseNameValue(buffer, bufsize, &pdata);\n+\t/*down = GetValueFromNameValueList(&pdata, \"NewDownstreamMaxBitRate\");*/\n+\t/*up = GetValueFromNameValueList(&pdata, \"NewUpstreamMaxBitRate\");*/\n+\tdown = GetValueFromNameValueList(&pdata, \"NewLayer1DownstreamMaxBitRate\");\n+\tup = GetValueFromNameValueList(&pdata, \"NewLayer1UpstreamMaxBitRate\");\n+\t/*GetValueFromNameValueList(&pdata, \"NewWANAccessType\");*/\n+\t/*GetValueFromNameValueList(&pdata, \"NewPhysicalLinkSatus\");*/\n+\tif(down && up)\n+\t\tret = UPNPCOMMAND_SUCCESS;\n+\n+\tif(bitrateDown) {\n+\t\tif(down)\n+\t\t\tsscanf(down,\"%u\",bitrateDown);\n+\t\telse\n+\t\t\t*bitrateDown = 0;\n+\t}\n+\n+\tif(bitrateUp) {\n+\t\tif(up)\n+\t\t\tsscanf(up,\"%u\",bitrateUp);\n+\t\telse\n+\t\t\t*bitrateUp = 0;\n+\t}\n+\tp = GetValueFromNameValueList(&pdata, \"errorCode\");\n+\tif(p) {\n+\t\tret = UPNPCOMMAND_UNKNOWN_ERROR;\n+\t\tsscanf(p, \"%d\", &ret);\n+\t}\n+\tClearNameValueList(&pdata);\n+\treturn ret;\n+}\n+\n+\n+/* UPNP_GetExternalIPAddress() call the corresponding UPNP method.\n+ * if the third arg is not null the value is copied to it.\n+ * at least 16 bytes must be available\n+ * \n+ * Return values :\n+ * 0 : SUCCESS\n+ * NON ZERO : ERROR Either an UPnP error code or an unknown error.\n+ *\n+ * 402 Invalid Args - See UPnP Device Architecture section on Control.\n+ * 501 Action Failed - See UPnP Device Architecture section on Control.\n+ */\n+LIBSPEC int\n+UPNP_GetExternalIPAddress(const char * controlURL,\n+                          const char * servicetype,\n+                          char * extIpAdd)\n+{\n+\tstruct NameValueParserData pdata;\n+\tchar buffer[4096];\n+\tint bufsize = 4096;\n+\tchar * p;\n+\tint ret = UPNPCOMMAND_UNKNOWN_ERROR;\n+\n+\tif(!extIpAdd || !controlURL || !servicetype)\n+\t\treturn UPNPCOMMAND_INVALID_ARGS;\n+\n+\tif(simpleUPnPcommand(-1, controlURL, servicetype, \"GetExternalIPAddress\", 0, buffer, &bufsize) < 0) {\n+\t\treturn UPNPCOMMAND_HTTP_ERROR;\n+\t}\n+\t/*DisplayNameValueList(buffer, bufsize);*/\n+\tParseNameValue(buffer, bufsize, &pdata);\n+\t/*printf(\"external ip = %s\\n\", GetValueFromNameValueList(&pdata, \"NewExternalIPAddress\") );*/\n+\tp = GetValueFromNameValueList(&pdata, \"NewExternalIPAddress\");\n+\tif(p) {\n+\t\tstrncpy(extIpAdd, p, 16 );\n+\t\textIpAdd[15] = '\\0';\n+\t\tret = UPNPCOMMAND_SUCCESS;\n+\t} else\n+\t\textIpAdd[0] = '\\0';\n+\n+\tp = GetValueFromNameValueList(&pdata, \"errorCode\");\n+\tif(p) {\n+\t\tret = UPNPCOMMAND_UNKNOWN_ERROR;\n+\t\tsscanf(p, \"%d\", &ret);\n+\t}\n+\n+\tClearNameValueList(&pdata);\n+\treturn ret;\n+}\n+\n+LIBSPEC int\n+UPNP_AddPortMapping(const char * controlURL, const char * servicetype,\n+                    const char * extPort,\n+\t\t\t\t\tconst char * inPort,\n+\t\t\t\t\tconst char * inClient,\n+\t\t\t\t\tconst char * desc,\n+\t\t\t\t\tconst char * proto,\n+                    const char * remoteHost)\n+{\n+\tstruct UPNParg * AddPortMappingArgs;\n+\tchar buffer[4096];\n+\tint bufsize = 4096;\n+\tstruct NameValueParserData pdata;\n+\tconst char * resVal;\n+\tint ret;\n+\n+\tif(!inPort || !inClient || !proto || !extPort)\n+\t\treturn UPNPCOMMAND_INVALID_ARGS;\n+\n+\tAddPortMappingArgs = calloc(9, sizeof(struct UPNParg));\n+\tAddPortMappingArgs[0].elt = \"NewRemoteHost\";\n+\tAddPortMappingArgs[0].val = remoteHost;\n+\tAddPortMappingArgs[1].elt = \"NewExternalPort\";\n+\tAddPortMappingArgs[1].val = extPort;\n+\tAddPortMappingArgs[2].elt = \"NewProtocol\";\n+\tAddPortMappingArgs[2].val = proto;\n+\tAddPortMappingArgs[3].elt = \"NewInternalPort\";\n+\tAddPortMappingArgs[3].val = inPort;\n+\tAddPortMappingArgs[4].elt = \"NewInternalClient\";\n+\tAddPortMappingArgs[4].val = inClient;\n+\tAddPortMappingArgs[5].elt = \"NewEnabled\";\n+\tAddPortMappingArgs[5].val = \"1\";\n+\tAddPortMappingArgs[6].elt = \"NewPortMappingDescription\";\n+\tAddPortMappingArgs[6].val = desc?desc:\"libminiupnpc\";\n+\tAddPortMappingArgs[7].elt = \"NewLeaseDuration\";\n+\tAddPortMappingArgs[7].val = \"0\";\n+\tif(simpleUPnPcommand(-1, controlURL, servicetype, \"AddPortMapping\", AddPortMappingArgs, buffer, &bufsize) < 0) {\n+\t\tfree(AddPortMappingArgs);\n+\t\treturn UPNPCOMMAND_HTTP_ERROR;\n+\t}\n+\t/*DisplayNameValueList(buffer, bufsize);*/\n+\t/*buffer[bufsize] = '\\0';*/\n+\t/*puts(buffer);*/\n+\tParseNameValue(buffer, bufsize, &pdata);\n+\tresVal = GetValueFromNameValueList(&pdata, \"errorCode\");\n+\tif(resVal) {\n+\t\t/*printf(\"AddPortMapping errorCode = '%s'\\n\", resVal); */\n+\t\tret = UPNPCOMMAND_UNKNOWN_ERROR;\n+\t\tsscanf(resVal, \"%d\", &ret);\n+\t} else {\n+\t\tret = UPNPCOMMAND_SUCCESS;\n+\t}\n+\tClearNameValueList(&pdata);\n+\tfree(AddPortMappingArgs);\n+\treturn ret;\n+}\n+\n+LIBSPEC int\n+UPNP_DeletePortMapping(const char * controlURL, const char * servicetype,\n+                       const char * extPort, const char * proto,\n+                       const char * remoteHost)\n+{\n+\t/*struct NameValueParserData pdata;*/\n+\tstruct UPNParg * DeletePortMappingArgs;\n+\tchar buffer[4096];\n+\tint bufsize = 4096;\n+\tstruct NameValueParserData pdata;\n+\tconst char * resVal;\n+\tint ret;\n+\n+\tif(!extPort || !proto)\n+\t\treturn UPNPCOMMAND_INVALID_ARGS;\n+\n+\tDeletePortMappingArgs = calloc(4, sizeof(struct UPNParg));\n+\tDeletePortMappingArgs[0].elt = \"NewRemoteHost\";\n+\tDeletePortMappingArgs[0].val = remoteHost;\n+\tDeletePortMappingArgs[1].elt = \"NewExternalPort\";\n+\tDeletePortMappingArgs[1].val = extPort;\n+\tDeletePortMappingArgs[2].elt = \"NewProtocol\";\n+\tDeletePortMappingArgs[2].val = proto;\n+\tif(simpleUPnPcommand(-1, controlURL, servicetype,\n+\t                     \"DeletePortMapping\",\n+\t                     DeletePortMappingArgs, buffer, &bufsize) < 0 ) {\n+\t\tfree(DeletePortMappingArgs);\n+\t\treturn UPNPCOMMAND_HTTP_ERROR;\n+\t}\n+\t/*DisplayNameValueList(buffer, bufsize);*/\n+\tParseNameValue(buffer, bufsize, &pdata);\n+\tresVal = GetValueFromNameValueList(&pdata, \"errorCode\");\n+\tif(resVal) {\n+\t\tret = UPNPCOMMAND_UNKNOWN_ERROR;\n+\t\tsscanf(resVal, \"%d\", &ret);\n+\t} else {\n+\t\tret = UPNPCOMMAND_SUCCESS;\n+\t}\n+\tClearNameValueList(&pdata);\n+\tfree(DeletePortMappingArgs);\n+\treturn ret;\n+}\n+\n+LIBSPEC int\n+UPNP_GetGenericPortMappingEntry(const char * controlURL,\n+                                const char * servicetype,\n+\t\t\t\t\t\t\t const char * index,\n+\t\t\t\t\t\t\t char * extPort,\n+\t\t\t\t\t\t\t char * intClient,\n+\t\t\t\t\t\t\t char * intPort,\n+\t\t\t\t\t\t\t char * protocol,\n+\t\t\t\t\t\t\t char * desc,\n+\t\t\t\t\t\t\t char * enabled,\n+\t\t\t\t\t\t\t char * rHost,\n+\t\t\t\t\t\t\t char * duration)\n+{\n+\tstruct NameValueParserData pdata;\n+\tstruct UPNParg * GetPortMappingArgs;\n+\tchar buffer[4096];\n+\tint bufsize = 4096;\n+\tchar * p;\n+\tint r = UPNPCOMMAND_UNKNOWN_ERROR;\n+\tif(!index)\n+\t\treturn UPNPCOMMAND_INVALID_ARGS;\n+\tintClient[0] = '\\0';\n+\tintPort[0] = '\\0';\n+\tGetPortMappingArgs = calloc(2, sizeof(struct UPNParg));\n+\tGetPortMappingArgs[0].elt = \"NewPortMappingIndex\";\n+\tGetPortMappingArgs[0].val = index;\n+\tif(simpleUPnPcommand(-1, controlURL, servicetype,\n+\t                  \"GetGenericPortMappingEntry\",\n+\t\t\t\t\t  GetPortMappingArgs, buffer, &bufsize) < 0) {\n+\t\tfree(GetPortMappingArgs);\n+\t\treturn UPNPCOMMAND_HTTP_ERROR;\n+\t}\n+\tParseNameValue(buffer, bufsize, &pdata);\n+\tp = GetValueFromNameValueList(&pdata, \"NewRemoteHost\");\n+\tif(p && rHost)\n+\t{\n+\t\tstrncpy(rHost, p, 64);\n+\t\trHost[63] = '\\0';\n+\t}\n+\tp = GetValueFromNameValueList(&pdata, \"NewExternalPort\");\n+\tif(p && extPort)\n+\t{\n+\t\tstrncpy(extPort, p, 6);\n+\t\textPort[5] = '\\0';\n+\t\tr = UPNPCOMMAND_SUCCESS;\n+\t}\n+\tp = GetValueFromNameValueList(&pdata, \"NewProtocol\");\n+\tif(p && protocol)\n+\t{\n+\t\tstrncpy(protocol, p, 4);\n+\t\tprotocol[3] = '\\0';\n+\t}\n+\tp = GetValueFromNameValueList(&pdata, \"NewInternalClient\");\n+\tif(p && intClient)\n+\t{\n+\t\tstrncpy(intClient, p, 16);\n+\t\tintClient[15] = '\\0';\n+\t\tr = 0;\n+\t}\n+\tp = GetValueFromNameValueList(&pdata, \"NewInternalPort\");\n+\tif(p && intPort)\n+\t{\n+\t\tstrncpy(intPort, p, 6);\n+\t\tintPort[5] = '\\0';\n+\t}\n+\tp = GetValueFromNameValueList(&pdata, \"NewEnabled\");\n+\tif(p && enabled)\n+\t{\n+\t\tstrncpy(enabled, p, 4);\n+\t\tenabled[3] = '\\0';\n+\t}\n+\tp = GetValueFromNameValueList(&pdata, \"NewPortMappingDescription\");\n+\tif(p && desc)\n+\t{\n+\t\tstrncpy(desc, p, 80);\n+\t\tdesc[79] = '\\0';\n+\t}\n+\tp = GetValueFromNameValueList(&pdata, \"NewLeaseDuration\");\n+\tif(p && duration)\n+\t{\n+\t\tstrncpy(duration, p, 16);\n+\t\tduration[15] = '\\0';\n+\t}\n+\tp = GetValueFromNameValueList(&pdata, \"errorCode\");\n+\tif(p) {\n+\t\tr = UPNPCOMMAND_UNKNOWN_ERROR;\n+\t\tsscanf(p, \"%d\", &r);\n+\t}\n+\tClearNameValueList(&pdata);\n+\tfree(GetPortMappingArgs);\n+\treturn r;\n+}\n+\n+LIBSPEC int\n+UPNP_GetPortMappingNumberOfEntries(const char * controlURL,\n+                                   const char * servicetype,\n+                                   unsigned int * numEntries)\n+{\n+ \tstruct NameValueParserData pdata;\n+ \tchar buffer[4096];\n+ \tint bufsize = 4096;\n+ \tchar* p;\n+\tint ret = UPNPCOMMAND_UNKNOWN_ERROR;\n+ \tif(simpleUPnPcommand(-1, controlURL, servicetype, \"GetPortMappingNumberOfEntries\", 0, buffer, &bufsize) < 0) {\n+\t\treturn UPNPCOMMAND_HTTP_ERROR;\n+\t}\n+#ifdef DEBUG\n+\tDisplayNameValueList(buffer, bufsize);\n+#endif\n+ \tParseNameValue(buffer, bufsize, &pdata);\n+\n+ \tp = GetValueFromNameValueList(&pdata, \"NewPortMappingNumberOfEntries\");\n+ \tif(numEntries && p) {\n+\t\t*numEntries = 0;\n+ \t\tsscanf(p, \"%u\", numEntries);\n+\t\tret = UPNPCOMMAND_SUCCESS;\n+ \t}\n+\n+\tp = GetValueFromNameValueList(&pdata, \"errorCode\");\n+\tif(p) {\n+\t\tret = UPNPCOMMAND_UNKNOWN_ERROR;\n+\t\tsscanf(p, \"%d\", &ret);\n+\t}\n+\n+ \tClearNameValueList(&pdata);\n+\treturn ret;\n+}\n+\n+/* UPNP_GetSpecificPortMappingEntry retrieves an existing port mapping\n+ * the result is returned in the intClient and intPort strings\n+ * please provide 16 and 6 bytes of data */\n+LIBSPEC int\n+UPNP_GetSpecificPortMappingEntry(const char * controlURL,\n+                                 const char * servicetype,\n+                                 const char * extPort,\n+\t\t\t\t\t\t\t     const char * proto,\n+                                 char * intClient,\n+                                 char * intPort)\n+{\n+\tstruct NameValueParserData pdata;\n+\tstruct UPNParg * GetPortMappingArgs;\n+\tchar buffer[4096];\n+\tint bufsize = 4096;\n+\tchar * p;\n+\tint ret = UPNPCOMMAND_UNKNOWN_ERROR;\n+\n+\tif(!intPort || !intClient || !extPort || !proto)\n+\t\treturn UPNPCOMMAND_INVALID_ARGS;\n+\n+\tGetPortMappingArgs = calloc(4, sizeof(struct UPNParg));\n+\tGetPortMappingArgs[0].elt = \"NewRemoteHost\";\n+\tGetPortMappingArgs[1].elt = \"NewExternalPort\";\n+\tGetPortMappingArgs[1].val = extPort;\n+\tGetPortMappingArgs[2].elt = \"NewProtocol\";\n+\tGetPortMappingArgs[2].val = proto;\n+\tif(simpleUPnPcommand(-1, controlURL, servicetype,\n+\t                     \"GetSpecificPortMappingEntry\",\n+\t                     GetPortMappingArgs, buffer, &bufsize) < 0) {\n+\t\tfree(GetPortMappingArgs);\n+\t\treturn UPNPCOMMAND_HTTP_ERROR;\n+\t}\n+\t/*DisplayNameValueList(buffer, bufsize);*/\n+\tParseNameValue(buffer, bufsize, &pdata);\n+\n+\tp = GetValueFromNameValueList(&pdata, \"NewInternalClient\");\n+\tif(p) {\n+\t\tstrncpy(intClient, p, 16);\n+\t\tintClient[15] = '\\0';\n+\t\tret = UPNPCOMMAND_SUCCESS;\n+\t} else\n+\t\tintClient[0] = '\\0';\n+\n+\tp = GetValueFromNameValueList(&pdata, \"NewInternalPort\");\n+\tif(p) {\n+\t\tstrncpy(intPort, p, 6);\n+\t\tintPort[5] = '\\0';\n+\t} else\n+\t\tintPort[0] = '\\0';\n+\n+\tp = GetValueFromNameValueList(&pdata, \"errorCode\");\n+\tif(p) {\n+\t\tret = UPNPCOMMAND_UNKNOWN_ERROR;\n+\t\tsscanf(p, \"%d\", &ret);\n+\t}\n+\n+\tClearNameValueList(&pdata);\n+\tfree(GetPortMappingArgs);\n+\treturn ret;\n+}\n+\n+"
      },
      {
        "sha": "5561beaae289695127de5032727234560291a01f",
        "filename": "miniupnpc/upnpcommands.h",
        "status": "added",
        "additions": 194,
        "deletions": 0,
        "changes": 194,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/upnpcommands.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/upnpcommands.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/miniupnpc/upnpcommands.h?ref=b94b7b05a7b1d27e28ca9a8684877ca605d70256",
        "patch": "@@ -0,0 +1,194 @@\n+/* $Id: upnpcommands.h,v 1.18 2010/06/09 10:59:09 nanard Exp $ */\n+/* Miniupnp project : http://miniupnp.free.fr/\n+ * Author : Thomas Bernard\n+ * Copyright (c) 2005-2010 Thomas Bernard\n+ * This software is subject to the conditions detailed in the\n+ * LICENCE file provided within this distribution */\n+#ifndef __UPNPCOMMANDS_H__\n+#define __UPNPCOMMANDS_H__\n+\n+#include \"upnpreplyparse.h\"\n+#include \"declspec.h\"\n+\n+/* MiniUPnPc return codes : */\n+#define UPNPCOMMAND_SUCCESS (0)\n+#define UPNPCOMMAND_UNKNOWN_ERROR (-1)\n+#define UPNPCOMMAND_INVALID_ARGS (-2)\n+#define UPNPCOMMAND_HTTP_ERROR (-3)\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#if (defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L)\n+#define UNSIGNED_INTEGER unsigned long long\n+#define STRTOUI\tstrtoull\n+#else\n+#define UNSIGNED_INTEGER unsigned int\n+#define STRTOUI\tstrtoul\n+#endif\n+\n+LIBSPEC UNSIGNED_INTEGER\n+UPNP_GetTotalBytesSent(const char * controlURL,\n+\t\t\t\t\tconst char * servicetype);\n+\n+LIBSPEC UNSIGNED_INTEGER\n+UPNP_GetTotalBytesReceived(const char * controlURL,\n+\t\t\t\t\t\tconst char * servicetype);\n+\n+LIBSPEC UNSIGNED_INTEGER\n+UPNP_GetTotalPacketsSent(const char * controlURL,\n+\t\t\t\t\tconst char * servicetype);\n+\n+LIBSPEC UNSIGNED_INTEGER\n+UPNP_GetTotalPacketsReceived(const char * controlURL,\n+\t\t\t\t\tconst char * servicetype);\n+\n+/* UPNP_GetStatusInfo()\n+ * status and lastconnerror are 64 byte buffers\n+ * Return values :\n+ * UPNPCOMMAND_SUCCESS, UPNPCOMMAND_INVALID_ARGS, UPNPCOMMAND_UNKNOWN_ERROR\n+ * or a UPnP Error code */\n+LIBSPEC int\n+UPNP_GetStatusInfo(const char * controlURL,\n+\t\t\t       const char * servicetype,\n+\t\t\t\t   char * status,\n+\t\t\t\t   unsigned int * uptime,\n+                   char * lastconnerror);\n+\n+/* UPNP_GetConnectionTypeInfo()\n+ * argument connectionType is a 64 character buffer\n+ * Return Values :\n+ * UPNPCOMMAND_SUCCESS, UPNPCOMMAND_INVALID_ARGS, UPNPCOMMAND_UNKNOWN_ERROR\n+ * or a UPnP Error code */\n+LIBSPEC int\n+UPNP_GetConnectionTypeInfo(const char * controlURL,\n+                           const char * servicetype,\n+\t\t\t\t\t\t   char * connectionType);\n+\n+/* UPNP_GetExternalIPAddress() call the corresponding UPNP method.\n+ * if the third arg is not null the value is copied to it.\n+ * at least 16 bytes must be available \n+ *\n+ * Return values :\n+ * 0 : SUCCESS\n+ * NON ZERO : ERROR Either an UPnP error code or an unknown error.\n+ * \n+ * possible UPnP Errors :\n+ * 402 Invalid Args - See UPnP Device Architecture section on Control.\n+ * 501 Action Failed - See UPnP Device Architecture section on Control. */\n+LIBSPEC int\n+UPNP_GetExternalIPAddress(const char * controlURL,\n+                          const char * servicetype,\n+                          char * extIpAdd);\n+\n+/* UPNP_GetLinkLayerMaxBitRates()\n+ * call WANCommonInterfaceConfig:1#GetCommonLinkProperties\n+ *\n+ * return values :\n+ * UPNPCOMMAND_SUCCESS, UPNPCOMMAND_INVALID_ARGS, UPNPCOMMAND_UNKNOWN_ERROR\n+ * or a UPnP Error Code. */\n+LIBSPEC int\n+UPNP_GetLinkLayerMaxBitRates(const char* controlURL,\n+\t\t\t\t\t\t\tconst char* servicetype,\n+\t\t\t\t\t\t\tunsigned int * bitrateDown,\n+\t\t\t\t\t\t\tunsigned int * bitrateUp);\n+\n+/* UPNP_AddPortMapping()\n+ * if desc is NULL, it will be defaulted to \"libminiupnpc\"\n+ * remoteHost is usually NULL because IGD don't support it.\n+ *\n+ * Return values :\n+ * 0 : SUCCESS\n+ * NON ZERO : ERROR. Either an UPnP error code or an unknown error.\n+ * \n+ * List of possible UPnP errors for AddPortMapping :\n+ * errorCode errorDescription (short) - Description (long)\n+ * 402 Invalid Args - See UPnP Device Architecture section on Control.\n+ * 501 Action Failed - See UPnP Device Architecture section on Control.\n+ * 715 WildCardNotPermittedInSrcIP - The source IP address cannot be\n+ *                                   wild-carded\n+ * 716 WildCardNotPermittedInExtPort - The external port cannot be wild-carded\n+ * 718 ConflictInMappingEntry - The port mapping entry specified conflicts\n+ *                     with a mapping assigned previously to another client\n+ * 724 SamePortValuesRequired - Internal and External port values\n+ *                              must be the same \n+ * 725 OnlyPermanentLeasesSupported - The NAT implementation only supports\n+ *                  permanent lease times on port mappings\n+ * 726 RemoteHostOnlySupportsWildcard - RemoteHost must be a wildcard\n+ *                             and cannot be a specific IP address or DNS name\n+ * 727 ExternalPortOnlySupportsWildcard - ExternalPort must be a wildcard and\n+ *                                        cannot be a specific port value */\n+LIBSPEC int\n+UPNP_AddPortMapping(const char * controlURL, const char * servicetype,\n+                    const char * extPort,\n+\t\t\t\t    const char * inPort,\n+\t\t\t\t\tconst char * inClient,\n+\t\t\t\t\tconst char * desc,\n+                    const char * proto,\n+                    const char * remoteHost);\n+\n+/* UPNP_DeletePortMapping()\n+ * Use same argument values as what was used for AddPortMapping().\n+ * remoteHost is usually NULL because IGD don't support it.\n+ * Return Values :\n+ * 0 : SUCCESS\n+ * NON ZERO : error. Either an UPnP error code or an undefined error.\n+ *\n+ * List of possible UPnP errors for DeletePortMapping :\n+ * 402 Invalid Args - See UPnP Device Architecture section on Control.\n+ * 714 NoSuchEntryInArray - The specified value does not exist in the array */\n+LIBSPEC int\n+UPNP_DeletePortMapping(const char * controlURL, const char * servicetype,\n+                       const char * extPort, const char * proto,\n+                       const char * remoteHost);\n+\n+/* UPNP_GetPortMappingNumberOfEntries()\n+ * not supported by all routers */\n+LIBSPEC int\n+UPNP_GetPortMappingNumberOfEntries(const char* controlURL, const char* servicetype, unsigned int * num);\n+\n+/* UPNP_GetSpecificPortMappingEntry retrieves an existing port mapping\n+ * the result is returned in the intClient and intPort strings\n+ * please provide 16 and 6 bytes of data\n+ *\n+ * return value :\n+ * UPNPCOMMAND_SUCCESS, UPNPCOMMAND_INVALID_ARGS, UPNPCOMMAND_UNKNOWN_ERROR\n+ * or a UPnP Error Code. */\n+LIBSPEC int\n+UPNP_GetSpecificPortMappingEntry(const char * controlURL,\n+                                 const char * servicetype,\n+                                 const char * extPort,\n+                                 const char * proto,\n+                                 char * intClient,\n+                                 char * intPort);\n+\n+/* UPNP_GetGenericPortMappingEntry()\n+ *\n+ * return value :\n+ * UPNPCOMMAND_SUCCESS, UPNPCOMMAND_INVALID_ARGS, UPNPCOMMAND_UNKNOWN_ERROR\n+ * or a UPnP Error Code.\n+ *\n+ * Possible UPNP Error codes :\n+ * 402 Invalid Args - See UPnP Device Architecture section on Control.\n+ * 713 SpecifiedArrayIndexInvalid - The specified array index is out of bounds\n+ */\n+LIBSPEC int\n+UPNP_GetGenericPortMappingEntry(const char * controlURL,\n+                                const char * servicetype,\n+\t\t\t\t\t\t\t\tconst char * index,\n+\t\t\t\t\t\t\t\tchar * extPort,\n+\t\t\t\t\t\t\t\tchar * intClient,\n+\t\t\t\t\t\t\t\tchar * intPort,\n+\t\t\t\t\t\t\t\tchar * protocol,\n+\t\t\t\t\t\t\t\tchar * desc,\n+\t\t\t\t\t\t\t\tchar * enabled,\n+\t\t\t\t\t\t\t\tchar * rHost,\n+\t\t\t\t\t\t\t\tchar * duration);\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif\n+"
      },
      {
        "sha": "8a05349b155fea750e0f29f6b54c7e608e61d6e2",
        "filename": "miniupnpc/upnperrors.c",
        "status": "added",
        "additions": 66,
        "deletions": 0,
        "changes": 66,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/upnperrors.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/upnperrors.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/miniupnpc/upnperrors.c?ref=b94b7b05a7b1d27e28ca9a8684877ca605d70256",
        "patch": "@@ -0,0 +1,66 @@\n+/* $Id: upnperrors.c,v 1.3 2008/04/27 17:21:51 nanard Exp $ */\n+/* Project : miniupnp\n+ * Author : Thomas BERNARD\n+ * copyright (c) 2007 Thomas Bernard\n+ * All Right reserved.\n+ * http://miniupnp.free.fr/ or http://miniupnp.tuxfamily.org/\n+ * This software is subjet to the conditions detailed in the\n+ * provided LICENCE file. */\n+#include <string.h>\n+#include \"upnperrors.h\"\n+#include \"upnpcommands.h\"\n+\n+const char * strupnperror(int err)\n+{\n+\tconst char * s = NULL;\n+\tswitch(err) {\n+\tcase UPNPCOMMAND_SUCCESS:\n+\t\ts = \"Success\";\n+\t\tbreak;\n+\tcase UPNPCOMMAND_UNKNOWN_ERROR:\n+\t\ts = \"Miniupnpc Unknown Error\";\n+\t\tbreak;\n+\tcase UPNPCOMMAND_INVALID_ARGS:\n+\t\ts = \"Miniupnpc Invalid Arguments\";\n+\t\tbreak;\n+\tcase 401:\n+\t\ts = \"Invalid Action\";\n+\t\tbreak;\n+\tcase 402:\n+\t\ts = \"Invalid Args\";\n+\t\tbreak;\n+\tcase 501:\n+\t\ts = \"Action Failed\";\n+\t\tbreak;\n+\tcase 713:\n+\t\ts = \"SpecifiedArrayIndexInvalid\";\n+\t\tbreak;\n+\tcase 714:\n+\t\ts = \"NoSuchEntryInArray\";\n+\t\tbreak;\n+\tcase 715:\n+\t\ts = \"WildCardNotPermittedInSrcIP\";\n+\t\tbreak;\n+\tcase 716:\n+\t\ts = \"WildCardNotPermittedInExtPort\";\n+\t\tbreak;\n+\tcase 718:\n+\t\ts = \"ConflictInMappingEntry\";\n+\t\tbreak;\n+\tcase 724:\n+\t\ts = \"SamePortValuesRequired\";\n+\t\tbreak;\n+\tcase 725:\n+\t\ts = \"OnlyPermanentLeasesSupported\";\n+\t\tbreak;\n+\tcase 726:\n+\t\ts = \"RemoteHostOnlySupportsWildcard\";\n+\t\tbreak;\n+\tcase 727:\n+\t\ts = \"ExternalPortOnlySupportsWildcard\";\n+\t\tbreak;\n+\tdefault:\n+\t\ts = NULL;\n+\t}\n+\treturn s;\n+}"
      },
      {
        "sha": "2c544c97c3cea33b0e69010407848ecff00f4822",
        "filename": "miniupnpc/upnperrors.h",
        "status": "added",
        "additions": 26,
        "deletions": 0,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/upnperrors.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/upnperrors.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/miniupnpc/upnperrors.h?ref=b94b7b05a7b1d27e28ca9a8684877ca605d70256",
        "patch": "@@ -0,0 +1,26 @@\n+/* $Id: upnperrors.h,v 1.2 2008/07/02 23:31:15 nanard Exp $ */\n+/* (c) 2007 Thomas Bernard\n+ * All rights reserved.\n+ * MiniUPnP Project.\n+ * http://miniupnp.free.fr/ or http://miniupnp.tuxfamily.org/\n+ * This software is subjet to the conditions detailed in the\n+ * provided LICENCE file. */\n+#ifndef __UPNPERRORS_H__\n+#define __UPNPERRORS_H__\n+\n+#include \"declspec.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* strupnperror()\n+ * Return a string description of the UPnP error code \n+ * or NULL for undefinded errors */\n+LIBSPEC const char * strupnperror(int err);\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif"
      },
      {
        "sha": "c72b4c825f1170e520e3626cdb571890ae7fc488",
        "filename": "miniupnpc/upnpreplyparse.c",
        "status": "added",
        "additions": 127,
        "deletions": 0,
        "changes": 127,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/upnpreplyparse.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/upnpreplyparse.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/miniupnpc/upnpreplyparse.c?ref=b94b7b05a7b1d27e28ca9a8684877ca605d70256",
        "patch": "@@ -0,0 +1,127 @@\n+/* $Id: upnpreplyparse.c,v 1.10 2008/02/21 13:05:27 nanard Exp $ */\n+/* MiniUPnP project\n+ * http://miniupnp.free.fr/ or http://miniupnp.tuxfamily.org/\n+ * (c) 2006 Thomas Bernard \n+ * This software is subject to the conditions detailed\n+ * in the LICENCE file provided within the distribution */\n+\n+#include <stdlib.h>\n+#include <string.h>\n+#include <stdio.h>\n+\n+#include \"upnpreplyparse.h\"\n+#include \"minixml.h\"\n+\n+static void\n+NameValueParserStartElt(void * d, const char * name, int l)\n+{\n+    struct NameValueParserData * data = (struct NameValueParserData *)d;\n+    if(l>63)\n+        l = 63;\n+    memcpy(data->curelt, name, l);\n+    data->curelt[l] = '\\0';\n+}\n+\n+static void\n+NameValueParserGetData(void * d, const char * datas, int l)\n+{\n+    struct NameValueParserData * data = (struct NameValueParserData *)d;\n+    struct NameValue * nv;\n+    nv = malloc(sizeof(struct NameValue));\n+    if(l>63)\n+        l = 63;\n+    strncpy(nv->name, data->curelt, 64);\n+\tnv->name[63] = '\\0';\n+    memcpy(nv->value, datas, l);\n+    nv->value[l] = '\\0';\n+    LIST_INSERT_HEAD( &(data->head), nv, entries);\n+}\n+\n+void\n+ParseNameValue(const char * buffer, int bufsize,\n+                    struct NameValueParserData * data)\n+{\n+    struct xmlparser parser;\n+    LIST_INIT(&(data->head));\n+    /* init xmlparser object */\n+    parser.xmlstart = buffer;\n+    parser.xmlsize = bufsize;\n+    parser.data = data;\n+    parser.starteltfunc = NameValueParserStartElt;\n+    parser.endeltfunc = 0;\n+    parser.datafunc = NameValueParserGetData;\n+\tparser.attfunc = 0;\n+    parsexml(&parser);\n+}\n+\n+void\n+ClearNameValueList(struct NameValueParserData * pdata)\n+{\n+    struct NameValue * nv;\n+    while((nv = pdata->head.lh_first) != NULL)\n+    {\n+        LIST_REMOVE(nv, entries);\n+        free(nv);\n+    }\n+}\n+\n+char * \n+GetValueFromNameValueList(struct NameValueParserData * pdata,\n+                          const char * Name)\n+{\n+    struct NameValue * nv;\n+    char * p = NULL;\n+    for(nv = pdata->head.lh_first;\n+        (nv != NULL) && (p == NULL);\n+        nv = nv->entries.le_next)\n+    {\n+        if(strcmp(nv->name, Name) == 0)\n+            p = nv->value;\n+    }\n+    return p;\n+}\n+\n+#if 0\n+/* useless now that minixml ignores namespaces by itself */\n+char *\n+GetValueFromNameValueListIgnoreNS(struct NameValueParserData * pdata,\n+                                  const char * Name)\n+{\n+\tstruct NameValue * nv;\n+\tchar * p = NULL;\n+\tchar * pname;\n+\tfor(nv = pdata->head.lh_first;\n+\t    (nv != NULL) && (p == NULL);\n+\t\tnv = nv->entries.le_next)\n+\t{\n+\t\tpname = strrchr(nv->name, ':');\n+\t\tif(pname)\n+\t\t\tpname++;\n+\t\telse\n+\t\t\tpname = nv->name;\n+\t\tif(strcmp(pname, Name)==0)\n+\t\t\tp = nv->value;\n+\t}\n+\treturn p;\n+}\n+#endif\n+\n+/* debug all-in-one function \n+ * do parsing then display to stdout */\n+#ifdef DEBUG\n+void\n+DisplayNameValueList(char * buffer, int bufsize)\n+{\n+    struct NameValueParserData pdata;\n+    struct NameValue * nv;\n+    ParseNameValue(buffer, bufsize, &pdata);\n+    for(nv = pdata.head.lh_first;\n+        nv != NULL;\n+        nv = nv->entries.le_next)\n+    {\n+        printf(\"%s = %s\\n\", nv->name, nv->value);\n+    }\n+    ClearNameValueList(&pdata);\n+}\n+#endif\n+"
      },
      {
        "sha": "fb7d4535cd509a1d7d17f35ced4e3ca22c30911d",
        "filename": "miniupnpc/upnpreplyparse.h",
        "status": "added",
        "additions": 62,
        "deletions": 0,
        "changes": 62,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/upnpreplyparse.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/upnpreplyparse.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/miniupnpc/upnpreplyparse.h?ref=b94b7b05a7b1d27e28ca9a8684877ca605d70256",
        "patch": "@@ -0,0 +1,62 @@\n+/* $Id: upnpreplyparse.h,v 1.10 2009/07/09 16:01:50 nanard Exp $ */\n+/* MiniUPnP project\n+ * http://miniupnp.free.fr/ or http://miniupnp.tuxfamily.org/\n+ * (c) 2006-2009 Thomas Bernard \n+ * This software is subject to the conditions detailed\n+ * in the LICENCE file provided within the distribution */\n+\n+#ifndef __UPNPREPLYPARSE_H__\n+#define __UPNPREPLYPARSE_H__\n+\n+#if defined(NO_SYS_QUEUE_H) || defined(WIN32) || defined(__HAIKU__) \n+#include \"bsdqueue.h\"\n+#else\n+#include <sys/queue.h>\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+struct NameValue {\n+    LIST_ENTRY(NameValue) entries;\n+    char name[64];\n+    char value[64];\n+};\n+\n+struct NameValueParserData {\n+    LIST_HEAD(listhead, NameValue) head;\n+    char curelt[64];\n+};\n+\n+/* ParseNameValue() */\n+void\n+ParseNameValue(const char * buffer, int bufsize,\n+               struct NameValueParserData * data);\n+\n+/* ClearNameValueList() */\n+void\n+ClearNameValueList(struct NameValueParserData * pdata);\n+\n+/* GetValueFromNameValueList() */\n+char *\n+GetValueFromNameValueList(struct NameValueParserData * pdata,\n+                          const char * Name);\n+\n+/* GetValueFromNameValueListIgnoreNS() */\n+char *\n+GetValueFromNameValueListIgnoreNS(struct NameValueParserData * pdata,\n+                                  const char * Name);\n+\n+/* DisplayNameValueList() */\n+#ifdef DEBUG\n+void\n+DisplayNameValueList(char * buffer, int bufsize);\n+#endif\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif\n+"
      },
      {
        "sha": "0da8bedfc6c4e579ecd9d213f8a779ce15752a09",
        "filename": "miniupnpc/wingenminiupnpcstrings.c",
        "status": "added",
        "additions": 69,
        "deletions": 0,
        "changes": 69,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/wingenminiupnpcstrings.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b94b7b05a7b1d27e28ca9a8684877ca605d70256/miniupnpc/wingenminiupnpcstrings.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/miniupnpc/wingenminiupnpcstrings.c?ref=b94b7b05a7b1d27e28ca9a8684877ca605d70256",
        "patch": "@@ -0,0 +1,69 @@\n+/* $Id: wingenminiupnpcstrings.c,v 1.1 2009/12/10 18:46:15 nanard Exp $ */\n+/* Project: miniupnp\n+ * http://miniupnp.free.fr/ or http://miniupnp.tuxfamily.org/\n+ * Author: Thomas Bernard\n+ * Copyright (c) 2005-2009 Thomas Bernard\n+ * This software is subjects to the conditions detailed\n+ * in the LICENSE file provided within this distribution */\n+#include <stdio.h>\n+#include <windows.h>\n+\n+/* This program display the Windows version and is used to\n+ * generate the miniupnpcstrings.h\n+ * wingenminiupnpcstrings miniupnpcstrings.h.in miniupnpcstrings.h\n+ */\n+int main(int argc, char * * argv) {\n+\tchar buffer[256];\n+\tOSVERSIONINFO osvi;\n+\tFILE * fin;\n+\tFILE * fout;\n+\tint n;\n+\t/* dwMajorVersion :\n+       The major version number of the operating system. For more information, see Remarks.\n+     dwMinorVersion :\n+       The minor version number of the operating system. For more information, see Remarks.\n+     dwBuildNumber :\n+       The build number of the operating system.\n+     dwPlatformId\n+       The operating system platform. This member can be the following value. \n+     szCSDVersion\n+       A null-terminated string, such as \"Service Pack 3\", that indicates the\n+       latest Service Pack installed on the system. If no Service Pack has\n+       been installed, the string is empty.\n+   */\n+  ZeroMemory(&osvi, sizeof(OSVERSIONINFO));\n+  osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);\n+\n+  GetVersionEx(&osvi);\n+\n+\tprintf(\"Windows %lu.%lu Build %lu %s\\n\",\n+\t       osvi.dwMajorVersion, osvi.dwMinorVersion,\n+\t       osvi.dwBuildNumber, (const char *)&(osvi.szCSDVersion));\n+\n+\tif(argc >= 3) {\n+\t\tfin = fopen(argv[1], \"r\");\n+\t\tif(!fin) {\n+\t\t\tfprintf(stderr, \"Cannot open %s for reading.\\n\", argv[1]);\n+\t\t\treturn 1;\n+\t\t}\n+\t\tfout = fopen(argv[2], \"w\");\n+\t\tif(!fout) {\n+\t\t\tfprintf(stderr, \"Cannot open %s for writing.\\n\", argv[2]);\n+\t\t\treturn 1;\n+\t\t}\n+\t\tn = 0;\n+\t\twhile(fgets(buffer, sizeof(buffer), fin)) {\n+\t\t\tif(0 == memcmp(buffer, \"#define OS_STRING \\\"OS/version\\\"\", 30)) {\n+\t\t\t\tsprintf(buffer, \"#define OS_STRING \\\"MSWindows/%ld.%ld.%ld\\\"\\n\",\n+\t\t\t\t        osvi.dwMajorVersion, osvi.dwMinorVersion, osvi.dwBuildNumber);\n+\t\t\t}\n+\t\t\t/*fputs(buffer, stdout);*/\n+\t\t\tfputs(buffer, fout);\n+\t\t\tn++;\n+\t\t}\n+\t\tfclose(fin);\n+\t\tfclose(fout);\n+\t\tprintf(\"%d lines written to %s.\\n\", n, argv[2]);\n+\t}\n+  return 0;\n+}"
      },
      {
        "sha": "82d4ef46005fbbadf910778ce87963a2e4af1665",
        "filename": "net.cpp",
        "status": "modified",
        "additions": 88,
        "deletions": 1,
        "changes": 89,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b94b7b05a7b1d27e28ca9a8684877ca605d70256/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b94b7b05a7b1d27e28ca9a8684877ca605d70256/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/net.cpp?ref=b94b7b05a7b1d27e28ca9a8684877ca605d70256",
        "patch": "@@ -3,12 +3,17 @@\n // file license.txt or http://www.opensource.org/licenses/mit-license.php.\n \n #include \"headers.h\"\n+#include \"miniupnpc/miniwget.h\"\n+#include \"miniupnpc/miniupnpc.h\"\n+#include \"miniupnpc/upnpcommands.h\"\n+#include \"miniupnpc/upnperrors.h\"\n \n static const int MAX_OUTBOUND_CONNECTIONS = 8;\n \n void ThreadMessageHandler2(void* parg);\n void ThreadSocketHandler2(void* parg);\n void ThreadOpenConnections2(void* parg);\n+void ThreadMapPort2(void* parg);\n bool OpenNetworkConnection(const CAddress& addrConnect);\n \n \n@@ -857,6 +862,83 @@ void ThreadSocketHandler2(void* parg)\n \n \n \n+void ThreadMapPort(void* parg)\n+{\n+    IMPLEMENT_RANDOMIZE_STACK(ThreadMapPort(parg));\n+    try\n+    {\n+        vnThreadsRunning[5]++;\n+        ThreadMapPort2(parg);\n+        vnThreadsRunning[5]--;\n+    }\n+    catch (std::exception& e) {\n+        vnThreadsRunning[5]--;\n+        PrintException(&e, \"ThreadMapPort()\");\n+    } catch (...) {\n+        vnThreadsRunning[5]--;\n+        PrintException(NULL, \"ThreadMapPort()\");\n+    }\n+    printf(\"ThreadMapPort exiting\\n\");\n+}\n+\n+void ThreadMapPort2(void* parg)\n+{\n+    printf(\"ThreadMapPort started\\n\");\n+\n+    const char * rootdescurl = 0;\n+    const char * multicastif = 0;\n+    const char * minissdpdpath = 0;\n+    struct UPNPDev * devlist = 0;\n+    char lanaddr[64];\n+\n+    devlist = upnpDiscover(2000, multicastif, minissdpdpath, 0);\n+\n+    struct UPNPUrls urls;\n+    struct IGDdatas data;\n+int r;\n+\n+    if (UPNP_GetValidIGD(devlist, &urls, &data, lanaddr, sizeof(lanaddr)) == 1)\n+    {\n+        char intClient[16];\n+        char intPort[6];\n+\n+        r = UPNP_AddPortMapping(urls.controlURL, data.first.servicetype,\n+\t                        \"8333\", \"8333\", lanaddr, 0, \"TCP\", 0);\n+        if(r!=UPNPCOMMAND_SUCCESS)\n+            printf(\"AddPortMapping(%s, %s, %s) failed with code %d (%s)\\n\",\n+                \"8333\", \"8333\", lanaddr, r, strupnperror(r));\n+        else\n+            printf(\"UPnP Port Mapping successful.\\n\");\n+        loop {\n+            if (fShutdown)\n+            {\n+                r = UPNP_DeletePortMapping(urls.controlURL, data.first.servicetype, \"8333\", \"TCP\", 0);\n+                printf(\"UPNP_DeletePortMapping() returned : %d\\n\", r);\n+                freeUPNPDevlist(devlist); devlist = 0;\n+                FreeUPNPUrls(&urls);\n+                return;\n+            }\n+            Sleep(20);\n+        }\n+    } else {\n+        printf(\"No valid UPnP IGDs found\\n\");\n+        freeUPNPDevlist(devlist); devlist = 0;\n+        FreeUPNPUrls(&urls);\n+        loop {\n+            if (fShutdown)\n+                return;\n+            Sleep(20);\n+        }\n+    }\n+}\n+\n+\n+\n+\n+\n+\n+\n+\n \n \n \n@@ -1382,6 +1464,10 @@ void StartNode(void* parg)\n     // Start threads\n     //\n \n+    // Map ports with UPnP\n+    if (!CreateThread(ThreadMapPort, NULL))\n+        printf(\"Error: ThreadMapPort(ThreadMapPort) failed\\n\");\n+\n     // Get addresses from IRC and advertise ours\n     if (!CreateThread(ThreadIRCSeed, NULL))\n         printf(\"Error: CreateThread(ThreadIRCSeed) failed\\n\");\n@@ -1407,7 +1493,7 @@ bool StopNode()\n     fShutdown = true;\n     nTransactionsUpdated++;\n     int64 nStart = GetTime();\n-    while (vnThreadsRunning[0] > 0 || vnThreadsRunning[2] > 0 || vnThreadsRunning[3] > 0 || vnThreadsRunning[4] > 0)\n+    while (vnThreadsRunning[0] > 0 || vnThreadsRunning[2] > 0 || vnThreadsRunning[3] > 0 || vnThreadsRunning[4] > 0 || vnThreadsRunning[5] > 0)\n     {\n         if (GetTime() - nStart > 20)\n             break;\n@@ -1418,6 +1504,7 @@ bool StopNode()\n     if (vnThreadsRunning[2] > 0) printf(\"ThreadMessageHandler still running\\n\");\n     if (vnThreadsRunning[3] > 0) printf(\"ThreadBitcoinMiner still running\\n\");\n     if (vnThreadsRunning[4] > 0) printf(\"ThreadRPCServer still running\\n\");\n+    if (vnThreadsRunning[5] > 0) printf(\"ThreadMapPort still running\\n\");\n     while (vnThreadsRunning[2] > 0 || vnThreadsRunning[4] > 0)\n         Sleep(20);\n     Sleep(50);"
      }
    ]
  },
  {
    "sha": "e972d3215d1717d2cceda0cb9209f1188490621f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplOTcyZDMyMTVkMTcxN2QyY2NlZGEwY2I5MjA5ZjExODg0OTA2MjFm",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "matt@bluematt.me",
        "date": "2011-03-11T18:19:42Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "matt@bluematt.me",
        "date": "2011-03-11T18:19:42Z"
      },
      "message": "Add -noupnp option and a couple small improvements.",
      "tree": {
        "sha": "3310bf7aac0b21f9743b6f7aaf454c648b470a8b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3310bf7aac0b21f9743b6f7aaf454c648b470a8b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e972d3215d1717d2cceda0cb9209f1188490621f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e972d3215d1717d2cceda0cb9209f1188490621f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e972d3215d1717d2cceda0cb9209f1188490621f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e972d3215d1717d2cceda0cb9209f1188490621f/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "b94b7b05a7b1d27e28ca9a8684877ca605d70256",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b94b7b05a7b1d27e28ca9a8684877ca605d70256",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b94b7b05a7b1d27e28ca9a8684877ca605d70256"
      }
    ],
    "stats": {
      "total": 23,
      "additions": 15,
      "deletions": 8
    },
    "files": [
      {
        "sha": "bcccda800a3c0d94c2afc972596e3ea1ab126d80",
        "filename": "init.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e972d3215d1717d2cceda0cb9209f1188490621f/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e972d3215d1717d2cceda0cb9209f1188490621f/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/init.cpp?ref=e972d3215d1717d2cceda0cb9209f1188490621f",
        "patch": "@@ -176,6 +176,7 @@ bool AppInit2(int argc, char* argv[])\n             \"  -addnode=<ip>    \\t  \"   + _(\"Add a node to connect to\\n\") +\n             \"  -connect=<ip>    \\t\\t  \" + _(\"Connect only to the specified node\\n\") +\n             \"  -nolisten        \\t  \"   + _(\"Don't accept connections from outside\\n\") +\n+            \"  -noupnp          \\t  \"   + _(\"Don't attempt to use UPnP to map the listening port\\n\") +\n             \"  -paytxfee=<amt>  \\t  \"   + _(\"Fee per KB to add to transactions you send\\n\") +\n             \"  -server          \\t\\t  \" + _(\"Accept command line and JSON-RPC commands\\n\") +\n             \"  -daemon          \\t\\t  \" + _(\"Run in the background as a daemon and accept commands\\n\") +"
      },
      {
        "sha": "e6256334bba8582879d2eb99bc4d43e77125d085",
        "filename": "net.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 8,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e972d3215d1717d2cceda0cb9209f1188490621f/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e972d3215d1717d2cceda0cb9209f1188490621f/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/net.cpp?ref=e972d3215d1717d2cceda0cb9209f1188490621f",
        "patch": "@@ -885,6 +885,9 @@ void ThreadMapPort2(void* parg)\n {\n     printf(\"ThreadMapPort started\\n\");\n \n+    char port[6];\n+    sprintf(port, \"%d\", GetDefaultPort());\n+\n     const char * rootdescurl = 0;\n     const char * multicastif = 0;\n     const char * minissdpdpath = 0;\n@@ -895,30 +898,30 @@ void ThreadMapPort2(void* parg)\n \n     struct UPNPUrls urls;\n     struct IGDdatas data;\n-int r;\n+    int r;\n \n     if (UPNP_GetValidIGD(devlist, &urls, &data, lanaddr, sizeof(lanaddr)) == 1)\n     {\n         char intClient[16];\n         char intPort[6];\n \n         r = UPNP_AddPortMapping(urls.controlURL, data.first.servicetype,\n-\t                        \"8333\", \"8333\", lanaddr, 0, \"TCP\", 0);\n+\t                        port, port, lanaddr, 0, \"TCP\", 0);\n         if(r!=UPNPCOMMAND_SUCCESS)\n             printf(\"AddPortMapping(%s, %s, %s) failed with code %d (%s)\\n\",\n-                \"8333\", \"8333\", lanaddr, r, strupnperror(r));\n+                port, port, lanaddr, r, strupnperror(r));\n         else\n             printf(\"UPnP Port Mapping successful.\\n\");\n         loop {\n             if (fShutdown)\n             {\n-                r = UPNP_DeletePortMapping(urls.controlURL, data.first.servicetype, \"8333\", \"TCP\", 0);\n+                r = UPNP_DeletePortMapping(urls.controlURL, data.first.servicetype, port, \"TCP\", 0);\n                 printf(\"UPNP_DeletePortMapping() returned : %d\\n\", r);\n                 freeUPNPDevlist(devlist); devlist = 0;\n                 FreeUPNPUrls(&urls);\n                 return;\n             }\n-            Sleep(20);\n+            Sleep(2000);\n         }\n     } else {\n         printf(\"No valid UPnP IGDs found\\n\");\n@@ -927,7 +930,7 @@ int r;\n         loop {\n             if (fShutdown)\n                 return;\n-            Sleep(20);\n+            Sleep(2000);\n         }\n     }\n }\n@@ -1465,8 +1468,11 @@ void StartNode(void* parg)\n     //\n \n     // Map ports with UPnP\n-    if (!CreateThread(ThreadMapPort, NULL))\n-        printf(\"Error: ThreadMapPort(ThreadMapPort) failed\\n\");\n+    if (!GetBoolArg(\"-noupnp\"))\n+    {\n+        if (!CreateThread(ThreadMapPort, NULL))\n+            printf(\"Error: ThreadMapPort(ThreadMapPort) failed\\n\");\n+    }\n \n     // Get addresses from IRC and advertise ours\n     if (!CreateThread(ThreadIRCSeed, NULL))"
      }
    ]
  }
]