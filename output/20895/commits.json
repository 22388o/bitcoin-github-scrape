[
  {
    "sha": "d5581bb809abad4507e995d8af9a18645196060e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkNTU4MWJiODA5YWJhZDQ1MDdlOTk1ZDhhZjlhMTg2NDUxOTYwNjBl",
    "commit": {
      "author": {
        "name": "gzhao408",
        "email": "gzhao408@berkeley.edu",
        "date": "2020-10-19T20:18:05Z"
      },
      "committer": {
        "name": "gzhao408",
        "email": "gzhao408@berkeley.edu",
        "date": "2021-01-08T18:12:47Z"
      },
      "message": "[refactor] add MempoolAcceptResult struct\n\nThis is much cleaner and we can have ATMP\nreturn a const. Nobody else should be editing\nvalidation results.",
      "tree": {
        "sha": "a0eefaab8f840138faf4921f47dbd8694ded2ff9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a0eefaab8f840138faf4921f47dbd8694ded2ff9"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d5581bb809abad4507e995d8af9a18645196060e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d5581bb809abad4507e995d8af9a18645196060e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d5581bb809abad4507e995d8af9a18645196060e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d5581bb809abad4507e995d8af9a18645196060e/comments",
    "author": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "86a8b35f321d55bb2381ea56bcc1cdd17c7896e6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/86a8b35f321d55bb2381ea56bcc1cdd17c7896e6",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/86a8b35f321d55bb2381ea56bcc1cdd17c7896e6"
      }
    ],
    "stats": {
      "total": 212,
      "additions": 109,
      "deletions": 103
    },
    "files": [
      {
        "sha": "af539075dba88ccb1bbddbc3738a48814f99f53f",
        "filename": "src/bench/block_assemble.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d5581bb809abad4507e995d8af9a18645196060e/src/bench/block_assemble.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d5581bb809abad4507e995d8af9a18645196060e/src/bench/block_assemble.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/block_assemble.cpp?ref=d5581bb809abad4507e995d8af9a18645196060e",
        "patch": "@@ -48,9 +48,8 @@ static void AssembleBlock(benchmark::Bench& bench)\n         LOCK(::cs_main); // Required for ::AcceptToMemoryPool.\n \n         for (const auto& txr : txs) {\n-            TxValidationState state;\n-            bool ret{::AcceptToMemoryPool(*test_setup.m_node.mempool, state, txr, nullptr /* plTxnReplaced */, false /* bypass_limits */)};\n-            assert(ret);\n+            const MempoolAcceptResult res = ::AcceptToMemoryPool(*test_setup.m_node.mempool, txr, false /* bypass_limits */);\n+            assert(res.m_accepted);\n         }\n     }\n "
      },
      {
        "sha": "6a0a39845d03d824ea4ad663166156077252c360",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d5581bb809abad4507e995d8af9a18645196060e/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d5581bb809abad4507e995d8af9a18645196060e/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=d5581bb809abad4507e995d8af9a18645196060e",
        "patch": "@@ -1983,10 +1983,10 @@ void PeerManager::ProcessOrphanTx(std::set<uint256>& orphan_work_set)\n         if (orphan_it == mapOrphanTransactions.end()) continue;\n \n         const CTransactionRef porphanTx = orphan_it->second.tx;\n-        TxValidationState state;\n-        std::list<CTransactionRef> removed_txn;\n+        const MempoolAcceptResult result = AcceptToMemoryPool(m_mempool, porphanTx, false /* bypass_limits */);\n+        TxValidationState state = result.m_state;\n \n-        if (AcceptToMemoryPool(m_mempool, state, porphanTx, &removed_txn, false /* bypass_limits */)) {\n+        if (result.m_accepted) {\n             LogPrint(BCLog::MEMPOOL, \"   accepted orphan tx %s\\n\", orphanHash.ToString());\n             RelayTransaction(orphanHash, porphanTx->GetWitnessHash(), m_connman);\n             for (unsigned int i = 0; i < porphanTx->vout.size(); i++) {\n@@ -1998,7 +1998,7 @@ void PeerManager::ProcessOrphanTx(std::set<uint256>& orphan_work_set)\n                 }\n             }\n             EraseOrphanTx(orphanHash);\n-            for (const CTransactionRef& removedTx : removed_txn) {\n+            for (const CTransactionRef& removedTx : result.m_replaced_transactions) {\n                 AddToCompactExtraTransactions(removedTx);\n             }\n             break;\n@@ -2989,10 +2989,10 @@ void PeerManager::ProcessMessage(CNode& pfrom, const std::string& msg_type, CDat\n             return;\n         }\n \n-        TxValidationState state;\n-        std::list<CTransactionRef> lRemovedTxn;\n+        const MempoolAcceptResult result = AcceptToMemoryPool(m_mempool, ptx, false /* bypass_limits */);\n+        TxValidationState state = result.m_state;\n \n-        if (AcceptToMemoryPool(m_mempool, state, ptx, &lRemovedTxn, false /* bypass_limits */)) {\n+        if (result.m_accepted) {\n             m_mempool.check(&::ChainstateActive().CoinsTip());\n             // As this version of the transaction was acceptable, we can forget about any\n             // requests for it.\n@@ -3015,7 +3015,7 @@ void PeerManager::ProcessMessage(CNode& pfrom, const std::string& msg_type, CDat\n                 tx.GetHash().ToString(),\n                 m_mempool.size(), m_mempool.DynamicMemoryUsage() / 1000);\n \n-            for (const CTransactionRef& removedTx : lRemovedTxn) {\n+            for (const CTransactionRef& removedTx : result.m_replaced_transactions) {\n                 AddToCompactExtraTransactions(removedTx);\n             }\n "
      },
      {
        "sha": "3b11fb366f38c40a66ce708ad13bb6ec30c87a26",
        "filename": "src/node/transaction.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 10,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d5581bb809abad4507e995d8af9a18645196060e/src/node/transaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d5581bb809abad4507e995d8af9a18645196060e/src/node/transaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/transaction.cpp?ref=d5581bb809abad4507e995d8af9a18645196060e",
        "patch": "@@ -50,23 +50,21 @@ TransactionError BroadcastTransaction(NodeContext& node, const CTransactionRef t\n     }\n     if (!node.mempool->exists(hashTx)) {\n         // Transaction is not already in the mempool.\n-        TxValidationState state;\n         if (max_tx_fee > 0) {\n             // First, call ATMP with test_accept and check the fee. If ATMP\n             // fails here, return error immediately.\n-            CAmount fee{0};\n-            if (!AcceptToMemoryPool(*node.mempool, state, tx,\n-                nullptr /* plTxnReplaced */, false /* bypass_limits */, /* test_accept */ true, &fee)) {\n-                return HandleATMPError(state, err_string);\n-            } else if (fee > max_tx_fee) {\n+            const MempoolAcceptResult result =\n+                AcceptToMemoryPool(*node.mempool, tx, false /* bypass_limits */, true /* test_accept */);\n+            if (!result.m_accepted) {\n+                return HandleATMPError(result.m_state, err_string);\n+            } else if (result.m_fee > max_tx_fee) {\n                 return TransactionError::MAX_FEE_EXCEEDED;\n             }\n         }\n         // Try to submit the transaction to the mempool.\n-        if (!AcceptToMemoryPool(*node.mempool, state, tx,\n-                nullptr /* plTxnReplaced */, false /* bypass_limits */)) {\n-            return HandleATMPError(state, err_string);\n-        }\n+        const MempoolAcceptResult result =\n+            AcceptToMemoryPool(*node.mempool, tx, false /* bypass_limits */, false /* test_accept */);\n+        if (!result.m_accepted) return HandleATMPError(result.m_state, err_string);\n \n         // Transaction was accepted to the mempool.\n "
      },
      {
        "sha": "325cc4d1fee6e476e97f83a674c8bf4329edaf33",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 5,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d5581bb809abad4507e995d8af9a18645196060e/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d5581bb809abad4507e995d8af9a18645196060e/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=d5581bb809abad4507e995d8af9a18645196060e",
        "patch": "@@ -944,14 +944,15 @@ static RPCHelpMan testmempoolaccept()\n     UniValue result_0(UniValue::VOBJ);\n     result_0.pushKV(\"txid\", tx_hash.GetHex());\n \n-    TxValidationState state;\n-    bool test_accept_res;\n-    CAmount fee{0};\n+    MempoolAcceptResult accept_result(std::move(tx));\n     {\n         LOCK(cs_main);\n-        test_accept_res = AcceptToMemoryPool(mempool, state, std::move(tx),\n-            nullptr /* plTxnReplaced */, false /* bypass_limits */, /* test_accept */ true, &fee);\n+        accept_result = AcceptToMemoryPool(mempool, std::move(tx),\n+            false /* bypass_limits */, true /* test_accept */);\n     }\n+    const bool test_accept_res = accept_result.m_accepted;\n+    const TxValidationState state = accept_result.m_state;\n+    const CAmount fee = accept_result.m_fee;\n \n     // Check that fee does not exceed maximum fee\n     if (test_accept_res && max_raw_tx_fee && fee > max_raw_tx_fee) {"
      },
      {
        "sha": "fd413f1e693ee06be57df6d9806019d9b50d9063",
        "filename": "src/test/txvalidation_tests.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 10,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d5581bb809abad4507e995d8af9a18645196060e/src/test/txvalidation_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d5581bb809abad4507e995d8af9a18645196060e/src/test/txvalidation_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/txvalidation_tests.cpp?ref=d5581bb809abad4507e995d8af9a18645196060e",
        "patch": "@@ -30,25 +30,21 @@ BOOST_FIXTURE_TEST_CASE(tx_mempool_reject_coinbase, TestChain100Setup)\n \n     BOOST_CHECK(CTransaction(coinbaseTx).IsCoinBase());\n \n-    TxValidationState state;\n-\n     LOCK(cs_main);\n \n     unsigned int initialPoolSize = m_node.mempool->size();\n+    const MempoolAcceptResult result = AcceptToMemoryPool(*m_node.mempool, MakeTransactionRef(coinbaseTx),\n+                true /* bypass_limits */);\n \n-    BOOST_CHECK_EQUAL(\n-            false,\n-            AcceptToMemoryPool(*m_node.mempool, state, MakeTransactionRef(coinbaseTx),\n-                nullptr /* plTxnReplaced */,\n-                true /* bypass_limits */));\n+    BOOST_CHECK_EQUAL(false, result.m_accepted);\n \n     // Check that the transaction hasn't been added to mempool.\n     BOOST_CHECK_EQUAL(m_node.mempool->size(), initialPoolSize);\n \n     // Check that the validation state reflects the unsuccessful attempt.\n-    BOOST_CHECK(state.IsInvalid());\n-    BOOST_CHECK_EQUAL(state.GetRejectReason(), \"coinbase\");\n-    BOOST_CHECK(state.GetResult() == TxValidationResult::TX_CONSENSUS);\n+    BOOST_CHECK(result.m_state.IsInvalid());\n+    BOOST_CHECK_EQUAL(result.m_state.GetRejectReason(), \"coinbase\");\n+    BOOST_CHECK(result.m_state.GetResult() == TxValidationResult::TX_CONSENSUS);\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "8df78a798e814f8e31966daecb287873d267eadc",
        "filename": "src/test/txvalidationcache_tests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d5581bb809abad4507e995d8af9a18645196060e/src/test/txvalidationcache_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d5581bb809abad4507e995d8af9a18645196060e/src/test/txvalidationcache_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/txvalidationcache_tests.cpp?ref=d5581bb809abad4507e995d8af9a18645196060e",
        "patch": "@@ -28,9 +28,9 @@ BOOST_FIXTURE_TEST_CASE(tx_mempool_block_doublespend, TestChain100Setup)\n     const auto ToMemPool = [this](const CMutableTransaction& tx) {\n         LOCK(cs_main);\n \n-        TxValidationState state;\n-        return AcceptToMemoryPool(*m_node.mempool, state, MakeTransactionRef(tx),\n-            nullptr /* plTxnReplaced */, true /* bypass_limits */);\n+        const MempoolAcceptResult result = AcceptToMemoryPool(*m_node.mempool, MakeTransactionRef(tx),\n+            true /* bypass_limits */);\n+        return result.m_accepted;\n     };\n \n     // Create a double-spend of mature coinbase txn:"
      },
      {
        "sha": "f784acb3cb8d5b71731681e11076539646b65154",
        "filename": "src/test/validation_block_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 6,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d5581bb809abad4507e995d8af9a18645196060e/src/test/validation_block_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d5581bb809abad4507e995d8af9a18645196060e/src/test/validation_block_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/validation_block_tests.cpp?ref=d5581bb809abad4507e995d8af9a18645196060e",
        "patch": "@@ -286,12 +286,8 @@ BOOST_AUTO_TEST_CASE(mempool_locks_reorg)\n             TxValidationState state;\n             std::list<CTransactionRef> plTxnReplaced;\n             for (const auto& tx : txs) {\n-                BOOST_REQUIRE(AcceptToMemoryPool(\n-                    *m_node.mempool,\n-                    state,\n-                    tx,\n-                    &plTxnReplaced,\n-                    /* bypass_limits */ false));\n+                const MempoolAcceptResult result = AcceptToMemoryPool(*m_node.mempool, tx, false /* bypass_limits */);\n+                BOOST_REQUIRE(result.m_accepted);\n             }\n         }\n "
      },
      {
        "sha": "2993363c33d8f935c4594a69410d2354144e9817",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 57,
        "deletions": 51,
        "changes": 108,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d5581bb809abad4507e995d8af9a18645196060e/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d5581bb809abad4507e995d8af9a18645196060e/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=d5581bb809abad4507e995d8af9a18645196060e",
        "patch": "@@ -378,10 +378,9 @@ static void UpdateMempoolForReorg(CTxMemPool& mempool, DisconnectedBlockTransact\n     auto it = disconnectpool.queuedTx.get<insertion_order>().rbegin();\n     while (it != disconnectpool.queuedTx.get<insertion_order>().rend()) {\n         // ignore validation errors in resurrected transactions\n-        TxValidationState stateDummy;\n-        if (!fAddToMempool || (*it)->IsCoinBase() ||\n-            !AcceptToMemoryPool(mempool, stateDummy, *it,\n-                                nullptr /* plTxnReplaced */, true /* bypass_limits */)) {\n+        const MempoolAcceptResult result = AcceptToMemoryPool(mempool, *it, false /* bypass_limits */);\n+\n+        if (!fAddToMempool || (*it)->IsCoinBase() || !result.m_accepted) {\n             // If the transaction doesn't make it in to the mempool, remove any\n             // transactions that depend on it (which would now be orphans).\n             mempool.removeRecursive(**it, MemPoolRemovalReason::REORG);\n@@ -456,9 +455,7 @@ class MemPoolAccept\n     // around easier.\n     struct ATMPArgs {\n         const CChainParams& m_chainparams;\n-        TxValidationState &m_state;\n         const int64_t m_accept_time;\n-        std::list<CTransactionRef>* m_replaced_transactions;\n         const bool m_bypass_limits;\n         /*\n          * Return any outpoints which were not previously present in the coins\n@@ -469,11 +466,10 @@ class MemPoolAccept\n          */\n         std::vector<COutPoint>& m_coins_to_uncache;\n         const bool m_test_accept;\n-        CAmount* m_fee_out;\n     };\n \n     // Single transaction acceptance\n-    bool AcceptSingleTransaction(const CTransactionRef& ptx, ATMPArgs& args) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    MempoolAcceptResult AcceptSingleTransaction(const CTransactionRef& ptx, ATMPArgs& args) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n private:\n     // All the intermediate state that gets passed between the various levels\n@@ -498,22 +494,22 @@ class MemPoolAccept\n     // Looks up inputs, calculates feerate, considers replacement, evaluates\n     // package limits, etc. As this function can be invoked for \"free\" by a peer,\n     // only tests that are fast should be done here (to avoid CPU DoS).\n-    bool PreChecks(ATMPArgs& args, Workspace& ws) EXCLUSIVE_LOCKS_REQUIRED(cs_main, m_pool.cs);\n+    bool PreChecks(ATMPArgs& args, MempoolAcceptResult& result, Workspace& ws) EXCLUSIVE_LOCKS_REQUIRED(cs_main, m_pool.cs);\n \n     // Run the script checks using our policy flags. As this can be slow, we should\n     // only invoke this on transactions that have otherwise passed policy checks.\n-    bool PolicyScriptChecks(ATMPArgs& args, const Workspace& ws, PrecomputedTransactionData& txdata) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    bool PolicyScriptChecks(ATMPArgs& args, MempoolAcceptResult& result, Workspace& ws, PrecomputedTransactionData& txdata) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n     // Re-run the script checks, using consensus flags, and try to cache the\n     // result in the scriptcache. This should be done after\n     // PolicyScriptChecks(). This requires that all inputs either be in our\n     // utxo set or in the mempool.\n-    bool ConsensusScriptChecks(ATMPArgs& args, const Workspace& ws, PrecomputedTransactionData &txdata) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    bool ConsensusScriptChecks(ATMPArgs& args, MempoolAcceptResult& result, Workspace& ws, PrecomputedTransactionData &txdata) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n     // Try to add the transaction to the mempool, removing any conflicts first.\n     // Returns true if the transaction is in the mempool after any size\n     // limiting is performed, false otherwise.\n-    bool Finalize(ATMPArgs& args, Workspace& ws) EXCLUSIVE_LOCKS_REQUIRED(cs_main, m_pool.cs);\n+    bool Finalize(ATMPArgs& args, MempoolAcceptResult& result, Workspace& ws) EXCLUSIVE_LOCKS_REQUIRED(cs_main, m_pool.cs);\n \n     // Compare a package's feerate against minimum allowed.\n     bool CheckFeeRate(size_t package_size, CAmount package_fee, TxValidationState& state)\n@@ -544,14 +540,14 @@ class MemPoolAccept\n     size_t m_limit_descendant_size;\n };\n \n-bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n+bool MemPoolAccept::PreChecks(ATMPArgs& args, MempoolAcceptResult& result, Workspace& ws)\n {\n     const CTransactionRef& ptx = ws.m_ptx;\n     const CTransaction& tx = *ws.m_ptx;\n     const uint256& hash = ws.m_hash;\n \n     // Copy/alias what we need out of args\n-    TxValidationState &state = args.m_state;\n+    TxValidationState &state = result.m_state;\n     const int64_t nAcceptTime = args.m_accept_time;\n     const bool bypass_limits = args.m_bypass_limits;\n     std::vector<COutPoint>& coins_to_uncache = args.m_coins_to_uncache;\n@@ -676,16 +672,10 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n     if (!CheckSequenceLocks(m_pool, tx, STANDARD_LOCKTIME_VERIFY_FLAGS, &lp))\n         return state.Invalid(TxValidationResult::TX_PREMATURE_SPEND, \"non-BIP68-final\");\n \n-    CAmount nFees = 0;\n-    if (!Consensus::CheckTxInputs(tx, state, m_view, GetSpendHeight(m_view), nFees)) {\n+    if (!Consensus::CheckTxInputs(tx, state, m_view, GetSpendHeight(m_view), result.m_fee)) {\n         return false; // state filled in by CheckTxInputs\n     }\n \n-    // If fee_out is passed, return the fee to the caller\n-    if (args.m_fee_out) {\n-        *args.m_fee_out = nFees;\n-    }\n-\n     // Check for non-standard pay-to-script-hash in inputs\n     const auto& params = args.m_chainparams.GetConsensus();\n     auto taproot_state = VersionBitsState(::ChainActive().Tip(), params, Consensus::DEPLOYMENT_TAPROOT, versionbitscache);\n@@ -700,7 +690,7 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n     int64_t nSigOpsCost = GetTransactionSigOpCost(tx, m_view, STANDARD_SCRIPT_VERIFY_FLAGS);\n \n     // nModifiedFees includes any fee deltas from PrioritiseTransaction\n-    nModifiedFees = nFees;\n+    nModifiedFees = result.m_fee;\n     m_pool.ApplyDelta(hash, nModifiedFees);\n \n     // Keep track of transactions that spend a coinbase, which we re-scan\n@@ -714,7 +704,7 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n         }\n     }\n \n-    entry.reset(new CTxMemPoolEntry(ptx, nFees, nAcceptTime, ::ChainActive().Height(),\n+    entry.reset(new CTxMemPoolEntry(ptx, result.m_fee, nAcceptTime, ::ChainActive().Height(),\n             fSpendsCoinbase, nSigOpsCost, lp));\n     unsigned int nSize = entry->GetTxSize();\n \n@@ -918,11 +908,11 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n     return true;\n }\n \n-bool MemPoolAccept::PolicyScriptChecks(ATMPArgs& args, const Workspace& ws, PrecomputedTransactionData& txdata)\n+bool MemPoolAccept::PolicyScriptChecks(ATMPArgs& args, MempoolAcceptResult& result, Workspace& ws, PrecomputedTransactionData& txdata)\n {\n     const CTransaction& tx = *ws.m_ptx;\n \n-    TxValidationState &state = args.m_state;\n+    TxValidationState &state = result.m_state;\n \n     constexpr unsigned int scriptVerifyFlags = STANDARD_SCRIPT_VERIFY_FLAGS;\n \n@@ -945,12 +935,12 @@ bool MemPoolAccept::PolicyScriptChecks(ATMPArgs& args, const Workspace& ws, Prec\n     return true;\n }\n \n-bool MemPoolAccept::ConsensusScriptChecks(ATMPArgs& args, const Workspace& ws, PrecomputedTransactionData& txdata)\n+bool MemPoolAccept::ConsensusScriptChecks(ATMPArgs& args, MempoolAcceptResult& result, Workspace& ws, PrecomputedTransactionData& txdata)\n {\n     const CTransaction& tx = *ws.m_ptx;\n     const uint256& hash = ws.m_hash;\n \n-    TxValidationState &state = args.m_state;\n+    TxValidationState &state = result.m_state;\n     const CChainParams& chainparams = args.m_chainparams;\n \n     // Check again against the current block tip's script verification\n@@ -977,11 +967,11 @@ bool MemPoolAccept::ConsensusScriptChecks(ATMPArgs& args, const Workspace& ws, P\n     return true;\n }\n \n-bool MemPoolAccept::Finalize(ATMPArgs& args, Workspace& ws)\n+bool MemPoolAccept::Finalize(ATMPArgs& args, MempoolAcceptResult& result, Workspace& ws)\n {\n     const CTransaction& tx = *ws.m_ptx;\n     const uint256& hash = ws.m_hash;\n-    TxValidationState &state = args.m_state;\n+    TxValidationState &state = result.m_state;\n     const bool bypass_limits = args.m_bypass_limits;\n \n     CTxMemPool::setEntries& allConflicting = ws.m_all_conflicting;\n@@ -1000,8 +990,7 @@ bool MemPoolAccept::Finalize(ATMPArgs& args, Workspace& ws)\n                 hash.ToString(),\n                 FormatMoney(nModifiedFees - nConflictingFees),\n                 (int)entry->GetTxSize() - (int)nConflictingSize);\n-        if (args.m_replaced_transactions)\n-            args.m_replaced_transactions->push_back(it->GetSharedTx());\n+        result.m_replaced_transactions.push_back(it->GetSharedTx());\n     }\n     m_pool.RemoveStaged(allConflicting, false, MemPoolRemovalReason::REPLACED);\n \n@@ -1024,46 +1013,63 @@ bool MemPoolAccept::Finalize(ATMPArgs& args, Workspace& ws)\n     return true;\n }\n \n-bool MemPoolAccept::AcceptSingleTransaction(const CTransactionRef& ptx, ATMPArgs& args)\n+MempoolAcceptResult MemPoolAccept::AcceptSingleTransaction(const CTransactionRef& ptx, ATMPArgs& args)\n {\n     AssertLockHeld(cs_main);\n     LOCK(m_pool.cs); // mempool \"read lock\" (held through GetMainSignals().TransactionAddedToMempool())\n \n     Workspace workspace(ptx);\n+    MempoolAcceptResult result(ptx);\n \n-    if (!PreChecks(args, workspace)) return false;\n+    if (!PreChecks(args, result, workspace)) {\n+        result.m_accepted = false;\n+        return result;\n+    }\n \n     // Only compute the precomputed transaction data if we need to verify\n     // scripts (ie, other policy checks pass). We perform the inexpensive\n     // checks first and avoid hashing and signature verification unless those\n     // checks pass, to mitigate CPU exhaustion denial-of-service attacks.\n     PrecomputedTransactionData txdata;\n \n-    if (!PolicyScriptChecks(args, workspace, txdata)) return false;\n+    if (!PolicyScriptChecks(args, result, workspace, txdata)) {\n+        result.m_accepted = false;\n+        return result;\n+    }\n \n-    if (!ConsensusScriptChecks(args, workspace, txdata)) return false;\n+    if (!ConsensusScriptChecks(args, result, workspace, txdata)) {\n+        result.m_accepted = false;\n+        return result;\n+    }\n \n     // Tx was accepted, but not added\n-    if (args.m_test_accept) return true;\n+    if (args.m_test_accept) {\n+        result.m_accepted = true;\n+        return result;\n+    }\n \n-    if (!Finalize(args, workspace)) return false;\n+    if (!Finalize(args, result, workspace)) {\n+        result.m_accepted = false;\n+        return result;\n+    }\n \n     GetMainSignals().TransactionAddedToMempool(ptx, m_pool.GetAndIncrementSequence());\n \n-    return true;\n+    result.m_accepted = true;\n+    return result;\n }\n \n } // anon namespace\n \n /** (try to) add transaction to memory pool with a specified acceptance time **/\n-static bool AcceptToMemoryPoolWithTime(const CChainParams& chainparams, CTxMemPool& pool, TxValidationState &state, const CTransactionRef &tx,\n-                        int64_t nAcceptTime, std::list<CTransactionRef>* plTxnReplaced,\n-                        bool bypass_limits, bool test_accept, CAmount* fee_out=nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+static MempoolAcceptResult AcceptToMemoryPoolWithTime(const CChainParams& chainparams, CTxMemPool& pool, const CTransactionRef &tx,\n+                        int64_t nAcceptTime, bool bypass_limits, bool test_accept) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n     std::vector<COutPoint> coins_to_uncache;\n-    MemPoolAccept::ATMPArgs args { chainparams, state, nAcceptTime, plTxnReplaced, bypass_limits, coins_to_uncache, test_accept, fee_out };\n-    bool res = MemPoolAccept(pool).AcceptSingleTransaction(tx, args);\n-    if (!res) {\n+    MemPoolAccept::ATMPArgs args { chainparams, nAcceptTime, bypass_limits, coins_to_uncache, test_accept };\n+\n+    MempoolAcceptResult result = MemPoolAccept(pool).AcceptSingleTransaction(tx, args);\n+    if (!result.m_accepted) {\n         // Remove coins that were not present in the coins cache before calling ATMPW;\n         // this is to prevent memory DoS in case we receive a large number of\n         // invalid transactions that attempt to overrun the in-memory coins cache\n@@ -1075,15 +1081,15 @@ static bool AcceptToMemoryPoolWithTime(const CChainParams& chainparams, CTxMemPo\n     // After we've (potentially) uncached entries, ensure our coins cache is still within its size limits\n     BlockValidationState state_dummy;\n     ::ChainstateActive().FlushStateToDisk(chainparams, state_dummy, FlushStateMode::PERIODIC);\n-    return res;\n+    return result;\n }\n \n-bool AcceptToMemoryPool(CTxMemPool& pool, TxValidationState &state, const CTransactionRef &tx,\n-                        std::list<CTransactionRef>* plTxnReplaced,\n-                        bool bypass_limits, bool test_accept, CAmount* fee_out)\n+MempoolAcceptResult AcceptToMemoryPool(CTxMemPool& pool, const CTransactionRef &tx,\n+                        bool bypass_limits, bool test_accept)\n {\n     const CChainParams& chainparams = Params();\n-    return AcceptToMemoryPoolWithTime(chainparams, pool, state, tx, GetTime(), plTxnReplaced, bypass_limits, test_accept, fee_out);\n+    MempoolAcceptResult result = AcceptToMemoryPoolWithTime(chainparams, pool, tx, GetTime(), bypass_limits, test_accept);\n+    return result;\n }\n \n CTransactionRef GetTransaction(const CBlockIndex* const block_index, const CTxMemPool* const mempool, const uint256& hash, const Consensus::Params& consensusParams, uint256& hashBlock)\n@@ -5006,8 +5012,8 @@ bool LoadMempool(CTxMemPool& pool)\n             TxValidationState state;\n             if (nTime > nNow - nExpiryTimeout) {\n                 LOCK(cs_main);\n-                AcceptToMemoryPoolWithTime(chainparams, pool, state, tx, nTime,\n-                                           nullptr /* plTxnReplaced */, false /* bypass_limits */,\n+                AcceptToMemoryPoolWithTime(chainparams, pool, tx, nTime,\n+                                           false /* bypass_limits */,\n                                            false /* test_accept */);\n                 if (state.IsValid()) {\n                     ++count;"
      },
      {
        "sha": "822d21aad2e73f5524f72b1801aea531527983fb",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 17,
        "deletions": 7,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d5581bb809abad4507e995d8af9a18645196060e/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d5581bb809abad4507e995d8af9a18645196060e/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=d5581bb809abad4507e995d8af9a18645196060e",
        "patch": "@@ -12,6 +12,7 @@\n \n #include <amount.h>\n #include <coins.h>\n+#include <consensus/validation.h>\n #include <crypto/common.h> // for ReadLE64\n #include <fs.h>\n #include <optional.h>\n@@ -44,7 +45,6 @@ class CConnman;\n class CScriptCheck;\n class CTxMemPool;\n class ChainstateManager;\n-class TxValidationState;\n struct ChainTxData;\n \n struct DisconnectedBlockTransactions;\n@@ -194,12 +194,22 @@ void UnlinkPrunedFiles(const std::set<int>& setFilesToPrune);\n /** Prune block files up to a given height */\n void PruneBlockFilesManual(int nManualPruneHeight);\n \n-/** (try to) add transaction to memory pool\n- * plTxnReplaced will be appended to with all transactions replaced from mempool\n- * @param[out] fee_out optional argument to return tx fee to the caller **/\n-bool AcceptToMemoryPool(CTxMemPool& pool, TxValidationState &state, const CTransactionRef &tx,\n-                        std::list<CTransactionRef>* plTxnReplaced,\n-                        bool bypass_limits, bool test_accept=false, CAmount* fee_out=nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+/** Per-transaction result from trying to accept a transaction to the memory pool. */\n+struct MempoolAcceptResult {\n+    MempoolAcceptResult(const CTransactionRef& ptx) : txid(ptx->GetHash()) {}\n+\n+    uint256 txid;\n+    bool m_accepted = false;\n+    TxValidationState m_state;\n+    std::list<CTransactionRef> m_replaced_transactions{};\n+    CAmount m_fee = CAmount(0);\n+};\n+\n+/**\n+ * (Try to) add a transaction to the memory pool.\n+ */\n+MempoolAcceptResult AcceptToMemoryPool(CTxMemPool& pool, const CTransactionRef &tx,\n+                        bool bypass_limits, bool test_accept=false) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n /** Get the BIP9 state for a given deployment at the current tip. */\n ThresholdState VersionBitsTipState(const Consensus::Params& params, Consensus::DeploymentPos pos);"
      }
    ]
  },
  {
    "sha": "18a0552880fca0b5ba88b0b73b829da3edf8d0b2",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxOGEwNTUyODgwZmNhMGI1YmE4OGIwYjczYjgyOWRhM2VkZjhkMGIy",
    "commit": {
      "author": {
        "name": "gzhao408",
        "email": "gzhao408@berkeley.edu",
        "date": "2021-01-09T21:52:28Z"
      },
      "committer": {
        "name": "gzhao408",
        "email": "gzhao408@berkeley.edu",
        "date": "2021-01-09T23:56:03Z"
      },
      "message": "[p2p] mildly discourage peers who violate fee filter",
      "tree": {
        "sha": "b5c7a36387d7659082b8bcbc249bf9b486430ca4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b5c7a36387d7659082b8bcbc249bf9b486430ca4"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/18a0552880fca0b5ba88b0b73b829da3edf8d0b2",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/18a0552880fca0b5ba88b0b73b829da3edf8d0b2",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/18a0552880fca0b5ba88b0b73b829da3edf8d0b2",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/18a0552880fca0b5ba88b0b73b829da3edf8d0b2/comments",
    "author": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d5581bb809abad4507e995d8af9a18645196060e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d5581bb809abad4507e995d8af9a18645196060e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d5581bb809abad4507e995d8af9a18645196060e"
      }
    ],
    "stats": {
      "total": 22,
      "additions": 18,
      "deletions": 4
    },
    "files": [
      {
        "sha": "a6d9666c85b7259f34da9270daa623443c7efbd6",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 18,
        "deletions": 4,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/18a0552880fca0b5ba88b0b73b829da3edf8d0b2/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/18a0552880fca0b5ba88b0b73b829da3edf8d0b2/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=18a0552880fca0b5ba88b0b73b829da3edf8d0b2",
        "patch": "@@ -1092,6 +1092,10 @@ bool PeerManager::MaybePunishNodeForTx(NodeId nodeid, const TxValidationState& s\n     case TxValidationResult::TX_CONSENSUS:\n         Misbehaving(nodeid, 100, message);\n         return true;\n+    // The node violated our fee filter:\n+    case TxValidationResult::TX_MEMPOOL_POLICY:\n+        Misbehaving(nodeid, 1, message);\n+        return true;\n     // Conflicting (but not necessarily invalid) data or different policy:\n     case TxValidationResult::TX_RECENT_CONSENSUS_CHANGE:\n     case TxValidationResult::TX_INPUTS_NOT_STANDARD:\n@@ -1101,7 +1105,6 @@ bool PeerManager::MaybePunishNodeForTx(NodeId nodeid, const TxValidationState& s\n     case TxValidationResult::TX_WITNESS_MUTATED:\n     case TxValidationResult::TX_WITNESS_STRIPPED:\n     case TxValidationResult::TX_CONFLICT:\n-    case TxValidationResult::TX_MEMPOOL_POLICY:\n         break;\n     }\n     if (message != \"\") {\n@@ -3021,9 +3024,20 @@ void PeerManager::ProcessMessage(CNode& pfrom, const std::string& msg_type, CDat\n \n             // Recursively process any orphan transactions that depended on this one\n             ProcessOrphanTx(peer->m_orphan_work_set);\n-        }\n-        else if (state.GetResult() == TxValidationResult::TX_MISSING_INPUTS)\n-        {\n+        } else if (state.GetResult() == TxValidationResult::TX_MEMPOOL_POLICY\n+                        && state.GetRejectReason().find(\"fee\") != std::string::npos) {\n+            // If the transaction didn't meet fee-related mempool policy,\n+            // check if our peer isn't respecting the fee filter we sent them.\n+            const CAmount tx_feeperk = CFeeRate(result.m_fee, ptx->GetTotalSize()).GetFeePerK();\n+            if (tx_feeperk > pfrom.m_tx_relay->lastSentFeeFilter) {\n+                LogPrint(BCLog::MEMPOOLREJ, \"%s from peer=%d had a fee of %d, exceeding the fee filter sent, %d\\n\",\n+                    tx.GetHash().ToString(),\n+                    pfrom.GetId(),\n+                    result.m_fee,\n+                    pfrom.m_tx_relay->lastSentFeeFilter);\n+                MaybePunishNodeForTx(pfrom.GetId(), state, \"violated fee filter\");\n+            }\n+        } else if (state.GetResult() == TxValidationResult::TX_MISSING_INPUTS) {\n             bool fRejectedParents = false; // It may be the case that the orphans parents have all been rejected\n \n             // Deduplicate parent txids, so that we don't have to loop over"
      }
    ]
  },
  {
    "sha": "d0988dd32202617ead0e259ab244b5efec0af973",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkMDk4OGRkMzIyMDI2MTdlYWQwZTI1OWFiMjQ0YjVlZmVjMGFmOTcz",
    "commit": {
      "author": {
        "name": "gzhao408",
        "email": "gzhao408@berkeley.edu",
        "date": "2021-01-09T23:24:31Z"
      },
      "committer": {
        "name": "gzhao408",
        "email": "gzhao408@berkeley.edu",
        "date": "2021-01-09T23:56:03Z"
      },
      "message": "[test] fee filter violations",
      "tree": {
        "sha": "27e1591ddd49b90bcd9df8fbc0083032713fc757",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/27e1591ddd49b90bcd9df8fbc0083032713fc757"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d0988dd32202617ead0e259ab244b5efec0af973",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d0988dd32202617ead0e259ab244b5efec0af973",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d0988dd32202617ead0e259ab244b5efec0af973",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d0988dd32202617ead0e259ab244b5efec0af973/comments",
    "author": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following{/other_user}",
      "gists_url": "https://api.github.com/users/glozow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/glozow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "18a0552880fca0b5ba88b0b73b829da3edf8d0b2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/18a0552880fca0b5ba88b0b73b829da3edf8d0b2",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/18a0552880fca0b5ba88b0b73b829da3edf8d0b2"
      }
    ],
    "stats": {
      "total": 64,
      "additions": 59,
      "deletions": 5
    },
    "files": [
      {
        "sha": "e4feed257140e111a0b94103100b68234571c1a5",
        "filename": "test/functional/p2p_feefilter.py",
        "status": "modified",
        "additions": 59,
        "deletions": 5,
        "changes": 64,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d0988dd32202617ead0e259ab244b5efec0af973/test/functional/p2p_feefilter.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d0988dd32202617ead0e259ab244b5efec0af973/test/functional/p2p_feefilter.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_feefilter.py?ref=d0988dd32202617ead0e259ab244b5efec0af973",
        "patch": "@@ -5,15 +5,30 @@\n \"\"\"Test processing of feefilter messages.\"\"\"\n \n from decimal import Decimal\n-\n-from test_framework.messages import MSG_TX, MSG_WTX, msg_feefilter\n-from test_framework.p2p import P2PInterface, p2p_lock\n+from io import BytesIO\n+\n+from test_framework.address import ADDRESS_BCRT1_P2WSH_OP_TRUE\n+from test_framework.messages import (\n+    COIN,\n+    CTransaction,\n+    MSG_TX,\n+    MSG_WTX,\n+    msg_feefilter\n+)\n+from test_framework.p2p import (\n+    P2PDataStore,\n+    P2PInterface,\n+    p2p_lock,\n+)\n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import assert_equal\n+from test_framework.util import (\n+    assert_equal,\n+    hex_str_to_bytes,\n+)\n from test_framework.wallet import MiniWallet\n \n \n-class FeefilterConn(P2PInterface):\n+class FeefilterConn(P2PDataStore):\n     feefilter_received = False\n \n     def on_feefilter(self, message):\n@@ -60,6 +75,7 @@ def set_test_params(self):\n \n     def run_test(self):\n         self.test_feefilter_forcerelay()\n+        self.test_feefilter_violation()\n         self.test_feefilter()\n \n     def test_feefilter_forcerelay(self):\n@@ -74,6 +90,44 @@ def test_feefilter_forcerelay(self):\n         self.restart_node(0)\n         self.connect_nodes(1, 0)\n \n+    def test_feefilter_violation(self):\n+        self.log.info(\"Restart node0 with a really high fee filter\")\n+        HIGH_FEE_FILTER = Decimal(100000) / COIN\n+        self.restart_node(0, extra_args=[\"-minrelaytxfee={}\".format(HIGH_FEE_FILTER)])\n+        self.connect_nodes(1, 0)\n+\n+        assert_equal(self.nodes[1].getpeerinfo()[0]['minfeefilter'], HIGH_FEE_FILTER)\n+        miniwallet = MiniWallet(self.nodes[1])\n+        miniwallet.generate(100)\n+        self.nodes[1].generate(100)\n+        self.sync_all()\n+\n+        self.log.info('Send 100 transactions with feerate below the filter')\n+        cheap_txns = []\n+        txids = []\n+        for _ in range(100):\n+            tx = miniwallet.send_self_transfer(fee_rate=Decimal('0.00000150'), from_node=self.nodes[1])\n+            transaction = CTransaction()\n+            transaction.deserialize(BytesIO(hex_str_to_bytes(tx['hex'])))\n+            transaction.rehash()\n+            cheap_txns.append(transaction)\n+            txids.append(tx['txid'])\n+        assert_equal(set(txids), set(self.nodes[1].getrawmempool()))\n+        assert_equal(len(self.nodes[0].getrawmempool()), 0)\n+\n+        self.log.info('Check behavior when feefilter is violated')\n+        cheap_peer = self.nodes[0].add_p2p_connection(FeefilterConn())\n+        cheap_peer.assert_feefilter_received(True)\n+        cheap_peer.send_txs_and_test(cheap_txns[:99], self.nodes[0], success=False, expect_disconnect=False)\n+        self.log.info('The 100th violation should cause disconnect')\n+        cheap_peer.send_txs_and_test([cheap_txns[99]], self.nodes[0], success=False, expect_disconnect=True)\n+\n+        # Clear mempool and Restart to disconnect peers and load default extra_args\n+        self.nodes[1].generateblock(output=ADDRESS_BCRT1_P2WSH_OP_TRUE, transactions=txids)\n+        self.sync_all()\n+        self.restart_node(0)\n+        self.connect_nodes(1, 0)\n+\n     def test_feefilter(self):\n         node1 = self.nodes[1]\n         node0 = self.nodes[0]"
      }
    ]
  }
]