[
  {
    "sha": "dc7e41bd6fe77ca9d0bc8d14412660c885a5d74d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkYzdlNDFiZDZmZTc3Y2E5ZDBiYzhkMTQ0MTI2NjBjODg1YTVkNzRk",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-08-14T15:46:22Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2018-01-11T18:52:22Z"
      },
      "message": "Turn mapBlocksInFlight into a multimap",
      "tree": {
        "sha": "5a0af82fb9a2b81a0fba59bfeeaa352b674023ca",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5a0af82fb9a2b81a0fba59bfeeaa352b674023ca"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/dc7e41bd6fe77ca9d0bc8d14412660c885a5d74d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dc7e41bd6fe77ca9d0bc8d14412660c885a5d74d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/dc7e41bd6fe77ca9d0bc8d14412660c885a5d74d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dc7e41bd6fe77ca9d0bc8d14412660c885a5d74d/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "32c9b570fceaad76536a2c881b4dc1d961d9b306",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/32c9b570fceaad76536a2c881b4dc1d961d9b306",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/32c9b570fceaad76536a2c881b4dc1d961d9b306"
      }
    ],
    "stats": {
      "total": 145,
      "additions": 92,
      "deletions": 53
    },
    "files": [
      {
        "sha": "78b2aa9315070d64c72331b41ab461f2280c5d12",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 92,
        "deletions": 53,
        "changes": 145,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dc7e41bd6fe77ca9d0bc8d14412660c885a5d74d/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dc7e41bd6fe77ca9d0bc8d14412660c885a5d74d/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=dc7e41bd6fe77ca9d0bc8d14412660c885a5d74d",
        "patch": "@@ -114,7 +114,8 @@ namespace {\n         bool fValidatedHeaders;                                  //!< Whether this block has validated headers at the time of request.\n         std::unique_ptr<PartiallyDownloadedBlock> partialBlock;  //!< Optional, used for CMPCTBLOCK downloads\n     };\n-    std::map<uint256, std::pair<NodeId, std::list<QueuedBlock>::iterator> > mapBlocksInFlight;\n+    typedef std::multimap<uint256, std::pair<NodeId, std::list<QueuedBlock>::iterator>> BlockDownloadMap;\n+    BlockDownloadMap mmapBlocksInFlight;\n \n     /** Stack of nodes which we have set to announce using compact blocks */\n     std::list<NodeId> lNodesAnnouncingHeaderAndIDs;\n@@ -275,7 +276,6 @@ CNodeState *State(NodeId pnode) {\n         return nullptr;\n     return &it->second;\n }\n-\n void UpdatePreferredDownload(CNode* node, CNodeState* state)\n {\n     nPreferredDownload -= state->fPreferredDownload;\n@@ -307,51 +307,74 @@ void PushNodeVersion(CNode *pnode, CConnman* connman, int64_t nTime)\n     }\n }\n \n+// Requires cs_main\n+// Helper function for MarkBlockAsReceived and MarkBlockAsNotInFlight\n+static void ClearDownloadState(BlockDownloadMap::iterator itInFlight) {\n+    AssertLockHeld(cs_main);\n+\n+    CNodeState *state = State(itInFlight->second.first);\n+    state->nBlocksInFlightValidHeaders -= itInFlight->second.second->fValidatedHeaders;\n+    if (state->nBlocksInFlightValidHeaders == 0 && itInFlight->second.second->fValidatedHeaders) {\n+        // Last validated block on the queue was received.\n+        nPeersWithValidatedDownloads--;\n+    }\n+    if (state->vBlocksInFlight.begin() == itInFlight->second.second) {\n+        // First block on the queue was received, update the start download time for the next one\n+        state->nDownloadingSince = std::max(state->nDownloadingSince, GetTimeMicros());\n+    }\n+    state->vBlocksInFlight.erase(itInFlight->second.second);\n+    state->nBlocksInFlight--;\n+    state->nStallingSince = 0;\n+}\n+\n+// Requires cs_main.\n+// Used to remove block from mmapBlocksInFlight and clear the download state for\n+// a block if for some reason block was not received. Download state clearing is\n+// skipped as an optimization in FinalizeNode.\n+static void MarkBlockAsNotInFlight(const uint256& hash, NodeId nodeid, bool clearState = true) {\n+    AssertLockHeld(cs_main);\n+\n+    std::pair<BlockDownloadMap::iterator, BlockDownloadMap::iterator> range = mmapBlocksInFlight.equal_range(hash);\n+    while (range.first != range.second) {\n+        BlockDownloadMap::iterator itInFlight = range.first;\n+        range.first++;\n+        if (itInFlight->second.first == nodeid) {\n+            if (clearState) ClearDownloadState(itInFlight);\n+            mmapBlocksInFlight.erase(itInFlight);\n+        }\n+    }\n+}\n+\n // Requires cs_main.\n // Returns a bool indicating whether we requested this block.\n-// Also used if a block was /not/ received and timed out or started with another peer\n bool MarkBlockAsReceived(const uint256& hash) {\n-    std::map<uint256, std::pair<NodeId, std::list<QueuedBlock>::iterator> >::iterator itInFlight = mapBlocksInFlight.find(hash);\n-    if (itInFlight != mapBlocksInFlight.end()) {\n-        CNodeState *state = State(itInFlight->second.first);\n-        assert(state != nullptr);\n-        state->nBlocksInFlightValidHeaders -= itInFlight->second.second->fValidatedHeaders;\n-        if (state->nBlocksInFlightValidHeaders == 0 && itInFlight->second.second->fValidatedHeaders) {\n-            // Last validated block on the queue was received.\n-            nPeersWithValidatedDownloads--;\n-        }\n-        if (state->vBlocksInFlight.begin() == itInFlight->second.second) {\n-            // First block on the queue was received, update the start download time for the next one\n-            state->nDownloadingSince = std::max(state->nDownloadingSince, GetTimeMicros());\n-        }\n-        state->vBlocksInFlight.erase(itInFlight->second.second);\n-        state->nBlocksInFlight--;\n-        state->nStallingSince = 0;\n-        mapBlocksInFlight.erase(itInFlight);\n-        return true;\n+    std::pair<BlockDownloadMap::iterator, BlockDownloadMap::iterator> range = mmapBlocksInFlight.equal_range(hash);\n+    if (range.first == range.second) return false;\n+    while (range.first != range.second) {\n+        ClearDownloadState(range.first);\n+        range.first = mmapBlocksInFlight.erase(range.first);\n     }\n-    return false;\n+    return true;\n }\n \n // Requires cs_main.\n // returns false, still setting pit, if the block was already in flight from the same peer\n // pit will only be valid as long as the same cs_main lock is being held\n bool MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const CBlockIndex* pindex = nullptr, std::list<QueuedBlock>::iterator** pit = nullptr) {\n+    AssertLockHeld(cs_main);\n     CNodeState *state = State(nodeid);\n     assert(state != nullptr);\n \n     // Short-circuit most stuff in case its from the same node\n-    std::map<uint256, std::pair<NodeId, std::list<QueuedBlock>::iterator> >::iterator itInFlight = mapBlocksInFlight.find(hash);\n-    if (itInFlight != mapBlocksInFlight.end() && itInFlight->second.first == nodeid) {\n-        if (pit) {\n-            *pit = &itInFlight->second.second;\n+    for (auto range = mmapBlocksInFlight.equal_range(hash); range.first != range.second; range.first++) {\n+        if (range.first->second.first == nodeid) {\n+            if (pit) {\n+                *pit = &range.first->second.second;\n+            }\n+            return false;\n         }\n-        return false;\n     }\n \n-    // Make sure it's not listed somewhere already.\n-    MarkBlockAsReceived(hash);\n-\n     std::list<QueuedBlock>::iterator it = state->vBlocksInFlight.insert(state->vBlocksInFlight.end(),\n             {hash, pindex, pindex != nullptr, std::unique_ptr<PartiallyDownloadedBlock>(pit ? new PartiallyDownloadedBlock(&mempool) : nullptr)});\n     state->nBlocksInFlight++;\n@@ -363,7 +386,7 @@ bool MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const CBlockIndex*\n     if (state->nBlocksInFlightValidHeaders == 1 && pindex != nullptr) {\n         nPeersWithValidatedDownloads++;\n     }\n-    itInFlight = mapBlocksInFlight.insert(std::make_pair(hash, std::make_pair(nodeid, it))).first;\n+    BlockDownloadMap::iterator itInFlight = mmapBlocksInFlight.insert(std::make_pair(hash, std::make_pair(nodeid, it)));\n     if (pit)\n         *pit = &itInFlight->second.second;\n     return true;\n@@ -441,7 +464,7 @@ bool TipMayBeStale(const Consensus::Params &consensusParams)\n     if (g_last_tip_update == 0) {\n         g_last_tip_update = GetTime();\n     }\n-    return g_last_tip_update < GetTime() - consensusParams.nPowTargetSpacing * 3 && mapBlocksInFlight.empty();\n+    return g_last_tip_update < GetTime() - consensusParams.nPowTargetSpacing * 3 && mmapBlocksInFlight.empty();\n }\n \n // Requires cs_main\n@@ -526,7 +549,7 @@ void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<con\n             if (pindex->nStatus & BLOCK_HAVE_DATA || chainActive.Contains(pindex)) {\n                 if (pindex->nChainTx)\n                     state->pindexLastCommonBlock = pindex;\n-            } else if (mapBlocksInFlight.count(pindex->GetBlockHash()) == 0) {\n+            } else if (mmapBlocksInFlight.count(pindex->GetBlockHash()) == 0) {\n                 // The block is not already downloaded, and not yet in flight.\n                 if (pindex->nHeight > nWindowEnd) {\n                     // We reached the end of the window.\n@@ -542,7 +565,7 @@ void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<con\n                 }\n             } else if (waitingfor == -1) {\n                 // This is the first already-in-flight block.\n-                waitingfor = mapBlocksInFlight[pindex->GetBlockHash()].first;\n+                waitingfor = mmapBlocksInFlight.lower_bound(pindex->GetBlockHash())->second.first;\n             }\n         }\n     }\n@@ -592,7 +615,7 @@ void PeerLogicValidation::FinalizeNode(NodeId nodeid, bool& fUpdateConnectionTim\n     }\n \n     for (const QueuedBlock& entry : state->vBlocksInFlight) {\n-        mapBlocksInFlight.erase(entry.hash);\n+        MarkBlockAsNotInFlight(entry.hash, nodeid, false);\n     }\n     EraseOrphansFor(nodeid);\n     nPreferredDownload -= state->fPreferredDownload;\n@@ -605,7 +628,7 @@ void PeerLogicValidation::FinalizeNode(NodeId nodeid, bool& fUpdateConnectionTim\n \n     if (mapNodeState.empty()) {\n         // Do a consistency check after the last peer is removed.\n-        assert(mapBlocksInFlight.empty());\n+        assert(mmapBlocksInFlight.empty());\n         assert(nPreferredDownload == 0);\n         assert(nPeersWithValidatedDownloads == 0);\n         assert(g_outbound_peers_with_protect_from_disconnect == 0);\n@@ -940,7 +963,7 @@ void PeerLogicValidation::BlockChecked(const CBlock& block, const CValidationSta\n     //    just check that there are currently no other blocks in flight.\n     else if (state.IsValid() &&\n              !IsInitialBlockDownload() &&\n-             mapBlocksInFlight.count(hash) == mapBlocksInFlight.size()) {\n+             mmapBlocksInFlight.count(hash) == mmapBlocksInFlight.size()) {\n         if (it != mapBlockSource.end()) {\n             MaybeSetPeerAsAnnouncingHeaderAndIDs(it->second.first, connman);\n         }\n@@ -1380,7 +1403,7 @@ bool static ProcessHeadersMessage(CNode *pfrom, CConnman *connman, const std::ve\n             // Calculate all the blocks we'd need to switch to pindexLast, up to a limit.\n             while (pindexWalk && !chainActive.Contains(pindexWalk) && vToFetch.size() <= MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n                 if (!(pindexWalk->nStatus & BLOCK_HAVE_DATA) &&\n-                        !mapBlocksInFlight.count(pindexWalk->GetBlockHash()) &&\n+                        !mmapBlocksInFlight.count(pindexWalk->GetBlockHash()) &&\n                         (!IsWitnessEnabled(pindexWalk->pprev, chainparams.GetConsensus()) || State(pfrom->GetId())->fHaveWitness)) {\n                     // We don't have this block, and it's not yet in flight.\n                     vToFetch.push_back(pindexWalk);\n@@ -1414,7 +1437,7 @@ bool static ProcessHeadersMessage(CNode *pfrom, CConnman *connman, const std::ve\n                             pindexLast->GetBlockHash().ToString(), pindexLast->nHeight);\n                 }\n                 if (vGetData.size() > 0) {\n-                    if (nodestate->fSupportsDesiredCmpctVersion && vGetData.size() == 1 && mapBlocksInFlight.size() == 1 && pindexLast->pprev->IsValid(BLOCK_VALID_CHAIN)) {\n+                    if (nodestate->fSupportsDesiredCmpctVersion && vGetData.size() == 1 && mmapBlocksInFlight.size() == 1 && pindexLast->pprev->IsValid(BLOCK_VALID_CHAIN)) {\n                         // In any case, we want to download using a compact block, not a regular one\n                         vGetData[0] = CInv(MSG_CMPCT_BLOCK, vGetData[0].hash);\n                     }\n@@ -1850,7 +1873,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n \n             if (inv.type == MSG_BLOCK) {\n                 UpdateBlockAvailability(pfrom->GetId(), inv.hash);\n-                if (!fAlreadyHave && !fImporting && !fReindex && !mapBlocksInFlight.count(inv.hash)) {\n+                if (!fAlreadyHave && !fImporting && !fReindex && !mmapBlocksInFlight.count(inv.hash)) {\n                     // We used to request the full block here, but since headers-announcements are now the\n                     // primary method of announcement on the network, and since, in the case that a node\n                     // fell back to inv we probably have a reorg which we should get the headers for first,\n@@ -2324,12 +2347,18 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             nodestate->m_last_block_announcement = GetTime();\n         }\n \n-        std::map<uint256, std::pair<NodeId, std::list<QueuedBlock>::iterator> >::iterator blockInFlightIt = mapBlocksInFlight.find(pindex->GetBlockHash());\n-        bool fAlreadyInFlight = blockInFlightIt != mapBlocksInFlight.end();\n-\n         if (pindex->nStatus & BLOCK_HAVE_DATA) // Nothing to do here\n             return true;\n \n+        std::pair<BlockDownloadMap::iterator, BlockDownloadMap::iterator> rangeInFlight = mmapBlocksInFlight.equal_range(pindex->GetBlockHash());\n+        bool fAlreadyInFlight = rangeInFlight.first != rangeInFlight.second;\n+        bool fInFlightFromSamePeer = false;\n+        while (rangeInFlight.first != rangeInFlight.second) {\n+            if (rangeInFlight.first->second.first == pfrom->GetId())\n+                fInFlightFromSamePeer = true;\n+            rangeInFlight.first++;\n+        }\n+\n         if (pindex->nChainWork <= chainActive.Tip()->nChainWork || // We know something better\n                 pindex->nTx != 0) { // We had this block at some point, but pruned it\n             if (fAlreadyInFlight) {\n@@ -2356,8 +2385,8 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         // possibilities in compact block processing...\n         if (pindex->nHeight <= chainActive.Height() + 2) {\n             if ((!fAlreadyInFlight && nodestate->nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) ||\n-                 (fAlreadyInFlight && blockInFlightIt->second.first == pfrom->GetId())) {\n-                std::list<QueuedBlock>::iterator* queuedBlockIt = nullptr;\n+                fInFlightFromSamePeer) {\n+                std::list<QueuedBlock>::iterator *queuedBlockIt = nullptr;\n                 if (!MarkBlockAsInFlight(pfrom->GetId(), pindex->GetBlockHash(), pindex, &queuedBlockIt)) {\n                     if (!(*queuedBlockIt)->partialBlock)\n                         (*queuedBlockIt)->partialBlock.reset(new PartiallyDownloadedBlock(&mempool));\n@@ -2371,7 +2400,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 PartiallyDownloadedBlock& partialBlock = *(*queuedBlockIt)->partialBlock;\n                 ReadStatus status = partialBlock.InitData(cmpctblock, vExtraTxnForCompact);\n                 if (status == READ_STATUS_INVALID) {\n-                    MarkBlockAsReceived(pindex->GetBlockHash()); // Reset in-flight state in case of whitelist\n+                    MarkBlockAsNotInFlight(pindex->GetBlockHash(), pfrom->GetId()); // Reset in-flight state in case of whitelist\n                     Misbehaving(pfrom->GetId(), 100);\n                     LogPrintf(\"Peer %d sent us invalid compact block\\n\", pfrom->GetId());\n                     return true;\n@@ -2489,17 +2518,27 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         {\n             LOCK(cs_main);\n \n-            std::map<uint256, std::pair<NodeId, std::list<QueuedBlock>::iterator> >::iterator it = mapBlocksInFlight.find(resp.blockhash);\n-            if (it == mapBlocksInFlight.end() || !it->second.second->partialBlock ||\n-                    it->second.first != pfrom->GetId()) {\n+            bool expected_BLOCKTXN = false;\n+            std::pair<BlockDownloadMap::iterator, BlockDownloadMap::iterator> rangeInFlight = mmapBlocksInFlight.equal_range(resp.blockhash);\n+            while (rangeInFlight.first != rangeInFlight.second) {\n+                if (rangeInFlight.first->second.first == pfrom->GetId()) {\n+                    if (rangeInFlight.first->second.second->partialBlock) {\n+                        expected_BLOCKTXN = true;\n+                    }\n+                    break;\n+                }\n+                rangeInFlight.first++;\n+            }\n+\n+            if (!expected_BLOCKTXN) {\n                 LogPrint(BCLog::NET, \"Peer %d sent us block transactions for block we weren't expecting\\n\", pfrom->GetId());\n                 return true;\n             }\n \n-            PartiallyDownloadedBlock& partialBlock = *it->second.second->partialBlock;\n+            PartiallyDownloadedBlock& partialBlock = *rangeInFlight.first->second.second->partialBlock;\n             ReadStatus status = partialBlock.FillBlock(*pblock, resp.txn);\n             if (status == READ_STATUS_INVALID) {\n-                MarkBlockAsReceived(resp.blockhash); // Reset in-flight state in case of whitelist\n+                MarkBlockAsNotInFlight(resp.blockhash, pfrom->GetId()); // Reset in-flight state in case of whitelist\n                 Misbehaving(pfrom->GetId(), 100);\n                 LogPrintf(\"Peer %d sent us invalid compact block/non-matching block transactions\\n\", pfrom->GetId());\n                 return true;\n@@ -2526,7 +2565,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 // though the block was successfully read, and rely on the\n                 // handling in ProcessNewBlock to ensure the block index is\n                 // updated, reject messages go out, etc.\n-                MarkBlockAsReceived(resp.blockhash); // it is now an empty pointer\n+                MarkBlockAsNotInFlight(resp.blockhash, pfrom->GetId()); // it is now an empty pointer\n                 fBlockRead = true;\n                 // mapBlockSource is only used for sending reject messages and DoS scores,\n                 // so the race between here and cs_main in ProcessNewBlock is fine.\n@@ -2538,7 +2577,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         } // Don't hold cs_main when we call into ProcessNewBlock\n         if (fBlockRead) {\n             bool fNewBlock = false;\n-            // Since we requested this block (it was in mapBlocksInFlight), force it to be processed,\n+            // Since we requested this block (it was in mmapBlocksInFlight), force it to be processed,\n             // even if it would not be a candidate for new tip (missing previous block, chain not long enough, etc)\n             // This bypasses some anti-DoS logic in AcceptBlock (eg to prevent\n             // disk-space attacks), but this should be safe due to the"
      }
    ]
  },
  {
    "sha": "489b1a3926ff241d2a1575bf8f2a22636967ffd5",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0ODliMWEzOTI2ZmYyNDFkMmExNTc1YmY4ZjJhMjI2MzY5NjdmZmQ1",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-06-06T20:13:55Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2018-01-11T18:52:22Z"
      },
      "message": "Call NewPoWValidBlock callbacks for all new blocks, not just !IBD\n\nThis pushes some \"is this callback useful\" logic down into\nnet_processing, which is useful for later changes as it allows for\nmore notifications to be used.",
      "tree": {
        "sha": "0dd8810f1ca40beb3dd39a9bb8320a139f0ebf36",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0dd8810f1ca40beb3dd39a9bb8320a139f0ebf36"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/489b1a3926ff241d2a1575bf8f2a22636967ffd5",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/489b1a3926ff241d2a1575bf8f2a22636967ffd5",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/489b1a3926ff241d2a1575bf8f2a22636967ffd5",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/489b1a3926ff241d2a1575bf8f2a22636967ffd5/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "dc7e41bd6fe77ca9d0bc8d14412660c885a5d74d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dc7e41bd6fe77ca9d0bc8d14412660c885a5d74d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/dc7e41bd6fe77ca9d0bc8d14412660c885a5d74d"
      }
    ],
    "stats": {
      "total": 32,
      "additions": 19,
      "deletions": 13
    },
    "files": [
      {
        "sha": "f1ba57ae274c83cf39772bb1c21c77c46b4feb71",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/489b1a3926ff241d2a1575bf8f2a22636967ffd5/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/489b1a3926ff241d2a1575bf8f2a22636967ffd5/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=489b1a3926ff241d2a1575bf8f2a22636967ffd5",
        "patch": "@@ -867,7 +867,10 @@ static std::shared_ptr<const CBlockHeaderAndShortTxIDs> most_recent_compact_bloc\n static uint256 most_recent_block_hash;\n static bool fWitnessesPresentInMostRecentCompactBlock;\n \n-void PeerLogicValidation::NewPoWValidBlock(const CBlockIndex *pindex, const std::shared_ptr<const CBlock>& pblock) {\n+void PeerLogicValidation::NewPoWValidBlock(const CBlockIndex *pindex, const std::shared_ptr<const CBlock>& pblock, bool fNewCandidateTip) {\n+    if (!fNewCandidateTip || IsInitialBlockDownload())\n+        return;\n+\n     std::shared_ptr<const CBlockHeaderAndShortTxIDs> pcmpctblock = std::make_shared<const CBlockHeaderAndShortTxIDs> (*pblock, true);\n     const CNetMsgMaker msgMaker(PROTOCOL_VERSION);\n "
      },
      {
        "sha": "248514992a9946bcf8a4030626b7be7bdc4b75b5",
        "filename": "src/net_processing.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/489b1a3926ff241d2a1575bf8f2a22636967ffd5/src/net_processing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/489b1a3926ff241d2a1575bf8f2a22636967ffd5/src/net_processing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.h?ref=489b1a3926ff241d2a1575bf8f2a22636967ffd5",
        "patch": "@@ -45,7 +45,7 @@ class PeerLogicValidation : public CValidationInterface, public NetEventsInterfa\n     void BlockConnected(const std::shared_ptr<const CBlock>& pblock, const CBlockIndex* pindexConnected, const std::vector<CTransactionRef>& vtxConflicted) override;\n     void UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload) override;\n     void BlockChecked(const CBlock& block, const CValidationState& state) override;\n-    void NewPoWValidBlock(const CBlockIndex *pindex, const std::shared_ptr<const CBlock>& pblock) override;\n+    void NewPoWValidBlock(const CBlockIndex *pindex, const std::shared_ptr<const CBlock>& pblock, bool fNewCandidateTip) override;\n \n \n     void InitializeNode(CNode* pnode) override;"
      },
      {
        "sha": "5ec3115da14ac2885c4be6c0dfff79fbac617aaa",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/489b1a3926ff241d2a1575bf8f2a22636967ffd5/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/489b1a3926ff241d2a1575bf8f2a22636967ffd5/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=489b1a3926ff241d2a1575bf8f2a22636967ffd5",
        "patch": "@@ -3234,9 +3234,7 @@ static bool AcceptBlock(const std::shared_ptr<const CBlock>& pblock, CValidation\n     }\n \n     // Header is valid/has work, merkle tree and segwit merkle tree are good...RELAY NOW\n-    // (but if it does not build on our best tip, let the SendMessages loop relay it)\n-    if (!IsInitialBlockDownload() && chainActive.Tip() == pindex->pprev)\n-        GetMainSignals().NewPoWValidBlock(pindex, pblock);\n+    GetMainSignals().NewPoWValidBlock(pindex, pblock, chainActive.Tip() == pindex->pprev);\n \n     int nHeight = pindex->nHeight;\n "
      },
      {
        "sha": "67f3656dad8b14241ca315e8985f50ef6ed5ea49",
        "filename": "src/validationinterface.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/489b1a3926ff241d2a1575bf8f2a22636967ffd5/src/validationinterface.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/489b1a3926ff241d2a1575bf8f2a22636967ffd5/src/validationinterface.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validationinterface.cpp?ref=489b1a3926ff241d2a1575bf8f2a22636967ffd5",
        "patch": "@@ -27,7 +27,7 @@ struct MainSignalsInstance {\n     boost::signals2::signal<void (const uint256 &)> Inventory;\n     boost::signals2::signal<void (int64_t nBestBlockTime, CConnman* connman)> Broadcast;\n     boost::signals2::signal<void (const CBlock&, const CValidationState&)> BlockChecked;\n-    boost::signals2::signal<void (const CBlockIndex *, const std::shared_ptr<const CBlock>&)> NewPoWValidBlock;\n+    boost::signals2::signal<void (const CBlockIndex *, const std::shared_ptr<const CBlock>&, bool)> NewPoWValidBlock;\n \n     // We are not allowed to assume the scheduler only runs in one thread,\n     // but must ensure all callbacks happen in-order, so we end up creating\n@@ -75,7 +75,7 @@ void RegisterValidationInterface(CValidationInterface* pwalletIn) {\n     g_signals.m_internals->Inventory.connect(boost::bind(&CValidationInterface::Inventory, pwalletIn, _1));\n     g_signals.m_internals->Broadcast.connect(boost::bind(&CValidationInterface::ResendWalletTransactions, pwalletIn, _1, _2));\n     g_signals.m_internals->BlockChecked.connect(boost::bind(&CValidationInterface::BlockChecked, pwalletIn, _1, _2));\n-    g_signals.m_internals->NewPoWValidBlock.connect(boost::bind(&CValidationInterface::NewPoWValidBlock, pwalletIn, _1, _2));\n+    g_signals.m_internals->NewPoWValidBlock.connect(boost::bind(&CValidationInterface::NewPoWValidBlock, pwalletIn, _1, _2, _3));\n }\n \n void UnregisterValidationInterface(CValidationInterface* pwalletIn) {\n@@ -88,7 +88,7 @@ void UnregisterValidationInterface(CValidationInterface* pwalletIn) {\n     g_signals.m_internals->BlockDisconnected.disconnect(boost::bind(&CValidationInterface::BlockDisconnected, pwalletIn, _1));\n     g_signals.m_internals->TransactionRemovedFromMempool.disconnect(boost::bind(&CValidationInterface::TransactionRemovedFromMempool, pwalletIn, _1));\n     g_signals.m_internals->UpdatedBlockTip.disconnect(boost::bind(&CValidationInterface::UpdatedBlockTip, pwalletIn, _1, _2, _3));\n-    g_signals.m_internals->NewPoWValidBlock.disconnect(boost::bind(&CValidationInterface::NewPoWValidBlock, pwalletIn, _1, _2));\n+    g_signals.m_internals->NewPoWValidBlock.disconnect(boost::bind(&CValidationInterface::NewPoWValidBlock, pwalletIn, _1, _2, _3));\n }\n \n void UnregisterAllValidationInterfaces() {\n@@ -160,6 +160,6 @@ void CMainSignals::BlockChecked(const CBlock& block, const CValidationState& sta\n     m_internals->BlockChecked(block, state);\n }\n \n-void CMainSignals::NewPoWValidBlock(const CBlockIndex *pindex, const std::shared_ptr<const CBlock> &block) {\n-    m_internals->NewPoWValidBlock(pindex, block);\n+void CMainSignals::NewPoWValidBlock(const CBlockIndex *pindex, const std::shared_ptr<const CBlock> &block, bool fNewCandidateTip) {\n+    m_internals->NewPoWValidBlock(pindex, block, fNewCandidateTip);\n }"
      },
      {
        "sha": "03f4d7f2bd3dc04c3feb507f0aa5b4ddc815aa73",
        "filename": "src/validationinterface.h",
        "status": "modified",
        "additions": 8,
        "deletions": 3,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/489b1a3926ff241d2a1575bf8f2a22636967ffd5/src/validationinterface.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/489b1a3926ff241d2a1575bf8f2a22636967ffd5/src/validationinterface.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validationinterface.h?ref=489b1a3926ff241d2a1575bf8f2a22636967ffd5",
        "patch": "@@ -104,8 +104,13 @@ class CValidationInterface {\n     virtual void BlockChecked(const CBlock&, const CValidationState&) {}\n     /**\n      * Notifies listeners that a block which builds directly on our current tip\n-     * has been received and connected to the headers tree, though not validated yet */\n-    virtual void NewPoWValidBlock(const CBlockIndex *pindex, const std::shared_ptr<const CBlock>& block) {};\n+     * has been received and connected to the headers tree, though not validated yet.\n+     * If the new block builds on the current best tip, the final bool argument is\n+     * set to true, otherwise it is false.\n+     * Consider if you need an IsInitialBlockDownload check in your client (and note\n+     * that any such calls will be racy wrt the state when the callback was generated)\n+     * */\n+    virtual void NewPoWValidBlock(const CBlockIndex *pindex, const std::shared_ptr<const CBlock>& block, bool fNewCandidateTip) {};\n     friend void ::RegisterValidationInterface(CValidationInterface*);\n     friend void ::UnregisterValidationInterface(CValidationInterface*);\n     friend void ::UnregisterAllValidationInterfaces();\n@@ -144,7 +149,7 @@ class CMainSignals {\n     void Inventory(const uint256 &);\n     void Broadcast(int64_t nBestBlockTime, CConnman* connman);\n     void BlockChecked(const CBlock&, const CValidationState&);\n-    void NewPoWValidBlock(const CBlockIndex *, const std::shared_ptr<const CBlock>&);\n+    void NewPoWValidBlock(const CBlockIndex *, const std::shared_ptr<const CBlock>&, bool);\n };\n \n CMainSignals& GetMainSignals();"
      }
    ]
  },
  {
    "sha": "c133cfeb9b3cb9da692bab70118d8e74c5ec4f88",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjMTMzY2ZlYjliM2NiOWRhNjkyYmFiNzAxMThkOGU3NGM1ZWM0Zjg4",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-06-06T20:16:58Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2018-01-11T18:52:22Z"
      },
      "message": "MarkBlockAsReceived on NewPoWValidBlock at receive.\n\nThe received block could be malleated, so this is both simpler, and\nsupports parallel downloads.",
      "tree": {
        "sha": "de85221209f34795b169152072dea30614e6039e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/de85221209f34795b169152072dea30614e6039e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c133cfeb9b3cb9da692bab70118d8e74c5ec4f88",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c133cfeb9b3cb9da692bab70118d8e74c5ec4f88",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c133cfeb9b3cb9da692bab70118d8e74c5ec4f88",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c133cfeb9b3cb9da692bab70118d8e74c5ec4f88/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "489b1a3926ff241d2a1575bf8f2a22636967ffd5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/489b1a3926ff241d2a1575bf8f2a22636967ffd5",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/489b1a3926ff241d2a1575bf8f2a22636967ffd5"
      }
    ],
    "stats": {
      "total": 19,
      "additions": 8,
      "deletions": 11
    },
    "files": [
      {
        "sha": "4a56163cbf57dba8eee556c44d93248bf4eca303",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 11,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c133cfeb9b3cb9da692bab70118d8e74c5ec4f88/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c133cfeb9b3cb9da692bab70118d8e74c5ec4f88/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=c133cfeb9b3cb9da692bab70118d8e74c5ec4f88",
        "patch": "@@ -345,9 +345,9 @@ static void MarkBlockAsNotInFlight(const uint256& hash, NodeId nodeid, bool clea\n     }\n }\n \n-// Requires cs_main.\n // Returns a bool indicating whether we requested this block.\n bool MarkBlockAsReceived(const uint256& hash) {\n+    LOCK(cs_main);\n     std::pair<BlockDownloadMap::iterator, BlockDownloadMap::iterator> range = mmapBlocksInFlight.equal_range(hash);\n     if (range.first == range.second) return false;\n     while (range.first != range.second) {\n@@ -868,6 +868,9 @@ static uint256 most_recent_block_hash;\n static bool fWitnessesPresentInMostRecentCompactBlock;\n \n void PeerLogicValidation::NewPoWValidBlock(const CBlockIndex *pindex, const std::shared_ptr<const CBlock>& pblock, bool fNewCandidateTip) {\n+    // The block was received in non-malleated form (and is/will be stored on disk).\n+    // We can consider all in-flight requests completed\n+    MarkBlockAsReceived(pindex->GetBlockHash());\n     if (!fNewCandidateTip || IsInitialBlockDownload())\n         return;\n \n@@ -2499,16 +2502,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 LOCK(cs_main);\n                 mapBlockSource.erase(pblock->GetHash());\n             }\n-            LOCK(cs_main); // hold cs_main for CBlockIndex::IsValid()\n-            if (pindex->IsValid(BLOCK_VALID_TRANSACTIONS)) {\n-                // Clear download state for this block, which is in\n-                // process from some other peer.  We do this after calling\n-                // ProcessNewBlock so that a malleated cmpctblock announcement\n-                // can't be used to interfere with block relay.\n-                MarkBlockAsReceived(pblock->GetHash());\n-            }\n         }\n-\n     }\n \n     else if (strCommand == NetMsgType::BLOCKTXN && !fImporting && !fReindex) // Ignore blocks received while importing\n@@ -2635,7 +2629,10 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             LOCK(cs_main);\n             // Also always process if we requested the block explicitly, as we may\n             // need it even though it is not a candidate for a new best tip.\n-            forceProcessing |= MarkBlockAsReceived(hash);\n+            // TODO: Only process if requested from this peer?\n+            forceProcessing |= mmapBlocksInFlight.count(hash);\n+            // Block is no longer in flight from this peer\n+            MarkBlockAsNotInFlight(hash, pfrom->GetId());\n             // mapBlockSource is only used for sending reject messages and DoS scores,\n             // so the race between here and cs_main in ProcessNewBlock is fine.\n             mapBlockSource.emplace(hash, std::make_pair(pfrom->GetId(), true));"
      }
    ]
  },
  {
    "sha": "a63474546943ef857554adb68c8c0b23e3a24f88",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphNjM0NzQ1NDY5NDNlZjg1NzU1NGFkYjY4YzhjMGIyM2UzYTI0Zjg4",
    "commit": {
      "author": {
        "name": "Alex Morcos",
        "email": "morcos@chaincode.com",
        "date": "2016-12-29T22:23:07Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2018-01-11T18:52:23Z"
      },
      "message": "Only request full blocks from the peer we thought had the block in-flight\n\nThis is a change in behavior so that if for some reason we request a block from a peer, we don't allow an unsolicited CMPCT_BLOCK announcement for that same block to cause a request for a full block from the uninvited peer (as some type of request is already outstanding from the original peer)",
      "tree": {
        "sha": "3b34f5cdfb272cf1b6bac04244c175497ac1c78f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/3b34f5cdfb272cf1b6bac04244c175497ac1c78f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a63474546943ef857554adb68c8c0b23e3a24f88",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a63474546943ef857554adb68c8c0b23e3a24f88",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a63474546943ef857554adb68c8c0b23e3a24f88",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a63474546943ef857554adb68c8c0b23e3a24f88/comments",
    "author": {
      "login": "morcos",
      "id": 4360349,
      "node_id": "MDQ6VXNlcjQzNjAzNDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4360349?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morcos",
      "html_url": "https://github.com/morcos",
      "followers_url": "https://api.github.com/users/morcos/followers",
      "following_url": "https://api.github.com/users/morcos/following{/other_user}",
      "gists_url": "https://api.github.com/users/morcos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morcos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
      "organizations_url": "https://api.github.com/users/morcos/orgs",
      "repos_url": "https://api.github.com/users/morcos/repos",
      "events_url": "https://api.github.com/users/morcos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morcos/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c133cfeb9b3cb9da692bab70118d8e74c5ec4f88",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c133cfeb9b3cb9da692bab70118d8e74c5ec4f88",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c133cfeb9b3cb9da692bab70118d8e74c5ec4f88"
      }
    ],
    "stats": {
      "total": 6,
      "additions": 3,
      "deletions": 3
    },
    "files": [
      {
        "sha": "e6683566c61479ee00a4becbe857d0aa0cf27f24",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a63474546943ef857554adb68c8c0b23e3a24f88/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a63474546943ef857554adb68c8c0b23e3a24f88/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=a63474546943ef857554adb68c8c0b23e3a24f88",
        "patch": "@@ -2367,7 +2367,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n \n         if (pindex->nChainWork <= chainActive.Tip()->nChainWork || // We know something better\n                 pindex->nTx != 0) { // We had this block at some point, but pruned it\n-            if (fAlreadyInFlight) {\n+            if (fInFlightFromSamePeer) {\n                 // We requested this block for some reason, but our mempool will probably be useless\n                 // so we just grab the block via normal getdata\n                 std::vector<CInv> vInv(1);\n@@ -2378,7 +2378,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         }\n \n         // If we're not close to tip yet, give up and let parallel block fetch work its magic\n-        if (!fAlreadyInFlight && !CanDirectFetch(chainparams.GetConsensus()))\n+        if (!fInFlightFromSamePeer && !CanDirectFetch(chainparams.GetConsensus()))\n             return true;\n \n         if (IsWitnessEnabled(pindex->pprev, chainparams.GetConsensus()) && !nodestate->fSupportsDesiredCmpctVersion) {\n@@ -2452,7 +2452,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 }\n             }\n         } else {\n-            if (fAlreadyInFlight) {\n+            if (fInFlightFromSamePeer) {\n                 // We requested this block, but its far into the future, so our\n                 // mempool will probably be useless - request the block normally\n                 std::vector<CInv> vInv(1);"
      }
    ]
  },
  {
    "sha": "ee1e8a2507474cb97ef526a4af32c037d1ec50fb",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplZTFlOGEyNTA3NDc0Y2I5N2VmNTI2YTRhZjMyYzAzN2QxZWM1MGZi",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-09-27T21:03:08Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2018-01-11T18:52:23Z"
      },
      "message": "Allow up to 2 simultaneous downloads of the same block at once\n\n...as long as the second one uses compact blocks with no more than\n10 missing transactions",
      "tree": {
        "sha": "e95da90158c56ad9110348b8edb4680eecc3dcbf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e95da90158c56ad9110348b8edb4680eecc3dcbf"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ee1e8a2507474cb97ef526a4af32c037d1ec50fb",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ee1e8a2507474cb97ef526a4af32c037d1ec50fb",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ee1e8a2507474cb97ef526a4af32c037d1ec50fb",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ee1e8a2507474cb97ef526a4af32c037d1ec50fb/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a63474546943ef857554adb68c8c0b23e3a24f88",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a63474546943ef857554adb68c8c0b23e3a24f88",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a63474546943ef857554adb68c8c0b23e3a24f88"
      }
    ],
    "stats": {
      "total": 59,
      "additions": 46,
      "deletions": 13
    },
    "files": [
      {
        "sha": "b52dff31f5f18ada1c020e9b49ae703b17c1567d",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 41,
        "deletions": 13,
        "changes": 54,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ee1e8a2507474cb97ef526a4af32c037d1ec50fb/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ee1e8a2507474cb97ef526a4af32c037d1ec50fb/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=ee1e8a2507474cb97ef526a4af32c037d1ec50fb",
        "patch": "@@ -1382,7 +1382,8 @@ bool static ProcessHeadersMessage(CNode *pfrom, CConnman *connman, const std::ve\n         nodestate->nUnconnectingHeaders = 0;\n \n         assert(pindexLast);\n-        UpdateBlockAvailability(pfrom->GetId(), pindexLast->GetBlockHash());\n+        uint256 last_block_hash = pindexLast->GetBlockHash();\n+        UpdateBlockAvailability(pfrom->GetId(), last_block_hash);\n \n         // From here, pindexBestKnownBlock should be guaranteed to be non-null,\n         // because it is set in UpdateBlockAvailability. Some nullptr checks\n@@ -1401,6 +1402,16 @@ bool static ProcessHeadersMessage(CNode *pfrom, CConnman *connman, const std::ve\n         }\n \n         bool fCanDirectFetch = CanDirectFetch(chainparams.GetConsensus());\n+\n+        if (fCanDirectFetch && chainActive.Tip() == pindexLast->pprev && nodestate->fSupportsDesiredCmpctVersion &&\n+                mmapBlocksInFlight.count(last_block_hash) < MAX_CMPCTBLOCKS_INFLIGHT_PER_BLOCK) {\n+            // We're going to download one block, which will be our new best, using compact blocks, from this peer\n+            MarkBlockAsInFlight(pfrom->GetId(), last_block_hash, pindexLast);\n+            std::vector<CInv> vGetData = { CInv(MSG_CMPCT_BLOCK, last_block_hash) };\n+            connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, vGetData));\n+            return true;\n+        }\n+\n         // If this set of headers is valid and ends in a block with at least as\n         // much work as our tip, download as much as possible.\n         if (fCanDirectFetch && pindexLast->IsValid(BLOCK_VALID_TREE) && chainActive.Tip()->nChainWork <= pindexLast->nChainWork) {\n@@ -2357,13 +2368,14 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             return true;\n \n         std::pair<BlockDownloadMap::iterator, BlockDownloadMap::iterator> rangeInFlight = mmapBlocksInFlight.equal_range(pindex->GetBlockHash());\n-        bool fAlreadyInFlight = rangeInFlight.first != rangeInFlight.second;\n+        size_t already_in_flight = std::distance(rangeInFlight.first, rangeInFlight.second);\n         bool fInFlightFromSamePeer = false;\n         while (rangeInFlight.first != rangeInFlight.second) {\n             if (rangeInFlight.first->second.first == pfrom->GetId())\n                 fInFlightFromSamePeer = true;\n             rangeInFlight.first++;\n         }\n+        bool first_in_flight = !already_in_flight || fInFlightFromSamePeer; // Or NC, or OH, depending on where you live\n \n         if (pindex->nChainWork <= chainActive.Tip()->nChainWork || // We know something better\n                 pindex->nTx != 0) { // We had this block at some point, but pruned it\n@@ -2390,7 +2402,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         // We want to be a bit conservative just to be extra careful about DoS\n         // possibilities in compact block processing...\n         if (pindex->nHeight <= chainActive.Height() + 2) {\n-            if ((!fAlreadyInFlight && nodestate->nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) ||\n+            if ((already_in_flight < MAX_CMPCTBLOCKS_INFLIGHT_PER_BLOCK && nodestate->nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) ||\n                 fInFlightFromSamePeer) {\n                 std::list<QueuedBlock>::iterator *queuedBlockIt = nullptr;\n                 if (!MarkBlockAsInFlight(pfrom->GetId(), pindex->GetBlockHash(), pindex, &queuedBlockIt)) {\n@@ -2411,10 +2423,14 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                     LogPrintf(\"Peer %d sent us invalid compact block\\n\", pfrom->GetId());\n                     return true;\n                 } else if (status == READ_STATUS_FAILED) {\n-                    // Duplicate txindexes, the block is now in-flight, so just request it\n-                    std::vector<CInv> vInv(1);\n-                    vInv[0] = CInv(MSG_BLOCK | GetFetchFlags(pfrom), cmpctblock.header.GetHash());\n-                    connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, vInv));\n+                    if (first_in_flight) {\n+                        // Duplicate txindexes, the block is now in-flight, so just request it\n+                        std::vector<CInv> vInv(1);\n+                        vInv[0] = CInv(MSG_BLOCK | GetFetchFlags(pfrom), cmpctblock.header.GetHash());\n+                        connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, vInv));\n+                    } else {\n+                        MarkBlockAsNotInFlight(pindex->GetBlockHash(), pfrom->GetId());\n+                    }\n                     return true;\n                 }\n \n@@ -2430,8 +2446,12 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                     blockTxnMsg << txn;\n                     fProcessBLOCKTXN = true;\n                 } else {\n-                    req.blockhash = pindex->GetBlockHash();\n-                    connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETBLOCKTXN, req));\n+                    if (req.indexes.size() <= MAX_GETBLOCKTXN_TXN_AFTER_FIRST_IN_FLIGHT || first_in_flight) {\n+                        req.blockhash = pindex->GetBlockHash();\n+                        connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETBLOCKTXN, req));\n+                    } else {\n+                        MarkBlockAsNotInFlight(pindex->GetBlockHash(), pfrom->GetId());\n+                    }\n                 }\n             } else {\n                 // This block is either already in flight from a different\n@@ -2516,6 +2536,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             LOCK(cs_main);\n \n             bool expected_BLOCKTXN = false;\n+            bool first_in_flight = true;\n             std::pair<BlockDownloadMap::iterator, BlockDownloadMap::iterator> rangeInFlight = mmapBlocksInFlight.equal_range(resp.blockhash);\n             while (rangeInFlight.first != rangeInFlight.second) {\n                 if (rangeInFlight.first->second.first == pfrom->GetId()) {\n@@ -2524,6 +2545,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                     }\n                     break;\n                 }\n+                first_in_flight = false;\n                 rangeInFlight.first++;\n             }\n \n@@ -2540,10 +2562,16 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 LogPrintf(\"Peer %d sent us invalid compact block/non-matching block transactions\\n\", pfrom->GetId());\n                 return true;\n             } else if (status == READ_STATUS_FAILED) {\n-                // Might have collided, fall back to getdata now :(\n-                std::vector<CInv> invs;\n-                invs.push_back(CInv(MSG_BLOCK | GetFetchFlags(pfrom), resp.blockhash));\n-                connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, invs));\n+                if (first_in_flight) {\n+                    // Might have collided, fall back to getdata now :(\n+                    std::vector<CInv> invs;\n+                    invs.push_back(CInv(MSG_BLOCK | GetFetchFlags(pfrom), resp.blockhash));\n+                    connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, invs));\n+                } else {\n+                    MarkBlockAsNotInFlight(resp.blockhash, pfrom->GetId()); // Reset in-flight state in case of whitelist\n+                    LogPrintf(\"Peer %d sent us a compact block but it failed to reconstruct, waiting on first download to complete\\n\", pfrom->GetId());\n+                    return true;\n+                }\n             } else {\n                 // Block is either okay, or possibly we received\n                 // READ_STATUS_CHECKBLOCK_FAILED."
      },
      {
        "sha": "4d9c41becf1d2bfe82a1e947cc871624a3936a51",
        "filename": "src/net_processing.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ee1e8a2507474cb97ef526a4af32c037d1ec50fb/src/net_processing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ee1e8a2507474cb97ef526a4af32c037d1ec50fb/src/net_processing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.h?ref=ee1e8a2507474cb97ef526a4af32c037d1ec50fb",
        "patch": "@@ -10,6 +10,11 @@\n #include <validationinterface.h>\n #include <consensus/params.h>\n \n+\n+/** Maximum number of outstanding CMPCTBLOCK requests for the same block. */\n+static const unsigned int MAX_CMPCTBLOCKS_INFLIGHT_PER_BLOCK = 2;\n+/** Maximum number of missing transactions for a non-first getblocktxn request */\n+static const unsigned int MAX_GETBLOCKTXN_TXN_AFTER_FIRST_IN_FLIGHT = 10;\n /** Default for -maxorphantx, maximum number of orphan transactions kept in memory */\n static const unsigned int DEFAULT_MAX_ORPHAN_TRANSACTIONS = 100;\n /** Expiration time for orphan transactions in seconds */"
      }
    ]
  },
  {
    "sha": "8acd39abf659241c70d257c7517d179559cc6951",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4YWNkMzlhYmY2NTkyNDFjNzBkMjU3Yzc1MTdkMTc5NTU5Y2M2OTUx",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-08-14T16:09:47Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2018-01-11T18:52:23Z"
      },
      "message": "Add simple parallel compact block download test",
      "tree": {
        "sha": "5fa7468d0e71339439d13c631e2508741df050cd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5fa7468d0e71339439d13c631e2508741df050cd"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8acd39abf659241c70d257c7517d179559cc6951",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8acd39abf659241c70d257c7517d179559cc6951",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8acd39abf659241c70d257c7517d179559cc6951",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8acd39abf659241c70d257c7517d179559cc6951/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ee1e8a2507474cb97ef526a4af32c037d1ec50fb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ee1e8a2507474cb97ef526a4af32c037d1ec50fb",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ee1e8a2507474cb97ef526a4af32c037d1ec50fb"
      }
    ],
    "stats": {
      "total": 71,
      "additions": 68,
      "deletions": 3
    },
    "files": [
      {
        "sha": "cf4c09ebd40a76e9d004a1f377c6fff8030249d3",
        "filename": "test/functional/p2p-compactblocks.py",
        "status": "modified",
        "additions": 68,
        "deletions": 3,
        "changes": 71,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8acd39abf659241c70d257c7517d179559cc6951/test/functional/p2p-compactblocks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8acd39abf659241c70d257c7517d179559cc6951/test/functional/p2p-compactblocks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-compactblocks.py?ref=8acd39abf659241c70d257c7517d179559cc6951",
        "patch": "@@ -14,6 +14,11 @@\n from test_framework.blocktools import create_block, create_coinbase, add_witness_commitment\n from test_framework.script import CScript, OP_TRUE\n \n+# Maximum number of parallel compact-blocks-in-flight bitcoind allows\n+MAX_CMPCTBLOCKS_INFLIGHT_PER_BLOCK = 2\n+# Maximum number of missing txn in a compact block for parallel downloads\n+MAX_GETBLOCKTXN_TXN_AFTER_FIRST_IN_FLIGHT = 10\n+\n # TestNode: A peer we use to send messages to bitcoind, and store responses.\n class TestNode(NodeConnCB):\n     def __init__(self):\n@@ -737,7 +742,7 @@ def request_cb_announcements(self, peer, node, version):\n         msg.announce = True\n         peer.send_and_ping(msg)\n \n-    def test_compactblock_reconstruction_multiple_peers(self, node, stalling_peer, delivery_peer):\n+    def test_compactblock_reconstruction_stalling_peer(self, node, stalling_peer, delivery_peer):\n         assert(len(self.utxos))\n \n         def announce_cmpct_block(node, peer):\n@@ -786,6 +791,63 @@ def announce_cmpct_block(node, peer):\n         stalling_peer.send_and_ping(msg)\n         assert_equal(int(node.getbestblockhash(), 16), block.sha256)\n \n+    def test_compactblock_reconstruction_parallel_reconstruction(self, node, stalling_peer, delivery_peer):\n+        assert(len(self.utxos))\n+\n+        def announce_cmpct_block(node, peer, txn_count):\n+            utxo = self.utxos.pop(0)\n+            block = self.build_block_with_transactions(node, utxo, txn_count)\n+\n+            cmpct_block = HeaderAndShortIDs()\n+            cmpct_block.initialize_from_block(block)\n+            msg = msg_cmpctblock(cmpct_block.to_p2p())\n+            peer.send_and_ping(msg)\n+            with mininode_lock:\n+                assert \"getblocktxn\" in peer.last_message\n+            return block, cmpct_block\n+\n+        # Test the simple parallel download case...\n+        block, cmpct_block = announce_cmpct_block(node, stalling_peer, MAX_GETBLOCKTXN_TXN_AFTER_FIRST_IN_FLIGHT)\n+\n+        delivery_peer.send_and_ping(msg_cmpctblock(cmpct_block.to_p2p()))\n+        with mininode_lock:\n+            # The second peer to announce should still get a getblocktxn\n+            assert \"getblocktxn\" in delivery_peer.last_message\n+        assert(int(node.getbestblockhash(), 16) != block.sha256)\n+\n+        msg = msg_blocktxn()\n+        msg.block_transactions.blockhash = block.sha256\n+        msg.block_transactions.transactions = block.vtx[1:]\n+        delivery_peer.send_and_ping(msg)\n+        assert_equal(int(node.getbestblockhash(), 16), block.sha256)\n+\n+        # Nothing bad should happen if we get a late fill from the first peer...\n+        stalling_peer.send_and_ping(msg)\n+\n+        self.utxos.append([block.vtx[-1].sha256, 0, block.vtx[-1].vout[0].nValue])\n+\n+        # Now test that parallel downloads are not allowed if they would require too many transactions\n+        with mininode_lock:\n+            # We're gonna wanna check that stalling_peer didn't send us a getblocktxn in a second\n+            del stalling_peer.last_message[\"getblocktxn\"]\n+\n+        block, cmpct_block = announce_cmpct_block(node, delivery_peer, MAX_GETBLOCKTXN_TXN_AFTER_FIRST_IN_FLIGHT + 1)\n+\n+        stalling_peer.send_and_ping(msg_cmpctblock(cmpct_block.to_p2p()))\n+        with mininode_lock:\n+            # The second peer to announce should not get a getblocktxn this time\n+            assert \"getblocktxn\" not in stalling_peer.last_message\n+\n+        msg = msg_blocktxn()\n+        msg.block_transactions.blockhash = block.sha256\n+        msg.block_transactions.transactions = block.vtx[1:]\n+        stalling_peer.send_and_ping(msg)\n+\n+        assert(int(node.getbestblockhash(), 16) != block.sha256)\n+\n+        delivery_peer.send_and_ping(msg)\n+        assert_equal(int(node.getbestblockhash(), 16), block.sha256)\n+\n     def run_test(self):\n         # Setup the p2p connections and start up the network thread.\n         self.test_node = self.nodes[0].add_p2p_connection(TestNode())\n@@ -858,8 +920,11 @@ def run_test(self):\n         self.test_invalid_tx_in_compactblock(self.nodes[1], self.segwit_node, False)\n         self.test_invalid_tx_in_compactblock(self.nodes[1], self.old_node, False)\n \n-        self.log.info(\"Testing reconstructing compact blocks from all peers...\")\n-        self.test_compactblock_reconstruction_multiple_peers(self.nodes[1], self.segwit_node, self.old_node)\n+        self.log.info(\"Testing reconstructing compact blocks with a stalling peer...\")\n+        self.test_compactblock_reconstruction_stalling_peer(self.nodes[1], self.segwit_node, self.old_node)\n+\n+        self.log.info(\"Testing reconstructing compact blocks from multiple peers...\")\n+        self.test_compactblock_reconstruction_parallel_reconstruction(self.nodes[1], self.segwit_node, self.old_node)\n         sync_blocks(self.nodes)\n \n         # Advance to segwit activation"
      }
    ]
  }
]