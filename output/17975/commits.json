[
  {
    "sha": "af8ed9a0e8665d0e15c37e30e7533f9b88b999f9",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphZjhlZDlhMGU4NjY1ZDBlMTVjMzdlMzBlNzUzM2Y5Yjg4Yjk5OWY5",
    "commit": {
      "author": {
        "name": "James Chiang",
        "email": "james.chiangwu@gmail.com",
        "date": "2020-01-20T14:46:56Z"
      },
      "committer": {
        "name": "James Chiang",
        "email": "james.chiangwu@gmail.com",
        "date": "2020-03-14T13:52:31Z"
      },
      "message": "TestFramework: Add Miniscript property class\n\nProperty describes basic Miniscript types and properties. Class includes\nstring (de)serializers and property consistency checks.",
      "tree": {
        "sha": "e135b05b3123e2d7be4d26a023958eeb1dfdbb3c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e135b05b3123e2d7be4d26a023958eeb1dfdbb3c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/af8ed9a0e8665d0e15c37e30e7533f9b88b999f9",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/af8ed9a0e8665d0e15c37e30e7533f9b88b999f9",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/af8ed9a0e8665d0e15c37e30e7533f9b88b999f9",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/af8ed9a0e8665d0e15c37e30e7533f9b88b999f9/comments",
    "author": {
      "login": "jachiang",
      "id": 26572234,
      "node_id": "MDQ6VXNlcjI2NTcyMjM0",
      "avatar_url": "https://avatars.githubusercontent.com/u/26572234?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jachiang",
      "html_url": "https://github.com/jachiang",
      "followers_url": "https://api.github.com/users/jachiang/followers",
      "following_url": "https://api.github.com/users/jachiang/following{/other_user}",
      "gists_url": "https://api.github.com/users/jachiang/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jachiang/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jachiang/subscriptions",
      "organizations_url": "https://api.github.com/users/jachiang/orgs",
      "repos_url": "https://api.github.com/users/jachiang/repos",
      "events_url": "https://api.github.com/users/jachiang/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jachiang/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jachiang",
      "id": 26572234,
      "node_id": "MDQ6VXNlcjI2NTcyMjM0",
      "avatar_url": "https://avatars.githubusercontent.com/u/26572234?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jachiang",
      "html_url": "https://github.com/jachiang",
      "followers_url": "https://api.github.com/users/jachiang/followers",
      "following_url": "https://api.github.com/users/jachiang/following{/other_user}",
      "gists_url": "https://api.github.com/users/jachiang/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jachiang/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jachiang/subscriptions",
      "organizations_url": "https://api.github.com/users/jachiang/orgs",
      "repos_url": "https://api.github.com/users/jachiang/repos",
      "events_url": "https://api.github.com/users/jachiang/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jachiang/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7f8176a1ebd00679596971fd01012cf61743b826",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7f8176a1ebd00679596971fd01012cf61743b826",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7f8176a1ebd00679596971fd01012cf61743b826"
      }
    ],
    "stats": {
      "total": 68,
      "additions": 68,
      "deletions": 0
    },
    "files": [
      {
        "sha": "5c7dd0f2a799202b78bfaafddda83353af41a55e",
        "filename": "test/functional/test_framework/miniscript.py",
        "status": "added",
        "additions": 68,
        "deletions": 0,
        "changes": 68,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/af8ed9a0e8665d0e15c37e30e7533f9b88b999f9/test/functional/test_framework/miniscript.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/af8ed9a0e8665d0e15c37e30e7533f9b88b999f9/test/functional/test_framework/miniscript.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/miniscript.py?ref=af8ed9a0e8665d0e15c37e30e7533f9b88b999f9",
        "patch": "@@ -0,0 +1,68 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2020 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Classes and methods to encode and decode miniscripts\"\"\"\n+\n+\n+class Property:\n+    \"\"\"Miniscript expression property\"\"\"\n+    # \"B\": Base type\n+    # \"V\": Verify type\n+    # \"K\": Key type\n+    # \"W\": Wrapped type\n+    # \"z\": Zero-arg property\n+    # \"o\": One-arg property\n+    # \"n\": Nonzero arg property\n+    # \"d\": Dissatisfiable property\n+    # \"u\": Unit property\n+    # \"e\": Expression property\n+    # \"f\": Forced property\n+    # \"s\": Safe property\n+    # \"m\": Nonmalleable property\n+    # \"x\": Expensive verify\n+    types = \"BVKW\"\n+    props = \"zonduefsmx\"\n+\n+    def __init__(self):\n+        for literal in self.types+self.props:\n+            setattr(self, literal, False)\n+\n+    def from_string(self, property_str):\n+        \"\"\"Construct property from string of valid property and types\"\"\"\n+        for char in property_str:\n+            assert(hasattr(self, char))\n+            setattr(self, char, True)\n+        assert self.is_valid()\n+        return self\n+\n+    def to_string(self):\n+        \"\"\"Generate string representation of property\"\"\"\n+        property_str = \"\"\n+        for char in self.types+self.props:\n+            if getattr(self, char):\n+                property_str += char\n+        return property_str\n+\n+    def is_valid(self):\n+        # Can only be of a single type.\n+        num_types = 0\n+        for typ in self.types:\n+            if getattr(self, typ):\n+                num_types += 1\n+        assert num_types == 1\n+\n+        # Check for conflicts in type & properties.\n+        return \\\n+            (not self.z or not self.o) and \\\n+            (not self.n or not self.z) and \\\n+            (not self.V or not self.d) and \\\n+            (not self.K or self.u) and \\\n+            (not self.V or not self.u) and \\\n+            (not self.e or not self.f) and \\\n+            (not self.e or self.d) and \\\n+            (not self.V or not self.e) and \\\n+            (not self.d or not self.f) and \\\n+            (not self.V or self.f) and \\\n+            (not self.K or self.s) and \\\n+            (not self.z or self.m)"
      }
    ]
  },
  {
    "sha": "63197b30175885f4286c77e181606255d5ae816e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2MzE5N2IzMDE3NTg4NWY0Mjg2Yzc3ZTE4MTYwNjI1NWQ1YWU4MTZl",
    "commit": {
      "author": {
        "name": "James Chiang",
        "email": "james.chiangwu@gmail.com",
        "date": "2020-01-20T14:48:09Z"
      },
      "committer": {
        "name": "James Chiang",
        "email": "james.chiangwu@gmail.com",
        "date": "2020-03-14T13:52:31Z"
      },
      "message": "TestFramework: Add Miniscript expression enum",
      "tree": {
        "sha": "96878fbb18dbf6e333edd58a23ac9ceffc0007b6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/96878fbb18dbf6e333edd58a23ac9ceffc0007b6"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/63197b30175885f4286c77e181606255d5ae816e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/63197b30175885f4286c77e181606255d5ae816e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/63197b30175885f4286c77e181606255d5ae816e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/63197b30175885f4286c77e181606255d5ae816e/comments",
    "author": {
      "login": "jachiang",
      "id": 26572234,
      "node_id": "MDQ6VXNlcjI2NTcyMjM0",
      "avatar_url": "https://avatars.githubusercontent.com/u/26572234?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jachiang",
      "html_url": "https://github.com/jachiang",
      "followers_url": "https://api.github.com/users/jachiang/followers",
      "following_url": "https://api.github.com/users/jachiang/following{/other_user}",
      "gists_url": "https://api.github.com/users/jachiang/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jachiang/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jachiang/subscriptions",
      "organizations_url": "https://api.github.com/users/jachiang/orgs",
      "repos_url": "https://api.github.com/users/jachiang/repos",
      "events_url": "https://api.github.com/users/jachiang/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jachiang/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jachiang",
      "id": 26572234,
      "node_id": "MDQ6VXNlcjI2NTcyMjM0",
      "avatar_url": "https://avatars.githubusercontent.com/u/26572234?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jachiang",
      "html_url": "https://github.com/jachiang",
      "followers_url": "https://api.github.com/users/jachiang/followers",
      "following_url": "https://api.github.com/users/jachiang/following{/other_user}",
      "gists_url": "https://api.github.com/users/jachiang/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jachiang/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jachiang/subscriptions",
      "organizations_url": "https://api.github.com/users/jachiang/orgs",
      "repos_url": "https://api.github.com/users/jachiang/repos",
      "events_url": "https://api.github.com/users/jachiang/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jachiang/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "af8ed9a0e8665d0e15c37e30e7533f9b88b999f9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/af8ed9a0e8665d0e15c37e30e7533f9b88b999f9",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/af8ed9a0e8665d0e15c37e30e7533f9b88b999f9"
      }
    ],
    "stats": {
      "total": 35,
      "additions": 35,
      "deletions": 0
    },
    "files": [
      {
        "sha": "23f31b818e89ee21229a354178a80343ea12f203",
        "filename": "test/functional/test_framework/miniscript.py",
        "status": "modified",
        "additions": 35,
        "deletions": 0,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/63197b30175885f4286c77e181606255d5ae816e/test/functional/test_framework/miniscript.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/63197b30175885f4286c77e181606255d5ae816e/test/functional/test_framework/miniscript.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/miniscript.py?ref=63197b30175885f4286c77e181606255d5ae816e",
        "patch": "@@ -4,6 +4,8 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Classes and methods to encode and decode miniscripts\"\"\"\n \n+from enum import Enum\n+\n \n class Property:\n     \"\"\"Miniscript expression property\"\"\"\n@@ -66,3 +68,36 @@ def is_valid(self):\n             (not self.V or self.f) and \\\n             (not self.K or self.s) and \\\n             (not self.z or self.m)\n+\n+\n+class NodeType(Enum):\n+    JUST_0 = 0\n+    JUST_1 = 1\n+    PK = 2\n+    PK_H = 3\n+    OLDER = 4\n+    AFTER = 5\n+    SHA256 = 6\n+    HASH256 = 7\n+    RIPEMD160 = 8\n+    HASH160 = 9\n+    WRAP_A = 10\n+    WRAP_S = 11\n+    WRAP_C = 12\n+    WRAP_T = 13\n+    WRAP_D = 14\n+    WRAP_V = 15\n+    WRAP_J = 16\n+    WRAP_N = 17\n+    WRAP_U = 18\n+    WRAP_L = 19\n+    AND_V = 20\n+    AND_B = 21\n+    AND_N = 22\n+    OR_B = 23\n+    OR_C = 24\n+    OR_D = 25\n+    OR_I = 26\n+    ANDOR = 27\n+    THRESH = 28\n+    THRESH_M = 29"
      }
    ]
  },
  {
    "sha": "a62393ad15103f9d5824d41fb2eed392a84dd66b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphNjIzOTNhZDE1MTAzZjlkNTgyNGQ0MWZiMmVlZDM5MmE4NGRkNjZi",
    "commit": {
      "author": {
        "name": "James Chiang",
        "email": "james.chiangwu@gmail.com",
        "date": "2020-01-20T14:57:32Z"
      },
      "committer": {
        "name": "James Chiang",
        "email": "james.chiangwu@gmail.com",
        "date": "2020-03-14T13:52:31Z"
      },
      "message": "TestFramework: Add Miniscript Node class\n\nAdds basic miniscript expression class for terminal expressions as\nwell as descriptor string and cscript (de)serializers. Support of\nexpression properties is added (Node.p.to_string()).",
      "tree": {
        "sha": "83bc36ce963341210282ee973b428d1c9d91ab49",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/83bc36ce963341210282ee973b428d1c9d91ab49"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a62393ad15103f9d5824d41fb2eed392a84dd66b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a62393ad15103f9d5824d41fb2eed392a84dd66b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a62393ad15103f9d5824d41fb2eed392a84dd66b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a62393ad15103f9d5824d41fb2eed392a84dd66b/comments",
    "author": {
      "login": "jachiang",
      "id": 26572234,
      "node_id": "MDQ6VXNlcjI2NTcyMjM0",
      "avatar_url": "https://avatars.githubusercontent.com/u/26572234?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jachiang",
      "html_url": "https://github.com/jachiang",
      "followers_url": "https://api.github.com/users/jachiang/followers",
      "following_url": "https://api.github.com/users/jachiang/following{/other_user}",
      "gists_url": "https://api.github.com/users/jachiang/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jachiang/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jachiang/subscriptions",
      "organizations_url": "https://api.github.com/users/jachiang/orgs",
      "repos_url": "https://api.github.com/users/jachiang/repos",
      "events_url": "https://api.github.com/users/jachiang/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jachiang/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jachiang",
      "id": 26572234,
      "node_id": "MDQ6VXNlcjI2NTcyMjM0",
      "avatar_url": "https://avatars.githubusercontent.com/u/26572234?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jachiang",
      "html_url": "https://github.com/jachiang",
      "followers_url": "https://api.github.com/users/jachiang/followers",
      "following_url": "https://api.github.com/users/jachiang/following{/other_user}",
      "gists_url": "https://api.github.com/users/jachiang/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jachiang/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jachiang/subscriptions",
      "organizations_url": "https://api.github.com/users/jachiang/orgs",
      "repos_url": "https://api.github.com/users/jachiang/repos",
      "events_url": "https://api.github.com/users/jachiang/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jachiang/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "63197b30175885f4286c77e181606255d5ae816e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/63197b30175885f4286c77e181606255d5ae816e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/63197b30175885f4286c77e181606255d5ae816e"
      }
    ],
    "stats": {
      "total": 588,
      "additions": 588,
      "deletions": 0
    },
    "files": [
      {
        "sha": "aac5ea2971c74e5fc62dd196149b8af1be95a08f",
        "filename": "test/functional/feature_miniscript.py",
        "status": "added",
        "additions": 117,
        "deletions": 0,
        "changes": 117,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a62393ad15103f9d5824d41fb2eed392a84dd66b/test/functional/feature_miniscript.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a62393ad15103f9d5824d41fb2eed392a84dd66b/test/functional/feature_miniscript.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_miniscript.py?ref=a62393ad15103f9d5824d41fb2eed392a84dd66b",
        "patch": "@@ -0,0 +1,117 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2020 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test miniscript implementation.\"\"\"\n+\n+from test_framework.key import ECKey\n+from test_framework.miniscript import Node\n+from test_framework.messages import hash256, sha256\n+from test_framework.script import hash160\n+from test_framework.test_framework import BitcoinTestFramework\n+\n+import hashlib\n+\n+\n+class MiniscriptTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.setup_clean_chain = True\n+\n+    def test_miniscript_expr(self, desc_str, property_str):\n+        node = Node.from_desc(desc_str)\n+        node_from_script = Node.from_script(node.script)\n+        assert(''.join(sorted(property_str)) ==\n+               ''.join(sorted(node.p.to_string()))\n+               )\n+        assert(node.desc == desc_str)\n+        assert(node_from_script.desc == node.desc)\n+        assert(node_from_script.script == node.script)\n+        return node\n+\n+    def generate_key_pair(self, keyhash_dict):\n+        privkey = ECKey()\n+        privkey.generate()\n+        pubkeyhash = hash160(privkey.get_pubkey().get_bytes())\n+        keyhash_dict[pubkeyhash] = privkey\n+\n+    def get_pubkey_hex_list(self, n, keyhash_dict):\n+        key_hex_list = []\n+        for pkh in list(keyhash_dict)[0:n]:\n+            pk_hex = keyhash_dict[pkh].get_pubkey().get_bytes().hex()\n+            key_hex_list.append(pk_hex)\n+        return key_hex_list\n+\n+    def run_test(self):\n+        # Generate key pairs.\n+        keyhash_dict = {}\n+        for i in range(5):\n+            self.generate_key_pair(keyhash_dict)\n+\n+        # Generate hashlocks.\n+        sha256_dict = {}\n+        hash256_dict = {}\n+        ripemd160_dict = {}\n+        hash160_dict = {}\n+        for i in range(5):\n+            secret = ECKey()\n+            secret.generate()\n+            sha256_dict[sha256(secret.get_bytes())] = secret.get_bytes()\n+            hash256_dict[hash256(secret.get_bytes())] = secret.get_bytes()\n+            ripemd160_dict[hashlib.new(\n+                'ripemd160', secret.get_bytes()).digest()] = secret.get_bytes()\n+            hash160_dict[hash160(secret.get_bytes())] = secret.get_bytes()\n+\n+        # Test (de)serialization of terminal expressions.\n+\n+        # pk(key)\n+        pk_hex = self.get_pubkey_hex_list(1, keyhash_dict)[0]\n+        desc0 = \"pk({})\".format(pk_hex)\n+        self.test_miniscript_expr(desc0, \"Konduesm\")\n+\n+        # pk_h(key)\n+        pkh = list(keyhash_dict)[0]\n+        desc1 = \"pk_h({})\".format(pkh.hex())\n+        self.test_miniscript_expr(desc1, \"Knduesm\")\n+\n+        # older(delay)\n+        delay = 20\n+        desc2 = \"older({})\".format(delay)\n+        self.test_miniscript_expr(desc2, \"Bzfm\")\n+\n+        # after(time)\n+        time = 21\n+        desc3 = \"after({})\".format(time)\n+        self.test_miniscript_expr(desc3, \"Bzfm\")\n+\n+        # sha256(h)\n+        sha256_digest = list(sha256_dict)[0]\n+        desc5 = \"sha256({})\".format(sha256_digest.hex())\n+        self.test_miniscript_expr(desc5, \"Bondum\")\n+\n+        # hash256(h)\n+        h256_digest = list(hash256_dict)[0]\n+        desc6 = \"hash256({})\".format(h256_digest.hex())\n+        self.test_miniscript_expr(desc6, \"Bondum\")\n+\n+        # ripemd160(h)\n+        ripemd160_digest = list(ripemd160_dict)[0]\n+        desc7 = \"ripemd160({})\".format(ripemd160_digest.hex())\n+        self.test_miniscript_expr(desc7, \"Bondum\")\n+\n+        # hash160(h)\n+        h160_digest = list(hash160_dict)[0]\n+        desc8 = \"hash160({})\".format(h160_digest.hex())\n+        self.test_miniscript_expr(desc8, \"Bondum\")\n+\n+        # thresh_m(k, pk, pk, ...)\n+        k = 2\n+        pk_hex_list = self.get_pubkey_hex_list(3, keyhash_dict)\n+        desc9 = (\"thresh_m({},{},{},{})\").format(k, pk_hex_list[0],\n+                                                 pk_hex_list[1],\n+                                                 pk_hex_list[2])\n+        self.test_miniscript_expr(desc9, \"Bnduesm\")\n+\n+\n+if __name__ == '__main__':\n+    MiniscriptTest().main()"
      },
      {
        "sha": "a76859d7131af00f85623c56f2754434c85437d6",
        "filename": "test/functional/test_framework/miniscript.py",
        "status": "modified",
        "additions": 471,
        "deletions": 0,
        "changes": 471,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a62393ad15103f9d5824d41fb2eed392a84dd66b/test/functional/test_framework/miniscript.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a62393ad15103f9d5824d41fb2eed392a84dd66b/test/functional/test_framework/miniscript.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/miniscript.py?ref=a62393ad15103f9d5824d41fb2eed392a84dd66b",
        "patch": "@@ -6,6 +6,13 @@\n \n from enum import Enum\n \n+from .key import ECPubKey\n+from .script import CScript, OP_ADD, OP_CHECKLOCKTIMEVERIFY, \\\n+    OP_CHECKSEQUENCEVERIFY, OP_CHECKMULTISIG, OP_CHECKSIG, \\\n+    OP_CHECKMULTISIGVERIFY, OP_CHECKSIGVERIFY, OP_DUP, OP_EQUAL, \\\n+    OP_EQUALVERIFY, OP_HASH160, OP_HASH256, OP_RIPEMD160, OP_SHA256, \\\n+    OP_SIZE, OP_VERIFY\n+\n \n class Property:\n     \"\"\"Miniscript expression property\"\"\"\n@@ -101,3 +108,467 @@ class NodeType(Enum):\n     ANDOR = 27\n     THRESH = 28\n     THRESH_M = 29\n+\n+\n+class Node:\n+    \"\"\"Miniscript expression class\n+\n+    Provides methods to instantiate a miniscript node from a string descriptor\n+    or script. Node.sat, Node.dsat, Node.sat_ncan and Node.dsat_ncan return a\n+    list of tuples which encode the (dis)satisfying witness stack.\n+    \"\"\"\n+\n+    def __init__(self):\n+        self.desc = ''\n+        self.children = None\n+        self.t = None\n+        self._sat = None\n+        self._k = None\n+        self._pk = []\n+        self._pk_h = None\n+\n+    @staticmethod\n+    def from_desc(string):\n+        \"\"\"Construct miniscript node from string descriptor\"\"\"\n+        tag, child_exprs = Node._parse_string(string)\n+        k = None\n+\n+        if tag == '0':\n+            return Node().construct_just_0()\n+\n+        if tag == '1':\n+            return Node().construct_just_1()\n+\n+        if tag == 'pk':\n+            key_b = bytes.fromhex(child_exprs[0])\n+            key_obj = ECPubKey()\n+            key_obj.set(key_b)\n+            return Node().construct_pk(key_obj)\n+\n+        if tag == 'pk_h':\n+            keyhash_b = bytes.fromhex(child_exprs[0])\n+            return Node().construct_pk_h(keyhash_b)\n+\n+        if tag == \"older\":\n+            n = int(child_exprs[0])\n+            return Node().construct_older(n)\n+\n+        if tag == \"after\":\n+            time = int(child_exprs[0])\n+            return Node().construct_after(time)\n+\n+        if tag in [\"sha256\", \"hash256\", \"ripemd160\", \"hash160\"]:\n+            hash_b = bytes.fromhex(child_exprs[0])\n+            return getattr(Node(), \"construct_\"+tag)(hash_b)\n+\n+        if tag == 'thresh_m':\n+            k = int(child_exprs.pop(0))\n+            key_n = []\n+            for child_expr in child_exprs:\n+                key_obj = ECPubKey()\n+                key_obj.set(bytes.fromhex(child_expr))\n+                key_n.append(key_obj)\n+            return Node().construct_thresh_m(k, key_n)\n+\n+        if tag == 'thresh':\n+            k = int(child_exprs.pop(0))\n+            return Node().construct_thresh(\n+                k, Node._parse_child_strings(child_exprs))\n+\n+        # Standard node constructor forms:\n+        # construct_tag(node_x, node_y, ...):\n+        return getattr(Node(), \"construct_\"+tag)(\n+                *Node._parse_child_strings(child_exprs))\n+\n+    @property\n+    def script(self):\n+        return CScript(Node._collapse_script(self._script))\n+\n+    @staticmethod\n+    def from_script(c_script):\n+        \"\"\"Construct miniscript node from script\"\"\"\n+        expr_list = []\n+        for op in c_script:\n+            # Encode 0, 20, 32 as int.\n+            # Other values are coerced to int types with Node._coerce_to_int()\n+            if op in [b'', b'\\x14', b'\\x20']:\n+                op_int = int.from_bytes(op, byteorder='big')\n+                expr_list.append(op_int)\n+            else:\n+                expr_list.append(op)\n+\n+        # Decompose script:\n+        # OP_CHECKSIGVERIFY > OP_CHECKSIG + OP_VERIFY\n+        # OP_CHECKMULTISIGVERIFY > OP_CHECKMULTISIG + OP_VERIFY\n+        # OP_EQUALVERIFY > OP_EQUAL + OP_VERIFY\n+        expr_list = Node._decompose_script(expr_list)\n+        expr_list_len = len(expr_list)\n+\n+        # Parse for terminal expressions.\n+        idx = 0\n+        while idx < expr_list_len:\n+\n+            # Match against pk(key).\n+            if isinstance(expr_list[idx], bytes) and \\\n+                    len(expr_list[idx]) == 33 and \\\n+                    expr_list[idx][0] in [2, 3]:\n+                key = ECPubKey()\n+                key.set(expr_list[idx])\n+                expr_list[idx] = Node().construct_pk(key)\n+\n+            # Match against just1.\n+            if expr_list[idx] == 1:\n+                expr_list[idx] = Node().construct_just_1()\n+\n+            # Match against just0.\n+            if expr_list[idx] == 0:\n+                expr_list[idx] = Node().construct_just_0()\n+\n+            # 2 element terminal expressions.\n+            if expr_list_len-idx >= 2:\n+                try:\n+                    # Timelock encoding n.\n+                    n_int = Node._coerce_to_int(expr_list[idx])\n+                    # Match against older.\n+                    if n_int >= 1 and \\\n+                            expr_list[idx+1] == OP_CHECKSEQUENCEVERIFY:\n+                        node = Node().construct_older(n_int)\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        expr_list_len -= 1\n+                    # Match against after.\n+                    elif n_int >= 1 and n_int <= 2**32 and \\\n+                            expr_list[idx+1] == OP_CHECKLOCKTIMEVERIFY:\n+                        node = Node().construct_after(n_int)\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        expr_list_len -= 1\n+                except Exception:\n+                    pass\n+\n+            # 4 element terminal expressions.\n+            if expr_list_len-idx >= 5:\n+\n+                # Match against pk_h(pkhash).\n+                if expr_list[idx:idx+2] == [OP_DUP, OP_HASH160] and \\\n+                        isinstance(expr_list[idx+2], bytes) and \\\n+                        len(expr_list[idx+2]) == 20 and \\\n+                        expr_list[idx+3:idx+5] == [OP_EQUAL, OP_VERIFY]:\n+                    node = Node().construct_pk_h(expr_list[idx+2])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                    # Reduce length of list after node construction.\n+                    expr_list_len -= 4\n+\n+            # 6 element terminal expressions.\n+            if expr_list_len-idx >= 7:\n+\n+                # Match against sha256.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_SHA256] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 32 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_sha256(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+                # Match against hash256.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_HASH256] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 32 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_hash256(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+                # Match against ripemd160.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_RIPEMD160] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 20 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_ripemd160(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+                # Match against hash160.\n+                if expr_list[idx:idx+5] == [OP_SIZE, 32, OP_EQUAL,\n+                                            OP_VERIFY, OP_HASH160] and \\\n+                        isinstance(expr_list[idx+5], bytes) and \\\n+                        len(expr_list[idx+5]) == 20 and \\\n+                        expr_list[idx+6] == OP_EQUAL:\n+                    node = Node().construct_hash160(expr_list[idx+5])\n+                    expr_list = expr_list[:idx]+[node]+expr_list[idx+7:]\n+                    expr_list_len -= 6\n+\n+            # Increment index.\n+            idx += 1\n+\n+        # Construct AST recursively.\n+        return Node._parse_expr_list(expr_list)\n+\n+    @staticmethod\n+    def _parse_expr_list(expr_list):\n+        # Every recursive call must progress the AST construction,\n+        # until it is complete (single root node remains).\n+        expr_list_len = len(expr_list)\n+\n+        # Root node reached.\n+        if expr_list_len == 1 and isinstance(expr_list[0], Node):\n+            return expr_list[0]\n+\n+        # Step through each list index and match against templates.\n+        idx = expr_list_len - 1\n+        while idx >= 0:\n+\n+            # Match against thresh_m.\n+            # Termainal expression, but k and n values can be Nodes (JUST_0/1)\n+            if expr_list_len-idx >= 5 and \\\n+                    ((\n+                    isinstance(expr_list[idx], int) and\n+                    expr_list_len-idx-3 >= expr_list[idx] >= 1\n+                    ) or (\n+                    isinstance(expr_list[idx], Node) and\n+                    expr_list[idx].t == NodeType.JUST_1\n+                    )):\n+                k = Node._coerce_to_int(expr_list[idx])\n+                # Permissible values for n:\n+                # len(expr)-3 >= n >= 1\n+                for n in range(k, expr_list_len-2):\n+                    # Match ... <PK>*n ...\n+                    match, pk_m = True, []\n+                    for i in range(n):\n+                        if not (isinstance(expr_list[idx+1+i], Node) and\n+                                expr_list[idx+1+i].t == NodeType.PK):\n+                            match = False\n+                            break\n+                        else:\n+                            key = ECPubKey()\n+                            key.set(expr_list[idx+1+i]._pk[0])\n+                            pk_m.append(key)\n+                    # Match ... <m> <OP_CHECKMULTISIG>\n+                    if match is True:\n+                        m = Node._coerce_to_int(expr_list[idx+n+1])\n+                        if isinstance(m, int) and m == len(pk_m) and \\\n+                                expr_list[idx+n+2] == OP_CHECKMULTISIG:\n+                            try:\n+                                node = Node().construct_thresh_m(k, pk_m)\n+                                expr_list = expr_list[:idx] + [node] + \\\n+                                    expr_list[idx+n+3:]\n+                                return Node._parse_expr_list(expr_list)\n+                            except Exception:\n+                                pass\n+\n+            # Right-to-left parsing.\n+            # Step one position left.\n+            idx -= 1\n+\n+        # No match found.\n+        raise Exception(\"Malformed miniscript\")\n+\n+    def construct_just_1(self):\n+        self._construct(NodeType.JUST_1, Property().from_string(\"Bzufm\"),\n+                        [],\n+                        [1], '1')\n+        return self\n+\n+    def construct_just_0(self):\n+        self._construct(NodeType.JUST_0, Property().from_string(\"Bzudems\"),\n+                        [],\n+                        [0], '0')\n+        return self\n+\n+    def construct_pk(self, pubkey):\n+        assert isinstance(pubkey, ECPubKey) and pubkey.is_valid\n+        self._pk = [pubkey.get_bytes()]\n+        self._construct(NodeType.PK, Property().from_string(\"Konudems\"),\n+                        [],\n+                        [pubkey.get_bytes()], 'pk('+self._pk[0].hex()+')'\n+                        )\n+        return self\n+\n+    def construct_pk_h(self, pk_hash_digest):\n+        assert isinstance(pk_hash_digest, bytes) and len(pk_hash_digest) == 20\n+        self._pk_h = pk_hash_digest\n+        self._construct(NodeType.PK_H, Property().from_string(\"Knudems\"),\n+                        [],\n+                        [OP_DUP, OP_HASH160, pk_hash_digest, OP_EQUALVERIFY],\n+                        'pk_h('+pk_hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_older(self, delay):\n+        assert delay >= 1\n+        self._delay = delay\n+        self._construct(NodeType.OLDER, Property().from_string(\"Bzfm\"),\n+                        [],\n+                        [delay, OP_CHECKSEQUENCEVERIFY],\n+                        'older('+str(delay)+')'\n+                        )\n+        return self\n+\n+    def construct_after(self, time):\n+        assert time >= 1 and time < 2**31\n+        self._time = time\n+        self._construct(NodeType.AFTER, Property().from_string(\"Bzfm\"),\n+                        [],\n+                        [time, OP_CHECKLOCKTIMEVERIFY],\n+                        'after('+str(time)+')'\n+                        )\n+        return self\n+\n+    def construct_sha256(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 32\n+        self._sha256 = hash_digest\n+        self._construct(NodeType.SHA256, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_SHA256, hash_digest, OP_EQUAL],\n+                        'sha256('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_hash256(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 32\n+        self._hash256 = hash_digest\n+        self._construct(NodeType.HASH256, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_HASH256, hash_digest, OP_EQUAL],\n+                        'hash256('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_ripemd160(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 20\n+        self._ripemd160 = hash_digest\n+        self._construct(NodeType.RIPEMD160, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_RIPEMD160, hash_digest, OP_EQUAL],\n+                        'ripemd160('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_hash160(self, hash_digest):\n+        assert isinstance(hash_digest, bytes) and len(hash_digest) == 20\n+        self._hash160 = hash_digest\n+        self._construct(NodeType.HASH160, Property().from_string(\"Bonudm\"),\n+                        [],\n+                        [OP_SIZE, 32, OP_EQUALVERIFY,\n+                         OP_HASH160, hash_digest, OP_EQUAL],\n+                        'hash160('+hash_digest.hex()+')'\n+                        )\n+        return self\n+\n+    def construct_thresh_m(self, k, keys_n):\n+        self._k = k\n+        n = len(keys_n)\n+        assert n >= k >= 1\n+        prop_str = \"Bnudems\"\n+        self._pk_n = [key.get_bytes() for key in keys_n]\n+        desc = \"thresh_m(\"+str(k)+\",\"\n+        for idx, key_b in enumerate(self._pk_n):\n+            desc += key_b.hex()\n+            desc += \",\" if idx != (n-1) else \")\"\n+        self._construct(NodeType.THRESH_M, Property().from_string(prop_str),\n+                        [],\n+                        [k, *self._pk_n, n, OP_CHECKMULTISIG], desc\n+                        )\n+        return self\n+\n+    def _construct(self,\n+                   node_type, node_prop,\n+                   children,\n+                   script, desc):\n+        self.t = node_type\n+        self.p = node_prop\n+        self.children = children\n+        self._script = script\n+        self.desc = desc\n+\n+    # Utility methods.\n+    @staticmethod\n+    def _coerce_to_int(expr):\n+        # Coerce expression to int when iterating through CScript expressions\n+        # after terminal expressions have been parsed.\n+        if isinstance(expr, bytes):\n+            op_int = int.from_bytes(expr, byteorder=\"big\")\n+        elif isinstance(expr, Node) and expr.t == NodeType.JUST_0:\n+            op_int = 0\n+        elif isinstance(expr, Node) and expr.t == NodeType.JUST_1:\n+            op_int = 1\n+        else:\n+            op_int = expr\n+        return op_int\n+\n+    @staticmethod\n+    def _parse_child_strings(child_exprs):\n+        child_nodes = []\n+        for string in child_exprs:\n+            child_nodes.append(Node.from_desc(string))\n+        return child_nodes\n+\n+    @staticmethod\n+    def _parse_string(string):\n+        string = ''.join(string.split())\n+        tag = ''\n+        child_exprs = []\n+        depth = 0\n+\n+        for idx, ch in enumerate(string):\n+            if (ch == '0' or ch == '1') and len(string) == 1:\n+                return ch, child_exprs\n+            if ch == ':' and depth == 0:\n+                # Discern between 1 or two wrappers.\n+                if idx == 1:\n+                    return string[0], [string[2:]]\n+                else:\n+                    return string[0], [string[1:]]\n+            if ch == '(':\n+                depth += 1\n+                if depth == 1:\n+                    tag = string[:idx]\n+                    prev_idx = idx\n+            if ch == ')':\n+                depth -= 1\n+                if depth == 0:\n+                    child_exprs.append(string[prev_idx+1:idx])\n+            if ch == ',' and depth == 1:\n+                child_exprs.append(string[prev_idx+1:idx])\n+                prev_idx = idx\n+        if depth == 0 and bool(tag) and bool(child_exprs):\n+            return tag, child_exprs\n+        else:\n+            raise Exception('Malformed miniscript string.')\n+\n+    @staticmethod\n+    def _decompose_script(expr_list):\n+        idx = 0\n+        while idx < len(expr_list):\n+            if expr_list[idx] == OP_CHECKSIGVERIFY:\n+                expr_list = expr_list[:idx]+[OP_CHECKSIG, OP_VERIFY]+expr_list[\n+                    idx+1:]\n+            elif expr_list[idx] == OP_CHECKMULTISIGVERIFY:\n+                expr_list = expr_list[:idx]+[OP_CHECKMULTISIG, OP_VERIFY] + \\\n+                    expr_list[idx+1:]\n+            elif expr_list[idx] == OP_EQUALVERIFY:\n+                expr_list = expr_list[:idx]+[OP_EQUAL, OP_VERIFY]+expr_list[\n+                    idx+1:]\n+            idx += 1\n+        return expr_list\n+\n+    @staticmethod\n+    def _collapse_script(expr_list):\n+        idx = 0\n+        while idx < len(expr_list):\n+            if expr_list[idx:idx+1] == [OP_CHECKSIG, OP_VERIFY]:\n+                expr_list = expr_list[:idx]+[OP_CHECKSIGVERIFY]+expr_list[\n+                    idx+2:]\n+            elif expr_list[idx:idx+1] == [OP_CHECKMULTISIG, OP_VERIFY]:\n+                expr_list = expr_list[:idx]+[OP_CHECKMULTISIGVERIFY] + \\\n+                    expr_list[idx+2:]\n+            elif expr_list[idx:idx+1] == [OP_EQUAL, OP_VERIFY]:\n+                expr_list = expr_list[:idx]+[OP_EQUALVERIFY]+expr_list[\n+                    idx+2:]\n+            idx += 1\n+        return expr_list"
      }
    ]
  },
  {
    "sha": "a85d9c9b74af95da6a8f63e3ed15c3b6fd284c2e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphODVkOWM5Yjc0YWY5NWRhNmE4ZjYzZTNlZDE1YzNiNmZkMjg0YzJl",
    "commit": {
      "author": {
        "name": "James Chiang",
        "email": "james.chiangwu@gmail.com",
        "date": "2020-01-20T16:14:33Z"
      },
      "committer": {
        "name": "James Chiang",
        "email": "james.chiangwu@gmail.com",
        "date": "2020-03-14T13:52:31Z"
      },
      "message": "TestFramework: Add non-terminal Miniscript exprs\n\nAdds non-terminal miniscript expressions, which inherit properties from\nits children.",
      "tree": {
        "sha": "83ab22bdb5582541eed094009e279752b9f28fe7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/83ab22bdb5582541eed094009e279752b9f28fe7"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a85d9c9b74af95da6a8f63e3ed15c3b6fd284c2e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a85d9c9b74af95da6a8f63e3ed15c3b6fd284c2e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a85d9c9b74af95da6a8f63e3ed15c3b6fd284c2e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a85d9c9b74af95da6a8f63e3ed15c3b6fd284c2e/comments",
    "author": {
      "login": "jachiang",
      "id": 26572234,
      "node_id": "MDQ6VXNlcjI2NTcyMjM0",
      "avatar_url": "https://avatars.githubusercontent.com/u/26572234?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jachiang",
      "html_url": "https://github.com/jachiang",
      "followers_url": "https://api.github.com/users/jachiang/followers",
      "following_url": "https://api.github.com/users/jachiang/following{/other_user}",
      "gists_url": "https://api.github.com/users/jachiang/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jachiang/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jachiang/subscriptions",
      "organizations_url": "https://api.github.com/users/jachiang/orgs",
      "repos_url": "https://api.github.com/users/jachiang/repos",
      "events_url": "https://api.github.com/users/jachiang/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jachiang/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jachiang",
      "id": 26572234,
      "node_id": "MDQ6VXNlcjI2NTcyMjM0",
      "avatar_url": "https://avatars.githubusercontent.com/u/26572234?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jachiang",
      "html_url": "https://github.com/jachiang",
      "followers_url": "https://api.github.com/users/jachiang/followers",
      "following_url": "https://api.github.com/users/jachiang/following{/other_user}",
      "gists_url": "https://api.github.com/users/jachiang/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jachiang/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jachiang/subscriptions",
      "organizations_url": "https://api.github.com/users/jachiang/orgs",
      "repos_url": "https://api.github.com/users/jachiang/repos",
      "events_url": "https://api.github.com/users/jachiang/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jachiang/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a62393ad15103f9d5824d41fb2eed392a84dd66b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a62393ad15103f9d5824d41fb2eed392a84dd66b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a62393ad15103f9d5824d41fb2eed392a84dd66b"
      }
    ],
    "stats": {
      "total": 833,
      "additions": 825,
      "deletions": 8
    },
    "files": [
      {
        "sha": "1a9da06dbde8af52db963478623fdc07ca38323c",
        "filename": "test/functional/feature_miniscript.py",
        "status": "modified",
        "additions": 157,
        "deletions": 2,
        "changes": 159,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a85d9c9b74af95da6a8f63e3ed15c3b6fd284c2e/test/functional/feature_miniscript.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a85d9c9b74af95da6a8f63e3ed15c3b6fd284c2e/test/functional/feature_miniscript.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_miniscript.py?ref=a85d9c9b74af95da6a8f63e3ed15c3b6fd284c2e",
        "patch": "@@ -18,15 +18,19 @@ def set_test_params(self):\n         self.num_nodes = 1\n         self.setup_clean_chain = True\n \n-    def test_miniscript_expr(self, desc_str, property_str):\n+    def test_miniscript_expr(self, desc_str, property_str,\n+                             alt_desc_str=None):\n         node = Node.from_desc(desc_str)\n         node_from_script = Node.from_script(node.script)\n         assert(''.join(sorted(property_str)) ==\n                ''.join(sorted(node.p.to_string()))\n                )\n         assert(node.desc == desc_str)\n-        assert(node_from_script.desc == node.desc)\n         assert(node_from_script.script == node.script)\n+        if alt_desc_str is None:\n+            assert(node_from_script.desc == node.desc)\n+        else:\n+            assert(node_from_script.desc == alt_desc_str)\n         return node\n \n     def generate_key_pair(self, keyhash_dict):\n@@ -112,6 +116,157 @@ def run_test(self):\n                                                  pk_hex_list[2])\n         self.test_miniscript_expr(desc9, \"Bnduesm\")\n \n+        # Test (de)serialization of composable expressions.\n+\n+        # c:pkh(key)\n+        pkh = list(keyhash_dict)[0]\n+        desc10 = \"c:pk_h({})\".format(pkh.hex())\n+        self.test_miniscript_expr(desc10, \"Bndemus\")\n+\n+        # and_v(vc:pk_h(key), c:pk_h(key)) expression.\n+        pkh0 = list(keyhash_dict)[0]\n+        pkh1 = list(keyhash_dict)[1]\n+        desc11 = \"and_v(vc:pk_h({}),c:pk_h({}))\".format(pkh0.hex(), pkh1.hex())\n+        self.test_miniscript_expr(desc11, \"Bnfmus\")\n+\n+        # and_v(vc:pk_h(key),older(delay))) expression.\n+        pkh0 = list(keyhash_dict)[0]\n+        delay = 10\n+        desc12 = \"and_v(vc:pk_h({}),older({}))\".format(\n+            pkh0.hex(), delay)\n+        self.test_miniscript_expr(desc12, \"Bnfms\")\n+\n+        # or_b(c:pk(key),a:and_b(c:pk_h(key),sc:pk(key)))\n+        pk_hex_list = self.get_pubkey_hex_list(2, keyhash_dict)\n+        pkh0 = list(keyhash_dict)[0]\n+        desc13 = \"or_b(c:pk({}),a:and_b(c:pk_h({}),sc:pk({})))\".format(\n+            pk_hex_list[0], pkh0.hex(), pk_hex_list[1])\n+        self.test_miniscript_expr(desc13, \"Bdemus\")\n+\n+        # or_b(c:pk(key),a:and_n(c:pk(key),c:pk_h(key)))\n+        pk_hex_list = self.get_pubkey_hex_list(2, keyhash_dict)\n+        pkh0 = list(keyhash_dict)[0]\n+        desc14 = \"or_b(c:pk({}),a:and_n(c:pk({}),c:pk_h({})))\".format(\n+            *pk_hex_list, pkh0.hex())\n+        self.test_miniscript_expr(desc14, \"Bdemus\")\n+\n+        # or_b(c:pk(key),sc:pk(key))\n+        pk_hex_list = self.get_pubkey_hex_list(2, keyhash_dict)\n+        desc15 = \"or_b(c:pk({}),sc:pk({}))\".format(*pk_hex_list)\n+        self.test_miniscript_expr(desc15, \"Bdemus\")\n+\n+        # or_d(c:pk_h(key),c:pk_h(key))\n+        pk_hex_list = self.get_pubkey_hex_list(2, keyhash_dict)\n+        desc16 = \"or_d(c:pk({}),c:pk({}))\".format(*pk_hex_list)\n+        self.test_miniscript_expr(desc16, \"Bdemus\")\n+\n+        # t:or_c(c:pk(key),and_v(vc:pk(key),or_c(c:pk(key),v:hash160(h))))\n+        # and_v(or_c(c:pk(key),and_v(vc:pk(key),or_c(c:pk(key),v:hash160(h)))),1)\n+        h160_digest = list(hash160_dict)[0]\n+        pk_hex_list = self.get_pubkey_hex_list(3, keyhash_dict)\n+        desc17 = (\"t:or_c(c:pk({}),and_v(vc:pk({}),or_c(c:pk({}),\" +\n+                 \"v:hash160({}))))\").format(*pk_hex_list, h160_digest.hex())\n+        desc17_alt = (\"and_v(or_c(c:pk({}),and_v(vc:pk({}),or_c(c:pk({}),\" +\n+                     \"v:hash160({})))),1)\").format(*pk_hex_list,\n+                                                   h160_digest.hex())\n+        self.test_miniscript_expr(desc17, \"Bufsm\", desc17_alt)\n+\n+        # t:or_c(c:pk(key),and_v(vc:pk(key),or_c(c:pk(key),v:sha256(h))))\n+        # and_v(or_c(c:pk(key),and_v(vc:pk(key),or_c(c:pk(key),v:sha256(h)))),1)\n+        sha256_digest = list(sha256_dict)[0]\n+        pk_hex_list = self.get_pubkey_hex_list(3, keyhash_dict)\n+        desc18 = (\"t:or_c(c:pk({}),and_v(vc:pk({}),or_c(c:pk({}),\" +\n+                 \"v:sha256({}))))\").format(*pk_hex_list, sha256_digest.hex())\n+        desc18_alt = (\"and_v(or_c(c:pk({}),and_v(vc:pk({}),\" +\n+                     \"or_c(c:pk({}),v:sha256({})))),1)\").format(\n+                         *pk_hex_list, sha256_digest.hex())\n+        self.test_miniscript_expr(desc18, \"Bufsm\", desc18_alt)\n+\n+        # or_i(and_v(vc:pk_h(key_local),hash256(h)),older(20))\n+        h256_digest = list(hash256_dict)[0]\n+        pkh0 = list(keyhash_dict)[0]\n+        delay = 20\n+        desc19 = \"or_i(and_v(vc:pk_h({}),hash256({})),older({}))\".format(\n+            pkh0.hex(), h256_digest.hex(), delay)\n+        self.test_miniscript_expr(desc19, \"Bfm\")\n+\n+        # andor(c:pk(key),older(25),c:pk(key))\n+        delay = 25\n+        pk_hex_list = self.get_pubkey_hex_list(2, keyhash_dict)\n+        desc20 = \"andor(c:pk({}),older({}),c:pk({}))\".format(\n+            pk_hex_list[0], delay, pk_hex_list[1])\n+        self.test_miniscript_expr(desc20, \"Bdems\")\n+\n+        # andor(c:pk(key),or_i(and_v(vc:pk_h(key),hash160(h)),older(35)),c:pk(key))\n+        older = 35\n+        pkh0 = list(keyhash_dict)[0]\n+        pk_hex_list = self.get_pubkey_hex_list(2, keyhash_dict)\n+        ripemd160_digest = list(ripemd160_dict)[0]\n+        desc21 = (\"andor(c:pk({}),or_i(and_v(vc:pk_h({}),ripemd160({})),\" +\n+                  \"older({})),c:pk({}))\").format(\n+            pk_hex_list[0], pkh0.hex(), ripemd160_digest.hex(), older,\n+            pk_hex_list[1])\n+        self.test_miniscript_expr(desc21, \"Bdems\")\n+\n+        # thresh(k,c:pk(key),sc:pk(key),sc:pk(key),sdv:after(30))\n+        n = 4\n+        after = 30\n+        for k in range(2, n):\n+            pk_hex_list = self.get_pubkey_hex_list(n-1, keyhash_dict)\n+            desc22 = (\"thresh({},c:pk({}),sc:pk({}),sc:pk({}),\" +\n+                           \"sdv:after({}))\").format(k, *pk_hex_list, after)\n+            self.test_miniscript_expr(desc22, \"Bdmus\")\n+\n+        # thresh(k,c:pk(key),sc:pk(key),sc:pk(key),sc:pk(key),sc:pk(key))\n+        n = 5\n+        for k in range(2, n):\n+            pk_hex_list = self.get_pubkey_hex_list(n, keyhash_dict)\n+            desc23 = (\"thresh({},c:pk({}),sc:pk({}),sc:pk({}),sc:pk({})\" +\n+                           \",sc:pk({}))\").format(k, *pk_hex_list)\n+            self.test_miniscript_expr(desc23, \"Bdemus\")\n+\n+        # or_d(thresh_m(1,key),or_b(thresh_m(3,key,key,key),su:after(50)))\n+        # or_d(thresh_m(1,key),or_b(thresh_m(3,key,key,key),s:or_i(after(50),0)))\n+        k1 = 1\n+        k2 = 2\n+        after = 30\n+        pk_hex_list = self.get_pubkey_hex_list(4, keyhash_dict)\n+        desc24 = (\"or_d(thresh_m({},{}),or_b(thresh_m({},{},{},{}),\" +\n+                         \"su:after({})))\").format(k1, pk_hex_list[0], k2,\n+                                                  pk_hex_list[1],\n+                                                  pk_hex_list[2],\n+                                                  pk_hex_list[3], after)\n+        desc24_alt = (\"or_d(thresh_m({},{}),or_b(thresh_m({},{},{},{}),\" +\n+                      \"s:or_i(after({}),0)))\").format(k1, pk_hex_list[0], k2,\n+                                                      pk_hex_list[1],\n+                                                      pk_hex_list[2],\n+                                                      pk_hex_list[3], after)\n+        self.test_miniscript_expr(desc24, \"Bdemu\", desc24_alt)\n+\n+        # uuj:and_v(v:thresh_m(2,key,key),after(10))\n+        # or_i(or_i(j:and_v(v:thresh_m(2,key,key),after(time)),0),0)\n+        k = 2\n+        delay = 40\n+        pk_hex_list = self.get_pubkey_hex_list(2, keyhash_dict)\n+        desc25 = \"uuj:and_v(v:thresh_m({},{},{}),after({}))\".format(\n+            k, pk_hex_list[0], pk_hex_list[1], delay)\n+        desc25_alt = (\"or_i(or_i(j:and_v(v:thresh_m({},{},{}),after({})),0),\" +\n+                      \"0)\").format(k, pk_hex_list[0], pk_hex_list[1], delay)\n+        self.test_miniscript_expr(desc25, \"Bdsm\", desc25_alt)\n+\n+        # or_b(un:thresh_m(k,key,key),al:older(delay))\n+        # or_b(or_i(n:thresh_m(k,key,key),0),a:or_i(0,older(delay)))\n+        k = 2\n+        older = 45\n+        pk_hex_list = self.get_pubkey_hex_list(2, keyhash_dict)\n+        desc26 = \"or_b(un:thresh_m({},{},{}),al:older({}))\".format(\n+            k, pk_hex_list[0], pk_hex_list[1], older)\n+        desc26_alt = (\"or_b(or_i(n:thresh_m({},{},{}),0),\" +\n+                      \"a:or_i(0,older({})))\").format(k, pk_hex_list[0],\n+                                                     pk_hex_list[1],\n+                                                     older)\n+        self.test_miniscript_expr(desc26, \"Bdu\", desc26_alt)\n+\n \n if __name__ == '__main__':\n     MiniscriptTest().main()"
      },
      {
        "sha": "23fae3d7c0e0c2294b4f5d075fecda77dcf3cbf5",
        "filename": "test/functional/test_framework/miniscript.py",
        "status": "modified",
        "additions": 668,
        "deletions": 6,
        "changes": 674,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a85d9c9b74af95da6a8f63e3ed15c3b6fd284c2e/test/functional/test_framework/miniscript.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a85d9c9b74af95da6a8f63e3ed15c3b6fd284c2e/test/functional/test_framework/miniscript.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/miniscript.py?ref=a85d9c9b74af95da6a8f63e3ed15c3b6fd284c2e",
        "patch": "@@ -7,11 +7,12 @@\n from enum import Enum\n \n from .key import ECPubKey\n-from .script import CScript, OP_ADD, OP_CHECKLOCKTIMEVERIFY, \\\n-    OP_CHECKSEQUENCEVERIFY, OP_CHECKMULTISIG, OP_CHECKSIG, \\\n-    OP_CHECKMULTISIGVERIFY, OP_CHECKSIGVERIFY, OP_DUP, OP_EQUAL, \\\n-    OP_EQUALVERIFY, OP_HASH160, OP_HASH256, OP_RIPEMD160, OP_SHA256, \\\n-    OP_SIZE, OP_VERIFY\n+from .script import CScript, OP_ADD, OP_BOOLAND, OP_BOOLOR, OP_DUP, OP_ELSE, \\\n+    OP_ENDIF, OP_EQUAL, OP_EQUALVERIFY, OP_FROMALTSTACK, OP_IFDUP, OP_IF, \\\n+    OP_CHECKLOCKTIMEVERIFY, OP_CHECKMULTISIG, OP_CHECKMULTISIGVERIFY, \\\n+    OP_CHECKSEQUENCEVERIFY, OP_CHECKSIG, OP_CHECKSIGVERIFY, OP_HASH160, \\\n+    OP_HASH256, OP_NOTIF, OP_RIPEMD160, OP_SHA256, OP_SIZE, OP_SWAP, \\\n+    OP_TOALTSTACK, OP_VERIFY, OP_0NOTEQUAL\n \n \n class Property:\n@@ -40,7 +41,7 @@ def __init__(self):\n     def from_string(self, property_str):\n         \"\"\"Construct property from string of valid property and types\"\"\"\n         for char in property_str:\n-            assert(hasattr(self, char))\n+            assert (hasattr(self, char))\n             setattr(self, char, True)\n         assert self.is_valid()\n         return self\n@@ -316,10 +317,252 @@ def _parse_expr_list(expr_list):\n         if expr_list_len == 1 and isinstance(expr_list[0], Node):\n             return expr_list[0]\n \n+        # Step through each list index and match against templates.\n+\n+        # Right - to - left parsing.\n+            # Note: Parsing from script is ambiguous:\n+            # r-to-l:\n+            #    and_v(vc:pk_h(KEY),c:pk_h(KEY))\n+            # l-to-r:\n+            #   c:and_v(vc:pk_h(KEY),pk_h(KEY))\n+\n         # Step through each list index and match against templates.\n         idx = expr_list_len - 1\n         while idx >= 0:\n \n+            # 2 element expressions.\n+            if expr_list_len-idx >= 2:\n+\n+                # Match against and_v.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node):\n+                    try:\n+                        node = Node().construct_and_v(\n+                            expr_list[idx], expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against c wrapper.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_CHECKSIG:\n+                    try:\n+                        # Construct AST tree node.\n+                        node = Node().construct_c(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        # Recursive parse of remaining top-level nodes.\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against t wrapper.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+1].t == NodeType.JUST_1:\n+                    try:\n+                        node = Node().construct_t(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against v wrapper.\n+                elif isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_VERIFY:\n+                    try:\n+                        node = Node().construct_v(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against s wrapper.\n+                elif isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx] == OP_SWAP:\n+                    try:\n+                        node = Node().construct_s(expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against n wrapper.\n+                elif isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_0NOTEQUAL:\n+                    try:\n+                        node = Node().construct_n(expr_list[idx])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+2:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 3 element expressions.\n+            if expr_list_len-idx >= 3:\n+\n+                # Match against and_b.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_BOOLAND:\n+                    try:\n+                        node = Node().construct_and_b(expr_list[idx],\n+                                                      expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+3:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against or_b.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_BOOLOR:\n+                    try:\n+                        node = Node().construct_or_b(expr_list[idx],\n+                                                     expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+3:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against a wrapper.\n+                if expr_list[idx] == OP_TOALTSTACK and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_FROMALTSTACK:\n+                    try:\n+                        node = Node().construct_a(expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+3:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 4 element expressions.\n+            if expr_list_len-idx >= 4:\n+\n+                # Match against or_c.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_NOTIF and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+3] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_or_c(expr_list[idx],\n+                                                     expr_list[idx+2])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+4:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against d wrapper.\n+                if expr_list[idx:idx+2] == [OP_DUP, OP_IF] and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+3] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_d(expr_list[idx+2])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+4:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 5 element expressions.\n+            if expr_list_len-idx >= 5:\n+\n+                # Match against or_d.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1:idx+3] == [OP_IFDUP, OP_NOTIF] and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_or_d(expr_list[idx],\n+                                                     expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against or_i.\n+                if expr_list[idx] == OP_IF and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_or_i(expr_list[idx+1],\n+                                                     expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against j wrapper.\n+                if expr_list[idx:idx+3] == [OP_SIZE, OP_0NOTEQUAL, OP_IF] and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_j(expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against l wrapper.\n+                if expr_list[idx] == OP_IF and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+1].t == NodeType.JUST_0 and \\\n+                        expr_list[idx+2] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+3], Node) and \\\n+                        expr_list[idx+4] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_l(expr_list[idx+3])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against u wrapper.\n+                if expr_list[idx] == OP_IF and \\\n+                        isinstance(expr_list[idx+1], Node) and \\\n+                        expr_list[idx+2:idx+5] == [OP_ELSE, 0, OP_ENDIF]:\n+                    try:\n+                        node = Node().construct_u(expr_list[idx+1])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+5:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+            # 6 element expressions.\n+            if expr_list_len-idx >= 6:\n+\n+                # Match against and_n.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_NOTIF and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+2].t == NodeType.JUST_0 and \\\n+                        expr_list[idx+3] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+4], Node) and \\\n+                        expr_list[idx+5] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_and_n(expr_list[idx],\n+                                                      expr_list[idx+4])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+6:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n+                # Match against andor.\n+                if isinstance(expr_list[idx], Node) and \\\n+                        expr_list[idx+1] == OP_NOTIF and \\\n+                        isinstance(expr_list[idx+2], Node) and \\\n+                        expr_list[idx+3] == OP_ELSE and \\\n+                        isinstance(expr_list[idx+4], Node) and \\\n+                        expr_list[idx+5] == OP_ENDIF:\n+                    try:\n+                        node = Node().construct_andor(expr_list[idx],\n+                                                      expr_list[idx+4],\n+                                                      expr_list[idx+2])\n+                        expr_list = expr_list[:idx]+[node]+expr_list[idx+6:]\n+                        return Node._parse_expr_list(expr_list)\n+                    except Exception:\n+                        pass\n+\n             # Match against thresh_m.\n             # Termainal expression, but k and n values can be Nodes (JUST_0/1)\n             if expr_list_len-idx >= 5 and \\\n@@ -358,6 +601,39 @@ def _parse_expr_list(expr_list):\n                             except Exception:\n                                 pass\n \n+            # Match against thresh.\n+            if expr_list_len-idx >= 7:\n+                # Permissible values for n:\n+                # (len(list)-1)/2 >= n >= 3:\n+                for n in range(3, int((expr_list_len-1)/2)+1):\n+                    # Length of k-of-n thresh expression.\n+                    thresh_expr_len = 1+2*n\n+                    # Match (<expr> <OP_ADD>)*(n-1)\n+                    match = True\n+                    children = []\n+                    for i in range(n-1):\n+                        if not isinstance(expr_list[i*2+1], Node) or \\\n+                                expr_list[i*2+2] != OP_ADD:\n+                            match = False\n+                            break\n+                        else:\n+                            children.append(expr_list[i*2+1])\n+                    # Match <expr> ... <k> <OP_EQUAL>\n+                    if match is True:\n+                        k = Node._coerce_to_int(expr_list[thresh_expr_len-2])\n+                        if isinstance(expr_list[idx], Node) and \\\n+                            isinstance(k, int) and \\\n+                                expr_list[thresh_expr_len-1] == OP_EQUAL:\n+                            try:\n+                                k = expr_list[thresh_expr_len-2]\n+                                children = [expr_list[idx]] + children\n+                                node = Node().construct_thresh(k, children)\n+                                expr_list = expr_list[:idx] + [node] + \\\n+                                    expr_list[idx+thresh_expr_len:]\n+                                return Node._parse_expr_list(expr_list)\n+                            except Exception:\n+                                pass\n+\n             # Right-to-left parsing.\n             # Step one position left.\n             idx -= 1\n@@ -476,6 +752,392 @@ def construct_thresh_m(self, k, keys_n):\n                         )\n         return self\n \n+\n+    def construct_and_v(self, child_x, child_y):\n+        prop_str = \"\"\n+        prop_str += \"B\" if child_x.p.V and child_y.p.B else \"\"\n+        prop_str += \"K\" if child_x.p.V and child_y.p.K else \"\"\n+        prop_str += \"V\" if child_x.p.V and child_y.p.V else \"\"\n+        prop_str += \"u\" if child_y.p.u else \"\"\n+        prop_str += \"n\" if child_x.p.n or (child_x.p.z and child_y.p.n) else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_y.p.z else \"\"\n+        prop_str += \"o\" if (child_x.p.z and child_y.p.o) or \\\n+            (child_x.p.o and child_y.p.z) else \"\"\n+        prop_str += \"f\" if child_x.p.s or child_y.p.f else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_y.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s or child_y.p.s else \"\"\n+        self._construct(NodeType.AND_V, Property().from_string(prop_str),\n+                        [child_x, child_y],\n+                        child_x._script+child_y._script,\n+                        \"and_v(\"+child_x.desc+\",\"+child_y.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_and_b(self, child_x, child_y):\n+        prop_str = \"u\"\n+        prop_str += \"B\" if child_x.p.B and child_y.p.W else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_y.p.z else \"\"\n+        prop_str += \"o\" if (child_x.p.z and child_y.p.o) or \\\n+            (child_x.p.o and child_y.p.z) else \"\"\n+        prop_str += \"n\" if child_x.p.n or (child_x.p.z and child_y.p.n) else \"\"\n+        prop_str += \"d\" if child_x.p.d and child_y.p.d else \"\"\n+        prop_str += \"f\" if (child_x.p.f and child_y.p.f) or \\\n+            (child_x.p.s and child_x.p.f) or \\\n+            (child_y.p.s and child_y.p.f) else \"\"\n+        prop_str += \"e\" if child_x.p.e and child_y.p.e and \\\n+            child_x.p.s and child_y.p.s else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_y.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s or child_y.p.s else \"\"\n+        self._construct(NodeType.AND_B, Property().from_string(prop_str),\n+                        [child_x, child_y],\n+                        child_x._script+child_y._script+[OP_BOOLAND],\n+                        \"and_b(\"+child_x.desc+\",\"+child_y.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_and_n(self, child_x, child_y):\n+        assert (child_x.p.d and child_x.p.u)\n+        assert (child_x.p.f and child_y.p.f) is False\n+        prop_str = \"d\"\n+        prop_str += \"B\" if child_x.p.B and child_y.p.B else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_y.p.z else \"\"\n+        prop_str += \"o\" if child_x.p.o and child_y.p.z else \"\"\n+        prop_str += \"u\" if child_y.p.u else \"\"\n+        prop_str += \"e\" if child_x.p.e and \\\n+            (child_x.p.s or child_y.p.f) else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_y.p.m and \\\n+            child_x.p.e else \"\"\n+        prop_str += \"s\" if child_x.p.s or child_y.p.s else \"\"\n+        self._construct(NodeType.AND_N, Property().from_string(prop_str),\n+                        [child_x, child_y],\n+                        child_x._script+[OP_NOTIF, 0, OP_ELSE]+child_y._script+[\n+                            OP_ENDIF],\n+                        \"and_n(\"+child_x.desc+\",\"+child_y.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_or_b(self, child_x, child_z):\n+        assert (child_x.p.d and child_z.p.d)\n+        assert (child_x.p.f or child_z.p.f) is False\n+        prop_str = \"du\"\n+        prop_str += \"B\" if child_x.p.B and child_z.p.W else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_z.p.z else \"\"\n+        prop_str += \"o\" if (child_x.p.z and child_z.p.o) or \\\n+            (child_x.p.o and child_z.p.z) else \"\"\n+        prop_str += \"e\" if child_x.p.e and child_z.p.e else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_z.p.m and \\\n+            child_x.p.e and child_z.p.e and \\\n+            (child_x.p.s or child_z.p.s) else \"\"\n+        prop_str += \"s\" if child_x.p.s and child_z.p.s else \"\"\n+        self._construct(NodeType.OR_B, Property().from_string(prop_str),\n+                        [child_x, child_z],\n+                        child_x._script+child_z._script+[OP_BOOLOR],\n+                        \"or_b(\"+child_x.desc+\",\"+child_z.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_or_d(self, child_x, child_z):\n+        assert (child_x.p.d and child_x.p.u)\n+        prop_str = \"\"\n+        prop_str += \"B\" if child_x.p.B and child_z.p.B else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_z.p.z else \"\"\n+        prop_str += \"o\" if child_x.p.o and child_z.p.z else \"\"\n+        prop_str += \"u\" if child_x.p.u and \\\n+            (child_x.p.f or child_z.p.u) else \"\"\n+        prop_str += \"d\" if child_x.p.d and child_z.p.d else \"\"\n+        prop_str += \"f\" if child_x.p.f or child_z.p.f else \"\"\n+        prop_str += \"e\" if child_x.p.e and child_z.p.e else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_z.p.m and \\\n+            child_x.p.e and (child_x.p.s or child_z.p.s) else \"\"\n+        prop_str += \"s\" if child_x.p.s and child_z.p.s else \"\"\n+        self._construct(NodeType.OR_D, Property().from_string(prop_str),\n+                        [child_x, child_z],\n+                        child_x._script+[OP_IFDUP, OP_NOTIF]+child_z._script+[\n+                            OP_ENDIF],\n+                        \"or_d(\"+child_x.desc+\",\"+child_z.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_or_c(self, child_x, child_z):\n+        assert (child_x.p.d and child_x.p.u)\n+        prop_str = \"\"\n+        prop_str += \"V\" if child_x.p.B and child_z.p.V else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_z.p.z else \"\"\n+        prop_str += \"o\" if child_x.p.o and child_z.p.z else \"\"\n+        prop_str += \"f\" if child_x.p.f or child_z.p.f else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_z.p.m and \\\n+            child_x.p.e and (child_x.p.s or child_z.p.s) else \"\"\n+        prop_str += \"s\" if child_x.p.s and child_z.p.s else \"\"\n+        self._construct(NodeType.OR_C, Property().from_string(prop_str),\n+                        [child_x, child_z],\n+                        child_x._script+[OP_NOTIF]+child_z._script+[OP_ENDIF],\n+                        \"or_c(\"+child_x.desc+\",\"+child_z.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_or_i(self, child_x, child_z):\n+        prop_str = \"\"\n+        prop_str += \"B\" if child_x.p.B and child_z.p.B else \"\"\n+        prop_str += \"K\" if child_x.p.K and child_z.p.K else \"\"\n+        prop_str += \"K\" if child_x.p.V and child_z.p.V else \"\"\n+        prop_str += \"u\" if child_x.p.u and child_z.p.u else \"\"\n+        prop_str += \"d\" if child_x.p.d or child_z.p.d else \"\"\n+        prop_str += \"o\" if child_x.p.z and child_z.p.z else \"\"\n+        prop_str += \"e\" if (child_x.p.e and child_z.p.f) or \\\n+            (child_x.p.f and child_z.p.e) else \"\"\n+        prop_str += \"f\" if child_x.p.f and child_z.p.f else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_z.p.m and \\\n+            (child_x.p.s or child_z.p.s) else \"\"\n+        prop_str += \"s\" if child_x.p.s and child_z.p.s else \"\"\n+        self._construct(NodeType.OR_I, Property().from_string(prop_str),\n+                        [child_x, child_z],\n+                        [OP_IF]+child_x._script+[OP_ELSE]+child_z._script+[\n+                        OP_ENDIF],\n+                        \"or_i(\"+child_x.desc+\",\"+child_z.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_andor(self, child_x, child_y, child_z):\n+        assert (child_x.p.d and child_x.p.u)\n+        prop_str = \"\"\n+        prop_str += \"B\" if child_x.p.B and child_y.p.B and child_z.p.B else \"\"\n+        prop_str += \"K\" if child_x.p.B and child_y.p.K and child_z.p.K else \"\"\n+        prop_str += \"V\" if child_x.p.B and child_y.p.V and child_z.p.V else \"\"\n+        prop_str += \"z\" if child_x.p.z and child_y.p.z and child_z.p.z else \"\"\n+        prop_str += \"o\" if (child_x.p.z and child_y.p.o and child_z.p.o) or \\\n+            (child_x.p.o and child_y.p.z and child_z.p.z) else \"\"\n+        prop_str += \"u\" if child_y.p.u and child_z.p.u else \"\"\n+        prop_str += \"d\" if child_x.p.d and child_z.p.d else \"\"\n+        prop_str += \"f\" if child_z.p.f and (child_x.p.s or child_y.p.f) else \"\"\n+        prop_str += \"e\" if child_x.p.e and child_z.p.e and \\\n+            (child_x.p.s or child_y.p.f) else \"\"\n+        prop_str += \"m\" if child_x.p.m and child_y.p.m and child_z.p.m and \\\n+            child_x.p.e and (child_x.p.s or child_y.p.s or child_z.p.s) else \"\"\n+        prop_str += \"s\" if child_z.p.s and (child_x.p.s or child_y.p.s) else \"\"\n+        self._construct(NodeType.ANDOR, Property().from_string(prop_str),\n+                        [child_x, child_y, child_z],\n+                        child_x._script+[OP_NOTIF]+child_z._script+[\n+                        OP_ELSE]+child_y._script+[OP_ENDIF],\n+                        \"andor(\"+child_x.desc+\",\"+child_y.desc+\",\"\n+                        + child_z.desc+\")\"\n+                        )\n+        return self\n+\n+    def construct_a(self, child_x):\n+        prop_str = \"\"\n+        prop_str += \"W\" if child_x.p.B else \"\"\n+        prop_str += \"u\" if child_x.p.u else \"\"\n+        prop_str += \"d\" if child_x.p.d else \"\"\n+        prop_str += \"f\" if child_x.p.f else \"\"\n+        prop_str += \"e\" if child_x.p.e else \"\"\n+        prop_str += \"m\" if child_x.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s else \"\"\n+        tag = \"a\" if child_x.t.name.startswith('WRAP_') else \"a:\"\n+        self._construct(NodeType.WRAP_A, Property().from_string(prop_str),\n+                        [child_x],\n+                        [OP_TOALTSTACK]+child_x._script+[OP_FROMALTSTACK],\n+                        tag+child_x.desc\n+                        )\n+        return self\n+\n+    def construct_s(self, child_x):\n+        assert (child_x.p.B and child_x.p.o)\n+        prop_str = \"W\"\n+        prop_str += \"u\" if child_x.p.u else \"\"\n+        prop_str += \"d\" if child_x.p.d else \"\"\n+        prop_str += \"f\" if child_x.p.f else \"\"\n+        prop_str += \"e\" if child_x.p.e else \"\"\n+        prop_str += \"m\" if child_x.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s else \"\"\n+        tag = \"s\" if child_x.t.name.startswith('WRAP_') else \"s:\"\n+        self._construct(NodeType.WRAP_S, Property().from_string(prop_str),\n+                        [child_x],\n+                        [OP_SWAP]+child_x._script, tag+child_x.desc\n+                        )\n+        return self\n+\n+    def construct_c(self, child_x):\n+        assert child_x.p.K\n+        prop_str = \"Bu\"\n+        prop_str += \"o\" if child_x.p.o else \"\"\n+        prop_str += \"n\" if child_x.p.n else \"\"\n+        prop_str += \"d\" if child_x.p.d else \"\"\n+        prop_str += \"e\" if child_x.p.e else \"\"\n+        prop_str += \"m\" if child_x.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s else \"\"\n+        tag = \"c\" if child_x.t.name.startswith('WRAP_') else \"c:\"\n+        self._construct(NodeType.WRAP_C, Property().from_string(prop_str),\n+                        [child_x],\n+                        child_x._script+[OP_CHECKSIG], tag+child_x.desc\n+                        )\n+        return self\n+\n+    def construct_t(self, child_x):\n+        prop_str = \"uf\"\n+        prop_str += \"B\" if child_x.p.V else \"\"\n+        prop_str += \"n\" if child_x.p.n else \"\"\n+        prop_str += \"z\" if child_x.p.z else \"\"\n+        prop_str += \"o\" if child_x.p.o else \"\"\n+        prop_str += \"m\" if child_x.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s else \"\"\n+        tag = \"t\" if child_x.t.name.startswith('WRAP_') else \"t:\"\n+        self._construct(NodeType.WRAP_T, Property().from_string(prop_str),\n+                        [child_x],\n+                        child_x._script+[1], tag+child_x.desc\n+                        )\n+        return self\n+\n+    def construct_d(self, child_x):\n+        assert (child_x.p.z)\n+        prop_str = \"nud\"\n+        prop_str += \"B\" if child_x.p.V else \"\"\n+        prop_str += \"o\" if child_x.p.z else \"\"\n+        prop_str += \"e\" if child_x.p.f else \"\"\n+        prop_str += \"m\" if child_x.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s else \"\"\n+        tag = \"d\" if child_x.t.name.startswith('WRAP_') else \"d:\"\n+        self._construct(NodeType.WRAP_D, Property().from_string(prop_str),\n+                        [child_x],\n+                        [OP_DUP, OP_IF]+child_x._script+[OP_ENDIF],\n+                        tag+child_x.desc\n+                        )\n+        return self\n+\n+    def construct_v(self, child_x):\n+        assert child_x.p.B\n+        prop_str = \"V\"\n+        prop_str += \"z\" if child_x.p.z else \"\"\n+        prop_str += \"o\" if child_x.p.o else \"\"\n+        prop_str += \"n\" if child_x.p.n else \"\"\n+        prop_str += \"f\"\n+        prop_str += \"m\" if child_x.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s else \"\"\n+        tag = \"v\" if child_x.t.name.startswith('WRAP_') else \"v:\"\n+        # Combine OP_CHECKSIG/OP_CHECKMULTISIG/OP_EQUAL with OP_VERIFY.\n+        if child_x._script[-1] == OP_CHECKSIG:\n+            script = child_x._script[:-1]+[OP_CHECKSIGVERIFY]\n+        elif child_x._script[-1] == OP_CHECKMULTISIG:\n+            script = child_x._script[:-1]+[OP_CHECKMULTISIGVERIFY]\n+        elif child_x._script[-1] == OP_EQUAL:\n+            script = child_x._script[:-1]+[OP_EQUALVERIFY]\n+        else:\n+            script = child_x._script+[OP_VERIFY]\n+        self._construct(NodeType.WRAP_V, Property().from_string(prop_str),\n+                        [child_x],\n+                        script, tag+child_x.desc)\n+        return self\n+\n+    def construct_j(self, child_x):\n+        assert (child_x.p.n)\n+        prop_str = \"nd\"\n+        prop_str += \"B\" if child_x.p.B else \"\"\n+        prop_str += \"o\" if child_x.p.o else \"\"\n+        prop_str += \"u\" if child_x.p.u else \"\"\n+        prop_str += \"e\" if child_x.p.f else \"\"\n+        prop_str += \"m\" if child_x.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s else \"\"\n+        tag = \"j\" if child_x.t.name.startswith('WRAP_') else \"j:\"\n+        script = [OP_SIZE, OP_0NOTEQUAL, OP_IF]+child_x._script+[OP_ENDIF]\n+        self._construct(NodeType.WRAP_J, Property().from_string(prop_str),\n+                        [child_x],\n+                        script, tag+child_x.desc)\n+        return self\n+\n+    def construct_n(self, child_x):\n+        prop_str = \"u\"\n+        prop_str += \"B\" if child_x.p.B else \"\"\n+        prop_str += \"z\" if child_x.p.z else \"\"\n+        prop_str += \"o\" if child_x.p.o else \"\"\n+        prop_str += \"n\" if child_x.p.n else \"\"\n+        prop_str += \"d\" if child_x.p.d else \"\"\n+        prop_str += \"f\" if child_x.p.f else \"\"\n+        prop_str += \"e\" if child_x.p.e else \"\"\n+        prop_str += \"m\" if child_x.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s else \"\"\n+        tag = \"n\" if child_x.t.name.startswith('WRAP_') else \"n:\"\n+        self._construct(NodeType.WRAP_N, Property().from_string(prop_str),\n+                        [child_x],\n+                        child_x._script+[OP_0NOTEQUAL], tag+child_x.desc)\n+        return self\n+\n+    def construct_l(self, child_x):\n+        prop_str = \"d\"\n+        prop_str += \"B\" if child_x.p.B else \"\"\n+        prop_str += \"o\" if child_x.p.z else \"\"\n+        prop_str += \"u\" if child_x.p.u else \"\"\n+        prop_str += \"e\" if child_x.p.f else \"\"\n+        prop_str += \"m\" if child_x.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s else \"\"\n+        tag = \"l\" if child_x.t.name.startswith('WRAP_') else \"l:\"\n+        script = [OP_IF, 0, OP_ELSE]+child_x._script+[OP_ENDIF]\n+        self._construct(NodeType.WRAP_L, Property().from_string(prop_str),\n+                        [child_x],\n+                        script, tag+child_x.desc)\n+        return self\n+\n+    def construct_u(self, child_x):\n+        prop_str = \"d\"\n+        prop_str += \"B\" if child_x.p.B else \"\"\n+        prop_str += \"o\" if child_x.p.z else \"\"\n+        prop_str += \"u\" if child_x.p.u else \"\"\n+        prop_str += \"e\" if child_x.p.f else \"\"\n+        prop_str += \"m\" if child_x.p.m else \"\"\n+        prop_str += \"s\" if child_x.p.s else \"\"\n+        tag = \"u\" if child_x.t.name.startswith('WRAP_') else \"u:\"\n+        script = [OP_IF]+child_x._script+[OP_ELSE, 0, OP_ENDIF]\n+        self._construct(NodeType.WRAP_U, Property().from_string(prop_str),\n+                        [child_x],\n+                        script, tag+child_x.desc)\n+        return self\n+\n+    def construct_thresh(self, k, children_n):\n+        n = len(children_n)\n+        assert n > k > 1\n+        child_is_z_count = 0\n+        child_is_o_count = 0\n+        child_is_s_count = 0\n+        child_is_e = True\n+        child_is_m = True\n+        for idx, child in enumerate(children_n):\n+            assert child.p.d and child.p.u\n+            child_is_z_count += 1 if child.p.z else 0\n+            child_is_o_count += 1 if child.p.o else 0\n+            child_is_s_count += 1 if child.p.s else 0\n+            child_is_e = child_is_e and child.p.e\n+            child_is_m = child_is_m and child.p.m\n+            if idx == 0:\n+                is_B = child.p.B\n+            else:\n+                is_B = is_B and child.p.W\n+        prop_str = \"Bdu\" if is_B else \"\"\n+        if child_is_z_count == n:\n+            prop_str += \"z\"\n+        elif (child_is_z_count == n-1) and (child_is_o_count == 1):\n+            prop_str += \"o\"\n+        if child_is_e and (child_is_s_count is n):\n+            prop_str += \"e\"\n+        if child_is_e and child_is_m and child_is_s_count >= (n-k):\n+            prop_str += \"m\"\n+        if child_is_s_count >= (n-k+1):\n+            prop_str += \"s\"\n+        script = []\n+        script.extend(children_n[0]._script)\n+        for child in children_n[1:]:\n+            script.extend(child._script+[OP_ADD])\n+        script.extend([k] + [OP_EQUAL])\n+        self._k = k\n+\n+        desc = \"thresh(\"+str(k)+\",\"\n+        for idx, child in enumerate(children_n):\n+            desc += child.desc\n+            desc += \",\" if idx != (n-1) else \")\"\n+\n+        self._construct(NodeType.THRESH, Property().from_string(prop_str),\n+                        children_n,\n+                        script, desc\n+                        )\n+        return self\n+\n     def _construct(self,\n                    node_type, node_prop,\n                    children,"
      }
    ]
  },
  {
    "sha": "08ecc87fb912d2d3221db33aa803d26b07e39176",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowOGVjYzg3ZmI5MTJkMmQzMjIxZGIzM2FhODAzZDI2YjA3ZTM5MTc2",
    "commit": {
      "author": {
        "name": "James Chiang",
        "email": "james.chiangwu@gmail.com",
        "date": "2020-01-20T16:41:36Z"
      },
      "committer": {
        "name": "James Chiang",
        "email": "james.chiangwu@gmail.com",
        "date": "2020-03-14T13:52:31Z"
      },
      "message": "TestFramework: Add SatType class\n\nSatType enum defines types of witness elements which is required to\nproduce a valid witness to spend a miniscript expression. SatType is\nused in a tuple context (SatType, Hint), where the hint data provides\nthe required information to generate the satisfying witness element.",
      "tree": {
        "sha": "ac22aa0f4309f7aa4089eba4b5be153c642c8adc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ac22aa0f4309f7aa4089eba4b5be153c642c8adc"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/08ecc87fb912d2d3221db33aa803d26b07e39176",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/08ecc87fb912d2d3221db33aa803d26b07e39176",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/08ecc87fb912d2d3221db33aa803d26b07e39176",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/08ecc87fb912d2d3221db33aa803d26b07e39176/comments",
    "author": {
      "login": "jachiang",
      "id": 26572234,
      "node_id": "MDQ6VXNlcjI2NTcyMjM0",
      "avatar_url": "https://avatars.githubusercontent.com/u/26572234?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jachiang",
      "html_url": "https://github.com/jachiang",
      "followers_url": "https://api.github.com/users/jachiang/followers",
      "following_url": "https://api.github.com/users/jachiang/following{/other_user}",
      "gists_url": "https://api.github.com/users/jachiang/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jachiang/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jachiang/subscriptions",
      "organizations_url": "https://api.github.com/users/jachiang/orgs",
      "repos_url": "https://api.github.com/users/jachiang/repos",
      "events_url": "https://api.github.com/users/jachiang/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jachiang/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jachiang",
      "id": 26572234,
      "node_id": "MDQ6VXNlcjI2NTcyMjM0",
      "avatar_url": "https://avatars.githubusercontent.com/u/26572234?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jachiang",
      "html_url": "https://github.com/jachiang",
      "followers_url": "https://api.github.com/users/jachiang/followers",
      "following_url": "https://api.github.com/users/jachiang/following{/other_user}",
      "gists_url": "https://api.github.com/users/jachiang/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jachiang/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jachiang/subscriptions",
      "organizations_url": "https://api.github.com/users/jachiang/orgs",
      "repos_url": "https://api.github.com/users/jachiang/repos",
      "events_url": "https://api.github.com/users/jachiang/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jachiang/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a85d9c9b74af95da6a8f63e3ed15c3b6fd284c2e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a85d9c9b74af95da6a8f63e3ed15c3b6fd284c2e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a85d9c9b74af95da6a8f63e3ed15c3b6fd284c2e"
      }
    ],
    "stats": {
      "total": 16,
      "additions": 16,
      "deletions": 0
    },
    "files": [
      {
        "sha": "1079711e6c3b13f6cf0addea5f7ad2e2a839fa92",
        "filename": "test/functional/test_framework/miniscript.py",
        "status": "modified",
        "additions": 16,
        "deletions": 0,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/08ecc87fb912d2d3221db33aa803d26b07e39176/test/functional/test_framework/miniscript.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/08ecc87fb912d2d3221db33aa803d26b07e39176/test/functional/test_framework/miniscript.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/miniscript.py?ref=08ecc87fb912d2d3221db33aa803d26b07e39176",
        "patch": "@@ -111,6 +111,22 @@ class NodeType(Enum):\n     THRESH_M = 29\n \n \n+class SatType(Enum):\n+    # SatType Class provides information on how to construct satisfying or\n+    # non-satisfying witnesses. sat/dsat methods return list of tuples:\n+    # [(SatType, Value), (SatType, Value), ...]\n+    # The value provides a hint how to construct the resp. witness element.\n+    OLDER = 0                       # Value: Delay\n+    AFTER = 1                       # Value: Time\n+    SIGNATURE = 2                   # Value: 33B Key/20B HASH160 Digest\n+    KEY_AND_HASH160_PREIMAGE = 3    # Value: 20B HASH160 Digest\n+    SHA256_PREIMAGE = 4             # Value: 32B SHA256 Digest\n+    HASH256_PREIMAGE = 5            # Value: 32B HASH256 Digest\n+    RIPEMD160_PREIMAGE = 6          # Value: 20B RIPEMD160 Digest\n+    HASH160_PREIMAGE = 7            # Value: 20B HASH160 Digest\n+    DATA = 8                        # Value: Bytes\n+\n+\n class Node:\n     \"\"\"Miniscript expression class\n "
      }
    ]
  },
  {
    "sha": "7a59782a2d5b8e65fd7d09e035eb35e7b2168824",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3YTU5NzgyYTJkNWI4ZTY1ZmQ3ZDA5ZTAzNWViMzVlN2IyMTY4ODI0",
    "commit": {
      "author": {
        "name": "James Chiang",
        "email": "james.chiangwu@gmail.com",
        "date": "2020-01-21T13:44:12Z"
      },
      "committer": {
        "name": "James Chiang",
        "email": "james.chiangwu@gmail.com",
        "date": "2020-03-14T13:52:31Z"
      },
      "message": "TestFramework: Add Node.(d)sat and _lift methods\n\nNode.sat/Node.dsat return a list of tuple-lists which allow the user\nto generate all possible (dis)satisfying witnesses.",
      "tree": {
        "sha": "cc1df8110e9599dbb6fb83335b557827e10eae67",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/cc1df8110e9599dbb6fb83335b557827e10eae67"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7a59782a2d5b8e65fd7d09e035eb35e7b2168824",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7a59782a2d5b8e65fd7d09e035eb35e7b2168824",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7a59782a2d5b8e65fd7d09e035eb35e7b2168824",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7a59782a2d5b8e65fd7d09e035eb35e7b2168824/comments",
    "author": {
      "login": "jachiang",
      "id": 26572234,
      "node_id": "MDQ6VXNlcjI2NTcyMjM0",
      "avatar_url": "https://avatars.githubusercontent.com/u/26572234?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jachiang",
      "html_url": "https://github.com/jachiang",
      "followers_url": "https://api.github.com/users/jachiang/followers",
      "following_url": "https://api.github.com/users/jachiang/following{/other_user}",
      "gists_url": "https://api.github.com/users/jachiang/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jachiang/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jachiang/subscriptions",
      "organizations_url": "https://api.github.com/users/jachiang/orgs",
      "repos_url": "https://api.github.com/users/jachiang/repos",
      "events_url": "https://api.github.com/users/jachiang/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jachiang/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jachiang",
      "id": 26572234,
      "node_id": "MDQ6VXNlcjI2NTcyMjM0",
      "avatar_url": "https://avatars.githubusercontent.com/u/26572234?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jachiang",
      "html_url": "https://github.com/jachiang",
      "followers_url": "https://api.github.com/users/jachiang/followers",
      "following_url": "https://api.github.com/users/jachiang/following{/other_user}",
      "gists_url": "https://api.github.com/users/jachiang/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jachiang/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jachiang/subscriptions",
      "organizations_url": "https://api.github.com/users/jachiang/orgs",
      "repos_url": "https://api.github.com/users/jachiang/repos",
      "events_url": "https://api.github.com/users/jachiang/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jachiang/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "08ecc87fb912d2d3221db33aa803d26b07e39176",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/08ecc87fb912d2d3221db33aa803d26b07e39176",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/08ecc87fb912d2d3221db33aa803d26b07e39176"
      }
    ],
    "stats": {
      "total": 546,
      "additions": 520,
      "deletions": 26
    },
    "files": [
      {
        "sha": "f198f64f5da1cf569eea54fb00d0c7f710d806f9",
        "filename": "test/functional/feature_miniscript.py",
        "status": "modified",
        "additions": 185,
        "deletions": 24,
        "changes": 209,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7a59782a2d5b8e65fd7d09e035eb35e7b2168824/test/functional/feature_miniscript.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7a59782a2d5b8e65fd7d09e035eb35e7b2168824/test/functional/feature_miniscript.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_miniscript.py?ref=7a59782a2d5b8e65fd7d09e035eb35e7b2168824",
        "patch": "@@ -4,14 +4,18 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test miniscript implementation.\"\"\"\n \n+import hashlib\n+from io import BytesIO\n+\n+from test_framework.address import script_to_p2wsh\n from test_framework.key import ECKey\n-from test_framework.miniscript import Node\n-from test_framework.messages import hash256, sha256\n-from test_framework.script import hash160\n+from test_framework.miniscript import Node, SatType\n+from test_framework.messages import CTransaction, CTxInWitness, COutPoint, \\\n+    CTxIn, CTxOut, hash256, sha256\n+from test_framework.script import CScript, hash160, \\\n+    SegwitV0SignatureHash, SIGHASH_ALL\n from test_framework.test_framework import BitcoinTestFramework\n \n-import hashlib\n-\n \n class MiniscriptTest(BitcoinTestFramework):\n     def set_test_params(self):\n@@ -33,6 +37,99 @@ def test_miniscript_expr(self, desc_str, property_str,\n             assert(node_from_script.desc == alt_desc_str)\n         return node\n \n+    def test_miniscript_satisfaction(self, node, keyhash_dict, sha256_dict,\n+                                     hash256_dict, ripemd160_dict,\n+                                     hash160_dict):\n+        # Send funds to p2wsh(miniscript.script).\n+        v0_address = script_to_p2wsh(node.script)\n+        tx = self.generate_and_send_coin(v0_address)\n+        # Construct spending transaction.\n+        minfee_sat = int(self.nodes[0].getmempoolinfo()[\n+            'mempoolminfee'] * 100000000)\n+        spending_tx = self.create_spending_transaction(\n+            tx.hash, amount=tx.vout[0].nValue-minfee_sat)\n+        spending_tx.wit.vtxinwit = [CTxInWitness()]\n+        node_script = CScript(node.script)\n+        sig_hash = SegwitV0SignatureHash(node_script,\n+                                               spending_tx, 0,\n+                                               SIGHASH_ALL,\n+                                               tx.vout[0].nValue)\n+        # Test each canonical AND non-canonical\n+        # satisfying witness for spending transaction.\n+        for wit_sat in node.sat:\n+            witness_arr = []\n+            for sat_element in wit_sat:\n+                # Set sequence for input at index 0.\n+                if sat_element[0] is SatType.OLDER:\n+                    delay = max(spending_tx.vin[0].nSequence, sat_element[1])\n+                    spending_tx.vin[0].nSequence = delay\n+                    # Recompute sighash.\n+                    sig_hash = SegwitV0SignatureHash(node_script,\n+                                                           spending_tx, 0,\n+                                                           SIGHASH_ALL,\n+                                                           tx.vout[0].nValue)\n+                # Set locktime.\n+                if sat_element[0] is SatType.AFTER:\n+                    locktime = max(spending_tx.nLockTime, sat_element[1])\n+                    spending_tx.nLockTime = locktime\n+                    # Recompute sighash.\n+                    sig_hash = SegwitV0SignatureHash(node_script,\n+                                                           spending_tx, 0,\n+                                                           SIGHASH_ALL,\n+                                                           tx.vout[0].nValue)\n+                # Add signature witness element.\n+                if sat_element[0] is SatType.SIGNATURE:\n+                    # Value: 33B Pubkey\n+                    if len(sat_element[1]) == 33:\n+                        pkhash = hash160(sat_element[1])\n+                        signature = keyhash_dict[pkhash].sign_ecdsa(\n+                            sig_hash)+b'\\x01'\n+                        witness_arr.append(signature)\n+                    # Value: 20B Pubkeyhash\n+                    elif len(sat_element[1]) == 20:\n+                        signature = keyhash_dict[sat_element[1]].sign_ecdsa(\n+                            sig_hash) + b'\\x01'\n+                        witness_arr.append(signature)\n+                # Add public key witness element.\n+                elif sat_element[0] is SatType.KEY_AND_HASH160_PREIMAGE:\n+                    secret_key = keyhash_dict[sat_element[1]]\n+                    witness_arr.append(secret_key.get_pubkey().get_bytes())\n+                # Add sha256 preimage witness element.\n+                elif sat_element[0] is SatType.SHA256_PREIMAGE:\n+                    sha256_preimage = sha256_dict[sat_element[1]]\n+                    witness_arr.append(sha256_preimage)\n+                # Add hash256 preimage witness element.\n+                elif sat_element[0] is SatType.HASH256_PREIMAGE:\n+                    hash256_preimage = hash256_dict[sat_element[1]]\n+                    witness_arr.append(hash256_preimage)\n+                # Add ripemd160 preimage witness element.\n+                elif sat_element[0] is SatType.RIPEMD160_PREIMAGE:\n+                    ripemd160_preimage = ripemd160_dict[sat_element[1]]\n+                    witness_arr.append(ripemd160_preimage)\n+                # Add hash160 preimage witness element.\n+                elif sat_element[0] is SatType.HASH160_PREIMAGE:\n+                    hash160_preimage = hash160_dict[sat_element[1]]\n+                    witness_arr.append(hash160_preimage)\n+                # Add data witness element\n+                elif sat_element[0] is SatType.DATA:\n+                    witness_arr.append(sat_element[1])\n+            # Set witness and test mempool acceptance.\n+            spending_tx.wit.vtxinwit[0].scriptWitness.stack = witness_arr + [\n+                node_script]\n+            spending_tx.rehash()\n+            tx_str = spending_tx.serialize().hex()\n+            # Mine if delay or timelock.\n+            if spending_tx.vin[0].nSequence > 0 or spending_tx.nLockTime > 0:\n+                height = self.nodes[0].getblockchaininfo()['blocks']\n+                blocks_required = max(spending_tx.nLockTime-height,\n+                                      spending_tx.vin[0].nSequence)\n+                self.nodes[0].generate(blocks_required)\n+            # Test mempool acceptance.\n+            ret = self.nodes[0].testmempoolaccept(rawtxs=[tx_str],\n+                                                  maxfeerate=0)[0]\n+            assert(ret['allowed'])\n+\n+    # Test Utility Methods.\n     def generate_key_pair(self, keyhash_dict):\n         privkey = ECKey()\n         privkey.generate()\n@@ -46,6 +143,53 @@ def get_pubkey_hex_list(self, n, keyhash_dict):\n             key_hex_list.append(pk_hex)\n         return key_hex_list\n \n+    def generate_and_send_coin(self, address):\n+        if self.nodes[0].getblockchaininfo()['blocks'] == 0:\n+            self.coinbase_address = self.nodes[0].getnewaddress(\n+                address_type=\"bech32\")\n+            self.nodes[0].generatetoaddress(101, self.coinbase_address)\n+\n+        balance = self.nodes[0].getbalance()\n+\n+        while balance < 1:\n+            self.nodes[0].generatetoaddress(1, self.coinbase_address)\n+            balance = self.nodes[0].getbalance()\n+\n+        unspent_txid = self.nodes[0].listunspent(1)[-1][\"txid\"]\n+        inputs = [{\"txid\": unspent_txid, \"vout\": 0}]\n+\n+        # Send funds to address.\n+        tx_hex = self.nodes[0].createrawtransaction(inputs=inputs,\n+                                                    outputs=[{address: 1}])\n+        res = self.nodes[0].signrawtransactionwithwallet(hexstring=tx_hex)\n+        tx_hex = res[\"hex\"]\n+        assert res[\"complete\"]\n+        assert 'errors' not in res\n+\n+        # Max feerate set to 0 since no change output created.\n+        txid = self.nodes[0].sendrawtransaction(hexstring=tx_hex, maxfeerate=0)\n+        tx_hex = self.nodes[0].getrawtransaction(txid)\n+        tx = CTransaction()\n+        tx.deserialize(BytesIO(bytes.fromhex(tx_hex)))\n+        tx.rehash()\n+        return tx\n+\n+    def create_spending_transaction(self, txid, amount=0, version=2,\n+                                    nSequence=0, nLocktime=0):\n+        spending_tx = CTransaction()\n+        spending_tx.nVersion = version\n+        spending_tx.nLockTime = nLocktime\n+        outpoint = COutPoint(int(txid, 16), 0)\n+        spending_tx_in = CTxIn(outpoint=outpoint, nSequence=nSequence)\n+        spending_tx.vin = [spending_tx_in]\n+        dest_addr = self.nodes[0].getnewaddress(address_type=\"bech32\")\n+        scriptpubkey = bytes.fromhex(self.nodes[0].getaddressinfo(dest_addr)[\n+            'scriptPubKey'])\n+        amount_sat = amount\n+        dest_output = CTxOut(nValue=amount_sat, scriptPubKey=scriptpubkey)\n+        spending_tx.vout = [dest_output]\n+        return spending_tx\n+\n     def run_test(self):\n         # Generate key pairs.\n         keyhash_dict = {}\n@@ -116,49 +260,53 @@ def run_test(self):\n                                                  pk_hex_list[2])\n         self.test_miniscript_expr(desc9, \"Bnduesm\")\n \n-        # Test (de)serialization of composable expressions.\n+        # Test (de)serialization and (dis)satisfaction\n+        # of composable expressions.\n+\n+        # Append miniscript nodes for satisfaction tests.\n+        miniscript_list = []\n \n         # c:pkh(key)\n         pkh = list(keyhash_dict)[0]\n         desc10 = \"c:pk_h({})\".format(pkh.hex())\n-        self.test_miniscript_expr(desc10, \"Bndemus\")\n+        miniscript_list.append(self.test_miniscript_expr(desc10, \"Bndemus\"))\n \n         # and_v(vc:pk_h(key), c:pk_h(key)) expression.\n         pkh0 = list(keyhash_dict)[0]\n         pkh1 = list(keyhash_dict)[1]\n         desc11 = \"and_v(vc:pk_h({}),c:pk_h({}))\".format(pkh0.hex(), pkh1.hex())\n-        self.test_miniscript_expr(desc11, \"Bnfmus\")\n+        miniscript_list.append(self.test_miniscript_expr(desc11, \"Bnfmus\"))\n \n         # and_v(vc:pk_h(key),older(delay))) expression.\n         pkh0 = list(keyhash_dict)[0]\n         delay = 10\n         desc12 = \"and_v(vc:pk_h({}),older({}))\".format(\n             pkh0.hex(), delay)\n-        self.test_miniscript_expr(desc12, \"Bnfms\")\n+        miniscript_list.append(self.test_miniscript_expr(desc12, \"Bnfms\"))\n \n         # or_b(c:pk(key),a:and_b(c:pk_h(key),sc:pk(key)))\n         pk_hex_list = self.get_pubkey_hex_list(2, keyhash_dict)\n         pkh0 = list(keyhash_dict)[0]\n         desc13 = \"or_b(c:pk({}),a:and_b(c:pk_h({}),sc:pk({})))\".format(\n             pk_hex_list[0], pkh0.hex(), pk_hex_list[1])\n-        self.test_miniscript_expr(desc13, \"Bdemus\")\n+        miniscript_list.append(self.test_miniscript_expr(desc13, \"Bdemus\"))\n \n         # or_b(c:pk(key),a:and_n(c:pk(key),c:pk_h(key)))\n         pk_hex_list = self.get_pubkey_hex_list(2, keyhash_dict)\n         pkh0 = list(keyhash_dict)[0]\n         desc14 = \"or_b(c:pk({}),a:and_n(c:pk({}),c:pk_h({})))\".format(\n             *pk_hex_list, pkh0.hex())\n-        self.test_miniscript_expr(desc14, \"Bdemus\")\n+        miniscript_list.append(self.test_miniscript_expr(desc14, \"Bdemus\"))\n \n         # or_b(c:pk(key),sc:pk(key))\n         pk_hex_list = self.get_pubkey_hex_list(2, keyhash_dict)\n         desc15 = \"or_b(c:pk({}),sc:pk({}))\".format(*pk_hex_list)\n-        self.test_miniscript_expr(desc15, \"Bdemus\")\n+        miniscript_list.append(self.test_miniscript_expr(desc15, \"Bdemus\"))\n \n         # or_d(c:pk_h(key),c:pk_h(key))\n         pk_hex_list = self.get_pubkey_hex_list(2, keyhash_dict)\n         desc16 = \"or_d(c:pk({}),c:pk({}))\".format(*pk_hex_list)\n-        self.test_miniscript_expr(desc16, \"Bdemus\")\n+        miniscript_list.append(self.test_miniscript_expr(desc16, \"Bdemus\"))\n \n         # t:or_c(c:pk(key),and_v(vc:pk(key),or_c(c:pk(key),v:hash160(h))))\n         # and_v(or_c(c:pk(key),and_v(vc:pk(key),or_c(c:pk(key),v:hash160(h)))),1)\n@@ -169,7 +317,8 @@ def run_test(self):\n         desc17_alt = (\"and_v(or_c(c:pk({}),and_v(vc:pk({}),or_c(c:pk({}),\" +\n                      \"v:hash160({})))),1)\").format(*pk_hex_list,\n                                                    h160_digest.hex())\n-        self.test_miniscript_expr(desc17, \"Bufsm\", desc17_alt)\n+        miniscript_list.append(self.test_miniscript_expr(desc17, \"Bufsm\",\n+                                                         desc17_alt))\n \n         # t:or_c(c:pk(key),and_v(vc:pk(key),or_c(c:pk(key),v:sha256(h))))\n         # and_v(or_c(c:pk(key),and_v(vc:pk(key),or_c(c:pk(key),v:sha256(h)))),1)\n@@ -180,24 +329,25 @@ def run_test(self):\n         desc18_alt = (\"and_v(or_c(c:pk({}),and_v(vc:pk({}),\" +\n                      \"or_c(c:pk({}),v:sha256({})))),1)\").format(\n                          *pk_hex_list, sha256_digest.hex())\n-        self.test_miniscript_expr(desc18, \"Bufsm\", desc18_alt)\n+        miniscript_list.append(self.test_miniscript_expr(desc18, \"Bufsm\",\n+                                                         desc18_alt))\n \n         # or_i(and_v(vc:pk_h(key_local),hash256(h)),older(20))\n         h256_digest = list(hash256_dict)[0]\n         pkh0 = list(keyhash_dict)[0]\n         delay = 20\n         desc19 = \"or_i(and_v(vc:pk_h({}),hash256({})),older({}))\".format(\n             pkh0.hex(), h256_digest.hex(), delay)\n-        self.test_miniscript_expr(desc19, \"Bfm\")\n+        miniscript_list.append(self.test_miniscript_expr(desc19, \"Bfm\"))\n \n         # andor(c:pk(key),older(25),c:pk(key))\n         delay = 25\n         pk_hex_list = self.get_pubkey_hex_list(2, keyhash_dict)\n         desc20 = \"andor(c:pk({}),older({}),c:pk({}))\".format(\n             pk_hex_list[0], delay, pk_hex_list[1])\n-        self.test_miniscript_expr(desc20, \"Bdems\")\n+        miniscript_list.append(self.test_miniscript_expr(desc20, \"Bdems\"))\n \n-        # andor(c:pk(key),or_i(and_v(vc:pk_h(key),hash160(h)),older(35)),c:pk(key))\n+        # andor(c:pk(key),or_i(and_v(vc:pk_h(key),ripemd160(h)),older(35)),c:pk(key))\n         older = 35\n         pkh0 = list(keyhash_dict)[0]\n         pk_hex_list = self.get_pubkey_hex_list(2, keyhash_dict)\n@@ -206,7 +356,7 @@ def run_test(self):\n                   \"older({})),c:pk({}))\").format(\n             pk_hex_list[0], pkh0.hex(), ripemd160_digest.hex(), older,\n             pk_hex_list[1])\n-        self.test_miniscript_expr(desc21, \"Bdems\")\n+        miniscript_list.append(self.test_miniscript_expr(desc21, \"Bdems\"))\n \n         # thresh(k,c:pk(key),sc:pk(key),sc:pk(key),sdv:after(30))\n         n = 4\n@@ -215,15 +365,17 @@ def run_test(self):\n             pk_hex_list = self.get_pubkey_hex_list(n-1, keyhash_dict)\n             desc22 = (\"thresh({},c:pk({}),sc:pk({}),sc:pk({}),\" +\n                            \"sdv:after({}))\").format(k, *pk_hex_list, after)\n-            self.test_miniscript_expr(desc22, \"Bdmus\")\n+            miniscript_list.append(self.test_miniscript_expr(\n+                desc22, \"Bdmus\"))\n \n         # thresh(k,c:pk(key),sc:pk(key),sc:pk(key),sc:pk(key),sc:pk(key))\n         n = 5\n         for k in range(2, n):\n             pk_hex_list = self.get_pubkey_hex_list(n, keyhash_dict)\n             desc23 = (\"thresh({},c:pk({}),sc:pk({}),sc:pk({}),sc:pk({})\" +\n                            \",sc:pk({}))\").format(k, *pk_hex_list)\n-            self.test_miniscript_expr(desc23, \"Bdemus\")\n+            miniscript_list.append(self.test_miniscript_expr(\n+                desc23, \"Bdemus\"))\n \n         # or_d(thresh_m(1,key),or_b(thresh_m(3,key,key,key),su:after(50)))\n         # or_d(thresh_m(1,key),or_b(thresh_m(3,key,key,key),s:or_i(after(50),0)))\n@@ -241,7 +393,8 @@ def run_test(self):\n                                                       pk_hex_list[1],\n                                                       pk_hex_list[2],\n                                                       pk_hex_list[3], after)\n-        self.test_miniscript_expr(desc24, \"Bdemu\", desc24_alt)\n+        miniscript_list.append(self.test_miniscript_expr(\n+            desc24, \"Bdemu\", desc24_alt))\n \n         # uuj:and_v(v:thresh_m(2,key,key),after(10))\n         # or_i(or_i(j:and_v(v:thresh_m(2,key,key),after(time)),0),0)\n@@ -252,7 +405,8 @@ def run_test(self):\n             k, pk_hex_list[0], pk_hex_list[1], delay)\n         desc25_alt = (\"or_i(or_i(j:and_v(v:thresh_m({},{},{}),after({})),0),\" +\n                       \"0)\").format(k, pk_hex_list[0], pk_hex_list[1], delay)\n-        self.test_miniscript_expr(desc25, \"Bdsm\", desc25_alt)\n+        miniscript_list.append(self.test_miniscript_expr(\n+            desc25, \"Bdsm\", desc25_alt))\n \n         # or_b(un:thresh_m(k,key,key),al:older(delay))\n         # or_b(or_i(n:thresh_m(k,key,key),0),a:or_i(0,older(delay)))\n@@ -265,7 +419,14 @@ def run_test(self):\n                       \"a:or_i(0,older({})))\").format(k, pk_hex_list[0],\n                                                      pk_hex_list[1],\n                                                      older)\n-        self.test_miniscript_expr(desc26, \"Bdu\", desc26_alt)\n+        miniscript_list.append(self.test_miniscript_expr(desc26, \"Bdu\",\n+                                                         desc26_alt))\n+\n+        # Test Miniscript satisfaction of all test expressions.\n+        for ms in miniscript_list:\n+            self.test_miniscript_satisfaction(ms, keyhash_dict, sha256_dict,\n+                                              hash256_dict, ripemd160_dict,\n+                                              hash160_dict)\n \n \n if __name__ == '__main__':"
      },
      {
        "sha": "0efc514b321a90a03a84b584789a2e56f6fb2d4c",
        "filename": "test/functional/test_framework/miniscript.py",
        "status": "modified",
        "additions": 335,
        "deletions": 2,
        "changes": 337,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7a59782a2d5b8e65fd7d09e035eb35e7b2168824/test/functional/test_framework/miniscript.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7a59782a2d5b8e65fd7d09e035eb35e7b2168824/test/functional/test_framework/miniscript.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/miniscript.py?ref=7a59782a2d5b8e65fd7d09e035eb35e7b2168824",
        "patch": "@@ -3,8 +3,8 @@\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Classes and methods to encode and decode miniscripts\"\"\"\n-\n from enum import Enum\n+from itertools import product\n \n from .key import ECPubKey\n from .script import CScript, OP_ADD, OP_BOOLAND, OP_BOOLOR, OP_DUP, OP_ELSE, \\\n@@ -657,15 +657,94 @@ def _parse_expr_list(expr_list):\n         # No match found.\n         raise Exception(\"Malformed miniscript\")\n \n+    def _lift_sat(self):\n+        # Return satisfying witnesses if terminal node.\n+        if not self.children:\n+            return self._sat()\n+        child_sat_set_ls, child_dsat_set_ls = self._generate_child_sat_dsat()\n+        return self._lift_function(self._sat, child_sat_set_ls, child_dsat_set_ls)\n+\n+    def _lift_dsat(self):\n+        # Return non-satisfying witness if terminal node.\n+        if not self.children:\n+            return self._dsat()\n+        child_sat_set_ls, child_dsat_set_ls = self._generate_child_sat_dsat()\n+        return self._lift_function(self._dsat, child_sat_set_ls, child_dsat_set_ls)\n+\n+    def _lift_function(self, function, child_sat_set_ls, child_dsat_set_ls):\n+        # Applies (d)sat function on all child_sat_set x child_dsat_set\n+        # permutations. Returns list of unique (dis)satisfying witnesses.\n+        ret_ls = []\n+        for child_sat_set in child_sat_set_ls:\n+            for child_dsat_set in child_dsat_set_ls:\n+                for ret in function(child_sat_set, child_dsat_set):\n+                    if ret not in ret_ls:\n+                        # Order (d)sat elements with OLDER/AFTER\n+                        # SatType elements at beginning.\n+                        ret_older = []\n+                        ret_after = []\n+                        ret_ordered = []\n+                        valid = True\n+                        for element in ret:\n+                            # Handle None element from children,\n+                            # which represents lack of non-cannonical (d)sat.\n+                            if element is None:\n+                                valid = False\n+                                break\n+                            else:\n+                                if element[0] == SatType.OLDER:\n+                                    ret_older.append(element)\n+                                elif element[0] == SatType.AFTER:\n+                                    ret_after.append(element)\n+                                else:\n+                                    ret_ordered.append(element)\n+                        if valid is True:\n+                            ret_ordered = ret_older+ret_after+ret_ordered\n+                            # Append ordered (d)sat.\n+                            ret_ls.append(ret_ordered)\n+        return ret_ls\n+\n+    def _generate_child_sat_dsat(self):\n+        # Create list of lists of unique satisfying witnesses for each child.\n+        # [\n+        # [satx', satx'', satx'''],\n+        # [saty', saty'', saty'''],\n+        # [satz', satz'', satz''']\n+        # ]\n+        child_sat_var_ls = []\n+        child_dsat_var_ls = []\n+        for child in self.children:\n+            child_sat_var_ls.append(child.sat) # what if multiple are returned?\n+            child_dsat_var_ls.append(child.dsat)\n+\n+        # Generate all permutations of sets each containing a single satisfying\n+        # witness element from each child.\n+        # [\n+        # [satx', saty', satz'],\n+        # [satx', saty', satz''],\n+        # [satx', saty'', satz''],\n+        # [satx'', saty'', satz''],\n+        # [satx'', saty'', satz'],\n+        # [satx'', saty', satz'], ...\n+        # ]\n+\n+        # List iterators are reusable.\n+        child_sat_set_ls = list(product(*child_sat_var_ls))\n+        child_dsat_set_ls = list(product(*child_dsat_var_ls))\n+        return child_sat_set_ls, child_dsat_set_ls\n+\n+\n     def construct_just_1(self):\n         self._construct(NodeType.JUST_1, Property().from_string(\"Bzufm\"),\n                         [],\n+                        self._just_1_sat, self._just_1_dsat,\n                         [1], '1')\n         return self\n \n     def construct_just_0(self):\n         self._construct(NodeType.JUST_0, Property().from_string(\"Bzudems\"),\n                         [],\n+                        self._just_0_sat, self._just_0_dsat,\n                         [0], '0')\n         return self\n \n@@ -674,6 +753,7 @@ def construct_pk(self, pubkey):\n         self._pk = [pubkey.get_bytes()]\n         self._construct(NodeType.PK, Property().from_string(\"Konudems\"),\n                         [],\n+                        self._pk_sat, self._pk_dsat,\n                         [pubkey.get_bytes()], 'pk('+self._pk[0].hex()+')'\n                         )\n         return self\n@@ -683,6 +763,7 @@ def construct_pk_h(self, pk_hash_digest):\n         self._pk_h = pk_hash_digest\n         self._construct(NodeType.PK_H, Property().from_string(\"Knudems\"),\n                         [],\n+                        self._pk_h_sat, self._pk_h_dsat,\n                         [OP_DUP, OP_HASH160, pk_hash_digest, OP_EQUALVERIFY],\n                         'pk_h('+pk_hash_digest.hex()+')'\n                         )\n@@ -693,6 +774,7 @@ def construct_older(self, delay):\n         self._delay = delay\n         self._construct(NodeType.OLDER, Property().from_string(\"Bzfm\"),\n                         [],\n+                        self._older_sat, self._older_dsat,\n                         [delay, OP_CHECKSEQUENCEVERIFY],\n                         'older('+str(delay)+')'\n                         )\n@@ -703,6 +785,7 @@ def construct_after(self, time):\n         self._time = time\n         self._construct(NodeType.AFTER, Property().from_string(\"Bzfm\"),\n                         [],\n+                        self._after_sat, self._after_dsat,\n                         [time, OP_CHECKLOCKTIMEVERIFY],\n                         'after('+str(time)+')'\n                         )\n@@ -713,6 +796,7 @@ def construct_sha256(self, hash_digest):\n         self._sha256 = hash_digest\n         self._construct(NodeType.SHA256, Property().from_string(\"Bonudm\"),\n                         [],\n+                        self._sha256_sat, self._sha256_dsat,\n                         [OP_SIZE, 32, OP_EQUALVERIFY,\n                          OP_SHA256, hash_digest, OP_EQUAL],\n                         'sha256('+hash_digest.hex()+')'\n@@ -724,6 +808,7 @@ def construct_hash256(self, hash_digest):\n         self._hash256 = hash_digest\n         self._construct(NodeType.HASH256, Property().from_string(\"Bonudm\"),\n                         [],\n+                        self._hash256_sat, self._hash256_dsat,\n                         [OP_SIZE, 32, OP_EQUALVERIFY,\n                          OP_HASH256, hash_digest, OP_EQUAL],\n                         'hash256('+hash_digest.hex()+')'\n@@ -735,6 +820,7 @@ def construct_ripemd160(self, hash_digest):\n         self._ripemd160 = hash_digest\n         self._construct(NodeType.RIPEMD160, Property().from_string(\"Bonudm\"),\n                         [],\n+                        self._ripemd160_sat, self._ripemd160_dsat,\n                         [OP_SIZE, 32, OP_EQUALVERIFY,\n                          OP_RIPEMD160, hash_digest, OP_EQUAL],\n                         'ripemd160('+hash_digest.hex()+')'\n@@ -746,6 +832,7 @@ def construct_hash160(self, hash_digest):\n         self._hash160 = hash_digest\n         self._construct(NodeType.HASH160, Property().from_string(\"Bonudm\"),\n                         [],\n+                        self._hash160_sat, self._hash160_dsat,\n                         [OP_SIZE, 32, OP_EQUALVERIFY,\n                          OP_HASH160, hash_digest, OP_EQUAL],\n                         'hash160('+hash_digest.hex()+')'\n@@ -764,11 +851,11 @@ def construct_thresh_m(self, k, keys_n):\n             desc += \",\" if idx != (n-1) else \")\"\n         self._construct(NodeType.THRESH_M, Property().from_string(prop_str),\n                         [],\n+                        self._thresh_m_sat, self._thresh_m_dsat,\n                         [k, *self._pk_n, n, OP_CHECKMULTISIG], desc\n                         )\n         return self\n \n-\n     def construct_and_v(self, child_x, child_y):\n         prop_str = \"\"\n         prop_str += \"B\" if child_x.p.V and child_y.p.B else \"\"\n@@ -784,6 +871,7 @@ def construct_and_v(self, child_x, child_y):\n         prop_str += \"s\" if child_x.p.s or child_y.p.s else \"\"\n         self._construct(NodeType.AND_V, Property().from_string(prop_str),\n                         [child_x, child_y],\n+                        self._and_v_sat, self._and_v_dsat,\n                         child_x._script+child_y._script,\n                         \"and_v(\"+child_x.desc+\",\"+child_y.desc+\")\"\n                         )\n@@ -806,6 +894,7 @@ def construct_and_b(self, child_x, child_y):\n         prop_str += \"s\" if child_x.p.s or child_y.p.s else \"\"\n         self._construct(NodeType.AND_B, Property().from_string(prop_str),\n                         [child_x, child_y],\n+                        self._and_b_sat, self._and_b_dsat,\n                         child_x._script+child_y._script+[OP_BOOLAND],\n                         \"and_b(\"+child_x.desc+\",\"+child_y.desc+\")\"\n                         )\n@@ -826,6 +915,7 @@ def construct_and_n(self, child_x, child_y):\n         prop_str += \"s\" if child_x.p.s or child_y.p.s else \"\"\n         self._construct(NodeType.AND_N, Property().from_string(prop_str),\n                         [child_x, child_y],\n+                        self._and_n_sat, self._and_n_dsat,\n                         child_x._script+[OP_NOTIF, 0, OP_ELSE]+child_y._script+[\n                             OP_ENDIF],\n                         \"and_n(\"+child_x.desc+\",\"+child_y.desc+\")\"\n@@ -847,6 +937,7 @@ def construct_or_b(self, child_x, child_z):\n         prop_str += \"s\" if child_x.p.s and child_z.p.s else \"\"\n         self._construct(NodeType.OR_B, Property().from_string(prop_str),\n                         [child_x, child_z],\n+                        self._or_b_sat, self._or_b_dsat,\n                         child_x._script+child_z._script+[OP_BOOLOR],\n                         \"or_b(\"+child_x.desc+\",\"+child_z.desc+\")\"\n                         )\n@@ -868,6 +959,7 @@ def construct_or_d(self, child_x, child_z):\n         prop_str += \"s\" if child_x.p.s and child_z.p.s else \"\"\n         self._construct(NodeType.OR_D, Property().from_string(prop_str),\n                         [child_x, child_z],\n+                        self._or_d_sat, self._or_d_dsat,\n                         child_x._script+[OP_IFDUP, OP_NOTIF]+child_z._script+[\n                             OP_ENDIF],\n                         \"or_d(\"+child_x.desc+\",\"+child_z.desc+\")\"\n@@ -886,6 +978,7 @@ def construct_or_c(self, child_x, child_z):\n         prop_str += \"s\" if child_x.p.s and child_z.p.s else \"\"\n         self._construct(NodeType.OR_C, Property().from_string(prop_str),\n                         [child_x, child_z],\n+                        self._or_c_sat, self._or_c_dsat,\n                         child_x._script+[OP_NOTIF]+child_z._script+[OP_ENDIF],\n                         \"or_c(\"+child_x.desc+\",\"+child_z.desc+\")\"\n                         )\n@@ -907,6 +1000,7 @@ def construct_or_i(self, child_x, child_z):\n         prop_str += \"s\" if child_x.p.s and child_z.p.s else \"\"\n         self._construct(NodeType.OR_I, Property().from_string(prop_str),\n                         [child_x, child_z],\n+                        self._or_i_sat, self._or_i_dsat,\n                         [OP_IF]+child_x._script+[OP_ELSE]+child_z._script+[\n                         OP_ENDIF],\n                         \"or_i(\"+child_x.desc+\",\"+child_z.desc+\")\"\n@@ -932,6 +1026,7 @@ def construct_andor(self, child_x, child_y, child_z):\n         prop_str += \"s\" if child_z.p.s and (child_x.p.s or child_y.p.s) else \"\"\n         self._construct(NodeType.ANDOR, Property().from_string(prop_str),\n                         [child_x, child_y, child_z],\n+                        self._andor_sat, self._andor_dsat,\n                         child_x._script+[OP_NOTIF]+child_z._script+[\n                         OP_ELSE]+child_y._script+[OP_ENDIF],\n                         \"andor(\"+child_x.desc+\",\"+child_y.desc+\",\"\n@@ -951,6 +1046,7 @@ def construct_a(self, child_x):\n         tag = \"a\" if child_x.t.name.startswith('WRAP_') else \"a:\"\n         self._construct(NodeType.WRAP_A, Property().from_string(prop_str),\n                         [child_x],\n+                        self._a_sat, self._a_dsat,\n                         [OP_TOALTSTACK]+child_x._script+[OP_FROMALTSTACK],\n                         tag+child_x.desc\n                         )\n@@ -968,6 +1064,7 @@ def construct_s(self, child_x):\n         tag = \"s\" if child_x.t.name.startswith('WRAP_') else \"s:\"\n         self._construct(NodeType.WRAP_S, Property().from_string(prop_str),\n                         [child_x],\n+                        self._s_sat, self._s_dsat,\n                         [OP_SWAP]+child_x._script, tag+child_x.desc\n                         )\n         return self\n@@ -984,6 +1081,7 @@ def construct_c(self, child_x):\n         tag = \"c\" if child_x.t.name.startswith('WRAP_') else \"c:\"\n         self._construct(NodeType.WRAP_C, Property().from_string(prop_str),\n                         [child_x],\n+                        self._c_sat, self._c_dsat,\n                         child_x._script+[OP_CHECKSIG], tag+child_x.desc\n                         )\n         return self\n@@ -999,6 +1097,7 @@ def construct_t(self, child_x):\n         tag = \"t\" if child_x.t.name.startswith('WRAP_') else \"t:\"\n         self._construct(NodeType.WRAP_T, Property().from_string(prop_str),\n                         [child_x],\n+                        self._t_sat, self._t_dsat,\n                         child_x._script+[1], tag+child_x.desc\n                         )\n         return self\n@@ -1014,6 +1113,7 @@ def construct_d(self, child_x):\n         tag = \"d\" if child_x.t.name.startswith('WRAP_') else \"d:\"\n         self._construct(NodeType.WRAP_D, Property().from_string(prop_str),\n                         [child_x],\n+                        self._d_sat, self._d_dsat,\n                         [OP_DUP, OP_IF]+child_x._script+[OP_ENDIF],\n                         tag+child_x.desc\n                         )\n@@ -1040,6 +1140,7 @@ def construct_v(self, child_x):\n             script = child_x._script+[OP_VERIFY]\n         self._construct(NodeType.WRAP_V, Property().from_string(prop_str),\n                         [child_x],\n+                        self._v_sat, self._v_dsat,\n                         script, tag+child_x.desc)\n         return self\n \n@@ -1056,6 +1157,7 @@ def construct_j(self, child_x):\n         script = [OP_SIZE, OP_0NOTEQUAL, OP_IF]+child_x._script+[OP_ENDIF]\n         self._construct(NodeType.WRAP_J, Property().from_string(prop_str),\n                         [child_x],\n+                        self._j_sat, self._j_dsat,\n                         script, tag+child_x.desc)\n         return self\n \n@@ -1073,6 +1175,7 @@ def construct_n(self, child_x):\n         tag = \"n\" if child_x.t.name.startswith('WRAP_') else \"n:\"\n         self._construct(NodeType.WRAP_N, Property().from_string(prop_str),\n                         [child_x],\n+                        self._n_sat, self._n_dsat,\n                         child_x._script+[OP_0NOTEQUAL], tag+child_x.desc)\n         return self\n \n@@ -1088,6 +1191,7 @@ def construct_l(self, child_x):\n         script = [OP_IF, 0, OP_ELSE]+child_x._script+[OP_ENDIF]\n         self._construct(NodeType.WRAP_L, Property().from_string(prop_str),\n                         [child_x],\n+                        self._l_sat, self._l_dsat,\n                         script, tag+child_x.desc)\n         return self\n \n@@ -1103,6 +1207,7 @@ def construct_u(self, child_x):\n         script = [OP_IF]+child_x._script+[OP_ELSE, 0, OP_ENDIF]\n         self._construct(NodeType.WRAP_U, Property().from_string(prop_str),\n                         [child_x],\n+                        self._u_sat, self._u_dsat,\n                         script, tag+child_x.desc)\n         return self\n \n@@ -1150,20 +1255,248 @@ def construct_thresh(self, k, children_n):\n \n         self._construct(NodeType.THRESH, Property().from_string(prop_str),\n                         children_n,\n+                        self._thresh_sat, self._thresh_dsat,\n                         script, desc\n                         )\n         return self\n \n     def _construct(self,\n                    node_type, node_prop,\n                    children,\n+                   sat, dsat,\n                    script, desc):\n         self.t = node_type\n         self.p = node_prop\n         self.children = children\n+        self._sat = sat\n+        self._dsat = dsat\n+        self.sat = self._lift_sat()\n+        self.dsat = self._lift_dsat()\n         self._script = script\n         self.desc = desc\n \n+    # sat/dsat methods for terminal node types:\n+    def _just_1_sat(self):\n+        return [[]]\n+\n+    def _just_1_dsat(self):\n+        return [[]]\n+\n+    def _just_0_sat(self):\n+        return [[]]\n+\n+    def _just_0_dsat(self):\n+        return [[]]\n+\n+    def _pk_sat(self):\n+        # Returns (SIGNATURE, 33B_PK) tuple.\n+        return [[(SatType.SIGNATURE, self._pk[0])]]\n+\n+    def _pk_dsat(self):\n+        return [[(SatType.DATA, b'')]]\n+\n+    def _pk_h_sat(self):\n+        # Returns (SIGNATURE, 32B_PK_HASH) tuple.\n+        return [[(SatType.SIGNATURE, self._pk_h),\n+                 (SatType.KEY_AND_HASH160_PREIMAGE, self._pk_h)]]\n+\n+    def _pk_h_dsat(self):\n+        return [[(SatType.DATA, b''),\n+                (SatType.KEY_AND_HASH160_PREIMAGE, self._pk_h)]]\n+\n+    def _older_sat(self):\n+        return [[(SatType.OLDER, self._delay)]]\n+\n+    def _older_dsat(self):\n+        return [[]]\n+\n+    def _after_sat(self):\n+        return [[(SatType.AFTER, self._time)]]\n+\n+    def _after_dsat(self):\n+        return [[]]\n+\n+    def _sha256_sat(self):\n+        return [[(SatType.SHA256_PREIMAGE, self._sha256)]]\n+\n+    def _sha256_dsat(self):\n+        return [[(SatType.DATA, bytes(32))]]\n+\n+    def _hash256_sat(self):\n+        return [[(SatType.HASH256_PREIMAGE, self._hash256)]]\n+\n+    def _hash256_dsat(self):\n+        return [[(SatType.DATA, bytes(32))]]\n+\n+    def _ripemd160_sat(self):\n+        return [[(SatType.RIPEMD160_PREIMAGE, self._ripemd160)]]\n+\n+    def _ripemd160_dsat(self):\n+        return [[(SatType.DATA, bytes(32))]]\n+\n+    def _hash160_sat(self):\n+        return [[(SatType.HASH160_PREIMAGE, self._hash160)]]\n+\n+    def _hash160_dsat(self):\n+        return [[(SatType.DATA, bytes(32))]]\n+\n+    def _thresh_m_sat(self):\n+        thresh_m_sat_ls = []\n+        n = len(self._pk_n)\n+        for i in range(2**n):\n+            if bin(i).count(\"1\") == self._k:\n+                sat = [(SatType.DATA, b'')]\n+                for j in range(n):\n+                    if ((1 << j) & i) != 0:\n+                        sat.append((SatType.SIGNATURE, self._pk_n[j]))\n+                thresh_m_sat_ls.append(sat)\n+        return thresh_m_sat_ls\n+\n+    def _thresh_m_dsat(self):\n+        return [[(SatType.DATA, b'')]*(self._k+1)]\n+\n+    # sat/dsat methods for node types with children:\n+        # sat must return list of possible satisfying witnesses.\n+        # dsat must return (unique) non-satisfying witness if available.\n+\n+    # child_sat_set: [child_x_sat, child_y_dsat, ...]\n+    # dsat child_dsat_set: [child_x_dsat, child_y_dsat, ...]\n+\n+    def _and_v_sat(self, child_sat_set, child_dsat_set):\n+        return [child_sat_set[1]+child_sat_set[0]]\n+\n+    def _and_v_dsat(self, child_sat_set, child_dsat_set):\n+        return [[]]\n+\n+    def _and_b_sat(self, child_sat_set, child_dsat_set):\n+        return [child_sat_set[1]+child_sat_set[0]]\n+\n+    def _and_b_dsat(self, child_sat_set, child_dsat_set):\n+        return [child_dsat_set[1]+child_dsat_set[0]]\n+\n+    def _and_n_sat(self, child_sat_set, child_dsat_set):\n+        return [child_sat_set[1]+child_sat_set[0]]\n+\n+    def _and_n_dsat(self, child_sat_set, child_dsat_set):\n+        return [child_dsat_set[0]]\n+\n+    def _or_b_sat(self, child_sat_set, child_dsat_set):\n+        return [child_dsat_set[1]+child_sat_set[0],\n+                child_sat_set[1]+child_dsat_set[0]]\n+\n+    def _or_b_dsat(self, child_sat_set, child_dsat_set):\n+        return [child_dsat_set[1]+child_dsat_set[0]]\n+\n+    def _or_d_sat(self, child_sat_set, child_dsat_set):\n+        return [child_sat_set[0],\n+                child_sat_set[1]+child_dsat_set[0]]\n+\n+    def _or_d_dsat(self, child_sat_set, child_dsat_set):\n+        return [child_dsat_set[1]+child_dsat_set[0]]\n+\n+    def _or_c_sat(self, child_sat_set, child_dsat_set):\n+        return [child_sat_set[0],\n+                child_sat_set[1]+child_dsat_set[0]]\n+\n+    def _or_c_dsat(self, child_sat_set, child_dsat_set):\n+        return [[]]\n+\n+    def _or_i_sat(self, child_sat_set, child_dsat_set):\n+        return [child_sat_set[0]+[(SatType.DATA, b'\\x01')],\n+                child_sat_set[1]+[(SatType.DATA, b'')]]\n+\n+    def _or_i_dsat(self, child_sat_set, child_dsat_set):\n+        return [[(SatType.DATA, b'\\x01')]+child_dsat_set[1] + [\n+                (SatType.DATA, b'')]]\n+\n+    def _andor_sat(self, child_sat_set, child_dsat_set):\n+        return [child_sat_set[1]+child_sat_set[0],\n+                child_sat_set[2]+child_dsat_set[0]]\n+\n+    def _andor_dsat(self, child_sat_set, child_dsat_set):\n+        return [child_dsat_set[2]+child_dsat_set[0]]\n+\n+    def _a_sat(self, child_sat_set, child_dsat_set):\n+        return [child_sat_set[0]]\n+\n+    def _a_dsat(self, child_sat_set, child_dsat_set):\n+        return [child_dsat_set[0]]\n+\n+    def _s_sat(self, child_sat_set, child_dsat_set):\n+        return [child_sat_set[0]]\n+\n+    def _s_dsat(self, child_sat_set, child_dsat_set):\n+        return [child_dsat_set[0]]\n+\n+    def _c_sat(self, child_sat_set, child_dsat_set):\n+        return [child_sat_set[0]]\n+\n+    def _c_dsat(self, child_sat_set, child_dsat_set):\n+        return [child_dsat_set[0]]\n+\n+    def _t_sat(self, child_sat_set, child_dsat_set):\n+        return [child_sat_set[0]]\n+\n+    def _t_dsat(self, child_sat_set, child_dsat_set):\n+        return [[]]\n+\n+    def _d_sat(self, child_sat_set, child_dsat_set):\n+        return [child_sat_set[0]+[(SatType.DATA, b'\\x01')]]\n+\n+    def _d_dsat(self, child_sat_set, child_dsat_set):\n+        return [[(SatType.DATA, b'')]]\n+\n+    def _v_sat(self, child_sat_set, child_dsat_set):\n+        return [child_sat_set[0]]\n+\n+    def _v_dsat(self, child_sat_set, child_dsat_set):\n+        return [[]]\n+\n+    def _j_sat(self, child_sat_set, child_dsat_set):\n+        return [child_sat_set[0]]\n+\n+    def _j_dsat(self, child_sat_set, child_dsat_set):\n+        return [[(SatType.DATA, b'')]]\n+\n+    def _n_sat(self, child_sat_set, child_dsat_set):\n+        return [child_sat_set[0]]\n+\n+    def _n_dsat(self, child_sat_set, child_dsat_set):\n+        return [child_dsat_set[0]]\n+\n+    def _l_sat(self, child_sat_set, child_dsat_set):\n+        return [child_sat_set[0]+[(SatType.DATA, b'')]]\n+\n+    def _l_dsat(self, child_sat_set, child_dsat_set):\n+        return [[(SatType.DATA, b'\\x01')]]\n+\n+    def _u_sat(self, child_sat_set, child_dsat_set):\n+        return [child_sat_set[0]+[(SatType.DATA, b'\\x01')]]\n+\n+    def _u_dsat(self, child_sat_set, child_dsat_set):\n+        return [[(SatType.DATA, b'')]]\n+\n+    def _thresh_sat(self, child_sat_set, child_dsat_set):\n+        thresh_sat_ls = []\n+        n = len(self.children)\n+        for i in range(2**n):\n+            if bin(i).count(\"1\") is self._k:\n+                sat = []\n+                for j in reversed(range(n)):\n+                    if ((1 << j) & i) != 0:\n+                        sat.extend(child_sat_set[j])\n+                    else:\n+                        sat.extend(child_dsat_set[j])\n+                thresh_sat_ls.append(sat)\n+        return thresh_sat_ls\n+\n+    def _thresh_dsat(self, child_sat_set, child_dsat_set):\n+        thres_dsat = []\n+        for child_dsat in child_dsat_set:\n+            thres_dsat.extend(child_dsat)\n+        return [thres_dsat]\n+\n+\n     # Utility methods.\n     @staticmethod\n     def _coerce_to_int(expr):"
      }
    ]
  },
  {
    "sha": "f8a30b4c76f32ffe7d313ecbcdea18d900ef4d52",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmOGEzMGI0Yzc2ZjMyZmZlN2QzMTNlY2JjZGVhMThkOTAwZWY0ZDUy",
    "commit": {
      "author": {
        "name": "James Chiang",
        "email": "james.chiangwu@gmail.com",
        "date": "2020-01-20T20:15:21Z"
      },
      "committer": {
        "name": "James Chiang",
        "email": "james.chiangwu@gmail.com",
        "date": "2020-03-14T13:52:31Z"
      },
      "message": "TestFramework: Add non-canonical (d)sat methods\n\nThere are non-canonical, yet valid, (dis)satisfying witnesses for\ncertain miniscript expressions. These are added for completeness.",
      "tree": {
        "sha": "e6548b8ce22cb32d9ca248543e001db5ff2e8a69",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e6548b8ce22cb32d9ca248543e001db5ff2e8a69"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f8a30b4c76f32ffe7d313ecbcdea18d900ef4d52",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f8a30b4c76f32ffe7d313ecbcdea18d900ef4d52",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f8a30b4c76f32ffe7d313ecbcdea18d900ef4d52",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f8a30b4c76f32ffe7d313ecbcdea18d900ef4d52/comments",
    "author": {
      "login": "jachiang",
      "id": 26572234,
      "node_id": "MDQ6VXNlcjI2NTcyMjM0",
      "avatar_url": "https://avatars.githubusercontent.com/u/26572234?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jachiang",
      "html_url": "https://github.com/jachiang",
      "followers_url": "https://api.github.com/users/jachiang/followers",
      "following_url": "https://api.github.com/users/jachiang/following{/other_user}",
      "gists_url": "https://api.github.com/users/jachiang/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jachiang/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jachiang/subscriptions",
      "organizations_url": "https://api.github.com/users/jachiang/orgs",
      "repos_url": "https://api.github.com/users/jachiang/repos",
      "events_url": "https://api.github.com/users/jachiang/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jachiang/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jachiang",
      "id": 26572234,
      "node_id": "MDQ6VXNlcjI2NTcyMjM0",
      "avatar_url": "https://avatars.githubusercontent.com/u/26572234?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jachiang",
      "html_url": "https://github.com/jachiang",
      "followers_url": "https://api.github.com/users/jachiang/followers",
      "following_url": "https://api.github.com/users/jachiang/following{/other_user}",
      "gists_url": "https://api.github.com/users/jachiang/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jachiang/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jachiang/subscriptions",
      "organizations_url": "https://api.github.com/users/jachiang/orgs",
      "repos_url": "https://api.github.com/users/jachiang/repos",
      "events_url": "https://api.github.com/users/jachiang/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jachiang/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7a59782a2d5b8e65fd7d09e035eb35e7b2168824",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7a59782a2d5b8e65fd7d09e035eb35e7b2168824",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7a59782a2d5b8e65fd7d09e035eb35e7b2168824"
      }
    ],
    "stats": {
      "total": 111,
      "additions": 110,
      "deletions": 1
    },
    "files": [
      {
        "sha": "1edd2071021082d754d76c760e66c8cb1821031a",
        "filename": "test/functional/feature_miniscript.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f8a30b4c76f32ffe7d313ecbcdea18d900ef4d52/test/functional/feature_miniscript.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f8a30b4c76f32ffe7d313ecbcdea18d900ef4d52/test/functional/feature_miniscript.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_miniscript.py?ref=f8a30b4c76f32ffe7d313ecbcdea18d900ef4d52",
        "patch": "@@ -56,7 +56,7 @@ def test_miniscript_satisfaction(self, node, keyhash_dict, sha256_dict,\n                                                tx.vout[0].nValue)\n         # Test each canonical AND non-canonical\n         # satisfying witness for spending transaction.\n-        for wit_sat in node.sat:\n+        for wit_sat in node.sat+node.sat_ncan:\n             witness_arr = []\n             for sat_element in wit_sat:\n                 # Set sequence for input at index 0."
      },
      {
        "sha": "97640836256cb9f166c9b1631aa948ec9b6f2fa3",
        "filename": "test/functional/test_framework/miniscript.py",
        "status": "modified",
        "additions": 109,
        "deletions": 0,
        "changes": 109,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f8a30b4c76f32ffe7d313ecbcdea18d900ef4d52/test/functional/test_framework/miniscript.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f8a30b4c76f32ffe7d313ecbcdea18d900ef4d52/test/functional/test_framework/miniscript.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/miniscript.py?ref=f8a30b4c76f32ffe7d313ecbcdea18d900ef4d52",
        "patch": "@@ -733,6 +733,80 @@ def _generate_child_sat_dsat(self):\n         child_dsat_set_ls = list(product(*child_dsat_var_ls))\n         return child_sat_set_ls, child_dsat_set_ls\n \n+    @property\n+    def sat_ncan(self):\n+        \"\"\"Retrieve non-canonical satisfactions of miniscript object\"\"\"\n+        if self._sat_ncan == [[None]]:\n+            return []\n+        else:\n+            return self._sat_ncan\n+\n+    @property\n+    def dsat_ncan(self):\n+        \"\"\"Retrieve non-canonical dissatisfactions of miniscript object\"\"\"\n+        if self._dsat_ncan == [[None]]:\n+            return []\n+        else:\n+            return self._dsat_ncan\n+\n+    def _lift_sat_ncan(self):\n+        if not self.children:\n+            return [[None]]\n+\n+        (child_sat_n_can_set_ls,\n+         child_dsat_n_can_set_ls) = self._generate_child_sat_dsat_ncan()\n+\n+        sat_ncan_ls = self._lift_function(\n+            self._sat, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+        sat_ncan_ls += self._lift_function(\n+            self._sat_ncan, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+\n+        # Check if already in sat_can\n+        sat__ncan_ls_ret = []\n+        for sat_ncan in sat_ncan_ls:\n+            if sat_ncan not in self.sat:\n+                sat__ncan_ls_ret.append(sat_ncan)\n+        if len(sat__ncan_ls_ret) == 0:\n+            return [[None]]\n+        else:\n+            return sat__ncan_ls_ret\n+\n+    def _lift_dsat_ncan(self):\n+        if not self.children:\n+            return [[None]]\n+\n+        (child_sat_n_can_set_ls,\n+         child_dsat_n_can_set_ls) = self._generate_child_sat_dsat_ncan()\n+\n+        dsat_ncan_ls = self._lift_function(\n+            self._dsat, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+        dsat_ncan_ls += self._lift_function(\n+            self._dsat_ncan, child_sat_n_can_set_ls, child_dsat_n_can_set_ls)\n+\n+        # Check if already in dsat_can\n+        dsat__ncan_ls_ret = []\n+        for dsat_ncan in dsat_ncan_ls:\n+            if dsat_ncan not in self.dsat:\n+                dsat__ncan_ls_ret.append(dsat_ncan)\n+        if len(dsat__ncan_ls_ret) == 0:\n+            return [[None]]\n+        else:\n+            return dsat__ncan_ls_ret\n+\n+    def _generate_child_sat_dsat_ncan(self):\n+        child_sat_n_can_var_ls = []\n+        child_dsat_n_can_var_ls = []\n+\n+        for child in self.children:\n+            child_sat_n_can_var_ls.append(child.sat+child._sat_ncan)\n+            child_dsat_n_can_var_ls.append(child.dsat+child._dsat_ncan)\n+\n+        # List iterators are reusable.\n+        child_sat_n_can_set_ls = list(product(*child_sat_n_can_var_ls))\n+        child_dsat_n_can_set_ls = list(product(*child_dsat_n_can_var_ls))\n+\n+        return (child_sat_n_can_set_ls,\n+                child_dsat_n_can_set_ls)\n \n     def construct_just_1(self):\n         self._construct(NodeType.JUST_1, Property().from_string(\"Bzufm\"),\n@@ -1272,6 +1346,8 @@ def _construct(self,\n         self._dsat = dsat\n         self.sat = self._lift_sat()\n         self.dsat = self._lift_dsat()\n+        self._sat_ncan = self._lift_sat_ncan()\n+        self._dsat_ncan = self._lift_dsat_ncan()\n         self._script = script\n         self.desc = desc\n \n@@ -1496,6 +1572,39 @@ def _thresh_dsat(self, child_sat_set, child_dsat_set):\n             thres_dsat.extend(child_dsat)\n         return [thres_dsat]\n \n+    def _sat_ncan(self, child_sat_set, child_dsat_set):\n+        if self.t is NodeType.OR_B:\n+            return [child_sat_set[1]+child_sat_set[0]]\n+        else:\n+            return [[None]]\n+\n+    def _dsat_ncan(self, child_sat_set, child_dsat_set):\n+        if self.t is NodeType.ANDOR:\n+            return [child_dsat_set[1]+child_sat_set[0]]\n+        elif self.t is NodeType.AND_V:\n+            return [child_dsat_set[1]+child_sat_set[0]]\n+        elif self.t is NodeType.AND_B:\n+            return [child_sat_set[1]+child_dsat_set[0],\n+                    child_dsat_set[1]+child_sat_set[0]]\n+        elif self.t is NodeType.THRESH:\n+            thresh_dsat_ls = []\n+            n = len(self.children)\n+            for i in range(2**n):\n+                if bin(i).count(\"1\") != self._k and \\\n+                        bin(i).count(\"1\") != 0:\n+                    sat = []\n+                    for j in reversed(range(n)):\n+                        if ((1 << j) & i) != 0:\n+                            sat.extend(child_sat_set[j])\n+                        else:\n+                            sat.extend(child_dsat_set[j])\n+                    thresh_dsat_ls.append(sat)\n+            return thresh_dsat_ls\n+        elif self.t is NodeType.WRAP_J:\n+            return [[None]] if child_dsat_set[0] is [(SatType.DATA, b'')] \\\n+                else [child_dsat_set[0]]\n+        else:\n+            return [[None]]\n \n     # Utility methods.\n     @staticmethod"
      }
    ]
  }
]