[
  {
    "sha": "b8cd2a429271b7af12e98186449ddc00fc7580e6",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiOGNkMmE0MjkyNzFiN2FmMTJlOTgxODY0NDlkZGMwMGZjNzU4MGU2",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-07-29T06:07:59Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2021-08-20T19:49:50Z"
      },
      "message": "Add references for the generator/constant used in Bech32(m)",
      "tree": {
        "sha": "66a68e294ecac7731a40ca0a2c3e8bb4311c19f8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/66a68e294ecac7731a40ca0a2c3e8bb4311c19f8"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b8cd2a429271b7af12e98186449ddc00fc7580e6",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b8cd2a429271b7af12e98186449ddc00fc7580e6",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b8cd2a429271b7af12e98186449ddc00fc7580e6",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b8cd2a429271b7af12e98186449ddc00fc7580e6/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4fc15d15667d9d9c4fb5515ce73c05b4596298ec",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4fc15d15667d9d9c4fb5515ce73c05b4596298ec",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4fc15d15667d9d9c4fb5515ce73c05b4596298ec"
      }
    ],
    "stats": {
      "total": 34,
      "additions": 32,
      "deletions": 2
    },
    "files": [
      {
        "sha": "9da2488ef2afb60ed9970d5f70b6ad069b06697a",
        "filename": "src/bech32.cpp",
        "status": "modified",
        "additions": 32,
        "deletions": 2,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b8cd2a429271b7af12e98186449ddc00fc7580e6/src/bech32.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b8cd2a429271b7af12e98186449ddc00fc7580e6/src/bech32.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bech32.cpp?ref=b8cd2a429271b7af12e98186449ddc00fc7580e6",
        "patch": "@@ -66,6 +66,26 @@ uint32_t PolyMod(const data& v)\n     // the above example, `c` initially corresponds to 1 mod g(x), and after processing 2 inputs of\n     // v, it corresponds to x^2 + v0*x + v1 mod g(x). As 1 mod g(x) = 1, that is the starting value\n     // for `c`.\n+\n+    // The following Sage code constructs the generator used:\n+    //\n+    // B = GF(2) # Binary field\n+    // BP.<b> = B[] # Polynomials over the binary field\n+    // F_mod = b**5 + b**3 + 1\n+    // F.<f> = GF(32, modulus=F_mod, repr='int') # GF(32) definition\n+    // FP.<x> = F[] # Polynomials over GF(32)\n+    // E_mod = x**2 + F.fetch_int(9)*x + F.fetch_int(23)\n+    // E.<e> = F.extension(E_mod) # GF(1024) extension field definition\n+    // for p in divisors(E.order() - 1): # Verify e has order 1023.\n+    //    assert((e**p == 1) == (p % 1023 == 0))\n+    // G = lcm([(e**i).minpoly() for i in range(997,1000)])\n+    // print(G) # Print out the generator\n+    //\n+    // It demonstrates that g(x) is the least common multiple of the minimal polynomials\n+    // of 3 consecutive powers (997,998,999) of a primitive element (e) of GF(1024).\n+    // That guarantees it is, in fact, the generator of a primitive BCH code with cycle\n+    // length 1023 and distance 4. See https://en.wikipedia.org/wiki/BCH_code for more details.\n+\n     uint32_t c = 1;\n     for (const auto v_i : v) {\n         // We want to update `c` to correspond to a polynomial with one extra term. If the initial\n@@ -88,12 +108,21 @@ uint32_t PolyMod(const data& v)\n         // Then compute c1*x^5 + c2*x^4 + c3*x^3 + c4*x^2 + c5*x + v_i:\n         c = ((c & 0x1ffffff) << 5) ^ v_i;\n \n-        // Finally, for each set bit n in c0, conditionally add {2^n}k(x):\n+        // Finally, for each set bit n in c0, conditionally add {2^n}k(x). These constants can be\n+        // computed using the following Sage code (continuing the code above):\n+        //\n+        // for i in [1,2,4,8,16]: # Print out {1,2,4,8,16}*(g(x) mod x^6), packed in hex integers.\n+        //     v = 0\n+        //     for coef in reversed((F.fetch_int(i)*(G % x**6)).coefficients(sparse=True)):\n+        //         v = v*32 + coef.integer_representation()\n+        //     print(\"0x%x\" % v)\n+        //\n         if (c0 & 1)  c ^= 0x3b6a57b2; //     k(x) = {29}x^5 + {22}x^4 + {20}x^3 + {21}x^2 + {29}x + {18}\n         if (c0 & 2)  c ^= 0x26508e6d; //  {2}k(x) = {19}x^5 +  {5}x^4 +     x^3 +  {3}x^2 + {19}x + {13}\n         if (c0 & 4)  c ^= 0x1ea119fa; //  {4}k(x) = {15}x^5 + {10}x^4 +  {2}x^3 +  {6}x^2 + {15}x + {26}\n         if (c0 & 8)  c ^= 0x3d4233dd; //  {8}k(x) = {30}x^5 + {20}x^4 +  {4}x^3 + {12}x^2 + {30}x + {29}\n         if (c0 & 16) c ^= 0x2a1462b3; // {16}k(x) = {21}x^5 +     x^4 +  {8}x^3 + {24}x^2 + {21}x + {19}\n+\n     }\n     return c;\n }\n@@ -125,7 +154,8 @@ Encoding VerifyChecksum(const std::string& hrp, const data& values)\n     // PolyMod computes what value to xor into the final values to make the checksum 0. However,\n     // if we required that the checksum was 0, it would be the case that appending a 0 to a valid\n     // list of values would result in a new valid list. For that reason, Bech32 requires the\n-    // resulting checksum to be 1 instead. In Bech32m, this constant was amended.\n+    // resulting checksum to be 1 instead. In Bech32m, this constant was amended. See\n+    // https://gist.github.com/sipa/14c248c288c3880a3b191f978a34508e for details.\n     const uint32_t check = PolyMod(Cat(ExpandHRP(hrp), values));\n     if (check == EncodingConstant(Encoding::BECH32)) return Encoding::BECH32;\n     if (check == EncodingConstant(Encoding::BECH32M)) return Encoding::BECH32M;"
      }
    ]
  }
]