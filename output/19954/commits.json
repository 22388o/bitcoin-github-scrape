[
  {
    "sha": "1d3ec2a1fda7446323786a52da1fd109c01aa6fb",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxZDNlYzJhMWZkYTc0NDYzMjM3ODZhNTJkYTFmZDEwOWMwMWFhNmZi",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2020-10-09T03:27:27Z"
      },
      "committer": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2020-10-09T08:32:19Z"
      },
      "message": "Support bypassing range check in ReadCompactSize\n\nThis is needed when we want to encode an arbitrary number as CompactSize\nlike node service flags, which is a bitmask and could be bigger than the\nusual size of an object.",
      "tree": {
        "sha": "7d4dd26269bf40b771e360c64ca3a12388ec5880",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7d4dd26269bf40b771e360c64ca3a12388ec5880"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/1d3ec2a1fda7446323786a52da1fd109c01aa6fb",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQQzBAABCAAdFiEE5k2NRWFNsHVF2czBVN8G9ktVy78FAl+AIBQACgkQVN8G9ktV\ny7+hKh/+NEbP7SBxaGDrWtXI5reqWIiM1N7k7Savzq4uPXNXTyZn6Fobi8xK0oaD\n10K35aK+BO4++NUZpXEnC6tjPX13p/Mmbr0JWXUjaV7dZ62/G5Fbyl1LQOYmi4i/\n/ILceOmjVfjGpJWptEchPA98/VOTrP2mkjukUx1U/Le8WViCebDl52wD3GWT6s7I\nPTZUccW7lb2C2frd0wlQvBwYOkBqJBFyKPKw4G0ZEMp2DW5/DF/cooXakEduwjTq\nqi3SsjEl9Z/vUHoQKGbWDbHrMuQw6adLPWWHuX573rThDZbF/eSHLvgn44GjQVx3\nqMrfhKCeWmvkCvvn5xMGx4d/TVqeApbvxgnRsQxH4b6U888rJ2gWdAljV4qCC6qA\nPFUhg9w6ixZANiA6KA8SCDKSzBHb+kj4/agS1wiKkDUhCY6sqr4yC5MEF8/VvEiq\n4IcVDvt8zNk3wDDkXAv48W037mMJAQzx/T9QsFKLbJh8Zr3lhonSS2hmuztqkKu9\nwnpiuIfKrgaiXCdT50DwLUvoXGGDeLb1JLVuGuFqdWSqSvmi/gzr4Bn9Hu4/cxI/\n8yOo4lHHeA3sWA6kvkLSf7U7Qc/6uUcL/Gb27jit4vigf222G2+ktMYZSeNt3uS9\n0H2+lbawRNVuLGjMGkEvmv6zHCnLhup+Luxpqia+Kaz/RbPz9nM1Yy/936FmTpRy\n4IWr6xCC3ZEL3zWG+9E4lsctRNgLN/kyIux6hz5n8XJ2Ibpf3YP1ie4uEYVUz4/k\ntRfwoPYYYpCSdXrCazD8vSNgDb2MjOawhh1BhlvMo02Sdi4ChLkBAiXTrSpQN5u2\n35DZXer39ZgPsK1MARzUU5nEbY968095skVHUPQn6dAz/80Cl/+6gmEsIJTjiAsa\nklTzYjrd92rEi/JsvzjFprrhdE4p2mBDKeF0aZin+afex1/3xUShRWGgwt4QtKDs\nswmPXcn+InVECbdN3WEQpmtq8sr1aA6VYjJIumaB2/skBTdMJJXwpm6SPQsGcpOE\nMAzZjEUTUPGIuh+xQ2JWKP54lDvmWozqhwfxgR+O+5XzxzKt2BLskjSztVWd4o32\nIPZprFrc08/TZTlF6tUbzcJ4lRQYaF9MrhvzwlGDDFEq8X/OVd8tJ3HpE/eMPqup\ncuwws0IG7Jxi5focRRcdVRPjd0oQTWLLBucLlY8Bnb6oTY3+eG5SJn235NXo57NL\nY1WX5oGbuSgLR5rJ9cQD7+sqK5uwnoFsxCkvhIt05Lw1w54W4Ka0FgioeJtDYMD4\nom7zgCeD0DXGF76sV+gjXS9eCib9/VHoBO4TkqoMocI+HOp0pkF6CkspnPrcBhI7\nQ5QMuh2IUggb6sJQnyu+fsqMaL/50Q==\n=V994\n-----END PGP SIGNATURE-----",
        "payload": "tree 7d4dd26269bf40b771e360c64ca3a12388ec5880\nparent 6af9b31bfc6dd6086d245c00eb7cff762fc34a1e\nauthor Pieter Wuille <pieter@wuille.net> 1602214047 -0700\ncommitter Vasil Dimov <vd@FreeBSD.org> 1602232339 +0200\n\nSupport bypassing range check in ReadCompactSize\n\nThis is needed when we want to encode an arbitrary number as CompactSize\nlike node service flags, which is a bitmask and could be bigger than the\nusual size of an object.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1d3ec2a1fda7446323786a52da1fd109c01aa6fb",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/1d3ec2a1fda7446323786a52da1fd109c01aa6fb",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1d3ec2a1fda7446323786a52da1fd109c01aa6fb/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "vasild",
      "id": 266751,
      "node_id": "MDQ6VXNlcjI2Njc1MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vasild",
      "html_url": "https://github.com/vasild",
      "followers_url": "https://api.github.com/users/vasild/followers",
      "following_url": "https://api.github.com/users/vasild/following{/other_user}",
      "gists_url": "https://api.github.com/users/vasild/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vasild/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
      "organizations_url": "https://api.github.com/users/vasild/orgs",
      "repos_url": "https://api.github.com/users/vasild/repos",
      "events_url": "https://api.github.com/users/vasild/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vasild/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6af9b31bfc6dd6086d245c00eb7cff762fc34a1e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6af9b31bfc6dd6086d245c00eb7cff762fc34a1e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6af9b31bfc6dd6086d245c00eb7cff762fc34a1e"
      }
    ],
    "stats": {
      "total": 22,
      "additions": 17,
      "deletions": 5
    },
    "files": [
      {
        "sha": "d9ca984f9cdac72215f9f6cba5e448ef8a9fd877",
        "filename": "src/serialize.h",
        "status": "modified",
        "additions": 17,
        "deletions": 5,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/1d3ec2a1fda7446323786a52da1fd109c01aa6fb/src/serialize.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/1d3ec2a1fda7446323786a52da1fd109c01aa6fb/src/serialize.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/serialize.h?ref=1d3ec2a1fda7446323786a52da1fd109c01aa6fb",
        "patch": "@@ -24,7 +24,11 @@\n #include <prevector.h>\n #include <span.h>\n \n-static const unsigned int MAX_SIZE = 0x02000000;\n+/**\n+ * The maximum size of a serialized object in bytes or number of elements\n+ * (for eg vectors) when the size is encoded as CompactSize.\n+ */\n+static constexpr uint64_t MAX_SIZE = 0x02000000;\n \n /** Maximum amount of memory (in bytes) to allocate at once when deserializing vectors. */\n static const unsigned int MAX_VECTOR_ALLOCATE = 5000000;\n@@ -304,8 +308,14 @@ void WriteCompactSize(Stream& os, uint64_t nSize)\n     return;\n }\n \n+/**\n+ * Decode a CompactSize-encoded variable-length integer.\n+ *\n+ * As these are primarily used to encode the size of vector-like serializations, by default a range\n+ * check is performed. When used as a generic number encoding, range_check should be set to false.\n+ */\n template<typename Stream>\n-uint64_t ReadCompactSize(Stream& is)\n+uint64_t ReadCompactSize(Stream& is, bool range_check = true)\n {\n     uint8_t chSize = ser_readdata8(is);\n     uint64_t nSizeRet = 0;\n@@ -331,8 +341,9 @@ uint64_t ReadCompactSize(Stream& is)\n         if (nSizeRet < 0x100000000ULL)\n             throw std::ios_base::failure(\"non-canonical ReadCompactSize()\");\n     }\n-    if (nSizeRet > (uint64_t)MAX_SIZE)\n+    if (range_check && nSizeRet > MAX_SIZE) {\n         throw std::ios_base::failure(\"ReadCompactSize(): size too large\");\n+    }\n     return nSizeRet;\n }\n \n@@ -466,7 +477,7 @@ static inline Wrapper<Formatter, T&> Using(T&& t) { return Wrapper<Formatter, T&\n \n #define VARINT_MODE(obj, mode) Using<VarIntFormatter<mode>>(obj)\n #define VARINT(obj) Using<VarIntFormatter<VarIntMode::DEFAULT>>(obj)\n-#define COMPACTSIZE(obj) Using<CompactSizeFormatter>(obj)\n+#define COMPACTSIZE(obj) Using<CompactSizeFormatter<true>>(obj)\n #define LIMITED_STRING(obj,n) Using<LimitedStringFormatter<n>>(obj)\n \n /** Serialization wrapper class for integers in VarInt format. */\n@@ -529,12 +540,13 @@ struct CustomUintFormatter\n template<int Bytes> using BigEndianFormatter = CustomUintFormatter<Bytes, true>;\n \n /** Formatter for integers in CompactSize format. */\n+template<bool RangeCheck>\n struct CompactSizeFormatter\n {\n     template<typename Stream, typename I>\n     void Unser(Stream& s, I& v)\n     {\n-        uint64_t n = ReadCompactSize<Stream>(s);\n+        uint64_t n = ReadCompactSize<Stream>(s, RangeCheck);\n         if (n < std::numeric_limits<I>::min() || n > std::numeric_limits<I>::max()) {\n             throw std::ios_base::failure(\"CompactSize exceeds limit of type\");\n         }"
      }
    ]
  },
  {
    "sha": "201a4596d92d640d5eb7e76cc8d959228fa09dbb",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyMDFhNDU5NmQ5MmQ2NDBkNWViN2U3NmNjOGQ5NTkyMjhmYTA5ZGJi",
    "commit": {
      "author": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2020-05-19T15:39:05Z"
      },
      "committer": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2020-10-09T14:42:49Z"
      },
      "message": "net: CAddress & CAddrMan: (un)serialize as ADDRv2\n\nChange the serialization of `CAddrMan` to serialize its addresses\nin ADDRv2/BIP155 format by default. Introduce a new `CAddrMan` format\nversion (3).\n\nAdd support for ADDRv2 format in `CAddress` (un)serialization.\n\nCo-authored-by: Carl Dong <contact@carldong.me>",
      "tree": {
        "sha": "1f0641dfee1f4d475336a32f3fea930eded9d629",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1f0641dfee1f4d475336a32f3fea930eded9d629"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/201a4596d92d640d5eb7e76cc8d959228fa09dbb",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQQzBAABCAAdFiEE5k2NRWFNsHVF2czBVN8G9ktVy78FAl+AdukACgkQVN8G9ktV\ny7+DSx/6As2WF9xwftpHDLho/vKy3FWrkhTK/B0gGHCzOy/27jBuFMb5U2OZEMqH\nLr04awTGd1QMVqo1zlIWCLu4j9nj9ngxod0L6DP4mm1Zy6VFtVz9nEEdk7Gh5qV0\ny+I6j/XOoNnRJZ7Z17TIfhM500zWWKptN0uDmU2MkW93Frz9sTSBZIBzRuk1ZRq2\nI3pgBtNV7Jd5N8gMY1Gx/OrrwxssiTKyTUA38g/uXgeAxzz9+o3LV4WKWFaNvRB7\nS9I+IiW/8sJNHOO6W+nQognAGH36VeeWoPDOgTh1qX9SLrx+uykV+nEcBNzi2nq9\nDbU5WE9Zxfw+qgLIp1M236RciVRXfe/nJp/F9OaYtyk16OZDtkgEDkhEFndrluih\nyHxQ1D/sjYILI8ggcDzj3oP8AbeM3UgsCakwGsP+K2rYQd3pVOSlZ57tBOiD/FZy\nYBqmWYUPjq7I+Nagxayuqq+0lqt9ojpOYi3+NTXxGaGfHwgQsw5b2JMnCmgY+Eu1\ncd1v658nl+Cem+qTGQjpwkOl/S5Rngvll+ngClNmmy17nfvvC4VtZBNODx/KQfNI\n7HCjmlZWMBv/k7GOvzXvq0ZpEq0EWVBtsiB/S6o35i7z90GmlIqXzNYmY+DEJbOg\n1flXoOR7UFhpp28vmbQ5w9ZhPBz099O98UXGaF7pbjQQ7dvXAM+R32dz1NJs9KF3\nDDhnX93iOqPtthnHQDqO0qPjzCbpZp8q8yB3JmHMBYXVghFe+KDk2edWzVoxjQ2Q\nYiQGrsGdDjtWXYXddlgOsdb5osQDf0FsnTyp5GrLxYCsqFdUakBUzQb4ofx27b7W\n0qqqmtErOP4HoDhkzI93N/J2ok9LmcIEr81lG+DiAZwkJIvfjEgP/jNw85ZQ5gAc\nQfOHwpgysr1/IwMjqXNS9zhRelmAR0e3PwgQ8P4uSWu+Bc0fxUfd+H9kOKOuvDFS\nU1FO9ls+vd5ZFMN/z8Dpd73Qnil2NlKBn2CANREcBPoAFp0PYFw2N/koYNTQPdPS\nPDy9VSux1cF+eYP/vYvNLjZye3udR+VhmcsxRnkChiRGZhRlYUIGoKi9dtm+cPQj\nFOuNDhDHx/FWo/h1/axQCx45subdu5Yi9ejNJW9MdrRI+VMPlruqJJy/6+JMFQ3N\ny0ieCJnsP8t2MuVCUTg/uKtFqMjRNhDXlrAUYuXvTqZAMCBJH5sPk+b1k/Vpn+pb\n3E5/EYyXTYmi4yVabx6l8zdNFXwrWMOEkiZRiuGEz0QIQPbF1qlq56uie6X6cbGT\nlbgV2kcHHnSmqcEnBrGVsMg6/cULqoa5MJKCTahF147B3EDUr5jSCMYFeJA++jDe\n/PdbhYN3Y5dcR6KqsCpTsRfDlQso8Q==\n=GHYL\n-----END PGP SIGNATURE-----",
        "payload": "tree 1f0641dfee1f4d475336a32f3fea930eded9d629\nparent 1d3ec2a1fda7446323786a52da1fd109c01aa6fb\nauthor Vasil Dimov <vd@FreeBSD.org> 1589902745 +0200\ncommitter Vasil Dimov <vd@FreeBSD.org> 1602254569 +0200\n\nnet: CAddress & CAddrMan: (un)serialize as ADDRv2\n\nChange the serialization of `CAddrMan` to serialize its addresses\nin ADDRv2/BIP155 format by default. Introduce a new `CAddrMan` format\nversion (3).\n\nAdd support for ADDRv2 format in `CAddress` (un)serialization.\n\nCo-authored-by: Carl Dong <contact@carldong.me>\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/201a4596d92d640d5eb7e76cc8d959228fa09dbb",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/201a4596d92d640d5eb7e76cc8d959228fa09dbb",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/201a4596d92d640d5eb7e76cc8d959228fa09dbb/comments",
    "author": {
      "login": "vasild",
      "id": 266751,
      "node_id": "MDQ6VXNlcjI2Njc1MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vasild",
      "html_url": "https://github.com/vasild",
      "followers_url": "https://api.github.com/users/vasild/followers",
      "following_url": "https://api.github.com/users/vasild/following{/other_user}",
      "gists_url": "https://api.github.com/users/vasild/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vasild/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
      "organizations_url": "https://api.github.com/users/vasild/orgs",
      "repos_url": "https://api.github.com/users/vasild/repos",
      "events_url": "https://api.github.com/users/vasild/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vasild/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "vasild",
      "id": 266751,
      "node_id": "MDQ6VXNlcjI2Njc1MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vasild",
      "html_url": "https://github.com/vasild",
      "followers_url": "https://api.github.com/users/vasild/followers",
      "following_url": "https://api.github.com/users/vasild/following{/other_user}",
      "gists_url": "https://api.github.com/users/vasild/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vasild/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
      "organizations_url": "https://api.github.com/users/vasild/orgs",
      "repos_url": "https://api.github.com/users/vasild/repos",
      "events_url": "https://api.github.com/users/vasild/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vasild/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1d3ec2a1fda7446323786a52da1fd109c01aa6fb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1d3ec2a1fda7446323786a52da1fd109c01aa6fb",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1d3ec2a1fda7446323786a52da1fd109c01aa6fb"
      }
    ],
    "stats": {
      "total": 186,
      "additions": 170,
      "deletions": 16
    },
    "files": [
      {
        "sha": "490100a84de6fc673043efde31df7a715bb2f0df",
        "filename": "doc/release-notes.md",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/201a4596d92d640d5eb7e76cc8d959228fa09dbb/doc/release-notes.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/201a4596d92d640d5eb7e76cc8d959228fa09dbb/doc/release-notes.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes.md?ref=201a4596d92d640d5eb7e76cc8d959228fa09dbb",
        "patch": "@@ -60,6 +60,14 @@ From Bitcoin Core 0.20.0 onwards, macOS versions earlier than 10.12 are no\n longer supported. Additionally, Bitcoin Core does not yet change appearance\n when macOS \"dark mode\" is activated.\n \n+The node's known peers are persisted to disk in a file called `peers.dat`. The\n+format of this file has been changed in a backwards-incompatible way in order to\n+accommodate the storage of Tor v3 and other BIP155 addresses. This means that if\n+the file is modified by 0.21.0 or newer then older versions will not be able to\n+read it. Those old versions, in the event of a downgrade, will log an error\n+message that deserialization has failed and will continue normal operation\n+as if the file was missing, creating a new empty one. (#19954)\n+\n Notable changes\n ===============\n "
      },
      {
        "sha": "b4089dc8944476d7e40244a9052f54286c020659",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 46,
        "deletions": 14,
        "changes": 60,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/201a4596d92d640d5eb7e76cc8d959228fa09dbb/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/201a4596d92d640d5eb7e76cc8d959228fa09dbb/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=201a4596d92d640d5eb7e76cc8d959228fa09dbb",
        "patch": "@@ -12,6 +12,7 @@\n #include <random.h>\n #include <sync.h>\n #include <timedata.h>\n+#include <tinyformat.h>\n #include <util/system.h>\n \n #include <fs.h>\n@@ -264,6 +265,14 @@ friend class CAddrManTest;\n     void SetServices_(const CService &addr, ServiceFlags nServices) EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n public:\n+    //! Serialization versions.\n+    enum class Format : uint8_t {\n+        V0_HISTORICAL = 0,    //!< historic format, before commit e6b343d88\n+        V1_DETERMINISTIC = 1, //!< for pre-asmap files\n+        V2_ASMAP = 2,         //!< for files including asmap version\n+        V3_BIP155 = 3,        //!< same as V2_ASMAP plus addresses are in BIP155 format\n+    };\n+\n     // Compressed IP->ASN mapping, loaded from a file when a node starts.\n     // Should be always empty if no file was provided.\n     // This mapping is then used for bucketing nodes in Addrman.\n@@ -285,8 +294,8 @@ friend class CAddrManTest;\n \n \n     /**\n-     * serialized format:\n-     * * version byte (1 for pre-asmap files, 2 for files including asmap version)\n+     * Serialized format.\n+     * * version byte (@see `Format`)\n      * * 0x20 + nKey (serialized as if it were a vector, for backward compatibility)\n      * * nNew\n      * * nTried\n@@ -313,13 +322,16 @@ friend class CAddrManTest;\n      * We don't use SERIALIZE_METHODS since the serialization and deserialization code has\n      * very little in common.\n      */\n-    template<typename Stream>\n-    void Serialize(Stream &s) const\n+    template <typename Stream>\n+    void Serialize(Stream& s_) const\n     {\n         LOCK(cs);\n \n-        unsigned char nVersion = 2;\n-        s << nVersion;\n+        // Always serialize in the latest version (currently Format::V3_BIP155).\n+\n+        OverrideStream<Stream> s(&s_, s_.GetType(), s_.GetVersion() | ADDRV2_FORMAT);\n+\n+        s << static_cast<uint8_t>(Format::V3_BIP155);\n         s << ((unsigned char)32);\n         s << nKey;\n         s << nNew;\n@@ -370,14 +382,34 @@ friend class CAddrManTest;\n         s << asmap_version;\n     }\n \n-    template<typename Stream>\n-    void Unserialize(Stream& s)\n+    template <typename Stream>\n+    void Unserialize(Stream& s_)\n     {\n         LOCK(cs);\n \n         Clear();\n-        unsigned char nVersion;\n-        s >> nVersion;\n+\n+        Format format;\n+        s_ >> Using<CustomUintFormatter<1>>(format);\n+\n+        static constexpr Format maximum_supported_format = Format::V3_BIP155;\n+        if (format > maximum_supported_format) {\n+            throw std::ios_base::failure(strprintf(\n+                \"Unsupported format of addrman database: %u. Maximum supported is %u. \"\n+                \"Continuing operation without using the saved list of peers.\",\n+                static_cast<uint8_t>(format),\n+                static_cast<uint8_t>(maximum_supported_format)));\n+        }\n+\n+        int stream_version = s_.GetVersion();\n+        if (format >= Format::V3_BIP155) {\n+            // Add ADDRV2_FORMAT to the version so that the CNetAddr and CAddress\n+            // unserialize methods know that an address in addrv2 format is coming.\n+            stream_version |= ADDRV2_FORMAT;\n+        }\n+\n+        OverrideStream<Stream> s(&s_, s_.GetType(), stream_version);\n+\n         unsigned char nKeySize;\n         s >> nKeySize;\n         if (nKeySize != 32) throw std::ios_base::failure(\"Incorrect keysize in addrman deserialization\");\n@@ -386,7 +418,7 @@ friend class CAddrManTest;\n         s >> nTried;\n         int nUBuckets = 0;\n         s >> nUBuckets;\n-        if (nVersion != 0) {\n+        if (format >= Format::V1_DETERMINISTIC) {\n             nUBuckets ^= (1 << 30);\n         }\n \n@@ -449,21 +481,21 @@ friend class CAddrManTest;\n             supplied_asmap_version = SerializeHash(m_asmap);\n         }\n         uint256 serialized_asmap_version;\n-        if (nVersion > 1) {\n+        if (format >= Format::V2_ASMAP) {\n             s >> serialized_asmap_version;\n         }\n \n         for (int n = 0; n < nNew; n++) {\n             CAddrInfo &info = mapInfo[n];\n             int bucket = entryToBucket[n];\n             int nUBucketPos = info.GetBucketPosition(nKey, true, bucket);\n-            if (nVersion == 2 && nUBuckets == ADDRMAN_NEW_BUCKET_COUNT && vvNew[bucket][nUBucketPos] == -1 &&\n+            if (format >= Format::V2_ASMAP && nUBuckets == ADDRMAN_NEW_BUCKET_COUNT && vvNew[bucket][nUBucketPos] == -1 &&\n                 info.nRefCount < ADDRMAN_NEW_BUCKETS_PER_ADDRESS && serialized_asmap_version == supplied_asmap_version) {\n                 // Bucketing has not changed, using existing bucket positions for the new table\n                 vvNew[bucket][nUBucketPos] = n;\n                 info.nRefCount++;\n             } else {\n-                // In case the new table data cannot be used (nVersion unknown, bucket count wrong or new asmap),\n+                // In case the new table data cannot be used (format unknown, bucket count wrong or new asmap),\n                 // try to give them a reference based on their primary source address.\n                 LogPrint(BCLog::ADDRMAN, \"Bucketing method was updated, re-bucketing addrman entries from disk\\n\");\n                 bucket = info.GetNewBucket(nKey, m_asmap);"
      },
      {
        "sha": "e2d3602792f42a3c853468bae2e590a6662261c5",
        "filename": "src/protocol.h",
        "status": "modified",
        "additions": 10,
        "deletions": 2,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/201a4596d92d640d5eb7e76cc8d959228fa09dbb/src/protocol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/201a4596d92d640d5eb7e76cc8d959228fa09dbb/src/protocol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.h?ref=201a4596d92d640d5eb7e76cc8d959228fa09dbb",
        "patch": "@@ -351,7 +351,8 @@ class CAddress : public CService\n \n public:\n     CAddress() : CService{} {};\n-    explicit CAddress(CService ipIn, ServiceFlags nServicesIn) : CService{ipIn}, nServices{nServicesIn} {};\n+    CAddress(CService ipIn, ServiceFlags nServicesIn) : CService{ipIn}, nServices{nServicesIn} {};\n+    CAddress(CService ipIn, ServiceFlags nServicesIn, uint32_t nTimeIn) : CService{ipIn}, nTime{nTimeIn}, nServices{nServicesIn} {};\n \n     SERIALIZE_METHODS(CAddress, obj)\n     {\n@@ -370,7 +371,14 @@ class CAddress : public CService\n             // nTime.\n             READWRITE(obj.nTime);\n         }\n-        READWRITE(Using<CustomUintFormatter<8>>(obj.nServices));\n+        if (nVersion & ADDRV2_FORMAT) {\n+            uint64_t services_tmp;\n+            SER_WRITE(obj, services_tmp = obj.nServices);\n+            READWRITE(Using<CompactSizeFormatter<false>>(services_tmp));\n+            SER_READ(obj, obj.nServices = static_cast<ServiceFlags>(services_tmp));\n+        } else {\n+            READWRITE(Using<CustomUintFormatter<8>>(obj.nServices));\n+        }\n         READWRITEAS(CService, obj);\n     }\n "
      },
      {
        "sha": "c22f5936fda3d49690bb1ad9a0070574b08671a9",
        "filename": "src/streams.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/201a4596d92d640d5eb7e76cc8d959228fa09dbb/src/streams.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/201a4596d92d640d5eb7e76cc8d959228fa09dbb/src/streams.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/streams.h?ref=201a4596d92d640d5eb7e76cc8d959228fa09dbb",
        "patch": "@@ -60,6 +60,7 @@ class OverrideStream\n     int GetVersion() const { return nVersion; }\n     int GetType() const { return nType; }\n     size_t size() const { return stream->size(); }\n+    void ignore(size_t size) { return stream->ignore(size); }\n };\n \n /* Minimal stream for overwriting and/or appending to an existing byte vector"
      },
      {
        "sha": "eb0d95a373d4344d602941c24cd60db78807b64c",
        "filename": "src/test/netbase_tests.cpp",
        "status": "modified",
        "additions": 105,
        "deletions": 0,
        "changes": 105,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/201a4596d92d640d5eb7e76cc8d959228fa09dbb/src/test/netbase_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/201a4596d92d640d5eb7e76cc8d959228fa09dbb/src/test/netbase_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/netbase_tests.cpp?ref=201a4596d92d640d5eb7e76cc8d959228fa09dbb",
        "patch": "@@ -4,9 +4,13 @@\n \n #include <net_permissions.h>\n #include <netbase.h>\n+#include <protocol.h>\n+#include <serialize.h>\n+#include <streams.h>\n #include <test/util/setup_common.h>\n #include <util/strencodings.h>\n #include <util/translation.h>\n+#include <version.h>\n \n #include <string>\n \n@@ -443,4 +447,105 @@ BOOST_AUTO_TEST_CASE(netbase_dont_resolve_strings_with_embedded_nul_characters)\n     BOOST_CHECK(!LookupSubNet(std::string(\"5wyqrzbvrdsumnok.onion\\0example.com\\0\", 35), ret));\n }\n \n+// Since CNetAddr (un)ser is tested separately in net_tests.cpp here we only\n+// try a few edge cases for port, service flags and time.\n+\n+static const std::vector<CAddress> fixture_addresses({\n+    CAddress(\n+        CService(CNetAddr(in6addr_loopback), 0 /* port */),\n+        NODE_NONE,\n+        0x4966bc61U /* Fri Jan  9 02:54:25 UTC 2009 */\n+    ),\n+    CAddress(\n+        CService(CNetAddr(in6addr_loopback), 0x00f1 /* port */),\n+        NODE_NETWORK,\n+        0x83766279U /* Tue Nov 22 11:22:33 UTC 2039 */\n+    ),\n+    CAddress(\n+        CService(CNetAddr(in6addr_loopback), 0xf1f2 /* port */),\n+        static_cast<ServiceFlags>(NODE_WITNESS | NODE_COMPACT_FILTERS | NODE_NETWORK_LIMITED),\n+        0xffffffffU /* Sun Feb  7 06:28:15 UTC 2106 */\n+    )\n+});\n+\n+// fixture_addresses should equal to this when serialized in V1 format.\n+// When this is unserialized from V1 format it should equal to fixture_addresses.\n+static constexpr const char* stream_addrv1_hex =\n+    \"03\" // number of entries\n+\n+    \"61bc6649\"                         // time, Fri Jan  9 02:54:25 UTC 2009\n+    \"0000000000000000\"                 // service flags, NODE_NONE\n+    \"00000000000000000000000000000001\" // address, fixed 16 bytes (IPv4 embedded in IPv6)\n+    \"0000\"                             // port\n+\n+    \"79627683\"                         // time, Tue Nov 22 11:22:33 UTC 2039\n+    \"0100000000000000\"                 // service flags, NODE_NETWORK\n+    \"00000000000000000000000000000001\" // address, fixed 16 bytes (IPv6)\n+    \"00f1\"                             // port\n+\n+    \"ffffffff\"                         // time, Sun Feb  7 06:28:15 UTC 2106\n+    \"4804000000000000\"                 // service flags, NODE_WITNESS | NODE_COMPACT_FILTERS | NODE_NETWORK_LIMITED\n+    \"00000000000000000000000000000001\" // address, fixed 16 bytes (IPv6)\n+    \"f1f2\";                            // port\n+\n+// fixture_addresses should equal to this when serialized in V2 format.\n+// When this is unserialized from V2 format it should equal to fixture_addresses.\n+static constexpr const char* stream_addrv2_hex =\n+    \"03\" // number of entries\n+\n+    \"61bc6649\"                         // time, Fri Jan  9 02:54:25 UTC 2009\n+    \"00\"                               // service flags, COMPACTSIZE(NODE_NONE)\n+    \"02\"                               // network id, IPv6\n+    \"10\"                               // address length, COMPACTSIZE(16)\n+    \"00000000000000000000000000000001\" // address\n+    \"0000\"                             // port\n+\n+    \"79627683\"                         // time, Tue Nov 22 11:22:33 UTC 2039\n+    \"01\"                               // service flags, COMPACTSIZE(NODE_NETWORK)\n+    \"02\"                               // network id, IPv6\n+    \"10\"                               // address length, COMPACTSIZE(16)\n+    \"00000000000000000000000000000001\" // address\n+    \"00f1\"                             // port\n+\n+    \"ffffffff\"                         // time, Sun Feb  7 06:28:15 UTC 2106\n+    \"fd4804\"                           // service flags, COMPACTSIZE(NODE_WITNESS | NODE_COMPACT_FILTERS | NODE_NETWORK_LIMITED)\n+    \"02\"                               // network id, IPv6\n+    \"10\"                               // address length, COMPACTSIZE(16)\n+    \"00000000000000000000000000000001\" // address\n+    \"f1f2\";                            // port\n+\n+BOOST_AUTO_TEST_CASE(caddress_serialize_v1)\n+{\n+    CDataStream s(SER_NETWORK, PROTOCOL_VERSION);\n+\n+    s << fixture_addresses;\n+    BOOST_CHECK_EQUAL(HexStr(s), stream_addrv1_hex);\n+}\n+\n+BOOST_AUTO_TEST_CASE(caddress_unserialize_v1)\n+{\n+    CDataStream s(ParseHex(stream_addrv1_hex), SER_NETWORK, PROTOCOL_VERSION);\n+    std::vector<CAddress> addresses_unserialized;\n+\n+    s >> addresses_unserialized;\n+    BOOST_CHECK(fixture_addresses == addresses_unserialized);\n+}\n+\n+BOOST_AUTO_TEST_CASE(caddress_serialize_v2)\n+{\n+    CDataStream s(SER_NETWORK, PROTOCOL_VERSION | ADDRV2_FORMAT);\n+\n+    s << fixture_addresses;\n+    BOOST_CHECK_EQUAL(HexStr(s), stream_addrv2_hex);\n+}\n+\n+BOOST_AUTO_TEST_CASE(caddress_unserialize_v2)\n+{\n+    CDataStream s(ParseHex(stream_addrv2_hex), SER_NETWORK, PROTOCOL_VERSION | ADDRV2_FORMAT);\n+    std::vector<CAddress> addresses_unserialized;\n+\n+    s >> addresses_unserialized;\n+    BOOST_CHECK(fixture_addresses == addresses_unserialized);\n+}\n+\n BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  },
  {
    "sha": "353a3fdaad055eea42a0baf7326bdd591f541170",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozNTNhM2ZkYWFkMDU1ZWVhNDJhMGJhZjczMjZiZGQ1OTFmNTQxMTcw",
    "commit": {
      "author": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2020-05-20T10:05:18Z"
      },
      "committer": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2020-10-09T14:42:50Z"
      },
      "message": "net: advertise support for ADDRv2 via new message\n\nIntroduce a new message `sendaddrv2` to signal support for ADDRv2.\nSend the new message immediately after sending the `VERACK` message.\n\nAdd support for receiving and parsing ADDRv2 messages.\n\nSend ADDRv2 messages (instead of ADDR) to a peer if he has\nadvertised support for it.\n\nCo-authored-by: Carl Dong <contact@carldong.me>",
      "tree": {
        "sha": "ab25e783cbf347df239d98060f83dcf2ea72209a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ab25e783cbf347df239d98060f83dcf2ea72209a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/353a3fdaad055eea42a0baf7326bdd591f541170",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQQzBAABCAAdFiEE5k2NRWFNsHVF2czBVN8G9ktVy78FAl+AduoACgkQVN8G9ktV\ny78s1x//QODMQnS5WFYzRedGBIKRS7h7Iolnk9uGq7bDen9olqURrzZLpgbEdl5z\nKCCJB6WNBdpa+WUKqlFzZoYaKjkSxmmwLU0BKcGu2a9pVWkCNcQ6uUoKQWXeqX/3\nF/RzoNh+nZI4D8DDBCHjaa+IrxtPX5V0cTjpLeT78820FSVIhHhaf60bJr+/r3Ka\ntyXRunaHBfUeiS2lbW87Duede77gBK+muGV5uE8nsN3YpxuwET6cLgE4m3ztsvFS\nJ9KrSrWw1rumXG7v0H6ayKwrleDbRW0ntWI7spqvY5LGvqwI4mBd78W7l5kmTKl8\nmsIkNwxH69arohR20QnyqtNRVmziSsTM/5l3uWhlqi6kUSPIWyvGL8rjY3/BtGT4\n7bACo7mZAY+Q4S+bHws6Nr4wFfxnkWFyZgYiVkslVK28AaLdB4hc4BgxQ5sbehvM\nZ30vkcioOBoGAuBP6Uj78elqGN2z1qncGKOU8g7FgpCAt/sIWHPsAmoMilPrtKY+\nOcnWkWIYfxp66sFaFfzC/SMKmsyJNvPS/N3Y93XUdhFhVv3OJ6ooLIlxZL5qZuKm\nqiMcKsbMoOubLzO2QdeVTeKwytdIKQYZToArEIoEL3cn7tqbLzjGBwsgBeTLruqh\nEkPnpkn6m4ttCNulNwscSGefINt87rTnK8EcmHRGnL39HcylOSqAtWcYPxvvnExW\n/U5UXiXNy3YIa46Fjl0A6jHi1/AQI1xORHFrUmLTt0VHxzcEtNXEZyopFjaapUtV\nJ67yTCR8pPtYfKnti8BSmTmaXHM3m8HZl/LXa01eEyrVBtrA3DRbggsjg/WzWe6O\n3uHFmGoalnUzz+MVIwr3Oq3UAJOVFm/RIjU2VOFNL5IVR+aUXNYvkaxamohjZaGg\n5H0v3AANKOkVYCvnlHHgnJOyvPgTzlt3QmkogScomiudKkIjW/WcbkSgVeEK9zuM\nfOG3ntXgGtmGArb/HetHj0RiIbaiDTdwhtmMJ41zzB3UZsAgvbr8Fj5aHBPv3q5F\n4/eCUECjXmf5tH0dkDwX9xil43tM7/tut36NGT5yGgCxmm7meNJISNCYXgEUE99P\nyIcZQRHqIWmef9X+Tpm5fr0gsIc0DRPx0Aoz8ydIXqGjfuYHsbnoBN4C5CVX7ZzZ\nbBAjS+zO6rTOvv8lPUl8W3kNPmo3ngJkbQZPjuCORLrag94K3EMym99OkhUzu6Sr\n07iWclPG59xRh1P9uCIJgVIiAjRRTcM5Nk8Xx+4G4urhwSTddGZpIjEho8123zs4\n+LAaXaJdrwIZv+UfujSFIOB4hVvykNR53GbAErZofFH1yYcQy2PnzuBLp57+K+H3\nrTFfboncHn9v9Ki4NM+eyMcrN9z7rQ==\n=jkZF\n-----END PGP SIGNATURE-----",
        "payload": "tree ab25e783cbf347df239d98060f83dcf2ea72209a\nparent 201a4596d92d640d5eb7e76cc8d959228fa09dbb\nauthor Vasil Dimov <vd@FreeBSD.org> 1589969118 +0200\ncommitter Vasil Dimov <vd@FreeBSD.org> 1602254570 +0200\n\nnet: advertise support for ADDRv2 via new message\n\nIntroduce a new message `sendaddrv2` to signal support for ADDRv2.\nSend the new message immediately after sending the `VERACK` message.\n\nAdd support for receiving and parsing ADDRv2 messages.\n\nSend ADDRv2 messages (instead of ADDR) to a peer if he has\nadvertised support for it.\n\nCo-authored-by: Carl Dong <contact@carldong.me>\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/353a3fdaad055eea42a0baf7326bdd591f541170",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/353a3fdaad055eea42a0baf7326bdd591f541170",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/353a3fdaad055eea42a0baf7326bdd591f541170/comments",
    "author": {
      "login": "vasild",
      "id": 266751,
      "node_id": "MDQ6VXNlcjI2Njc1MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vasild",
      "html_url": "https://github.com/vasild",
      "followers_url": "https://api.github.com/users/vasild/followers",
      "following_url": "https://api.github.com/users/vasild/following{/other_user}",
      "gists_url": "https://api.github.com/users/vasild/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vasild/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
      "organizations_url": "https://api.github.com/users/vasild/orgs",
      "repos_url": "https://api.github.com/users/vasild/repos",
      "events_url": "https://api.github.com/users/vasild/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vasild/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "vasild",
      "id": 266751,
      "node_id": "MDQ6VXNlcjI2Njc1MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vasild",
      "html_url": "https://github.com/vasild",
      "followers_url": "https://api.github.com/users/vasild/followers",
      "following_url": "https://api.github.com/users/vasild/following{/other_user}",
      "gists_url": "https://api.github.com/users/vasild/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vasild/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
      "organizations_url": "https://api.github.com/users/vasild/orgs",
      "repos_url": "https://api.github.com/users/vasild/repos",
      "events_url": "https://api.github.com/users/vasild/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vasild/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "201a4596d92d640d5eb7e76cc8d959228fa09dbb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/201a4596d92d640d5eb7e76cc8d959228fa09dbb",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/201a4596d92d640d5eb7e76cc8d959228fa09dbb"
      }
    ],
    "stats": {
      "total": 415,
      "additions": 392,
      "deletions": 23
    },
    "files": [
      {
        "sha": "def30b47781225b8311e1a62146a75513116765e",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 11,
        "deletions": 1,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/353a3fdaad055eea42a0baf7326bdd591f541170/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/353a3fdaad055eea42a0baf7326bdd591f541170/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=353a3fdaad055eea42a0baf7326bdd591f541170",
        "patch": "@@ -868,6 +868,11 @@ class CNode\n     bool m_legacyWhitelisted{false};\n     bool fClient{false}; // set by version message\n     bool m_limited_node{false}; //after BIP159, set by version message\n+    /**\n+     * Whether the peer has signaled support for receiving ADDRv2 (BIP155)\n+     * messages, implying a preference to receive ADDRv2 instead of ADDR ones.\n+     */\n+    std::atomic_bool m_wants_addrv2{false};\n     std::atomic_bool fSuccessfullyConnected{false};\n     // Setting fDisconnect to true will cause the node to be disconnected the\n     // next time DisconnectNodes() runs\n@@ -1115,11 +1120,16 @@ class CNode\n \n     void PushAddress(const CAddress& _addr, FastRandomContext &insecure_rand)\n     {\n+        // Whether the peer supports the address in `_addr`. For example,\n+        // nodes that do not implement BIP155 cannot receive Tor v3 addresses\n+        // because they require ADDRv2 (BIP155) encoding.\n+        const bool addr_format_supported = m_wants_addrv2 || _addr.IsAddrV1Compatible();\n+\n         // Known checking here is only to save space from duplicates.\n         // SendMessages will filter it again for knowns that were added\n         // after addresses were pushed.\n         assert(m_addr_known);\n-        if (_addr.IsValid() && !m_addr_known->contains(_addr.GetKey())) {\n+        if (_addr.IsValid() && !m_addr_known->contains(_addr.GetKey()) && addr_format_supported) {\n             if (vAddrToSend.size() >= MAX_ADDR_TO_SEND) {\n                 vAddrToSend[insecure_rand.randrange(vAddrToSend.size())] = _addr;\n             } else {"
      },
      {
        "sha": "2b3b4767c550a1191d46b308f917edcef35712a4",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 38,
        "deletions": 7,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/353a3fdaad055eea42a0baf7326bdd591f541170/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/353a3fdaad055eea42a0baf7326bdd591f541170/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=353a3fdaad055eea42a0baf7326bdd591f541170",
        "patch": "@@ -23,6 +23,7 @@\n #include <random.h>\n #include <reverse_iterator.h>\n #include <scheduler.h>\n+#include <streams.h>\n #include <tinyformat.h>\n #include <txmempool.h>\n #include <util/check.h> // For NDEBUG compile time check\n@@ -2408,11 +2409,16 @@ void PeerManager::ProcessMessage(CNode& pfrom, const std::string& msg_type, CDat\n         pfrom.SetCommonVersion(greatest_common_version);\n         pfrom.nVersion = nVersion;\n \n+        const CNetMsgMaker msg_maker(greatest_common_version);\n+\n         if (greatest_common_version >= WTXID_RELAY_VERSION) {\n-            m_connman.PushMessage(&pfrom, CNetMsgMaker(greatest_common_version).Make(NetMsgType::WTXIDRELAY));\n+            m_connman.PushMessage(&pfrom, msg_maker.Make(NetMsgType::WTXIDRELAY));\n         }\n \n-        m_connman.PushMessage(&pfrom, CNetMsgMaker(greatest_common_version).Make(NetMsgType::VERACK));\n+        m_connman.PushMessage(&pfrom, msg_maker.Make(NetMsgType::VERACK));\n+\n+        // Signal ADDRv2 support (BIP155).\n+        m_connman.PushMessage(&pfrom, msg_maker.Make(NetMsgType::SENDADDRV2));\n \n         pfrom.nServices = nServices;\n         pfrom.SetAddrLocal(addrMe);\n@@ -2582,16 +2588,25 @@ void PeerManager::ProcessMessage(CNode& pfrom, const std::string& msg_type, CDat\n         return;\n     }\n \n-    if (msg_type == NetMsgType::ADDR) {\n+    if (msg_type == NetMsgType::ADDR || msg_type == NetMsgType::ADDRV2) {\n+        int stream_version = vRecv.GetVersion();\n+        if (msg_type == NetMsgType::ADDRV2) {\n+            // Add ADDRV2_FORMAT to the version so that the CNetAddr and CAddress\n+            // unserialize methods know that an address in v2 format is coming.\n+            stream_version |= ADDRV2_FORMAT;\n+        }\n+\n+        OverrideStream<CDataStream> s(&vRecv, vRecv.GetType(), stream_version);\n         std::vector<CAddress> vAddr;\n-        vRecv >> vAddr;\n+\n+        s >> vAddr;\n \n         if (!pfrom.RelayAddrsWithConn()) {\n             return;\n         }\n         if (vAddr.size() > MAX_ADDR_TO_SEND)\n         {\n-            Misbehaving(pfrom.GetId(), 20, strprintf(\"addr message size = %u\", vAddr.size()));\n+            Misbehaving(pfrom.GetId(), 20, strprintf(\"%s message size = %u\", msg_type, vAddr.size()));\n             return;\n         }\n \n@@ -2635,6 +2650,11 @@ void PeerManager::ProcessMessage(CNode& pfrom, const std::string& msg_type, CDat\n         return;\n     }\n \n+    if (msg_type == NetMsgType::SENDADDRV2) {\n+        pfrom.m_wants_addrv2 = true;\n+        return;\n+    }\n+\n     if (msg_type == NetMsgType::SENDHEADERS) {\n         LOCK(cs_main);\n         State(pfrom.GetId())->fPreferHeaders = true;\n@@ -4095,6 +4115,17 @@ bool PeerManager::SendMessages(CNode* pto)\n             std::vector<CAddress> vAddr;\n             vAddr.reserve(pto->vAddrToSend.size());\n             assert(pto->m_addr_known);\n+\n+            const char* msg_type;\n+            int make_flags;\n+            if (pto->m_wants_addrv2) {\n+                msg_type = NetMsgType::ADDRV2;\n+                make_flags = ADDRV2_FORMAT;\n+            } else {\n+                msg_type = NetMsgType::ADDR;\n+                make_flags = 0;\n+            }\n+\n             for (const CAddress& addr : pto->vAddrToSend)\n             {\n                 if (!pto->m_addr_known->contains(addr.GetKey()))\n@@ -4104,14 +4135,14 @@ bool PeerManager::SendMessages(CNode* pto)\n                     // receiver rejects addr messages larger than MAX_ADDR_TO_SEND\n                     if (vAddr.size() >= MAX_ADDR_TO_SEND)\n                     {\n-                        m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::ADDR, vAddr));\n+                        m_connman.PushMessage(pto, msgMaker.Make(make_flags, msg_type, vAddr));\n                         vAddr.clear();\n                     }\n                 }\n             }\n             pto->vAddrToSend.clear();\n             if (!vAddr.empty())\n-                m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::ADDR, vAddr));\n+                m_connman.PushMessage(pto, msgMaker.Make(make_flags, msg_type, vAddr));\n             // we only send the big addr message once\n             if (pto->vAddrToSend.capacity() > 40)\n                 pto->vAddrToSend.shrink_to_fit();"
      },
      {
        "sha": "eece0190b5f91432df2da429dd760ab6a1a6a681",
        "filename": "src/netaddress.cpp",
        "status": "modified",
        "additions": 26,
        "deletions": 3,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/353a3fdaad055eea42a0baf7326bdd591f541170/src/netaddress.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/353a3fdaad055eea42a0baf7326bdd591f541170/src/netaddress.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.cpp?ref=353a3fdaad055eea42a0baf7326bdd591f541170",
        "patch": "@@ -474,6 +474,26 @@ bool CNetAddr::IsInternal() const\n    return m_net == NET_INTERNAL;\n }\n \n+bool CNetAddr::IsAddrV1Compatible() const\n+{\n+    switch (m_net) {\n+    case NET_IPV4:\n+    case NET_IPV6:\n+    case NET_INTERNAL:\n+        return true;\n+    case NET_ONION:\n+        return m_addr.size() == ADDR_TORV2_SIZE;\n+    case NET_I2P:\n+    case NET_CJDNS:\n+        return false;\n+    case NET_UNROUTABLE: // m_net is never and should not be set to NET_UNROUTABLE\n+    case NET_MAX:        // m_net is never and should not be set to NET_MAX\n+        assert(false);\n+    } // no default case, so the compiler can warn about missing cases\n+\n+    assert(false);\n+}\n+\n enum Network CNetAddr::GetNetwork() const\n {\n     if (IsInternal())\n@@ -744,9 +764,12 @@ std::vector<unsigned char> CNetAddr::GetGroup(const std::vector<bool> &asmap) co\n \n std::vector<unsigned char> CNetAddr::GetAddrBytes() const\n {\n-    uint8_t serialized[V1_SERIALIZATION_SIZE];\n-    SerializeV1Array(serialized);\n-    return {std::begin(serialized), std::end(serialized)};\n+    if (IsAddrV1Compatible()) {\n+        uint8_t serialized[V1_SERIALIZATION_SIZE];\n+        SerializeV1Array(serialized);\n+        return {std::begin(serialized), std::end(serialized)};\n+    }\n+    return std::vector<unsigned char>(m_addr.begin(), m_addr.end());\n }\n \n uint64_t CNetAddr::GetHash() const"
      },
      {
        "sha": "a0992e70c406ebc3e9b0ccd020b2f312d5feff76",
        "filename": "src/netaddress.h",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/353a3fdaad055eea42a0baf7326bdd591f541170/src/netaddress.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/353a3fdaad055eea42a0baf7326bdd591f541170/src/netaddress.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.h?ref=353a3fdaad055eea42a0baf7326bdd591f541170",
        "patch": "@@ -173,6 +173,12 @@ class CNetAddr\n         bool IsRoutable() const;\n         bool IsInternal() const;\n         bool IsValid() const;\n+\n+        /**\n+         * Check if the current object can be serialized in pre-ADDRv2/BIP155 format.\n+         */\n+        bool IsAddrV1Compatible() const;\n+\n         enum Network GetNetwork() const;\n         std::string ToString() const;\n         std::string ToStringIP() const;"
      },
      {
        "sha": "dc8f795a0cced55b138c938d61787e216ed30fa3",
        "filename": "src/protocol.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/353a3fdaad055eea42a0baf7326bdd591f541170/src/protocol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/353a3fdaad055eea42a0baf7326bdd591f541170/src/protocol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.cpp?ref=353a3fdaad055eea42a0baf7326bdd591f541170",
        "patch": "@@ -14,6 +14,8 @@ namespace NetMsgType {\n const char *VERSION=\"version\";\n const char *VERACK=\"verack\";\n const char *ADDR=\"addr\";\n+const char *ADDRV2=\"addrv2\";\n+const char *SENDADDRV2=\"sendaddrv2\";\n const char *INV=\"inv\";\n const char *GETDATA=\"getdata\";\n const char *MERKLEBLOCK=\"merkleblock\";\n@@ -52,6 +54,8 @@ const static std::string allNetMessageTypes[] = {\n     NetMsgType::VERSION,\n     NetMsgType::VERACK,\n     NetMsgType::ADDR,\n+    NetMsgType::ADDRV2,\n+    NetMsgType::SENDADDRV2,\n     NetMsgType::INV,\n     NetMsgType::GETDATA,\n     NetMsgType::MERKLEBLOCK,"
      },
      {
        "sha": "309fac621c963ddc30ea190650123b344b06a0a3",
        "filename": "src/protocol.h",
        "status": "modified",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/353a3fdaad055eea42a0baf7326bdd591f541170/src/protocol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/353a3fdaad055eea42a0baf7326bdd591f541170/src/protocol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.h?ref=353a3fdaad055eea42a0baf7326bdd591f541170",
        "patch": "@@ -76,6 +76,18 @@ extern const char* VERACK;\n  * network.\n  */\n extern const char* ADDR;\n+/**\n+ * The addrv2 message relays connection information for peers on the network just\n+ * like the addr message, but is extended to allow gossiping of longer node\n+ * addresses (see BIP155).\n+ */\n+extern const char *ADDRV2;\n+/**\n+ * The sendaddrv2 message signals support for receiving ADDRV2 messages (BIP155).\n+ * It also implies that its sender can encode as ADDRV2 and would send ADDRV2\n+ * instead of ADDR to a peer that has signaled ADDRV2 support by sending SENDADDRV2.\n+ */\n+extern const char *SENDADDRV2;\n /**\n  * The inv message (inventory message) transmits one or more inventories of\n  * objects known to the transmitting peer."
      },
      {
        "sha": "fe03c1ece48fed671337982d85bbf871dfa9955e",
        "filename": "src/test/net_tests.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 0,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/353a3fdaad055eea42a0baf7326bdd591f541170/src/test/net_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/353a3fdaad055eea42a0baf7326bdd591f541170/src/test/net_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/net_tests.cpp?ref=353a3fdaad055eea42a0baf7326bdd591f541170",
        "patch": "@@ -212,6 +212,7 @@ BOOST_AUTO_TEST_CASE(cnetaddr_basic)\n     BOOST_REQUIRE(addr.IsIPv4());\n \n     BOOST_CHECK(addr.IsBindAny());\n+    BOOST_CHECK(addr.IsAddrV1Compatible());\n     BOOST_CHECK_EQUAL(addr.ToString(), \"0.0.0.0\");\n \n     // IPv4, INADDR_NONE\n@@ -220,6 +221,7 @@ BOOST_AUTO_TEST_CASE(cnetaddr_basic)\n     BOOST_REQUIRE(addr.IsIPv4());\n \n     BOOST_CHECK(!addr.IsBindAny());\n+    BOOST_CHECK(addr.IsAddrV1Compatible());\n     BOOST_CHECK_EQUAL(addr.ToString(), \"255.255.255.255\");\n \n     // IPv4, casual\n@@ -228,6 +230,7 @@ BOOST_AUTO_TEST_CASE(cnetaddr_basic)\n     BOOST_REQUIRE(addr.IsIPv4());\n \n     BOOST_CHECK(!addr.IsBindAny());\n+    BOOST_CHECK(addr.IsAddrV1Compatible());\n     BOOST_CHECK_EQUAL(addr.ToString(), \"12.34.56.78\");\n \n     // IPv6, in6addr_any\n@@ -236,6 +239,7 @@ BOOST_AUTO_TEST_CASE(cnetaddr_basic)\n     BOOST_REQUIRE(addr.IsIPv6());\n \n     BOOST_CHECK(addr.IsBindAny());\n+    BOOST_CHECK(addr.IsAddrV1Compatible());\n     BOOST_CHECK_EQUAL(addr.ToString(), \"::\");\n \n     // IPv6, casual\n@@ -244,6 +248,7 @@ BOOST_AUTO_TEST_CASE(cnetaddr_basic)\n     BOOST_REQUIRE(addr.IsIPv6());\n \n     BOOST_CHECK(!addr.IsBindAny());\n+    BOOST_CHECK(addr.IsAddrV1Compatible());\n     BOOST_CHECK_EQUAL(addr.ToString(), \"1122:3344:5566:7788:9900:aabb:ccdd:eeff\");\n \n     // TORv2\n@@ -252,6 +257,7 @@ BOOST_AUTO_TEST_CASE(cnetaddr_basic)\n     BOOST_REQUIRE(addr.IsTor());\n \n     BOOST_CHECK(!addr.IsBindAny());\n+    BOOST_CHECK(addr.IsAddrV1Compatible());\n     BOOST_CHECK_EQUAL(addr.ToString(), \"6hzph5hv6337r6p2.onion\");\n \n     // TORv3\n@@ -261,6 +267,7 @@ BOOST_AUTO_TEST_CASE(cnetaddr_basic)\n     BOOST_REQUIRE(addr.IsTor());\n \n     BOOST_CHECK(!addr.IsBindAny());\n+    BOOST_CHECK(!addr.IsAddrV1Compatible());\n     BOOST_CHECK_EQUAL(addr.ToString(), torv3_addr);\n \n     // TORv3, broken, with wrong checksum\n@@ -285,6 +292,7 @@ BOOST_AUTO_TEST_CASE(cnetaddr_basic)\n     BOOST_REQUIRE(addr.IsInternal());\n \n     BOOST_CHECK(!addr.IsBindAny());\n+    BOOST_CHECK(addr.IsAddrV1Compatible());\n     BOOST_CHECK_EQUAL(addr.ToString(), \"esffpvrt3wpeaygy.internal\");\n \n     // Totally bogus\n@@ -379,6 +387,7 @@ BOOST_AUTO_TEST_CASE(cnetaddr_unserialize_v2)\n     s >> addr;\n     BOOST_CHECK(addr.IsValid());\n     BOOST_CHECK(addr.IsIPv4());\n+    BOOST_CHECK(addr.IsAddrV1Compatible());\n     BOOST_CHECK_EQUAL(addr.ToString(), \"1.2.3.4\");\n     BOOST_REQUIRE(s.empty());\n \n@@ -415,6 +424,7 @@ BOOST_AUTO_TEST_CASE(cnetaddr_unserialize_v2)\n     s >> addr;\n     BOOST_CHECK(addr.IsValid());\n     BOOST_CHECK(addr.IsIPv6());\n+    BOOST_CHECK(addr.IsAddrV1Compatible());\n     BOOST_CHECK_EQUAL(addr.ToString(), \"102:304:506:708:90a:b0c:d0e:f10\");\n     BOOST_REQUIRE(s.empty());\n \n@@ -426,6 +436,7 @@ BOOST_AUTO_TEST_CASE(cnetaddr_unserialize_v2)\n                                               // sha256(name)[0:10]\n     s >> addr;\n     BOOST_CHECK(addr.IsInternal());\n+    BOOST_CHECK(addr.IsAddrV1Compatible());\n     BOOST_CHECK_EQUAL(addr.ToString(), \"zklycewkdo64v6wc.internal\");\n     BOOST_REQUIRE(s.empty());\n \n@@ -461,6 +472,7 @@ BOOST_AUTO_TEST_CASE(cnetaddr_unserialize_v2)\n     s >> addr;\n     BOOST_CHECK(addr.IsValid());\n     BOOST_CHECK(addr.IsTor());\n+    BOOST_CHECK(addr.IsAddrV1Compatible());\n     BOOST_CHECK_EQUAL(addr.ToString(), \"6hzph5hv6337r6p2.onion\");\n     BOOST_REQUIRE(s.empty());\n \n@@ -482,6 +494,7 @@ BOOST_AUTO_TEST_CASE(cnetaddr_unserialize_v2)\n     s >> addr;\n     BOOST_CHECK(addr.IsValid());\n     BOOST_CHECK(addr.IsTor());\n+    BOOST_CHECK(!addr.IsAddrV1Compatible());\n     BOOST_CHECK_EQUAL(addr.ToString(),\n                       \"pg6mmjiyjmcrsslvykfwnntlaru7p5svn6y2ymmju6nubxndf4pscryd.onion\");\n     BOOST_REQUIRE(s.empty());\n@@ -503,6 +516,8 @@ BOOST_AUTO_TEST_CASE(cnetaddr_unserialize_v2)\n                            \"f98232ae42d4b6fd2fa81952dfe36a87\"));\n     s >> addr;\n     BOOST_CHECK(addr.IsValid());\n+    BOOST_CHECK(addr.IsI2P());\n+    BOOST_CHECK(!addr.IsAddrV1Compatible());\n     BOOST_CHECK_EQUAL(addr.ToString(),\n                       \"ukeu3k5oycgaauneqgtnvselmt4yemvoilkln7jpvamvfx7dnkdq.b32.i2p\");\n     BOOST_REQUIRE(s.empty());\n@@ -524,6 +539,8 @@ BOOST_AUTO_TEST_CASE(cnetaddr_unserialize_v2)\n                            ));\n     s >> addr;\n     BOOST_CHECK(addr.IsValid());\n+    BOOST_CHECK(addr.IsCJDNS());\n+    BOOST_CHECK(!addr.IsAddrV1Compatible());\n     BOOST_CHECK_EQUAL(addr.ToString(), \"fc00:1:2:3:4:5:6:7\");\n     BOOST_REQUIRE(s.empty());\n "
      },
      {
        "sha": "23ce3e5d045b6c4971022f6ba5f9ec1b7c44c51c",
        "filename": "test/functional/p2p_addrv2_relay.py",
        "status": "added",
        "additions": 79,
        "deletions": 0,
        "changes": 79,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/353a3fdaad055eea42a0baf7326bdd591f541170/test/functional/p2p_addrv2_relay.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/353a3fdaad055eea42a0baf7326bdd591f541170/test/functional/p2p_addrv2_relay.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_addrv2_relay.py?ref=353a3fdaad055eea42a0baf7326bdd591f541170",
        "patch": "@@ -0,0 +1,79 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2020 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"\n+Test addrv2 relay\n+\"\"\"\n+\n+import time\n+\n+from test_framework.messages import (\n+    CAddress,\n+    msg_addrv2,\n+    NODE_NETWORK,\n+    NODE_WITNESS,\n+)\n+from test_framework.p2p import P2PInterface\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_equal\n+\n+ADDRS = []\n+for i in range(10):\n+    addr = CAddress()\n+    addr.time = int(time.time()) + i\n+    addr.nServices = NODE_NETWORK | NODE_WITNESS\n+    addr.ip = \"123.123.123.{}\".format(i % 256)\n+    addr.port = 8333 + i\n+    ADDRS.append(addr)\n+\n+\n+class AddrReceiver(P2PInterface):\n+    addrv2_received_and_checked = False\n+\n+    def __init__(self):\n+        super().__init__(support_addrv2 = True)\n+\n+    def on_addrv2(self, message):\n+        for addr in message.addrs:\n+            assert_equal(addr.nServices, 9)\n+            assert addr.ip.startswith('123.123.123.')\n+            assert (8333 <= addr.port < 8343)\n+        self.addrv2_received_and_checked = True\n+\n+    def wait_for_addrv2(self):\n+        self.wait_until(lambda: \"addrv2\" in self.last_message)\n+\n+\n+class AddrTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 1\n+\n+    def run_test(self):\n+        self.log.info('Create connection that sends addrv2 messages')\n+        addr_source = self.nodes[0].add_p2p_connection(P2PInterface())\n+        msg = msg_addrv2()\n+\n+        self.log.info('Send too-large addrv2 message')\n+        msg.addrs = ADDRS * 101\n+        with self.nodes[0].assert_debug_log(['addrv2 message size = 1010']):\n+            addr_source.send_and_ping(msg)\n+\n+        self.log.info('Check that addrv2 message content is relayed and added to addrman')\n+        addr_receiver = self.nodes[0].add_p2p_connection(AddrReceiver())\n+        msg.addrs = ADDRS\n+        with self.nodes[0].assert_debug_log([\n+                'Added 10 addresses from 127.0.0.1: 0 tried',\n+                'received: addrv2 (131 bytes) peer=0',\n+                'sending addrv2 (131 bytes) peer=1',\n+        ]):\n+            addr_source.send_and_ping(msg)\n+            self.nodes[0].setmocktime(int(time.time()) + 30 * 60)\n+            addr_receiver.wait_for_addrv2()\n+\n+        assert addr_receiver.addrv2_received_and_checked\n+\n+\n+if __name__ == '__main__':\n+    AddrTest().main()"
      },
      {
        "sha": "db72a361d98089eabc925d6a2d46725f56f2c0f8",
        "filename": "test/functional/p2p_invalid_messages.py",
        "status": "modified",
        "additions": 94,
        "deletions": 1,
        "changes": 95,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/353a3fdaad055eea42a0baf7326bdd591f541170/test/functional/p2p_invalid_messages.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/353a3fdaad055eea42a0baf7326bdd591f541170/test/functional/p2p_invalid_messages.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_invalid_messages.py?ref=353a3fdaad055eea42a0baf7326bdd591f541170",
        "patch": "@@ -4,6 +4,9 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test node responses to invalid network messages.\"\"\"\n \n+import struct\n+import time\n+\n from test_framework.messages import (\n     CBlockHeader,\n     CInv,\n@@ -22,7 +25,10 @@\n     P2PInterface,\n )\n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import assert_equal\n+from test_framework.util import (\n+    assert_equal,\n+    hex_str_to_bytes,\n+)\n \n VALID_DATA_LIMIT = MAX_PROTOCOL_MESSAGE_LENGTH - 5  # Account for the 5-byte length prefix\n \n@@ -42,6 +48,11 @@ def __repr__(self):\n         return \"{}(data={})\".format(self.msgtype, self.str_data)\n \n \n+class SenderOfAddrV2(P2PInterface):\n+    def wait_for_sendaddrv2(self):\n+        self.wait_until(lambda: 'sendaddrv2' in self.last_message)\n+\n+\n class InvalidMessagesTest(BitcoinTestFramework):\n     def set_test_params(self):\n         self.num_nodes = 1\n@@ -53,6 +64,10 @@ def run_test(self):\n         self.test_checksum()\n         self.test_size()\n         self.test_msgtype()\n+        self.test_addrv2_empty()\n+        self.test_addrv2_no_addresses()\n+        self.test_addrv2_too_long_address()\n+        self.test_addrv2_unrecognized_network()\n         self.test_oversized_inv_msg()\n         self.test_oversized_getdata_msg()\n         self.test_oversized_headers_msg()\n@@ -127,6 +142,84 @@ def test_msgtype(self):\n         assert_equal(self.nodes[0].getpeerinfo()[0]['bytesrecv_per_msg']['*other*'], 26)\n         self.nodes[0].disconnect_p2ps()\n \n+    def test_addrv2(self, label, required_log_messages, raw_addrv2):\n+        node = self.nodes[0]\n+        conn = node.add_p2p_connection(SenderOfAddrV2())\n+\n+        # Make sure bitcoind signals support for ADDRv2, otherwise this test\n+        # will bombard an old node with messages it does not recognize which\n+        # will produce unexpected results.\n+        conn.wait_for_sendaddrv2()\n+\n+        self.log.info('Test addrv2: ' + label)\n+\n+        msg = msg_unrecognized(str_data=b'')\n+        msg.msgtype = b'addrv2'\n+        with node.assert_debug_log(required_log_messages):\n+            # override serialize() which would include the length of the data\n+            msg.serialize = lambda: raw_addrv2\n+            conn.send_raw_message(conn.build_message(msg))\n+            conn.sync_with_ping()\n+\n+        node.disconnect_p2ps()\n+\n+    def test_addrv2_empty(self):\n+        self.test_addrv2('empty',\n+            [\n+                'received: addrv2 (0 bytes)',\n+                'ProcessMessages(addrv2, 0 bytes): Exception',\n+                'end of data',\n+            ],\n+            b'')\n+\n+    def test_addrv2_no_addresses(self):\n+        self.test_addrv2('no addresses',\n+            [\n+                'received: addrv2 (1 bytes)',\n+            ],\n+            hex_str_to_bytes('00'))\n+\n+    def test_addrv2_too_long_address(self):\n+        self.test_addrv2('too long address',\n+            [\n+                'received: addrv2 (525 bytes)',\n+                'ProcessMessages(addrv2, 525 bytes): Exception',\n+                'Address too long: 513 > 512',\n+            ],\n+            hex_str_to_bytes(\n+                '01' +       # number of entries\n+                '61bc6649' + # time, Fri Jan  9 02:54:25 UTC 2009\n+                '00' +       # service flags, COMPACTSIZE(NODE_NONE)\n+                '01' +       # network type (IPv4)\n+                'fd0102' +   # address length (COMPACTSIZE(513))\n+                'ab' * 513 + # address\n+                '208d'))     # port\n+\n+    def test_addrv2_unrecognized_network(self):\n+        now_hex = struct.pack('<I', int(time.time())).hex()\n+        self.test_addrv2('unrecognized network',\n+            [\n+                'received: addrv2 (25 bytes)',\n+                'IP 9.9.9.9 mapped',\n+                'Added 1 addresses',\n+            ],\n+            hex_str_to_bytes(\n+                '02' +     # number of entries\n+                # this should be ignored without impeding acceptance of subsequent ones\n+                now_hex +  # time\n+                '01' +     # service flags, COMPACTSIZE(NODE_NETWORK)\n+                '99' +     # network type (unrecognized)\n+                '02' +     # address length (COMPACTSIZE(2))\n+                'ab' * 2 + # address\n+                '208d' +   # port\n+                # this should be added:\n+                now_hex +  # time\n+                '01' +     # service flags, COMPACTSIZE(NODE_NETWORK)\n+                '01' +     # network type (IPv4)\n+                '04' +     # address length (COMPACTSIZE(4))\n+                '09' * 4 + # address\n+                '208d'))   # port\n+\n     def test_oversized_msg(self, msg, size):\n         msg_type = msg.msgtype.decode('ascii')\n         self.log.info(\"Test {} message of size {} is logged as misbehaving\".format(msg_type, size))"
      },
      {
        "sha": "ff7f73bdf4c6ee11bb3d8b7e77feafbf80d4b532",
        "filename": "test/functional/test_framework/messages.py",
        "status": "modified",
        "additions": 93,
        "deletions": 10,
        "changes": 103,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/353a3fdaad055eea42a0baf7326bdd591f541170/test/functional/test_framework/messages.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/353a3fdaad055eea42a0baf7326bdd591f541170/test/functional/test_framework/messages.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/messages.py?ref=353a3fdaad055eea42a0baf7326bdd591f541170",
        "patch": "@@ -136,12 +136,17 @@ def uint256_from_compact(c):\n     return v\n \n \n-def deser_vector(f, c):\n+# deser_function_name: Allow for an alternate deserialization function on the\n+# entries in the vector.\n+def deser_vector(f, c, deser_function_name=None):\n     nit = deser_compact_size(f)\n     r = []\n     for _ in range(nit):\n         t = c()\n-        t.deserialize(f)\n+        if deser_function_name:\n+            getattr(t, deser_function_name)(f)\n+        else:\n+            t.deserialize(f)\n         r.append(t)\n     return r\n \n@@ -204,38 +209,82 @@ def ToHex(obj):\n \n \n class CAddress:\n-    __slots__ = (\"ip\", \"nServices\", \"pchReserved\", \"port\", \"time\")\n+    __slots__ = (\"net\", \"ip\", \"nServices\", \"port\", \"time\")\n+\n+    # see https://github.com/bitcoin/bips/blob/master/bip-0155.mediawiki\n+    NET_IPV4 = 1\n+\n+    ADDRV2_NET_NAME = {\n+        NET_IPV4: \"IPv4\"\n+    }\n+\n+    ADDRV2_ADDRESS_LENGTH = {\n+        NET_IPV4: 4\n+    }\n \n     def __init__(self):\n         self.time = 0\n         self.nServices = 1\n-        self.pchReserved = b\"\\x00\" * 10 + b\"\\xff\" * 2\n+        self.net = self.NET_IPV4\n         self.ip = \"0.0.0.0\"\n         self.port = 0\n \n     def deserialize(self, f, *, with_time=True):\n+        \"\"\"Deserialize from addrv1 format (pre-BIP155)\"\"\"\n         if with_time:\n             # VERSION messages serialize CAddress objects without time\n-            self.time = struct.unpack(\"<i\", f.read(4))[0]\n+            self.time = struct.unpack(\"<I\", f.read(4))[0]\n         self.nServices = struct.unpack(\"<Q\", f.read(8))[0]\n-        self.pchReserved = f.read(12)\n+        # We only support IPv4 which means skip 12 bytes and read the next 4 as IPv4 address.\n+        f.read(12)\n+        self.net = self.NET_IPV4\n         self.ip = socket.inet_ntoa(f.read(4))\n         self.port = struct.unpack(\">H\", f.read(2))[0]\n \n     def serialize(self, *, with_time=True):\n+        \"\"\"Serialize in addrv1 format (pre-BIP155)\"\"\"\n+        assert self.net == self.NET_IPV4\n         r = b\"\"\n         if with_time:\n             # VERSION messages serialize CAddress objects without time\n-            r += struct.pack(\"<i\", self.time)\n+            r += struct.pack(\"<I\", self.time)\n         r += struct.pack(\"<Q\", self.nServices)\n-        r += self.pchReserved\n+        r += b\"\\x00\" * 10 + b\"\\xff\" * 2\n+        r += socket.inet_aton(self.ip)\n+        r += struct.pack(\">H\", self.port)\n+        return r\n+\n+    def deserialize_v2(self, f):\n+        \"\"\"Deserialize from addrv2 format (BIP155)\"\"\"\n+        self.time = struct.unpack(\"<I\", f.read(4))[0]\n+\n+        self.nServices = deser_compact_size(f)\n+\n+        self.net = struct.unpack(\"B\", f.read(1))[0]\n+        assert self.net == self.NET_IPV4\n+\n+        address_length = deser_compact_size(f)\n+        assert address_length == self.ADDRV2_ADDRESS_LENGTH[self.net]\n+\n+        self.ip = socket.inet_ntoa(f.read(4))\n+\n+        self.port = struct.unpack(\">H\", f.read(2))[0]\n+\n+    def serialize_v2(self):\n+        \"\"\"Serialize in addrv2 format (BIP155)\"\"\"\n+        assert self.net == self.NET_IPV4\n+        r = b\"\"\n+        r += struct.pack(\"<I\", self.time)\n+        r += ser_compact_size(self.nServices)\n+        r += struct.pack(\"B\", self.net)\n+        r += ser_compact_size(self.ADDRV2_ADDRESS_LENGTH[self.net])\n         r += socket.inet_aton(self.ip)\n         r += struct.pack(\">H\", self.port)\n         return r\n \n     def __repr__(self):\n-        return \"CAddress(nServices=%i ip=%s port=%i)\" % (self.nServices,\n-                                                         self.ip, self.port)\n+        return (\"CAddress(nServices=%i net=%s addr=%s port=%i)\"\n+                % (self.nServices, self.ADDRV2_NET_NAME[self.net], self.ip, self.port))\n \n \n class CInv:\n@@ -1064,6 +1113,40 @@ def __repr__(self):\n         return \"msg_addr(addrs=%s)\" % (repr(self.addrs))\n \n \n+class msg_addrv2:\n+    __slots__ = (\"addrs\",)\n+    msgtype = b\"addrv2\"\n+\n+    def __init__(self):\n+        self.addrs = []\n+\n+    def deserialize(self, f):\n+        self.addrs = deser_vector(f, CAddress, \"deserialize_v2\")\n+\n+    def serialize(self):\n+        return ser_vector(self.addrs, \"serialize_v2\")\n+\n+    def __repr__(self):\n+        return \"msg_addrv2(addrs=%s)\" % (repr(self.addrs))\n+\n+\n+class msg_sendaddrv2:\n+    __slots__ = ()\n+    msgtype = b\"sendaddrv2\"\n+\n+    def __init__(self):\n+        pass\n+\n+    def deserialize(self, f):\n+        pass\n+\n+    def serialize(self):\n+        return b\"\"\n+\n+    def __repr__(self):\n+        return \"msg_sendaddrv2()\"\n+\n+\n class msg_inv:\n     __slots__ = (\"inv\",)\n     msgtype = b\"inv\""
      },
      {
        "sha": "6846d31221b39f34234a4d1bedac93cac6c020de",
        "filename": "test/functional/test_framework/p2p.py",
        "status": "modified",
        "additions": 11,
        "deletions": 1,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/353a3fdaad055eea42a0baf7326bdd591f541170/test/functional/test_framework/p2p.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/353a3fdaad055eea42a0baf7326bdd591f541170/test/functional/test_framework/p2p.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/p2p.py?ref=353a3fdaad055eea42a0baf7326bdd591f541170",
        "patch": "@@ -33,6 +33,7 @@\n     MAX_HEADERS_RESULTS,\n     MIN_VERSION_SUPPORTED,\n     msg_addr,\n+    msg_addrv2,\n     msg_block,\n     MSG_BLOCK,\n     msg_blocktxn,\n@@ -56,6 +57,7 @@\n     msg_notfound,\n     msg_ping,\n     msg_pong,\n+    msg_sendaddrv2,\n     msg_sendcmpct,\n     msg_sendheaders,\n     msg_tx,\n@@ -75,6 +77,7 @@\n \n MESSAGEMAP = {\n     b\"addr\": msg_addr,\n+    b\"addrv2\": msg_addrv2,\n     b\"block\": msg_block,\n     b\"blocktxn\": msg_blocktxn,\n     b\"cfcheckpt\": msg_cfcheckpt,\n@@ -97,6 +100,7 @@\n     b\"notfound\": msg_notfound,\n     b\"ping\": msg_ping,\n     b\"pong\": msg_pong,\n+    b\"sendaddrv2\": msg_sendaddrv2,\n     b\"sendcmpct\": msg_sendcmpct,\n     b\"sendheaders\": msg_sendheaders,\n     b\"tx\": msg_tx,\n@@ -285,7 +289,7 @@ class P2PInterface(P2PConnection):\n \n     Individual testcases should subclass this and override the on_* methods\n     if they want to alter message handling behaviour.\"\"\"\n-    def __init__(self):\n+    def __init__(self, support_addrv2=False):\n         super().__init__()\n \n         # Track number of messages of each type received.\n@@ -303,6 +307,8 @@ def __init__(self):\n         # The network services received from the peer\n         self.nServices = 0\n \n+        self.support_addrv2 = support_addrv2\n+\n     def peer_connect(self, *args, services=NODE_NETWORK|NODE_WITNESS, send_version=True, **kwargs):\n         create_conn = super().peer_connect(*args, **kwargs)\n \n@@ -345,6 +351,7 @@ def on_close(self):\n         pass\n \n     def on_addr(self, message): pass\n+    def on_addrv2(self, message): pass\n     def on_block(self, message): pass\n     def on_blocktxn(self, message): pass\n     def on_cfcheckpt(self, message): pass\n@@ -365,6 +372,7 @@ def on_mempool(self, message): pass\n     def on_merkleblock(self, message): pass\n     def on_notfound(self, message): pass\n     def on_pong(self, message): pass\n+    def on_sendaddrv2(self, message): pass\n     def on_sendcmpct(self, message): pass\n     def on_sendheaders(self, message): pass\n     def on_tx(self, message): pass\n@@ -389,6 +397,8 @@ def on_version(self, message):\n         if message.nVersion >= 70016:\n             self.send_message(msg_wtxidrelay())\n         self.send_message(msg_verack())\n+        if self.support_addrv2:\n+            self.send_message(msg_sendaddrv2())\n         self.nServices = message.nServices\n \n     # Connection helper methods"
      },
      {
        "sha": "ba32f6406590789d29fe2087361f4c9b8c9308e7",
        "filename": "test/functional/test_runner.py",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/353a3fdaad055eea42a0baf7326bdd591f541170/test/functional/test_runner.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/353a3fdaad055eea42a0baf7326bdd591f541170/test/functional/test_runner.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_runner.py?ref=353a3fdaad055eea42a0baf7326bdd591f541170",
        "patch": "@@ -154,6 +154,7 @@\n     'feature_proxy.py',\n     'rpc_signrawtransaction.py',\n     'wallet_groups.py',\n+    'p2p_addrv2_relay.py',\n     'p2p_disconnect_ban.py',\n     'rpc_decodescript.py',\n     'rpc_blockchain.py',"
      }
    ]
  },
  {
    "sha": "dcf0cb477699d11afd0ff37c8bfb2b1b4f7f1ee5",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkY2YwY2I0Nzc2OTlkMTFhZmQwZmYzN2M4YmZiMmIxYjRmN2YxZWU1",
    "commit": {
      "author": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2020-09-14T12:30:15Z"
      },
      "committer": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2020-10-09T14:42:50Z"
      },
      "message": "tor: make a TORv3 hidden service instead of TORv2\n\nTORv2 is deprecated [1], thus whenever we create the hidden service\nourselves create a TORv3 one instead.\n\n[1] https://blog.torproject.org/v2-deprecation-timeline",
      "tree": {
        "sha": "0aa35085ba830cf29850697bf93dc85953a53217",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0aa35085ba830cf29850697bf93dc85953a53217"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/dcf0cb477699d11afd0ff37c8bfb2b1b4f7f1ee5",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQQzBAABCAAdFiEE5k2NRWFNsHVF2czBVN8G9ktVy78FAl+AduoACgkQVN8G9ktV\ny78LRB/+OJziNSr7y0l6wbAE4LQUwgK1VIvWdKKv84hM4xJ+YJn9/lwu3w3Su+Em\nRUsIsrq4jl25qz7S3TBvuDa1qQ6vXtgPE97G8Hx2jwrVRoU7ue6DX6h5WJZL/qvs\nH35tj04fGiwlanKF4AqBjUa3+1SGHCpFK0WGm8I9zPwQCGti+D94YT/lIrXap2ZX\nnSFqa1FYW4cibZ34YD/xvwnuk18Jcbdvr8FyLlU+dNyKKrmWElD5mWTwwB1KdZ1N\nN9CN2GDahvx8fmdauraSmGsvoqSOQTaIsZCcPbL5dIVkmrzdK8eZeD9n4IpY5a/p\nDFGYoEFmAFcKjcWcV4/54kYVvDIK0kNnH+jCFjPmJp3nLfkXvLtUOS/b73tyi/4M\nKiEXCPB1K6Zk2f148tDaA6s4RLZIauk44Y4L0zAp8eAJ7o+PP7pK5SzdRl9/ROy0\nisz3LTFtgNWWgqe5hJPWBQXcn+VOOjS4ggdaeeXQA4ohlwhDA4yLhqrBSXrmeewP\nq/s6LL8nljw+LWdeQHR64KscRMudsZAh4/VMWXDJsafGO3UhBaM1bJB8QfCv6jVp\nAfOO2dQYMAI+w+1HbNWmaKtH/QM/RgvYhfHyQoJYFb08vo8YT1L9no24sMEq2RYk\nYv2KnRySHF/bdlHQ5WnhGFH5qANWaJ+rY0cwGKwG1mbpoFVj6NYKoISqlyaJJGDS\n0Gty/MkXR/J+1g9P4Yl3yH47d7Mktdotj0RAyrx1mwP2n8RlWGpQpPau3G/1aTYX\nkVCoMnKXvBPHkXlHVL6UiHTLFBqNaVTs7aoB/kugWHQMt5aLDfhu0ylkabSCXVR+\nmagi+VwXPnUQkrUiOPcGz2UxeIpdxKeKoQ0PdGK1KYEK4ucFX66q+benuHtu/I4m\nTW3sXp01OfZ5NGHkLm3gmIjNSwgMn9gJvaw7rn7y/8m0y3mmd870pw4enobhnSZl\nZFLwyQv0cDZz7wdIXa4k26rhT7upWZePGTMHmZ3tj5Ikwt+dhNvdPcgLZVtCl2vt\n0XEnExOxPSntNKRKaS9ct0gpSCoduVfORA3i6Y/FonBoowiN38ePCvOpZkID3iUm\nsiaxXFJFzRMIvMxzL5lh+u1z2WuYcRqf91Se6ea3dSHb2PUQJvwYKGtDgzE4oxK2\nVjwusnpfCEJGDDsr5EwKKSSJMSZxvks0bSJ4Xf8ZQWExim1ww0H3AMJztdi1KsSN\nJ4V06SGyQNv0zExE4P1in4FhXZn1R5FN47leAYXWmxjghZ98urjYXac/42rgLuxC\nPrAdceTeMjt4sauzrWht/N0DcHMZ6ypcfu0qQYYfjhAWKxksV7s47oY/sKunPRZd\naGY+HggWxuKxJbVsCGzv92ZnwesixA==\n=2XFG\n-----END PGP SIGNATURE-----",
        "payload": "tree 0aa35085ba830cf29850697bf93dc85953a53217\nparent 353a3fdaad055eea42a0baf7326bdd591f541170\nauthor Vasil Dimov <vd@FreeBSD.org> 1600086615 +0200\ncommitter Vasil Dimov <vd@FreeBSD.org> 1602254570 +0200\n\ntor: make a TORv3 hidden service instead of TORv2\n\nTORv2 is deprecated [1], thus whenever we create the hidden service\nourselves create a TORv3 one instead.\n\n[1] https://blog.torproject.org/v2-deprecation-timeline\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dcf0cb477699d11afd0ff37c8bfb2b1b4f7f1ee5",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/dcf0cb477699d11afd0ff37c8bfb2b1b4f7f1ee5",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/dcf0cb477699d11afd0ff37c8bfb2b1b4f7f1ee5/comments",
    "author": {
      "login": "vasild",
      "id": 266751,
      "node_id": "MDQ6VXNlcjI2Njc1MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vasild",
      "html_url": "https://github.com/vasild",
      "followers_url": "https://api.github.com/users/vasild/followers",
      "following_url": "https://api.github.com/users/vasild/following{/other_user}",
      "gists_url": "https://api.github.com/users/vasild/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vasild/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
      "organizations_url": "https://api.github.com/users/vasild/orgs",
      "repos_url": "https://api.github.com/users/vasild/repos",
      "events_url": "https://api.github.com/users/vasild/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vasild/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "vasild",
      "id": 266751,
      "node_id": "MDQ6VXNlcjI2Njc1MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vasild",
      "html_url": "https://github.com/vasild",
      "followers_url": "https://api.github.com/users/vasild/followers",
      "following_url": "https://api.github.com/users/vasild/following{/other_user}",
      "gists_url": "https://api.github.com/users/vasild/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vasild/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
      "organizations_url": "https://api.github.com/users/vasild/orgs",
      "repos_url": "https://api.github.com/users/vasild/repos",
      "events_url": "https://api.github.com/users/vasild/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vasild/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "353a3fdaad055eea42a0baf7326bdd591f541170",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/353a3fdaad055eea42a0baf7326bdd591f541170",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/353a3fdaad055eea42a0baf7326bdd591f541170"
      }
    ],
    "stats": {
      "total": 21,
      "additions": 17,
      "deletions": 4
    },
    "files": [
      {
        "sha": "e52b3a972efc9867519a2ca651dde7caada1159c",
        "filename": "doc/files.md",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dcf0cb477699d11afd0ff37c8bfb2b1b4f7f1ee5/doc/files.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dcf0cb477699d11afd0ff37c8bfb2b1b4f7f1ee5/doc/files.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/files.md?ref=dcf0cb477699d11afd0ff37c8bfb2b1b4f7f1ee5",
        "patch": "@@ -56,7 +56,7 @@ Subdirectory       | File(s)               | Description\n `./`               | `fee_estimates.dat`   | Stores statistics used to estimate minimum transaction fees and priorities required for confirmation\n `./`               | `guisettings.ini.bak` | Backup of former [GUI settings](#gui-settings) after `-resetguisettings` option is used\n `./`               | `mempool.dat`         | Dump of the mempool's transactions\n-`./`               | `onion_private_key`   | Cached Tor onion service private key for `-listenonion` option\n+`./`               | `onion_v3_private_key` | Cached Tor onion service private key for `-listenonion` option\n `./`               | `peers.dat`           | Peer IP address database (custom format)\n `./`               | `settings.json`       | Read-write settings set through GUI or RPC interfaces, augmenting manual settings from [bitcoin.conf](bitcoin-conf.md). File is created automatically if read-write settings storage is not disabled with `-nosettings` option. Path can be specified with `-settings` option\n `./`               | `.cookie`             | Session RPC authentication cookie; if used, created at start and deleted on shutdown; can be specified by `-rpccookiefile` option\n@@ -98,6 +98,7 @@ Path           | Description | Repository notes\n `blkindex.dat` | Blockchain index BDB database; replaced by {`chainstate/`, `blocks/index/`, `blocks/revNNNNN.dat`<sup>[\\[2\\]](#note2)</sup>} in 0.8.0 | [PR #1677](https://github.com/bitcoin/bitcoin/pull/1677)\n `blk000?.dat`  | Block data (custom format, 2 GiB per file); replaced by `blocks/blkNNNNN.dat`<sup>[\\[2\\]](#note2)</sup> in 0.8.0 | [PR #1677](https://github.com/bitcoin/bitcoin/pull/1677)\n `addr.dat`     | Peer IP address BDB database; replaced by `peers.dat` in [0.7.0](https://github.com/bitcoin/bitcoin/blob/master/doc/release-notes/release-notes-0.7.0.md) | [PR #1198](https://github.com/bitcoin/bitcoin/pull/1198), [`928d3a01`](https://github.com/bitcoin/bitcoin/commit/928d3a011cc66c7f907c4d053f674ea77dc611cc)\n+`onion_private_key` | Cached Tor onion service private key for `-listenonion` option. Was used for Tor v2 services; replaced by `onion_v3_private_key` in [0.21.0](https://github.com/bitcoin/bitcoin/blob/master/doc/release-notes/release-notes-0.21.0.md) | [PR #19954](https://github.com/bitcoin/bitcoin/pull/19954)\n \n ## Notes\n "
      },
      {
        "sha": "16a9184b653126fe60e1254c92fcd4f7bd98bffb",
        "filename": "doc/release-notes.md",
        "status": "modified",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dcf0cb477699d11afd0ff37c8bfb2b1b4f7f1ee5/doc/release-notes.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dcf0cb477699d11afd0ff37c8bfb2b1b4f7f1ee5/doc/release-notes.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes.md?ref=dcf0cb477699d11afd0ff37c8bfb2b1b4f7f1ee5",
        "patch": "@@ -82,6 +82,17 @@ P2P and network changes\n   node using P2P relay. This version reduces the initial broadcast guarantees\n   for wallet transactions submitted via P2P to a node running the wallet. (#18038)\n \n+- The Tor onion service that is automatically created by setting the\n+  `-listenonion` configuration parameter will now be created as a Tor v3 service\n+  instead of Tor v2. The private key that was used for Tor v2 (if any) will be\n+  left untouched in the `onion_private_key` file in the data directory (see\n+  `-datadir`) and can be removed if not needed. Bitcoin Core will no longer\n+  attempt to read it. The private key for the Tor v3 service will be saved in a\n+  file named `onion_v3_private_key`. To use the deprecated Tor v2 service (not\n+  recommended), then `onion_private_key` can be copied over\n+  `onion_v3_private_key`, e.g.\n+  `cp -f onion_private_key onion_v3_private_key`. (#19954)\n+\n Updated RPCs\n ------------\n "
      },
      {
        "sha": "e25d4ce2b85b156ae544024051ab71abe7d1f7e4",
        "filename": "src/torcontrol.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/dcf0cb477699d11afd0ff37c8bfb2b1b4f7f1ee5/src/torcontrol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/dcf0cb477699d11afd0ff37c8bfb2b1b4f7f1ee5/src/torcontrol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/torcontrol.cpp?ref=dcf0cb477699d11afd0ff37c8bfb2b1b4f7f1ee5",
        "patch": "@@ -532,8 +532,9 @@ void TorController::auth_cb(TorControlConnection& _conn, const TorControlReply&\n         }\n \n         // Finally - now create the service\n-        if (private_key.empty()) // No private key, generate one\n-            private_key = \"NEW:RSA1024\"; // Explicitly request RSA1024 - see issue #9214\n+        if (private_key.empty()) { // No private key, generate one\n+            private_key = \"NEW:ED25519-V3\"; // Explicitly request key type - see issue #9214\n+        }\n         // Request onion service, redirect port.\n         // Note that the 'virtual' port is always the default port to avoid decloaking nodes using other ports.\n         _conn.Command(strprintf(\"ADD_ONION %s Port=%i,127.0.0.1:%i\", private_key, Params().GetDefaultPort(), GetListenPort()),\n@@ -718,7 +719,7 @@ void TorController::Reconnect()\n \n fs::path TorController::GetPrivateKeyFile()\n {\n-    return GetDataDir() / \"onion_private_key\";\n+    return GetDataDir() / \"onion_v3_private_key\";\n }\n \n void TorController::reconnect_cb(evutil_socket_t fd, short what, void *arg)"
      }
    ]
  }
]